/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  * Platform: 	MACINTOSH 	X *				WINDOWS		 *------------------------------------------------------------------------------ */#include "VTypes.h"#include "AppDeflt.h"#include "AppFiles.h"#include "WalkBuff.h"#include "Unit.h"#include "RuleItem.h"#include "Light.h"#include "AppText.h"#include "PopColor.h"#include "VDialog.h"#include "VFile.h"#include "VgerFile.h"#include "VGraphic.h"#include "VGUtil.h"#include "VWindow.h"#include "VError.h"#include "Misc.h"#include "VMath.h"#include "VTextDef.h"#include "WHandle.h"#include "VDocumnt.h"#include "VMemUtil.h"#if USE_HMD#include "HMD.h"		// ABD HMD MAR95#endif // USE_HMD#include <string.h>#define SameColor(c1,c2) (((c1.red == c2.red)&&(c1.green == c2.green)&&(c1.blue == c2.blue))?1:0)#define WINDOW_DIFFERENT	0x01RGBColor	appDesignColor = { 0xFFFF, 0xFFFF, 0xFFFF };RGBColor	appGridColor = { 0x544F, 0xC69C, 0xFFFF };RGBColor	appRulerColor = { 0x0000, 0x0000, 0x0000 };RGBColor	appRangeColor ={ 0xC000, 0xC000, 0xC000 };RGBColor	appHomeColor ={ 0x6E14, 0x5484, 0xFFFF };RGBColor	appGuideColor ={ 0xB5C3, 0x0000, 0xFFFF };RGBColor	appBackColor ={ 0xC000, 0xC000, 0xC000 };RGBColor	appColor = { 0xFFFF, 0xFFFF, 0xFFFF };RGBColor	appSkyColor = { 0x4D5F , 0xD83B , 0xFFF6 };RGBColor	vColorSlateL = { 0xDEB8, 0xDEB8, 0xDEB8 };RGBColor	vColorSlateM = { 0xBAE1, 0xBAE1, 0xBAE1 };RGBColor	vColorSlateD = { 0x87AE, 0x87AE, 0x87AE };RGBColor	vColorSlateLine = { 0x451F, 0x451F, 0x451F };Point3DFFixed defBoundMin = { INITFIXXED(-300,0x0000) , INITFIXXED(-300,0x0000) , INITFIXXED(-300,0x0000)  } ;Point3DFFixed defBoundMax = { INITFIXXED(300,0x0000) , INITFIXXED(300,0x0000), INITFIXXED(300,0x0000)  } ;Point3DFFixed	appHomePosition = { INITFIXXED(0,0x0000) , INITFIXXED(0,0x0000) , INITFIXXED(66,0x0000) };FFixed	appViewHeight = INITFIXXED(5,0x0000);FFixed	appBViewHeight = INITFIXXED(50,0x0000);FFixed	appEViewHeight = INITFIXXED(66,0x0000);FFixed	appMMViewHeight = INITFIXXED(1000,0x0000);FFixed	appCMViewHeight = INITFIXXED(100,0x0000);FFixed	appExtrusionHeight= INITFIXXED(10,0x0000);FFixed	appBExtrusionHeight = INITFIXXED(100,0x0000);FFixed	appEExtrusionHeight = INITFIXXED(96,0x0000);FFixed	appMMExtrusionHeight = INITFIXXED(2500,0x0000);FFixed	appCMExtrusionHeight = INITFIXXED(250,0x0000);char	*appLayerName = TXTD_UNNAMED;char	*appObjectName = TXTD_UNNAMED;char	*appObjectDesc = TXT_EMPTYSTRING;short	appDefaultSides = 16;short	appDefaultLevels = 5;short	appTrackState = positionView;/* THIS NEEDS A DEFINE FOR WORLD AND SCREEN */// DAS-VR 8/24/93#if VWT#if VRML_ANCHOR // ABD PRO25 AUG95long appDesignDefaults = RULER_DISPLAY|TAB_DISPLAY|GRID_DISPLAY|RULER_SNAP|ORIGIN_DISPLAY|GUIDE_DISPLAY|URL_DISPLAY;#elselong appDesignDefaults = RULER_DISPLAY|TAB_DISPLAY|GRID_DISPLAY|RULER_SNAP|ORIGIN_DISPLAY|GUIDE_DISPLAY;#endiflong appRenderDrawMode = RENDER_FILL|RENDER_FRAME;#elif VR#if VRML_ANCHOR // ABD PRO25 AUG95long appDesignDefaults = RULER_DISPLAY|GRID_DISPLAY|RULER_SNAP|URL_DISPLAY;#elselong appDesignDefaults = RULER_DISPLAY|GRID_DISPLAY|RULER_SNAP;#endiflong appRenderDrawMode = RENDER_FILL|RENDER_FRAME;#endiflong appRenderShadeMode = RENDER_FLATSH;long appRenderOpenMode = RENDER_SEEIN|RENDER_SEEOUT|RENDER_SEECONN;double	appNavSensitivity = 1.0000;double	appNavMagnitude  = 1.0000;#if VWTlong	appNavigateMode = NAVIG_BUTTON|NAVIG_CROSS;#elif VRlong	appNavigateMode = NAVIG_BUTTON|NAVIG_CROSS; // BILBIL should be |NAVIG_COLLISION#endif //VWTPoint	appAspectRatio = { 133, 100 };// This will probably turn into #if ENGLISH, but now with just two// languages, I'm still ENGLISH-centric.// jca 14MAR95 we're now up to 3 lanuguages, so I'm not ENGLISH-centric// at all.#if ENGLISH && INCHESint	appUnitSystem	= unitInch;double appUnitSize	= SI_INCH;#elseint	appUnitSystem	= unitCentimeter;double appUnitSize	= SI_CENTIMETER;#endif //JAPANESEint	appFocalLength	= 35;int	appFilmWidth	= 36;#define MAX_WORLD_UNITS	65536.0double	appUnitBaseSize = 1.0000;double	appCustomSize  = 1.0000;char	*appCustomName = TXTD_CUSTOM;char	*appCustomSym = TXTD_CUSTOMSYM;Rect	appDefaultEditorRect	= InitRect(34,12,285,400);Rect	appDefaultViewRect	= InitRect(42 , 12 , 285 , 400);Rect	appDefaultToolRect	= InitRect(42 , 12 , 285 , 87);long appDelayTime = WAITTIME(250);short	appDefaultEditorType	= PREF_VIEW_TOP;FFixed	appScale = INITFIXXED(0,0x8000);long	appEventTypes	= EVENT_COLLIDE|EVENT_POSITION;char	appEventResolve= FALSE;Point3DFFixed topViewVector = { INITFIXXED(0,0x0000) , INITFIXXED(0,0x0000) , INITFIXXED(1,0x0000) };Point3DFFixed bottomViewVector = { INITFIXXED(0,0x0000), INITFIXXED(0,0x0000) , INITFIXXED(-1,0x0000) };Point3DFFixed frontViewVector = { INITFIXXED(0,0x0000), INITFIXXED(-1,0x0000) , INITFIXXED(0,0x0000) };Point3DFFixed backViewVector = { INITFIXXED(0,0x0000) , INITFIXXED(1,0x0000) , INITFIXXED(0,0x0000) };Point3DFFixed leftViewVector = { INITFIXXED(-1,0x0000) , INITFIXXED(0,0x0000) , INITFIXXED(0,0x0000) };Point3DFFixed rightViewVector = { INITFIXXED(1,0x0000) , INITFIXXED(0,0x0000) , INITFIXXED(0,0x0000) };Point3DFFixed appLight1Loc = { INITFIXXED(0,0x0000), INITFIXXED(0,0x0000) , INITFIXXED(0,0x0000) };Point3DFFixed appLight2Loc = { INITFIXXED(-34,0x0000) , INITFIXXED(-57,0x0000) , INITFIXXED(247,0x0000) };Point3DFFixed appLight3Loc = { INITFIXXED(209,0x0000) , INITFIXXED(105,0x0000) , INITFIXXED(104,0x0000) };Point3DFFixed appLight4Loc = { INITFIXXED(-5,0x0000) , INITFIXXED(-226,0x0000) , INITFIXXED(-119,0x0000) };RGBColor appLight1Color = { 0x6000 , 0x6000 , 0x6000 };RGBColor appLight2Color = { 0x8000 , 0x8000 , 0x8000 };RGBColor appLight3Color = { 0x7000 , 0x7000 , 0x7000 };RGBColor appLight4Color = { 0x8000 , 0x8000 , 0x8000 };double	GetSIUnit(int flag)	{	double size;	switch(flag)		{		case unitInch:			size = SI_INCH; break;		case unitFoot:			size = SI_FOOT; break;		case unitYard: 			size = SI_YARD;break;		case unitMile:		 	size = SI_MILE;break;		case unitMillimeter:	size = SI_MILLIMETER; break;		case unitCentimeter:	size = SI_CENTIMETER; break;		case unitMeter:			size = SI_METER; break;		case unitKilometer:		size = SI_KILOMETER; break;		case unitPica:			size = SI_PICA; break;		case unitPoint:			size = SI_POINT; break;		case unitAngstrom:		size = SI_ANGSTROM; break;		case unitParsec:		size = SI_PARSEC; break;		case unitCustom:		size = SI_METER; break;		default: 				size = SI_METER; break;		}	return(size);	}void Preference::cPreference() { changeFlag = PREF_NOCHANGE; }void Preference::dPreference() { delete this; }voidPreference::SetName(Handle *name,char *nm)	{	char *namePtr;	*name = NewHandle(strlen(nm) + 1);	HLock((Handle)*name);	namePtr = (char *)HDeref(*name);	strcpy(namePtr, nm);	HUnlock((Handle)*name);	}void Preference::SetChange(int setChange) { changeFlag = setChange; }int  Preference::GetChange() { return changeFlag; }int	 Preference::IO(V_Buffer *buffer) { return FALSE; }int  Preference::IO_PREF(V_Buffer *buffer) { return FALSE; }	void AppPreference::cAppPreference() 	{ 			navigate = new(NavigatePreference);	navigate->cPreference();		render = new(RenderPreference);	render->cPreference();		window = new(WindowPreference);	window->cPreference();	event = new(EventPreference);	event->cPreference();	deflt = new(DefaultPreference);	deflt->cPreference();	#if (!VPLAYER)	editor = new(EditorPreference);	editor->cPreference();		unit = new(UnitPreference);	unit->cPreference();		translator = new(TranslatorPreference);	translator->cPreference();#endif //!VPLAYER	model = new(ModelPreference);	model->cPreference();	configure = new(ConfigurePreference);    configure->cPreference();	// MERGE-HMD [[[	#if USE_HMD	hmd = new(HMDPreference);    hmd->cPreference();	#endif // USE_HMD	// MERGE-HMD ]]]	lastItem = preferEditor;	}void AppPreference::dAppPreference() 	{ 	navigate->dPreference();		render->dPreference();		window->dPreference();	event->dPreference();	deflt->dPreference();	#if (!VPLAYER)	editor->dPreference();		unit->dPreference();		translator->dPreference();#endif //!VPLAYER	model->dPreference();    configure->dPreference();	// MERGE-HMD [[[	#if USE_HMD	hmd->dPreference();	#endif // USE_HMD	// MERGE-HMD ]]]	delete this;	}int AppPreference::MakeDefault(int query) 	{ 	V_File	*file;	int	err;		err = 0;		file = new(V_File);	file->cFile(query,appFileTypePreference,appFileCreator,appFilterDescriptorPrefs,TXTEXTWalkThroughDefs);	err = file->FindSystem();	switch(query)		{		case LOAD:#if (!VPLAYER)			file->SetName(localPreference);			err = file->SetDirectory();			if(noErr == err)            	{				file->SetName(globalWalkThroughPrefs);				err = file->Find();				err = file->Open(TRUE);				if(noErr == err)					err = IO(file);				file->Close();				}#endif //!VPLAYER			LoadConfigure();			break;					case SAVE:#if (!VPLAYER)			file->SetName(localPreference);			err = file->SetDirectory();			if(fileNotFoundErr == err)				{				err = file->MakeDirectory();				err = file->SetDirectory();				}			if(noErr == err) 				{				file->SetName(globalWalkThroughPrefs);				err = file->Open(TRUE);				if(noErr == err)					err = IO(file);				file->Close();				}#endif //!VPLAYER			SaveConfigure();			break;		}		file->dFile();		return err;	}	Preference *AppPreference::GetPreference(short getType)	{ 	Preference	*pref;	switch(getType)		{		case preferNavigate: pref = navigate; break;		case preferRenderer: pref = render; break;		case preferWindows: pref = window; break;		case preferEvents: pref = event; break;		case preferDefaults: pref = deflt; break;#if (!VPLAYER)		case preferEditor: pref = editor; break;		case preferUnits: pref = unit; break;		case preferTranslator: pref = translator; break;#endif //!VPLAYER		case preferModeler: pref = model; break;        case preferConfigure: pref = configure; break;        // MERGE-HMD [[[        #if USE_HMD        case preferHMD: pref = hmd; break;        #endif // USE_HMD        // MERGE-HMD ]]]		default: pref = NULL; break;		}	return pref;	}intAppPreference::IO(V_Buffer *buffer)	{	long id;	int err = 0;	if (buffer->IODirection() == DATA_IN)		{		switch(id = buffer->OpenChunkR())			{			case IFF_FORM:				err = IO_FORM(buffer);				break;			}		if (id != 0) buffer->CloseChunk();		}	else		{		buffer->OpenChunkW(IFF_FORM);		err = IO_FORM(buffer);		buffer->CloseChunk();		}	return(err);	}intAppPreference::IO_FORM(V_Buffer *buffer)	{	long id;	int err = 0;	if (buffer->IODirection() == DATA_IN)		{		err = buffer->IOType(&id, IO_LONG);		if (!err && id == IFF_VPRF)			{			buffer->SetRefCon(0);			while (!err)				{				id = buffer->OpenChunkR();				if (id == 0) break;				switch (id)					{					case IFF_VERS:						err = IO_VERS(buffer);						if (!err && (buffer->GetRefCon() < 0x01000000L ||							buffer->GetRefCon() >= 0x02000000L))							err = 1;						break;					case IFF_RENDER:  	err = render->IO(buffer);	break;					case IFF_NAVIGATE: 	err = navigate->IO(buffer);	break;					case IFF_MODEL: 	err = model->IO(buffer); 	break;					case IFF_DEFAULTS: 	err = deflt->IO(buffer);	break;#if (!VPLAYER)					case IFF_EDITOR:  	err = editor->IO(buffer);	break;					case IFF_UNITS: 	err = unit->IO(buffer);		break;// DAS-VR 8/24/93 ignore the window positions. Use the defaults.#if VWT					case IFF_WINDOW: 	err = window->IO(buffer); 	break;#endif					case IFF_TRANSLATOR:err = translator->IO(buffer);break;#endif //!VPLAYER                    case IFF_CONFIGURE:	err = configure->IO(buffer);break;                    // MERGE-HMD [[[                    #if USE_HMD					case IFF_HMDPREF:  	err = hmd->IO(buffer);	break;					#endif                    // MERGE-HMD ]]]					}				buffer->CloseChunk();				}			}		}	else		{		id = IFF_VPRF;		err = buffer->IOType(&id, IO_LONG);		if (!err)			{			buffer->OpenChunkW(IFF_VERS);			err = IO_VERS(buffer);			buffer->CloseChunk();			} 		if (!err)			{			buffer->OpenChunkW(IFF_RENDER); 			err = render->IO(buffer);			buffer->CloseChunk();			}		if (!err)			{	 		buffer->OpenChunkW(IFF_NAVIGATE);	 		err = navigate->IO(buffer);			buffer->CloseChunk();			}		if (!err)			{	 		buffer->OpenChunkW(IFF_DEFAULTS);	 		err = deflt->IO(buffer);			buffer->CloseChunk();			}#if (!VPLAYER)		if (!err)			{	 		buffer->OpenChunkW(IFF_EDITOR);	 		err = editor->IO(buffer);			buffer->CloseChunk();			}		if (!err)			{	 		buffer->OpenChunkW(IFF_UNITS);	 		err = unit->IO(buffer);			buffer->CloseChunk();			}		if (!err)			{			buffer->OpenChunkW(IFF_TRANSLATOR);	 		err = translator->IO(buffer);			buffer->CloseChunk();			}#endif //!VPLAYER		if (!err)			{	 		buffer->OpenChunkW(IFF_MODEL);	 		err = model->IO(buffer);			buffer->CloseChunk();			}		if (!err)			{	 		buffer->OpenChunkW(IFF_WINDOW);	 		err = window->IO(buffer);			buffer->CloseChunk();			}			if (!err && buffer->GetBufferType() != V_FILETYPE)			{			buffer->OpenChunkW(IFF_CONFIGURE);			err = configure->IO(buffer);			buffer->CloseChunk();            } 		#if USE_HMD	// ABD HMD APR95		if (!err)			{	 		buffer->OpenChunkW(IFF_HMDPREF);	 		err = hmd->IO(buffer);			buffer->CloseChunk();			}        #endif // USE_HMD		}	return(err);	}#define CPRF_VERS		2#if (!VPLAYER)intAppPreference::OLD_IO(V_Buffer *buffer)	{ 	Point3DFFixed	pt3D;	RGBColor		colr;	short	flags, DXFflags,num;	short	vers;	int 	err;		err = FALSE;		vers = CPRF_VERS;			err = buffer->IOType(&vers, IO_SHORT);	flags = 0;	DXFflags = 0;	ObjLock((ObjectHandle)this);	ObjLock((ObjectHandle)deflt);	ObjLock((ObjectHandle)editor);		if (buffer->IODirection() == DATA_IN ) 		{		if (vers <= CPRF_VERS)			{						if (!err) err = IOType(buffer, &deflt->extrusionMax, IO_POINT3D_FFIXED);			if (!err) err = IOType(buffer, &deflt->extrusionMin, IO_POINT3D_FFIXED);			if (!err) err = IOType(buffer, &editor->backColor, IO_RGB_COLOR);			if (!err) err = IOType(buffer, &editor->rulerColor, IO_RGB_COLOR);			if (!err) err = IOType(buffer, &editor->gridColor, IO_RGB_COLOR);			if (!err) err = buffer->IOType(&deflt->regularSides, IO_SHORT);			if (!err) err = buffer->IOType(&deflt->ellipseLevels, IO_SHORT);			if (!err) err = buffer->IOType(&flags, IO_SHORT);			if (!err && vers > 1) err = buffer->IOType(&DXFflags, IO_SHORT);					if (!err)				{				if(flags & 0x0001)editor->editorState |=RULER_SNAP;				else editor->editorState &= ~RULER_SNAP;				if(flags & 0x0002)editor->editorState |=GRID_DISPLAY;				else editor->editorState &= ~GRID_DISPLAY;				if(flags & 0x0004)editor->editorState |=RULER_DISPLAY;				else editor->editorState &= ~RULER_DISPLAY;				if(flags & 0x0008)editor->editorState |=TAB_DISPLAY;				else editor->editorState &= ~TAB_DISPLAY;				if(flags & 0x0010)/*THIS IS DEPTH STATE */;				if(flags & 0x0020)editor->trackState = positionWorld;				else editor->trackState = positionView;// DAS-VR 8/24/93#if VR				editor->editorState=appDesignDefaults;#endif				if (vers > 1)					{					translator->DXFobjColor = (DXFflags & 0x0001 ? TRUE : FALSE);					translator->DXFextr = (DXFflags & 0x0002 ? TRUE : FALSE);					}				}			}		}	else		{		if(editor->editorState & RULER_SNAP)flags |= 0x0001;		if(editor->editorState & GRID_DISPLAY)flags |= 0x0002;		if(editor->editorState & RULER_DISPLAY)flags |= 0x0004;		if(editor->editorState & TAB_DISPLAY)flags |= 0x0008;		if(FALSE)flags |= 0x0010;		if(editor->trackState == positionWorld)flags |= 0x0020;				if (translator->DXFobjColor) DXFflags |= 0x0001;		if (translator->DXFextr) DXFflags |= 0x0002;		if (!err) err = IOType(buffer, &deflt->extrusionMin, IO_POINT3D_FFIXED);		if (!err) err = IOType(buffer, &deflt->extrusionMax, IO_POINT3D_FFIXED);		if (!err) err = IOType(buffer, &editor->backColor, IO_RGB_COLOR);		if (!err) err = IOType(buffer, &editor->rulerColor, IO_RGB_COLOR);		if (!err) err = IOType(buffer, &editor->gridColor, IO_RGB_COLOR);		if (!err) err = buffer->IOType(&deflt->regularSides, IO_SHORT);		if (!err) err = buffer->IOType(&deflt->ellipseLevels, IO_SHORT);		if (!err) err = buffer->IOType(&flags, IO_SHORT);		if (!err && vers > 1) err = buffer->IOType(&DXFflags, IO_SHORT);		}			if (!err) err = deflt->popColor->IO_Color(buffer);	ObjUnlock((ObjectHandle)editor);	ObjUnlock((ObjectHandle)deflt);	ObjUnlock((ObjectHandle)this);	return err;	}#endif //!VPLAYERvoid AppPreference::LoadConfigure() { configure->LoadConfigure(); }void AppPreference::SaveConfigure() { configure->SaveConfigure(); }		/*************************************************************************** * *	The Editor Configuration Object * ***************************************************************************/ void EditorPreference::cPreference() 	{ 		Preference::cPreference();		backColor = appDesignColor;			gridColor = appGridColor;	rulerColor = appRulerColor;			extrRangeColor = appRangeColor;		homeColor = appHomeColor;		guideColor = appGuideColor;			editorState = appDesignDefaults;	trackState = appTrackState;	}	intEditorPreference::IO(V_Buffer *buffer)	{ 	Preference	**pref;	int		err;		err = FALSE;		ObjLock((ObjectHandle)this);		if (!err) err = buffer->IOType(&editorState, IO_LONG);// DAS-VR 8/24/93#if VR	editorState = (editorState&RULER_SNAP)|(appDesignDefaults&~RULER_SNAP); // DAS-VR-FIX 9/29/93#endif	if (!err) err = buffer->IOType(&trackState, IO_LONG);	if (!err) err = IOType(buffer,&backColor,IO_RGB_COLOR);	if (!err) err = IOType(buffer,&gridColor,IO_RGB_COLOR);	if (!err) err = IOType(buffer,&rulerColor,IO_RGB_COLOR);	if (!err) err = IOType(buffer,&extrRangeColor,IO_RGB_COLOR);	if (!err) err = IOType(buffer,&homeColor,IO_RGB_COLOR);	if (!err) err = IOType(buffer,&guideColor,IO_RGB_COLOR);// { DAS-VR-FIX 9/29/93 this forces these to always be the defaults when loading VWT documents#if VR	backColor = appDesignColor;			gridColor = appGridColor;	rulerColor = appRulerColor;			extrRangeColor = appRangeColor;		homeColor = appHomeColor;		guideColor = appGuideColor;		trackState = appTrackState;#endif// } DAS-VR-FIX 9/29/93 this forces these to always be the defaults when loading VWT documents	ObjUnlock((ObjectHandle)this);	return err;	}/*************************************************************************** * *	The Navigate Configuration Object * ***************************************************************************/ void NavigatePreference::cPreference() 	{ 		Preference::cPreference();	navigateMode = appNavigateMode;	aspectRatio = appAspectRatio;	aspectState = FALSE;	aspectType = aspectTelevision;	focalLength = appFocalLength;					filmWidth = appFilmWidth;			}intNavigatePreference::IO(V_Buffer *buffer)	{ 	int		err;	err = FALSE;		ObjLock((ObjectHandle)this);		if(DATA_IN == buffer->IODirection())		{		focalLength = appFocalLength;						filmWidth = appFilmWidth;				}			if (!err) err = buffer->IOType(&navigateMode, IO_LONG);#if VR	// ABD turn off velocity grid when loading models in VR	if (navigateMode & NAVIG_GRID)   	navigateMode ^= NAVIG_GRID;#endif // VR	if (!err) err = buffer->IOType(&aspectState, IO_SHORT);	if (!err) err = buffer->IOType(&aspectType, IO_SHORT);	if (!err) err = IOType(buffer,&aspectRatio, IO_POINT);		if(aspectType>=aspectMaxValue)		aspectType = aspectCustom;		if (!err) err = buffer->IOType(&focalLength, IO_SHORT);	if (!err) err = buffer->IOType(&filmWidth, IO_SHORT);	ObjUnlock((ObjectHandle)this);	return err;	}/*************************************************************************** * *	The Render Configuration Object * ***************************************************************************/ void RenderPreference::cPreference() 	{ 		Preference::cPreference();	renderDrawMode = appRenderDrawMode;	renderShadeMode = appRenderShadeMode;	renderOpenMode = appRenderOpenMode;	frameBlack = FALSE;	printWhiteShade = FALSE;	dither = TRUE;// { DAS-VR-BLENDED TRANSPARENCY 9/29/93 is now off#if VWT#if VPRO		// MERGE-GOURAUD-PRO-12    interpTransp = FALSE;		// MERGE-GOURAUD-PRO-12#else		// MERGE-GOURAUD-PRO-12    interpTransp = TRUE;#endif // VPRO		// MERGE-GOURAUD-PRO-12#elif VR   interpTransp = FALSE;#endif// } DAS-VR-BLENDED TRANSPARENCY 9/29/93 is now off	}intRenderPreference::IO(V_Buffer *buffer)	{ 	int		err;	err = FALSE;		ObjLock((ObjectHandle)this);	if (!err) err = buffer->IOType(&renderDrawMode, IO_LONG);	if (!err) err = buffer->IOType(&renderShadeMode, IO_LONG);	if (!err) err = buffer->IOType(&renderOpenMode, IO_LONG);	if (!err) err = buffer->IOType(&frameBlack, IO_CHAR);	if (!err) err = buffer->IOType(&printWhiteShade, IO_CHAR);    // New for v1.1 for Windows	buffer->IOType(&dither, IO_CHAR);	buffer->IOType(&interpTransp, IO_CHAR);// { DAS-VR-BLENDED TRANSPARENCY 9/29/93 is now off#if VR	interpTransp = FALSE;#endif// } DAS-VR-BLENDED TRANSPARENCY 9/29/93 is now off	ObjUnlock((ObjectHandle)this);		return err;	}/*************************************************************************** * *	The Default Configuration Object * ***************************************************************************/ void DefaultPreference::cPreference() 	{ 		Preference::cPreference();	objColor = appColor;	UnitConversion(appUnitSystem);	regularSides =  appDefaultSides;	ellipseLevels = appDefaultLevels;		SetName(&objectName,appObjectName);	SetName(&objectDesc,appObjectDesc);			SetName(&layerName,appLayerName);	#if (!VPLAYER)	popColor = new(PopColor);	popColor->cPane(FALSE);	popColor->Remember(&vWhite);#endif //!VPLAYER				localOrigin = Pt3DFFZero;#if (!VPLAYER)	guideLines = new(V_Array);	guideLines->cArray(0,sizeof(RulerItemDef*),4);	#endif //!VPLAYER	}void DefaultPreference::dPreference() 	{ 	int		i,length;#if (!VPLAYER)	RulerItemDef	**pItems;		popColor->dPane();#endif //!VPLAYER		DisposHandle((Handle)objectName);	DisposHandle((Handle)objectDesc);	DisposHandle((Handle)layerName);	#if (!VPLAYER)	length = guideLines->ALength();	pItems = (RulerItemDef	**)guideLines->Use();	for(i = 0 ; i < length; i++,pItems++)		(*pItems)->dRulerItemDef();	guideLines->Unuse();	guideLines->dArray();#endif //!VPLAYER	Preference::dPreference();	}voidDefaultPreference::UnitConversion(int unitSystem)	{	FFixed height;	homePosition = Pt3DFFZero; 	extrusionMin = Pt3DFFZero;		switch(unitSystem)		{		case unitInch: 			homePosition.z = appEViewHeight; 			height = appEExtrusionHeight;			break;					case unitFoot:		case unitYard:					case unitMile:			homePosition.z = appViewHeight; 			height = FFAdd(homePosition.z,homePosition.z);			break;					case unitMillimeter: 			homePosition.z = appMMViewHeight; 			height = appCMExtrusionHeight;			break;		case unitCentimeter:			homePosition.z = appCMViewHeight; 			height = appCMExtrusionHeight;			break;					case unitMeter:		case unitKilometer:			homePosition.z = appViewHeight; 			height = FFAdd(homePosition.z,homePosition.z);			break;					case unitPica: 		case unitPoint:		case unitAngstrom: 		case unitParsec:		case unitCustom:		default:				homePosition.z = appViewHeight; 			height = FFAdd(homePosition.z,homePosition.z);			break;		}			extrusionMax.x = height;	extrusionMax.y = height;	extrusionMax.z = height;	}	intDefaultPreference::IO(V_Buffer *buffer)	{ #if (!VPLAYER)	RulerItemDef	**pItem,*rItem;#endif //!VPLAYER	Handle	name;	char	*namePtr,*objNamePtr;	short	length,i;	int		err;	err = FALSE;		name = NewHandle(256);	ObjLock((ObjectHandle)this);	HLock((Handle)name);	namePtr = (char *)HDeref(name);		if (!err) err = buffer->IOType(&regularSides, IO_SHORT);	if (!err) err = buffer->IOType(&ellipseLevels, IO_SHORT);	if (!err) err = IOType(buffer, &homePosition, IO_POINT3D_FFIXED);	if (!err) err = IOType(buffer, &localOrigin, IO_POINT3D_FFIXED);	if (!err) err = IOType(buffer, &extrusionMin, IO_POINT3D_FFIXED);	if (!err) err = IOType(buffer, &extrusionMax, IO_POINT3D_FFIXED);	if (!err) err = IOType(buffer,&objColor,IO_RGB_COLOR);		if(!err)		{		if(DATA_IN == buffer->IODirection())			{			if (!err) err = IOType(buffer,namePtr,IO_CSTR);			if (!err) DisposHandle((Handle)objectName); SetName(&objectName, namePtr);			if (!err) err = IOType(buffer,namePtr,IO_CSTR);			if (!err) DisposHandle((Handle)objectDesc); SetName(&objectDesc, namePtr);			if (!err) err = IOType(buffer,namePtr,IO_CSTR);			if (!err) DisposHandle((Handle)layerName); SetName(&layerName, namePtr);			}		else			{			HLock((Handle)objectName);			objNamePtr = (char *)HDeref(objectName);			strncpy(namePtr,objNamePtr,255);namePtr[255] = 0;			if (!err) err = IOType(buffer,namePtr,IO_CSTR);			HUnlock((Handle)objectName);									HLock((Handle)objectDesc);			objNamePtr = (char *)HDeref(objectDesc);			strncpy(namePtr,objNamePtr,255);namePtr[255] = 0;			if (!err) err = IOType(buffer,namePtr,IO_CSTR);			HUnlock((Handle)objectDesc);						HLock((Handle)layerName);			objNamePtr = (char *)HDeref(layerName);			strncpy(namePtr,objNamePtr,255);namePtr[255] = 0;			if (!err) err = IOType(buffer,namePtr,IO_CSTR);			HUnlock((Handle)layerName);			}		}		#if (!VPLAYER)	if(DATA_IN == buffer->IODirection())		{		if (!err) err = buffer->IOType(&length, IO_SHORT);		if (!err) 			{			guideLines->SetLength(0);			for( i = 0; i < length; i++)				{				rItem = new(RulerItemDef);				rItem->cRulerItemDef();				err = rItem->IO(buffer);				if(err) break;				guideLines->Append(&rItem);				}			}		}	else		{		length = guideLines->ALength();		if (!err) err = buffer->IOType(&length, IO_SHORT);		if (!err) 			{			pItem = (RulerItemDef	**)guideLines->Use();			for( i = 0; i < length; i++,pItem++)				{				err = (*pItem)->IO(buffer);				if(err) break;				}			guideLines->Unuse();			}		}			if (!err) err = popColor->IO_Color(buffer);#endif //!VPLAYER	HUnlock((Handle)name);	ObjUnlock((ObjectHandle)this);	DisposHandle((Handle)name);		return err;	}/*************************************************************************** * *	The Unit Configuration Object * ***************************************************************************/ #if (!VPLAYER)void UnitPreference::cPreference() 	{ 		Preference::cPreference();	promoteFlag = TRUE;	unitSystem = appUnitSystem;	unitSize = appUnitSize;	baseSize = appUnitBaseSize;	worldSize = baseSize*MAX_WORLD_UNITS;	customSize = appCustomSize;	SetName(&customName,appCustomName);	SetName(&customSym,appCustomSym);	}void UnitPreference::dPreference() 	{ 		DisposHandle((Handle)customName);	DisposHandle((Handle)customSym);		Preference::dPreference();	}	UnitPreference::IO(V_Buffer *buffer)	{	IEEE_DOUBLE uSize,cSize,base,world;	Handle	name;	char	*namePtr,*tempPtr;	int		err;	err = FALSE;			uSize = unitSize;	base = baseSize;	cSize = customSize;	name = NewHandle(256);	ObjLock((ObjectHandle)this);	HLock(name);	namePtr = (char *)HDeref(name);		if (!err) err = buffer->IOType(&unitSystem, IO_SHORT);	if (!err) err = buffer->IOType(&promoteFlag, IO_SHORT);	if (!err) err = buffer->IOType(&uSize, IO_DOUBLE);	if (!err) err = buffer->IOType(&base, IO_DOUBLE);	if (!err) err = buffer->IOType(&cSize, IO_DOUBLE);	if(unitSystem>=unitMaxValue)		unitSystem = unitCustom;			if (!err && buffer->IODirection() == DATA_IN)		{		unitSize = uSize;		baseSize = base;		worldSize = baseSize*MAX_WORLD_UNITS;		customSize = cSize;		}		if (!err) 		{		if(DATA_IN == buffer->IODirection())			{			if (!err) err = IOType(buffer,namePtr,IO_CSTR);			if (!err) DisposHandle((Handle)customName); SetName(&customName, namePtr);			if (!err) err = IOType(buffer,namePtr,IO_CSTR);			if (!err) DisposHandle((Handle)customSym); SetName(&customSym, namePtr);			}		else			{			HLock(customName);			tempPtr = (char *)HDeref(customName);			strncpy(namePtr,tempPtr,255);namePtr[255] = 0;			if (!err) err = IOType(buffer,namePtr,IO_CSTR);			HUnlock(customName);						HLock(customSym);			tempPtr = (char *)HDeref(customSym);			strncpy(namePtr,tempPtr,255);namePtr[255] = 0;			if (!err) err = IOType(buffer,namePtr,IO_CSTR);			HUnlock(customSym);			}		}			HUnlock(name);	ObjUnlock((ObjectHandle)this);	DisposHandle(name);	return err;	}#endif //!VPLAYER/*************************************************************************** * *	The Model Configuration Object * ***************************************************************************/ void ModelPreference::cPreference() 	{ 	Light *light;	Preference::cPreference();	lights = new(LightModel);	lights->cLightModel();	light = new(Light);	light->cLight();	light->SetAmbient();	light->SetColor(appLight1Color);	lights->AddLight(light);	light = new(Light);	light->cLight();	light->SetSource(FFRound(appLight2Loc.x),FFRound(appLight2Loc.y),FFRound(appLight2Loc.z));	light->SetColor(appLight2Color);	lights->AddLight(light);	light = new(Light);	light->cLight();	light->SetSource(FFRound(appLight3Loc.x),FFRound(appLight3Loc.y),FFRound(appLight3Loc.z));	light->SetColor(appLight3Color);	lights->AddLight(light);	light = new(Light);	light->cLight();	light->SetSource(FFRound(appLight4Loc.x),FFRound(appLight4Loc.y),FFRound(appLight4Loc.z));	light->SetColor(appLight4Color);	lights->AddLight(light);	skyColor = appSkyColor;	viewPoint = Pt3DFFZero;	viewAngle = FFAngleZero;		}void ModelPreference::dPreference() 	{ 	lights->dLightModel();	Preference::dPreference() ;	}	intModelPreference::IO(V_Buffer *buffer)	{	int		err;		err = FALSE;		ObjLock((ObjectHandle)this);	if (DATA_IN == buffer->IODirection())		{		lights->dLightModel();		lights = new(LightModel);		lights->cLightModel();		}	if(!err) err = IOType(buffer, &viewPoint, IO_POINT3D_FFIXED);	if(!err) err = IOType(buffer, &viewAngle, IO_ANGLE3D_FFIXED);	if(!err) err = IOType(buffer,&skyColor,IO_RGB_COLOR);	if(!err) err = lights->IO(buffer);	ObjUnlock((ObjectHandle)this);				return err;	}/*************************************************************************** * *	The Window Configuration Object * ***************************************************************************/// { DAS-VR-INITIALIZE 8/14/93 These constants have been changed for VR. #if VWTshort	appDefaultTopWindowMargin = 44;short	appDefaultEdgeWindowMargin = 8;short	appDefaultLRWindowMargin = 4;short	appDefaultUDWindowMargin = 24;short	appDefaultToolWidth = 75;short 	appDefaultBottomWindowMargin = 4; /*this is for the information pane - DAS*/#elif VR// { DAS-VR 9/28/93 changed these to make more roomshort	appDefaultTopWindowMargin = 42;short	appDefaultEdgeWindowMargin = 2;short	appDefaultLRWindowMargin = 4;short	appDefaultUDWindowMargin = 24;short	appDefaultToolWidth = VRLIB_DEFWIDTH;short 	appDefaultBottomWindowMargin = 24; /*this is for the information pane - DAS*/short 	appDefaultDesignHeight = 190;// } DAS-VR 9/28/93 changed these to make more room#endif// }DAS-VR-INITIALIZE 8/14/93void WindowPreference::cPreference() 	{ 		Preference::cPreference();		windows = new(V_Array);	windows->cArray(0,sizeof(WindowPreRec*),4);		BuildDefault();	}/* { DAS-VR-INITIALIZE  - this has been changed to have the    design view appear on top of the walk view for VR    instead of having them appear side by side. Also,    note that the library/tool area is made larger for VR.*/void WindowPreference::BuildDefault() 	{ 		Rect	r,sr;	short	type,width,farRight;	FFixed	realScale = appScale;	// BILBIL - CadDraft zoom sizing for english/metric	GetLimitedScreen(&sr);	farRight = sr.right;/*this is the left tool palette area. It will be used also as the default location of the library window. DAS-VR-INITIALIZE 8/14/93 */	r.top = appDefaultTopWindowMargin - 8;	r.bottom = sr.bottom - appDefaultBottomWindowMargin;	r.left = sr.left + appDefaultEdgeWindowMargin;	r.right = r.left + appDefaultToolWidth;#if VWT// DAS-VR 8/24/93 turning off the Tool Palette here	AddRecord(&r,FFOne,PtZero,PREF_VIEW_TOOLSET);#endif// BILBIL - CadDraft zoom sizing for english/metric [[[	if (appUnitSystem == unitCentimeter)		{		realScale.intg = 0;		realScale.frac = 0x4000;		}// BILBIL - CadDraft zoom sizing for english/metric ]]]#if MACINTOSH#if VWT	r.top = appDefaultTopWindowMargin;	width = ((farRight - r.right)>>1) - appDefaultEdgeWindowMargin;	r.left = r.right + appDefaultLRWindowMargin;	r.right = r.left + width;	AddRecord(&r,realScale,PtZero,appDefaultEditorType);	r.left = r.right + appDefaultLRWindowMargin;	r.right = r.left + width;	AddRecord(&r,FFOne,PtZero,PREF_VIEW_WALK);#elif VR	r.top = appDefaultTopWindowMargin;	r.left = r.right + appDefaultLRWindowMargin;	r.right = sr.right - appDefaultEdgeWindowMargin;	r.bottom = (sr.top+appDefaultTopWindowMargin + (sr.bottom-appDefaultBottomWindowMargin))>>1;	if(r.bottom-r.top<appDefaultDesignHeight)		r.bottom=r.top+appDefaultDesignHeight;	r.bottom -= appDefaultUDWindowMargin;	AddRecord(&r,realScale,PtZero,appDefaultEditorType);//	infoR = doc->GetInfoWinRect();//	libR = doc->GetVRLibRect();	r.top = r.bottom + appDefaultUDWindowMargin;	r.bottom = sr.bottom-appDefaultBottomWindowMargin;	AddRecord(&r,FFOne,PtZero,PREF_VIEW_WALK);#endif // VWT#elif WINDOWS#if VWT	V_Document *doc;    Rect docRect;	Rect editRect, walkRect;	doc = GetCurrentDocument();	docRect = doc->GetFrameRect();	docRect.left = max(docRect.left,		r.right+appDefaultLRWindowMargin+GetSystemMetrics(SM_CXFRAME));	AddRecord(&docRect,FFOne,PtZero,PREF_VIEW_DOCUMENT);	editRect = docRect;    walkRect = docRect;    width = (docRect.right - docRect.left) >> 1;	editRect.left = docRect.left;	editRect.right = editRect.left + width;	walkRect.left = editRect.right;    walkRect.right = docRect.right;	editRect.top += GetSystemMetrics(SM_CYFRAME)+GetSystemMetrics(SM_CYCAPTION);	editRect.bottom -= GetSystemMetrics(SM_CYFRAME);	editRect.left += GetSystemMetrics(SM_CXFRAME);	editRect.right -= GetSystemMetrics(SM_CXFRAME);	AddRecord(&editRect,realScale,PtZero,appDefaultEditorType);	walkRect.top += GetSystemMetrics(SM_CYFRAME)+GetSystemMetrics(SM_CYCAPTION);	walkRect.bottom -= GetSystemMetrics(SM_CYFRAME);	walkRect.left += GetSystemMetrics(SM_CXFRAME);	walkRect.right -= GetSystemMetrics(SM_CXFRAME);	AddRecord(&walkRect,FFOne,PtZero,PREF_VIEW_WALK);#elif VR	V_Document *doc;    Rect docRect;	Rect editRect, walkRect, infoR, libR;    int height;	doc = GetCurrentDocument();	docRect = doc->GetFrameRect();// jca 13 Nov 93 -- Don't adjust the left edge.  There's no tool palette// to account for, and in VR adjusting the left edge just messes up// the maximized document window.	AddRecord(&docRect,FFOne,PtZero,PREF_VIEW_DOCUMENT);	infoR = doc->GetInfoWinRect();	libR = doc->GetVRLibRect();	docRect.bottom -= (infoR.bottom - infoR.top);  // account for the info rect	docRect.left += appDefaultToolWidth;	editRect = docRect;    walkRect = docRect;    height = (docRect.bottom - docRect.top) >> 1;	editRect.top = docRect.top;	editRect.bottom = editRect.top + height;	walkRect.top = editRect.bottom;	walkRect.bottom = docRect.bottom;	editRect.top += GetSystemMetrics(SM_CYFRAME)+GetSystemMetrics(SM_CYCAPTION);	editRect.bottom -= GetSystemMetrics(SM_CYFRAME);	editRect.left += GetSystemMetrics(SM_CXFRAME);	editRect.right -= GetSystemMetrics(SM_CXFRAME);	AddRecord(&editRect,realScale,PtZero,appDefaultEditorType);	walkRect.top += GetSystemMetrics(SM_CYFRAME)+GetSystemMetrics(SM_CYCAPTION);	walkRect.bottom -= GetSystemMetrics(SM_CYFRAME);	walkRect.left += GetSystemMetrics(SM_CXFRAME);	walkRect.right -= GetSystemMetrics(SM_CXFRAME);	AddRecord(&walkRect,FFOne,PtZero,PREF_VIEW_WALK);#endif // VWT#endif //WINDOWS	}// } DAS-VR-INITIALIZE 8/14/93void WindowPreference::dPreference() 	{ 		ClearRecords();	windows->dArray();	Preference::dPreference();	}/*----------------------------------------------------------------------*/#if 0	CheckWindows()		Verify and move windows onto screen.				1)  Reasonableness check				windows formed properly (left to right)				windows of minimum size		2)  Fit onto screen				Find a suitable screen (FindScreenR())				Move and resize for the following goals.								1) Have top visible (easy to move screen)				2) Reduce size so if it were moved, it would all fit					(easier to reach resize and other active corners)				3) Don't resize unless (2)				4) Keep visible edges in place.			Method:				if top is offscreen above, slide down whole.				if top is offscreen beneath, slide up whole.				size the bottom based on the top.				if right is visible or offscreen left,					ensure right is visible,					size the left based on the right.				Else, right is offscreen right, so get left onscreen.					if left is offscreen left, slide right.					if left is offscreen right, slide left.					size right based on left.							Really need concept of Inner size vs Outer size ... #endif/*----------------------------------------------------------------------*//* * 08/13/92 gjr CheckWindows: redo edge checks. Testcase: Bill's Bridge 2 */#if MACINTOSH#define LEFT_EDGE   (1)				/* extra size for edgeing */#define RIGHT_EDGE  (2)#define BOTTOM_EDGE (2)#define TOP_EDGE    (18)#elif WINDOWS#define LEFT_EDGE   (GetSystemMetrics(SM_CXFRAME))#define RIGHT_EDGE  (GetSystemMetrics(SM_CXFRAME))#define BOTTOM_EDGE (GetSystemMetrics(SM_CYFRAME))#define TOP_EDGE    (GetSystemMetrics(SM_CYFRAME)+GetSystemMetrics(SM_CYCAPTION))#endif //WINDOWS#define WINDOW_MARGIN	(72)		/* min interior window size */#define WIDTH_EDGES (LEFT_EDGE + RIGHT_EDGE)#define HEIGHT_EDGES (BOTTOM_EDGE + TOP_EDGE)#define MIN_WIDTH_VISIBLE (28)	/* plus left/right edge */#define MIN_HEIGHT_VISIBLE (8)	/* plus top bar */int WindowPreference::CheckWindows() 	{ 	V_Offscreen *scr,*mainScr;	WindowPreRec	**pWindRec;	Rect	targetRect,windRect ;	int		width, height;	int		length,i,menuBarAdjust ; 		screen->Get(0,&mainScr);	length = windows->ALength();	pWindRec = (WindowPreRec	**)windows->Use();	for(i =0 ; i < length; i++,pWindRec++)		{		windRect = (*pWindRec)->where;		/* Reasonableness, coords go down and right, and minimum size */		windRect.bottom = max(windRect.bottom, windRect.top + WINDOW_MARGIN);			windRect.right = max(windRect.right, windRect.left + WINDOW_MARGIN);						scr = FindScreenR(&windRect);        //MERGE-PRO-JAM-2 protect against off-screen windows [[[		if(scr == NULL)		{        	scr = mainScr;		}		//MERGE-PRO-JAM-2 protect against off-screen windows ]]]		scr->GetRect(&targetRect);		#if MACINTOSH		/* adjust for actual screen real estate */		if(scr == mainScr)menuBarAdjust = GetMBarHeight(); else menuBarAdjust = 0;		targetRect.top += menuBarAdjust;#endif //MACINTOSH		/* Get sizes, then ensure within target size */		width  = windRect.right - windRect.left;		height = windRect.bottom - windRect.top;				width  = min(width, targetRect.right - targetRect.left - WIDTH_EDGES);		height = min(height, targetRect.bottom - targetRect.top - HEIGHT_EDGES);				/* force top menu visible, then slide bottom appropriately */		windRect.top = max(windRect.top, targetRect.top + TOP_EDGE);		windRect.top = min(windRect.top, targetRect.bottom - MIN_HEIGHT_VISIBLE);		windRect.bottom = windRect.top + height;				/* Checking right edge first */		if (windRect.right < targetRect.right)			{  /* then either visible or we have to move anyway */			/* force right edge visible if too far left */			windRect.right = max(windRect.right, targetRect.left + MIN_WIDTH_VISIBLE);			/* maintain width by sliding left edge properly */			windRect.left = windRect.right - width;			}		else			{  /* not forced to correct right, so fiddle with left */			/* force left edge onto screen, no matter where it is */			windRect.left = max(windRect.left, targetRect.left);			windRect.left = min(windRect.left, targetRect.right - MIN_WIDTH_VISIBLE);			windRect.right = windRect.left + width;			}		(*pWindRec)->where = windRect;					}	windows->Unuse();			return TRUE;	}	intWindowPreference::Compare(V_Array *oWindPref) 	{ 		return FALSE;	}void WindowPreference::AddRecord(Rect *r,FFixed scale,Point sPosn,int type) 	{ 		WindowPreRec	*windRec;	windRec = new(WindowPreRec);	windRec->cWindowRec();	windRec->SetScale(scale);	windRec->SetRect(r);	windRec->SetType(type);		windows->Append(&windRec);	}void WindowPreference::ClearRecords() 	{ 		WindowPreRec	**pWindRec;	int		length,i;		length = windows->ALength();	pWindRec = (WindowPreRec	**)windows->Use();	for(i = 0; i < length; i++,pWindRec++) 		(*pWindRec)->dWindowRec();	windows->Unuse();	windows->SetLength(0);	}int CompareScreens(V_Array *);intCompareScreens(V_Array *windowState)	{	V_Offscreen	**pOffscr;	Rect	sr,*r;	int	i,length,result;		result = FALSE;	length = windowState->ALength();	if(length == screen->ALength())		{		pOffscr = (V_Offscreen	**)screen->Use();		r = (Rect *)windowState->Use();		result = TRUE;		for(i = 0; i < length; i++,pOffscr++,r++)			{			(*pOffscr)->GetRect(&sr);			if((sr.left!=r->left)||(sr.right!=r->right) ||(sr.bottom!=r->bottom)||(sr.top!=r->top))				{ result = FALSE; break; }			}		windowState->Unuse();		screen->Unuse();		}		return result;	}	intWindowPreference::IO(V_Buffer *buffer)	{// DAS-VR-DEAD 8/24/93	V_Array		*windowState;	WindowPreRec	**pWindRec,*windRec;	V_Offscreen	**pOffscr;	Rect	r,*or,sr;	long	id;	short	length,i,scrLength;	int		err;	err = FALSE;		if(DATA_IN == buffer->IODirection())		{		length = 0;				err = buffer->IOType(&length, IO_SHORT);		if(!err && length) 			{			windowState= new(V_Array);			windowState->cArray(0,sizeof(Rect),4);			ClearRecords() ;						for (i = 0; i < length && !err; i++,pWindRec++)				{				windRec = new(WindowPreRec);				windRec->cWindowRec();				err = windRec->IO(buffer);					if (!err) windows->Append(&windRec);				else windRec->dWindowRec();				}							if(!err) 				{				err = buffer->IOType(&length, IO_SHORT);				if(!err && length) 					{					for (i = 0; i < length && !err; i++)		 				{		 				err = IOType(buffer,&r,IO_RECT);		 				if(!err)windowState->Append(&r);		 				}					}				}						if(!err)				{				if(!CompareScreens(windowState))					CheckWindows();				}									windowState->dArray();			}		}	else		{		length = windows->ALength();		err = buffer->IOType(&length, IO_SHORT);		if(!err) 			{			pWindRec = (WindowPreRec	**)windows->Use();			for(i = 0; i < length && !err; i++,pWindRec++)		 		if(err = (*pWindRec)->IO(buffer)) 		 			break;			windows->Unuse();			}		if(!err) 			{			scrLength = screen->ALength();			err = buffer->IOType(&scrLength, IO_SHORT);			pOffscr = (V_Offscreen	**)screen->Use();			for(i = 0; i < scrLength && !err; i++,pOffscr++)		 		{		 		(*pOffscr)->GetRect(&r); 		 		if(err = IOType(buffer,&r,IO_RECT))break;		 		}			screen->Unuse();			}		}	return err;	}/*************************************************************************** * *	The Window description Object * ***************************************************************************/ void WindowPreRec::cWindowRec() 	{ 		where.top = 0;	where.left = 0;	where.bottom = 0;	where.right = 0;	scale = FFOne;	scrollPosition = PtZero;	type = 0;	}void WindowPreRec::dWindowRec() { delete this; }void  WindowPreRec::SetRect(Rect *r) {  where = *r;	 }void  WindowPreRec::SetType(int newType) {  type = newType;	 }void  WindowPreRec::SetScale(FFixed newScale) {  scale = newScale;	 }int WindowPreRec::Compare(WindowPreRec *otherWindowRec) 	{ 	int result;		result = 0;	if(type!=otherWindowRec->type)		result |= WINDOW_DIFFERENT;	if((where.top!=otherWindowRec->where.top)||(where.bottom!=otherWindowRec->where.bottom)		||(where.left!=otherWindowRec->where.left) || (where.right!=otherWindowRec->where.right))			result |= WINDOW_DIFFERENT;	return result;	}int WindowPreRec::IO(V_Buffer *buffer) 	{ 	int	err;		err = FALSE;	ObjLock((ObjectHandle)this);	if(!err) err = IOType(buffer, &where, IO_RECT);	if(!err) err = IOType(buffer, &scrollPosition, IO_POINT);	if(!err) err = IOType(buffer, &scale, IO_FFIXED);	if(!err) err = buffer->IOType(&type, IO_SHORT);	ObjUnlock((ObjectHandle)this);		return(err);	}	/*************************************************************************** * *	The Event Configuration Object * ***************************************************************************/void EventPreference::cPreference() 	{ 		Preference::cPreference();	eventTypes = appEventTypes;	resolveFlag = appEventResolve;	}intEventPreference::IO(V_Buffer *buffer)	{	int		err;		err = FALSE;		ObjLock((ObjectHandle)this);	if(!err) err = buffer->IOType(&eventTypes, IO_LONG);	if(!err) err = buffer->IOType(&resolveFlag, IO_CHAR);	ObjUnlock((ObjectHandle)this);				return err;	}/*************************************************************************** * *	The Translate Configuration Object * ***************************************************************************/#if (!VPLAYER)void TranslatorPreference::cPreference() 	{ 		Preference::cPreference();		DXFobjColor = TRUE;	DXFextr = TRUE;	DXFsurf = exportLine;		GetLimitedScreen(&outputRect);	exportView = topViewVector;	exportType = format3DDXF;		outputColorDepth = MainDepth();	exportLineMode = LINETERM_DEFAULT;#if VWT		// jca 17 Oct 93 {	bitmapFlag = FALSE;#else // VR, PRO	bitmapFlag = TRUE;	// picts show textures only if bitmaps#endif		// jca 17 Oct 93 }	smoothFlag = FALSE;	startFrame = 0;	endFrame = 0;		frameBlack = TRUE;	importFlag = IMPORT_PATCH|IMPORT_NONCONVEX|IMPORT_DEGENERATE|IMPORT_ORPHANS;		CLARISFillType = CLARISFillObject;	EPSColorFlag = TRUE;	EPSPreviewFlag = TRUE;	EPSFDevice = EPSFOR_DEFAULT;#if WINDOWS && VR             // jam 6OCT94 jca VR1.0.1 18AUG94 don't compress automatically [[[	TIFFCompression = FALSE;#elif SPECIAL_EDITION         // merge SE		// GJR 7/4/95	TIFFCompression = FALSE;#else	TIFFCompression = TIFFLZW;#endif // WINDOWS && VR        // jca VR1.0.1 ]]]	frameRate = 10;	// jca 8 Nov 93 --New for WinVR, but not IO'd	AVICompressorId = 0;          // no compressor	AVICompressorQuality = 10000;	// our default is of the highest quality	// jca 8 Nov 93	lastTranslator = FORMAT_DEFAULT;	screenSize = screenWindow;	//JAM added 18JULY94 for texture embedding/not embedding [[[	#if VPRO	EmbedTexturesFlag = EMBED_TEXTURES_DEFAULT;	#endif	//JAM added 18JULY94 for texture embedding/not embedding ]]]		#if VRML_ANCHOR				// VRML-ABD 23JUN95	// default VRML export preferences	two_sided_polys = FALSE;	use_cr = TRUE;	use_lf = TRUE;	surffeature_z_offset = DblToFixed(0.01);	strcpy(texture_ext, ".jpg");		// PRO25	export_textures = FALSE;			// PRO25	#endif // VRML_ANCHOR		}void TranslatorPreference::dPreference() 	{ 	Preference::dPreference();	}		intTranslatorPreference::IO(V_Buffer *buffer)	{	Handle 	name;	char	*namePtr,*aboutTextPtr;	int		err;	err = FALSE;		ObjLock((ObjectHandle)this);	if(!err) err = buffer->IOType(&importFlag, IO_SHORT);	if(!err) err = IOType(buffer, &exportView, IO_POINT3D_FFIXED);	if(!err) err = buffer->IOType(&DXFobjColor, IO_SHORT);	if(!err) err = buffer->IOType(&DXFextr, IO_SHORT);	if(!err) err = buffer->IOType(&DXFsurf, IO_SHORT);	if(!err) err = buffer->IOType(&exportLineMode, IO_SHORT);	if(!err) err = buffer->IOType(&CLARISFillType, IO_SHORT);	if(!err) err = buffer->IOType(&frameBlack, IO_SHORT);	if(!err) err = buffer->IOType(&lastTranslator, IO_SHORT);	if(!err) err = buffer->IOType(&screenSize, IO_SHORT);	if(!err) err = IOType(buffer, &outputRect, IO_RECT);	if(!err) err = buffer->IOType(&outputColorDepth, IO_SHORT);	if(!err) err = buffer->IOType(&bitmapFlag, IO_CHAR);	if(!err) err = buffer->IOType(&EPSColorFlag, IO_CHAR);	if(!err) err = buffer->IOType(&smoothFlag, IO_SHORT);	// New for v1.1 for Windows	buffer->IOType(&EPSPreviewFlag, IO_SHORT);	buffer->IOType(&EPSFDevice, IO_SHORT);	buffer->IOType(&TIFFCompression, IO_SHORT);	buffer->IOType(&frameRate, IO_SHORT);	//JAM added 18JULY94 for texture embedding/not embedding [[[	#if VPRO	buffer->IOType(&EmbedTexturesFlag, IO_SHORT);	#endif	//JAM added 18JULY94 for texture embedding/not embedding ]]]	// jca 8 Nov 93 -- NOTE that AVICompressorId and AVICompressorQuality   // do not have IO statements!!!	if(lastTranslator>=formatMaxValue)		lastTranslator = FORMAT_DEFAULT;// JOEBOB -- check against Mac values on Windows and Windows values on Mac	if(screenSize>=screenMaxValue)		screenSize = screenCustom;	if(EPSFDevice>=EPSFMaxValue)		EPSFDevice = EPSFOR_DEFAULT;	if(TIFFCompression>=TIFFMaxValue)    	TIFFCompression = TIFFLZW;	#if VRML_ANCHOR				// VRML-ABD 23JUN95	if(!err) err = buffer->IOType(&two_sided_polys, IO_SHORT);	if(!err) err = buffer->IOType(&use_cr, IO_SHORT);	if(!err) err = buffer->IOType(&use_lf, IO_SHORT);	if(!err) err = IOType(buffer, &surffeature_z_offset, IO_FFIXED);	if(!err) err = IOType(buffer, &texture_ext, IO_CSTR);		// PRO25	if(!err) err = buffer->IOType(&export_textures, IO_SHORT);		// PRO25	#endif // VRML_ANCHOR			ObjUnlock((ObjectHandle)this);	return err;	}intTranslatorPreference::IOVoyager(V_Buffer *buffer)	{	long id;	int err = 0;	if (buffer->IODirection() == DATA_IN)		{		while (!err)			{			id = buffer->OpenChunkR();			if (id == 0) break;			switch (id)				{				case IFF_VGERSIMPLE: err = IO_VSimple(buffer); break;				case IFF_VGERPICT: err = IO_VPICT(buffer); break;				case IFF_VGERTEXT: err = IO_VText(buffer); break;				}			buffer->CloseChunk();			}		if ((creditType == creditForm && text == NULL) ||			(creditType == creditPICT && pictFile == NULL))			creditType = creditNone;		}	else		{		if (!err)			{			buffer->OpenChunkW(IFF_VGERSIMPLE);			err = IO_VSimple(buffer);			buffer->CloseChunk();			}		if (!err && pictFile != NULL)			{			V_File *modelFile = (V_File *)buffer;			pictFile->SetRelative(modelFile);			buffer->OpenChunkW(IFF_VGERPICT);			err = pictFile->IO(buffer);			buffer->CloseChunk();			}		if (!err && text != NULL)			{			buffer->OpenChunkW(IFF_VGERTEXT);			text->IO(buffer);			buffer->CloseChunk();			}		}	}intTranslatorPreference::IO_VSimple(V_Buffer *buffer)	{	int		err;	err = FALSE;		ObjLock((Handle)this);	if(!err) err = buffer->IOType(&noviceMode, IO_SHORT);	if(!err) err = buffer->IOType(&creditType, IO_SHORT);	ObjUnlock((Handle)this);	return err;	}intTranslatorPreference::IO_VPICT(V_Buffer *buffer)	{	int		err;	V_File	*modelFile;	char	fileName[256], str[256];	err = FALSE;	modelFile = (V_File *)buffer;	pictFile = new(V_File);	pictFile->cFile(REFERENCE, appFileTypePICT, appFileCreatorPICT, "", "");	pictFile->SetRelative(modelFile);	err = pictFile->IO(buffer);	if (err == fileNotFoundErr)		VerifyPictFile();	return err;	}intTranslatorPreference::IO_VText(V_Buffer *buffer)	{	int		err;	err = FALSE;	text = new(V_Array);	text->cArray(buffer->ChunkSize(), 1, 16);	text->IO(buffer);	return err;	}voidTranslatorPreference::VerifyPictFile()	{	char	fileName[256], str[256];	int		err = 0;	if ((err = pictFile->FVerify()) != 0)		{		pictFile->GetFName(fileName);		sprintf(str, TXTW_CREDITS_MISSING, fileName);	// PRO-JAP			if (WarningMessage(str, TXTC_FORGET, TXTC_LOCATE, POSITIVE_BUTTON_TWO|DEFAULT_BUTTON_TWO))			{			sprintf(str, TXTW_LOCATE_CREDITS, fileName);			pictFile->SetQuery(LOADAS, str);				err = pictFile->Find();			pictFile->SetQuery(REFERENCE, "");			}		if (err)			{			pictFile->dFile();			pictFile = NULL;			creditType = creditNone;			}		}	}// JAM 7-18-94 to help handle embedding/file refs for textures[[[#if VPROshortTranslatorPreference::GetEmbedTextures(void){	return(EmbedTexturesFlag);}voidTranslatorPreference::SetEmbedTextures(short newvalue){	EmbedTexturesFlag = newvalue;}#endif// JAM 7-18-94 to help handle embedding/file refs for textures]]]#endif //!VPLAYERintScreenSize(int screenType,Point *p,V_Window *window)	{	V_Offscreen *scr;	Rect 	r;	switch(screenType)		{		case screen9: p->h = 512; p->v = 342; break;		case screen12: p->h = 512; p->v = 384; break;		case screen13: p->h = 640; p->v = 480; break;		case screen320x200: p->h = 320; p->v = 200; break;		case screen640x480: p->h = 640; p->v = 480; break;		case screen800x600: p->h = 800; p->v = 600; break;		case screen1024x768: p->h = 1024; p->v = 768; break;		case screenFull: 			if(window)				{				window->Locate(&r);				scr = FindScreenR(&r);				scr->GetRect(&r);				p->h = r.right - r.left;				p->v = r.bottom - r.top;				}			break;		case screenWindow: 			if(window)				{				window->GetRect(&r);				p->h = r.right - r.left;				p->v = r.bottom - r.top;				}			break;		}	}	intAspectRatio(int aspectType,Point *p)	{	switch(aspectType)		{		case aspect35Horz:p->h = 36; p->v = 24; break;		case aspect35Vert: p->h = 24; p->v = 36;break;		case aspect225Square: p->h = 1; p->v = 1; break;		case aspect4x5Horz: p->h = 5; p->v = 4; break;		case aspect4x5Vert: p->h = 4; p->v = 5; break;		case aspectTelevision: p->h = 133; p->v = 100;break;#if JAPANESE  // jca 18APR95		case aspectJapaneseHiVision: p->h = 178; p->v = 100;break;#endif // JAPANESE		case aspectAcademyAperture: p->h = 133; p->v = 100; break;		case aspectEuroWideScreen: p->h = 166; p->v = 100; break;		case aspectUSWideScreen: p->h = 185; p->v = 100; break;		case aspectAnamorphicAperture: p->h = 235; p->v = 100; break;		case aspectCustom: break;		}	}	/*************************************************************************** * *	The Configure Configuration Object * ***************************************************************************/voidConfigurePreference::cPreference()	{ 		Preference::cPreference();    flashFill = TRUE;	}intConfigurePreference::IO(V_Buffer *buffer)	{	int err = FALSE;	ObjLock((ObjectHandle)this);	if(!err) err = buffer->IOType(&flashFill, IO_CHAR);	ObjUnlock((ObjectHandle)this);	return err;	}voidConfigurePreference::LoadConfigure()	{#if MACINTOSH	// Need to do the Mac thing here.#elif WINDOWS	int f;	if ((f = GetProfileInt(TXT_APPNAME,appKeyFlashFill,-1)) != -1)		flashFill = (f ? TRUE : FALSE);#endif //WINDOWS    VSetUserFlash(flashFill);	}voidConfigurePreference::SaveConfigure()	{#if MACINTOSH	// Need to do the Mac thing here.#elif WINDOWS	char s[32];	sprintf(s,"%d",flashFill);	WriteProfileString(TXT_APPNAME,appKeyFlashFill,s);#endif //WINDOWS    VSetUserFlash(flashFill);	}// MERGE-HMD [[[#if USE_HMD/*************************************************************************** * *	The HMD Configuration Object * ***************************************************************************/voidHMDPreference::cPreference()	{ 		Preference::cPreference();	hmd_type = HMD_VREX;		// ABD HMD MAR95 	ipd = DblToFixed(0.5);	iod = DblToFixed(4.0);	wp = DblToFixed(12.0);   //	dp = DblToFixed(12.0);   //	dv = DblToFixed(12.0);	cross_eyed = FALSE;	yblank = 48; 	}voidHMDPreference::dPreference()	{ 		Preference::dPreference();	}intHMDPreference::IO(V_Buffer *buffer)	{	int err = FALSE;	FFixed dum = { 0, 0 };	ObjLock((ObjectHandle)this);	err = buffer->IOType(&hmd_type, IO_SHORT);	if (!err) err = IOType(buffer, &ipd, IO_FFIXED);	if (!err) err = IOType(buffer, &wp, IO_FFIXED);	if (!err) err = IOType(buffer, &dum, IO_FFIXED);	if (!err) err = IOType(buffer, &dum, IO_FFIXED);	if (!err) err = buffer->IOType(&cross_eyed, IO_SHORT);	if (!err) err = buffer->IOType(&yblank, IO_SHORT);	if (!err) err = IOType(buffer, &iod, IO_FFIXED);	ObjUnlock((ObjectHandle)this);	return err;	}#endif // USE_HMD// MERGE-HMD ]]]