/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "DlogTran.h"	#include "Layout.h"	#include "AppDeflt.h"#include "AppFiles.h"#include "AppText.h"	#include "VTextDef.h"#include "WalkThru.h"#include "WlkCntrl.h"	#include "Observer.h"	#include "VMath.h"	#include "VWindow.h"#include "VGraphic.h"	#include "VGUtil.h"#include "VFile.h"#include "AVIMovie.h" 	// jca 8 Nov 93 for avi translator#include <stdio.h>#include <string.h>const int snapColors =	snapColor2|snapColor3|snapColorPopUp|snapColorPopBMP;intTransText::Action(char c,long modifiers)	{	int result;		if(c != V_ENTER)		result = V_EditText::Action(c,modifiers);	else		{		((TranslateDialog*)thePane)->Update();		result = TRUE;		}			return result;	}intTranslateDialog::cTranslateDialog( Controller *ctrl,int format,int direction)	{	AppPreference	*realPref;	TranslatorPreference *transPref;	Rect r,sR;	int	result,cH,cV,lH,lV;		controller = ctrl;		realPref = controller->GetPreference();	transPref = (TranslatorPreference*)realPref->GetPreference(preferTranslator);			switch(format)		{		case formatPICT: translateObject = new(PICTSnap); break;			case formatBMP: translateObject = new(BMPSnap); break;		case formatTIFF: translateObject = new (TIFFSnap); break;		case formatEPS: translateObject = new(EPSFSnap); break;        case formatIllustrator: translateObject = new(IllustratorSnap); break;		case formatClarisCAD: translateObject = new(ClarisCADExport); break;		case formatMacDraw: translateObject = new(MacDrawExport); break;		case format2DDXF: translateObject = new(DXF2DExport);break;		case format3DDXF: 			if(export == direction) translateObject = new(DXF3DExport);			else translateObject = new(DXF3DImport); 			break;		case formatFLIC: translateObject = new (ADeskAnimatorSnap); break;		case formatAVI: translateObject = new (AVISnap); break;		case formatPICS: translateObject = new(PICSSnap); break;		case formatQuickTime: translateObject = new(QuickTimeSnap);break;//		case formatVoyager: translateObject = new(VoyagerExport); break;		#if VRML_ANCHOR				// VRML-ABD PRO25		case formatVRML:			translateObject = new(VRMLExport);		// ABD PRO25 turned this back on, don't return			break;		#endif // VRML_ANCHOR		}				translateObject->cTranslateObject();	SetTitle(translateObject->GetTitle());	translateObject->GetRect(&r);		GetScreen(&sR);	cH = (sR.right-sR.left)>>1;	cV = (sR.bottom-sR.top)>>1;	lH = r.right-r.left;	lV = r.bottom-r.top;	r.left = cH - (lH>>1); 	r.right = r.left + lH; 	r.top = cV - (lV>>1); 	r.bottom = r.top + lV; 	cDialog(&r);	useOffscreen = TRUE;				translateObject->SetInterface(this);	translateObject->SetOptions(transPref);		Show();	if(result = Modal())		translateObject->GetResults(transPref);	translateObject->dTranslateObject();	translateObject = NULL;    // jca 12 Nov 93 Delete() is calling for an Update().  Very odd.	Delete();	return result;	}voidTranslateDialog::Update()	{	AppPreference	*realPref;	TranslatorPreference *transPref;	realPref = controller->GetPreference();	transPref = (TranslatorPreference*)realPref->GetPreference(preferTranslator);	if (translateObject)	// if we have anything to operate on		{    // this may be NULL; Windows sometimes calls an update of this after it's been destroyed.		translateObject->GetResults(transPref);		translateObject->SetOptions(transPref);			VDisplay(DRAW);		}    // otherwise, nothing to update.	}	/************************************************************************************* * *		Base Translator Object * ************************************************************************************/void TranslateObject::cTranslateObject() { }void TranslateObject::dTranslateObject()  { delete this; }void TranslateObject::SetInterface(V_Dialog *dialog) 	{ 	V_CtrlButton_Die	*button;	V_Array	*buttonGroup;	Rect	r,rDone, rCancel;		formatTitle = new(V_Text);	formatTitle->cItem();	formatTitle->SetRect(&layoutSpec[transTFormat].destRect);	dialog->AddItem(formatTitle);	GetRect(&r);#if MACINTOSH	rDone.bottom = r.bottom-D_EDGE;	rDone.top = rDone.bottom-D_BTNH;	rDone.right = r.right-D_EDGE;	rDone.left = rDone.right-D_BTNW;	rCancel.bottom = rDone.bottom;	rCancel.top = rDone.top;	rCancel.right = rDone.left-D_EDGE;	rCancel.left = rCancel.right-D_BTNW;#elif WINDOWS	rDone.bottom = r.bottom-D_EDGE;	rDone.top = rDone.bottom-D_BTNH;	rDone.left = r.right-(D_BTNW+D_BTNW+D_BTNSEP) >> 1;	rDone.right = rDone.left+D_BTNW;	rCancel.bottom = rDone.bottom;	rCancel.top = rDone.top;	rCancel.left = rDone.right+D_BTNSEP;    rCancel.right = rCancel.left+D_BTNW;#endif //WINDOWS	buttonGroup = new(V_Array);	buttonGroup->cArray(0,sizeof(V_CtrlButton_Die*),4);	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&rDone);	button->SetText(layoutSpec[transBDone].title);	button->SetFlag(TRUE);    button->SetGroup(buttonGroup);#if WINDOWS    button->SetCtrlNumber(IDOK);#endif	dialog->SetDefBtn(button);	dialog->AddItem(button);	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&rCancel);	button->SetText(layoutSpec[transBCancel].title);	button->SetFlag(FALSE);		button->SetGroup(buttonGroup);#if WINDOWS	button->SetCtrlNumber(IDCANCEL);#endif	dialog->AddItem(button);	}void TranslateObject::GetRect(Rect *r) 	{	r->top = r->left = 0;	r->bottom = TRANS_HEIGHT;	r->right = TRANS_WIDTH;	}char *TranslateObject::GetTitle()	{	return TXT_EMPTYSTRING;    }	void TranslateObject::GetResults(TranslatorPreference *masterPref) { }void TranslateObject::SetOptions(TranslatorPreference *masterPref) { }/************************************************************************************* * *		Snap2D Snaphot Object * ************************************************************************************/void Snap2D::SetContents(int cont) { contents = cont; }voidSnap2D::cTranslateObject()	{	TranslateObject::cTranslateObject();	contents = 0;	sizePopUp = NULL;	aspectH = NULL;	aspectV = NULL;	colorDepth = NULL;	grayscale = NULL;	radioColor = NULL;	radioGrayscale = NULL;	radioBW = NULL;	radioCmpOn = NULL;	radioCmpOff = NULL;	radioCmpLZW = NULL;       	// jca 8 aug 93.  for tiff compression	radioCmpPackBits = NULL;    radioCmpNone = NULL;	previewCheck = NULL;	radioBitmap = NULL;	radioObject = NULL;	}voidSnap2D::SetInterface(V_Dialog *dialog)	{	WalkController *controller;	Controller *pCtrl;	V_Window *window;	V_Text	*statText;	V_Array	*radioGroup;	char str[256];	TranslateObject::SetInterface(dialog);	if (contents & snapSize)		{		controller = (WalkController *)((TranslateDialog*)dialog)->controller;		pCtrl = controller->GetFrontController();		window = pCtrl->GetWindow(pCtrl->GetType());		statText = new(V_Text);		statText->cItem();		statText->SetRect(&layoutSpec[transTSize].destRect);		statText->SetText(layoutSpec[transTSize].title);		dialog->AddItem(statText);#if WINDOWS && V_AVI		if (contents & snapAVI)	// jca 10 Nov 93 {			{  	// we want the size to notify the compression stuff of changes.			// this can be improved.			sizePopUp = new(AVISizeMenu);            ((AVISizeMenu*)sizePopUp)->cItem();            }		else	// normal case#endif //WINDOWS && V_AVI        	{			sizePopUp = new(SizePopMenu);			sizePopUp->cItem();            }					// jca 10 Nov 93 }		sizePopUp->SetRect(&layoutSpec[transPSize].destRect);		sizePopUp->SetWindow(window);		dialog->AddItem(sizePopUp);		aspectH = new(TransText);		aspectH->cItem();		aspectH->SetRect(&(layoutSpec[transESizeH].destRect));		dialog->AddItem(aspectH);//		dialog->itemList->AddTabItem(aspectH);		statText = new(V_Text);		statText->cItem();		statText->SetRect(&layoutSpec[transSDot].destRect);		statText->SetText(layoutSpec[transSDot].title);	 	dialog->AddItem(statText);		aspectV = new(TransText);		aspectV->cItem();		aspectV->SetRect(&(layoutSpec[transESizeV].destRect));  	 	dialog->AddItem(aspectV);//		dialog->itemList->AddTabItem(aspectV);			sizePopUp->LinkText(aspectH,aspectV);#if WINDOWS		sizePopUp->FocusOn(); // this is a peculiarity of windows.  We want the size to be active.#endif		}	if (contents & snapColors)		{		statText = new(V_Text);		statText->cItem();		statText->SetRect(&layoutSpec[transTColorDepth].destRect);		statText->SetText(layoutSpec[transTColorDepth].title);		dialog->AddItem(statText);		if (contents & (snapColorPopUp|snapColorPopBMP))			{			if (snapColorPopUp & contents)				{				colorDepth = new(ColorDepthMenu);				colorDepth->cItem();                }			else				{				colorDepth = new(ColorDepthMenuBMP);				colorDepth->cItem();				}			colorDepth->SetRect(&layoutSpec[transPColorDepth].destRect);			dialog->AddItem(colorDepth);			if (contents & snapGrayscale)				{				grayscale = new(V_CtrlCheck);				grayscale->cItem();				grayscale->SetRect(&layoutSpec[transCColor].destRect);				grayscale->SetText(layoutSpec[transCColor].title);				dialog->AddItem(grayscale);				}			}		else			{			radioGroup = new(V_Array);			radioGroup->cArray(0,sizeof(V_CtrlRadio*),4);			radioColor = new(V_CtrlRadio);			radioColor->cItem();			radioColor->SetRect(&layoutSpec[transRColor].destRect);			radioColor->SetText(layoutSpec[transRColor].title);			radioColor->SetGroup(radioGroup);			dialog->AddItem(radioColor);			radioGrayscale = new(V_CtrlRadio);			radioGrayscale->cItem();			radioGrayscale->SetRect(&layoutSpec[transRGrayscale].destRect);			radioGrayscale->SetText(layoutSpec[transRGrayscale].title);			radioGrayscale->SetGroup(radioGroup);			dialog->AddItem(radioGrayscale);			if (contents & snapColor3)				{				radioBW = new(V_CtrlRadio);				radioBW->cItem();				radioBW->SetRect(&layoutSpec[transRBW].destRect);				radioBW->SetText(layoutSpec[transRBW].title);				radioBW->SetGroup(radioGroup);				dialog->AddItem(radioBW);            	}			}		}	if (contents & snapCompression)		{		statText = new(V_Text);		statText->cItem();		statText->SetRect(&layoutSpec[transTCompression].destRect);		statText->SetText(layoutSpec[transTCompression].title);		dialog->AddItem(statText);		radioGroup = new(V_Array);		radioGroup->cArray(0,sizeof(V_CtrlRadio*),4);		radioCmpOn = new(V_CtrlRadio);		radioCmpOn->cItem();		radioCmpOn->SetRect(&layoutSpec[transRCmpOn].destRect);		radioCmpOn->SetText(layoutSpec[transRCmpOn].title);		radioCmpOn->SetGroup(radioGroup);		dialog->AddItem(radioCmpOn);		radioCmpOff = new(V_CtrlRadio);		radioCmpOff->cItem();		radioCmpOff->SetRect(&layoutSpec[transRCmpOff].destRect);		radioCmpOff->SetText(layoutSpec[transRCmpOff].title);		radioCmpOff->SetGroup(radioGroup);		dialog->AddItem(radioCmpOff);		}	if (contents & snapTIFFCompression)            // jca 8 aug 93.  Tiff compression		{		statText = new(V_Text);		statText->cItem();		statText->SetRect(&layoutSpec[transTCompression].destRect);		statText->SetText(layoutSpec[transTCompression].title);		dialog->AddItem(statText);		radioGroup = new(V_Array);		radioGroup->cArray(0,sizeof(V_CtrlRadio*),4);		radioCmpLZW = new(V_CtrlRadio);		radioCmpLZW->cItem();		radioCmpLZW->SetRect(&layoutSpec[transRCmpLZW].destRect);		radioCmpLZW->SetText(layoutSpec[transRCmpLZW].title);		radioCmpLZW->SetGroup(radioGroup);		dialog->AddItem(radioCmpLZW);		radioCmpPackBits = new(V_CtrlRadio);		radioCmpPackBits->cItem();		radioCmpPackBits->SetRect(&layoutSpec[transRCmpPackBits].destRect);		radioCmpPackBits->SetText(layoutSpec[transRCmpPackBits].title);		radioCmpPackBits->SetGroup(radioGroup);		dialog->AddItem(radioCmpPackBits);		radioCmpNone = new(V_CtrlRadio);		radioCmpNone->cItem();		radioCmpNone->SetRect(&layoutSpec[transRCmpNone].destRect);		radioCmpNone->SetText(layoutSpec[transRCmpNone].title);		radioCmpNone->SetGroup(radioGroup);		dialog->AddItem(radioCmpNone);		}	if (contents & snapPreview)		{		previewCheck = new(V_CtrlCheck);		previewCheck->cItem();		previewCheck->SetRect(&layoutSpec[transCPreview].destRect);		previewCheck->SetText(layoutSpec[transCPreview].title);		dialog->AddItem(previewCheck);		}	if (contents & snapPICTFormat)		{		statText = new(V_Text);		statText->cItem();		statText->SetRect(&layoutSpec[transTPICTFmt].destRect);		statText->SetText(layoutSpec[transTPICTFmt].title);		dialog->AddItem(statText);		radioGroup = new(V_Array);		radioGroup->cArray(0,sizeof(V_CtrlRadio*),4);		radioBitmap = new(V_CtrlRadio);		radioBitmap->cItem();		radioBitmap->SetRect(&layoutSpec[transRBitmap].destRect);		radioBitmap->SetText(layoutSpec[transRBitmap].title);		radioBitmap->SetGroup(radioGroup);		dialog->AddItem(radioBitmap);		radioObject = new(V_CtrlRadio);		radioObject->cItem();		radioObject->SetRect(&layoutSpec[transRObject].destRect);		radioObject->SetText(layoutSpec[transRObject].title);		radioObject->SetGroup(radioGroup);		dialog->AddItem(radioObject);		}	}voidSnap2D::SetOptions(TranslatorPreference *transPref)	{	char	str[256];	TranslateObject::SetOptions(transPref);	if (contents & snapSize)		{		Point p;		sizePopUp->SetScreenType(transPref->screenSize);		if(screenCustom != transPref->screenSize)			sizePopUp->GetScreenSize(&p);		else			{			p.h = transPref->outputRect.right;			p.v = transPref->outputRect.bottom;			}			sprintf(str,"%i",p.h);		aspectH->SetText(str);		sprintf(str,"%i",p.v);		aspectV->SetText(str);		}   if (contents & snapColors)		{		if (contents & snapColorPopUp)        	{			colorDepth->SetColorDepth(transPref->outputColorDepth); 	 			if (contents & snapGrayscale) 				grayscale->SetValue(transPref->EPSColorFlag ? FALSE : TRUE); 					}		else if (contents & snapColorPopBMP)        	{			if (colorDepth2Bit == transPref->outputColorDepth)				transPref->outputColorDepth = colorDepth4Bit;			if (colorDepth16Bit == transPref->outputColorDepth)				transPref->outputColorDepth = colorDepth8Bit;			colorDepth->SetColorDepth(transPref->outputColorDepth);    			if (contents & snapGrayscale) 				grayscale->SetValue(transPref->EPSColorFlag ? FALSE : TRUE);					}		else			{			int color=FALSE,igray=FALSE,bw=FALSE;			if (contents & snapColor2)				{				radioColor->SetValue(transPref->EPSColorFlag ? TRUE : FALSE);                radioGrayscale->SetValue(transPref->EPSColorFlag ? FALSE : TRUE);				}			else				{				if (transPref->outputColorDepth <= 1) bw = TRUE;				else if (!transPref->EPSColorFlag) igray = TRUE;				else color = TRUE;				radioColor->SetValue(color);				radioGrayscale->SetValue(igray);			    radioBW->SetValue(bw);				}			}		}	if (contents & snapCompression)		{		radioCmpOn->SetValue(transPref->TIFFCompression ? TRUE : FALSE);	    radioCmpOff->SetValue(transPref->TIFFCompression ? FALSE : TRUE);		}	if (contents & snapTIFFCompression)  	// jca 8 aug 93.  tiff compression		{		radioCmpLZW->SetValue(transPref->TIFFCompression == TIFFLZW ? TRUE : FALSE);		radioCmpPackBits->SetValue(transPref->TIFFCompression == TIFFPackBits? TRUE : FALSE);		radioCmpNone->SetValue(transPref->TIFFCompression ? FALSE : TRUE);		}	if (contents & snapPreview)		previewCheck->SetValue(transPref->EPSPreviewFlag ? TRUE : FALSE);	if (contents & snapPICTFormat)		{		radioBitmap->SetValue(transPref->bitmapFlag ? TRUE : FALSE);	    radioObject->SetValue(transPref->bitmapFlag ? FALSE : TRUE);		}	}voidSnap2D::GetResults(TranslatorPreference *transPref)	{		char	str[256];	TranslateObject::GetResults(transPref);	if (contents & snapSize)		{		Point p;		int h,v;		transPref->screenSize = sizePopUp->GetScreenSize(&p);		h = transPref->outputRect.right;		aspectH->GetText(str);		sscanf(str,"%i",&h);		v = transPref->outputRect.bottom;		aspectV->GetText(str);		sscanf(str,"%i",&v);			if( h!=p.h || v!=p.v)			transPref->screenSize = screenCustom;				if(screenCustom == transPref->screenSize)			{			transPref->outputRect.left = 0;			transPref->outputRect.top = 0;			transPref->outputRect.right = h;			transPref->outputRect.bottom = v;			}			}    if (contents & snapColors)		{		if (contents & (snapColorPopUp|snapColorPopBMP))			{			transPref->outputColorDepth = colorDepth->GetColorDepth();			if (contents & snapGrayscale)				transPref->EPSColorFlag = !grayscale->GetValue();			}		else			{			if (contents & snapColor2)				transPref->EPSColorFlag = radioColor->GetValue();			else				{				if (radioColor->GetValue())					{					if (transPref->outputColorDepth <= 1)						transPref->outputColorDepth = 8;					transPref->EPSColorFlag = TRUE;					}				else if (radioGrayscale->GetValue())					{					if (transPref->outputColorDepth <= 1)						transPref->outputColorDepth = 8;					transPref->EPSColorFlag = FALSE;					}				else					{					transPref->outputColorDepth = 1;					transPref->EPSColorFlag = FALSE;			        }				}            }		}	if (contents & snapCompression)		transPref->TIFFCompression = radioCmpOn->GetValue();	if (contents & snapTIFFCompression)  	// jca 8 aug 93.  tiff compression		{		if (radioCmpLZW->GetValue()) transPref->TIFFCompression = TIFFLZW;		else if (radioCmpPackBits->GetValue()) transPref->TIFFCompression = TIFFPackBits;		else transPref->TIFFCompression = 0;    // no compression		}	if (contents & snapPreview)		transPref->EPSPreviewFlag = previewCheck->GetValue();	if (contents & snapPICTFormat)		transPref->bitmapFlag = radioBitmap->GetValue();	}/************************************************************************************* * *		PICT Snaphot Object * ************************************************************************************/void PICTSnap::GetRect(Rect *r) { *r = layoutSpec[transWSnapPICT].destRect; }char *PICTSnap::GetTitle() { return layoutSpec[transWSnapPICT].title; }voidPICTSnap::SetInterface(V_Dialog *dialog)	{	char str[256];    SetContents(snapSize|snapColorPopUp|snapPICTFormat);	Snap2D::SetInterface(dialog);	sprintf(str,"%s: %s",TXTD_SFORMAT,TXTM_PICT);	formatTitle->SetText(str);	}/************************************************************************************* * *		BMP Snaphot Object * ************************************************************************************/void BMPSnap::GetRect(Rect *r) { *r = layoutSpec[transWSnapBMP].destRect; }char *BMPSnap::GetTitle() { return layoutSpec[transWSnapBMP].title; }voidBMPSnap::SetInterface(V_Dialog *dialog)	{	char str[256];		SetContents(snapSize|snapColorPopBMP|snapGrayscale|snapCompression);	Snap2D::SetInterface(dialog);	sprintf(str,"%s: %s",TXTD_SFORMAT,TXTM_BMP);	formatTitle->SetText(str);	}/************************************************************************************* * *		TIFF Snaphot Object * ************************************************************************************/void TIFFSnap::GetRect(Rect *r) { *r = layoutSpec[transWSnapTIFF].destRect; }char *TIFFSnap::GetTitle() { return layoutSpec[transWSnapTIFF].title; }voidTIFFSnap::SetInterface(V_Dialog *dialog)	{	char str[256];	    SetContents(snapSize|snapColor3|snapTIFFCompression);	Snap2D::SetInterface(dialog);	sprintf(str,"%s: %s",TXTD_SFORMAT,TXTM_TIFF);	formatTitle->SetText(str);	}/************************************************************************************* * *		EPSF Snaphot Object * ************************************************************************************/void EPSFSnap::GetRect(Rect *r) { *r = layoutSpec[transWSnapEPSF].destRect; }char *EPSFSnap::GetTitle() { return layoutSpec[transWSnapEPSF].title; }voidEPSFSnap::SetInterface(V_Dialog *dialog)	{	char str[256];	    SetContents(snapSize|snapColor2|snapGrayscale|snapPreview);	Snap2D::SetInterface(dialog);	sprintf(str,"%s: %s",TXTD_SFORMAT,TXTM_EPS);	formatTitle->SetText(str);	}voidIllustratorSnap::SetInterface(V_Dialog *dialog)	{	char str[256];		EPSFSnap::SetInterface(dialog);	sprintf(str,"%s: %s",TXTD_SFORMAT,TXTM_ILLUS);	formatTitle->SetText(str);	}/************************************************************************************* * *		Time Based Translator Object * ************************************************************************************/	voidSnap2DTime::cTranslateObject()	{	Snap2D::cTranslateObject();	observer = NULL;	fromFrame = NULL;	toFrame = NULL;	smoothCheck = NULL;	rate = NULL;	duration = NULL;#if WINDOWS && V_AVI	compressionOps = NULL;            // jca 9 Nov 93#endif	}voidSnap2DTime::SetInterface(V_Dialog *dialog)	{	WalkController *controller;	V_Text	*statText;	Snap2D::SetInterface(dialog);	controller = (WalkController *)((TranslateDialog*)dialog)->controller;	observer = controller->observer;	if (contents & snapAVI)  		// jca 8 Nov 93 {		{	#if WINDOWS && V_AVI		statText = new(V_Text);		statText->cItem();		statText->SetRect(&layoutSpec[transSAVICompress].destRect);		statText->SetText(layoutSpec[transSAVICompress].title);		dialog->AddItem(statText);		compressionOps = new(AVICompressorMenu);		compressionOps->cItem();		compressionOps->AddItems();		// set the link between the size and the compression stuff		((AVISizeMenu *)sizePopUp)->SetCompressorLink(compressionOps);		dialog->AddItem(compressionOps);#endif // WINDOWS && V_AVI		}		// jca 8 Nov 93 }	if (contents & snapFrames)		{		statText = new(V_Text);		statText->cItem();		statText->SetRect(&layoutSpec[transTFrame].destRect);		statText->SetText(layoutSpec[transTFrame].title);		dialog->AddItem(statText);		fromFrame = new(TransText);		fromFrame->cItem();		fromFrame->SetRect(&(layoutSpec[transEFromFrame].destRect));		dialog->AddItem(fromFrame);//		dialog->itemList->AddTabItem(fromFrame);		statText = new(V_Text);		statText->cItem();		statText->SetRect(&layoutSpec[transSToFrame].destRect);		statText->SetText(layoutSpec[transSToFrame].title);		dialog->AddItem(statText);		toFrame = new(TransText);		toFrame->cItem();		toFrame->SetRect(&(layoutSpec[transEToFrame].destRect));		dialog->AddItem(toFrame);//		dialog->itemList->AddTabItem(toFrame);		smoothCheck = new(V_CtrlCheck);		smoothCheck->cItem();		smoothCheck->SetRect(&layoutSpec[transCSmooth].destRect);		smoothCheck->SetText(layoutSpec[transCSmooth].title);		dialog->AddItem(smoothCheck);		}	if (contents & snapRate)		{		statText = new(V_Text);		statText->cItem();		statText->SetRect(&layoutSpec[transSRate].destRect);		statText->SetText(layoutSpec[transSRate].title);		dialog->AddItem(statText);		rate = new(TransText);		rate->cItem();		rate->SetRect(&layoutSpec[transERate].destRect);		dialog->AddItem(rate);//        dialog->itemList->AddTabItem(rate);		duration = new(V_Text);		duration->cItem();		duration->SetRect(&layoutSpec[transSDuration].destRect);		duration->SetText(layoutSpec[transSDuration].title);		dialog->AddItem(duration);		}	}voidSnap2DTime::SetOptions(TranslatorPreference *transPref)	{	char	str[256];	Snap2D::SetOptions(transPref);	if (contents & snapAVI)  		// jca 8 Nov 93 {		{	#if WINDOWS && V_AVI		Rect 	rScr;        Point	pScr;		if(screenCustom != transPref->screenSize)        	{			sizePopUp->GetScreenSize(&pScr);			VSetRect(&rScr, 0, 0, pScr.h, pScr.v);            }		else			{			rScr = transPref->outputRect;			}		compressionOps->SetCompressorId(transPref->AVICompressorId);		compressionOps->EnablePossibleCompressors(&rScr, 8/* ELVIS transPref->outputColorDepth*/);#endif // WINDOWS && V_AVI		}		// jca 8 Nov 93 }	if (contents & snapFrames)		{		int num;		num = transPref->startFrame+1;		sprintf(str,"%i",num);		fromFrame->SetText(str);			num = transPref->endFrame+1;		sprintf(str,"%i",num);		toFrame->SetText(str);		smoothCheck->SetValue(transPref->smoothFlag ? TRUE : FALSE);		}	if (contents & snapRate)		{		int frames,fRate;        int minutes,seconds,tenths;		frames = transPref->endFrame-transPref->startFrame+1;		fRate = transPref->frameRate;		minutes = frames / (fRate * 60);        frames -= minutes * (fRate * 60);		seconds = frames / fRate;        frames -= seconds * fRate;        tenths = (frames * 10 + (fRate>>1)) / fRate;		sprintf(str,"%i",fRate);		rate->SetText(str);		sprintf(str,"%s   (%d:%02d.%d %s)",layoutSpec[transSDuration].title,			minutes,seconds,tenths,TXTD_MINUTES);		duration->SetText(str);		}	}voidSnap2DTime::GetResults(TranslatorPreference *transPref)	{		char	str[256];	Snap2D::GetResults(transPref);	if (contents & snapAVI)  		// jca 8 Nov 93 {		{	#if WINDOWS && V_AVI		transPref->AVICompressorId = compressionOps->GetCompressorId();		transPref->AVICompressorQuality = compressionOps->GetCompressorQuality();#endif // WINDOWS && V_AVI		}		// jca 8 Nov 93 }	if (contents & snapFrames)		{		int	maxFrame,frame;		maxFrame = observer->path->ALength();	        frame = transPref->startFrame+1;		fromFrame->GetText(str);		sscanf(str,"%i", &frame);		transPref->startFrame = frame-1;	        frame = transPref->endFrame+1;		toFrame->GetText(str);		sscanf(str,"%i", &frame);		transPref->endFrame = frame-1;			if(transPref->endFrame >= maxFrame) transPref->endFrame = maxFrame-1;		if(transPref->startFrame >= maxFrame) transPref->startFrame = maxFrame-1;		if(transPref->endFrame < 0) transPref->endFrame = 0;		if(transPref->startFrame < 0) transPref->startFrame = 0;		if(transPref->endFrame < transPref->startFrame)			transPref->endFrame = transPref->startFrame;		transPref->smoothFlag = smoothCheck->GetValue();		}	if (contents & snapRate)		{		int fRate;		fRate = transPref->frameRate;		rate->GetText(str);		sscanf(str,"%i", &fRate);		transPref->frameRate = fRate;		if(transPref->frameRate < 1) transPref->frameRate = 1;        /* JOEBOB -- format specific limits */        }	}/************************************************************************************* * *		PICS Snap Object *		Quicktime Snap Object *		Animator Pro Snap Object * ************************************************************************************/	void PICSSnap::GetRect(Rect *r) { *r = layoutSpec[transWSnapPICS].destRect; }char *PICSSnap::GetTitle() { return layoutSpec[transWSnapPICS].title; }voidPICSSnap::SetInterface(V_Dialog *dialog) 	{	char str[256];    SetContents(snapSize|snapColorPopUp|snapFrames);	Snap2DTime::SetInterface(dialog);	sprintf(str,"%s: %s",TXTD_MFORMAT,TXTM_PICS);	formatTitle->SetText(str);	}void QuickTimeSnap::GetRect(Rect *r) { *r = layoutSpec[transWSnapQTime].destRect; }char *QuickTimeSnap::GetTitle() { return layoutSpec[transWSnapQTime].title; }voidQuickTimeSnap::SetInterface(V_Dialog *dialog) 	{	char str[256];	SetContents(snapSize|snapColorPopUp|snapFrames/*|snapRate -- Not yet... jca*/);	Snap2DTime::SetInterface(dialog);	sprintf(str,"%s: %s",TXTD_MFORMAT,TXTM_QTIME);	formatTitle->SetText(str);	}void ADeskAnimatorSnap::GetRect(Rect *r) { *r = layoutSpec[transWSnapAnim].destRect; }char *ADeskAnimatorSnap::GetTitle() { return layoutSpec[transWSnapAnim].title; }voidADeskAnimatorSnap::SetInterface(V_Dialog *dialog)	{	char str[256];    SetContents(snapSize|snapColor2|snapFrames|snapRate);	Snap2DTime::SetInterface(dialog);	sprintf(str,"%s: %s",TXTD_MFORMAT,TXTM_FLIC);	formatTitle->SetText(str);	}void AVISnap::GetRect(Rect *r) { *r = layoutSpec[transWSnapAnim].destRect; }char *AVISnap::GetTitle() { return layoutSpec[transWSnapAnim].title; }voidAVISnap::SetInterface(V_Dialog *dialog)	{	char str[256];	SetContents(snapSize|snapFrames|snapRate|snapAVI);	Snap2DTime::SetInterface(dialog);	sprintf(str,"%s: %s",TXTD_MFORMAT,TXTM_AVI);	formatTitle->SetText(str);	}/************************************************************************************* * *		Export 2D Translator Object * ************************************************************************************/voidExport2D::SetInterface(V_Dialog *dialog)	{	V_Text	*statText;		TranslateObject::SetInterface(dialog);			view = new(ViewPopMenu);	view->cItem();	view->SetRect(&layoutSpec[transPAxis].destRect);	dialog->AddItem(view);		statText = new(V_Text);	statText->cItem();	statText->SetRect(&layoutSpec[transTAxis].destRect);	statText->SetText(layoutSpec[transTAxis].title);	dialog->AddItem(statText);	}voidExport2D::SetOptions(TranslatorPreference	*transPref)	{		TranslateObject::SetOptions(transPref);	view->SetViewVector(transPref->exportView);	}	voidExport2D::GetResults(TranslatorPreference	*transPref)	{		TranslateObject::GetResults(transPref);	transPref->exportView = view->GetViewVector();	}	/************************************************************************************* * *		Claris Export Object * ************************************************************************************/void ClarisExport::GetRect(Rect *r) { *r = layoutSpec[transWExpClaris].destRect; }char *ClarisExport::GetTitle() { return layoutSpec[transWExpClaris].title; }voidClarisExport::SetInterface(V_Dialog *dialog)	{	V_Text  *statText;			Export2D::SetInterface(dialog);		fillPop = new(FillPopMenu);	fillPop->cItem();	fillPop->SetRect(&layoutSpec[transPFill].destRect);	dialog->AddItem(fillPop);		statText = new(V_Text);	statText->cItem();	statText->SetRect(&layoutSpec[transTAxis].destRect);	statText->SetText(layoutSpec[transTAxis].title);	dialog->AddItem(statText);	statText = new(V_Text);	statText->cItem();	statText->SetRect(&layoutSpec[transTFill].destRect);	statText->SetText(layoutSpec[transTFill].title);	dialog->AddItem(statText);	frameBlack = new(V_CtrlCheck);	frameBlack->cItem();	frameBlack->SetRect(&layoutSpec[transCFrBlack].destRect);	frameBlack->SetText(layoutSpec[transCFrBlack].title);	dialog->AddItem(frameBlack);	}voidClarisExport::SetOptions(TranslatorPreference	*transPref)	{	Export2D::SetOptions(transPref);	fillPop->SetFillType(transPref->CLARISFillType);	frameBlack->SetValue(transPref->frameBlack ? TRUE : FALSE);	}	voidClarisExport::GetResults(TranslatorPreference	*transPref)	{		Export2D::GetResults(transPref);		transPref->frameBlack = frameBlack->GetValue();	transPref->CLARISFillType = fillPop->GetFillType();	}	/************************************************************************************* * *		MacDraw Export Object *		ClarisCAD Export Object * ************************************************************************************/voidMacDrawExport::SetInterface(V_Dialog *dialog)	{	char str[256];	ClarisExport::SetInterface(dialog);	sprintf(str,"%s: %s",TXTD_XFORMAT,TXTM_MACDRAWII);	formatTitle->SetText(str);	}voidClarisCADExport::SetInterface(V_Dialog *dialog)	{	char str[256];	ClarisExport::SetInterface(dialog);	sprintf(str,"%s: %s",TXTD_XFORMAT,TXTM_CLARISCAD);	formatTitle->SetText(str);	}/************************************************************************************* * *		DXF Export Object * ************************************************************************************/voidDXFExport::SetInterface(V_Dialog *dialog)	{	V_Text	*statText;	V_Array		*radioGroup;		statText = new(V_Text);	statText->cItem();	statText->SetRect(&layoutSpec[transTLineTerm].destRect);	statText->SetText(layoutSpec[transTLineTerm].title);	dialog->AddItem(statText);	radioGroup = new(V_Array);	radioGroup->cArray(0,sizeof(V_CtrlRadio*),4);	radioLTMac = new(V_CtrlRadio);	radioLTMac->cItem();	radioLTMac->SetRect(&layoutSpec[transTLineTermMac].destRect);	radioLTMac->SetText(layoutSpec[transTLineTermMac].title);	radioLTMac->SetGroup(radioGroup);	dialog->AddItem(radioLTMac);	radioLTPC = new(V_CtrlRadio);	radioLTPC->cItem();	radioLTPC->SetRect(&layoutSpec[transTLineTermPC].destRect);	radioLTPC->SetText(layoutSpec[transTLineTermPC].title);	radioLTPC->SetGroup(radioGroup);	dialog->AddItem(radioLTPC);	radioLTUnix = new(V_CtrlRadio);	radioLTUnix->cItem();	radioLTUnix->SetRect(&layoutSpec[transTLineTermUnix].destRect);	radioLTUnix->SetText(layoutSpec[transTLineTermUnix].title);	radioLTUnix->SetGroup(radioGroup);	dialog->AddItem(radioLTUnix);	statText = new(V_Text);	statText->cItem();	statText->SetRect(&layoutSpec[transTColor].destRect);	statText->SetText(layoutSpec[transTColor].title);	dialog->AddItem(statText);	radioGroup = new(V_Array);	radioGroup->cArray(0,sizeof(V_CtrlRadio*),4);	radioCLRObject = new(V_CtrlRadio);	radioCLRObject->cItem();	radioCLRObject->SetRect(&layoutSpec[transRColorObj].destRect);	radioCLRObject->SetText(layoutSpec[transRColorObj].title);	radioCLRObject->SetGroup(radioGroup);	dialog->AddItem(radioCLRObject);	radioCLRLayer = new(V_CtrlRadio);	radioCLRLayer->cItem();	radioCLRLayer->SetRect(&layoutSpec[transRColorLayer].destRect);	radioCLRLayer->SetText(layoutSpec[transRColorLayer].title);	radioCLRLayer->SetGroup(radioGroup);	dialog->AddItem(radioCLRLayer);	}voidDXFExport::SetOptions(TranslatorPreference	*transPref)	{	TranslateObject::SetOptions(transPref);		radioLTUnix->SetValue((lineTermUNIX==transPref->exportLineMode) ? TRUE : FALSE);	radioLTPC->SetValue((lineTermPC==transPref->exportLineMode) ? TRUE : FALSE);	radioLTMac->SetValue((lineTermMac==transPref->exportLineMode) ? TRUE : FALSE);	radioCLRObject->SetValue((transPref->DXFobjColor)  ? TRUE : FALSE);	radioCLRLayer->SetValue((transPref->DXFobjColor)  ? FALSE : TRUE);	}	voidDXFExport::GetResults(TranslatorPreference	*transPref)	{		TranslateObject::GetResults(transPref);	if(radioLTMac->GetValue())transPref->exportLineMode = lineTermMac;	else if(radioLTPC->GetValue())transPref->exportLineMode = lineTermPC;	else if(radioLTUnix->GetValue())transPref->exportLineMode = lineTermUNIX;	transPref->DXFobjColor = radioCLRObject->GetValue();	}/************************************************************************************* * *		DXF 2D Export Object * ************************************************************************************/void DXF2DExport::GetRect(Rect *r) { *r = layoutSpec[transWExpDXF2D].destRect; }char *DXF2DExport::GetTitle() { return layoutSpec[transWExpDXF2D].title; }voidDXF2DExport::SetInterface(V_Dialog *dialog)	{	V_Text	*statText;	char	str[256];		TranslateObject::SetInterface(dialog);		sprintf(str,"%s: %s",TXTD_XFORMAT,TXTM_DXF2D);	formatTitle->SetText(str);		view = new(ViewPopMenu);	view->cItem();	view->SetRect(&layoutSpec[transPAxis].destRect);	dialog->AddItem(view);	DXFExport::SetInterface(dialog);	statText = new(V_Text);	statText->cItem();	statText->SetRect(&layoutSpec[transTAxis].destRect);	statText->SetText(layoutSpec[transTAxis].title);	dialog->AddItem(statText);#if WINDOWS	view->FocusOn();#endif	}voidDXF2DExport::SetOptions(TranslatorPreference	*transPref)	{	DXFExport::SetOptions(transPref);	view->SetViewVector(transPref->exportView);	}	voidDXF2DExport::GetResults(TranslatorPreference	*transPref)	{		DXFExport::GetResults(transPref);	transPref->exportView = view->GetViewVector();	}/************************************************************************************* * *		DXF 3D Export Object * ************************************************************************************/void DXF3DExport::GetRect(Rect *r) { *r = layoutSpec[transWExpDXF3D].destRect; }char *DXF3DExport::GetTitle() { return layoutSpec[transWExpDXF3D].title; }voidDXF3DExport::SetInterface(V_Dialog *dialog)	{	V_Array	*radioGroup;	V_Text	*statText;	char	str[256];	long	where;		TranslateObject::SetInterface(dialog);		sprintf(str,"%s: %s",TXTD_XFORMAT,TXTM_DXF3D);	formatTitle->SetText(str);	statText = new(V_Text);	statText->cItem();	statText->SetRect(&layoutSpec[transTSurface].destRect);	statText->SetText(layoutSpec[transTSurface].title);	dialog->AddItem(statText);	radioGroup = new(V_Array);	radioGroup->cArray(0,sizeof(V_CtrlRadio*),4);		radioSTLine = new(V_CtrlRadio);	radioSTLine->cItem();	radioSTLine->SetRect(&layoutSpec[transRSurfLine].destRect);	radioSTLine->SetText(layoutSpec[transRSurfLine].title);	radioSTLine->SetGroup(radioGroup);	dialog->AddItem(radioSTLine);	radioSTFace = new(V_CtrlRadio);	radioSTFace->cItem();	radioSTFace->SetRect(&layoutSpec[transRSurfFace].destRect);	radioSTFace->SetText(layoutSpec[transRSurfFace].title);	radioSTFace->SetGroup(radioGroup);	dialog->AddItem(radioSTFace);	DXFExport::SetInterface(dialog);	extrudeBox = new(V_CtrlCheck);	extrudeBox->cItem();	extrudeBox->SetRect(&layoutSpec[transCExtrude].destRect);	extrudeBox->SetText(layoutSpec[transCExtrude].title);	dialog->AddItem(extrudeBox);	}voidDXF3DExport::SetOptions(TranslatorPreference	*transPref)	{	DXFExport::SetOptions(transPref);	extrudeBox->SetValue(transPref->DXFextr ? TRUE : FALSE);	if (exportLine == transPref->DXFsurf)    	{		radioSTLine->SetValue(TRUE);#if WINDOWS		radioSTLine->FocusOn();		// set the focus#endif //WINDOWS		}	else   radioSTLine->SetValue(FALSE);	if (exportFace == transPref->DXFsurf)		{		radioSTFace->SetValue(TRUE);#if WINDOWS		radioSTFace->FocusOn();#endif //WINDOWS		}	else	radioSTFace->SetValue(FALSE);	}	voidDXF3DExport::GetResults(TranslatorPreference	*transPref)	{		DXFExport::GetResults(transPref);	transPref->DXFextr = extrudeBox->GetValue() ? TRUE : FALSE;	transPref->DXFsurf = radioSTLine->GetValue() ? exportLine : exportFace;	}/************************************************************************************* * *		DXF 3D Import Object * ************************************************************************************/void DXF3DImport::GetRect(Rect *r) { *r = layoutSpec[transWImpDXF3D].destRect; }char *DXF3DImport::GetTitle() { return layoutSpec[transWImpDXF3D].title; }voidDXF3DImport::SetInterface(V_Dialog *dialog)	{	V_Text	*statText;	char	str[256];		TranslateObject::SetInterface(dialog);	sprintf(str,"%s: %s",TXTD_IFORMAT,TXTM_DXF3D);	formatTitle->SetText(str);	patch = new(V_CtrlCheck);	patch->cItem();	patch->SetRect(&(layoutSpec[importCPatch].destRect));	patch->SetText(layoutSpec[importCPatch].title);	dialog->AddItem(patch);	nonConvex = new(V_CtrlCheck);	nonConvex->cItem();	nonConvex->SetRect(&(layoutSpec[importCNonConvex].destRect));	nonConvex->SetText(layoutSpec[importCNonConvex].title);	dialog->AddItem(nonConvex);	degenerate = new(V_CtrlCheck);	degenerate->cItem();	degenerate->SetRect(&(layoutSpec[importCDegenerate].destRect));	degenerate->SetText(layoutSpec[importCDegenerate].title);	dialog->AddItem(degenerate);	orphan = new(V_CtrlCheck);	orphan->cItem();	orphan->SetRect(&(layoutSpec[importCOrphan].destRect));	orphan->SetText(layoutSpec[importCOrphan].title);	dialog->AddItem(orphan);	}voidDXF3DImport::SetOptions(TranslatorPreference	*transPref)	{	TranslateObject::SetOptions(transPref);	orphan->SetValue(IMPORT_ORPHANS&transPref->importFlag ? TRUE : FALSE);	degenerate->SetValue(IMPORT_DEGENERATE&transPref->importFlag ? TRUE : FALSE);	nonConvex->SetValue(IMPORT_NONCONVEX&transPref->importFlag ? TRUE : FALSE);	patch->SetValue(IMPORT_PATCH&transPref->importFlag ? TRUE : FALSE);	}	voidDXF3DImport::GetResults(TranslatorPreference	*transPref)	{		short	flag;	TranslateObject::GetResults(transPref);	flag = 0;	if(patch->GetValue())flag |= IMPORT_PATCH;	if(nonConvex->GetValue())flag |= IMPORT_NONCONVEX;	if(degenerate->GetValue())flag |= IMPORT_DEGENERATE;	if(orphan->GetValue())flag |= IMPORT_ORPHANS;	transPref->importFlag = flag;	}/************************************************************************************* * *		Virtus Voyager Export Object * ************************************************************************************/void VoyagerExport::GetRect(Rect *r) { *r = layoutSpec[transWVoyager].destRect; }char *VoyagerExport::GetTitle() { return layoutSpec[transWVoyager].title; }#if 0voidExportVoyager::SetInterface(V_Dialog *dialog)	{	AppPreference *appPref;	TranslatorPreference	*transPref;	V_StatText	*statText;	V_Array		*cluster;	char str[256];	DialogExport::SetInterface(dialog);	sprintf(str,"%s %s",TXTD_XFORMAT,TXTM_VOYAGER);	formatTitle->SetText(str);	appPref = controller->GetPreference();	transPref = appPref->GetPreference(preferTranslator);	statText = new(V_StatText);	statText->cStatText(dialog, &(DiagLoc[exportTCredits]), TXTD_CREDITS, D_TEXT_JUST, D_TEXT_FONT, D_TEXT_FACE, D_TEXT_SIZE);	if (transPref->pictFile != NULL)		transPref->VerifyPictFile();	credits = new(CreditsPopMenu);	credits->ctheMenu(D_TEXT_FONT,D_TEXT_FACE,D_TEXT_SIZE);	credits->SetCreditType(transPref->creditType);	credits->SetFile(transPref->pictFile, FALSE);	credits->SetText(transPref->text, FALSE);	dialog->AddMenuPop(credits);	preview = new(CreditsPreviewButton);	preview->cCtrlButton(dialog, &(DiagLoc[exportBPreview]), TXTD_PREVIEW);	preview->SetMenu(credits);	statText = new(V_StatText);	statText->cStatText(dialog, &(DiagLoc[exportTMode]), TXTD_MODE, D_TEXT_JUST, D_TEXT_FONT, D_TEXT_FACE, D_TEXT_SIZE);	cluster = NIL;	novice = new(V_CtrlRadio);	novice->cCtrlRadio(dialog, &(DiagLoc[exportRNovice]),TXTD_NOVICE, transPref->noviceMode, &cluster);	pro = new(V_CtrlRadio);	pro->cCtrlRadio(dialog, &(DiagLoc[exportRPro]), TXTD_PRO, !transPref->noviceMode, &cluster);	}voidExportVoyager::SetOptions(TranslatorPreference	*transPref)	{	TranslateObject::SetOptions(transPref);	orphan->SetValue(IMPORT_ORPHANS&transPref->importFlag ? TRUE : FALSE);	degenerate->SetValue(IMPORT_DEGENERATE&transPref->importFlag ? TRUE : FALSE);	nonConvex->SetValue(IMPORT_NONCONVEX&transPref->importFlag ? TRUE : FALSE);	patch->SetValue(IMPORT_PATCH&transPref->importFlag ? TRUE : FALSE);	}	voidExportVoyager::GetResults(TranslatorPreference	*transPref)	{		short	flag;	TranslateObject::GetResults(transPref);	flag = 0;	if(patch->GetValue())flag |= IMPORT_PATCH;	if(nonConvex->GetValue())flag |= IMPORT_NONCONVEX;	if(degenerate->GetValue())flag |= IMPORT_DEGENERATE;	if(orphan->GetValue())flag |= IMPORT_ORPHANS;	transPref->importFlag = flag;	}voidExportVoyager::GetResults()	{	AppPreference *appPref;	TranslatorPreference	*transPref;	V_File *f;	V_Array *t;	appPref = controller->GetPreference();	transPref = appPref->GetPreference(preferTranslator);	transPref->creditType = credits->GetCreditType();	transPref->noviceMode = (novice->GetControlValue() ? TRUE : FALSE);	if (transPref->creditType == creditPICT)		{		f = credits->GetFile(TRUE);		if (transPref->pictFile != NULL && transPref->pictFile != f)			transPref->pictFile->dFile();		transPref->pictFile = f;		}	else if (transPref->pictFile != NULL)		{		transPref->pictFile->dFile();		transPref->pictFile = NULL;		}		if (transPref->creditType == creditForm)		{		t = credits->GetText(TRUE);		if (transPref->text != NULL && transPref->text != t)			transPref->text->dArray();		transPref->text = t;		}	else if (transPref->text != NULL)		{		transPref->text->dArray();		transPref->text = NULL;		}	}#endif/************************************************************************************* * *		PopUp definitions * ************************************************************************************/voidViewPopMenu::AddItems()	{	Append(TXTM_VTOP);	Append(TXTM_VBOTTOM);	Append(TXTM_VFRONT);	Append(TXTM_VBACK);	Append(TXTM_VLEFT);	Append(TXTM_VRIGHT);	}	Point3DFFixedViewPopMenu::GetViewVector()	{	Point3DFFixed viewVector;		switch(GetValue())		{		case viewPopTop:	viewVector = topViewVector; 	break;		case viewPopBottom:	viewVector = bottomViewVector; 	break;		case viewPopFront: 	viewVector = frontViewVector;  	break;		case viewPopBack:	viewVector = backViewVector;  	break;		case viewPopLeft:	viewVector = leftViewVector; 	break;		case viewPopRight: 	viewVector = rightViewVector;	break;		}	return viewVector;	}voidViewPopMenu::SetViewVector(Point3DFFixed newView)	{		if(!FFZero(newView.x))		{		if(GRTR ==FFLogic(newView.x,FFZero)) SetValue(viewPopRight);		else SetValue(viewPopLeft);		}	else		{		if(!FFZero(newView.y))			{			if(GRTR ==FFLogic(newView.y,FFZero))SetValue(viewPopBack);			else SetValue(viewPopFront);			}		else			{			if(GRTR ==FFLogic(newView.z,FFZero)) SetValue(viewPopTop);			else SetValue(viewPopBottom);			}		}	}voidFillPopMenu::AddItems()	{	Append(TXTD_FILLNONE);	Append(TXTD_FILLOBJECT);	Append(TXTD_FILLWHITE);	}voidFillPopMenu::SetFillType(int newType)	{	switch(newType)		{		case CLARISFillNone:	SetValue(menuFillNone); break;		case CLARISFillObject:	SetValue(menuFillObject); break;		case CLARISFillWhite:	SetValue(menuFillWhite); break;		}	}	intFillPopMenu::GetFillType()	{	int result;	switch(GetValue())		{		case menuFillNone:	result = CLARISFillNone; break;		case menuFillObject:result = CLARISFillObject;  break;		case menuFillWhite:	result = CLARISFillWhite;  break;		}	return result;	}	voidColorDepthMenu::AddItems()	{	Append(TXTD_1BIT);	if(0!=MainDepth())		{		Append(TXTD_2BIT);		Append(TXTD_4BIT);		Append(TXTD_8BIT);		Append(TXTD_16BIT);		Append(TXTD_32BIT);        }	}voidColorDepthMenu::SetColorDepth(int cD)	{	switch(cD)		{		case 0: 		case 1:SetValue(colorDepth1Bit); break;		case 2:SetValue(colorDepth2Bit); break;		case 4:SetValue(colorDepth4Bit); break;		case 8:SetValue(colorDepth8Bit); break;		case 16:SetValue(colorDepth16Bit); break;		case 32:SetValue(colorDepth32Bit); break;		}	}intColorDepthMenu::GetColorDepth()	{	int result;	switch(GetValue())		{		case colorDepth1Bit:	result = 1; break;		case colorDepth2Bit:	result = 2; break;		case colorDepth4Bit:	result = 4; break;		case colorDepth8Bit:	result = 8; break;		case colorDepth16Bit:	result = 16; break;		case colorDepth32Bit:	result = 32; break;		}	return result;	}voidColorDepthMenuBMP::AddItems()	{	Append(TXTD_1BIT);	if(0!=MainDepth())		{		Append(TXTD_4BIT);		Append(TXTD_8BIT);		Append(TXTD_32BIT);        }	}voidColorDepthMenuBMP::SetColorDepth(int cD)	{	switch(cD)		{		case 0: 		case 1:SetValue(1); break;    // colorDepth1Bit		case 4:SetValue(2); break;    // colorDepth4Bit		case 8:SetValue(3); break;    // colorDepth8Bit		case 32:SetValue(4); break;  // colorDepth32Bit		}	}intColorDepthMenuBMP::GetColorDepth()	{	int result;	switch(GetValue())		{		case 1: result = 1; break;	//colorDepth1Bit		case 2: result = 4; break;	//colorDepth4Bit		case 3: result = 8; break;	//colorDepth8Bit		case 4: result = 32; break;	//colorDepth32Bit		}	return result;	}void SizePopMenu::SetWindow(V_Window *w) { window = w; }void SizePopMenu::LinkText(TransText *h,TransText *v) { horzSize = h; vertSize = v; }voidSizePopMenu::AddItems()	{#if MACINTOSH	Append(TXTC_9SCR);	Append(TXTC_12SCR);	Append(TXTC_13SCR);	Append(TXTC_SCREEN);	Append(TXTC_WINDOWSCR);	AppendSeparator();		// ABD WILLIAMS MERGE11 9/11/93	Append(TXTC_CUSTOMSCR);#elif WINDOWS	Append(TXTC_320SCR);	Append(TXTC_640SCR);	Append(TXTC_800SCR);	Append(TXTC_1024SCR);	Append(TXTC_SCREEN);	Append(TXTC_WINDOWSCR);	Append(TXTC_CUSTOMSCR);#endif //WINDOWS	}voidSizePopMenu::Action()	{	char str[256];	Point p;	GetScreenSize(&p);	sprintf(str,"%i",p.h);	if(horzSize)horzSize->SetText(str);	sprintf(str,"%i",p.v);	if(vertSize)vertSize->SetText(str);    V_PopMenu::Action();	}intSizePopMenu::GetScreenSize(Point *p)	{	char str[256];	Point cPt;	int type;    long tmp_long;	// ABD JAN95		switch(GetValue())		{#if MACINTOSH		case menuScreen9: type = screen9; break;		case menuScreen12: type = screen12; break;		case menuScreen13: type = screen13; break;#elif WINDOWS		case menuScreen320x200: type = screen320x200; break;		case menuScreen640x480: type = screen640x480; break;		case menuScreen800x600: type = screen800x600; break;        case menuScreen1024x768: type = screen1024x768; break;#endif //WINDOWS		case menuScreenFull: type = screenFull; break;		case menuScreenWindow: type = screenWindow;  break;		case menuScreenCustom: 		default:			type = screenCustom;			str[0]=0;			cPt=PtZero;			if(horzSize)horzSize->GetText(str);			sscanf(str,"%ld",&tmp_long);        // ABD JAN95			cPt.h = (short)tmp_long;            // ABD JAN95			if(vertSize)vertSize->GetText(str);			sscanf(str,"%ld",&tmp_long);        // ABD JAN95			cPt.v = (short)tmp_long;			// ABD JAN95			*p = cPt; 			break;		}	ScreenSize(type,p,window);	return type;	}	voidSizePopMenu::SetScreenType(int sT)	{	switch(sT)		{#if MACINTOSH		case screen9:SetValue(menuScreen9); break;		case screen12:SetValue(menuScreen12); break;		case screen13:SetValue(menuScreen13); break;#elif WINDOWS		case screen320x200:SetValue(menuScreen320x200); break;		case screen640x480:SetValue(menuScreen640x480); break;		case screen800x600:SetValue(menuScreen800x600); break;        case screen1024x768:SetValue(menuScreen1024x768); break;#endif //WINDOWS		case screenFull:SetValue(menuScreenFull); break;		case screenWindow:SetValue(menuScreenWindow); break;		case screenCustom:SetValue(menuScreenCustom); break;		}	}	// jca 9 Nov 93 -- Do something for the avi compressors {#if WINDOWS && V_AVIvoid AVISizeMenu::cItem(void){	V_PopMenu::cItem();    aviMenu = NULL;}void AVISizeMenu::Action(void){	if (aviMenu)		{		Rect r;		Point p;		GetScreenSize(&p);		r.left = r.top = 0;		r.right = p.h; r.bottom = p.v;		aviMenu->EnablePossibleCompressors(&r, 8 /* ELVIS -- this should be a color value from the prefs */);		}    SizePopMenu::Action();}void AVISizeMenu::SetCompressorLink(AVICompressorMenu *theAviMenu)	{	aviMenu = theAviMenu;	}void AVICompressorMenu::cItem(void){	V_PopMenu::cItem();	compressorList = new(V_Array);	compressorList->cArray(0, sizeof(AVICompressorCodec), 4);	FindVideoCodecs(compressorList);	// find the video compressor list}void AVICompressorMenu::dItem(void){	compressorList->dArray();}void AVICompressorMenu::AddItems(void){	AVICompressorCodec *aviCC;  	int i;	                    	Append(NO_AVI_COMPRESSION);   	// step one... put in the default compressor	aviCC = (AVICompressorCodec *)compressorList->Use();	for (i = 0; i < compressorList->ALength(); i++)	{		if (aviCC[i].works == TRUE)			Append(aviCC[i].ic.szDescription);	}	compressorList->Unuse();	SetRect(&layoutSpec[transPAVICompress].destRect);	SetValue(1);    // this is the default, right?}ULong AVICompressorMenu::GetCompressorId(void){	AVICompressorCodec 	*aviCCPtr;	int i, currentChoice, done, trueCount;	ULong theChosenOne = 0;	trueCount = 0;	currentChoice = (GetValue()-1);  // values are from 1 to n, not 0 to n-1 (plus, entry 0 is not in the v_Array)	aviCCPtr = (AVICompressorCodec *)compressorList->Use();	if (currentChoice >= 0)		{		for (i = 0, done = 0; !done && i < compressorList->ALength(); i++)			{			if (aviCCPtr[i].works == TRUE)				trueCount++;   // count of the number of "TRUE"s we've hit			if (trueCount == currentChoice)				{				done = TRUE;				theChosenOne = aviCCPtr[i].ic.fccHandler;				}             }		}	compressorList->Unuse();	return(theChosenOne);}int AVICompressorMenu::SetCompressorId(ULong id){	AVICompressorCodec 	*aviCCPtr;    int newCount, i, done;	int which = 1;	if (id != 0)		{		newCount = 1;		aviCCPtr = (AVICompressorCodec *)compressorList->Use();		for (i = 0, done = 0; !done && i < compressorList->ALength(); i++)			{			if (id == aviCCPtr[i].ic.fccHandler)				{    // this is the right item				if (aviCCPtr[i].works == FALSE)					{      // this *was* the right item					char str[256];					sprintf(str, AVI_DRIVER_DOESNT_SUPPORT, aviCCPtr[i].ic.szDescription);					AlertMessage(str);					done = 1;					}				else					{   	// this will still be the right item					which = newCount+1;                    done = 1;					}				}			else				{				if (aviCCPtr[i].works != FALSE)                    newCount++;	// this the count of things in the new list				// else, don't worry.  Be happy.				}			}		compressorList->Unuse();        }	else		which = 1;	SetValue(which);    return(which);}int AVICompressorMenu::GetCompressorQuality(void){	AVICompressorCodec 	aviCC;	int quality = -1;	int which;	which = GetValue();    which--;	// "No Compression" is not a compressor	if (which > 0)		{		compressorList->Get(which-1, &aviCC);		quality = GetRecommendedQuality(&aviCC);		}	return(quality);}void AVICompressorMenu::EnablePossibleCompressors(Rect *r, int d){	ULong theId;    theId = GetCompressorId();	if (CanCodecsCompressVideo(compressorList, r, d))	// returns true if things have changed		{		if(NULL != theControl)			SendMessage(theControl,CB_RESETCONTENT,0,0);  // reset the control contents		AddItems();		SetCompressorId(theId);		}	// else, the compressor list did not change, so we're fine.}#endif // WINDOWS && V_AVI// jca 9 Nov 93 -- Do something for the avi compressors }#if 0voidCreditsPopMenu::ctheMenu(int font,int face,int size)	{	PopMenu::ctheMenu(font,face,size);	SetRect(&DiagLoc[exportPCredits]);	PopTitle(TXTD_CREDITNONE);	Append(TXTD_CREDITNONE);	Append(TXTD_CREDITFORM);	Append(TXTD_CREDITPICT);	file = NULL;	fileOwned = FALSE;	text = NULL;	textOwned = FALSE;	}voidCreditsPopMenu::dArray()	{	if (file != NULL && fileOwned) file->dFile();	if (text != NULL && textOwned) text->dArray();	V_Array::dArray();	}voidCreditsPopMenu::Display(int activeFlag)	{	switch(current)		{		case menuCreditNone:	PopTitle(TXTD_CREDITNONE); break;		case menuCreditForm:	PopTitle(TXTD_CREDITFORM); break;		case menuCreditPICT:	PopTitle(TXTD_CREDITPICT); break;		}	PopMenu::Display(activeFlag);	}voidCreditsPopMenu::Action(int num, long modifier)	{	int oldCurrent;	oldCurrent = GetCurrent();	PopMenu::Action(num, modifier);	if (current == menuCreditPICT)		{		V_File *newFile;		newFile = new(V_File);		newFile->cFile(LOADAS, appFileTypePICT, appFileCreatorPICT, TXTGF_CREDITPICT);		if (newFile->Find())			{			newFile->dFile();			SetCurrent(oldCurrent);			}		else			{			newFile->SetQuery(REFERENCE, "");			if (file != NULL && fileOwned)				file->dFile();			file = newFile;			fileOwned = TRUE;			}		}	else if (current == menuCreditForm)		{		V_Array *newText;		char null = 0;		CreditsForm *form;		Rect r;		newText = new(V_Array);		newText->cArray(0, sizeof(char), 16);		if (text != NULL)			text->CopyArray(newText);		newText->Append(&null);		newText->SetLength(newText->ALength()-1);		GetScreen(&r);		r.top += *(short *)MBarHeight + 10; r.bottom -= 10;		r.left += 10; r.right -= 10;		form = new(CreditsForm);		if (!form->cCreditsForm(&r, newText))			{			newText->dArray();			SetCurrent(oldCurrent);			}		else			{			if (text != NULL && textOwned)				text->dArray();			text = newText;			textOwned = TRUE;			}		}	if (current != menuCreditPICT && file != NULL)		{		if (fileOwned) file->dFile();		file = NULL;		fileOwned = FALSE;		}	if (current != menuCreditForm && text != NULL)		{		if (textOwned) text->dArray();		text = NULL;		textOwned = FALSE;		}	}voidCreditsPopMenu::SetCreditType(int newType)	{	switch(newType)		{		case creditNone: current = menuCreditNone; break;		case creditForm: current = menuCreditForm; break;		case creditPICT: current = menuCreditPICT; break;		}	}	intCreditsPopMenu::GetCreditType()	{	int result;	switch(current)		{		case menuCreditNone: result = creditNone; break;		case menuCreditForm: result = creditForm; break;		case menuCreditPICT: result = creditPICT; break;		}	return result;	}voidCreditsPopMenu::SetFile(V_File *f, int takeOver)	{	file = f;	fileOwned = takeOver;	}struct V_File *CreditsPopMenu::GetFile(int takeOver)	{	if (takeOver)		fileOwned = FALSE;	return(file);	}voidCreditsPopMenu::SetText(V_Array *t, int takeOver)	{	text = t;	textOwned = takeOver;	}V_Array *CreditsPopMenu::GetText(int takeOver)	{	if (takeOver)		textOwned = FALSE;	return(text);	}voidCreditsPreviewButton::SetMenu(CreditsPopMenu *m)	{	menu = m;	}voidCreditsPreviewButton::Display()	{	Activate(menu->GetCreditType() != creditNone);	V_Control::Display();	}voidCreditsPreviewButton::Action()	{	CreditsPreview *credits;	Rect r;	GetScreen(&r);	r.top += *(short *)MBarHeight + 10; r.bottom -= 10;	r.left += 10; r.right -= 10;	credits = new(CreditsPreview);	credits->cCreditsPreview(&r, menu->GetFile(FALSE), menu->GetText(FALSE), TRUE);	}V_Dialog *CreditsPreview::cCreditsPreview(Rect *r, V_File *file, V_Array *text, int doit)	{	Rect rect;	int height, width;	int err;	if (file != NULL)		{		creditPICT = new(V_Picture);		creditPICT->cPicture(TRUE);		err = file->Find();		if (!err) err = file->Open(FALSE);		if (!err)			{			err = creditPICT->IOPictFile(file);			file->Close();			}		if (err)			{			creditPICT->dPicture();			creditPICT = NULL;			}		}	else if (text != NULL)		{		creditPICT = new(V_Picture);		creditPICT->cPicture(TRUE);		if (creditPICT->GetPictNum(RSRC_PICT_STANDARDFORM) != 0)			{			creditPICT->dPicture();			creditPICT = NULL;			}		}	else creditPICT = NULL;	if (creditPICT != NULL)		{		creditPICT->GetRect(&rect);		pictRect = rect;		}	else		{		/* If there's nothing else to show */		pictRect = VZeroRect;		pictRect.right = 300;		pictRect.bottom = 200;		}	height = r->bottom - r->top;	width = r->right - r->left;	if (width < pictRect.right || height < pictRect.bottom)		{		long wRatio, hRatio, ratio;		wRatio = ((long)width << 16) / pictRect.right;		hRatio = ((long)height << 16) / pictRect.bottom;		ratio = min(wRatio, hRatio);		pictRect.right = pictRect.right * ratio + (1L<<15) >> 16;		pictRect.bottom = pictRect.bottom * ratio + (1L<<15) >> 16;		}	r->left += (width - pictRect.right) >> 1;	r->right = r->left + pictRect.right;	r->top += (height - pictRect.bottom) >> 1;	r->bottom = r->top + pictRect.bottom;	V_Dialog::cDialog(r);	if (text != NULL)		{		char *t, null = 0;		int font, size, face, just;		rect = DiagLoc[exportECreditForm];		rect.right -= rect.left;		rect.bottom -= rect.top;		rect.left = DiagLoc[exportTPreview].left; rect.right += rect.left;		rect.top = DiagLoc[exportTPreview].top; rect.bottom += rect.top;		text->Append(&null);		text->SetLength(text->ALength()-1);		if (RealFont(DV_TEXT_FONT, DV_TEXT_SIZE))			{			font = DV_TEXT_FONT; size = DV_TEXT_SIZE;			face = DV_TEXT_FACE; just = DV_TEXT_JUST;			}		else			{			font = D_TEXT_FONT; size = D_TEXT_SIZE;			face = D_TEXT_FACE; just = D_TEXT_JUST;			}		t = text->Use();		creditText = new(V_StatText);		creditText->cStatText(this, &rect, t, just, font, face, size);		text->Unuse();		}	if (doit)		{		Show();		Modal();			Delete();		}	return(NULL);	}voidCreditsPreview::dPane()	{	if (creditPICT != NULL)		creditPICT->dPicture();	V_Pane::dPane();	}voidCreditsPreview::Display(int type, int h, int v)	{	Rect r;	VBackColor(&vWhite);	r = dataRect;	EraseRect(&r);	if (creditPICT != NULL)		{		r = pictRect;		creditPICT->Draw(&r);		}/* This is a total hack to get the text out. It's here because VOutput doesn't *//* draw the item list. This will be automatic with Mark's new (5/92) V_Item stuff. */if (type == PICT_DRAW && creditText != NULL)	{	Rect r;	SetPane(); /* drawing the picture mucks up the port */	creditText->GlobalRect(&r);	TextFont(creditText->font);	TextFace(creditText->face);	TextSize(creditText->size);	HLock(creditText->tbString);	TextBox(*creditText->tbString, strlen(*creditText->tbString), &r, creditText->just);	HUnlock(creditText->tbString);	TextFont(0);	TextFace(0);	TextSize(12);	}	}voidCreditsPreview::MouseDown(Point p, long modifiers)	{	theWindow->SendEvent(DieWindowEvent);	}intCreditsPreview::KeyAction(char ch, long modifiers)	{	theWindow->SendEvent(DieWindowEvent);	return(TRUE);	}#define CREDITSFORM_WIDTH		364#define CREDITSFORM_HEIGHT		185intCreditsForm::cCreditsForm(Rect *r, V_Array *txt)	{	V_StatText *label;	CreditsTextBox *text;	V_CtrlButton_Die *button;	int font, size, face, just;	Rect br;	char *t;	int result;	r->left = (r->left + r->right - CREDITSFORM_WIDTH) >> 1;	r->right = r->left + CREDITSFORM_WIDTH;	r->top = (r->top + r->bottom - CREDITSFORM_HEIGHT) >> 1;	r->bottom = r->top + CREDITSFORM_HEIGHT;	V_Dialog::cDialog(r);	label = new(V_StatText);	label->cStatText(this, &(DiagLoc[exportTCreditForm]), TXTD_CREDITTEXT, D_TEXT_JUST, D_TEXT_FONT, D_TEXT_FACE, D_TEXT_SIZE);	if (RealFont(DV_TEXT_FONT, DV_TEXT_SIZE))		{		font = DV_TEXT_FONT; size = DV_TEXT_SIZE;		face = DV_TEXT_FACE; just = DV_TEXT_JUST;		}	else		{		font = D_TEXT_FONT; size = D_TEXT_SIZE;		face = D_TEXT_FACE; just = D_TEXT_JUST;		}	t = txt->Use();	text = new(CreditsTextBox);	text->cTextBox(this, &(DiagLoc[exportECreditForm]), t, just, font, face, size);	txt->Unuse();	br.bottom = (r->bottom - r->top) - 13;	br.top = br.bottom - 18;	br.left = (r->right - r->left) - 186;	br.right = br.left + 80;	button = new(V_CtrlButton_Die);	button->cCtrlButtonDie(this, &br, TXTC_CANCEL, FALSE);	br.left = br.right + 13;	br.right = br.left + 80;	button = new(V_CtrlButton_Die);	button->cCtrlButtonDie(this, &br, TXTC_OK, TRUE);	Show();	result = Modal();	if (result)		{		txt->SetLength(text->TextLength()+1);		t = txt->Use();		text->GetText(t);		txt->Unuse();		txt->SetLength(txt->ALength()-1);		}	Delete();	return(result);	}intCreditsTextBox::Action(char c, long modifier)	{	if (c == V_RETURN) return(FALSE);	else return(V_TextBox::Action(c, modifier));	}#endif#if VRML_ANCHOR				// VRML-ABD 23JUN95/************************************************************************************* * *		VRML Export Object (VRML options) * ************************************************************************************/void VRMLExport::GetRect(Rect *r) { *r = layoutSpec[transWVRML].destRect; }char *VRMLExport::GetTitle() { return layoutSpec[transWVRML].title; }voidVRMLExport::SetInterface(V_Dialog *dialog)	{	WalkController *controller;	AppPreference *appPref;	TranslatorPreference	*transPref;	V_Text	*statText;	char str[256];	V_Array *radioGroup;	TranslateObject::SetInterface(dialog);	sprintf(str,"%s %s",TXTD_XFORMAT,TXTM_VRML);	formatTitle->SetText(str);	controller = (WalkController *)((TranslateDialog*)dialog)->controller;	appPref = controller->GetPreference();	transPref = (TranslatorPreference*)appPref->GetPreference(preferTranslator);	#if 0		// PRO25	two_sided = new(V_CtrlCheck);	two_sided->cItem();	two_sided->SetRect(&layoutSpec[transC2Sided].destRect);	two_sided->SetText(layoutSpec[transC2Sided].title);	dialog->AddItem(two_sided);	statText = new(V_Text);	statText->cItem();	statText->SetRect(&layoutSpec[transSCRLF].destRect);	statText->SetText(layoutSpec[transSCRLF].title);	dialog->AddItem(statText);	radioGroup = new(V_Array);	radioGroup->cArray(0,sizeof(V_CtrlRadio*),4);	line_feeds = new(V_CtrlRadio);	line_feeds->cItem();	line_feeds->SetRect(&layoutSpec[transCLF].destRect);	line_feeds->SetText(layoutSpec[transCLF].title);	line_feeds->SetGroup(radioGroup);	dialog->AddItem(line_feeds);	carriage_returns = new(V_CtrlRadio);	carriage_returns->cItem();	carriage_returns->SetRect(&layoutSpec[transCCR].destRect);	carriage_returns->SetText(layoutSpec[transCCR].title);	carriage_returns->SetGroup(radioGroup);	dialog->AddItem(carriage_returns);	crlf = new(V_CtrlRadio);	crlf->cItem();	crlf->SetRect(&layoutSpec[transCCRLF].destRect);	crlf->SetText(layoutSpec[transCCRLF].title);	crlf->SetGroup(radioGroup);	dialog->AddItem(crlf);	statText = new(V_Text);	statText->cItem();	statText->SetRect(&layoutSpec[transSZOffset].destRect);	statText->SetText(layoutSpec[transSZOffset].title);	dialog->AddItem(statText);	z_offset = new(TransText);	z_offset->cItem();	z_offset->SetRect(&layoutSpec[transEZOffset].destRect);	z_offset->SetText(layoutSpec[transEZOffset].title);	dialog->AddItem(z_offset);	#endif		// PRO25	// PRO25 [[[	statText = new(V_Text);	statText->cItem();	statText->SetRect(&layoutSpec[transSTxtrExt].destRect);	statText->SetText(layoutSpec[transSTxtrExt].title);	dialog->AddItem(statText);		texture_ext = new(TransText);	texture_ext->cItem();	texture_ext->SetRect(&layoutSpec[transETxtrExt].destRect);	texture_ext->SetText(layoutSpec[transETxtrExt].title);	dialog->AddItem(texture_ext);	exp_tex = new(V_CtrlCheck);	exp_tex->cItem();	exp_tex->SetRect(&layoutSpec[transCExpText].destRect);	exp_tex->SetText(layoutSpec[transCExpText].title);	dialog->AddItem(exp_tex);	// PRO25 ]]]	}voidVRMLExport::SetOptions(TranslatorPreference	*transPref)	{	char str[256];	TranslateObject::SetOptions(transPref);			#if 0 		// PRO25		two_sided->SetValue(transPref->two_sided_polys);		if (transPref->use_cr && transPref->use_lf)		{			crlf->SetValue(1);		}		else if (transPref->use_cr)		{			carriage_returns->SetValue(1);		}		else if (transPref->use_lf)		{			line_feeds->SetValue(1);		}		sprintf(str,"%f",FixedToDbl(transPref->surffeature_z_offset));		z_offset->SetText(str);		#endif 		// PRO25		texture_ext->SetText(transPref->texture_ext);		// PRO25		exp_tex->SetValue(transPref->export_textures);	}	voidVRMLExport::GetResults(TranslatorPreference	*transPref)	{		short	flag;	double d;	char str[256];		// ABD-VRML4	TranslateObject::GetResults(transPref);		#if 0 		// PRO25		transPref->two_sided_polys = two_sided->GetValue();		if (crlf->GetValue())		{			transPref->use_cr = TRUE;			transPref->use_lf = TRUE;		}		else if (carriage_returns->GetValue())		{			transPref->use_cr = TRUE;			transPref->use_lf = FALSE;		}		else if (line_feeds->GetValue())		{			transPref->use_cr = FALSE;			transPref->use_lf = TRUE;		}		z_offset->GetText(str);		sscanf(str,"%g",&d);		transPref->surffeature_z_offset = DblToFixed(d);		#endif 		// PRO25		texture_ext->GetText(transPref->texture_ext);		// PRO25		if (exp_tex->GetValue())		// PRO25			transPref->export_textures = TRUE;		// PRO25		else										// PRO25			transPref->export_textures = FALSE;		// PRO25				}#endif // VRML_ANCHOR