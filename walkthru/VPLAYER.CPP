#include "VTypes.h"#include "VPlayer.h"#include "WMenus.h"#include "Drawing.h"#include "Polyhdrn.h"#include "Observer.h"#include "WalkPane.h"#include "AppMssgs.h"#include "AppDeflt.h"#include "AppText.h"#include "AppFiles.h"#include "HelpPane.h"#include "VAbout.h"#include "VFile.h"#include "VWindow.h"#include "VError.h"#include "VTextDef.h"#include "VGUtil.h"#include "TextArry.h"#include "VMain.h"#include "VWndUtls.h"#include "WlkCntrl.h"#include "ToolDef.h"#include "VWCntrl.h"#include "VRLibs.h"#include "VDialog.h"#include "VMemUtil.h"#include "TextSrvr.h"#include "Clip.h"#include "InitText.h"#include "ObjPrClp.h"	// JAM 3 Mar 94#include "DesCntrl.h"#include "VWI.h"#include "Credits.h"#include "Gouraud.h"	// MERGE-GOURAUD#include <stdio.h>#include <string.h>#if WINDOWS// There is no menu bar height to think about under Windoow(tm) - BILBIL#define GetMBarHeight() 0#endif //WINDOWS/* current top corner of the document windows */V_Buffer	*clipBuf;TextureArray *gCurrentTextures;TextureArray *gAllTextures;TextureArray *gAllDocTextures;V_Array *gTextureArrays;TextureArray *gCustomPicts;int gCurrentlyDoingIO = FALSE;	//MERGE-PRO-JAM-2 don't update walk and cad panes when doing ioint gReadingEncryptedFile = FALSE;		// PRO-22voidStartUp()	{	PlayerStub *stubby;	extern struct TextureServer *gTextureServer;	gTextureServer = new(TextureServer);	gTextureServer->cTextureServer();	InitTextureMapping();		// JAM 28 Oct 93	InitGouraud();				// MERGE-GOURAUD	InitClipping();				// JAM 3 Mar 94	InitSpacialClip();			// JAM 19 Aug 94	//FASTERSPACIALCLIP	VSplashScreen();	stubby = new(PlayerStub);	stubby->OpenDocument(INIT,NULL,NewMDI);	SetStub(stubby);	clipBuf = new(V_Buffer);	clipBuf->cBuffer(DATA_OUT);	VRLibsInit();	}voidEndIt()	{	clipBuf->dBuffer();	gTextureServer->dTextureServer();	EndTextureMapping();	EndGouraud();					// JAM 6 Oct 94	EndClipping();					// JAM 3 Mar 94	EndSpacialClip();				// JAM 19 Aug 94 FASTERSPACIALCLIP	VRLibsDelete();			// jca 27FEB95 clean up after ourselves	if (gCustomPicts)	// jca 28FEB95 clean up thoroughly, please		{		gCustomPicts->dTextureItemsInTextureArray();			gCustomPicts->dTextureArray();	// delete our texture array		gCustomPicts = NULL;		}          // jca 28FEB95 end clean up, thanks.	}voidNewDocument(V_File *file,int flag)	{	Player *doc;	long 	form,size,type;	short	err = 0;		if(file)		{				err = file->Open(FALSE);		if (!err)			{	// jca--don't try to do this if there's no such file!			file->IOType(&form,IO_LONG);			file->IOType(&size,IO_LONG);			file->IOType(&type,IO_LONG);			file->IOSetPosition(0L);			if (type != IFF_VMDL)				{				file->SetCryptOn();				file->IOType(&form,IO_LONG);				file->IOType(&size,IO_LONG);				file->IOType(&type,IO_LONG);				file->IOSetPosition(0L);				file->SetCryptOff();				}			}		else        	type = 0L;		file->Close();		if ((type == IFF_VMDL)||(type == appFileTypePlayerModel))			{			if (ActiveDocument() != stub)				{				if (ActiveDocument() != FindHelpDocument())					{					char	textStr[256];										sprintf(textStr,TXTD_PLAYERCLOSE,((PlayerStub*)ActiveDocument())->title);					if (0 == WarningMessage(textStr, TXTC_OK, TXTC_CANCEL, 1))						ActiveDocument()->Close();					else						{						file->dFile();						return;						}					}				else if (theSuper->ALength() > 1)					{					V_Document	*oldDoc;					char		textStr[256];										theSuper->Get(1, &oldDoc);										sprintf(textStr,TXTD_PLAYERCLOSE,((PlayerStub*)oldDoc)->title);					if (0 == WarningMessage(textStr, TXTC_OK, TXTC_CANCEL, 1))						oldDoc->Close();					else						{						file->dFile();						return;						}					}				}			doc = new(Player);			doc->OpenDocument(LOADSTART,file,NoMDI);			}		else			file->dFile();		}	else		{		if (ActiveDocument() != stub)			{			if (ActiveDocument() != FindHelpDocument())				{				char	textStr[256];								sprintf(textStr,TXTD_PLAYERCLOSE, ActiveDocument()->title);				if (0 == WarningMessage(textStr, TXTC_OK, TXTC_CANCEL, 1))					ActiveDocument()->Close();				else					return;				}			else if (theSuper->ALength() > 1)				{				V_Document	*oldDoc;				char		textStr[256];								theSuper->Get(1, &oldDoc);								sprintf(textStr, TXTD_PLAYERCLOSE, oldDoc->title);				if (0 == WarningMessage(textStr, TXTC_OK, TXTC_CANCEL, 1))					oldDoc->Close();				else					return;				}			}		doc = new(Player);		doc->OpenDocument(flag,NULL,NoMDI);		}	}PlayerHelp *FindHelpDocument()	{#if MACINTOSH	V_Document *doc;	int length, i;	char title[256];	length = theSuper->ALength();	for (i = 0; i < length; i++)		{		theSuper->Get(i, &doc);		doc->GetTitle(title);		/* Look for Help document key string after real title */		if (strcmp(title+strlen(title)+1, HELP_KEYSTRING) == 0)			break;		}	if (i == length)		return(NULL);	else		return((PlayerHelp *)doc);#elif WINDOWS	return NULL;#endif //MACINTOSH	}intPlayerStub::cDocument(int query,V_File *file)	{	V_MenuMgr	*mgr;	V_Document::cDocument(query,file);	sprintf(titlePrefix, "Virtus %s", PRODUCTNAME);	mgr = GetMenuMgr();	aboutMenu = new(MenuAbout);	aboutMenu->ctheMenu(this);	mgr->Append(aboutMenu);	fileMenu = new(MenuFile);	fileMenu->ctheMenu(this);	mgr->Append(fileMenu);#if MACINTOSH	editMenu = new(MenuEdit);	editMenu->ctheMenu(this);	mgr->Append(editMenu);#endif //MACINTOSH	return TRUE;	}voidPlayerStub::dDocument()	{	aboutMenu->dMenu();	fileMenu->dMenu();#if MACINTOSH	editMenu->dMenu();#endif //MACINTOSH	V_Document::dDocument();	}intPlayerStub::Load(int query)	{	int err = 0;	switch(query)		{		case LOADAS:		case LOADSTART:			NewDocument(0L,query);			break;		default:			break;		}	return(err);	}voidPlayerStub::TransferControl()	{	if (this == stub) return;	if (theSuper->ALength() == 1)		TransferDocumentControl(stub);	}intPlayer::cDocument(int query,V_File *file)	{	V_MenuMgr *mgr;	Rect	r;	int		height, width, offset;	Point	pMin, pMax;	Rect	inset;	char	str[256];	int		result;	LaunchInit	launchInit;	walkFile = file;		result = PlayerStub::cDocument(query,file);		if (FindHelpDocument() == NULL) stub->TransferDocumentControl(this);	appPreferences = new(AppPreference);	appPreferences->cAppPreference();	mgr = GetMenuMgr();	walkMenu = new(MenuVRWalk);	walkMenu->ctheMenu(this);	mgr->Append(walkMenu);		GetScreen(&r);	height = r.bottom - r.top;	width = r.right - r.left;	r.top += GetMBarHeight() + 23;	r.bottom -= (6 + GetMBarHeight());	r.left += 5;	r.right -= 6;	if (height > 342)		{		offset = (height - 342) >> 1;		r.top += offset;		offset = (height - 342) - offset;		r.bottom -= offset;		}	if (width > 512)		{		offset = (width - 512) >> 1;		r.left += offset;		offset = (width - 512) - offset;		r.right -= offset;		}	wCntrl = new(WalkController);	wCntrl->cController(this);	rootPolyhedron = wCntrl->drawing->polyhedron;	observer = wCntrl->observer;	walkMenu->SetController(wCntrl);	fileMenu->SetController(wCntrl);	result = Load(query);	if(result) { Close(); return(TRUE); }	launchInit.location = r;	wCntrl->SetTitle(title);	wCntrl->LaunchController(launchInit,toolCRTLView);	MoveWalkWin();		return(TRUE);	}voidPlayer::dDocument()	{	walkMenu->dMenu();	wCntrl->dController();	appPreferences->dAppPreference();	if (creditBitMap) creditBitMap->dOffscreen();	if (creditText) creditText->dArray();	PlayerStub::dDocument();	}voidPlayer::CloseDocument()	{	VWIShow();	V_Document::CloseDocument();#if VR	// with texture stuff we need to do several things:	// 1) remove the this-document-only textures from the gAllTextures list	// 2) delete all of the texture items in gAllDocTextures	// 3) delete all of the textures and texture types that are only in gAllDocTextures	// 4) set the length of gAllDocTexture to zero	// remove the texture items that are only in this document from the gAllTextures list	//gTextureServer->RemoveDocTextures();	// MERGE20	// MERGE-DEL [[[	// delete the texture items in gAllDocTextures -- dTextureItem also removes the texture	// item from its parent TextureArray, which is gAllTextures	if (gAllDocTextures)	{		int i;		// delete all the texture items that are in the document we are closing 		for ( i = gAllDocTextures->ALength()-1 ; i >= 0 ; i-- )		{		TextureItem *ti = NULL;			gAllDocTextures->Get(i, &ti);			if (ti) ti->dTextureItem();		// calls Remove from gAllTextures		}	}	// MERGE-DEL ]]]		// ¥¥¥Êdelete the textures here	// set the length of gAllDocTexture to zero	gAllDocTextures->SetLength(0);#endif	}intPlayer::Load(int query) 	{	char str[256];	int result = 0;	switch(query)		{		case INIT:			query = LOADAS;		case LOADAS:			walkFile = new(V_File);		#if MACINTOSH			walkFile->cFile(query,appFileTypePlayerModel, appFileCreator, NULL, TXTPF_MODEL);			walkFile->AddFType(appFileTypeModel, NULL);		#elif WINDOWS			walkFile->cFile(query,appFileTypePlayerModel, appFileCreator, appFilterDescriptorPLAYER, TXTPF_MODEL);			walkFile->AddFType(appFileTypeModel, appFilterDescriptorVR);			walkFile->AddFType(appFileTypeModel, appFilterDescriptorVPRO);			walkFile->AddFType(appFileTypeModel, appFilterDescriptorWALK);		#endif //MACINTOSH			walkFile->SetVolume(0);		case LOADSTART:			walkFile->SetQuery(query,TXTGF_MODEL);			result = walkFile->Find();			if(!result)				{				long 	form,size,type;				FindTextureFiles(walkFile);				walkFile->Open(FALSE);								walkFile->IOType(&form,IO_LONG);				walkFile->IOType(&size,IO_LONG);				walkFile->IOType(&type,IO_LONG);				walkFile->IOSetPosition(0L);				if (type != IFF_VMDL)					{					gReadingEncryptedFile = TRUE;   // PRO-22					walkFile->SetCryptOn();                    }								walkFile->GetFName(str);				walkFile->GetFName(title);					SetTitle(str);				result = IO(walkFile);								if (gReadingEncryptedFile)					{					walkFile->SetCryptOff();					gReadingEncryptedFile = FALSE;   // PRO-22					}				walkFile->Close();				}			walkFile->dFile();			walkFile = NULL;			break;		default:			break;		}	return result;	}intPlayer::Empty()	{	return(FALSE);	}voidPlayer::SetPreferences()	{	AppPreference		*appPref;	RenderPreference	*renderPref;	NavigatePreference	*navigPref;	int	hAspect,vAspect;	int viewOptions = 0;	int options = 0;	int noviceState;	appPref = GetPreference();	renderPref = (RenderPreference*)appPref->GetPreference(preferRenderer);	navigPref = (NavigatePreference*)appPref->GetPreference(preferNavigate);	if (navigPref->navigateMode & NAVIG_BUTTON) options |= VIEW_BUTTON;	if (navigPref->navigateMode & NAVIG_CROSS) options |= VIEW_CROSSHAIR;	if (navigPref->navigateMode & NAVIG_GRID) options |= VIEW_VELOCITY;//	walkPane->SetOptions(options);	hAspect = (navigPref->aspectState ? navigPref->aspectRatio.h : 0);	vAspect = (navigPref->aspectState ? navigPref->aspectRatio.v : 0);//	walkPane->AspectRatio(hAspect,vAspect);	if (renderPref->renderDrawMode & RENDER_FILL) viewOptions |= DRAW_FILL;	if (renderPref->renderDrawMode & RENDER_FRAME) viewOptions |= DRAW_FRAME;	if (renderPref->renderOpenMode & RENDER_SEEIN) viewOptions |= DRAW_SEE_IN;	if (renderPref->renderOpenMode & RENDER_SEEOUT) viewOptions |= DRAW_SEE_OUT;	if (renderPref->renderOpenMode & RENDER_SEECONN) viewOptions |= DRAW_SEE_THROUGH;	if (renderPref->renderShadeMode & RENDER_FLATSH) viewOptions |= DRAW_SHADE;	if (renderPref->renderShadeMode & RENDER_NOSHADE) viewOptions |= DRAW_NO_SHADE;	if (renderPref->renderShadeMode & RENDER_WHITESH) viewOptions |= DRAW_WHITE_SHADE;	if (renderPref->frameBlack) viewOptions |= DRAW_BLACK_FRAME;//	observer->SetOptions(viewOptions);//	observer->SetFocalValue(navigPref->focalLength,navigPref->filmWidth);	}voidPlayer::ShowPlayerCredits()	{	ShowCredits(creditBitMap, creditText);	}AppPreference *Player::GetPreference()	{	return(appPreferences);	}Observer *Player::GetObserver()	{	return(observer);	}voidPlayer::MoveWalkWin()	{#if WINDOWS	V_Window *walkWindow = NULL;	Rect	mdiR, infoR, cliR;	HWND	hwnd = GetMDIClient();	int		i,length;	ToolDef *toolDef;	length = wCntrl->toolChest->ALength();	for(i = 0; i < length; i++)		{		wCntrl->toolChest->Get(i,&toolDef);		if(toolCRTLView == toolDef->GetType())			{			walkWindow = toolDef->GetWindow();			break;			}		}	infoR = GetInfoWinRect();	GetClientRect(GetFrame(), &cliR);   // get the MDI client size	cliR.bottom -= (infoR.bottom - infoR.top);  // whack out the info win height	if (walkWindow && walkWindow->Visible())		MoveWindow(walkWindow->theWindow, cliR.left, cliR.top, cliR.right-cliR.left, cliR.bottom-cliR.top, TRUE);#endif //WINDOWS	}intPlayer::IO(V_Buffer *buf)	{	int err = -1;	long id;			gCurrentlyDoingIO ++;	if (buf->IODirection() == DATA_IN)		{		switch(id = buf->OpenChunkR())			{			case IFF_FORM:				rootPolyhedron->SetLightModel(NULL);				rootPolyhedron->RemoveUnit();				err = IO_FORM(buf);				break;			}		if (id != 0) buf->CloseChunk();		}	gCurrentlyDoingIO --;	return(err);	}	voidPlayer::FindTextureFiles(V_File *theDocFile){	VCGrafPort savePort;	// MERGE-1/26	VGrafDevice saveDevice;	// MERGE-1/26	short		error;	VfsLocation	*fSpec, *fSpec2;	TextureItem *ti;	char		name[256];#if MACINTOSH	short		vRefNum;	long		dirID;	CInfoPBRec	pb;	long		theDirID;	Boolean		isDirectory;	FSSpec		item;	int			counter = 1;	extern int gQuickTime;#elif WINDOWS	int			loop;	V_Array		*bmpFiles;	V_File		**files;#endif //MACINTOSH		VGetPort(&savePort,&saveDevice);	// MERGE-1/26		if (gCustomPicts) //gCustomPicts->dTextureArray();  bad.  This doesn't delete the texture items.    	{		gCustomPicts->dTextureItemsInTextureArray();  // jca better way to do it.  28FEB95		gCustomPicts->dTextureArray();		gCustomPicts = NULL;        }	gCustomPicts = new(TextureArray);	gCustomPicts->cTextureArray();		fSpec=new(VfsLocation);	fSpec->cVfsLocation();	fSpec2=new(VfsLocation);	fSpec2->cVfsLocation();	error = theDocFile->VGetLocation(fSpec);	if (error) 			{	// MERGE-1/26		VSetPort(savePort,saveDevice);		// MERGE-1/26		return;		}	// MERGE-1/26	#if MACINTOSH	strcpy(name, fSpec->name);	C2Pstr(name);	vRefNum = fSpec->volume;	dirID = fSpec->directory;	pb.hFileInfo.ioNamePtr = (StringPtr)name;	pb.hFileInfo.ioVRefNum = vRefNum;	pb.hFileInfo.ioDirID = dirID;	pb.hFileInfo.ioFDirIndex = 0;				/* use ioNamePtr and ioDirID */	error = PBGetCatInfoSync(&pb);	theDirID = pb.hFileInfo.ioFlParID;	while (error == noErr)		{		pb.hFileInfo.ioNamePtr = (StringPtr) &(item.name);		pb.hFileInfo.ioDirID = theDirID;		pb.hFileInfo.ioFDirIndex = counter;		error = PBGetCatInfoSync(&pb);		if (error == noErr)			{			item.parID = pb.hFileInfo.ioFlParID;	/* return item's parID */			item.vRefNum = pb.hFileInfo.ioVRefNum;	/* return item's vRefNum */						if (!(pb.hFileInfo.ioFlAttrib & 0x10))				{				P2Cstr((char*)item.name);				strcpy(fSpec2->name, (char*)item.name);				strcpy(name, (char*)item.name);				C2Pstr((char*)item.name);				fSpec2->volume = item.vRefNum;				fSpec2->directory = item.parID;				if (pb.hFileInfo.ioFlFndrInfo.fdType == appFileTypePICT)					gCustomPicts->GetTextureItem(name, fSpec2, &ti);				else if ((gQuickTime) && (pb.hFileInfo.ioFlFndrInfo.fdType == appFileTypeQuickTime))					gCustomPicts->GetTextureItem(name, fSpec2, &ti);				}			++ counter;			}		}#elif WINDOWS	bmpFiles = new(V_Array);	bmpFiles->cArray(0,sizeof(V_File*),4);	FindAllFilesInDir(bmpFiles, fSpec->path, "", appFileTypeBMP);	FindAllFilesInDir(bmpFiles, fSpec->path, "", appFileTypeDIB);	files = (V_File**)bmpFiles->Use();	for (loop = 0; loop < bmpFiles->ALength(); loop ++)		{		files[loop]->GetFName(name);		if (noErr == files[loop]->VGetLocation(fSpec2))			{			gCustomPicts->GetTextureItem(name, fSpec2, &ti);			if (ti != NULL)				ti->settings.shade = FALSE;				}		files[loop]->dFile();		}	bmpFiles->Unuse();    bmpFiles->dArray();#endif  // MACINTOSH	fSpec->dVfsLocation();	fSpec2->dVfsLocation();	VSetPort(savePort,saveDevice);		// MERGE-1/26}intPlayer::IO_FORM(V_Buffer *buf)	{	V_File	*file;	char	str[256],fileName[256];	long i,length,total,id;	Point3DFFixed point;	Angle3DFFixed angle;	int err;		err = 0;	MeterCreate();	MeterTitle(TXT_APPNAME);	file = (V_File*)buf;	file->GetFName(fileName);	sprintf(str,TXT_METREAD,fileName);	MeterSetText(str);	buf->IOLength(&total);		MeterSetTotal(total);	MeterSetCount(0);	MeterStart();	gTextureServer->BeginTextureIO(buf, gAllTextures);		if (buf->IODirection() == DATA_IN)		{		err = buf->IOType(&id, IO_LONG);		if (!err && id == IFF_VMDL)			{			buf->SetRefCon(0);				while (!err)				{				id = buf->OpenChunkR();				if (id == 0) break;					switch(id)					{					case IFF_VERS:						err = IO_VERS(buf);						if (!err && (buf->GetRefCon() < 0x01000000L ||							buf->GetRefCon() >= 0x02000000L))							err = 1;						break;					case IFF_CRED: err = IO_CRED(buf); break;					case IFF_PPRF: appPreferences->IO(buf); break;					case IFF_TXTB: err = gTextureServer->IOTextureTable(buf, 0); break; /* ABD MERGE-TEXTURE 9/13/93 purge textures ignored on input */					case IFF_VPRF: observer->IO(buf); break;/* MJU */					case IFF_ROOT: err = rootPolyhedron->IORoot(buf); break;					}					buf->CloseChunk();				}			}		observer->GetPosition(&point, &angle);		}	gTextureServer->EndTextureIO(buf);	MeterStop();		if (err && (CheckMemory() > memoryFine))//#error - need to put these strings back in!		{		sprintf(str,TXTW_LOADMEMERR, fileName); 		AlertMessage((strPtr)str);		}	else if (err)		{		sprintf(str,TXTW_LOADERR, fileName);		AlertMessage((strPtr)str);		}	return(err);	}intPlayer::IO_CRED(V_Buffer *buf)	{	int		err = 0;	long	id;		MeterSetCount(buf->IOGetPosition());	if (MeterUpdate(0)) err = -2;	while (!err)		{		id = buf->OpenChunkR();		if (id == 0) break;		switch (id)			{			case IFF_TEXT:				err = IO_TEXT(buf);				break;			case IFF_BMAP:				if (creditBitMap)					creditBitMap->dOffscreen();				creditBitMap = new(V_Offscreen);				creditBitMap->IO_BMAP(buf, NULL, NoCompression);				break;			}		buf->CloseChunk();		}	MeterSetCount(buf->IOGetPosition());	if (MeterUpdate(0)) err = -2;		MeterSetCreditInfo(creditBitMap, creditText);		return (err);	}intPlayer::IO_TEXT(V_Buffer *buf)	{	int err = 0;	if (creditText)		creditText->dArray();	creditText = new(V_Array);	creditText->cArray(buf->ChunkSize(), 1, 16);	creditText->IO(buf);	return(err);	}#if MACINTOSHintPlayerHelp::cDocument(int query,V_File *file)	{	V_MenuMgr	*mgr;	V_Window 	*window;	HelpPane	*helpPane;	Rect	r, size;	Point	pMin, pMax;	char	*title = TXTT_HELP;	int		result;	result = PlayerStub::cDocument(query,file);	SetTitle(title);	helpPane = new(HelpPane);	helpPane->cPane(0);	helpPane->GetSize(&size);	window = new(V_Window);#if MACINTOSH	GetScreen(&r);	r.top += GetMBarHeight() + 35;	r.bottom = r.top + size.bottom;	r.right -= 20;	r.left = r.right - size.right;	pMin.h = size.right; pMin.v = size.bottom;	pMin = pMax;	window->cWindow(&r,title,pMin,pMax,pMin,DRAGBAR|GOAWAY,WINDOW_DESTROY);#elif WINDOWS	r = size;	r.left ++; r.right ++;	r.top ++; r.bottom ++;	pMin.h = size.right; pMin.v = size.bottom;	pMin = pMax;	window->cWindow(&r,title,pMin,pMax,pMin,BORDERLESS,WINDOW_DESTROY);#endif //MACINTOSH	Install(window);	window->Install(helpPane);	window->Show();	return TRUE;	}intPlayerHelp::Load(int query)	{	int err = 0;	switch(query)		{		case LOADAS:		case LOADSTART:			NewDocument(0L,query);			break;		default:			break;		}	return(err);	}voidPlayerHelp::GetTitle(strPtr str)	{	V_Document::GetTitle(str);	/* Add some hidden stuff to uniquely mark this as the Help document */	strcpy(str+strlen(str)+1, HELP_KEYSTRING);	}#endif //MACINTOSH