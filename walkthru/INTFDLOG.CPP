/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "IntfDlog.h"#include "Misc.h"#include "PopColor.h"#include "AppText.h"#include "VGraphic.h"#include "VGUtil.h"#include "VDocumnt.h"#include "VTextDef.h"#include "vmain.h"#include <string.h>voidColorPop::cItem()	{	popColor = NULL;	color = vWhite;		V_Text::cItem();	}voidColorPop::Display()	{	Rect	r;	int 	depth;		depth = currentPane->depth;	r = popRect;			VSetPattern(vPatBlack);	VForeColor(&vBlack);	DrawDropRect(&r);	if(depth<4)VForeColor(&vWhite);	else VForeColor(&color);	r.top++; r.left++; r.right--;r.bottom--;	VPaintRect(&r);		VForeColor(&vBlack);	V_Text::Display();	}intColorPop::MouseDown(Point p,long modifiers)	{		RGBColor newColor;	int	result;	Rect	avoidRect;	Point	scrPoint;#if WINDOWS	FARPROC proc;	extern BOOL CALLBACK _export EnumWindowsProc(HWND ,LPARAM);  // define in VWindow.c	VGrafPort activeWin;#endif		result = VPtInRect(p,&popRect);	if(TRUE == result)		{		p.h = popRect.left;		p.v = popRect.top;		newColor = color;		/* jca.  Let's move the window over, so the		mouse won't be over it when the color pickler 		comes up. */		scrPoint = p;		avoidRect.top = avoidRect.left = 0;		avoidRect.right = popRect.right - popRect.left;		avoidRect.bottom = popRect.bottom - popRect.top;		LocalToGlobal(&scrPoint);		VOffsetRect(&avoidRect, scrPoint.h, scrPoint.v);		// jca-- save the state#if WINDOWS		activeWin = GetActiveWindow();#endif //WINDOWS		if(popColor->Pop(p, &newColor, &avoidRect))			{  			color = newColor;  			thePane->VDisplay(DRAW);  			}#if WINDOWS		// jca-- make the prefs the only active window		proc = MakeProcInstance((FARPROC)EnumWindowsProc,GetAppInstance());		EnumTaskWindows(GetCurrentTask(),proc,MAKELPARAM(activeWin,FALSE));		FreeProcInstance(proc);		SetActiveWindow(activeWin);#endif		}			return result;	}	void ColorPop::SetPopColor(PopColor *pop) { popColor = pop; }void ColorPop::SetColor(RGBColor clr) { color = clr; }RGBColor ColorPop::GetColor() { return(color); }void ColorPop::SetRect(Rect *r) 	{ 	V_Text::SetRect(r);	popRect = bounds;	popRect.bottom = popRect.top+COLORPOP_HEIGHT;	popRect.right = popRect.left-COLORPOP_GAP;	popRect.left = popRect.right-COLORPOP_WIDTH;	}voidActionCheck::Action(void)	{	V_CtrlCheck::Action();	thePane->VDisplay(DRAW);	}