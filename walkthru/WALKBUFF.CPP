/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	 *				David W. Easter *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "WalkBuff.h"#include "VMath.h"#include "WTypes.h"#include "DXFOUT.H"#include "VIO.h"#include <string.h>#define FFIXED			((FFixed *)data)#define POINT			((Point *)data)#define RECT			((Rect *)data)#define POINT3D			((Point3D *)data)#define ANGLE3D			((Angle3D *)data)#define POINT_FFIXED	((PointFFixed *)data)#define POINT3D_FFIXED	((Point3DFFixed *)data)#define ANGLE3D_FFIXED	((Angle3DFFixed *)data)#define SHEAR3D_FFIXED	((Shear3DFFixed *)data)#define RGB_COLOR		((RGBColor *)data)#define RGBA_COLOR		((RGBAColor *)data)#define CSTR			((unsigned char *)data)#define PSTR			((unsigned char *)data)#define DXF				((DxfFile **)data)intIOType(V_Buffer *buf, void *data, int type)	{	int err;	long clr;	unsigned char n, zero = 0;	int i;	switch(type)		{		case IO_FFIXED:			err = buf->IOType(&FFIXED->intg, IO_SHORT);			if (!err) err = buf->IOType(&FFIXED->frac, IO_SHORT);			break;		case IO_POINT:			err = buf->IOType(&POINT->h, IO_SHORT);			if (!err) err = buf->IOType(&POINT->v, IO_SHORT);			break;		case IO_RECT:			err = buf->IOType(&RECT->left, IO_SHORT);			if (!err) err = buf->IOType(&RECT->top, IO_SHORT);			if (!err) err = buf->IOType(&RECT->right, IO_SHORT);			if (!err) err = buf->IOType(&RECT->bottom, IO_SHORT);			break;		case IO_POINT3D:			err = buf->IOType(&POINT3D->x, IO_SHORT);			if (!err) err = buf->IOType(&POINT3D->y, IO_SHORT);			if (!err) err = buf->IOType(&POINT3D->z, IO_SHORT);			break;		case IO_ANGLE3D:			err = buf->IOType(&ANGLE3D->roll, IO_SHORT);			if (!err) err = buf->IOType(&ANGLE3D->pitch, IO_SHORT);			if (!err) err = buf->IOType(&ANGLE3D->yaw, IO_SHORT);			break;		case IO_POINT_FFIXED:			err = IOType(buf, &POINT_FFIXED->h, IO_FFIXED);			if (!err) err = IOType(buf, &POINT_FFIXED->v, IO_FFIXED);			break;		case IO_POINT3D_FFIXED:			err = IOType(buf, &POINT3D_FFIXED->x, IO_FFIXED);			if (!err) err = IOType(buf, &POINT3D_FFIXED->y, IO_FFIXED);			if (!err) err = IOType(buf, &POINT3D_FFIXED->z, IO_FFIXED);			break;		case IO_ANGLE3D_FFIXED:			err = IOType(buf, &ANGLE3D_FFIXED->roll, IO_FFIXED);			if (!err) err = IOType(buf, &ANGLE3D_FFIXED->pitch, IO_FFIXED);			if (!err) err = IOType(buf, &ANGLE3D_FFIXED->yaw, IO_FFIXED);			break;				case IO_SHEAR3D_FFIXED:			err = IOType(buf, &SHEAR3D_FFIXED->xy, IO_FFIXED);			if (!err) err = IOType(buf, &SHEAR3D_FFIXED->xz, IO_FFIXED);			if (!err) err = IOType(buf, &SHEAR3D_FFIXED->yz, IO_FFIXED);			break;				case IO_RGB_COLOR:			if (buf->direction == DATA_OUT)				{				clr = ((long)RGB_COLOR->red & 0xff00) << 8 |					((long)RGB_COLOR->green & 0xff00) |					((long)RGB_COLOR->blue & 0xff00) >> 8;				}			err = buf->IOType(&clr, IO_LONG);						if (buf->direction == DATA_IN)				{				RGB_COLOR->red = clr >> 8 & 0xff00;				RGB_COLOR->green = clr & 0xff00;				RGB_COLOR->blue = clr << 8 & 0xff00;				}			break;		case IO_RGBA_COLOR:			if (buf->direction == DATA_OUT)				{				clr = ((long)RGBA_COLOR->alpha & 0xff00) << 16 |					((long)RGBA_COLOR->red & 0xff00) << 8 |					((long)RGBA_COLOR->green & 0xff00) |					((long)RGBA_COLOR->blue & 0xff00) >> 8;				}			err = buf->IOType(&clr, IO_LONG);			if (buf->direction == DATA_IN)				{				RGBA_COLOR->alpha = clr >> 16 & 0xff00;				RGBA_COLOR->red = clr >> 8 & 0xff00;				RGBA_COLOR->green = clr & 0xff00;				RGBA_COLOR->blue = clr << 8 & 0xff00;				}			break;		case IO_CSTR:			if (buf->direction == DATA_OUT)				{				i = strlen((char *)CSTR);				n = (i < 256 ? i : 255);				}			err = buf->IOType(&n, IO_CHAR);			if (!err) err = buf->IOData(CSTR, n);			if (!err && !(n & 1)) err = buf->IOType(&zero, IO_CHAR);			if (buf->direction == DATA_IN)				CSTR[n] = '\0';			break;		case IO_PSTR:			err = buf->IOType(PSTR, IO_CHAR);			if (!err) err = buf->IOData(PSTR+1, PSTR[0]);			if (!err && !(PSTR[0] & 1)) err = buf->IOType(&zero, IO_CHAR);			break;#if VWT && !SPECIAL_EDITION         	// merge SE, vrmadness		// GJR 7/4/95/* jca 17 Sept 93.  Not in VR { */		case IO_DXFOUT:			if (buf->direction == DATA_OUT)				{				char **h = (*DXF)->buf_h;				int len = (*DXF)->count;				if (len > 0)					{#if MACINTOSH                    // On the Mac, h is a true Mac Handle					HLock((Handle)h);					err = buf->IOData(*h, len);					HUnlock((Handle)h);					DxfBufCleared(DXF);#elif WINDOWS					// On Windows, h is in Kandu's private memory manager and					// can't move anyway					err = buf->IOData(*h, len);					DxfBufCleared(DXF);#endif // WINDOWS					}				}			break;#endif // VWT.  jca 17 Sept 93 }		}	return(err);	}