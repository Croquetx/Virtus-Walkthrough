/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "Draft.h"#include "VMath.h"#include "VGraphic.h"#include "VGUtil.h"#define VIRT_TRACK_PAD 30#define SCROLL_DELAY	12	/* 1/5 second */	// MERGE15#define cadMax VMax#define cadMin VMin#define cadFFMax VFFMax#define cadFFMin VFFMinvoid Draft::cPane(int flag)	{				V_Pane::cPane(flag);			gridUnit = FFZero;	anchorPosition = currentPosition = lastPosition = PtZero;	anchorPositionR = currentPositionR = lastPositionR = PtZero;	ffLastPt = PtFFZero;	scroll2World = PtFFOne;	world2Scroll = PtFFOne;	scroll2WorldP = PtZero;	world2ScrollP = PtZero;		origin = PtFFZero;	lOrigin.h = 0; 	lOrigin.v = 0;	worldMin = PtMin;	worldMax = PtMax;	userZoom = 1.0;	userScale = 1.0;	scale2Local = FFOne;	scale2World = FFOne;	localPrecision	= 0;	worldPrecision	= 0;	color = vWhite;	}							void Draft::Display(int type,int x,int y)	{	V_Picture	**picts;	Rect		r;	PointFFixed	pt,wPt,oOrigin,offset;	PointLong	oldOrigin;	Point		p,dp,pMin,pMax,pLim;	double		ratioH,ratioV;	long		overFlow,extent;	int			i,length;	oldOrigin = lOrigin;oOrigin = origin;/* this is a cheat for the rulers forcing the scroll with a push */	if(-SCROLL_DRAW == type)		{		type = SCROLL_DRAW;		pt = origin;		}	else		{		p.h = x;		p.v = -y;		pt = Scroll2World(p);		}		r = dataRect;		switch(type)		{		case	PICT_DRAW:				CalcOrigin(pt);				if(DrawInColor())            	{				VForeColor(&color);				VPaintRect(&r);					VForeColor(&vBlack);                }			else				VEraseRect(&r);			break;					case	PRINT_DRAW:				p.h = paneRect.right; 				p.v = -paneRect.bottom;			wPt = Local2World(p,SCALE_RELATIVE);			ratioH = (double)(r.right - r.left)/(FFRound(wPt.h));			ratioV = (double)(r.bottom - r.top)/(FFRound(wPt.v));			if(ratioH>ratioV)scale2Local = DblToFixed(ratioV);else scale2Local = DblToFixed(ratioH);			CalcOrigin(pt);				break;					case	SCROLL_DRAW:			offset.h = FFSub(pt.h,oOrigin.h);			offset.v = FFSub(pt.v,oOrigin.v);			ffLastPt.h = FFAdd(ffLastPt.h,offset.h);			ffLastPt.v = FFAdd(ffLastPt.v,offset.v);											default:				CalcOrigin(pt);							VSetPattern(vPatBlack);			VPenMode(vPatCopy);			if(DrawInColor())            	{				VForeColor(&color);				VPaintRect(&r);					VForeColor(&vBlack);                }			else				VEraseRect(&r);			V_Pane::Display(type,x,y);									if(dataRect.right>worldMax.h)				{				VSetPattern(vPatGray);				r = dataRect;				r.left = worldMax.h;				VPaintRect(&r);				VSetPattern(vPatBlack);					VMoveTo(worldMax.h,worldMin.v);							VLineTo(worldMax.h,worldMax.v);							}			if(dataRect.bottom>worldMax.v)				{				VSetPattern(vPatGray);				r = dataRect;				r.top = worldMax.v;				VPaintRect(&r);									VSetPattern(vPatBlack);					VMoveTo(worldMin.h,worldMax.v);							VLineTo(worldMax.h,worldMax.v);							}							break;				}	origin = pt;	}		void Draft::CalcOrigin(PointFFixed pt) 	{		long		overFlow,extent;	lOrigin.h = FFLongMult(scale2Local,pt.h);	lOrigin.v = FFLongMult(scale2Local,FFNeg(pt.v));			extent = FFLongMult(scale2Local,VFFMax);	if(cadMin > (overFlow = -extent - lOrigin.h))worldMin.h = cadMin; else worldMin.h = overFlow;	if(cadMin > (overFlow = -extent - lOrigin.v))worldMin.v = cadMin; else worldMin.v = overFlow;	if(cadMax < (overFlow = extent - lOrigin.h))worldMax.h = cadMax; else worldMax.h = overFlow;	if(cadMax < (overFlow = extent - lOrigin.v))worldMax.v = cadMax; else worldMax.v = overFlow;	}void Draft::Reset() 	{		Update();	V_Pane::Reset();	}	void Draft::GetVirtual(Rect *r) 	{	/*	PointFFixed	pt;	Point	p;		p.h = p.v = VIRT_TRACK_PAD;	pt = Local2World(p,SCALE_RELATIVE);		r->top += FFRound(pt.v);	r->bottom -= FFRound(pt.v);	r->right += FFRound(pt.h);	r->left -= FFRound(pt.h);*/	r->top = -r->top;	r->bottom = -r->bottom;	}#define POLONIUS FALSEvoid Draft::CalcScroll()	{	PointFFixed	pt1,pt2;	Point		p;	long		n,d,scrollMax,scrollMin,width;	double		sc,check;	V_CtrlScrollBar *ctrl;		CalcOrigin(origin);		width = 0;	scrollRect = VMaxRect;	scrollRect.top>>=1;	scrollRect.bottom>>=1;	scrollRect.left>>=1;	scrollRect.right>>=1;	scroll2World = PtFFOne;	scroll2WorldP = PtZero;	world2Scroll = PtFFOne;	world2ScrollP = PtZero;		if(dataRect.right<=worldMax.h)p.h = dataRect.right; else p.h = 0;	if(dataRect.bottom<=worldMax.v)p.v = dataRect.bottom; else p.v = 0;	pt2 = Local2World(p,SCALE_RELATIVE);	if(dataRect.right>worldMax.h)pt2.h = cadFFMax;	if(dataRect.bottom>worldMax.v)pt2.v = cadFFMax;/*	p.h = min(dataRect.right,worldMax.h);	p.v = min(dataRect.bottom,worldMax.v);		pt2 = Local2World(p,SCALE_RELATIVE);*/		scrollMin = min((virtRect.left),(FFRound(origin.h)));	scrollMax = max((virtRect.right),(FFRound(pt2.h)));	width = (long)FFRound(pt2.h) - FFRound(origin.h);	n = scrollMax-scrollMin;	d = VMax;    d>>=1;	if(2 > n) n = 2;	sc = (double)n/d;	check = sc;		while((check < (1<<MAX_PRECISION)) && (scroll2WorldP.h <= MAX_PRECISION))		{ scroll2WorldP.h++; check*=2; }	scroll2World.h = DblToFixed((1<<scroll2WorldP.h)*sc);	world2Scroll.h = DblToFixed((double)d/n);	scrollMin = min((virtRect.top),(-FFRound(origin.v)));	scrollMax = max((virtRect.bottom),(-FFRound(pt2.v)));	n = scrollMax-scrollMin;	d = VMax;	d>>=1;	if(2 > n) n = 2;	sc = (double)n/d;	check = sc;		while((check < (1<<MAX_PRECISION)) && (scroll2WorldP.v <= MAX_PRECISION))		{ scroll2WorldP.v++; check*=2; }	scroll2World.v = DblToFixed(-(1<<scroll2WorldP.v)*sc);	world2Scroll.v = DblToFixed(-(double)d/n);	p = World2Scroll(origin);	SetHScrollValue(p.h);	SetVScrollValue(-p.v);		SetHScroll();	SetVScroll();	}		void Draft::SetHScroll()	{	PointFFixed pt,limPt;	Point		p,wp;	FFixed		width;	int 		pg;		p.h = min(dataRect.right,worldMax.h);	p.h>>=3;	p.v = 0;	pt = Local2World(p,SCALE_RELATIVE);	pt.v = FFZero;	p = World2Scroll(pt);	if(FFErr)p.h = VMax>>4;	scrollStep.h = p.h;	pg = (p.h<<3)-scrollStep.h;		 	if(!scrollStep.h)scrollStep.h = pg; 	// ABD JAP-BUG-FIX EXTRA SANITY CHECK FOR SMALL SCROLL VALUES  	// this is a quick 'n' dirty bug fix -- theoretically these values should never get this 	// small, but somehow if we have large objects then these values can accidentally get 	// super-small.  So we make sure they never get to zero.  This is not a good fix; the 	// proper fix is to see why really big objects screw up everything. 	// ABD JAP [[[ 	if (scrollStep.h == 0) 		scrollStep.h = 1; 	if (pg == 0) 		pg = 1; 	// ABD JAP ]]]	SetHSpeed(SCROLL_DELAY);	SetHMove(scrollStep.h);	SetHPage(pg);	}void Draft::SetVScroll()	{	PointFFixed pt,limPt;	Point		p;	FFixed		width;	int 		pg;			p.h = 0;	p.v = min(dataRect.bottom,worldMax.v);	p.v>>=3;	pt = Local2World(p,SCALE_RELATIVE);	pt.h = FFZero;	p = World2Scroll(pt);	if(FFErr)p.v = VMax>>4;	scrollStep.v = -p.v;	pg = (-p.v<<3)-scrollStep.v;		if(!scrollStep.v)scrollStep.v = pg; 	// ABD JAP-BUG-FIX EXTRA SANITY CHECK FOR SMALL SCROLL VALUES  	// this is a quick 'n' dirty bug fix -- theoretically these values should never get this 	// small, but somehow if we have large objects then these values can accidentally get 	// super-small.  So we make sure they never get to zero.  This is not a good fix; the 	// proper fix is to see why really big objects screw up everything. 	// ABD JAP [[[ 	if (scrollStep.v == 0) 		scrollStep.v = 1; 	if (pg == 0) 		pg = 1;	// ABD JAP ]]]	SetVSpeed(SCROLL_DELAY);	SetVMove(scrollStep.v);	SetVPage(pg);	}	void Draft::SetOrigin(PointFFixed newOrigin)	{	origin = newOrigin;	}PointFFixed Draft::SetToGrid(PointFFixed pt,PointFFixed gridTo)	{	gridTo.h.l = pt.h.l%gridTo.h.l;	gridTo.v.l = pt.v.l%gridTo.v.l;	pt.h = FFSub(pt.h,gridTo.h);	pt.v = FFSub(pt.v,gridTo.v);	return(pt);	} PointFFixedDraft::MakePtInWorld(PointFFixed pt,int forceCenter)	{	Point	checkPt;	Point	edgePt;	edgePt.h = min(dataRect.right,worldMax.h);	edgePt.v = min(dataRect.bottom,worldMax.v);		checkPt = World2Local(pt,SCALE_ABSOLUTE);	if((checkPt.h < 0) || (checkPt.v < 0) 		|| (checkPt.h > edgePt.h) || (checkPt.v > edgePt.v) )		{		if(forceCenter)			{			checkPt.h = centerX;			checkPt.v = centerY;			}		else			{			if(checkPt.h < 0)checkPt.h = 0;			if(checkPt.v < 0)checkPt.v = 0;			if(checkPt.h > edgePt.h)checkPt.h = edgePt.h;			if(checkPt.v > edgePt.v)checkPt.v = edgePt.v;			}		pt = Local2World(checkPt,SCALE_ABSOLUTE);		}	return(pt);	}	void Draft::SetScale()	{	double	tmp,check;		ffLastPt = MakePtInWorld(ffLastPt,TRUE);			lastPositionR = World2Local(ffLastPt,SCALE_ABSOLUTE);	localPrecision = 0;	worldPrecision = 0;		tmp = userScale/userZoom;	check = tmp;		while((check < (1<<MAX_PRECISION)) && (worldPrecision <= MAX_PRECISION))		{ worldPrecision++; check*=2; }	scale2World = DblToFixed((1<<worldPrecision)*tmp);	tmp = userZoom/userScale;		scale2Local = DblToFixed(tmp);		CalcOrigin(origin);	MoveView(ffLastPt,Local2World(lastPositionR,SCALE_ABSOLUTE));	Update();	}void  Draft::FFSetScale(FFixed loc,int locPr,FFixed wrd,int wldPrec)	{	FFixed scal;	/*	ffLastPt = MakePtInWorld(ffLastPt,TRUE);			lastPositionR = World2Local(ffLastPt,SCALE_ABSOLUTE);*/		scale2Local = loc;	localPrecision = locPr;	scale2World = wrd;	worldPrecision = wldPrec;	userZoom = FixedToDbl(scale2Local);		CalcOrigin(origin);	MoveView(ffLastPt,Local2World(lastPositionR,SCALE_ABSOLUTE));	lastPositionR = World2Local(ffLastPt,SCALE_ABSOLUTE);	Update();	}		double Draft::ZoomRect(Rect *r)	{	Point	edgePt;	double 	newZoom,h,v;		edgePt.h = min(dataRect.right,worldMax.h);	edgePt.v = min(dataRect.bottom,worldMax.v);	lastPositionR.h = ((r->right - r->left)>>1) + r->left;	lastPositionR.v = ((r->bottom - r->top)>>1) + r->top;	ffLastPt = Local2World(lastPositionR,SCALE_ABSOLUTE);			h = r->right - r->left;	v = r->bottom - r->top;	h /= (double)edgePt.h;	v /= (double)edgePt.v;	if(h > v) newZoom = h;	else newZoom = v ;			newZoom = userZoom/newZoom;		return(newZoom);	}	void  Draft::SetZoom(double newZoom) { userZoom = newZoom; SetScale(); }double Draft::GetZoom() { return(userZoom); }FFixed Draft::ConvertAngle(FFixed angl)	{	FFixed result;	result = FFMult(degree2Radian,angl);		result = FFShift(result,-8);		return result;	}		PointFFixed Draft::Local2World(Point p,int method)	{	PointFFixed	pt;	pt.h = FFMultIntShift(scale2World,p.h,worldPrecision);	pt.v = FFMultIntShift(scale2World,-p.v,worldPrecision);	if(SCALE_ABSOLUTE == method) 		{		pt.h = FFAdd(pt.h,origin.h);		if(FFERR_OVERFLOW == FFErr)			{ if(VMax < FFOver) pt.h = VFFMax; else if(VMin > FFOver) pt.h = VFFMin; }			pt.v = FFAdd(pt.v,origin.v);		if(FFERR_OVERFLOW == FFErr)			{ if(VMax < FFOver) pt.v = VFFMax; else if(VMin > FFOver) pt.v = VFFMin; }		}	return(pt);	}Point Draft::World2Local(PointFFixed pt,int method)	{	Point p;	long  overFlow;		pt.h = FFMult(scale2Local,pt.h);	if(FFOver>VMax)pt.h = VFFMax; else if(FFOver<VMin)pt.h = VFFMin;	pt.v = FFMult(scale2Local,FFNeg(pt.v));	pt.v = FFShift(pt.v,-localPrecision);	if(FFOver>VMax)pt.v = VFFMax; else if(FFOver<VMin)pt.v = VFFMin;	p.h = FFRound(pt.h);	p.v = FFRound(pt.v);	if(SCALE_ABSOLUTE == method)		{		overFlow = (long)p.h - lOrigin.h;		if(overFlow>VMax)overFlow = VMax; else if(overFlow<VMin)overFlow = VMin;		p.h = overFlow;		overFlow = (long)p.v - lOrigin.v;		if(overFlow>VMax)overFlow = VMax; else if(overFlow<VMin)overFlow = VMin;		p.v = overFlow;		}	return(p);	}PointFFixed Draft::Scroll2World(Point p)	{	PointFFixed	pt;	double h,v;		h =FixedToDbl( FFShift(FFMult(scroll2World.h,FFOne),-scroll2WorldP.h) );	v =FixedToDbl( FFShift(FFMult(scroll2World.v,FFOne),-scroll2WorldP.v) );		h *= p.h;	v *= -p.v;		if(h>VMax)h =VMax;else if(h<VMin)h =VMin;	if(v>VMax)v =VMax;else if(v<VMin)v =VMin;		pt.h =DblToFixed(h);	pt.v =DblToFixed(v);/*	pt.h = FFMultIntShift(scroll2World.h,p.h,scroll2WorldP.h);	pt.v = FFMultIntShift(scroll2World.v,-p.v,scroll2WorldP.v);*/	return(pt);	}Point Draft::World2Scroll(PointFFixed pt)	{	Point p;	int	err;		err = 0;	pt.h = FFShift(pt.h,world2ScrollP.h);if(FFErr)err= FFErr;	pt.v = FFShift(pt.v,world2ScrollP.v);if(FFErr)err= FFErr;	pt.h = FFMult(world2Scroll.h,pt.h); if(FFErr)err= FFErr;	pt.v = FFMult(world2Scroll.v,FFNeg(pt.v));if(FFErr)err= FFErr;	p.h = FFRound(pt.h);	p.v = FFRound(pt.v);		FFErr = err;		return(p);	}	void Draft::MoveView( PointFFixed ptFrom, PointFFixed ptTo )	{	Rect	vRect;	PointFFixed	offset;			offset.h = FFSub(ptTo.h,ptFrom.h);	offset.v = FFSub(ptTo.v,ptFrom.v);	origin.h = FFSub(origin.h,offset.h);	origin.v = FFSub(origin.v,offset.v);	if(theWindow)		{		GetVirtual(&vRect);		virtRect = vRect;		CalcScroll();		}	}/* Optimize - precalculate pt from scrollstep */intDraft::Push(int dh,int dv)	{		PointFFixed	pt,oldOrigin;	Point	p;	long	scrollDelay,bound;	int		result,scrollWidth;    Rect	dRect;			pt = Scroll2World(scrollStep);	oldOrigin = origin;	dRect = dataRect;#if WINDOWS	// On Windows, the scroll bars are on top of the dataRect. Use a	// rect inside the scroll bars for the "Push" calculations.	scrollWidth = VScrollWidth();	dRect.right -= scrollWidth;    dRect.bottom -= scrollWidth;#endif //WINDOWS		if((dh > dRect.left) && (dh < dRect.right)) { dh = 0; pt.h = FFZero; }	if(dh)		{		if(dh < 0) pt.h = FFNeg(pt.h);		bound = (long)FFRound(origin.h)+FFRound(pt.h);		if(bound>VMax) 			bound = VMax; 		else  if(bound<VMin) 			bound = VMin; 		else			origin.h = FFAdd(origin.h,pt.h);					if(virtRect.left > bound )virtRect.left = bound;		else if(virtRect.right < bound )virtRect.right = bound;		}		if((dv > dRect.top) && (dv < dRect.bottom)) { dv = 0; pt.v = FFZero; }	if(dv)		{		if(dv > 0) pt.v = FFNeg(pt.v);		bound = -(long)(FFRound(origin.v)+FFRound(pt.v));		if(bound>VMax) 			bound = VMax; 		else  if(bound<VMin) 			bound = VMin;		else			origin.v = FFAdd(origin.v,pt.v);					if(virtRect.top > bound )virtRect.top = bound;		else if(virtRect.bottom < bound )virtRect.bottom = bound;		}			if(dh||dv)		{				//scrollDelay = VGetTime();		// MERGE23 ABD no delay on auto-scroll				SetPane();		Display(-SCROLL_DRAW,dh,dv);		/* UnsetPane();*/		CalcScroll();		SetScroll(FALSE);		UnsetPane();		result = TRUE;				pt.h = FFSub(oldOrigin.h,origin.h);		pt.v = FFSub(oldOrigin.v,origin.v);			p = World2Local(pt,SCALE_RELATIVE);		anchorPosition.h += p.h;	anchorPosition.v += p.v;		anchorPositionR.h += p.h;	anchorPositionR.v += p.v;		currentPosition.h += p.h;	currentPosition.v += p.v;		currentPositionR.h += p.h;	currentPositionR.v += p.v;		dropAnchor.h += p.h;		dropAnchor.v += p.v;		dropAnchorR.h += p.h;		dropAnchorR.v += p.v;				lastPosition.h += p.h;		lastPosition.v += p.v;		lastPositionR.h += p.h;		lastPositionR.v += p.v;		//while(SCROLL_DELAY > (VGetTime() - scrollDelay));		// MERGE23 ABD no delay on auto-scroll		}			return(result);	}void Draft::Update() { }void Draft::Color(RGBColor clr) { color = clr; }// { DAS-VDRAG 9/3/93int Draft::OKDrop(struct V_Pane *drag){ return TRUE; }void Draft::Drop(Point pt, struct V_Pane *drag){/* do nothing */ }// } DAS-VDRAG 9/3/93