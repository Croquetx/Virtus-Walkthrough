/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "Ruler.h"#include "RuleItem.h"#include "Cntrl.h"#include "DesCntrl.h"#include "CadDraft.h"/* THIS MUST CHANGE */#include "Format.h"#include "AppDeflt.h"#include "CVDefs.h"#include "UndoBuf.h"#include "MiscUndo.h"#include "AppMssgs.h"#include "CVEnvirn.h"#include "CadPosn.h"#include "ToolDef.h"#include "BallHelp.h"#include "Misc.h"#include "VGraphic.h"#include "VGUtil.h"#include "VMath.h"#include "VSound.h"#include "WalkDefs.h"	// MERGE-GOURAUD-PRO-9#include <stdio.h>#include <string.h>	RulerInfo	rulerTable[] = 	{/* 1/64" */	{ INITFIXXED(0 , 0x0400 ) , 8 , 3 },/* old UNIT_INCH_START *//* 1/32" */	{ INITFIXXED(0 , 0x0800 ) , 8 , 3 },/* 1/16" */	{ INITFIXXED( 0 , 0x1000 ) , 8 , 3 },/* 1/8" */	{ INITFIXXED( 0 , 0x2000 ) , 8 , 3 },/* 1/4" */	{ INITFIXXED( 0 , 0x4000 ) , 8 , 3 },/* 1/2" */	{ INITFIXXED( 0 , 0x8000 ) , 8 , 3 },/* 1" */	{ INITFIXXED( 1 , 0x0000 ) , 8 , 3 },/* UNIT_INCH_START *//* 2" */	{ INITFIXXED( 2 , 0x0000 ) , 8 , 3 },/* 6" */	{ INITFIXXED( 6 , 0x0000 ) ,12 , 5 },/* 1' */	{ INITFIXXED( 12 , 0x0000 ) ,12 , 5  },/* 2' */	{ INITFIXXED( 24 , 0x0000 ) ,12 , 5 },/* 5' */	{ INITFIXXED( 60 , 0x0000 ) ,10 , 1 },/* 10' */	{ INITFIXXED( 120 , 0x0000 ) ,10 , 4 },/* 20' */	{ INITFIXXED( 240 , 0x0000 ) ,10 , 4 },/* 50' */	{ INITFIXXED( 600 , 0x0000 ) ,10 , 4 },/* 100' */	{ INITFIXXED( 1200 , 0x0000 ) ,10 , 4 },/* 200' */	{ INITFIXXED( 2400 , 0x0000 ) ,10 , 4 },/* UNIT_INCH_END *//* 500' */	{ INITFIXXED( 6000 , 0x0000 ) ,10 , 4 },/* 1000' */	{ INITFIXXED( 12000 , 0x0000 ) ,10 , 4 },/* 1/16"*/	{ INITFIXXED( 0 , 0x0155 ) ,  8 , 3 },/***//* UNIT_FOOT_START *//* 1/8" */	{ INITFIXXED( 0 , 0x02AB ) ,  8 , 3 },/***//* 1/4" */	{ INITFIXXED( 0 , 0x0555 ) ,  8 , 3 },/***//* 1/2" */	{ INITFIXXED( 0 , 0x0AAB ) ,  8 , 3 },/***//* 1" */	{ INITFIXXED( 0 , 0x1555 ) ,  8 , 3 },/***//* 6" */	{ INITFIXXED( 0 , 0x8000 ) , 12 , 5 },/* 1' */	{ INITFIXXED( 1 , 0x0000 ) , 12 , 5 },/* 2' */	{ INITFIXXED( 2 , 0x0000 ) , 12 , 5 },/* 5' */	{ INITFIXXED( 5 , 0x0000 ) , 10 , 4 },/* 10' */	{ INITFIXXED( 10 , 0x0000 ) ,10 , 4 },/* 20' */	{ INITFIXXED( 20 , 0x0000 ) ,10 , 4 },/* 50' */	{ INITFIXXED( 50 , 0x0000 ) ,10 , 4 },/* 100' */	{ INITFIXXED( 100 , 0x0000 ) ,10 , 4 },/* 200' */	{ INITFIXXED( 200 , 0x0000 ) ,10 , 4 },/* 500' */	{ INITFIXXED( 500 , 0x0000 ) ,10 , 4 },/* 1000' */	{ INITFIXXED( 1000 , 0x0000 ) ,10 , 4 },/* 2000' */	{ INITFIXXED( 2000 , 0x0000 ) ,10 , 4 },/* 5000' */	{ INITFIXXED( 5000 , 0x0000 ) ,10 , 4 },/* 10000' */{ INITFIXXED( 10000 , 0x0000 ) ,10 , 4 },/* UNIT_FOOT_END *//* 1/64Mi*/	{ INITFIXXED( 0 , 0x0400 ) , 10 , 10 },/* UNIT_MILE_START *//* 1/32Mi */{ INITFIXXED( 0 , 0x0800 ) , 10 , 10 },/* 1/16Mi */{ INITFIXXED( 0 , 0x1000 ) , 10 , 10 },/* 1/8Mi */	{ INITFIXXED( 0 , 0x2000 ) , 10 , 10 },/* 1/4Mi */	{ INITFIXXED( 0 , 0x4000 ) , 10 , 10 },/* 1/2Mi */	{ INITFIXXED( 0 , 0x8000 ) , 10 , 10 },/* 1Mi */	{ INITFIXXED( 1 , 0x0000 ) , 10 , 10 },/* 2Mi */	{ INITFIXXED( 2 , 0x0000 ) , 10 , 10 },/* 5Mi */	{ INITFIXXED( 5 , 0x0000 ) , 10 , 10 },/* 10Mi */	{ INITFIXXED( 10 , 0x0000 ) ,10 , 10 },/* 20Mi */	{ INITFIXXED( 20 , 0x0000 ) ,10 , 10 },/* 50Mi */	{ INITFIXXED( 50 , 0x0000 ) ,10 , 10 },/* 100Mi */	{ INITFIXXED( 100 , 0x0000 ) ,10 , 10 },/* 200Mi */	{ INITFIXXED( 200 , 0x0000 ) , 10 , 10 },/* 500Mi */	{ INITFIXXED( 500 , 0x0000 ) , 10 , 10 },/* 1000Mi */{ INITFIXXED( 1000 , 0x0000 ) ,10 , 10  },/* 2000Mi */{ INITFIXXED( 2000 , 0x0000 ) , 10 , 10 },/* 5000Mi */{ INITFIXXED( 5000 , 0x0000 ) , 10 , 10 },/* 10000Mi */{ INITFIXXED( 10000 , 0x0000 ) , 10 , 10 },/* UNIT_MILE_END *//* 1/100m*/	{ INITFIXXED( 0 , 0x028F ) , 10 , 10 },/* 1/50m */{ INITFIXXED( 0 , 0x051F ) , 10 , 10 },/* 1/20m */{ INITFIXXED( 0 , 0x0CCD ) , 10 , 10 },/* old UNIT_METRIC_START *//* 1/10m */	{ INITFIXXED( 0 , 0x199A ) , 10 , 10 },/* 1/5m */	{ INITFIXXED( 0 , 0x3333 ) , 10 , 10 },/* 1/2m */	{ INITFIXXED( 0 , 0x8000 ) , 10 , 10 },/* 1m */	{ INITFIXXED( 1 , 0x0000 ) , 10 , 10 },/* UNIT_METRIC_START *//* 2m */	{ INITFIXXED( 2 , 0x0000 ) , 10 , 10 },/* 5m */	{ INITFIXXED( 5 , 0x0000 ) , 10 , 10 },/* 10m */	{ INITFIXXED( 10 , 0x0000 ) , 10 , 10 },/* 20m */	{ INITFIXXED( 20 , 0x0000 ) , 10 , 10 },/* 50m */	{ INITFIXXED( 50 , 0x0000 ) , 10 , 10 },/* 100m */	{ INITFIXXED( 100 , 0x0000 ) , 10 , 10 },/* 200m */	{ INITFIXXED( 200 , 0x0000 ) , 10 , 10 },/* 500m */	{ INITFIXXED( 500 , 0x0000 ) , 10 , 10 },/* 1000m */	{ INITFIXXED( 1000 , 0x0000 ) ,10 , 10  },/* 2000m */	{ INITFIXXED( 2000 , 0x0000 ) ,10 , 10  },/* 5000m */	{ INITFIXXED( 5000 , 0x0000 ) , 10 , 10 },/* 10000m */{ INITFIXXED( 10000 , 0x0000 ) , 10 , 10 }/* UNIT_METRIC_END */	};void Ruler::SetController(Controller *ctrl) { controller = ctrl; }	void Ruler::SetEnvironment(CAVEnvironment *e) { environment = e; }void Ruler::SetAxis(char ax) 	{	RulerItemDef	*itemDef;		defAxis = ax; 	if(localOrigin) { itemDef = localOrigin->GetItemDef(); itemDef->SetAxis(defAxis); }	if(extrusionRange) { itemDef = extrusionRange->GetItemDef(); itemDef->SetAxis(defAxis); }	}void Ruler::SetSide(char s) { side = s; }		void Ruler::cPane(int flag)	{	RulerItemDef	*itemDef;		V_Pane::cPane(flag);		tickTable = new(TickArray);	tickTable->cArray(0,sizeof(TickMark),16);		formatter = new(Formatter);	formatter->cFormat();		environment = NULL;	rulerItems = new(V_Array);	rulerItems->cArray(0,sizeof(RulerItem*),4);	extrusionRange = NULL;			itemDef = new(RulerItemDef);	itemDef->cRulerItemDef();	itemDef->SetValue(FFZero);	itemDef->SetAxis(defAxis);	localOrigin = new(RulerItem);	localOrigin->cRulerItem();	localOrigin->SetItemDef(itemDef);	localOrigin->SetType(originItem);		unitWidth = 0;	rulerInfo.divisions = 0;						rulerInfo.majorTick = 0;	start = 0;								position = 0;	side = POSITIVE_SIDE;	origin = FFZero;	offsetOrigin = FFZero;	anchor = FFZero;	gridUnit = FFZero;	gridPrecision = 0;	snapOrigin = FFZero;	color = vBlack;	backColor = vWhite;	editMode = outRulerItem;	SetDirection(HORZ_RULER);		SetState(SHOW_RULER,TAB_STATE);	SetState(FALSE,SNAP_STATE);	SetTabs(FFZero,FFZero);	SetScale(1.0);	}void Ruler::dPane()	{	RulerItem	**pItems;	RulerItemDef	*itemDef;	int	i,length;		if(extrusionRange)		{		itemDef = extrusionRange->GetItemDef();		itemDef->dRulerItemDef();		extrusionRange->dRulerItem();		}	itemDef = localOrigin->GetItemDef();	itemDef->dRulerItemDef();	localOrigin->dRulerItem();		KillList();	rulerItems->dArray();		tickTable->dArray();	formatter->dFormat();	V_Pane::dPane();	}		void Ruler::Center(FFixed ctr)	{	FFixed	value;	int end;	end = GetEnd();	value = Local2World(end,RSCALE_ABSOLUTE);	value = FFAdd(FFShift(FFSub(value,origin),-1),origin);	value = FFSub(ctr,value);	value = FFAdd(origin,value);	SetOrigin(value);	}voidRuler::AddRange()	{	RulerItemDef	*itemDef;	if(!extrusionRange)		{		itemDef = new(RulerItemDef);		itemDef->cRulerItemDef();		itemDef->SetValue(FFZero);		itemDef->SetAxis(defAxis);				extrusionRange = new(RulerItem);		extrusionRange->cRulerItem();		extrusionRange->SetItemDef(itemDef);		extrusionRange->SetType(rangeItem);		}	}void Ruler::GetVirtual(Rect *r)	{	*r = VMaxRect;	}			void Ruler::CalcSize(Rect *r,Point *p,int type,int warning)	{	int flag;	width = 0;	if( SHOW_TAB&showState ) width += TAB_WIDTH;	if( SHOW_RULER&showState ) width += RULER_WIDTH;	if(HORZ_RULER == direction)		{		r->left = r->bottom = width+1;		r->left++;		if( r->bottom ) r->bottom++;		}	else		{		r->top = r->right = width+1;		r->top++;		if( r->right ) r->right++;		}	if( HORZ_RULER == direction) flag = objHorzRuler;	else flag = objVertRuler;	controller->GetPlace(r,warning,flag);		}void Ruler::CalcScroll()	{	FFixed	pt,lim;	long	n,d;	double	sc,check;	int		scrollMin,scrollMax,p;	int		val,end;		scrollRect = VMaxRect;	scroll2World = FFOne;	world2Scroll = FFOne;	scrollPrecision = 0;		/* calculate the scrollBar scale */	if(HORZ_RULER == direction)		{		p = min(dataRect.right,worldMax);		pt = Local2World(p,RSCALE_ABSOLUTE);		scrollMin = min(virtRect.left,FFRound(origin));		scrollMax = max(virtRect.right,FFRound(pt));		}	else		{		p = min(dataRect.bottom,worldMax);		pt = Local2World(p,RSCALE_ABSOLUTE);		scrollMin = min(virtRect.top,-FFRound(origin));		scrollMax = max(virtRect.bottom,-FFRound(pt));		}					n = max(scrollMax,-scrollMin);	d = VMax;	if(2 > n) n = 2;	sc = (double)n/d;	check = sc;		while((check < (1<<RMAX_PRECISION)) && (scrollPrecision <= RMAX_PRECISION))		{ scrollPrecision++; check*=2; }	scroll2World = DblToFixed((1<<scrollPrecision)*sc);	scroll2World = DblToFixed(sc);	world2Scroll = DblToFixed((double)d/n);/* calculate the scrollBar value for the current origin */	val = World2Scroll(origin);	/* calculate the scrollBar step value *//* a step is a quarter of the visible world screen */	end = min(GetEnd(),worldMax);	pt = Local2World(end,RSCALE_RELATIVE);	pt = FFShift(pt,-2);	scrollStep = World2Scroll(pt);	SetVScrollValue(val);SetHScrollValue(val);	}void Ruler::SetHScroll()	{	int 	pg;			pg = scrollStep<<1;		SetHSpeed(SCROLL_DELAY);	SetHMove(scrollStep);	SetHPage(pg);	}	void Ruler::SetVScroll()	{	int 	pg;			pg = scrollStep<<1;		SetVSpeed(SCROLL_DELAY);	SetVMove(scrollStep);	SetVPage(pg);	}	int offscrn = TRUE;void Ruler::Display(int type,int x,int y)	{	TickMark	*tickMark;	Rect	r;	Point	p;	FFixed	pt,val;	long	oldOrigin,newOrigin,scrollDelay;	int  	divCount;	int		length,i,dp,where;		trackState = TICK_OFF;			VSetPattern(vPatBlack);	VPenMode(vPatCopy);			r = dataRect;		switch(type)		{		case -DRAW: /* DRAW ONLY THE TABS */			SetMetaPort();			GetTabRect(&r);			if(HORZ_RULER == direction)            	r.top--;			else r.left--;			if(depth<4)				VEraseRect(&r);			else				{				VForeColor(&backColor);				VPaintRect(&r);					}			DisplayTab();			if(depth > 2) VForeColor(&color);            			if(HORZ_RULER == direction)				{				DisplayTick(dataRect.left,-(TAB_WIDTH+1));				//DisplayTick(dataRect.left+width,-TAB_WIDTH);				}			else				{				DisplayTick(dataRect.top,-(TAB_WIDTH+1));			   //DisplayTick(dataRect.top+width,-TAB_WIDTH);				}            			if(grayOut)				{				VPenMode(vPatBic);				VSetPattern(vPatGray);				VPaintRect(&r);				VSetPattern(vPatBlack);				VPenMode(vPatCopy);				}			MetaCopy(&r);			UnsetMetaPort();			break;					case -SCROLL_DRAW:			if(HORZ_RULER == direction) where = x; else where = y;			pt = Scroll2World(where);			pt = FFAdd(origin,pt);			origin = SetOrigin(pt);			if(rulerNoMode != editMode) 				lAnchor = World2Local(anchor,RSCALE_ABSOLUTE);			break;					case SCROLL_DRAW:			if(HORZ_RULER == direction) where = x; else where = y;			pt = Scroll2World(where);			origin = SetOrigin(pt);			if(rulerNoMode != editMode) 				lAnchor = World2Local(anchor,RSCALE_ABSOLUTE);					case ACT_REBUILD_DRAW:		case ACT_REDRAW:		case DRAW:			if(  (SHOW_RULER&showState) && (SCROLL_DRAW != type)) Update();					default:			SetMetaPort();			if(depth<4)				VEraseRect(&r);			else				{				VForeColor(&backColor);				VPaintRect(&r);					}							if(depth > 2) VForeColor(&color);						if(HORZ_RULER == direction) TextSetUp(vMonacoFont,vMediumFont,vNormal);			else TextSetUp(vVerticalFont,vSmallFont,vNormal);							if( SHOW_TAB&showState)				{				DisplayTab();				if(depth > 2) VForeColor(&color);				DisplayLine(0);				}			else								if(depth > 2) VForeColor(&color);			if(  SHOW_RULER&showState )				{					if( SHOW_TAB&showState) DisplayLine(TAB_WIDTH+1);				else DisplayLine(0);								length = tickTable->ALength();				tickMark = (TickMark*)tickTable->Use();								divCount = 1;									for(i = 0; i < length; i++,tickMark++)												{					switch(tickMark->type)						{						case unitTick:							val = GridLoc(divCount++,0);							DisplayNumber(val,tickMark->where);							DisplayTick(tickMark->where,RULER_WIDTH);							break;						case majorTick:							DisplayTick(tickMark->where,MAJOR_WIDTH);							break;						case minorTick:							DisplayTick(tickMark->where,MINOR_WIDTH);							break;						case guideTick:							break;						}					}								tickTable->Unuse();					}						DisplayDocket();			DisplayExtreme();			if(grayOut)				{				VPenMode(vPatBic);				VSetPattern(vPatGray);				VPaintRect(&r);				VSetPattern(vPatBlack);				VPenMode(vPatCopy);				}						MetaCopy(&r);			UnsetMetaPort();			TextSetUp(vSystemFont,vSystemFontSize,vNormal);			break;		}					}void Ruler::DisplayLine(int w)	{	int	to;	w--;	if(HORZ_RULER == direction)		{		if(dataRect.right>worldMax)to = worldMax; else to = dataRect.right;		VMoveTo(dataRect.left,0);		VLineTo(dataRect.left,dataRect.top+width - w);		VLineTo(to,dataRect.top+width - w);		VLineTo(to,0);		}	else		{		if(dataRect.bottom>worldMax)to = worldMax; else to = dataRect.bottom;		VMoveTo(0,dataRect.top);		VLineTo(dataRect.left+width - w,dataRect.top);		VLineTo(dataRect.left+width - w,to);		VLineTo(0,to);		}	}voidRuler::GetTabRect(Rect *r) 	{ 		*r = dataRect;	if(HORZ_RULER == direction)		{		r->top++;		r->bottom=r->top+width;		if(  SHOW_RULER&showState ) r->top += RULER_WIDTH+1;		r->right-=DOCKET_WIDTH;		}	else		{		r->left++;		r->right=r->left+width;		if(  SHOW_RULER&showState ) r->left += RULER_WIDTH+1;		r->bottom-=DOCKET_WIDTH;		}	}void Ruler::DisplayTab()	{	RulerItem	**pItems;	FFixed	visibleMin,visibleMax;	int		i,length,bottom;		char	check;		VSetPattern(vPatBlack);	if(HORZ_RULER == direction) 		{		visibleMin = Local2World(0,RSCALE_ABSOLUTE);		visibleMax = Local2World(min(dataRect.right,worldMax),RSCALE_ABSOLUTE);		}	else 		{		visibleMax = Local2World(0,RSCALE_ABSOLUTE);		visibleMin = Local2World(min(dataRect.bottom,worldMax),RSCALE_ABSOLUTE);		}		if(extrusionRange && (SHOW_RANGE&showState))		extrusionRange->Display(this,visibleMin,visibleMax,FFZero,direction);	if(SHOW_ORIGIN&showState)		localOrigin->Display(this,visibleMin,visibleMax,FFZero,direction);	if(rulerItems && (SHOW_GUIDE&showState) && (length = rulerItems->ALength()))		{		pItems = (RulerItem	**)rulerItems->Use();		for( i = 0 ; i < length; i++,pItems++)			(*pItems)->Display(this,visibleMin,visibleMax,FFZero,direction);						rulerItems->Unuse();		}	}	void Ruler::DisplayTick(int where,int length)	{	int	tabOffset;	if(length<0)length--;	else length++;	if(HORZ_RULER == direction)		{		if(SHOW_TAB&showState)tabOffset = dataRect.top+width - TAB_WIDTH-1; 		else tabOffset = dataRect.top+width;		VMoveTo(where,tabOffset);		VLineTo(where,tabOffset - length);		}	else		{		if(SHOW_TAB&showState)tabOffset = dataRect.left+width - TAB_WIDTH-1;		else tabOffset = dataRect.left+width;		VMoveTo(tabOffset,where);		VLineTo(tabOffset - length,where);		}	}void Ruler::DisplayNumber(FFixed val,int where)	{	char str[256];	Rect r;		int	tabOffset;	int	i;#if WINDOWS	VTextMode(vSrcXor);#elif MACINTOSH	VTextMode(vSrcOr);#endif //WINDOWS	// MERGE-GOURAUD-PRO-9 [[[	if (HORZ_RULER == direction)	{		// for horizontal rulers, we must flip the bottom view, inside view, back view,		// and left view		switch(((CadControl*)controller)->environment->view)			{			case topView:			case frontView:			case rightView:			case outsideView:				/* do nothing */				break;				case bottomView:			case backView:			case leftView:			case insideView:				val.intg = -val.intg;				break;			}	}	else	// vertical ruler	{		// for vertical rulers, we don't flip anything		/* do nothing */	}	// MERGE-GOURAUD-PRO-9 ]]]	formatter->Format(val,str);		if(HORZ_RULER == direction)		{		if(SHOW_TAB&showState)r.bottom = dataRect.top+width - TAB_WIDTH - MAJOR_WIDTH; 		else r.bottom = dataRect.top+width - MAJOR_WIDTH+1;		r.top = r.bottom-vMediumFont;		r.left = where -11;		VDrawText(str,0,strlen(str),&r);		}	else		{		if(SHOW_TAB&showState)r.left = dataRect.left+width - TAB_WIDTH - MAJOR_WIDTH - 9; 		else r.left = dataRect.left+width - MAJOR_WIDTH - 8;		r.bottom=where;		r.top = r.bottom-vSmallFont;		i = 0;#if WINDOWS		r.top+=13;		r.bottom+=13;#elif MACINTOSH		r.top+=7;		r.bottom+=10;#endif //WINDOWS				while(str[i] != '\0')			{													VDrawChar(str[i],&r);			r.top-=6;			r.bottom-=6;			i++;								}			}#if WINDOWS	VTextMode(vSrcOr);#endif	}int	Ruler::InDocket(Point p)	{	Rect r;	GetDocketRect(&r);	if(VPtInRect(p,&r))return(rulerInDocket);	else return(rulerNoMode);	}void	Ruler::DoDocket(Point p,long modifiers,int thisEvent)	{		AppPreference 	*appPref;	EditorPreference *editPref;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	RulerItemDef	*itemDef;	Rect 	r;	FFixed	last,offset,value1,value2;	short	where,type,msg,objType,realWhere;		where = Parse(p);	last = Constrain(&where);				switch(thisEvent)		{		case MOUSE_DOWN:			SetTrackSet(POSITION_EDIT);			if(SHOW_BADTHING&showState && (inRulerItemRange != editItem->GetState()))				{				pcc(controller)->DrawGuide(lLast,direction,drawStep);				pcc(controller)->DrawGuide(lLast,direction,drawStay);				}			break;				case MOUSE_PUSH:			realWhere = Parse(p);			if((realWhere>GetEnd()) || (realWhere < 0))				{				if(SHOW_BADTHING&showState && (inRulerItemRange != editItem->GetState())) 					pcc(controller)->DrawGuide(lLast,direction,drawPush);				Push(p.h,p.v);				break;				}		case MOUSE_TRACK:			SetMetaPort();						GetTabRect(&r);			if(HORZ_RULER == direction)				r.top--;            else r.left--;			if(depth<4)				VEraseRect(&r);			else				{				VForeColor(&backColor);				VPaintRect(&r);					}			editItem->MoveItem(this,anchor,lLast,direction);			VForeColor(&vBlack);			if(HORZ_RULER == direction)				{				DisplayTick(dataRect.left,-(TAB_WIDTH+1));				DisplayTick(dataRect.right,-(TAB_WIDTH+1));				}			else				{				DisplayTick(dataRect.top,-(TAB_WIDTH+1));				DisplayTick(dataRect.bottom,-(TAB_WIDTH+1));				}								MetaCopy(&r);			UnsetMetaPort();			if(SHOW_BADTHING&showState && (inRulerItemRange != editItem->GetState()))				{				if(lLast == where) 					pcc(controller)->DrawGuide(lLast,direction,drawStay);				else					{					pcc(controller)->DrawGuide(lLast,direction,drawMove);					lLast = where;					pcc(controller)->DrawGuide(lLast,direction,drawMove);					}				}			else				lLast = where;			break;					case MOUSE_UP:					SetTrackSet(POSITION_TRACK);			if(SHOW_BADTHING&showState && (inRulerItemRange != editItem->GetState()))				pcc(controller)->DrawGuide(lLast,direction,drawCancel);							if(lAnchor != lLast)				{				offset = FFSub(last,anchor);				if(side != POSITIVE_SIDE) offset = FFNeg(offset);				type = editItem->GetType();								itemDef = editItem->GetItemDef();				undoItem = NewUndoItem(UNDO_CAD_FLAG);				undoSpec = undoItem->cEditSpec(_EDIT_HEIGHT);				((UCadHeight*)undoSpec)->SetOffset(offset);				((UCadHeight*)undoSpec)->SetType(editItem->GetState(),defAxis,type);								if(guideItem == type)					{					if(rulerItems && (0>rulerItems->Find(&editItem)))						{						undoSpec = undoItem->cEditSpec(_EDIT_GUIDE_CREATE);						appPref = controller->GetPreference();						editPref = (EditorPreference*)appPref->GetPreference(preferEditor);						itemDef->SetColor(editPref->guideColor);						((UCadHeight*)undoSpec)->SetList(pcc(controller)->guideLines);						}					else						{						if(InDocket(p))							{							undoSpec = undoItem->cEditSpec(_EDIT_GUIDE_DELETE);							((UCadHeight*)undoSpec)->SetList(pcc(controller)->guideLines);							editItem = NULL;							}						}					}								undoItem->SetEditObject(itemDef,NULL,UNDO_CAD_FLAG);				undoItem->Edit();				pcc(controller)->SetRulerValue(type,itemDef);				if(editItem)					{					editItem->ScaleItem(this,side);					editItem->SetState(outRulerItem);					}				}			else				{				editItem->SetState(outRulerItem);				VDisplay(DRAW);				}			break;		}	}		voidRuler::GetDocketRect(Rect *r)	{	*r = dataRect;	if(HORZ_RULER == direction)		{		r->right = min(worldMax,dataRect.right);		r->left = r->right-DOCKET_WIDTH;		}	else		{		r->bottom = min(worldMax,dataRect.bottom);		r->top = r->bottom-DOCKET_WIDTH;				}	}void Ruler::DoTab(Point p,long modifiers,int thisEvent) {}void Ruler::DisplayDocket() 	{	Rect 	r,txtR;	Point	p;	long	*loc;	int		i,length,where,bottom;	char	ch;		GetDocketRect(&r);if(HORZ_RULER == direction) { r.top--; r.right++; } else { r.left--; r.bottom++; } /* DWE */	if(depth>2) 		{		VForeColor(&vColorSlateD);		VPaintRect(&r);		}	else		VEraseRect(&r);			VForeColor(&vBlack);	VMoveTo(r.left,r.bottom);	VLineTo(r.left,r.top);	VLineTo(r.right-1,r.top);	VForeColor(&vBlack);	VLineTo(r.right-1,r.bottom-1);	VLineTo(r.left,r.bottom-1);if(HORZ_RULER == direction) { r.top++; r.right--; } else { r.left++; r.bottom--; } /* DWE */	VForeColor(&vBlack);		if(HORZ_RULER == direction)		{		p.h = r.left + 5;		p.v = r.top + 10;		}	else		{		p.h = r.left + 4;		p.v = r.top + 11;		}	switch(defAxis)		{		case 1:	ch = 'X'; break;		case 2: ch = 'Y';break;		case 3: ch = 'Z';break;		}	TextSetUp(vMonacoFont,vMediumFont,vNormal);#if WINDOWS	VTextMode(vSrcXor);#elif MACINTOSH	VTextMode(vSrcOr);#endif //MACINTOSH	txtR.left = p.h;	txtR.bottom=p.v;	txtR.top=txtR.bottom-vMediumFont;	VDrawChar(ch,&txtR);	VTextMode(vSrcOr);	if(showState&(SHOW_GUIDE|SHOW_ORIGIN|SHOW_RANGE))		{		if(HORZ_RULER == direction)			{			where = r.left + ((r.right-r.left)>>1);			bottom = r.bottom;			}		else			{			where = r.top + ((r.bottom-r.top)>>1);			bottom = r.right;			}		bottom-=3;		if(!(SHOW_GUIDE&showState))VSetPattern(vPatGray);		DrawGuideSymbol(bottom,where,direction,guideItem);		VSetPattern(vPatBlack);		}	}	void Ruler::DisplayExtreme()	{	Rect 	r;	if(HORZ_RULER == direction)		{		if(worldMax<dataRect.right)			{			VForeColor(&vBlack);			VSetPattern(vPatGray);			r = dataRect;			r.left = worldMax;			VPaintRect(&r);			VSetPattern(vPatBlack);			VMoveTo(r.left,r.top);			VLineTo(r.left,r.bottom);			}		}	else		{		if(worldMax<dataRect.bottom)			{			VForeColor(&vBlack);			VSetPattern(vPatGray);			r = dataRect;			r.top = worldMax;			VPaintRect(&r);			VSetPattern(vPatBlack);			VMoveTo(r.left,r.top);			VLineTo(r.right,r.top);			}		}	}		FFixed Ruler::Constrain(short *where)	{	RulerItem	*pItem;	RulerItemDef *itemDef;	TickMark	*tickMark;	FFixed	result;	int		length,i,lastTick,nextTick,loc,done;	int		count,gridLoc,divCount;		if(*where>worldMax) *where = worldMax;	loc = *where;	done = FALSE;	gridLoc = FALSE;	count = 0;	divCount = 0;		length = tickTable->ALength();	tickMark = (TickMark*)tickTable->Use();	lastTick = tickMark->where;		for(i = 0; i < length; i++,tickMark++)		{		if(loc>tickMark->where)lastTick = tickMark->where;/* keep going */		else 			{			if(loc==tickMark->where)/* exactly right - special conversion here */				{				done = TRUE;				gridLoc = TRUE;				}			else 				{				done = TRUE;				if( snapState )					{					if((loc-lastTick) < (tickMark->where-loc))  						{ 						tickMark--;						if(count) count--;						else { count = rulerInfo.divisions-1; divCount--; }						}					loc = tickMark->where;					}				}			}									if(done)			{			if( snapState )  *where = loc;			break;			}						if(tickMark->type != guideTick)			{			if(++count>=rulerInfo.divisions)				{ count = 0; divCount++; }			}		}			tickTable->Unuse();		if(snapState || gridLoc)		{		if(tickMark->type == guideTick) 			{			rulerItems->Get(tickMark->index,&pItem);					itemDef = pItem->GetItemDef();			result = itemDef->GetValue();				}		else result = GridLoc(divCount,count);		}	else		result = Local2World(*where,RSCALE_ABSOLUTE);			return(result);	}FFixed Ruler::GridLoc(int divCount,int count)	{	FFixed	result,fixup,floorFix;		floorFix = FFMultIntShift(rulerInfo.scale,divCount ,0);	if(count) fixup = FFMultIntShift(gridUnit,count,gridPrecision);	else fixup = FFZero;	if(HORZ_RULER == direction) 		{		result = FFAdd(snapOrigin,floorFix);		result = FFAdd(result,fixup);		}	else  		{		result = FFSub(snapOrigin,floorFix);		result = FFSub(result,fixup);		}		return(result);		}	FFixed Ruler::RulerTrack(short *where,int force)	{	FFixed	worldLoc;		worldLoc = Constrain(where);		if(position == *where && force == trackState) return(worldLoc);	if(  SHOW_RULER&showState )			{		SetPane();		VPenMode(vPatXor);		VSetPattern(vPatGray);		if((TICK_ON & trackState))			{			DisplayTick(position,TRACK_WIDTH);			trackState = TICK_OFF;			}					position = *where;				if((TICK_ON & force) && (TICK_OFF & trackState))			{			DisplayTick(position,TRACK_WIDTH);			trackState = TICK_ON;			}			VSetPattern(vPatBlack);		VPenMode(vPatCopy);		UnsetPane();		}	else		position = *where;		*where = position;		return(worldLoc);	}void Ruler::MouseDown(Point p,long modifiers)	{	RulerItem	**pItem;	RulerItemDef	*itemDef;	FFixed	loc,selectRange;	int		i,length;	short 	where,result;	FFixed	value1,value2,tmp;		if(grayOut) return;		editItem = NULL;		if(InDocket(p))		{		if((showState&SHOW_ORIGIN) && (AUTO_SELECT&modifiers)) 			{			tmp = Constrain(&where);			itemDef = localOrigin->GetItemDef();			localOrigin->SetState(inRulerItem);			loc = itemDef->GetValue();			editItem = localOrigin;			}		else 			if(showState&SHOW_GUIDE)				{				itemDef = new(RulerItemDef);				itemDef->cRulerItemDef();				itemDef->SetValue(FFZero);				itemDef->SetAxis(defAxis);				editItem = new(RulerItem);				editItem->cRulerItem();				editItem->SetState(inRulerItem);				editItem->SetItemDef(itemDef);				editItem->SetType(guideItem);				tmp = Constrain(&where);				loc = FFZero;				}		}	else		{		where = Parse(p) ;		if(InTab(p))			{			if(AUTO_SELECT&modifiers && extrusionRange)				{				extrusionRange->SetState(inRulerItemRange);				editItem = extrusionRange;				}			else				editItem = FindItem(where,&loc);								}			}				if((extrusionRange==editItem) && (doubleClick&modifiers) 		&& (toolCRTLDesign == controller->GetType()))		{		ppc(controller)->SetExtrudeHeight(defAxis);		editMode = outRulerItem;		editItem = NULL;		}	if(NULL != editItem)		{		tmp = Constrain(&where);/* UNSURE ABOUT THE CONSTRAINT SITUATION */		itemDef = editItem->GetItemDef();		value1 = itemDef->GetValue();		value2 = itemDef->GetValue2();		switch(editItem->GetState())			{			case inRulerItem:anchor = value1;break;			case inRulerItem2:anchor = value2;break;			case inRulerItemRange: 				if(!(AUTO_SELECT&modifiers))					{					if(side == NEGATIVE_SIDE)anchor = FFNeg(tmp);					else anchor = tmp;					}				else					{					FFMin(loc,value1,value2);					FFMax(value2,value1,value2);					value1 = loc;					loc = FFSub(value2,value1);					loc = FFShift(loc,-1);					loc = FFAdd(loc,value1);					anchor = loc;					}				break;				}				if(side == NEGATIVE_SIDE)anchor = FFNeg(anchor);		lAnchor = World2Local(anchor,RSCALE_ABSOLUTE);		lLast = where;		editMode = inRulerItem;		DoDocket(p,modifiers,MOUSE_DOWN);		}	}RulerItem	*Ruler::FindItem(int where,FFixed *loc)	{	RulerItem	*theItem,**pItem;	FFixed	selectRange;	int		i,length;	theItem = NULL;	if(showState&SHOW_GUIDE && rulerItems)		{		length = rulerItems->ALength();		if(length)			{			pItem = (RulerItem	**)rulerItems->Use();			for( i = 0; i < length; i++,pItem++)				if((*pItem)->FindLocal(where))					{ 					theItem = (*pItem); 					break; 					}			rulerItems->Unuse();			}		}	if(showState&SHOW_ORIGIN && !theItem && localOrigin)		if(localOrigin->FindLocal(where))			theItem = localOrigin;			if(showState&SHOW_RANGE && !theItem && extrusionRange)		if(extrusionRange->FindLocal(where))			theItem = extrusionRange;						return theItem;	}	voidRuler::TrackHelp(Point pt,long modifiers)// DAS-VWINDOWS 9/30/93	{// { DAS-VR-HELP 9/30/93#if VWT	RulerItem *theItem;	Rect r;	FFixed loc;	int  where;		if(rulerNoMode != editMode) return;		if(InDocket(pt))		{		GetDocketRect(&r);		Bubble(pt,&r,TXTB_DOCK);		}	else		{		where = Parse(pt);		if(InTab(pt))			{			theItem = FindItem(where,&loc);				r = dataRect;			BalloonHotRect(&r,pt);			if(!theItem)				Bubble(pt,&r,TXTB_RULERS);				else				{				switch(theItem->GetType())					{					case guideItem: Bubble(pt,&r,TXTB_GUIDELINE); break;					case rangeItem: Bubble(pt,&r,TXTB_DEPTHCONTROL); break;					case originItem: Bubble(pt,&r,TXTB_ORIGIN); break;									}				theItem->SetState(outRulerItem);				}			}			}#elif VR	Rect r;	r=dataRect;	BalloonHotRect(&r,pt);	Bubble(pt,&r,TXTB_RULERS);	#endif// } DAS-VR-HELP 9/30/93	}	intRuler::Push(int dh,int dv)	{		pcc(controller)->Push(dh,dv);	if(rulerNoMode != editMode) 		lAnchor = World2Local(anchor,RSCALE_ABSOLUTE);	}	static int lastInside = FALSE;void Ruler::Track(Point p,long modifiers,int inside)	{	TrackData	trackData;	FFixed loc,anch;	int thisEvent;		if(grayOut) return;	if(!inside)			{		if(!(buttonDown & modifiers)) 			{ 			if(lastInside!=inside)				{				pcc(controller)->ClearTrack(); 				lastInside = inside; 				}			return; 			}		}	lastInside = inside;		VSetCursor(vCursorArrow);	position = Parse(p);	loc = RulerTrack(&position,FALSE);	anch = anchor;		trackData.angle = FFAngleZero;	trackData.flag = 0;		trackData.point.x = loc; 	trackData.anchor.x = anch;	trackData.point.y = loc; 	trackData.anchor.y = anch; 	trackData.point.z = loc; 	trackData.anchor.z = anch; 	pcc(controller)->RulerTrack(&trackData);		SetPane();			if(!inside && (buttonDown & modifiers))  thisEvent = MOUSE_PUSH;	else  thisEvent = MOUSE_TRACK;		if(outRulerItem != editMode && editItem)		DoDocket(p,modifiers,thisEvent);	}void Ruler::MouseUp(Point p,long modifiers)	{		if(grayOut) return;	if(inRulerItem == editMode)		DoDocket(p,modifiers,MOUSE_UP);		editMode = outRulerItem;	editItem = NULL;	}int Ruler::GetAction(long action,long modifiers)	{	EditSpecList	*undoItem;	RulerItem		*pItem;	RulerItemDef	*itemDef,*testDef;	V_Array			*undoItems;	EditSpec		*undoSpec;	FFixed			value1,value2;	int 			length,result,type,objType,undoType,theAxis;		switch(action)		{			case  MSG_ORIGIN:			itemDef = localOrigin->GetItemDef();			value1 = FFNeg(itemDef->GetValue());			undoItem = NewUndoItem(UNDO_CAD_FLAG);			undoSpec = undoItem->cEditSpec(_EDIT_HEIGHT);			((UCadHeight*)undoSpec)->SetOffset(value1);			((UCadHeight*)undoSpec)->SetType(inRulerItem,defAxis,originItem);			undoItem->SetEditObject(itemDef,NULL,UNDO_CAD_FLAG);			undoItem->Edit();			pcc(controller)->SetRulerValue(originItem,itemDef);			result = FALSE;			break;						case  MSG_UNDO:			undoItem = UndoItem();			undoType = undoItem->GetType();			if((UNDO_CAD_FLAG == undoType))				{				undoItems = new(V_Array);				undoItems->cArray(0,sizeof(void*),4);				undoType = undoItem->GetItems(UNDO_CAD_FLAG,undoItems);								length = undoItems->ALength();				undoItems->Get(0,&itemDef);				type = itemDef->GetType();				theAxis = itemDef->GetAxis();				if(defAxis == theAxis)					{					RulerTrack(&position,TICK_OFF);					undoItem->Reverse();					undoItem->Edit();									pcc(controller)->SetRulerValue(type,itemDef);					result = TRUE;					}				undoItems->dArray();				}			else				result = FALSE;			break;				default:			result = FALSE;			break;		}	return(result);	}void Ruler::Update()	{	RulerItem **pItem;	TickMark  tickMark;	FFixed FFwhere;	long extreme;	int	 end,where,whole;	int	i,length;	int	interval,count;	double scal;		scal = FixedToDbl(scale2Local);	lOrigin = FFLongMult(scale2Local,origin);/* DUDE */	lOrigin = scal * FixedToDbl(origin);	if(VERT_RULER == direction)lOrigin = -lOrigin;	extreme = FFLongMult(scale2Local,VFFMax);	extreme = scal * FixedToDbl(VFFMax);	extreme -= lOrigin;	if(VMax < extreme) worldMax = VMax; else  worldMax = extreme;		tickTable->SetLength(0);		whole = 0;	where = start - unitWidth;	while(where<0)where+=unitWidth;	while(where>=0)where-=unitWidth;	snapOrigin = GetOriginOffset();while(LESS == FFLogic(origin,snapOrigin))snapOrigin = FFSub(snapOrigin,rulerInfo.scale);while(LESS == FFLogic(snapOrigin,origin))snapOrigin = FFAdd(snapOrigin,rulerInfo.scale);switch(direction)	{	case HORZ_RULER: 		if(LESS != FFLogic(snapOrigin,origin)) 			snapOrigin = FFSub(snapOrigin,rulerInfo.scale);		break;	case VERT_RULER: 		if(GRTR != FFLogic(snapOrigin,origin)) 			snapOrigin = FFAdd(snapOrigin,rulerInfo.scale);		break;	}	end = min(GetEnd(),worldMax);		count = 0;	interval = rulerInfo.majorTick;	tickMark.index = 0;	while(where < end)									{				if(whole <= 0)																{			if(count == rulerInfo.divisions)  				{ tickMark.type = unitTick; interval = 0; count = 1; }			else 				{ 				count++;				if(interval == rulerInfo.majorTick) 					{ interval = 0; tickMark.type = majorTick;}				else 					{ interval++; tickMark.type = minorTick;}				}			tickMark.where = where;			tickTable->Append(&tickMark);			whole += unitWidth;							}						whole -= rulerInfo.divisions;						where++;									}			/* Update the thing positions */	if(extrusionRange && (SHOW_RANGE&showState))		extrusionRange->ScaleItem(this,side);	if(SHOW_ORIGIN&showState)		localOrigin->ScaleItem(this,side);	if(rulerItems && (SHOW_GUIDE&showState) && (length = rulerItems->ALength()))		{		tickMark.type = guideTick;		pItem = (RulerItem	**)rulerItems->Use();		for( i = 0 ; i < length; i++,pItem++)			{			(*pItem)->ScaleItem(this,side);			tickMark.where = (*pItem)->scaleValue;			tickMark.index = i;			tickTable->Append(&tickMark);			}		rulerItems->Unuse();		tickTable->QuickSort();			}	}		FFixed Ruler::GetOrigin()	{	return(origin);	}FFixed Ruler::GetOriginOffset()	{	if(side&NEGATIVE_SIDE) return(FFNeg(offsetOrigin));	else return(offsetOrigin);	}		void Ruler::SetOriginOffset(FFixed org)	{	RulerItemDef *itemDef;#if !VR	offsetOrigin = org;	itemDef = localOrigin->GetItemDef();/* THIS SHOULD BE RIGHT */	itemDef->SetValue(offsetOrigin);	/* HE WANTS THE REAL OFFSET IN POSITIVE COORD */	origin = SetOrigin(origin);	formatter->SetOrigin(GetOriginOffset());#endif //!VR	}	FFixed Ruler::SetOrigin(FFixed org)	{	FFixed	finalOrigin,midOrigin,width,remain,resolutionLoss;	int 	val;		width = rulerInfo.scale;	midOrigin = GetOriginOffset();	midOrigin = FFSub(org,midOrigin);	remain.l = midOrigin.l%width.l;	if(remain.l < 0) remain.l += width.l;	remain.l = -remain.l;	val = World2Local(remain,RSCALE_RELATIVE);	resolutionLoss = Local2World(val,RSCALE_RELATIVE);	resolutionLoss = FFSub(remain,resolutionLoss);	finalOrigin = FFAdd(org,resolutionLoss);		if(!FFEqual(origin,org) || !FFEqual(finalOrigin,org) || (start != val))		{		origin = finalOrigin;		start = val;		Update();		}		return(finalOrigin);	}void Ruler::SetScale(double newScale)	{	double	check,tmp;	FFixed	tmpScale,oldOrigin,newOrigin,fDiv,newWidthFF;	int		tableStart,tableEnd,index,newWidth;	short	maxGrid,tickBits,maxBits;		switch(formatter->type)		{		case inch: 			tableStart = UNIT_INCH_START;			tableEnd = UNIT_INCH_END;			break;					case foot: 			tableStart = UNIT_FOOT_START;			tableEnd = UNIT_FOOT_END;			break;					case mile:			tableStart = UNIT_MILE_START;			tableEnd = UNIT_MILE_END;			break;				case meter:		case centimeter:		case custom:		default:			tableStart = UNIT_METRIC_START;			tableEnd = UNIT_METRIC_END;			break;		}		tmpScale = DblToFixed(newScale);	for( index = tableStart; index <= tableEnd; index++ )		{		newWidthFF = FFShift(FFMult(tmpScale,rulerTable[index].scale),0);		newWidth = FFRound(newWidthFF);				if((tableStart == index) && (newWidth > UNIT_MAX_WIDTH))			{//JAM altered 21SEPT94 kludge:  if we try to zoom too far, return to previous value//								instead of trying to go to maximum value.  Makes things happier.//			newWidth = UNIT_MAX_WIDTH;//			newScale = UNIT_MAX_WIDTH / FixedToDbl(rulerTable[index].scale);			newWidth = unitWidth;			newScale = newWidth / FixedToDbl(rulerTable[index].scale);			VPlaySound(beepSound);			break;			}					if((tableEnd == index) && (newWidth < UNIT_MIN_WIDTH))			{//JAM altered 21SEPT94 kludge:  if we try to zoom too far, return to previous value//								instead of trying to go to maximum value.  Makes things happier.//			newWidth = UNIT_MIN_WIDTH;//			newScale = UNIT_MIN_WIDTH / FixedToDbl(rulerTable[index].scale);			newWidth = unitWidth;			newScale = newWidth / FixedToDbl(rulerTable[index].scale);			VPlaySound(beepSound);			break;			}					if((UNIT_MIN_WIDTH < newWidth) && (UNIT_MAX_WIDTH > newWidth))			break; 				if(UNIT_MAX_WIDTH < newWidth)			{//JAM altered 21SEPT94 kludge:  if we try to zoom too far, return to previous value//								instead of trying to go to maximum value.  Makes things happier.//			newWidth = UNIT_MAX_WIDTH;//			newScale = UNIT_MAX_WIDTH / FixedToDbl(rulerTable[index].scale);            newWidth = unitWidth;			newScale = newWidth / FixedToDbl(rulerTable[index].scale);			break;			}		}		if(index>tableEnd)		{		index = tableEnd;		newWidth = UNIT_MIN_WIDTH;		}		rulerInfo = rulerTable[index];	newScale = newWidth / FixedToDbl(rulerInfo.scale);	unitWidth = newWidth;	#if FALSE	tickBits = 0;	gridPrecision = 0;	tmp = FixedToDbl(rulerInfo.scale)/rulerInfo.divisions;	while(rulerInfo.divisions>>tickBits)tickBits++;	maxBits = VMax>>tickBits;	while((maxBits>>1)>tmp)		{ gridPrecision++; tmp *= 2; }		gridUnit = DblToFixed(tmp);#endif	fDiv = FFZero;	fDiv.intg = rulerInfo.divisions;	gridUnit = FFDiv(rulerInfo.scale,fDiv);	gridPrecision = 0;		localPrecision = 0;	worldPrecision = 0;		check = 1.0/newScale;		tmp = check;	while((check < (1<<RMAX_PRECISION)) && (worldPrecision <= RMAX_PRECISION))		{ worldPrecision++; check*=2; }	scale2World = DblToFixed((1<<worldPrecision)*tmp);	check = newScale;		scale2Local = DblToFixed(check);		SetOrigin(origin);	Update();		}		double Ruler::GetScale()	{	double factor;	factor = FixedToDbl(scale2Local);	return(factor);	}void  Ruler::FFSetScale(RulerScaleInfo *rulerScaleInfo)	{	scale2Local = rulerScaleInfo->scale2Local;	localPrecision = rulerScaleInfo->localPrecision;	scale2World = rulerScaleInfo->scale2World;	worldPrecision = rulerScaleInfo->worldPrecision;	unitWidth = rulerScaleInfo->unitWidth;	gridUnit = rulerScaleInfo->gridUnit;	gridPrecision = rulerScaleInfo->gridPrecision;	rulerInfo.scale = rulerScaleInfo->unitValue;	rulerInfo.divisions = rulerScaleInfo->divisions;	rulerInfo.majorTick = rulerScaleInfo->majorTicks;	SetOrigin(origin);	Update();		}void  Ruler::FFGetScale(RulerScaleInfo *rulerScaleInfo)	{	rulerScaleInfo->scale2Local = scale2Local;	rulerScaleInfo->localPrecision = localPrecision;	rulerScaleInfo->scale2World = scale2World;	rulerScaleInfo->worldPrecision = worldPrecision;	rulerScaleInfo->unitWidth = unitWidth;	rulerScaleInfo->gridUnit = gridUnit;	rulerScaleInfo->gridPrecision = gridPrecision;	rulerScaleInfo->unitValue = rulerInfo.scale;	rulerScaleInfo->divisions = rulerInfo.divisions;	rulerScaleInfo->majorTicks = rulerInfo.majorTick;	}	/* 	Note:	The problem is when more then 32k is visible. This forces the relative calculation	to overflow and the result is crap. This is also a problem in the modeler since I 	move in offsets. It is possible for me to move something 64k in offset but I am	limited to 32k offset because of the format.*/	int Ruler::World2Local(FFixed val,int method)	{	int result;	if(RSCALE_ABSOLUTE == method) 		{		val = FFSub(val,origin);		if(FFOver>VMax)val = VFFMax;		}			val = FFMult(scale2Local,val);	if(FFERR_OVERFLOW == FFErr)		{ if(VMax < FFOver) val = VFFMax; else if(VMin > FFOver) val = VFFMin; }	result = FFRound(val);		if(VERT_RULER == direction)result = -result;		return(result);	}FFixed Ruler::Local2World(int val,int method)	{	FFixed result;		if(VERT_RULER == direction)val = -val;	result = FFMultIntShift(scale2World,val,worldPrecision);	if(RSCALE_ABSOLUTE == method) result = FFAdd(result,origin);	if(FFERR_OVERFLOW == FFErr)		{ if(VMax < FFOver) result = VFFMax; else if(VMin > FFOver) result = VFFMin; }	return(result);	}int Ruler::World2Scroll(FFixed val)	{	int result;	val = FFMult(world2Scroll,val);	result = FFRound(val);	if(VERT_RULER == direction)result = -result;		return(result);	}FFixed Ruler::Scroll2World(int val)	{	FFixed result;		if(VERT_RULER == direction)val = -val;	result = FFMultIntShift(scroll2World,val,0);	return(result);	}int  Ruler::GetEnd()	{ 	if(HORZ_RULER == direction)return(dataRect.right); 	else return(dataRect.bottom);	}		void Ruler::SetColor(RGBColor col){ color = col; }void Ruler::SetBackColor(RGBColor col){ backColor = col; }void Ruler::RangeColor(RGBColor col) 	{  	RulerItemDef	*itemDef;	itemDef = FindRulerItem(rangeItem);	if(itemDef) 		itemDef->SetColor(col); 	}void Ruler::SetStart(int num){ start = num; }int  Ruler::GetStart(){ return(start); }FFixed  Ruler::GetGrid(){ return(gridUnit); }void Ruler::SetPosition(int newPosition) { position = newPosition; }	void Ruler::SetState(char st,int which) 	{ 	switch(which)		{		case RULER_STATE: showState |= st; break;		case TAB_STATE: showState = st; break;		case SNAP_STATE: snapState = st; break;		}	}char Ruler::GetState(int which) 	{ 	char result;	switch(which)		{		case TAB_STATE: result = showState; break;		case SNAP_STATE: result = snapState; break;		}	return result;	}void Ruler::SetDivisions(int newDivision,int newMajorTick)	{ 	rulerInfo.divisions = newDivision; 	rulerInfo.majorTick = newMajorTick; 	}int Ruler::GetWidth() 	{ 	return(width);	}void Ruler::SetDirection(char dir) { direction = dir; }void Ruler::SetTabs(FFixed nTab1,FFixed nTab2)  	{ 	RulerItemDef	*itemDef;	itemDef = FindRulerItem(rangeItem);	if(itemDef) 		{		itemDef->SetValue(nTab1);		itemDef->SetValue2(nTab2);		}	}void Ruler::GetTabs(FFixed *oTab1,FFixed *oTab2)  	{ 	RulerItemDef	*itemDef;	itemDef = FindRulerItem(rangeItem);	if(itemDef) 		{		*oTab1 = itemDef->GetValue(); 		*oTab2 = itemDef->GetValue2();		}	}			void Ruler::SetFormat(Formatter *newFormat)  	{ 	formatter->Copy(newFormat);	SetScale(GetScale());	}void Ruler::KillList()  	{ 	RulerItem	**pItem;	int		i,length;		length = rulerItems->ALength();	pItem = (RulerItem	**)rulerItems->Use();	for(i = 0; i < length; i++,pItem++)		(*pItem)->dRulerItem();	rulerItems->Unuse();	rulerItems->SetLength(0);			}	void Ruler::CopyItem(RulerItemDef *itemDef,int s)  	{ 	RulerItem	*newItem;	newItem = new(RulerItem);	newItem->cRulerItem();	newItem->SetItemDef(itemDef);	newItem->SetType(guideItem);	rulerItems->Append(&newItem);	}	int Ruler::Parse(Point p)  	{ 	int where;	if(HORZ_RULER == direction)where = p.h; else where = p.v;	return(where);	}int Ruler::InTab(Point p)  	{ 	int	result;		if( !(SHOW_TAB&showState) ) return FALSE ;			if(HORZ_RULER == direction)		{ result = (p.v > (width - (TAB_WIDTH+1))) ? TRUE : FALSE; }	else		{ result = (p.h > (width - (TAB_WIDTH+1))) ? TRUE : FALSE; }		return result;	}RulerItemDef * Ruler::FindRulerItem(int type)	{	RulerItem		**pItem;	RulerItemDef	*itemDef;	int 			length,i;		if(!rulerItems) return(NULL);	itemDef = NULL;	switch(type)		{		case guideItem:			length = rulerItems->ALength();			if(length)				{				pItem = (RulerItem	**)rulerItems->Use();				for( i = 0 ; i < length; i++,pItem++)					if(type == (*pItem)->GetType())						{ itemDef = (*pItem)->GetItemDef(); break; }				rulerItems->Unuse();				}			break;		case rangeItem:			if(extrusionRange)				itemDef = extrusionRange->GetItemDef();			break;		case originItem:			itemDef = localOrigin->GetItemDef();			break;		}			return(itemDef);	}RGBColorRuler::GetItemColor(int itemType)	{	RulerItemDef	*itemDef;	RGBColor col;	switch(itemType)		{		case guideItem: itemDef = FindRulerItem(guideItem); break;		case originItem: itemDef = FindRulerItem(originItem);break;		case rangeItem: itemDef = FindRulerItem(rangeItem); break;		}	if(itemDef)col = itemDef->GetColor();else col = color;	return col;	}voidRuler::SetItemColor(int itemType,RGBColor col)	{	RulerItem		**pItem;	RulerItemDef	*itemDef;	int 			length,i;	switch(itemType)		{		case guideItem: 			if(rulerItems && (length = rulerItems->ALength()))				{				pItem = (RulerItem	**)rulerItems->Use();				for( i = 0 ; i < length; i++,pItem++)					{					itemDef = (*pItem)->GetItemDef();					itemDef->SetColor(col);					}				rulerItems->Unuse();				}			break;		case rangeItem: 		case originItem: 			itemDef = FindRulerItem(itemType); 			if(itemDef)				itemDef->SetColor(col); 			break;		}	}			void  Ruler::SetTrackSet(int mode)	{	TrackSet		trackSet;	if( POSITION_TRACK == mode || !editItem)		{		type = controller->GetType();		if( toolCRTLDesign == controller->GetType())			{			trackSet.length = 4;			trackSet.item1 = trackHPos;			trackSet.item2 = trackVPos;			trackSet.item3 = trackFloor;			trackSet.item4 = trackDepth;			}		else			{			trackSet.length = 2;			trackSet.item1 = trackHPos;			trackSet.item2 = trackVPos;			}		}	else		{		trackSet.length = 2;		if(HORZ_RULER == direction)			{			trackSet.item1 = trackHPos;			trackSet.item2 = trackDHPos;			}		else 			{			trackSet.item1 = trackVPos;			trackSet.item2 = trackDVPos;			}		}	pcc(controller)->SetTrackSet(&trackSet);		SetPane();			}int TickArray::Compare(void *data1, void *data2)	{	TickMark *t1 = (TickMark*)data1;	TickMark *t2 = (TickMark*)data2;		if(t1->where < t2->where)return -1;	if(t1->where > t2->where)return 1;	return(0);	}