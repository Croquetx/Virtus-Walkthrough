/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "SpacPane.h"#include "Space.h"#include "CVTumObj.h"#include "Polyhdrn.h"#include "Drawing.h"#include "SurfDef.h"#include "Surface.h"#include "CVEnvirn.h"#include "AppMssgs.h"#include "Position.h"#include "Misc.h"#include "VArray.h"#include "VGraphic.h"#include "VGUtil.h"#include <stdlib.h>enum constrainTumbleType	{	constrainNoTumble,	constrainRoll,	constrainPitch,	constrainYaw	};	voidSpacePane::cPane(int flag)	{#if 0	if(!tumble) tumble = new(CAVTumbleObject);#else	if(!tumble) tumble = new(OrientObject);#endif	environment = new(CAVEnvironment);	environment->cCAVEnvironment();	tumble->cCAVTumbleObject();	tumble->SetEnvironment(environment);	V_Pane::cPane(flag);	space = ((Space *)new(Space))->cSpace();	dx = dy = 0;	}	voidSpacePane::dPane(void)	{	space->dSpace();	tumble->dCAVTumbleObject();	environment->dCAVEnvironment();	V_Pane::dPane();	}voidSpacePane::InstallPoly(Polyhedron * newPoly)	{	polyhedron = newPoly;	tumble->SetPolyhedron(newPoly);	tumble->SetOrigin(polyhedron->posn->GetOrigin());	}void SpacePane::SizeNotify() 	{	Rect r;	r = dataRect;	r.top =+10;r.left += 10; r.right -= 10; r.bottom -= 10;	scale = tumble->Fit(&r);	}voidSpacePane::Display(int type,int x,int y)	{	Rect	r,wr;		V_Pane::Display(type,x,y);	r = dataRect;	wr = VMaxRect;	origin.h = -r.right>>1;	origin.v = -r.bottom>>1;	environment->SetEnvironment(&r,&wr,origin,scale,depth);	tumble->Update(space->m);	tumble->Display();	}	void SpacePane::SetMatrix(int vector[3][3])	{	space->SetMatrix(vector);	}voidSpacePane::GetMatrix(int m[3][3])	{	space->GetMatrix(m);	}voidSpacePane::MouseDown(Point p,long modifiers)	{	constrainMode = constrainNoTumble;	mods=modifiers;	lastPt = p;	anchorPt = p;	}	SurfDef	*SpacePane::GetSurface(int surf)	{	SurfDef	*surfDef = NULL;	if (surf>=0)		{		Surface	*surface = polyhedron->FindSurface(surf);		if (!surface->surfDef) surface->surfDef = polyhedron->GetSurfDef(surf);		surfDef = surface->surfDef;		}	return(surfDef);	}voidSpacePane::FrontSurface(int surf)	{	SurfDef 	*sdef;	int i,j,k;	matrix step1,step2;	int qa,qb;	long qx,qy;	Position *posn;	Angle3DFFixed rot;	Point3DFFixed ptA, ptB;		sdef = GetSurface(surf);	posn = new(Position);	posn->cPosition();	rot = Ang3DFFZero; rot.pitch = FFNeg(FFHalfPi);	posn->Rotate3D(rot, Pt3DFFZero);	posn->PositionX(sdef->position);	posn->SetOrigin3D(Pt3DFFZero);		ptA = Pt3DFFZero; ptA.x.intg = 16384;	ptA = posn->UnTransform3D(ptA);	ptB = Pt3DFFZero; ptB.y.intg = 16384;	ptB = posn->UnTransform3D(ptB);	posn->dPosition();	step1[A][X] = FFRound(ptA.x); step1[A][Y] = FFRound(ptA.y); step1[A][Z] = FFRound(ptA.z);	step1[B][X] = FFRound(ptB.x); step1[B][Y] = FFRound(ptB.y); step1[B][Z] = FFRound(ptB.z);	space->GetMatrix(step2);	for (i=1; i<5; i++)		{		for (j=0; j<3; j++)			for(k=0;k<3;k++)				{				qa = step1[j][k];				qb = i;				qx = (long)qa  * qb;				qa = step2[j][k];				qb = 4-i;				qy = (long)qa  * qb;				space->m[j][k] = (qx+qy)>>2;				}		Normalize();		VDisplay(-DRAW);		}	VDisplay(-DRAW);	}	voidSpacePane::Track(Point p,long modifiers,int inside)	{	Point constPt,spherePt;	long inSphere;	int constrainPinState,oldPinState,sphereRadius;		sphereRadius = min(centerX,centerY);	mods=modifiers;	if((modifiers & buttonDown))		{							dx = p.h - lastPt.h;		dy = p.v - lastPt.v;		x = p.h + origin.h;		y = p.v + origin.v;		if(!(V_SHIFT&modifiers))			constrainMode = constrainNoTumble;		else			{			if( constrainNoTumble == constrainMode)				{							spherePt.h = p.h - centerX;				spherePt.v = centerY - p.v;				inSphere = (long)spherePt.h*spherePt.h +(long)spherePt.v*spherePt.v;				if(inSphere > ((long)sphereRadius*sphereRadius))					constrainMode = constrainPitch; 				else					{					constPt.h = abs(p.h - anchorPt.h);					constPt.v = abs(p.v - anchorPt.v);					if(constPt.h == constPt.v)						constrainMode = constrainNoTumble; 					else						{						if(constPt.h > constPt.v)constrainMode = constrainRoll; 						else constrainMode = constrainYaw; 						}					}				}				}		oldPinState = space->GetPin();			switch(constrainMode)			{			case constrainPitch: constrainPinState = PIN_P; break;			case constrainRoll: constrainPinState = PIN_R; break;			case constrainYaw: constrainPinState = PIN_Y; break;			default: constrainPinState = oldPinState; break;			}					if(dx||dy)			{			space->SetPin(constrainPinState);			space->Update(x,y,dx,dy,min(centerX,centerY));			Display(-DRAW,0,0);			space->SetPin(oldPinState);			}				lastPt = p;		}	else		{		if(momentum)			{			DoMomentum(p,x,y);			Display(-DRAW,0,0);			}		}	}void	SpacePane::DoMomentum(Point p,int x,int y)	{	if(friction)		{		dx=(dx*((1L<<16)-(1L<<14)))>>16;		dy=(dy*((1L<<16)-(1L<<14)))>>16;		}			space->Update(x,y,dx,dy,min(centerX,centerY));	}	void SpacePane::Normalize(void)	{	space->Normalize();	}void SpacePane::Roll(int psi)	{	space->Roll(psi);	space->Normalize();	VDisplay(-DRAW);	}void SpacePane::Pitch(int phi)	{	space->Pitch(phi);	space->Normalize();	VDisplay(-DRAW);	}void SpacePane::Yaw(int theta)	{	space->Yaw(theta);	space->Normalize();	VDisplay(-DRAW);	}voidSpacePane::SetPin(int newpin)	{	space->SetPin(newpin);	}voidSpacePane::MakeCube(FFixed side)	{	V_Array	*ffoutl;	PointFFixed pt;	FFixed	side2,base,point;		((OrientObject*)tumble)->MakeBox(side,side,side);	FFShift(side,1);	point = side;	base = FFNeg(side);	side2 = base;		ffoutl = new(V_Array);	ffoutl->cArray(0,sizeof(PointFFixed),4);	pt.h = side2;	pt.v = side2;	ffoutl->Append(&pt);	pt.h = side2;	pt.v = side;	ffoutl->Append(&pt);	pt.h = side;	pt.v = side;	ffoutl->Append(&pt);	pt.h = side;	pt.v = side2;	ffoutl->Append(&pt);		studio = new(WalkDrawing);	studio->cWalkDrawing(NULL);	polyhedron = new(Polyhedron);	polyhedron->cPolyhedron(studio);	polyhedron->CreateInflate(INFL_Y,INFL_EXTRUDE,ffoutl,point,base);	polyhedron->SetColor(vWhite,0xFFFF,SURF_SHARED);		ffoutl->dArray();		InstallPoly(polyhedron);	}