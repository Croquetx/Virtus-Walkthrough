/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				David W. Easter *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "Space.h"#include "SinTable.h"#include "VGraphic.h"#include <stdlib.h>#include <math.h>voidRotate(int *x, int *y, int a);voidRotate(int *x, int *y, int a)	{		int qa,qb,c,s;	long qx,qy;		qa = *x;	qb = *y;	c = cos256(a>>6);	s = sin256(a>>6);	qx=(long)qa*c;	qy=(long)qb*s;	*x = (qx + qy) >> 7;	qx=(long)qb*c;	qy=(long)qa*s;	*y = (qx - qy) >> 7;	}/*------------------------------------------------------------------------------ * The Space object keeps track of the current coordinate frame by means * of a 3x3 matrix, m.  The matrix is rotated by RollY(), PitchX(), and YawZ(), * and renormalized by Oblique().  The only other significant variables are * rollpin, pitchpin, and yawpin, which restrict rotation around the three * individual axes if they are set to FALSE.  A parent object will call Normalize() * more often than the explicit rotation methods, however, because in general * the space is rotated by dragging the virtual sphere with the mouse. * * The matrix can be applied to points using the method Trans().  Usually, however, * the programmer should use the macros NewX, NewY, and NewZ instead, because they * are faster.  OldX, OldY, and Oldz perform the corresponding inverse transformation. *------------------------------------------------------------------------------ * Space * * Space::cSpace(void) * Constructor of the space object.  Note that the matrix is initially normalized * to be the identity matrix <<14. *------------------------------------------------------------------------------ */Space *Space::cSpace(void){pinState = PIN_R|PIN_P|PIN_Y;	m[A][X] = 1<<14;m[B][Y] = 1<<14;m[C][Z] = 1<<14;Normalize();		return(this);}voidSpace::AngleToMatrix(double phi,double theta,double psi){double cphi,sphi,ctheta,stheta,cpsi,spsi;cphi=cos(phi);sphi=sin(phi);ctheta=cos(theta);stheta=sin(theta);cpsi=cos(psi);spsi=sin(psi);m[A][X]=16384*cphi*ctheta;m[A][Y]=16384*sphi*ctheta;m[A][Z]=-16384*stheta;m[B][X]=16384*(cphi*stheta*spsi-sphi*cpsi);m[B][Y]=16384*(sphi*stheta*spsi+cphi*cpsi);m[B][Z]=16384*ctheta*spsi;m[C][X]=16384*(cphi*stheta*cpsi+sphi*spsi);m[C][Y]=16384*(sphi*stheta*cpsi-cphi*spsi);m[C][Z]=16384*ctheta*cpsi;}/* From Graphics Gems II, p. 320-3 */voidSpace::MatrixToAngle(double *phi,double *theta,double *psi){const double limit = PI/2 - 1./65536;*theta=asin(-m[A][Z]/16384.);if(*theta > -limit && *theta < limit)	{	*phi=atan2(m[A][Y],m[A][X]);	*psi=atan2(m[B][Z],m[C][Z]);	}else	{	*phi=0;	*psi=atan2(m[B][X],m[B][Y]);	}if(*phi<0)*phi+=PI2;if(*theta<0)*theta+=PI2;if(*psi<0)*psi+=PI2;}void SpaceTest(void);void SpaceTest(void){Space *stest;double phi,theta,psi;int r,p,y;stest=new(Space);stest->cSpace();stest->AngleToMatrix(10000*PI2/16384,2000*PI2/16384,5000*PI2/16384);stest->MatrixToAngle(&phi,&theta,&psi);r=phi*16384/PI2;p=theta*16384/PI2;y=psi*16384/PI2;}/*------------------------------------------------------------------------------ * void * Space::dSpace(void) * Destructor of the space object. *------------------------------------------------------------------------------ */voidSpace::dSpace(void){delete(this);}/*------------------------------------------------------------------------------ * Normalize() renormalizes the vectors and recomputes their cross product.  Call * this after every few rotations, in order to eliminate rounding errors.  This * should be called after calling RollY()/PitchX()/YawZ() explicitly, or after * messing with v directly.   *------------------------------------------------------------------------------ */voidSpace::Normalize(void){int d;int qa,qb,qc;long qx,qy,qz;/* Normalize m[A] */qa = m[A][X];qx=(long)qa*qa;qb = m[A][Y];qy=(long)qb*qb;qc = m[A][Z];qz=(long)qc*qc;d = LSqrt(qx+qy+qz);qx=(long)qa<<14;qy=(long)qb<<14;qz=(long)qc<<14;if(d==0)	{	m[A][X]=16384;	m[A][Y]=0;	m[A][Z]=0;	}else	{	m[A][X]=qx/d;		m[A][Y]=qy/d;	m[A][Z]=qz/d;	}/* Make v[B] perpendicular to v[A] */qa = m[A][X];qb = m[B][X];fLongMult(qx,qa,qb);qa = m[A][Y];qb = m[B][Y];fLongMult(qy,qa,qb);qa = m[A][Z];qb = m[B][Z];fLongMult(qz,qa,qb);d = qx+qy+qz;	qa = m[A][X];fLongMult(qx,qa,d);qb = m[A][Y];fLongMult(qy,qb,d);qc = m[A][Z];fLongMult(qz,qc,d);m[B][X] -= qx;m[B][Y] -= qy;m[B][Z] -= qz;	/* Normalize v[B] */qa = m[B][X];qx=(long)qa*qa;qb = m[B][Y];qy=(long)qb*qb;qc = m[B][Z];qz=(long)qc*qc;d = LSqrt(qx+qy+qz);qx=(long)qa<<14;qy=(long)qb<<14;qz=(long)qc<<14;if(d==0)	{	m[B][X]=16384;	m[B][Y]=0;	m[B][Z]=0;	}else	{	m[B][X]=qx/d;		m[B][Y]=qy/d;	m[B][Z]=qz/d;	}	/* Compute v[A] cross v[B], for the third axis v[C] */qa = m[A][Y];qb = m[B][Z];fLongMult(qx,qa,qb);qa = m[B][Y];qb = m[A][Z];fLongMult(qy,qa,qb);m[C][X] = qx - qy;	qa = m[B][X];qb = m[A][Z];fLongMult(qx,qa,qb);qa = m[A][X];qb = m[B][Z];fLongMult(qy,qa,qb);m[C][Y] = qx - qy;	qa = m[A][X];qb = m[B][Y];fLongMult(qx,qa,qb);qa = m[B][X];qb = m[A][Y];fLongMult(qy,qa,qb);m[C][Z] = qx - qy;}/*------------------------------------------------------------------------------ * void * Space::Roll(int psi) * void * Space::Pitch(int phi) * void * Space::Yaw(int theta) * Roll(), Pitch(), and Yaw() perform the actual rotations. *------------------------------------------------------------------------------ */voidSpace::Roll(int psi)/* Z */	{	if (PIN_R&pinState)		{		if(psi<0)psi+=16384;		psi=16384-psi;		Rotate(&m[A][X],&m[A][Y],psi);		Rotate(&m[B][X],&m[B][Y],psi);		}	}voidSpace::Pitch(int phi)/* Y */	{	if (PIN_P&pinState)		{		if(phi<0)phi+=16384;		Rotate(&m[A][X],&m[A][Z],phi);		Rotate(&m[B][X],&m[B][Z],phi);		}	}voidSpace::Yaw(int theta)/* X */	{	if (PIN_Y&pinState)		{		if(theta<0)theta+=16384;		theta=16384-theta;		Rotate(&m[A][Y],&m[A][Z],theta);		Rotate(&m[B][Y],&m[B][Z],theta);		}	}/*------------------------------------------------------------------------------ * void * Space::DRoll(int psi) * void * Space::DPitch(int phi) * void * Space::DYaw(int theta) * DRoll(), DPitch(), and DYaw() perform the actual rotations using radians. *------------------------------------------------------------------------------ */voidSpace::DRoll(double psi)/* Z */	{	double c,s,qx,qy;		psi=PI2-psi;	c=cos(psi);	s=sin(psi);	qx=m[A][X]*c+m[A][Y]*s;	qy=m[A][Y]*c-m[A][X]*s;	m[A][X]=qx;	m[A][Y]=qy;	qx=m[B][X]*c+m[B][Y]*s;	qy=m[B][Y]*c-m[B][X]*s;	m[B][X]=qx;	m[B][Y]=qy;	}voidSpace::DPitch(double phi)/* Y */	{	double c,s,qx,qz;		c=cos(phi);	s=sin(phi);	qx=m[A][X]*c+m[A][Z]*s;	qz=m[A][Z]*c-m[A][X]*s;	m[A][X]=qx;	m[A][Z]=qz;	qx=m[B][X]*c+m[B][Z]*s;	qz=m[B][Z]*c-m[B][X]*s;	m[B][X]=qx;	m[B][Z]=qz;	}voidSpace::DYaw(double theta)/* X */	{	double c,s,qz,qy;		theta=PI2-theta;	c=cos(theta);	s=sin(theta);	qy=m[A][Y]*c+m[A][Z]*s;	qz=m[A][Z]*c-m[A][Y]*s;	m[A][Y]=qy;	m[A][Z]=qz;	qy=m[B][Y]*c+m[B][Z]*s;	qz=m[B][Z]*c-m[B][Y]*s;	m[B][Y]=qy;	m[B][Z]=qz;	}/*------------------------------------------------------------------------------ * Update() rotates the coordinate frame in response to the * mouse action that's described to it.  x and y should point * to the current mouse position relative to the center of * rotation, and dx and dy should give the change from the last * position.  dd is the radius of the virtual sphere, which * in general should just contain the object being manipulated. *------------------------------------------------------------------------------ */voidSpace::Update(int x, int y, int dx, int dy, int dd){int ay,ap,ar,mx,my;long d;int rs = 4000;int ts = 16000;char s[80];long qx,qy,qz;int qa,qb,qc;qx=(long)x*x;qy=(long)y*y;qz=(long)dd*dd;qx = qx>>2;qy = qy>>2;if (qx+qy>qz) return;	/* Normalize position */qx = x;qx <<= 14;qx = qx/dd;x = qx;qy = y;qy <<=14;qy = qy/dd;y = qy;/* Normalize differentials */qx = dx;qx <<=14;qx = qx/dd;dx = qx;qy = dy;qy <<=14;qy = qy/dd;dy = qy;		mx = 16384-abs(x);my = 16384-abs(y);fLongMult(qx,x,x);fLongMult(qy,y,y);if (qx+qy>16384)	{	mx = 0;	my = 0;	}/* compute yaw */fLongMult(qx,my,dx);qa = qx;fLongMult(qy,qa,rs);ay = qy;/* compute pitch */fLongMult(qx,mx,dy);qa = qx;fLongMult(qy,qa,rs);ap = qy;/* compute roll */qa = x>>2;qb = y>>2;fLongMult(qx,qb,dx);fLongMult(qy,qa,dy);ar = qx - qy;fLongMult(qx,qa,qa);fLongMult(qy,qb,qb);d=qx+qy;if (d>1024)	{	qx = ar;	qx = qx<<10;	ar = qx/d;	}fLongMult(qx,ar,ts);ar = qx;Yaw(16384+ap);Pitch(-ar);Roll(16384+ay);Normalize();}void  Space::SetPin(int state) { pinState = 	state; }int   Space::GetPin() { return pinState; }void Space::GetMatrix(matrix n){int i,j;for(i=0;i<3;i++)	for(j=0;j<3;j++)		n[i][j]=m[i][j];}void Space::SetMatrix(matrix n){int i,j;for(i=0;i<3;i++)	for(j=0;j<3;j++)		m[i][j]=n[i][j];}/* Trans() translates x,y,z into the rotated coordinate space. * It accomplishes the same thing as the macros NewX(), NewY(), * and NewZ(). */voidSpace::Trans(int x, int y, int z, int *nx, int *ny, int *nz)	{		OldX(*nx,m,x,y,z);	OldY(*ny,m,x,y,z);	OldZ(*nz,m,x,y,z);	}#define MatrixMult(t,v1,v2)	m1=m[v1][X];		\							m2=mult->m[A][v2];	\							fLongMult(d1,m1,m2);\							m1=m[v1][Y];		\							m2=mult->m[B][v2];	\							fLongMult(d2,m1,m2);\							m1=m[v1][Z];		\							m2=mult->m[C][v2];	\							fLongMult(d3,m1,m2);\							t=d1+d2+d3;							void Space::Multiply(Space *mult){matrix n;long d1,d2,d3;int m1,m2;MatrixMult(n[A][X],A,X);MatrixMult(n[A][Y],A,Y);MatrixMult(n[A][Z],A,Z);MatrixMult(n[B][X],B,X);MatrixMult(n[B][Y],B,Y);MatrixMult(n[B][Z],B,Z);MatrixMult(n[C][X],C,X);MatrixMult(n[C][Y],C,Y);MatrixMult(n[C][Z],C,Z);SetMatrix(n);}