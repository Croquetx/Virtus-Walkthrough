/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "Misc.h"#include "SinTable.h"#include "Geometry.h"#include "VMath.h"#include "VArray.h"#include "VGraphic.h"#include "VGUtil.h"#include "VError.h"	// jca 15 Oct 93#include "AppText.h"	//PRO-JAP#include <stdlib.h>#include <math.h>#include <string.h>#define BALLOON_EDGE	8void BalloonHotRect(Rect *r,Point p)	{	Rect tr;	tr.left = p.h - BALLOON_EDGE;	tr.right = p.h + BALLOON_EDGE;	tr.top = p.v - BALLOON_EDGE;	tr.bottom = p.v + BALLOON_EDGE;	if(tr.left>r->left)r->left = tr.left;	if(tr.right<r->right)r->right = tr.right;	if(tr.top>r->top)r->top = tr.top;	if(tr.bottom<r->bottom)r->bottom = tr.bottom;	}void MakeRect(Rect *r, Point pa, Point pb)	{	if(pb.h > pa.h) { r->left = pa.h; r->right = pb.h;}	else			{ r->left = pb.h; r->right = pa.h;}		if(pb.v > pa.v) { r->top = pa.v; r->bottom = pb.v;}	else			{ r->top = pb.v; r->bottom = pa.v;}	}void DrawRect(Point pa, Point pb)	{	Rect	r;		if(pb.h > pa.h) { r.left = pa.h; r.right = pb.h;}	else			{ r.left = pb.h; r.right = pa.h;}		if(pb.v > pa.v) { r.top = pa.v; r.bottom = pb.v;}	else			{ r.top = pb.v; r.bottom = pa.v;}		VMoveTo(r.left, r.top);	VLineTo(r.right, r.top);	VLineTo(r.right, r.bottom);	VLineTo(r.left, r.bottom);	VLineTo(r.left, r.top);	}void SetAngle(int angle, int *ssin, int *ccos)	{	if(angle > 360) angle -= 360;	else { if(angle < 0)  angle += 360; }		*ssin = SinTable360[angle];		angle += 90;	if(angle > 360) angle -= 360;		*ccos = SinTable360[angle];	}int FindAngle(int dh, int dv)	{	int	angle=0;	#if MACINTOSH	if(dh)		{		if(dv)			{ 			angle = AngleFromSlope(FixRatio(dh,-dv));			if(dh>0)angle -= 90; else angle += 90;			}		else			{ if(dh > 0) angle = 0; else angle = 180; }		}	else		{		if(dv)			{ if(dv < 0) angle = 90; else angle = 270;}		else			angle = 0;		}#elif WINDOWS	if(dv==0&&dh==0)angle=-90;	else angle=(360/PI2)*atan2(dh,dv)-90;#endif //WINDOWS	while(0 > angle) angle += 360;	while(360 <= angle) angle -= 360;		return(angle);	}V_Array *RegularPoly(int nSides, Point center, int radius, int ang360)	{	double delta;	double dangle;	int sinAngle,cosAngle;	int i;	V_Array *dataPoints;	Point *pnt;	long h,v;		dataPoints=new(V_Array);	dataPoints->cArray(nSides,sizeof(Point),nSides);	pnt=(Point *)dataPoints->Use();	while(0 > ang360) ang360+=360;	dangle = ang360;	delta=360.0/nSides;	h=radius;	v=0;		for(i=0;i<nSides;i++)		{		sinAngle=dangle;		while(sinAngle>=360)sinAngle-=360;		cosAngle=sinAngle+90;		if(cosAngle>=360)cosAngle-=360;		pnt[i].h=center.h+((h*SinTable360[cosAngle]-v*SinTable360[sinAngle]+64)>>7);		pnt[i].v=center.v-((h*SinTable360[sinAngle]+v*SinTable360[cosAngle]+64)>>7);		dangle+=delta;		}	dataPoints->Unuse();	return dataPoints;	}		/*=========================================================================*-------------------------------------------------------------------------*/voidRotateRect(Point pointArray[4],Point position,Point anchor,Point offset,FFixed sinAngle,int limit,int display)	{	Point	p1,p3;	double	angle,csa,ssa,dx,dy,ax,ay,dh,dv;		if(!FFZero(sinAngle))		{		angle = FixedToDbl(sinAngle);		ssa = sin(angle);		csa = sin(angle+1.570196);					dh = offset.h;		dv = offset.v;			dx = dh*csa-dv*ssa;		dy = dh*ssa+dv*csa;		dh = position.h - anchor.h;		dv = position.v - anchor.v;		ax = dh*csa-dv*ssa;		ay = dh*ssa+dv*csa;					angle = 6.283185 - angle;		ssa = sin(angle);		csa = sin(angle-1.570196);		switch(0x07&limit)			{			case LIM_NONE: break;			case LIM_HORZ: dx = 0; break;			case LIM_VERT: 	dy = 0; break; 			}										dh = dx + ax;		dv = dy + ay;		if(LIM_ROT&limit)			{			p1.h = dh;p1.v = 0;			p3.h = 0;p3.v = dv;						}			else			{			p1.h = dh*csa;			p1.v = dh*ssa;			p3.h = dv*ssa;			p3.v = dv*csa;			}						if(LIM_NONE != limit)			{			position.h = anchor.h - p1.h - p3.h;			position.v = anchor.v + p1.v - p3.v;						}		else			{			position.h += offset.h;			position.v += offset.v;			}				p1.h = anchor.h - p1.h;		p1.v = anchor.v + p1.v;		p3.h = anchor.h - p3.h;		p3.v = anchor.v - p3.v;		}	else		{		switch(0x07&limit)			{			case LIM_NONE: break;			case LIM_HORZ: offset.h = 0; break;			case LIM_VERT: offset.v = 0; break;			}		position.h += offset.h;		position.v += offset.v;		p1.h = anchor.h;p1.v = position.v;		p3.h = position.h;p3.v = anchor.v;		}			pointArray[0] = anchor;	pointArray[1] = p1;	pointArray[2] = position;	pointArray[3] = p3;		if(display)		{		VMoveTo(pointArray[0].h,pointArray[0].v);		VLineTo(pointArray[1].h,pointArray[1].v);		VLineTo(pointArray[2].h,pointArray[2].v);		VLineTo(pointArray[3].h,pointArray[3].v);		VLineTo(pointArray[0].h,pointArray[0].v);			}			}/* Gregs with slight adjustment */longLightness(RGBColor rgb)	{	return ((0x8000L+((long)rgb.red)+((long)rgb.green)+((long)rgb.blue))>>2);	}/*=========================================================================*	Angle3DFFixed BuildRegular()*-------------------------------------------------------------------------*/FFixed BuildRegular(V_Array **poutline,PointFFixed origin,PointFFixed loc, int nSides)	{	PointFFixed		p;	FFixed			lastAngle;	double			rise,run,radius,delta,h,v,dangle,angle,centerX,centerY,x,y;	int 			i,length;		(*poutline)->SetLength(0);	#if FALSE	centerX = FixedToDbl(origin.h);	centerY = FixedToDbl(origin.v);	rise = FixedToDbl(loc.v);	run = FixedToDbl(loc.h);	radius = sqrt(rise*rise + run*run);	delta=PI2/nSides;	h=radius;	v=0;    if(loc.h.l==0 && loc.v.l==0)angle=0;	else	angle = atan2(-FixedToDbl(loc.v),FixedToDbl(loc.h));	for(i = 0; i < nSides; i++)		{		x = centerX + h*sin(angle + (PI/2)) - v*sin(angle);		y = centerY - h*sin(angle) + v*sin(angle+(PI/2));				p.h = DblToFixed(x);		p.v = DblToFixed(y);		(*poutline)->Append(&p);		angle-=delta;		}	if(run==0 && rise==0) angle=0;			else	angle = atan2(rise,run);	lastAngle = DblToFixed(angle);#endif	centerX = FixedToDbl(origin.h);	centerY = FixedToDbl(origin.v);	rise = FixedToDbl(loc.v);	run = FixedToDbl(loc.h);	radius = sqrt(rise*rise + run*run);	delta=PI2/nSides;   	if(loc.h.l==0 && loc.v.l==0)angle=0;	else	angle = atan2(FixedToDbl(loc.v),FixedToDbl(loc.h));	for(i = 0; i < nSides; i++)		{		x = radius*cos(angle);		y = radius*sin(angle);		x += centerX;		y += centerY;		p.h = DblToFixed(x);		p.v = DblToFixed(y);		(*poutline)->Append(&p);		angle-=delta;		}			    if(run==0 && rise==0) angle=0;	else	angle = atan2(rise,run);	lastAngle = DblToFixed(angle);	return(lastAngle);	}/*=========================================================================*	Angle3DFFixed BuildRect()*-------------------------------------------------------------------------*/FFixed BuildRect(V_Array **poutline,PointFFixed loc,int mark,int view,int limit)	{	PointFFixed	*p;	FFixed	swap;	int prev,next,where;		if(limit)		{			if(3 < ++mark) mark -= 4;		if(0 == mark || 2 == mark) 			{/* dude			if(frontView == view || backView == view) loc.v = FFZero; 			else loc.h = FFZero; */						if(3 == view || 4 == view)loc.v = FFZero; 			else loc.h = FFZero; 			}		else 			{/* dude			if(frontView == view || backView == view) loc.v = FFZero; 			else loc.h = FFZero; */			if(3 == view || 4 == view) loc.h = FFZero; 			else loc.v = FFZero; 			}		}	if(0 > (prev = mark - 1))prev += 4;	if(3 < (next = mark + 1))next -= 4;		if(0 == mark || 2 == mark)		{ where = prev; prev = next; next = where; }	/* dude	if(frontView == view || backView == view)		{ where = prev; prev = next; next = where; }*/	if(3 == view || 4 == view)		{ where = prev; prev = next; next = where; }				p = (PointFFixed*)(*poutline)->Use();		p[mark].h = FFAdd(p[mark].h,loc.h);	p[mark].v = FFAdd(p[mark].v,loc.v);	p[prev].h = FFAdd(p[prev].h,loc.h);	p[next].v = FFAdd(p[next].v,loc.v);		(*poutline)->Unuse();	}Point3DFFixedFF3DSub(Point3DFFixed a,Point3DFFixed b)	{	Point3DFFixed	result;	result.x = FFSub(a.x,b.x);	result.y = FFSub(a.y,b.y);	result.z = FFSub(a.z,b.z);	return(result);	}Point3DFFixedFF3DAdd(Point3DFFixed a,Point3DFFixed b)	{	Point3DFFixed	result;	result.x = FFAdd(a.x,b.x);	result.y = FFAdd(a.y,b.y);	result.z = FFAdd(a.z,b.z);	return(result);	}PointFFixedFF2DSub(PointFFixed a,PointFFixed b)	{	PointFFixed	result;	result.h = FFSub(a.h,b.h);	result.v = FFSub(a.v,b.v);	return(result);	}PointFFixedFF2DAdd(PointFFixed a,PointFFixed b)	{	PointFFixed	result;	result.h = FFAdd(a.h,b.h);	result.v = FFAdd(a.v,b.v);	return(result);	}#define NORMALIZER 32767.0void	PlaneEquation(Point3DFFixed	pt1,Point3DFFixed	pt2,Point3DFFixed	pt3,FFixed *A,FFixed *B,FFixed *C,FFixed *D)	{	double	x1,x2,x3,y1,y2,y3,z1,z2,z3;	double	a,b,c,d,norm,sign,temp;		x1 = FixedToDbl(pt1.x); y1 = FixedToDbl(pt1.y); z1 = FixedToDbl(pt1.z);	x2 = FixedToDbl(pt2.x); y2 = FixedToDbl(pt2.y); z2 = FixedToDbl(pt2.z);	x3 = FixedToDbl(pt3.x); y3 = FixedToDbl(pt3.y); z3 = FixedToDbl(pt3.z);	/*	old code jca 8 Dec 93	a = y1*(z2-z3) - z1*(y2-y3) + (y2*z3 - y3*z2);	b = -(x1*(z2-z3) - z1*(x2-x3) + (x2*z3 - x3*z2));	c = x1*(y2-y3) - y1*(x2-x3) + (x2*y3 - x3*y2);	d = -(x1*(y2*z3 - y3*z2) - y1*(x2*z3 - x3*z2) + z1*(x2*y3 - x3*y2));*/	/* jca 8 Dec 93.  This is the cross product from Foley, van Dam, Feiner,	and Hughes p 1104.  Believe it or not, this plain boring code is faster	than the stuff above, and even faster than	a = z1*(y3-y2) + z2*(y1-y3) + z3*(y2-y1);	b = x1*(z3-z2) + x2*(z1-z3) + x3*(z2-z1);	c = y1*(x3-x2) + y2*(x1-x3) + y3*(x2-x1);	which is the same as the above, only with the x2y2, y2z2, x2z2 terms	removed (they cancel, you see).  The plain stuff has only 2 multiplies	and 3 subtracts (vs. 3 or 4 multiplies).  This is double precision, so    the multiplies are the painful parts */	a = (z1-z2)*(y3-y2) - (y1-y2)*(z3-z2);	b = (x1-x2)*(z3-z2) - (z1-z2)*(x3-x2);	c = (y1-y2)*(x3-x2) - (x1-x2)*(y3-y2);	d = -a*x2 - b*y2 - c*z2;	temp = (d>0)?d:-d;	if(temp>NORMALIZER)		{ 		if(d > 0) sign = 1; else sign = -1; 		norm = d/(sign*NORMALIZER); d = sign*NORMALIZER; a /= norm; b /= norm; c /= norm;		}	if(abs(a)>NORMALIZER)		{ 		if(a > 0) sign = 1; else sign = -1; 		norm = a/(sign*NORMALIZER); a = sign*NORMALIZER; d /= norm; b /= norm; c /= norm;		}	if(abs(b)>NORMALIZER)		{ 		if(b > 0) sign = 1; else sign = -1; 		norm = b/(sign*NORMALIZER); b = sign*NORMALIZER; a /= norm; d /= norm; c /= norm;		}	if(abs(c)>NORMALIZER)		{ 		if(c > 0) sign = 1; else sign = -1; 		norm = c/(sign*NORMALIZER); c = sign*NORMALIZER; a /= norm; b /= norm; d /= norm;		}	  			*A = DblToFixed(a);	*B = DblToFixed(b);	*C = DblToFixed(c);	*D = DblToFixed(d);	}// MERGE18 [[[void	PlaneEquationDbl(Point3DFFixed	pt1,Point3DFFixed	pt2,Point3DFFixed	pt3,double *A,double *B,double *C,double *D)	{	double	x1,x2,x3,y1,y2,y3,z1,z2,z3;	double	a,b,c,d,norm,sign,temp;		x1 = FixedToDbl(pt1.x); y1 = FixedToDbl(pt1.y); z1 = FixedToDbl(pt1.z);	x2 = FixedToDbl(pt2.x); y2 = FixedToDbl(pt2.y); z2 = FixedToDbl(pt2.z);	x3 = FixedToDbl(pt3.x); y3 = FixedToDbl(pt3.y); z3 = FixedToDbl(pt3.z);	/*	old code jca 8 Dec 93	a = y1*(z2-z3) - z1*(y2-y3) + (y2*z3 - y3*z2);	b = -(x1*(z2-z3) - z1*(x2-x3) + (x2*z3 - x3*z2));	c = x1*(y2-y3) - y1*(x2-x3) + (x2*y3 - x3*y2);	d = -(x1*(y2*z3 - y3*z2) - y1*(x2*z3 - x3*z2) + z1*(x2*y3 - x3*y2));*/	/* jca 8 Dec 93.  This is the cross product from Foley, van Dam, Feiner,	and Hughes p 1104.  Believe it or not, this plain boring code is faster	than the stuff above, and even faster than	a = z1*(y3-y2) + z2*(y1-y3) + z3*(y2-y1);	b = x1*(z3-z2) + x2*(z1-z3) + x3*(z2-z1);	c = y1*(x3-x2) + y2*(x1-x3) + y3*(x2-x1);	which is the same as the above, only with the x2y2, y2z2, x2z2 terms	removed (they cancel, you see).  The plain stuff has only 2 multiplies	and 3 subtracts (vs. 3 or 4 multipliesin the above).  This is double	precision, so the multiplies are the painful parts */	a = (z1-z2)*(y3-y2) - (y1-y2)*(z3-z2);	b = (x1-x2)*(z3-z2) - (z1-z2)*(x3-x2);	c = (y1-y2)*(x3-x2) - (x1-x2)*(y3-y2);	d = -a*x2 - b*y2 - c*z2;	temp = (d>0)?d:-d;	if(temp>NORMALIZER)		{ 		if(d > 0) sign = 1; else sign = -1; 		norm = d/(sign*NORMALIZER); d = sign*NORMALIZER; a /= norm; b /= norm; c /= norm;		}	if(abs(a)>NORMALIZER)		{ 		if(a > 0) sign = 1; else sign = -1; 		norm = a/(sign*NORMALIZER); a = sign*NORMALIZER; d /= norm; b /= norm; c /= norm;		}	if(abs(b)>NORMALIZER)		{ 		if(b > 0) sign = 1; else sign = -1; 		norm = b/(sign*NORMALIZER); b = sign*NORMALIZER; a /= norm; d /= norm; c /= norm;		}	if(abs(c)>NORMALIZER)		{ 		if(c > 0) sign = 1; else sign = -1; 		norm = c/(sign*NORMALIZER); c = sign*NORMALIZER; a /= norm; b /= norm; d /= norm;		}	  			*A = a;	*B = b;	*C = c;	*D = d;	}// MERGE18 ]]]/*=========================================================================*	Angle3DFFixed AlignToVector(Point3DFFixed vector1,Point3DFFixed vector2,int constrain) *	Vector to is being aligned to vector1*-------------------------------------------------------------------------*/Angle3DFFixed AlignToVector(Point3DFFixed vector1,Point3DFFixed vector2,int constrain) 	{	Angle3DFFixed	alignAngle;	double			fromAngle,toAngle;	FFixed			h1,h2,v1,v2,angle;				alignAngle	=	Ang3DFFZero;		switch(constrain)		{		case 1:/*X_AXIS*/ 			h1 = vector1.y;			h2 = vector2.y;			v1 = vector1.z;			v2 = vector2.z;			break;		case 2:/*Y_AXIS*/			h1 = vector1.z;			h2 = vector2.z;			v1 = vector1.x;			v2 = vector2.x;			break;		case 3:/*Z_AXIS*/			h1 = vector1.x;			h2 = vector2.x;			v1 = vector1.y;			v2 = vector2.y;			break;		}	/* are they 180 out */	if((EQUL == FFLogic(h1,h2))		&& (EQUL == FFLogic(v1,v2)))		{		angle = FFPi;		}	/* are they already okay */	else		{		if((EQUL == FFLogic(h1,FFNeg(h2)))			&& (EQUL == FFLogic(v1,FFNeg(v2))))			{			angle = FFZero;			}	/* what is the angle between them */		else			{            if(h1.l==0 && v1.l==0)toAngle=0;			else	toAngle = atan2(FixedToDbl(v1),FixedToDbl(h1));			if(h2.l==0 && v2.l==0)fromAngle=0;			else	fromAngle = atan2(FixedToDbl(v2),FixedToDbl(h2));			angle = DblToFixed(toAngle - fromAngle);			angle = FFSub(angle,FFPi);			}		}			/* set the angle */	switch(constrain)		{		case 1:/*X_AXIS*/ alignAngle.pitch = angle; break;		case 2:/*Y_AXIS*/ alignAngle.roll = angle; break;		case 3:/*Z_AXIS*/ alignAngle.yaw = angle; break;		}						return(alignAngle);	}	FFixedDistanceToPlane(Point3DFFixed wp,FFixed FFA,FFixed FFB,FFixed FFC,FFixed FFD)	{	FFixed	distance;	double	x,y,z,A,B,C,D,p,a,b,c;		x = FixedToDbl(wp.x);	y = FixedToDbl(wp.y);	z = FixedToDbl(wp.z);	A = FixedToDbl(FFA);	B = FixedToDbl(FFB);	C = FixedToDbl(FFC);	D = FixedToDbl(FFD);		p = (A*x + B*y + C*z + D) / sqrt(A*A + B*B + C*C);			distance = DblToFixed(p);	return(distance);	}voidRegularPolyTest(int nSides, Point center, int radius, int ang360,int onLine)	{	Rect	tmp;	double delta,dangle,tmpAdj;	Point startPt,pnt;	long h,v;	int sinAngle,cosAngle,i;		dangle=ang360;	delta=360.0/nSides;	if(onLine)		{		tmpAdj = delta/2;		dangle -= tmpAdj;		}	h=radius;	v=0;		sinAngle=dangle;	while(sinAngle>=360)sinAngle-=360;	cosAngle=sinAngle+90;	if(cosAngle>=360)cosAngle-=360;	startPt.h=center.h+((h*SinTable360[cosAngle]-v*SinTable360[sinAngle]+64)>>7);	startPt.v=center.v-((h*SinTable360[sinAngle]+v*SinTable360[cosAngle]+64)>>7);	dangle+=delta;		tmp.left = startPt.h - 3;	tmp.right = startPt.h + 3;	tmp.top = startPt.v - 3;	tmp.bottom = startPt.v + 3;		VMoveTo(startPt.h,startPt.v);		for(i=1;i<nSides;i++)		{		sinAngle=dangle;		while(sinAngle>=360)sinAngle-=360;		cosAngle=sinAngle+90;		if(cosAngle>=360)cosAngle-=360;		pnt.h=center.h+((h*SinTable360[cosAngle]-v*SinTable360[sinAngle]+64)>>7);		pnt.v=center.v-((h*SinTable360[sinAngle]+v*SinTable360[cosAngle]+64)>>7);		dangle+=delta;		VLineTo(pnt.h,pnt.v);		}		VLineTo(startPt.h,startPt.v);		VFrameOval(&tmp);	}/*------------------------------------------------------------------------------ * int LineConvex(Point l1, Point l2,Point r1,Point r2, Point p) * * This determines if the new point p will maintain the convexity of the * polyhedron. *								. *							   . . * 							  .   . *							 .	   . *							.		. *						   .    pn   . *						  .           . *						 . 			   . *						l2___p2....p1___r2 *					   /				 \ *					  /					  \ *					 /					   \ *					/						\ *				   /						 \ *				  l1						  r1 *------------------------------------------------------------------------------*/int LineConvex(Point l1, Point l2,Point r1,Point r2, Point p1, Point p2){int c1,c2,c3;int d1,d2,d3;int t1,t2,t3;c1=Clockwise(r2,l2,l1);c2=Clockwise(r2,p1,l2);c3=Clockwise(r2,p2,l2);if( ((c1==CLOCKWISE || c1==LINEAR) &&	(c2==CLOCKWISE || c2==LINEAR) &&	(c3==CLOCKWISE || c3==LINEAR)) ||	( (c1==COUNTERCLOCKWISE || c1==LINEAR) &&	(c2==COUNTERCLOCKWISE || c2==LINEAR) &&	(c3==COUNTERCLOCKWISE || c3==LINEAR)))	{	d1=Clockwise(p2,l1,l2);	d2=Clockwise(p2,p1,l2);	d3=Clockwise(p2,p1,r2);	if( ((d1==CLOCKWISE || d1==LINEAR) &&		(d2==CLOCKWISE || d2==LINEAR) &&		(d3==CLOCKWISE || d3==LINEAR)) ||		( (d1==COUNTERCLOCKWISE || d1==LINEAR) &&		(d2==COUNTERCLOCKWISE || d2==LINEAR) &&		(d3==COUNTERCLOCKWISE || d3==LINEAR)))			{			t1=Clockwise(p1,l2,p2);			t2=Clockwise(p1,r2,p2);			t3=Clockwise(p1,r2,r1);						if( ((t1==CLOCKWISE || t1==LINEAR) &&				(t2==CLOCKWISE || t2==LINEAR) &&				(t3==CLOCKWISE || t3==LINEAR)) ||				( (t1==COUNTERCLOCKWISE || t1==LINEAR) &&				(t2==COUNTERCLOCKWISE || t2==LINEAR) &&				(t3==COUNTERCLOCKWISE || t3==LINEAR)))					return(TRUE);			}	}	return FALSE;}void DrawDropRect(Rect *r)				{ 			VEraseRect(r);		VFrameRect(r);						VMoveTo(r->left+2,r->bottom);		VLineTo(r->right,r->bottom);	VLineTo(r->right,r->top+2); 		}void DrawDropSymbol(Rect *r)				{ 									VMoveTo(r->right-9,r->bottom-6);		VLineTo(r->right-3,r->bottom-6);		VMoveTo(r->right-8,r->bottom-5);		VLineTo(r->right-4,r->bottom-5);		VMoveTo(r->right-7,r->bottom-4);		VLineTo(r->right-5,r->bottom-4);		VMoveTo(r->right-6,r->bottom-3);		VLineTo(r->right-6,r->bottom-3);		}void DrawPopSymbol(Rect *r)				{ 									VMoveTo(r->right-7,r->top+2);		VLineTo(r->right-7,r->top+8);		VMoveTo(r->right-6,r->top+3);		VLineTo(r->right-6,r->top+7);		VMoveTo(r->right-5,r->top+4);		VLineTo(r->right-5,r->top+6);		VMoveTo(r->right-4,r->top+5);		VLineTo(r->right-4,r->top+5);		}	void DrawSelectSymbol(Rect *r)				{ 	int	middle,x,y;		x = 0;	y = r->top + 2;	middle = (r->right+r->left)>>1;																					VMoveTo(middle+x,y);		VLineTo(middle-x,y);		x++;y++;	VMoveTo(middle+x,y);		VLineTo(middle-x,y);		x++;y++;	VMoveTo(middle+x,y);		VLineTo(middle-x,y);		y++;	VMoveTo(middle+x,y);		VLineTo(middle-x,y);		y+=2;	VMoveTo(middle+x,y);		VLineTo(middle-x,y);		y++;	VMoveTo(middle+x,y);		VLineTo(middle-x,y);		x--;y++;	VMoveTo(middle+x,y);		VLineTo(middle-x,y);		x--;y++;	VMoveTo(middle+x,y);		VLineTo(middle-x,y);		VMoveTo(r->left+1,r->top);		VLineTo(r->right-1,r->top);	VMoveTo(r->right,r->top+1);		VLineTo(r->right,r->bottom-1);	VMoveTo(r->right-1,r->bottom);		VLineTo(r->left+1,r->bottom);	VMoveTo(r->left,r->bottom-1);		VLineTo(r->left,r->top+1);	}	// jca 27 Sept 93 {	// MERGE17 [[[#if MACINTOSHvoid PStrConcat(UChar *targetStr, UChar *appendStr){	long appendLen;	/* Figure out number of bytes to copy, up to 255 */	if ((targetStr[0] + appendStr[0]) > 255)		appendLen = 255 - targetStr[0];	else		appendLen = appendStr[0];	if (appendLen > 0) {		BlockMove (appendStr + 1, targetStr + targetStr[0] + 1, appendLen);		targetStr [0] += appendLen;	}}#endifvoid Ellipsis (char *str, int desired_width){#if MACINTOSHchar pstr[256];short length;	strcpy(pstr, str);	C2Pstr(pstr); 	length = pstr[0];// DAS-VR-FIX 9/26/93	while ( length>0 && StringWidth((StringPtr)pstr) > desired_width )	{		length--;#if JAPANESE		length &= ~(0x0001);#endif //JAPANESE		pstr[0] = length;		PStrConcat((StringPtr)pstr, (unsigned char*)TXT_ELLIPSIS_P);		// PRO-JAP    }	P2Cstr(pstr);	strcpy(str, pstr);#elif WINDOWSchar tempStr[256];short length, doesntFit = TRUE;ULong extLen;	strcpy(tempStr, str);	length = strlen(tempStr);    if (length > 252)	length = 252;	// truncate	extLen = GetTextExtent(GetGraphicContext(), tempStr, strlen(tempStr));	if (LOWORD(extLen) <= desired_width)		doesntFit = FALSE;	while (doesntFit && length > 0)		{		length--;#if JAPANESE		length &= ~(0x0001);#endif //JAPANESE		tempStr[length] = '\0';		strcat(tempStr, TXT_ELLIPSIS);		extLen = GetTextExtent(GetGraphicContext(), tempStr, strlen(tempStr));		if (LOWORD(extLen) <= desired_width)			doesntFit = FALSE;		}    strcpy(str, tempStr);#endif // MACINTOSH}// MERGE17 ]]]// jca 27 Sept 93 }// jca 15 Oct 93 {/*	center the text within a rectangle.  If the text is too large,	we truncate it when we render.  Life is tough.	(but we return a flag to show the text was too big)   	*/intCenterTextInRect(char *str, Rect *r_in, Rect *r_out){	int 	err = noErr;    int		width, height, tWidth, tHeight;#if MACINTOSH	char pstr[256];    FontInfo fInfo;	strcpy(pstr, str);	C2Pstr(pstr);	tWidth = StringWidth((StringPtr)pstr);	GetFontInfo(&fInfo);	tHeight = fInfo.ascent;#elif WINDOWS	ULong winSize;	winSize = GetTextExtent(GetGraphicContext(), str, strlen(str));	tWidth = LOWORD(winSize);	tHeight = HIWORD(winSize);#endif	width = r_in->right - r_in->left;	height = r_in->bottom - r_in->top;	// truncate the text rect size.  If we want to do	// anything fancy, like elipses, do it here.	if (tWidth > width)		{ tWidth = width; 	err = -1; }	if (tHeight > height)	{ tHeight = height; err = -2; }	r_out->left = r_in->left + (width - tWidth)/2;	r_out->right = r_in->right - (width - tWidth)/2;	r_out->top = r_in->top + (height - tHeight)/2;	r_out->bottom = r_in->bottom - (height - tHeight)/2;    return (err);}// jca 15 Oct 93 }