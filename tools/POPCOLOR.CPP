/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   David A. Smith *               *               * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "PopColor.h"#include "WalkBuff.h"#include "VArray.h"#include "VGraphic.h"#include "VButton.h"#include "VGUtil.h"#include "VWindow.h"#include "clip.h"          // jca#include "AppText.h"#if MACINTOSH#include <QDOffscreen.h>#endif //MACINTOSH#define P_MONO  1#define P_16    2#define P_216   3#define CLRWHEEL_PICT 128#define MONOWHEEL_PICT 129#define WHEELMASK_PICT 130#define MONO_PAL_PICT	8131#define BIT4_PAL_PICT	8132#define BIT8_PAL_PICT	8133// these are the defines for the color display routine#define COLOR_MULTIPLIER	0x0FFFF#if MACINTOSH#define NGRAYS_IN_STRIP 	36#define N_RGB_SAT_CLRS		18#define N_RGB_TINTS			18#define N_CMY_IN_STRIP		12#define N_CMY_SAT_CLRS		6#define N_CMY_TINTS			6#define GRAY_FACTOR			0#define RGB_FACTOR			0#define CMY_FACTOR			0#elif WINDOWS#define NGRAYS_IN_STRIP 	35#define N_RGB_SAT_CLRS		18#define N_RGB_TINTS			19#define N_CMY_IN_STRIP		12#define N_CMY_SAT_CLRS		6#define N_CMY_TINTS			7#define GRAY_FACTOR			0#define RGB_FACTOR			1#define CMY_FACTOR			1#endif#define RESOURCE_PALETTE	1    // #def to control whether we draw the palette fresh each time, or use a resource#if MACINTOSH#undef RESOURCE_PALETTERGBColor clut[] = {                    {0x0000,0x0000,0x0000},                    {0x2000,0x2000,0x2000},                    {0x8000,0x8000,0x8000},                    {0xC000,0xC000,0xC000},                    {0xFFFF,0xFFFF,0xFFFF},                                        {0x5600,0x2C9D,0x0524}, /* brown */                    {0x90D7,0x7160,0x3A34}, /* tan */                    {0xF2D7,0x0856,0x84EC}, /* pink */                                        {0xDD6B,0x08C2,0x06A2}, /* red */                    {0xFFFF,0x648A,0x028C}, /* orange */                    {0xFC00,0xF37D,0x052F}, /* yellow */                    {0x1F21,0xB793,0x1431}, /* light green */                    {0x0000,0x64AF,0x11B0}, /* dark green */                    {0x0241,0xAB54,0xEAFF}, /* light blue */                    {0x0000,0x0000,0xD400}, /* dark blue */                    {0x46E3,0x0000,0xA53E}  /* violet */                    };#elif WINDOWSshort	color6Cubed[] = {					0x0000, 0x4000, 0x8000,  // six-cubed color space					0xC000, 0xE000, 0xFFFF					};RGBColor clut[] = {					{0xFFFF,0xFFFF,0xFFFF}, /* white */					{0xFFFF,0x0000,0x0000}, /* red */                    {0xFFFF,0xFFFF,0x0000}, /* yellow */                    {0x0000,0xFFFF,0x0000}, /* green */                    {0x0000,0xFFFF,0xFFFF}, /* cyan */                    {0x0000,0x0000,0xFFFF}, /* blue */                    {0xFFFF,0x0000,0xFFFF}, /* magenta */                    {0x8000,0x8000,0x8000},  /* dark gray */					{0xC000,0xC000,0xC000}, /* light gray */					{0x8000,0x0000,0x0000}, /* dark red */                    {0x8000,0x8000,0x0000}, /* dark yellow */					{0x0000,0x8000,0x0000}, /* dark green */					{0x0000,0x8000,0x8000}, /* dark cyan */                    {0x0000,0x0000,0x8000}, /* dark blue */					{0x8000,0x0000,0x8000}, /* dark magenta */					{0x0000,0x0000,0x0000}  /* black */					};V_Offscreen *colorPaletteResource;   // the colorpalette resource#endifV_Offscreen *wheel1;   // the color picker iconsV_Offscreen *wheel8;V_Offscreen *mask;V_Offscreen *image1;V_Offscreen *image8;int resCounter=0;      // a use counter for the resources/*** struct PopColor ***********************************************//* PopColor is a derived pane that allows the user to select colors from a * palette, or bring up a color picker dialog box.  Call cPopColor() when * the pane is first created, and then Pop() to bring up the pane.  Remember() * is used to add a color to the "recent" list, externally.  Call dPane() * when destroying the parent object, after you are completely through with * the PopColor.  These four routines are the only ones that the programmer * should need to call, in general. *//* cPane() * This basically just initializes all of the internal variables.  Call this * just after allocating space for the object. */voidPopColor::cPane(int flag)    {    int i;    Rect rr;        V_Pane::cPane(flag);        rcx = 16;    rcy = 16;    rnx = 15;    rny = 2;    nr = rnx * rny;    cc.red = 0;    cc.green = 0;    cc.blue = 0;        czone = ZoneNowhere;    ci = 0;    cj = 0;    VSetRect(&cr,0,0,0,0);        recent = new(V_Array);    recent->cArray(nr, sizeof(RGBColor), 5);    cz = (RGBColor*)recent->Use();    for (i=0; i<nr; i++)        {        cz[i].red = 1;        cz[i].green = 2;        cz[i].blue = 3;        }    recent->Unuse();        rr.top=rr.left=0;    rr.bottom=rr.right=40;	if(!resCounter)		{		wheel1=new(V_Offscreen);	        wheel1->LoadPNum(MONOWHEEL_PICT,0);	    image1=new(V_Offscreen);	    image1->cOffscreen(&rr,0,NULL,NULL);	    if(MainDepth())	        {   	        wheel8=new(V_Offscreen);	        wheel8->LoadPNum(CLRWHEEL_PICT,8);	        image8=new(V_Offscreen);	        image8->cOffscreen(&rr,8,NULL,NULL);	        }	    mask=new(V_Offscreen);	    mask->LoadPNum(WHEELMASK_PICT,0);#ifdef RESOURCE_PALETTE		colorPaletteResource=new(V_Offscreen);   // jca		if (MainDepth() > 4)			{			Rect	size;			PaneDepth();     // set the pane's depth            SetPT();         // set the color picker parameters			size.top = size.left = 0;        // size of the color picker palette			size.right = pcx*pnx;			size.bottom = pcy*pny;			colorPaletteResource->cOffscreen(&size, MainDepth(), NULL, NULL);			colorPaletteResource->SetMetaPort();   // draw the palette into the pane			DisplayPalette(0, 0);			colorPaletteResource->UnsetMetaPort();			// old way.  Perhaps high-color monitors should make use of this one?  jca 6 july 93			// colorPaletteResource->LoadPNum(BIT8_PAL_PICT,8);  			}		else if (MainDepth() > 1)			colorPaletteResource->LoadPNum(BIT4_PAL_PICT,4);		else			colorPaletteResource->LoadPNum(MONO_PAL_PICT,1);#endif		}	resCounter++;	}/* dPane() * This deletes the V_Array of recently used colors, and then deletes the * pane itself.  Call this when you're completely through with the pane. */voidPopColor::dPane()    {	resCounter--;    if(resCounter==0)		{		wheel1->dOffscreen();		mask->dOffscreen();	    image1->dOffscreen();	    if(MainDepth())	        {	        wheel8->dOffscreen();	        image8->dOffscreen();	        }#if RESOURCE_PALETTE		colorPaletteResource->dOffscreen();#endif		}	recent->dArray();    V_Pane::dPane();	}/* CalcSize() * This is called from V_Windows, to resize the pane.  The internal rectangles are * also initialized. */voidPopColor::CalcSize(Rect *r,Point *p,int type,int warning)    {    SetPT();    VSetRect(&cRect, 0, 0, 40, 40);    VOffsetRect(&cRect, 8, 4);/* 	in the old way, the color squares had no separating black lines and just ran	together.  The square size was 8x8.  The new way has different sized and offset 	rects 	-- jca 6 aug 93    SetRect(&rRect, 0, 0, rcx*rnx, rcy*rny);    VOffsetRect(&rRect, cRect.right, 0);    VOffsetRect(&rRect, 8, 8);    VSetRect(&pRect, 0, 0, pcx*pnx, pcy*pny);    VOffsetRect(&pRect, 0, rRect.bottom);    VOffsetRect(&pRect, 8, 8);	*/	// windows and mac, the new way    SetRect(&rRect, 0, 0, rcx*rnx, rcy*rny);    VOffsetRect(&rRect, cRect.right, 0);    VOffsetRect(&rRect, 7, 8);    VSetRect(&pRect, 0, 0, pcx*pnx-1, pcy*pny-1);    VOffsetRect(&pRect, 0, rRect.bottom);    VOffsetRect(&pRect, 8, 8);    VSetRect(r,0,0,pRect.right+8,pRect.bottom+8);    if(type==POPUP)        {        r->bottom-=5;        r->right-=5;        }             }/* Paint() * This paints the "current color" rectangle with whatever color is passed * to it.  This is called from Track() to reflect what the user is doing. */voidPopColor::Paint(RGBColor *rgb)    {    Rect r1,r2,rr,rimage;    VGrafPort   savePort;    VGrafDevice     saveDevice;    extern V_Offscreen *popScrn;#if WINDOWS    V_Array *points;    // jca    Clip    *clip=NULL, *tempclip = NULL;      // jca    Point   *p; // jca#endif //WINDOWS    VGetPort(&savePort,&saveDevice);    if(depth<4)image1->SetMetaPort();    else image8->SetMetaPort();    rimage.top=rimage.left=0;    rimage.right=rimage.bottom=40;            VForeColor(rgb);#if MACINTOSH    VPaintRect(&rimage);    VFrameRect(&rimage);#elif WINDOWS	VSetPattern(vPatDithered);  	points = new(V_Array);                  //    points->cArray(4, sizeof(Point), 1);      //	p = (Point *) VA_Abuse(points);          //	p[0].v = p[3].v = currentPane->centerY - rimage.top+1;   // top edge	p[1].v = p[2].v = currentPane->centerY - rimage.bottom;   // bottom edge	p[0].h = p[1].h = rimage.left - currentPane->centerX-1;   // left edge    p[2].h = p[3].h = rimage.right - currentPane->centerX;   // right edge	//JAM 12Oct94 the clip stuff is this way for bizarre historical reasons [[[	{		Rect r;		r.left = 0;		r.right = 32000;		r.top = 0;		r.bottom = 32000;		tempclip = new(Clip);        // jca		tempclip->cClip();           // jca        clip = tempclip->CreateInitialClip(&r);    }	//JAM 12Oct94 the clip stuff is this way for bizarre historical reasons ]]]	//JAM MERGE-GOURAUD-PRO	clip->DrawPoly(points, CLIP_FILL|CLIP_DITHER, NULL, FALSE, vPatBlack, rgb, rgb, FALSE, NULL);	if(clip) clip->dClip();	if(tempclip) tempclip->dClip();	points->dArray();	VSetPattern(vPatBlack);#endif //MACINTOSH    r1.top=r1.left=0;    r1.bottom=r1.right=32;    r2.top=r2.left=4;    r2.bottom=r2.right=36;    rr = cRect;    if(depth<4)        {        image1->UnsetMetaPort();        wheel1->MaskMetaTo(image1,mask,&r1,&r2);        image1->MetaTo(popScrn,&rimage,&rr);        }    else        {        image8->UnsetMetaPort();		wheel8->MaskMetaTo(image8,mask,&r1,&r2);		image8->MetaTo(popScrn,&rimage,&rr);         }#if WINDOWS    if (popScrn)        {         // this puts the color rect on the screen        SetMetaPort();     // jca        MetaCopy(&cRect); // jca        UnsetMetaPort(); // jca        }#endif    VSetPort(savePort,saveDevice);    }voidPopColor::SetPT(void)    {    if (depth<4) pt = P_MONO;#if MACINTOSH    if (depth==4) pt = P_16;	if (depth>4) pt = P_216;#elif WINDOWS//	if (depth==4) pt = P_16;	if (depth>=4) pt = P_216;#endif    switch (pt)        {        case P_MONO:            pcx = 18;            pcy = 49;            pnx = 16;            pny = 1;            break;        case P_16:            pcx = 36;            pcy = 25;            pnx = 8;            pny = 2;            break;        case P_216:            pcx = 8;            pcy = 8;            pnx = 36;            pny = 11;            break;        }    }/* Display() * This is called from PopUp() to display the pane. */voidPopColor::Display(int scroll,int h,int v)    {    RGBColor rgb;    Rect rr,r,pR;    int i,j,x,y;extern V_Offscreen *popScrn;int offscr = TRUE;#if WINDOWS	Rect    resRect;       // size of color palette resource#endif#if MACINTOSH	PenNormal();	Paint(&cc);	VForeColor(&vBlack);	rr = cRect;	VForeColor(&vBlack);	InsetRect(&rr,-1,-1);	FrameRect(&rr);		rr = rRect;	InsetRect(&rr,-1,-1);	if(depth>=4)rgb = offColor[TopFrame]; //DAS-VBUTTON 8/13/93 // 2 Oct 93	else rgb.red = rgb.green = rgb.blue = 0xFFFF;	VForeColor(&rgb);	PaintRect(&rr);	VForeColor(&vBlack);	FrameRect(&rr);		for (i=0; i<rnx; i++)	for (j=0; j<rny; j++)		{		RRect(i,j,&rr);		InsetRect(&rr,1,1);		RColor(i,j,&rgb);		if (rgb.red == 1 && rgb.green == 2 && rgb.blue == 3)			{			}		else			{			VForeColor(&(rgb));			PaintRect(&rr);			VForeColor(&vBlack);			FrameRect(&rr);			}		}		for (i=0; i<pnx; i++)	for (j=0; j<pny; j++)		{		PRect(i,j,&rr);		PColor(i,j,&rgb);		VForeColor(&rgb);		PaintRect(&rr);		}	VForeColor(&vBlack);	rr = pRect;	InsetRect(&rr,-1,-1);	FrameRect(&rr);	    for (i = 1; i <= pnx; i++)  // jca        {        VMoveTo(pRect.left+i*pcx -1, pRect.top);        VLineTo(pRect.left+i*pcx -1, pRect.top + pcy*pny-1);		}    for (j = 1; j <= pny; j++)   // jca        {        VMoveTo(pRect.left, pRect.top+ j*pcy -1);        VLineTo(pRect.left+pnx*pcx-1, pRect.top + pcy*j -1);        }#elif WINDOWS#if RESOURCE_PALETTE	colorPaletteResource->GetRect(&resRect); // jca#endif    r = dataRect;    pR = r;#if WINDOWS    pR.left++; pR.top++;    // jca this isn't a button!#endifif(offscr)    SetMetaPort();    if(depth>2&&colorButton)        TallColorButton(&pR,offColor);    else         {        pR.right--;        pR.bottom--;        MonoButton(&pR,0);        VMoveTo(pR.left,pR.bottom);        VLineTo(pR.right,pR.bottom);        VLineTo(pR.right,pR.top);        pR.right++;        pR.bottom++;        }	VSetPenNormal();    VForeColor(&vBlack);    rr = cRect;    VForeColor(&vBlack);    rr.top--;rr.left--;    rr.bottom++;rr.right++;    VFrameRect(&rr);        rr = rRect;    rr.top--;rr.left--;    rr.bottom++;rr.right++;    if(depth>=4)rgb = offColor[TopFrame]; //DAS-VBUTTON 8/13/93   // jca 2 Oct 93    else rgb.red = rgb.green = rgb.blue = 0xFFFF;    VForeColor(&rgb);    VPaintRect(&rr);    VForeColor(&vBlack);    VFrameRect(&rr);    VSetPattern(vPatDithered);  // jca set ditherable brush	DisplayRecent(currentPane->centerX, currentPane->centerY);	VForeColor(&vBlack);	VSetPattern(vPatBlack); // jca set pattern brush    rr = pRect;	rr.top--;rr.left--;	rr.bottom++;rr.right++;	VFrameRect(&rr);#ifdef RESOURCE_PALETTE	pR = pRect;	colorPaletteResource->MetaTo(popScrn, &resRect, &pR);#else	DisplayPalette(currentPane->centerX, currentPane->centerY);#endifif(offscr)    {    MetaCopy(&r);    UnsetMetaPort();    }    Paint(&cc);    VSetPattern(vPatBlack);    // jca#endif //WINDOWS - BUGBUG	}/* Pop() * This is the main callable routine.  Pass the point where the user clicked * (in local coordinates) and the color to be edited.  The return value * indicated whether or not a new color was selected.  Be careful that the * color being passed is not part of an unlocked relocatable block; otherwise * the results are unpredictable. */intPopColor::Pop(Point pt, RGBColor *c, Rect *avoidArea)    {    int sel;    #if MACINTOSH	LocalToGlobal(&pt);#endif //MACINTOSH    cc=*c;    VSetRect(&cr,0,0,0,0);	PopUp(pt,TRUE,avoidArea);    if (sel = Done())        *c=cc;	return(sel);    }/* this draws the recent color swatches to the current metaport */voidPopColor::DisplayRecent(int XPaneOffset, int YPaneOffset)	{	int 		i, j;	RGBColor 	rgb;    Rect		rr;#if WINDOWS	Clip		*clip = NULL, *tempclip = NULL;	V_Array		*points;    Point		*p;    // setup	points = new(V_Array);    points->cArray(4, sizeof(Point), 1);   	//JAM 12Oct94 the clip stuff is this way for bizarre historical reasons [[[	{		Rect r;		r.left = 0;		r.right = 32000;		r.top = 0;		r.bottom = 32000;		tempclip = new(Clip);        // jca		tempclip->cClip();           // jca        clip = tempclip->CreateInitialClip(&r);    }	//JAM 12Oct94 the clip stuff is this way for bizarre historical reasons ]]]#endif	for (i=0; i<rnx; i++)    for (j=0; j<rny; j++)        {        RRect(i,j,&rr);        rr.top++;rr.left++;		rr.bottom--;rr.right--;        RColor(i,j,&rgb);        if (rgb.red == 1 && rgb.green == 2 && rgb.blue == 3)            {            }        else            {#if MACINTOSH            VForeColor(&(rgb));            VPaintRect(&rr);            VForeColor(&vBlack);            VFrameRect(&rr);#elif WINDOWS            p=(Point *)VA_Abuse(points);    // jca            p[0].v = p[3].v = YPaneOffset - rr.top;   // jca            p[1].v = p[2].v = YPaneOffset - rr.bottom+1;   // jca            p[0].h = p[1].h = rr.left - XPaneOffset;   // jca            p[2].h = p[3].h = rr.right - XPaneOffset-1;   // jca			//JAM MERGE-GOURAUD-PRO			clip->DrawPoly(points, CLIP_FRAME|CLIP_FILL|CLIP_DITHER, NULL, FALSE, vPatBlack, &rgb, &vBlack, FALSE, NULL);#endif            }		}#if WINDOWS	if(clip) clip->dClip();	if(tempclip) tempclip->dClip();	points->dArray();#endif	}/* draw the color picker palette to the current metaport */voidPopColor::DisplayPalette(int XPaneOffset, int YPaneOffset)	{	int 		i, j;	RGBColor 	rgb;    Rect		pr;#if WINDOWS	Clip		*clip = NULL, *tempclip = NULL;	V_Array		*points;	Point		*p;    // setup	points = new(V_Array);	points->cArray(4, sizeof(Point), 1);	//JAM 12Oct94 the clip stuff is this way for bizarre historical reasons [[[   	{		Rect r;		r.left = 0;		r.right = 32000;		r.top = 0;		r.bottom = 32000;		tempclip = new(Clip);		tempclip->cClip();		clip = tempclip->CreateInitialClip(&r);	}           	//JAM 12Oct94 the clip stuff is this way for bizarre historical reasons ]]]#endif	for (i=0; i<pnx; i++)    for (j=0; j<pny; j++)        {        PRect(i,j,&pr);        PColor(i,j,&rgb);#if MACINTOSH		VForeColor(&rgb);        VPaintRect(&pr);#elif WINDOWS        p=(Point *)VA_Abuse(points);    // jca		p[0].v = p[3].v = YPaneOffset - pr.top;   // jca		p[1].v = p[2].v = YPaneOffset - pr.bottom+1;   // jca		p[0].h = p[1].h = pr.left - XPaneOffset+1;   // jca		p[2].h = p[3].h = pr.right - XPaneOffset;   // jca		//JAM MERGE-GOURAUD-PRO		clip->DrawPoly(points, CLIP_FILL, NULL, FALSE, vPatBlack, &rgb, &rgb, FALSE, NULL);#endif        }	// draw the nice frames around the colors	VForeColor(&vBlack);    for (i = 1; i <= pnx; i++)  // jca        {        VMoveTo(pRect.left+i*pcx -1, pRect.top);        VLineTo(pRect.left+i*pcx -1, pRect.top + pcy*pny);		}    for (j = 1; j <= pny; j++)   // jca        {        VMoveTo(pRect.left, pRect.top+ j*pcy -1);        VLineTo(pRect.left+pnx*pcx, pRect.top + pcy*j -1);        }#if WINDOWS	//JAM 12Oct94 the clip stuff is this way for bizarre historical reasons [[[	if(clip) clip->dClip();	if(tempclip) tempclip->dClip();	//JAM 12Oct94 the clip stuff is this way for bizarre historical reasons ]]]	points->dArray();#endif	}/* RColor() * This returns the color associated with a particular location in the * "recent" grid.  The value is fetched from the V_Array recent. */voidPopColor::RColor(int i, int j, RGBColor *c)    {    int r;        r = i+j*rnx;    recent->Get(r,c);    }/* PColor() * This returns the color associated with a particular location in the * palette grid.  The value is computed from the coordinates. */voidPopColor::PColor(int i, int j, RGBColor *c)    {    int r,g,b;        switch (pt)        {        case P_MONO:            c->red = c->green = c->blue = i*0x1111; // jca.  this gives 16 values over the range of 0 to 0xFFFF, inclusive.  old methoid was (i+1)*0x0FFF;            break;        case P_16:            *c = clut[i+j*8];            break;        case P_216:			if(j<6)                {                b = j;                g = i/6;                r = i-g*6;#if MACINTOSH                c->red = r*13107;                c->green = g*13107;                c->blue = b*13107;#elif WINDOWS 				c->red = color6Cubed[r];				c->green = color6Cubed[g];				c->blue = color6Cubed[b];#endif			   }            else             switch(j)                {                case 6:/* gray */					c->green=c->blue=c->red=(i+GRAY_FACTOR)*(COLOR_MULTIPLIER/NGRAYS_IN_STRIP);                    break;                case 7:/* red */					if(i<N_RGB_SAT_CLRS)                        {						c->red=(i+RGB_FACTOR)*(COLOR_MULTIPLIER/N_RGB_SAT_CLRS);                        c->green=c->blue=0;                        }                    else                        {						i-=N_RGB_SAT_CLRS;                        c->red=0xFFFF;						c->green=c->blue=(i+RGB_FACTOR)*(COLOR_MULTIPLIER/N_RGB_TINTS);                        }                    break;                case 8:/* green */					if(i<N_RGB_SAT_CLRS)                        {						c->green=(i+RGB_FACTOR)*(COLOR_MULTIPLIER/N_RGB_SAT_CLRS);                        c->red=c->blue=0;                        }                    else                        {						i-=N_RGB_SAT_CLRS;                        c->green=0xFFFF;						c->red=c->blue=(i+RGB_FACTOR)*(COLOR_MULTIPLIER/N_RGB_TINTS);                        }                    break;                case 9:/* blue */					if(i<N_RGB_SAT_CLRS)                        {						c->blue=(i+RGB_FACTOR)*(COLOR_MULTIPLIER/N_RGB_SAT_CLRS);                        c->red=c->green=0;                        }                    else                        {						i-=N_RGB_SAT_CLRS;                        c->blue=0xFFFF;						c->red=c->green=(i+RGB_FACTOR)*(COLOR_MULTIPLIER/N_RGB_TINTS);                        }                    break;                case 10:/* cyan...magenta...yellow */					if(i<N_CMY_IN_STRIP)                        {						if(i<N_CMY_SAT_CLRS)                            {							c->blue=c->green=(i+CMY_FACTOR)*(COLOR_MULTIPLIER/N_CMY_SAT_CLRS);                            c->red=0;                            }                        else                            {							i-=N_CMY_SAT_CLRS;							c->blue=c->green=COLOR_MULTIPLIER;							c->red=(i+CMY_FACTOR)*(COLOR_MULTIPLIER/N_CMY_TINTS);                            }                                                    }					else if(i<2*N_CMY_IN_STRIP)                        {						i-=N_CMY_IN_STRIP;						if(i<N_CMY_SAT_CLRS)                            {							c->red=c->blue=(i+CMY_FACTOR)*(COLOR_MULTIPLIER/N_CMY_SAT_CLRS);                            c->green=0;                            }                        else                            {							i-=N_CMY_SAT_CLRS;							c->red=c->blue=COLOR_MULTIPLIER;							c->green=(i+CMY_FACTOR)*(COLOR_MULTIPLIER/N_CMY_TINTS);                            }                        }                    else                        {						i-=2*N_CMY_IN_STRIP;						if(i<N_CMY_SAT_CLRS)                            {							c->green=c->red=(i+CMY_FACTOR)*(COLOR_MULTIPLIER/N_CMY_SAT_CLRS);                            c->blue=0;                            }                        else                            {							i-=N_CMY_SAT_CLRS;                            c->green=c->red=0xFFFF;							c->blue=(i+CMY_FACTOR)*(COLOR_MULTIPLIER/N_CMY_TINTS);                            }                        }                    break;                }            break;		}    }/* RRect() * This returns the rectangle associated with a particular location in the * "recent" grid. */voidPopColor::RRect(int i, int j, Rect *r)    {    int x,y;        x = i*rcx + rRect.left;    y = j*rcy + rRect.top;    VSetRect(r,0,0,rcx,rcy);    VOffsetRect(r,x,y);    }/* PRect() * This returns the rectangle associated with a particular location in the * palette grid. */voidPopColor::PRect(int i, int j, Rect *r)    {    int x,y;        x = i*pcx + pRect.left;    y = j*pcy + pRect.top;/*  if(j==6)y+=4;*/  //   VSetRect(r,0,0,pcx,pcy);   old way -- jca 6 aug 93    VSetRect(r,0,-1,pcx+1,pcy);/* this is how it used to work on the mac when the colors were all smerged together,rather than separated by black lines, like it is now.		-- jca 6 aug 93   	VOffsetRect(r,x,y);			*/    VOffsetRect(r,x-1,y);    }/* SetCR() * stands for "Set Current Rectangle".  Updates cr to the given rectangle, * un-hiliting the old rectangle and hiliting the new one. */voidPopColor::SetCR(Rect *r)    {    RGBColor c;    if (r->left == cr.left &&        r->right == cr.right &&        r->top == cr.top &&        r->bottom == cr.bottom) return;    if (czone == ZonePalette)        PColor(ci,cj,&c);    else if (czone == ZoneRecent)        {        if(depth>=4)c = offColor[TopFrame]; //DAS-VBUTTON 8/13/93  // jca 2 Oct 93        else c.red = c.green = c.blue = 0xFFFF;        }    else         {		if(depth>=4)c = offColor[BaseColor]; //DAS-VBUTTON 8/13/93    // jca 2 Oct 93        else c.red = c.green = c.blue = 0xFFFF;        }	if (czone == ZonePalette)		VForeColor(&vBlack);    else		VForeColor(&c);			if ((cr.left < cr.right) && (cr.top < cr.bottom))	// if czone == ZoneNowhere, cr = {0,0,0,0}		VFrameRect(&cr);	cr.left = r->left;	cr.right = r->right;    cr.top = r->top;    cr.bottom = r->bottom;    if(depth>=4 || czone==ZonePalette)VForeColor(&vWhite);	else VForeColor(&vBlack);    VFrameRect(&cr);	}/* Track() * This is called from PopUp() repeatedly, as long as the user holds down the * mouse button.  It handles hiliting the appropriate rectangle and showing the * current color, by calling SetCR() and Paint(). */voidPopColor::Track(Point pt, long modifier, int inside)    {    Rect r;    int i,j;    RGBColor c;#if WINDOWS	// if the button is not down, the do the tracking, but don't do	// the current rect update or the hilighting	if (!(modifier & buttonDown))		{		if (VPtInRect(pt, &cRect))			czone = ZoneCurrent;		else if (VPtInRect(pt, &rRect))			czone = ZoneRecent;		else if (VPtInRect(pt, &pRect))			czone = ZonePalette;		else			czone = ZoneNowhere;        return;		} #endif    if (VPtInRect(pt,&cRect))        {        SetCR(&cRect);       	czone = ZoneCurrent;        ci = 0;        cj = 0;        return;        }    if (VPtInRect(pt,&rRect))        {        i = (pt.h - rRect.left) / rcx;        j = (pt.v - rRect.top) / rcy;        RColor(i,j,&c);        if (c.red == 1 && c.green == 2 && c.blue == 3)            goto outside;        RRect(i,j,&r);        SetCR(&r);        Paint(&c);        czone = ZoneRecent;        ci = i;        cj = j;        return;        }    if (VPtInRect(pt,&pRect))        {       i = (pt.h - pRect.left) / pcx;        j = (pt.v - pRect.top) / pcy;        PColor(i,j,&c);        PRect(i,j,&r);		SetCR(&r);        Paint(&c);        czone = ZonePalette;        ci = i;        cj = j;        return;        }outside:    VSetRect(&r,0,0,0,0);    SetCR(&r);    Paint(&cc);    czone = ZoneNowhere;    ci = 0;    cj = 0;    }/* Remember() * This adds the given color to the "recent" list, or shuffles it up to the * top if it's already in the list. */voidPopColor::Remember(RGBColor *rgb)    {    int i;    RGBColor c;        if (rgb) if (rgb!=&cc) cc=*rgb;    recent->Insert(0,&cc);    for (i=1; i<nr; i++)        if (!recent->Get(i,&c))            if (c.red == cc.red && c.green == cc.green && c.blue == cc.blue)                break;    recent->Remove(i);    }/* GetRecent() * This adds the given color to the "recent" list, or shuffles it up to the * top if it's already in the list. */RGBColorPopColor::GetRecent(void)    {    RGBColor c;    if(recent->ALength())        recent->Get(0,&c);    return(c);    }/* Done() * This updates cc based on where the mouse cursor was when the user released * the mouse button.  It returns TRUE if the user chose a color, or FALSE * if he didn't. */intPopColor::Done(void)    {    RGBColor c;    RGBColor oc = cc;    Point pt = {0,0};    switch (czone)        {        case ZoneNowhere:            return(FALSE);			break;        case ZoneCurrent:            c=cc;			if(!VColorWheel(TXTI_SELECTCOLOR,&c))                return(FALSE);            cc=c;            break;        case ZoneRecent:            RColor(ci,cj,&cc);            break;        case ZonePalette:            PColor(ci,cj,&cc);            break;        }    Remember(&cc);    return(TRUE);    }intPopColor::IO_Color(V_Buffer *buf)    {	short num, i;	RGBColor *r, *rSave;    int err = 0;		r = rSave = (RGBColor*)recent->Use();	if (buf->IODirection() == DATA_OUT)		{		for (num = 0; num < nr; num++)			if (r[num].red == 1 && r[num].green == 2 && r[num].blue == 3)				break;		}	err = buf->IOType(&num, IO_SHORT);	r = rSave;	for (i = 0; i < num && !err; i++)		err = IOType(buf, r+i, IO_RGB_COLOR);	recent->Unuse();	return err;	}