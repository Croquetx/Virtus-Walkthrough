/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  * Platform: 	MACINTOSH 	X *				WINDOWS		 *------------------------------------------------------------------------------ */#include "VTypes.h"#include "ClrPane.h"#include "PopColor.h"#include "Cntrl.h"#include "CadCntrl.h"#include "AppMssgs.h"#include "AppDeflt.h"#include "ToolDef.h"#include "BallHelp.h"#include "Misc.h"#include "VGraphic.h"#include "VGUtil.h"#include "Clip.h"  // jca 16FEB94 use flash for the colorbar#include <stdlib.h>#include <string.h>#define USE_FLASH_FOR_COLORBAR  1  // jca 16FEB94void ColorSelect::SetController(Controller *ctrl)	{ 	AppPreference		*appPref;	DefaultPreference	*defPref;		controller = ctrl; 	appPref = controller->GetPreference();	defPref = (DefaultPreference*)appPref->GetPreference(preferDefaults);		popColor = defPref->popColor;	defaultColor = popColor->GetRecent();	}	void ColorSelect::CalcSize(Rect *r,Point *p,int type,int warning)	{	controller->GetPlace(r,warning,toolPColor);	}void	ColorSelect::Display(int type,int x,int y)	{	Rect	r;#if WINDOWS	VPenState	oldPen;    VGetPen(&oldPen);	// jca 15FEB94 save the old pen state, then set a solid line.	VSetPenNormal();    // jca 15FEB94 the dashed line used in the draft view with the color dropper does get undone.#endif // WINDOWS	r = dataRect;	if(2 < depth)		{			VForeColor(&vColorSlateM);		VPaintRect(&r);			}	else		VEraseRect(&r);			VForeColor(&vBlack);	VFrameRect(&r);	r.left+=2;r.right-=2;	r.top+=2;r.bottom-=2;#if WINDOWS && USE_FLASH_FOR_COLORBAR	/* WHY:  we'd like to have the color picker-select bar thingie to draw the	REAL color under Windows, not the solid color that approximates it.  If Windows	would dither, so should we.		jca 7 aug 93    */		{		Clip		*clip;		V_Array		*points;    	Point		*p;		// setup    	VSetPattern(vPatDithered);		points = new(V_Array);    	points->cArray(4, sizeof(Point), 1);       	clip = new(Clip);            	clip->cClip();           		p=(Point *)VA_Abuse(points);    		p[0].v = p[3].v = currentPane->centerY - r.top+1;		p[1].v = p[2].v = currentPane->centerY - r.bottom;		p[0].h = p[1].h = r.left - currentPane->centerX-1;		p[2].h = p[3].h = r.right - currentPane->centerX;		SetMetaPort();		//JAM MERGE-GOURAUD-PRO		clip->DrawPoly(points, CLIP_FRAME|CLIP_FILL|CLIP_DITHER, NULL, FALSE, FALSE, &defaultColor, &vBlack, FALSE, NULL);		UnsetMetaPort();		MetaCopy(&r);		clip->dClip();    	points->dArray();   		VSetPattern(vPatBlack);		}#else	VForeColor(&defaultColor);	VPaintRect(&r);	#endif	VForeColor(&vBlack);	VMoveTo(r.right-7,r.top+2);	VLineTo(r.right-7,r.top+8);	VMoveTo(r.right-6,r.top+3);	VLineTo(r.right-6,r.top+7);	VMoveTo(r.right-5,r.top+4);	VLineTo(r.right-5,r.top+6);	VMoveTo(r.right-4,r.top+5);	VLineTo(r.right-4,r.top+5);	VFrameRect(&r);#if WINDOWS	VSetPen(&oldPen);	// jca 15FEB94 reset the old pen state#endif // WINDOWS	}		void ColorSelect::MouseDown(Point p,long modifiers)	{		if(modifiers&doubleClick)		controller->Request(NULL,msgEdit,objColor,0);	delayTime = VGetTime();	}voidColorSelect::TrackHelp(Point pt,long modifiers)// DAS-VWINDOW 9/30/93	{	Rect r;	r = dataRect;	BalloonHotRect(&r,pt);	Bubble(pt,&r,TXTB_COLORBAR);			}	void ColorSelect::Track(Point p,long modifiers,int lastCall)	{			if( (buttonDown&modifiers) && appDelayTime < abs(VGetTime()-delayTime) && lastCall)		{		RGBColor	tmpcolor = defaultColor;		Point		l;		Rect		avoid=paneRect;    // jca -- avoid this pane		l.h = avoid.left;             // jca -- put the rect in real space		l.v = avoid.top;		LocalToGlobal(&l);		VOffsetRect(&avoid, l.h, l.v);		l.h = dataRect.right+2;		l.v = 0;		if (popColor->Pop(l,&tmpcolor, &avoid))			{			defaultColor = tmpcolor;			VDisplay(DRAW);			controller->Request(NULL,msgEdit,objColor,0);			}		}	VSetCursor(vCursorArrow);	}	void ColorSelect::MouseUp(Point p,long modifiers)	{		if(modifiers&doubleClick)		controller->Request(NULL,msgEdit,objColor,0);	}	void ColorSelect::SetColor(RGBColor color)	{		defaultColor = color;	}void ColorSelect::Remember(RGBColor color)	{		popColor->Remember(&color);	}	RGBColor ColorSelect::GetColor()	{		return(defaultColor);	}	int ColorSelect::GetAction(long action,long modifiers)	{		if(MSG_COLOR == action) 		{ controller->Request(NULL,msgEdit,objColor,0); return(TRUE); }	return(FALSE);	}