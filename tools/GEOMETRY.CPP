/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				 *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "Geometry.h"#include "VGraphic.h"#include "VArray.h"#include "VMath.h"#include "VDisplay.h"#include "VGUtil.h"#include "SurfDef.h"#include "Surface.h"#include "Polyhdrn.h"#include <math.h>#include <limits.h>#include <stdlib.h>/*------------------------------------------------------------------------------ * int Intersect(Point p1,Point p2,Point q1,Point q2) * * Determine if segment line1 intersects segment line2. *------------------------------------------------------------------------------*/int Intersect(Point p1,Point p2,Point q1,Point q2){long dh1,dv1,dh2,dv2,dir1,dir2;dh1=p2.h-p1.h;dv1=p2.v-p1.v;dir1=(q1.h-p1.h)*dv1-(q1.v-p1.v)*dh1;dir2=(q2.h-p1.h)*dv1-(q2.v-p1.v)*dh1;if((dir1<0 && dir2<0) || (dir1>0 && dir2>0))return NO_INTERSECT;dh2=q2.h-q1.h;dv2=q2.v-q1.v;dir1=(p1.h-q1.h)*dv2-(p1.v-q1.v)*dh2;dir2=(p2.h-q1.h)*dv2-(p2.v-q1.v)*dh2;if((dir1<0 && dir2<0) || (dir1>0 && dir2>0))return NO_INTERSECT;if(dh1*dv2==dh2*dv1)/*are they colinear?*/	{	/*do they share an end-point?*/	if((p1.h==q1.h && p1.v==q1.v) || (p2.h==q2.h && p2.v==q2.v))		{		if(dh1==0)			{			dh1=dv1;			dh2=dv2;			}		if(dh1<0 && dh2<0)return END_INTERSECT;		if(dh1>0 && dh2>0)return END_INTERSECT;		return FALSE;		}	if((p1.h==q2.h && p1.v==q2.v) || (p2.h==q1.h && p2.v==q1.v))		{		if(dh1==0)			{			dh1=dv1;			dh2=dv2;			}		if(dh1<0 && dh2>0)return END_INTERSECT;		if(dh1>0 && dh2<0)return END_INTERSECT;		return NO_INTERSECT;		}		if(dh1==0)		{		p1.h=p1.v;		p2.h=p2.v;		q1.h=q1.v;		q2.h=q2.v;		}	if(p1.h<q1.h && q1.h<p2.h)return INTERSECT;	if(p1.h>q1.h && q1.h>p2.h)return INTERSECT;	if(p1.h<q2.h && q2.h<p2.h)return INTERSECT;	if(p1.h>q2.h && q2.h>p2.h)return INTERSECT;	if(q1.h<p1.h && p1.h<q2.h)return INTERSECT;	if(q1.h>p1.h && p1.h>q2.h)return INTERSECT;	return FALSE;	}/*are they intersecting at the endpoint?*/if(p1.h==q1.h && p1.v==q1.v)return END_INTERSECT;if(p1.h==q2.h && p1.v==q2.v)return END_INTERSECT;if(p2.h==q1.h && p2.v==q1.v)return END_INTERSECT;if(p2.h==q2.h && p2.v==q2.v)return END_INTERSECT;return INTERSECT;}/*------------------------------------------------------------------------------ * int FFIntersect(Point p1,Point p2,Point q1,Point q2) * * Determine if segment line1 intersects segment line2. * Fast Fixed point version. *------------------------------------------------------------------------------*/int FFIntersect(PointFFixed p1,PointFFixed p2,PointFFixed q1,PointFFixed q2){FFixed dh1,dv1,dh2,dv2,dir1,dir2;dh1=FFSub(p2.h,p1.h);dv1=FFSub(p2.v,p1.v);dir1=FFSub(FFMult(FFSub(q1.h,p1.h),dv1),FFMult(FFSub(q1.v,p1.v),dh1));dir2=FFSub(FFMult(FFSub(q2.h,p1.h),dv1),FFMult(FFSub(q2.v,p1.v),dh1));if((FFNegative(dir1) && FFNegative(dir2)) || 	(FFPositive(dir1) && FFPositive(dir2)))return NO_INTERSECT;dh2=FFSub(q2.h,q1.h);dv2=FFSub(q2.v,q1.v);dir1=FFSub(FFMult(FFSub(p1.h,q1.h),dv2),FFMult(FFSub(p1.v,q1.v),dh2));dir2=FFSub(FFMult(FFSub(p2.h,q1.h),dv2),FFMult(FFSub(p2.v,q1.v),dh2));if((FFNegative(dir1) && FFNegative(dir2)) || 	(FFPositive(dir1) && FFPositive(dir2)))return NO_INTERSECT;if(EQUL==FFLogic(FFMult(dh1,dv2),FFMult(dh2,dv1)))/*are they colinear?*/	{	/*do they share an end-point?*/	if((FFEqual(p1.h,q1.h) && FFEqual(p1.v,q1.v)) || 		(FFEqual(p2.h,q2.h) && FFEqual(p2.v,q2.v)))		{		if(FFZero(dh1))			{			dh1=dv1;			dh2=dv2;			}		if(FFNegative(dh1) && FFNegative(dh2))return END_INTERSECT;		if(FFPositive(dh1) && FFPositive(dh2))return END_INTERSECT;		return FALSE;		}	if((FFEqual(p1.h,q2.h) && FFEqual(p1.v,q2.v))		 || (FFEqual(p2.h,q1.h) && FFEqual(p2.v,q1.v)))		{		if(FFZero(dh1))			{			dh1=dv1;			dh2=dv2;			}		if(FFNegative(dh1) && FFPositive(dh2))return END_INTERSECT;		if(FFPositive(dh1) && FFNegative(dh2))return END_INTERSECT;		return NO_INTERSECT;		}		if(FFZero(dh1))		{		p1.h=p1.v;		p2.h=p2.v;		q1.h=q1.v;		q2.h=q2.v;		}	if(LESS==FFLogic(p1.h,q1.h) && LESS==FFLogic(q1.h,p2.h))return INTERSECT;	if(GRTR==FFLogic(p1.h,q1.h) && GRTR==FFLogic(q1.h,p2.h))return INTERSECT;	if(LESS==FFLogic(p1.h,q2.h) && LESS==FFLogic(q2.h,p2.h))return INTERSECT;	if(GRTR==FFLogic(p1.h,q2.h) && GRTR==FFLogic(q2.h,p2.h))return INTERSECT;	if(LESS==FFLogic(q1.h,p1.h) && LESS==FFLogic(p1.h,q2.h))return INTERSECT;	if(GRTR==FFLogic(q1.h,p1.h) && GRTR==FFLogic(p1.h,q2.h))return INTERSECT;	return FALSE;	}/*are they intersecting at the endpoint?*/if(FFEqual(p1.h,q1.h) && FFEqual(p1.v,q1.v))return END_INTERSECT;if(FFEqual(p1.h,q2.h) && FFEqual(p1.v,q2.v))return END_INTERSECT;if(FFEqual(p2.h,q1.h) && FFEqual(p2.v,q1.v))return END_INTERSECT;if(FFEqual(p2.h,q2.h) && FFEqual(p2.v,q2.v))return END_INTERSECT;return INTERSECT;}/*------------------------------------------------------------------------------ * int ClockwiseStrict(Point p0, Point p1, Point p2); * * Determine if the angle described by the three points is in the clockwise or * counter clockwise direction. * Checks if LINEAR is trying to backtrack (Overlap) and UNKNOWN's it. *------------------------------------------------------------------------------*/int ClockwiseStrict(Point p0, Point p1, Point p2){int dx, dz, dxp, dzp;int rval;long b1, b2;dx = p2.h - p1.h;dz = p2.v - p1.v;dxp = p0.h - p1.h;dzp = p0.v - p1.v;if(dx==0 && dz==0)rval= UNKNOWN;else if(dxp==0 && dzp==0)rval= UNKNOWN;else	{	b1=(long)dz*dxp;	b2=(long)dx*dzp;	if (b1 > b2) rval= CLOCKWISE;	else if (b1 < b2) rval= COUNTERCLOCKWISE;	else if(dx>0 && dxp>0)rval = UNKNOWN;		 else if (dx<0 && dxp<0)rval = UNKNOWN;		 else if (dz>0 && dzp>0)rval = UNKNOWN;		 else if (dz<0 && dzp<0)rval = UNKNOWN;		 else rval= LINEAR;	}return rval;}/*------------------------------------------------------------------------------ * int Clockwise(Point p0, Point p1, Point p2); * * Determine if the angle described by the three points is in the clockwise or * counter clockwise direction. *------------------------------------------------------------------------------*/int Clockwise(Point p0, Point p1, Point p2){int dx, dz, dxp, dzp;long b1, b2;int cx,cy;int val;extern long cc;Rect r;/*cc++;cx=currentPane->centerX;cy=currentPane->centerY;PenSize(3,3);VForeColor(&blueColor);VMoveTo(cx+p0.h,cy-p0.v);VLineTo(cx+p0.h,cy-p0.v);VForeColor(&greenColor);VMoveTo(cx+p1.h,cy-p1.v);VLineTo(cx+p1.h,cy-p1.v);VForeColor(&redColor);VMoveTo(cx+p2.h,cy-p2.v);VLineTo(cx+p2.h,cy-p2.v);PenSize(1,1);VMoveTo(cx+p0.h,cy-p0.v);VLineTo(cx+p1.h,cy-p1.v);VLineTo(cx+p2.h,cy-p2.v);VForeColor(&blackColor);VMoveTo(cx+p0.h,cy-p0.v);VLineTo(cx+p1.h,cy-p1.v);VForeColor(&whiteColor);VLineTo(cx+p2.h,cy-p2.v);PenSize(3,3);VForeColor(&whiteColor);VMoveTo(cx+p0.h,cy-p0.v);VLineTo(cx+p0.h,cy-p0.v);VMoveTo(cx+p1.h,cy-p1.v);VLineTo(cx+p1.h,cy-p1.v);VForeColor(&redColor);VMoveTo(cx+p2.h,cy-p2.v);VLineTo(cx+p2.h,cy-p2.v);PenSize(1,1);VForeColor(&blackColor);/**/MClockwise(val,p0,p1,p2);return val;}/*------------------------------------------------------------------------------ * int FFClockwise(Point p0, Point p1, Point p2); * * Determine if the angle described by the three points is in the clockwise or * counter clockwise direction. *------------------------------------------------------------------------------*/int FFClockwise(PointFFixed p0, PointFFixed p1, PointFFixed p2){FFixed dx, dz, dxp, dzp,fb1,fb2;long b1,b2;dx = FFSub(p2.h,p1.h);dz = FFSub(p2.v,p1.v);dxp = FFSub(p0.h,p1.h);dzp = FFSub(p0.v,p1.v);if(FFZero(dx) && FFZero(dz))return UNKNOWN;if(FFZero(dxp) && FFZero(dzp))return UNKNOWN;	fb1=FFMult(dz,dxp);b1=FFOverflow();fb2=FFMult(dx,dzp);b2=FFOverflow();if(b1>b2)return CLOCKWISE;if(b1<b2)return COUNTERCLOCKWISE;if(b1>0){fb1.intg=1; fb2.intg=1;}if(b1<0){fb1.intg=-1;fb2.intg=-1;}fb1=FFSub(fb1,fb2);if(FFPositive(fb1))return CLOCKWISE;else if(FFNegative(fb1))return COUNTERCLOCKWISE;else return LINEAR;}/*------------------------------------------------------------------------------ * int PolyClockwise(V_Array *pnts) * * Determine the direction of the (possibly non-convex) polygon. *------------------------------------------------------------------------------*/#define ascending(x,y,z) x<y?(y<z?TRUE:(z<x?TRUE:FALSE)):(y<z && z<x)?TRUE:FALSEint PolyClockwise(V_Array *pnts){PointFFixed *p;int index3[4];long i,length;int top,left,bottom,right;int cw,count=0;V_Array *points;points=new(V_Array);points->cArray(0,sizeof(Point),8);pnts->CopyArray(points);redo:p=(PointFFixed *)points->Use();length=points->ALength();top=left=bottom=right=0;/*---------------take care of the simple cases first*/if(length<3)return -1;if(length==3)	{	cw=FFClockwise(p[0],p[1],p[2]);	points->Unuse();	points->dArray();	return cw;	}/*-------------------find the minimax*/for(i=1;i<length;i++)	{	if(LESS==FFLogic(p[i].v,p[top].v))top=i;	if(GRTR==FFLogic(p[i].v,p[bottom].v))bottom=i;	if(LESS==FFLogic(p[i].h,p[left].h))left=i;	if(GRTR==FFLogic(p[i].h,p[right].h))right=i;	}/*----------------oops, only found two useful points, need to remove one  ----------------and try again!*/if((top==left && bottom==right) || (top==right && bottom==left))	{	points->Unuse();	points->Remove(top);	goto redo;	}/*-----------------we have at least three points on the Rect*/index3[count]=left;if(index3[count]!=top)	{	count++;	index3[count]=top;	}if(index3[count]!=right)	{	count++;	index3[count]=right;	}if(index3[count]!=bottom)	{	count++;	index3[count]=bottom;	}cw=ascending(index3[2],index3[1],index3[0]);points->Unuse();points->dArray();return cw;}/*------------------------------------------------------------------------------ * int PtOnLine(Point p,Point line0,Point line1) * * Determine if Point is on the line. *------------------------------------------------------------------------------*/#define SENSITIVITY 5int PtOnLine(Point p,Point line0,Point line1){long d;long dx,dy;if(((p.h<=line0.h+3 && p.h>=line1.h-3)||	(p.h>=line0.h-3 && p.h<=line1.h+3))&&   ((p.v<=line0.v+3 && p.v>=line1.v-3)||   	(p.v>=line0.v-3 && p.v<=line1.v+3)))   	{	dx=line0.h-line1.h;	dy=line0.v-line1.v;	if((p.h<line0.h && p.h<line1.h)||(p.h>line0.h && p.h>line1.h))		{		if(dy!=0)			{			d=p.h-(line0.h-(line0.v-p.v)*dx/dy);			if(SENSITIVITY>=abs(d))return TRUE;			}		}	else		{		if(dx!=0)			{			d=p.v-(line0.v - (line0.h-p.h)*dy/dx);			if(SENSITIVITY>=abs(d))return TRUE;			}		if((p.v>=line0.v && p.v<=line1.v) || (p.v>=line1.v && p.v<=line0.v))			if(dy!=0)				{				d=p.h- (line0.h-(line0.v-p.v)*dx/dy);				if(SENSITIVITY>=abs(d))return TRUE;				}		}	}return FALSE;}int LPtOnLine(PointLong t, PointLong p, PointLong q){long dx,dy,dtpx,dtpy;long r;if(((t.h<=p.h+3 && t.h>=q.h-3)||	(t.h>=p.h-3 && t.h<=q.h+3))&&   ((t.v<=p.v+3 && t.v>=q.v-3)||   	(t.v>=p.v-3 && t.v<=q.v+3)))   		{   		dx=q.h-p.h;   		dy=q.v-p.v;   		dtpx=t.h-p.h;   		dtpy=t.v-p.v;   		/*we can assume at this point that the largest values are dx and dy   		since we have proven (above) that the test point is somewhere inside   		the rectangle defined by these points thus if any numbers are too large   		we can fix it with this:*/   		while(abs(dx)>0x0FF)   			{ 			dx>>=1; dy>>=1; dtpx>>=1; dtpy>>=1; 			}    	while(abs(dy)>0x0FF)   			{ 			dx>>=1; dy>>=1; dtpx>>=1; dtpy>>=1; 			} 		r=dy*dtpx-dtpy*dx; 		if(r>=(abs(dx)+abs(dy)))return FALSE; 		return TRUE;  		} return FALSE;}/*------------------------------------------------------------------------------ * int ExactPtOnLine(Point p,Point line0,Point line1) * * Determine if Point is on the line. * if point is beyond the line it returns the nearest end *------------------------------------------------------------------------------*/PointExactPtOnLine(Point p,Point line0,Point line1){double 	A,B,C1,C2,x,y,tmp;Point	np;if(0 == (B = line0.h - line1.h))	/* its vertical */	{ np.h = line0.h; np.v = p.v; }	else		{		if(0 == (A = line1.v - line0.v)) /* its horizontal */			{ np.h = p.h; np.v = line0.v; }		else			{			C1 = (double)line0.v*line1.h - (double)line1.v*line0.h;			C2 = A * p.v - B *p.h;			tmp = (B*B + A*A);						np.h = (-C1*A - C2*B) / tmp;			np.v = (C2*A - C1*B) / tmp;			}		}return(np);}PointFFixed	FFPtToLine(PointFFixed loc,PointFFixed pt1,PointFFixed pt2)	{	double 	x,y,theta,h1,h2,v1,v2,lh,lv,A,B,C1,C2,tmp,dx,dy;	PointFFixed	np;			lh = FixedToDbl(loc.h);	lv = FixedToDbl(loc.v);	h1 = FixedToDbl(pt1.h);	v1 = FixedToDbl(pt1.v);	h2 = FixedToDbl(pt2.h);	v2 = FixedToDbl(pt2.v);								if(0 == (B = h1 - h2))	/* its vertical */		{		dx = h1 - lh;		dy = 0;		}	else		{		if(0 == (A = v2 - v1)) /* its horizontal */			{			dx = 0;			dy = v1 - lv;			}		else			{			C1 = v1*h2 - v2*h1;			C2 = A * lv - B *lh;			tmp = (B*B + A*A);						dx = (-C1*A - C2*B) / tmp;			dy = (C2*A - C1*B) / tmp;						dx = dx - lh;			dy = dy - lv;			}		}			np.h = DblToFixed(dx);	np.v = DblToFixed(dy);		return(np);	}/*------------------------------------------------------------------------------ * int PointConvex(Point l1, Point l2,Point r1,Point r2, Point p) * * This determines if the new point p will maintain the convexity of the * polyhedron. * New points are appended to l1..l2 line. * *								. *							   . . * 							  .   . *							 .	   . *							.		. *						   .    p    . *						  .           . *						 . 			   . *						l2..............r2 *					   /				 \ *					  /					  \ *					 /					   \ *					/						\ *				   /						 \ *				  l1						  r1 *------------------------------------------------------------------------------*/int PointConvex(Point l1, Point l2,Point r1,Point r2, Point p){int c0,c1,c2,c3,c4;c0=ClockwiseStrict(l1,l2,r2);		// determine direction of original polyc1=ClockwiseStrict(l1,l2,p);c2=ClockwiseStrict(l2,p,r2);c3=ClockwiseStrict(p,r2,r1);#if 0 // oldc1=Clockwise(p,l1,l2);c2=Clockwise(p,r2,l2);c3=Clockwise(p,r2,r1);#endifif (c0==CLOCKWISE || c0==LINEAR)	{	if( (c1==CLOCKWISE || c1==LINEAR) &&		(c2==CLOCKWISE || c2==LINEAR) &&		(c3==CLOCKWISE || c3==LINEAR)) return TRUE;	else return FALSE;	}elseif (c0==COUNTERCLOCKWISE)	{	if( (c1==COUNTERCLOCKWISE || c1==LINEAR) &&		(c2==COUNTERCLOCKWISE || c2==LINEAR) &&		(c3==COUNTERCLOCKWISE || c3==LINEAR)) return TRUE;	else return FALSE;	}else	{ // l and r are colinear facing opposite directions	  // so allow new point to append to l anywhere but backwards	if (c1!=UNKNOWN) return TRUE;	else	return FALSE;	}}// BILBIL 3/23/94 -  multiple connectionsvoidFast2DFromConnection(Connection *conn, V_Array *list, short *plane)	{	PointFFixed		p;	Point3DFFixed	*surfPt;	short 			*index;	long			length, i;	Point3D			norm;		if ((*plane) == 0)		{		// find normal so we know where to project onto		norm.x = abs(conn->surf->surface->posnNormal.x);		norm.y = abs(conn->surf->surface->posnNormal.y);		norm.z = abs(conn->surf->surface->posnNormal.z);				if( norm.x >= norm.y && norm.x >= norm.z )			{ *plane = INFL_X; }		else if( norm.y >= norm.x && norm.y >= norm.z )			{ *plane = INFL_Y; }		else 			{ *plane = INFL_Z; }		}	length = conn->surf->surface->points->ALength();	index = (short*)(conn->surf->surface->points->Use());	surfPt = (Point3DFFixed*)(conn->poly->posnPoints->Use());		for (i = 0; i < length; i++,index++)		{		switch(*plane)			{			case INFL_X:				p.h.l = surfPt[*index].y.l;				p.v.l = surfPt[*index].z.l;					break;						case INFL_Y:				p.h.l = surfPt[*index].z.l;				p.v.l = surfPt[*index].x.l;					break;						case INFL_Z:				p.h.l = surfPt[*index].x.l;				p.v.l = surfPt[*index].y.l;					break;			}		list->Append(&p);		}	conn->surf->surface->points->Unuse();	conn->poly->posnPoints->Unuse();	}