/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	 *				David W. Easter *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "Format.h"#include "WTypes.h"#include "VMath.h"#include "AppText.h"#include "VMemUtil.h"#include <stdio.h>#include <string.h>/* Symbols for units; must match unitType enum */const char *unitSymbol[] =	{	TXTC_SINCH,		/* inch */	TXTC_SFOOT,		/* foot */	TXTC_SYARD,		/* yard */	TXTC_SMILE,		/* mile */	TXTC_SPOINT,	/* point */	TXTC_SPICA,		/* pica */	TXTC_SCMET,		/* centimeter */	TXTC_SMETER,	/* meter */	TXTC_SANGSTROM,	/* angstrom */	TXTC_SPARSEC,	/* parsec */	TXTC_SDEGREE,	/* degree */	TXTC_SRADIAN,	/* radian */	TXTC_SCUSTOM 	/* custom--unused; actual symbol in 'customSymbol' field */	};/* Unit categories */const int englishMin = inch;const int englishMax = mile;const int layoutMin = point;const int layoutMax = pica;/* Engineering prefixes */#if MACINTOSHconst char prefixArray[] = { 'p', 'n', '\xB5', 'm', ' ', 'k', 'M', 'G', 'T' };#elif WINDOWSconst char prefixArray[] = { 'p', 'n', '\xB5', 'm', ' ', 'k', 'M', 'G', 'T' };#endifconst char *unitPrefix = prefixArray + 4;voidFormatter::cFormat()	{	SetType(meter);	SetPromotion(TRUE);	SetMagnitude(0);	SetScale(FFOne);	SetOrigin(FFZero);	SetCustom("");	}voidFormatter::dFormat()	{	delete(this);	}voidFormatter::Copy(Formatter *from)	{	char c[sizeof(custSym)];	SetType(from->GetType());	SetPromotion(from->GetPromotion());	SetMagnitude(from->GetMagnitude());	SetScale(from->GetScale());	SetOrigin(from->GetOrigin());	from->GetCustom(c, sizeof(c));	SetCustom(c);	}void Formatter::SetType(unitType t) { type = t; }void Formatter::SetPromotion(int p) { promote = p; }void Formatter::SetMagnitude(short m) { magnitude = m; }void Formatter::SetScale(FFixed s) { scale = s; }void Formatter::SetOrigin(FFixed o) { origin = o; }unitType Formatter::GetType() { return(type); }int Formatter::GetPromotion() { return(promote); }short Formatter::GetMagnitude() { return(magnitude); }FFixed Formatter::GetScale() { return(scale); }FFixed Formatter::GetOrigin() { return(origin); }voidFormatter::SetCustom(char *c)	{	int n = sizeof(custSym);	ObjLock((ObjectHandle)this);	strncpy(custSym, c, n);	custSym[n-1] = '\0';	ObjUnlock((ObjectHandle)this);	}voidFormatter::GetCustom(char *c, int n)	{	ObjLock((ObjectHandle)this);	strncpy(c, custSym, n);	c[n-1] = '\0';	ObjUnlock((ObjectHandle)this);	}voidFormatter::Format(FFixed num, char *string)	{	long numInt;	ULong numFrac;	FFixed offset, absScale;	int negative = FALSE;	int tp, mag, shift, m, i;	int decimal, layout, english, scalable;	char *ptr = string, *p;	offset = FFNeg(origin);	numInt = (long)num.intg + offset.intg;	numFrac = (long)num.frac + offset.frac;	numInt += numFrac >> 16;	numFrac &= 0xFFFF;	if (numInt < 0)		{		if (numFrac != 0)			{			numInt = ~numInt;			numFrac = ~numFrac + 1;			numFrac &= 0xFFFF;			}		else numInt = -numInt;		negative = !negative;		}	if (FFNegative(scale))		{		absScale = FFNeg(scale);		negative = !negative;		}	else absScale = scale;	if (absScale.frac == 0)		{		if (absScale.intg != 1)			{			ULong top, middle;				top = numInt * absScale.intg;			middle = numFrac * absScale.intg;			numInt = top + (middle >> 16);			numFrac = middle & 0xFFFF;			}		}	else		{		ULong top, middle1, middle2, bottom;		ULong temp1, temp2;		top = numInt * absScale.intg;		middle1 = numInt * absScale.frac;		middle2 = numFrac * absScale.intg;		bottom = numFrac * absScale.frac;		temp1 = (top & 0xFFFF) + (middle1 >> 16) + (middle2 >> 16);		temp2 = (middle1 & 0xFFFF) + (middle2 & 0xFFFF) + (bottom >> 16);		temp1 += temp2 >> 16;		temp2 &= 0xFFFF;		numInt = (top & 0xFFFF0000) + temp1;		numFrac = temp2;		}	*ptr++ = (negative ? '-' : ' ');	decimal = (type >= meter || type == centimeter);	scalable = (type >= meter);	english = (type >= englishMin && type <= englishMax);	layout = (type >= layoutMin && type <= layoutMax);	tp = type;	mag = scalable ? magnitude : 0;	if (decimal || !promote)		{		char *fieldStart = ptr;		int len, i, m;		if (promote && tp == centimeter && (numInt == 0 || numInt >= 100))			{			numInt *= 10;			numFrac *= 10;				numInt += numFrac >> 16;			numFrac &= 0xFFFF;				tp = meter;			mag = -1;			scalable = TRUE;			}		if (promote && scalable && numInt == 0 && numFrac != 0)			{			while (numInt == 0)				{				numInt *= 1000;				numFrac *= 1000;					numInt += numFrac >> 16;				numFrac &= 0xFFFF;					mag--;				}			}		sprintf(ptr, "%ld", numInt);		len = strlen(ptr);		ptr += len;		if (promote)			{			m = (len-1) / 3;			mag += m;			shift = m * 3;			}		else shift = 0;		for (p = ptr, i = shift; i > 0; p--, i--) *p = *(p-1);		*p = '.';		ptr++;		if (shift < 4)			{			for (i = 4 - shift; i > 0; i--)				{				numFrac *= 10;				*ptr++ = '0' + (numFrac >> 16);				numFrac &= 0xFFFF;				}			}		else ptr -= (shift - 4);		if (*(ptr-1) == '9')			{			for (p = ptr-1; p >= fieldStart; p--)				{				if (*p == '.') continue;				if (*p == '9') *p = '0';				else { (*p)++; break; }				if (p == fieldStart)					{					memmove(p+1, p, ptr-p);					*p = '1';					ptr++;					break;					}				}			}		ptr--;		while (*ptr == '0') ptr--;		if (*ptr == '.') ptr--;		ptr++;		if (!promote || *(string+1) != '0')			{			ObjLock((ObjectHandle)this);			if (mag != 0)				*ptr++ = unitPrefix[mag];			strcpy(ptr, (tp == custom ? custSym : unitSymbol[tp]));			ObjUnlock((ObjectHandle)this);			}		else *ptr = '\0';		}	else if (layout)		{		long pointNumInt = -1;		char *numStart = ptr, *fieldStart;		if (tp == point && numInt >= 6)			{			pointNumInt = numInt;			numInt /= 6;			pointNumInt -= numInt * 6;			tp = pica;			}		while (TRUE)			{			fieldStart = ptr;			if (numInt != 0)				{				sprintf(ptr, "%ld", numInt);				ptr += strlen(ptr);				}			if (tp == point)				{				int i;				if (numInt == 0) *ptr++ = '0';				*ptr++ = '.';				for (i = 0; i < 4; i++)					{					numFrac *= 10;					*ptr++ = '0' + (numFrac >> 16);					numFrac &= 0xFFFF;					}				if (*(ptr-1) == '9')					{					for (p = ptr-1; p >= fieldStart; p--)						{						if (*p == '.') continue;								if (*p == '9') *p = '0';						else { (*p)++; break; }								if (p == fieldStart)							{							memmove(p+1, p, ptr-p);							*p = '1';							ptr++;							break;							}						}					}				ptr--;				while (*ptr == '0') ptr--;				if (*ptr == '.')					{					ptr--;					if (numInt == 0) ptr--;					}				ptr++;				}			if (ptr != fieldStart)				{				strcpy(ptr, unitSymbol[tp]);				ptr += strlen(ptr);				}			else *ptr = '\0';			if (tp == pica)				{				if (pointNumInt < 0)					{					numFrac *= 6;					numInt = numFrac >> 16;					numFrac &= 0xFFFF;					}				else numInt = pointNumInt;				tp = point;				}			else break;			}		if (ptr == numStart)			{			*ptr++ = '0';			*ptr = '\0';			}		}	else if (english)		{		long inchNumInt = -1;		char *numStart = ptr, *fieldStart;		int space = FALSE;		if (tp == inch && numInt >= 12)			{			inchNumInt = numInt;			numInt /= 12;			inchNumInt -= numInt * 12;			tp = foot;			}		while (TRUE)			{			fieldStart = ptr;			if (numInt != 0)				{				if (space) *ptr++ = ' ';				space = FALSE;				sprintf(ptr, "%ld", numInt);				ptr += strlen(ptr);				}			if (tp == inch)				{				int n, d, i;				if (numFrac != 0 && (numFrac & 0x07FF) == 0)					{					if (space || numInt != 0) *ptr++ = ' ';					n = (numFrac & 0xF800) >> 11;					d = 32;					while ((n & 1) == 0) { n >>= 1; d >>= 1; }					sprintf(ptr, "%d/%d", n, d);					ptr += strlen(ptr);					}				else					{					if (space) *ptr++ = ' ';					if (numInt == 0) *ptr++ = '0';					*ptr++ = '.';					for (i = 0; i < 4; i++)						{						numFrac *= 10;						*ptr++ = '0' + (numFrac >> 16);						numFrac &= 0xFFFF;						}					if (*(ptr-1) == '9')						{						for (p = ptr-1; p >= fieldStart; p--)							{							if (*p == '.') continue;										if (*p == '9') *p = '0';							else { (*p)++; break; }										if (p == fieldStart)								{								memmove(p+1, p, ptr-p);								*p = '1';								ptr++;								break;								}							}						}					ptr--;					while (*ptr == '0') ptr--;					if (*ptr == '.')						{						ptr--;						if (numInt == 0)							{							ptr--;							if (space) ptr--;							}						}					ptr++;					}				}			if (ptr != fieldStart)				{				strcpy(ptr, unitSymbol[tp]);				ptr += strlen(ptr);				space = TRUE;				}			else *ptr = '\0';			if (tp == mile)				{				numFrac *= 5280;				numInt = numFrac >> 16;				numFrac &= 0xFFFF;				tp = foot;				}			else if (tp == yard)				{				numFrac *= 36;				numInt = numFrac >> 16;				numFrac &= 0xFFFF;				tp = inch;				}			else if (tp == foot)				{				if (inchNumInt < 0)					{					numFrac *= 12;					numInt = numFrac >> 16;					numFrac &= 0xFFFF;					}				else numInt = inchNumInt;				tp = inch;				space = FALSE;				}			else break;			}		if (ptr == numStart)			{			*ptr++ = '0';			*ptr = '\0';			}		}	else *ptr = '\0';	}