/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "List.h"#include "AppText.h"#include "VGraphic.h"#include "VGUtil.h"#include <stdio.h>#include <string.h>void List::cPane(int flag)	{	theList = new(V_Array);		theList->cArray(0,sizeof(ListItem **),16);		selection = 0;	firstVisible = 0;	lastVisible = 0;		V_Pane::cPane(VERTSCROLLBAR);			SetVPage(5);	SetVMove(1);				}	void List::dPane()	{	dList();	theList->dArray();		V_Pane::dPane();	}void List::dList()	{	ListItem **aListItem;	int	length,i;		length = theList->ALength();	aListItem = (ListItem **)theList->Use();	for(i = 0; i < length; i++,aListItem++)		(*aListItem)->dListItem();	theList->Unuse();	}		int List::SetSelection(int who)	{	ListItem *theItem;	int	length;		length = theList->ALength() - 1;		if(0 > length) return(length);		if(selection>=0 && selection<=length)		{		theList->Get(selection,&theItem);		if(theItem)theItem->SetHilite(FALSE);		}	if(who > length) who = length;/* dude	if(who<0)who=0;*/	selection = who;	if(0 <= selection && length >= selection )		{		theList->Get(selection,&theItem);		theItem->SetHilite(TRUE);		}	return(selection);	}voidList::Display(int type,int x,int y)	{	ListItem	**aListItem;	Rect r;	int	 top;	VPenMode(vPatCopy);	VSetPattern(vPatBlack);		r = dataRect;		switch(type)		{		case DEACT_DRAW:				case DEACT_REDRAW:		case DEACT_REBUILD_DRAW:		case	ACT_REBUILD_DRAW:			case	ACT_DRAW:			case	DRAW:					case 	ACT_REDRAW:						VEraseRect(&r);			DrawContent(y,type);			break;		case	SCROLL_DRAW:			if(y>lastVisible)				type = DRAW;			r.bottom = r.bottom - leftOver - 1;			top = (firstVisible-y) * GetHeight();							#if MACINTOSH			{			RgnHandle	updateRgn;			updateRgn = NewRgn();			ScrollRect(&r,0,top,updateRgn);			SetClip(updateRgn);			DisposeRgn(updateRgn);            }			r = dataRect;#elif WINDOWS			ScrollWindow(paneWindow,0,top,&r,NULL);			if(top>=0)r.top=r.bottom+top;			else r.bottom=r.top+top;#endif //WINDOWS			VEraseRect(&r);			DrawContent(y,type);			break;		}	}			void List::DrawContent(int y,int type)	{	ListItem	**aListItem;	Rect		r;	int			i,length,height,bottom,dy,offset;	int			hl=-1;	int         fv,lv;		// ABD MERGE10 WILLIAMS 9/9/93		if(!(length = theList->ALength())) return;	height = GetHeight();	bottom = dataRect.bottom - 1;	aListItem = (ListItem **)theList->Use();	dy = firstVisible - y;		switch(type)		{		case SCROLL_DRAW:// ABD MERGE10 WILLIAMS 9/9/93 [[[			fv=y;			lv=fv + .5 + (dataRect.bottom - dataRect.top) / (double)GetHeight();			if(lv>=length)lv=length-1;			if(fv<0)fv=0;            #if 0 // PRO-12			if(dy > 0)      /* pane is moving down*/			    {			    for(i=0;i<fv;i++)			        aListItem[i]->location = -32000;			    }			else            /* pane is moving up */			    {			    for(i=lv+1;i<length;i++)			        aListItem[i]->location = -32000;				}			#endif // 0 PRO-12			for(i=0;i<length;i++)		// MERGE-GOURAUD-PRO-12		        aListItem[i]->location = -32000;		// MERGE-GOURAUD-PRO-12			offset=0;			for(i=fv;i<=lv;i++)			    {			    offset+=height;			    aListItem[i]->location=offset;			    aListItem[i]->Display();			    if(aListItem[i]->GetState())hl=i;			    }			    if(hl!=-1)aListItem[hl]->Hilite(TRUE);			firstVisible=fv;			lastVisible=lv;// ABD MERGE10 WILLIAMS 9/9/93 ]]]			break;					default:			r = dataRect;					firstVisible = y;			lastVisible = firstVisible + (r.bottom - r.top) / GetHeight();						/* guarantees the list will try to fit 			as much as the list as it can into the pane */									if(1 > (offset = length - lastVisible))				{				if(0>(firstVisible + offset))					offset = firstVisible;									firstVisible += offset;				lastVisible += offset;								if(lastVisible > length - 1)					lastVisible = length - 1;				}		    for(i=0;i<length;i++)		// MERGE-GOURAUD-PRO-12		        aListItem[i]->location = -32000;		// MERGE-GOURAUD-PRO-12							offset = 0;						for(i = firstVisible; i <= lastVisible; i++)				{				offset+=height;								aListItem[i]->location = offset;							aListItem[i]->Display();							if(aListItem[i]->GetState())hl=i;			/* dude - not necessary */				}			if(hl!=-1)aListItem[hl]->Hilite(TRUE);		/* dude - I think		*/						if(i)				leftOver = bottom-aListItem[i - 1]->location;			break;		}					theList->Unuse();	}	void List::MouseDown(Point p,long modifier)	{	ListItem	**aListItem;	int			oldselection;		if(!theList->ALength())return;		oldselection = selection;			Select(p);		if(oldselection != selection && oldselection!=-1)		{		aListItem = (ListItem **)theList->Use();				aListItem[ oldselection ]->Hilite(FALSE);					aListItem[ selection ]->Hilite(TRUE);				theList->Unuse();		}		if(modifier & doubleClick)		{		aListItem = (ListItem **)theList->Use();				aListItem[ selection ]->Action(p,modifier);				theList->Unuse();		}	}		void List::MouseUp(Point p,long modifier)	{	}int List::KeyAction(char ch,long modifier)	{	ListItem	*item;	Point	p;		p.h=p.v=0;	switch(ch)		{		case V_UPARROW:/* Up arrow */			if(selection > 0 && modifier&V_OPTION)				{				if(V_SHIFT&modifier)SetSelection(0);				else SetSelection(selection-1);				VDisplay(DRAW);				item = GetCurrentItem();				item->Action(p,modifier);				}			else				return(FALSE);			break;				case V_DOWNARROW:/* Down arrow */			if(selection < (theList->ALength()-1) && modifier&V_OPTION)				{				if(V_SHIFT&modifier)SetSelection(theList->ALength()-1);				else SetSelection(selection+1);				VDisplay(DRAW);				item = GetCurrentItem();				item->Action(p,modifier);				}			else				return(FALSE);			break;		default:			return(FALSE);			break;		}	return(TRUE);	}void List::Update(Point p,long modifier)	{	Rect r;	ListItem	**aListItem;	int			length,oldselection,i;	if(!(length = theList->ALength())) return;	oldselection = selection;		r = dataRect;	if(!VPtInRect(p,&r))		{				if(p.v > dataRect.bottom && selection < (length - 1) && lastVisible < length)			{			Push(0,-1);			SetPane();			selection = lastVisible;			}		else 			if(p.v < dataRect.top && firstVisible)				{				Push(0,1);				SetPane();				selection = firstVisible;				}		}			else		Select(p);		if(oldselection != selection)		{		aListItem = (ListItem **)theList->Use();				if(oldselection!=-1)aListItem[ oldselection ]->Hilite(FALSE);					aListItem[ selection ]->Hilite(TRUE);				theList->Unuse();		}	}/*========================================================================= * int List::GetNumRows() * ABD added this routine to separate the concept of list length and number * of rows displayed in list *-------------------------------------------------------------------------*/int List::GetNumRows()		// ABD WILLIAMS 8/11/93	{		if (theList)		{			return theList->ALength();		}		else			return 0;	}void List::CalcScroll()	{	int	numItemsScroll;		// ABD changed theList->ALength() to GetNumRows to handle lists where the	// number of rows is not equal to the length (i.e. 2D lists) 8/11/93		numItemsScroll = GetNumRows() - (dataRect.bottom / GetHeight());	// ABD 	if(numItemsScroll < 0)		numItemsScroll = 0;			scrollRect = virtRect;	scrollRect.bottom = numItemsScroll;	}void List::Track(Point p,long modifier,int lastCall)	{	if((modifier & buttonDown))		Update(p,modifier);		VSetCursor(vCursorArrow);	}	void List::GetVirtual(Rect *r)	{	r->top = r->left = r->right = 0;	if(!(r->bottom = theList->ALength()))		r->bottom = 1;	}void List::MoveListItem(int from,int to)	{	ListItem	*aListItem;		theList->Get(from,&aListItem);		theList->Remove(from);		theList->Insert(to,&aListItem);	}	void List::Select(Point p)	{		int	height,length;		height = GetHeight();		if(0 > (selection = firstVisible + p.v/ height)) selection = 0;	else		if(selection >= (length = theList->ALength())) 	selection = length-1;	}	int List::GetHeight()	{	return(LIST_MAGIC_HEIGHT);	}	void List::Hilite(int who)	{	ListItem *theItem;	int	length;	SetPane();		length = theList->ALength() - 1;		if(0 > length) return;		if(selection>=0 && selection<=length)		{		theList->Get(selection,&theItem);		if(theItem)theItem->Hilite(FALSE);		}	if(who > length) who = length;	selection = who;	if(0 <= selection && length >= selection )		{		theList->Get(selection,&theItem);		theItem->Hilite(TRUE);		}	UnsetPane();	}	void List::ListHilite(int hiliteState)	{	ListItem **aListItem;	int	i,length;			length = theList->ALength();		aListItem = (ListItem **)theList->Use();		for(i = 0; i < length; i++)		{		if(hiliteState != aListItem[ i ]->GetState())			aListItem[ i ]->Hilite(hiliteState);		}			theList->Unuse();	}ListItem *						// ABD changed return type to ListItem* from EditItem*List::GetCurrentItem()	{	EditItem *item;	if((theList->ALength() <= selection) || (0 > selection)) return(NULL);	theList->Get(selection,&item);	return(item);	}intList::RemoveCurrentItem()	{	ListItem *item;			// ABD changed from EditItem* to ListItem*	if(item = GetCurrentItem())		{		theList->Remove(selection);		item->dListItem();		SetSelection(--selection);		return(TRUE);		}	return(FALSE);	}void LayerList::MouseDown(Point p,long modifier)	{	ListItem	*aListItem;	int			tempSelection;	//BILBIL - 10/21/94 - don't use unsigned short here!		if(!theList->ALength())return;	lastPt = p;		tempSelection = selection;				Select(p);		if(tempSelection != selection &&tempSelection!=-1)		{		theList->Get(tempSelection,&aListItem);			if(aListItem->GetState())				aListItem->Hilite(FALSE);		}				theList->Get(selection,&aListItem);		aListItem->Hilite(TRUE);		if(modifier & doubleClick)		aListItem->Action(p,modifier);	else		{				ghostRect = dataRect;		aListItem->GetRect(&ghostRect);				adjust = p.v-ghostRect.top;				dragging = FALSE;		}	}void LayerList::Draggable(int newDragState)	{	dragState = newDragState;	}	void LayerList::CleanGhost()	{#if MACINTOSH		VPenMode(vPatXor);		VSetPattern(vPatGray);#elif WINDOWS		VPenMode(vMarqueeMove);#endif	VFrameRect(&ghostRect);				VPenMode(vPatCopy);	VSetPattern(vPatBlack);	}	void LayerList::Update(Point p,long modifier)	{	Rect	r;	int		length,swap;	if(!(length = theList->ALength())) return;		if(dragging)		{#if MACINTOSH		VPenMode(vPatXor);		VSetPattern(vPatGray);#elif WINDOWS		VPenMode(vMarqueeMove);#endif		r = dataRect;				if(!VPtInRect(p,&r))			{			VFrameRect(&ghostRect);					if(ghostRect.bottom > ghostRect.top)				{				swap = ghostRect.bottom;				ghostRect.bottom = ghostRect.top;				ghostRect.top = swap;				}						VPenMode(vPatCopy);			VSetPattern(vPatBlack);					if(p.v > dataRect.bottom&&selection < length && lastVisible < length)				Push(0,-1);			else 				if(p.v < dataRect.top && firstVisible)					Push(0,1);							return;			}			if(ghostRect.bottom < ghostRect.top)			{			swap = ghostRect.bottom;					ghostRect.bottom = ghostRect.top;			ghostRect.top = swap;					VFrameRect(&ghostRect);			}			if((p.v-adjust) != ghostRect.top)			{			VFrameRect(&ghostRect);					ghostRect.top = p.v-adjust;			ghostRect.bottom = ghostRect.top + GetHeight();					VFrameRect(&ghostRect);					}		VPenMode(vPatCopy);		VSetPattern(vPatBlack);		}	else		{		if(dragState)			if((p.v < ghostRect.top || p.v > ghostRect.bottom)				|| (p.v != lastPt.v || p.h != lastPt.h))				{ CleanGhost(); dragging = TRUE; }		}	}	void LayerList::MouseUp(Point p,long modifier)	{	ListItem	*aListItem;	int			tempSelection,swap;		if(!theList->ALength())return;		theList->Get(selection,&aListItem);		if(dragging)		{#if MACINTOSH		VPenMode(vPatXor);		VSetPattern(vPatGray);#elif WINDOWS		VPenMode(vMarqueeMove);#endif		VFrameRect(&ghostRect);			swap = ghostRect.top;		ghostRect.top = ghostRect.bottom;		ghostRect.bottom = swap;			swap = ghostRect.left; 		ghostRect.left = ghostRect.right;		ghostRect.right = swap;						VPenMode(vPatCopy);		VSetPattern(vPatBlack);		}			aListItem->Action(p,modifier);		if(dragging)		{		tempSelection = selection;		Select(p);			if(tempSelection != selection)			{			MoveListItem(tempSelection,selection);			VDisplay(DRAW);			}		}			dragging = FALSE;	}	void ListItem::Hilite(int hiliteState)	{	Rect	r;		hilited = hiliteState;		r.left = 0;	r.right = 500; /* dude */	GetRect(&r);	VEraseRect(&r);		Display();	#if !SPECIAL_EDITION         	// merge SE, vrmadness		// GJR 7/4/95	if(hilited)		{		VPenMode(vPatXor);			VPaintRect(&r);			VPenMode(vPatCopy);		}#endif //!SPECIAL_EDITION		// merge SE, vrmadness		// GJR 7/4/95	}	void ListItem::SetHilite(int hiliteState)	{	hilited = hiliteState;	}int ListItem::GetState(void)	{	return(hilited);	}	void ListItem::Display(void){}voidListItem::Action(Point p,long modifier){}// ABD WILLIAMS 8/10/93#if VRvoid ListItem::SetListPane(struct List *lp) { list_pane = lp;}#endif //VRint ListItem::GetHeight(void){ return(LIST_MAGIC_HEIGHT);}void ListItem::GetRect(Rect *r)	{	r->left = 0;	r->top = location - GetHeight();		// ABD WILLIAMS bug fix -- use real height instead											// ABD of hard-coded height	r->bottom = location;	}void ListItem::dListItem(void)	{	delete(this);	}void	EditItem::SetState(int  newState)	{	state = newState;	}