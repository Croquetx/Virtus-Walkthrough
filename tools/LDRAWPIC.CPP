/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				 *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "LDrawPic.h"#include "Clip.h"#include "WTypes.h"#include "Geometry.h"#include "VGraphic.h"#include "Misc.h"#include "VDisplay.h"#include "VGUtil.h"#include "VDisplay.h"#include "VPane.h"#include <stdlib.h>double scaleX,scaleY;long scaleXNumer,scaleXDenom,scaleYNumer,scaleYDenom;long offsetX,offsetY;PointLong lPenLoc;#if MACINTOSHpascal void LongTextProc(short byteCount, Ptr textBuf, Point numer, Point denom);pascal void LongTextProc(short byteCount, Ptr textBuf, Point numer, Point denom){int width;long lwidth,ascent,descent;PenState penState,newPenState;FontInfo info;#if VWT /* jca 17 Sept 93.  Not in VR { */GetPenState(&penState);GetFontInfo(&info);width=TextWidth(textBuf,0,byteCount);lwidth=scaleX*width;ascent=(info.leading+info.ascent)*scaleY;descent=info.descent*scaleY;/*even though the Picture can't draw, maybe the string can...*/if(lPenLoc.h > -32767 && lPenLoc.h < 32767 &&   lPenLoc.h+lwidth > -32767 && lPenLoc.h+lwidth < 32767 &&   lPenLoc.v-ascent > -32767 && lPenLoc.v-ascent < 32767 &&   lPenLoc.v+descent > -32767 && lPenLoc.v+descent <32767)   	{   	VMoveTo(lPenLoc.h,lPenLoc.v);   	numer.v=scaleYNumer;   	denom.v=scaleYDenom;   	numer.h=scaleXNumer;   	denom.h=scaleXDenom;   	StdText(byteCount,textBuf,numer,denom);   	}else	{	/*to be continued*/	}penState.pnLoc.h+=width;SetPenState(&penState);#endif // VWT. jca 17 Sept 93 }}pascal void LongLineProc(Point newPt);pascal void LongLineProc(Point newPt){ PenState penState;PointLong toPt;GetPenState(&penState);toPt.h=offsetX+newPt.h*scaleX;toPt.v=offsetY+newPt.v*scaleY;LongClipRect(&lPenLoc, &toPt,&thePort->portRect);lPenLoc=toPt;penState.pnLoc=newPt;SetPenState(&penState);}pascal void LongRectProc(GrafVerb verb, Rect *r);pascal void LongRectProc(GrafVerb verb, Rect *r){/*no effect on pen location*/RectLong lr;Rect sr;lr.top=offsetY+r->top*scaleY;lr.left=offsetX+r->left*scaleX;lr.bottom=offsetY+r->bottom*scaleY;lr.right=offsetX+r->right*scaleX;while(abs(lr.top) > 32767)lr.top>>=1;while(abs(lr.left) > 32767)lr.left>>=1;while(abs(lr.right) > 32767)lr.right>>=1;while(abs(lr.bottom) > 32767)lr.bottom>>=1;sr.top=lr.top;sr.left=lr.left;sr.bottom=lr.bottom;sr.right=lr.right;StdRect(verb,&sr);}pascal void LongRRectProc(GrafVerb verb, Rect *r, short ovalWidth, short ovalHeight);pascal void LongRRectProc(GrafVerb verb, Rect *r, short ovalWidth, short ovalHeight){/*no effect on pen location*/}pascal void LongOvalProc(GrafVerb verb, Rect *r);pascal void LongOvalProc(GrafVerb verb, Rect *r){/*no effect on pen location*/}pascal void LongArcProc(GrafVerb verb, Rect *r, short startAngle, short arcAngle);pascal void LongArcProc(GrafVerb verb, Rect *r, short startAngle, short arcAngle){/*no effect on pen location*/}pascal void LongPolyProc(GrafVerb verb, PolyHandle poly);pascal void LongPolyProc(GrafVerb verb, PolyHandle poly){/*no effect on pen location*/}pascal void LongRgnProc(GrafVerb verb, RgnHandle rgn);pascal void LongRgnProc(GrafVerb verb, RgnHandle rgn){/*no effect on pen location*/}pascal void LongBitsProc(BitMap *bitPtr, Rect *srcRect, Rect *dstRect, short mode, RgnHandle maskRgn);pascal void LongBitsProc(BitMap *bitPtr, Rect *srcRect, Rect *dstRect, short mode, RgnHandle maskRgn){/*no effect on pen location*/}#endif //MACINTOSH// In case we don't have the universal headers... BILBIL - 11/16/93#if MACINTOSH	#ifndef NewQDTextProc		#define NewQDTextProc(userRoutine) (Ptr)userRoutine	#endif		#ifndef NewQDLineProc		#define NewQDLineProc(userRoutine) (Ptr)userRoutine	#endif		#ifndef NewQDRectProc		#define NewQDRectProc(userRoutine) (Ptr)userRoutine	#endif		#ifndef NewQDRRectProc		#define NewQDRRectProc(userRoutine) (Ptr)userRoutine	#endif		#ifndef NewQDOvalProc		#define NewQDOvalProc(userRoutine) (Ptr)userRoutine	#endif		#ifndef NewQDArcProc		#define NewQDArcProc(userRoutine) (Ptr)userRoutine	#endif		#ifndef NewQDPolyProc		#define NewQDPolyProc(userRoutine) (Ptr)userRoutine	#endif		#ifndef NewQDRgnProc		#define NewQDRgnProc(userRoutine) (Ptr)userRoutine	#endif		#ifndef NewQDBitsProc		#define NewQDBitsProc(userRoutine) (Ptr)userRoutine	#endif#endifvoid#if MACINTOSHLongDrawPicture(V_Picture *thePicture, RectLong *to)#elif WINDOWSLongDrawPicture(V_Offscreen *thePicture, RectLong *to)#endif{#if VWT /* jca 17 Sept 93.  Not in VR { */#if MACINTOSHVPictHandle pict;CQDProcs bottlenecks;#elif WINDOWSRect paneR;VGrafPort	from;int	stretchMode;#endifRectLong lr;Rect r;#if MACINTOSHpict = thePicture->picture;#endif/*----------------------first, is there any need to go to all the trouble?*/if(to->top > -32767 && to->top < 32767 &&   to->left > -32767 && to->left < 32767 &&   to->right > -32767 && to->right <32767 &&   to->bottom > -32767 && to->bottom <32767)	{	r.top=to->top;	r.left=to->left;	r.right=to->right;	r.bottom=to->bottom;#if MACINTOSH	DrawPicture(pict,&r);#elif WINDOWS	thePicture->GetRect(&paneR);	from = thePicture->metaPort;    stretchMode = SetStretchBltMode(currentDevice, STRETCH_DELETESCANS);	StretchBlt(currentDevice, r.left, r.top, r.right-r.left, r.bottom-r.top,from,paneR.left,paneR.top,paneR.right-paneR.left,paneR.bottom-paneR.top,SRCCOPY);    SetStretchBltMode(currentDevice, stretchMode);#endif	return;	}/* Otherwise...Set the bottlenecks.  These bottlenecks will attempt to draw * a picture as well as possible given a long rect. *//*---------------------------first we need to set the proper scaling factors*/lr=*to;#if MACINTOSHr=((**pict).picFrame);#elif WINDOWSr = thePicture->rect;#endifscaleXNumer=lr.right-lr.left;scaleXDenom=r.right-r.left;while(((scaleXNumer & 0x01)==0) && ((scaleXDenom & 0x01)==0))	{	scaleXNumer>>=1;	scaleXDenom>>=1;	}scaleX=(double)scaleXNumer/scaleXDenom;scaleYNumer=lr.bottom-lr.top;scaleYDenom=r.bottom-r.top;while(((scaleYNumer & 0x01)==0) && ((scaleYDenom & 0x01)==0))	{	scaleYNumer>>=1;	scaleYDenom>>=1;	}scaleY=(double)scaleYNumer/scaleYDenom;offsetX=lr.left-r.left*scaleX;offsetY=lr.top-r.top*scaleY;#if MACINTOSH/*--------------------------now set up the bottleneck functions */if(FindDepth())	SetStdCProcs(&bottlenecks);else	SetStdProcs((QDProcs*)&bottlenecks);	// BILBIL - no procDPtr [[[bottlenecks.textProc = NewQDTextProc(LongTextProc);bottlenecks.lineProc = NewQDLineProc (LongLineProc);bottlenecks.rectProc = NewQDRectProc (LongRectProc);bottlenecks.rRectProc = NewQDRRectProc (LongRRectProc);bottlenecks.ovalProc = NewQDOvalProc (LongOvalProc);bottlenecks.arcProc = NewQDArcProc (LongArcProc);bottlenecks.polyProc = NewQDPolyProc (LongPolyProc);bottlenecks.rgnProc = NewQDRgnProc (LongRgnProc);bottlenecks.bitsProc = NewQDBitsProc (LongBitsProc);// BILBIL - no procDPtr ]]](*thePort).grafProcs = (QDProcs *) &bottlenecks;/*to insure that the picture gets drawn in a reasonable way, just have it draw to  its picframe (we don't want any scaling, unless we do it) */DrawPicture(pict, &((**pict).picFrame));(*thePort).grafProcs = 0L;#elif WINDOWS	lr.right = r.right * scaleX;	lr.bottom = r.bottom * scaleY;	lr.left = r.left * scaleX;	lr.top = r.top * scaleY;	thePicture->GetRect(&paneR);	from = thePicture->metaPort;	stretchMode = SetStretchBltMode(currentDevice, STRETCH_DELETESCANS);	StretchBlt(currentDevice, lr.left, lr.top, lr.right-lr.left, lr.bottom-lr.top,from,paneR.left, paneR.top,paneR.right-paneR.left, paneR.bottom-paneR.top,SRCCOPY);	SetStretchBltMode(currentDevice, stretchMode);#endif#endif // VWT.  jca 17 Sept 93 }}