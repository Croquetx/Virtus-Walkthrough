/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "RuleItem.h"#include "Ruler.h"#include "WalkBuff.h"#include "VMath.h"#include "Misc.h"#include "VGraphic.h"#include "VGUtil.h"#include "VMemUtil.h"#include <stdlib.h>int halfTabWidth = TAB_WIDTH>>1;voidRulerItemDef::cRulerItemDef()	{	value = FFZero;	value2 = FFZero;	color = vBlack;	axis = 0;	type = guideItem;	}void RulerItemDef::dRulerItemDef() { delete this; }FFixed RulerItemDef::GetValue() { return value; }void RulerItemDef::SetValue(FFixed num) { value = num;  }FFixed RulerItemDef::GetValue2() { return value2; }void RulerItemDef::SetValue2(FFixed num) {  value2 = num;  }void RulerItemDef::SetAxis(char num) { axis = num; }char RulerItemDef::GetAxis() { return axis; }void RulerItemDef::SetType(int t) { type = t; }int RulerItemDef::GetType() { return type; }void RulerItemDef::SetColor(RGBColor c) { color = c; }RGBColor RulerItemDef::GetColor() { return color; }int RulerItemDef::IO(V_Buffer *buffer) 	{	int	err;		err = 0;		ObjLock((ObjectHandle)this);		if(err = IOType(buffer,&value,IO_FFIXED)) return(err);	if(err = buffer->IOType(&axis,IO_SHORT)) return(err);		if(err = IOType(buffer,&color,IO_RGB_COLOR)) return(err);	ObjUnlock((ObjectHandle)this);	return(err);	}	voidRulerItem::cRulerItem()	{	state = outRulerItem;	itemDef = NULL;	scaleValue = 0;	}void RulerItem::dRulerItem() { delete this; }char RulerItem::GetState() { return state; }void RulerItem::SetState(char num) { state = num; }int RulerItem::GetType() { return itemDef->GetType(); }void RulerItem::SetType(int num) { itemDef->SetType(num);}RulerItemDef *RulerItem::GetItemDef() { return itemDef; }void RulerItem::SetItemDef(RulerItemDef *def) { itemDef = def; }int  RulerItem::Find(FFixed *loc,FFixed selectRange,int side) 	{ 	FFixed	diff,vMin,vMax,val,val2;	int opposite;		state = outRulerItem;	opposite = (side == NEGATIVE_SIDE) ? TRUE : FALSE;	val = itemDef->GetValue();	if(opposite)val = FFNeg(val);	diff = FFSub(val,*loc);	if(diff.l<0)diff.l = -diff.l;		if(LESS == FFLogic(diff,selectRange))		{ state = inRulerItem;  *loc = val; }	else		{ 		if(itemDef->GetType() == rangeItem)			{			val2 = itemDef->GetValue2();			if(opposite)val2 = FFNeg(val2);			diff = FFSub(val2,*loc);			if(diff.l<0)diff.l = -diff.l;			if(LESS == FFLogic(diff,selectRange))				{ state = inRulerItem2; *loc = val2; }			else				{				FFMin(vMin,val,val2);				FFMax(vMax,val,val2);				if((GRTR == FFLogic(*loc,vMin)) && (LESS == FFLogic(*loc,vMax)))					state = inRulerItemRange;				}			}		}			return state; 	}intRulerItem::FindLocal(int where) 	{ 	int val,val2;		if(SELECT_RANGE > abs(scaleValue-where) )		state = inRulerItem;	else		{			if(itemDef->GetType() == rangeItem)			{			if(SELECT_RANGE > abs(scaleValue2-where) )				state = inRulerItem2;			else				{				val = min(scaleValue,scaleValue2);				val2 = max(scaleValue,scaleValue2);				if((where>val) && (where < val2))					state = inRulerItemRange;				}			}		}	return state;	}	void RulerItem::MoveItem(Ruler *ruler,FFixed anchor,int loc,int direction) 	{	RGBColor	col;	Rect	r;	Point	p;	FFixed newValue,newValue2,val,val2;	int lValue,lValue2,bottom;	int	tValue,tValue2,opposite;		ruler->GetTabRect(&r);	if( HORZ_RULER == direction)bottom = r.bottom; else bottom = r.right;	opposite = (ruler->side == NEGATIVE_SIDE) ? TRUE : FALSE;	VSetPattern(vPatBlack);	if(ruler->depth>2)		{		col = itemDef->GetColor();		VForeColor(&col);		}	else 		VForeColor(&vBlack);		switch(itemDef->GetType())		{		case guideItem:		case originItem:			DrawGuideSymbol(bottom,loc,direction,itemDef->GetType());			break;				case rangeItem:						val = itemDef->GetValue();			val2 = itemDef->GetValue2();			if(opposite)				{				val= FFNeg(val);				val2= FFNeg(val2);				}			switch(state)				{				case inRulerItem:					tValue = loc;					tValue2 = ruler->World2Local(val2,RSCALE_ABSOLUTE);					break;								case inRulerItem2:					tValue = ruler->World2Local(val,RSCALE_ABSOLUTE);					tValue2 = loc;					break;								case inRulerItemRange:					val = FFSub(val,anchor);					val2 = FFSub(val2,anchor);					tValue = ruler->World2Local(val,RSCALE_RELATIVE)+loc;					tValue2 = ruler->World2Local(val2,RSCALE_RELATIVE)+loc;					break;									default: 					break;				}					lValue = min(tValue,tValue2);			lValue2 = max(tValue,tValue2);						if(HORZ_RULER == ruler->direction)				{				r.left = lValue;				r.right = lValue2;				r.top = r.bottom-TAB_WIDTH;				if(ruler->depth<4) VSetPattern(vPatGray);				VPaintRect(&r);				VForeColor(&vBlack);				VSetPattern(vPatBlack);				p.v = r.top;				p.h = r.left;				DrawTab(p,BACK_MARK,HORZ_MARK);				p.h = r.right; 				DrawTab(p,FORW_MARK,HORZ_MARK);				}			else				{				r.top = lValue;				r.bottom = lValue2;				r.left = r.right-TAB_WIDTH;				if(ruler->depth<4) VSetPattern(vPatGray);				VPaintRect(&r);				VForeColor(&vBlack);				VSetPattern(vPatBlack);				p.h = r.left;				p.v = r.top;				DrawTab(p,BACK_MARK,VERT_MARK);				p.v = r.bottom; 				DrawTab(p,FORW_MARK,VERT_MARK);				}			break;		}	}	void RulerItem::Display(Ruler *ruler,FFixed minWorld,FFixed maxWorld,FFixed offset,int direction) 	{	RGBColor	col;	Rect	r;	Point	p;	FFixed newValue,newValue2,val,val2;	int lValue,lValue2,bottom;	int	tValue,tValue2,opposite;		ruler->GetTabRect(&r);	if( HORZ_RULER == ruler->direction)bottom = r.bottom; else bottom = r.right;		if(ruler->depth>2)		{		VSetPattern(vPatBlack);		col = itemDef->GetColor();		VForeColor(&col);		}	else 		VForeColor(&vBlack);			opposite = (ruler->side == NEGATIVE_SIDE) ? TRUE : FALSE;	val = itemDef->GetValue();	if(opposite)val = FFNeg(val);	switch(itemDef->GetType())		{		case guideItem:		case originItem:			lValue = ruler->World2Local(val,RSCALE_ABSOLUTE);			DrawGuideSymbol(bottom,lValue,ruler->direction,itemDef->GetType());			scaleValue = lValue;			break;				case rangeItem:						val2 = itemDef->GetValue2();			if(opposite)val2 = FFNeg(val2);			tValue = ruler->World2Local(val,RSCALE_ABSOLUTE);			tValue2 = ruler->World2Local(val2,RSCALE_ABSOLUTE);					lValue = min(tValue,tValue2);			lValue2 = max(tValue,tValue2);						if(HORZ_RULER == ruler->direction)				{				r.left = lValue;				r.right = lValue2;				r.top = r.bottom-TAB_WIDTH;				if(ruler->depth<4) VSetPattern(vPatGray);				VPaintRect(&r);				VForeColor(&vBlack);				VSetPattern(vPatBlack);				p.v = r.top;				p.h = r.left;				DrawTab(p,BACK_MARK,HORZ_MARK);				p.h = r.right; 				DrawTab(p,FORW_MARK,HORZ_MARK);				}			else				{				r.top = lValue;				r.bottom = lValue2;				r.left = r.right-TAB_WIDTH;				if(ruler->depth<4) VSetPattern(vPatGray);				VPaintRect(&r);				VForeColor(&vBlack);				VSetPattern(vPatBlack);				p.h = r.left;				p.v = r.top;				DrawTab(p,BACK_MARK,VERT_MARK);				p.v = r.bottom; 				DrawTab(p,FORW_MARK,VERT_MARK);				}			break;		}	}	void RulerItem::ScaleItem(Ruler *ruler,int side) 	{	FFixed val;	val = itemDef->GetValue();	if(side == NEGATIVE_SIDE)val = FFNeg(val);	scaleValue = ruler->World2Local(val,RSCALE_ABSOLUTE);	if( itemDef->GetType() == rangeItem)		{		val = itemDef->GetValue2();		if(side == NEGATIVE_SIDE)val = FFNeg(val);		scaleValue2 =  ruler->World2Local(val,RSCALE_ABSOLUTE);		}	}	void RulerItem::Copy(RulerItem *from) 	{	itemDef->SetType(from->GetType());	}			/* THIS POINTS PERP TO THE AXIS OF THE EXTRUSION MARKERS */void DrawTab(Point where, int direction, int axis)	{	int		i;		if(HORZ_MARK == axis) /* HORIZONTAL */		{		for(i = TAB_WIDTH; i >= 0; i-=2)			{			VMoveTo(where.h,where.v);			VLineTo(where.h,where.v + i+1);			if(BACK_MARK == direction)where.h--; /* POINTS LEFT */			else where.h++;					/* POINTS RIGHT */			}		}	else			/* VERTICAL */		{		for(i = TAB_WIDTH; i >= 0; i-=2)			{			VMoveTo(where.h,where.v);			VLineTo(where.h + i+1,where.v);			if(BACK_MARK == direction)where.v--; /* POINTS UP */			else where.v++;					/* POINTS DOWN */			}		}			}/* THIS POINTS PERP TO THE AXIS OF THE EXTRUSION MARKERS */void DrawGuideSymbol(int h,int where, int axis,int type)	{	int		i,w,f,t;	w = halfTabWidth;	switch(type)		{		case guideItem:			if(HORZ_RULER == axis)				{				for(i = 0; i < w; i++,h--)					{					VMoveTo(where-i,h);					VLineTo(where+i+1,h);					}				for(; i >= 0; i--,h--)					{					VMoveTo(where-i,h);					VLineTo(where+i+1,h);					}									}			else				{				for(i = 0; i < w; i++,h--)					{					VMoveTo(h,where-i);					VLineTo(h,where+i+1);					}				for(; i >= 0; i--,h--)					{					VMoveTo(h,where-i);					VLineTo(h,where+i+1);					}									}			break;				case originItem:			w++;			if(HORZ_RULER == axis)				{				for(i = 0; i < w; i++,h--)					{					f = where-i;					t = where+i+1;					VMoveTo(f,h);					VLineTo(t,h);					h--;					VMoveTo(f,h);					VLineTo(t,h);					}								}			else				{				for(i = 0; i < w; i++,h--)					{					f = where-i;					t = where+i+1;					VMoveTo(h,f);					VLineTo(h,t);					h--;					VMoveTo(h,f);					VLineTo(h,t);					}									}						break;		}	}