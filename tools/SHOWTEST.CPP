/*------------------------------------------------------------------------------ * VWINDOWSt - the window object toolbox * Version 1.0 * * Copyright c 1989 by Virtus Corporation * All Rights Reserved * Written by David A. Smith * Virtus Corporation * 117 Edinburgh So. Suite 204 * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * ShowTest.c *------------------------------------------------------------------------------*/#include "Vtypes.h"#include "ShowTest.h"#include "VGraphic.h"#include "VWindow.h"#include "VArray.h"#include "VGUtil.h"#include <string.h>/*------------------------------------------------------------------------------ * ShowMem() * This function displays the current amount of memory available to the user and * the amount changed since the last call of the ShowMem() function. *------------------------------------------------------------------------------*/#undef DEBUG#define DEBUG 1#if DEBUG#if MACINTOSHvoid ShowMem(int hold){GrafPort meta;char str[255];Rect r;GrafPtr savePort;GDHandle saveDevice;long diff;long val=FreeMem();static long lastval;V_Offscreen *screen;diff=val-lastval;lastval=val;VGetPort(&savePort,&saveDevice);screen=new(V_Offscreen);screen->cScreen(GetMainDevice());screen->SetMetaPort();PenMode(patCopy);r.top=0;r.bottom=19;r.left=300;r.right=460;EraseRect(&r);MoveTo(300,18);NumToString(val,(StringPtr)str);DrawString((StringPtr)str);DrawString((StringPtr)"\p,");NumToString(diff,(StringPtr)str);DrawString((StringPtr)str);VSetPort(savePort,saveDevice);screen->UnsetMetaPort();screen->dOffscreen();if(hold)	{	while(!Button());	while(Button());	}}/*------------------------------------------------------------------------------ * ShowTime() *------------------------------------------------------------------------------*/void ShowTime(int start){GrafPort meta;char str[255];Rect r;GrafPtr savePort;GDHandle saveDevice;long val,diff;static	long lastval; if(start)lastval=TickCount();else	{	val=TickCount();	diff=val-lastval;	VGetPort(&savePort,&saveDevice);	OpenPort(&meta);	SetPortBits(&screenBits);	VSetPort(&meta,0L);	PenMode(patCopy);	r.top=0;	r.bottom=19;	r.left=200;	r.right=360;	EraseRect(&r);	MoveTo(200,18);	NumToString(diff,(StringPtr)str);	DrawString((StringPtr)str);	VSetPort(savePort,saveDevice);	ClosePort(&meta);	}}voidShowInfo(char *str)	{	char s[256];	GrafPtr savePort;	GDHandle saveDevice;	GrafPort meta;	int i;	Rect r;	for (i = 1; i < 255; i++)		s[i] = str[i-1];	s[255] = '\0';	s[0] = strlen(s+1);		VGetPort(&savePort,&saveDevice);	OpenPort(&meta);	SetPortBits(&screenBits);	VSetPort(&meta,0L);	PenMode(patCopy);	r.top=0;	r.bottom=19;	r.left=200;	r.right=360;	EraseRect(&r);	MoveTo(200,18);		r.left = h; r.right = h + 300;	r.top = v - 15; r.bottom = v + 3;	EraseRect(&r);		DrawString((StringPtr)s);	VSetPort(savePort,saveDevice);	ClosePort(&meta);	while(!Button());	}void ShowInfo2(char *str)	{	char s[256];	GrafPtr savePort;	GDHandle saveDevice;	GrafPort meta;	int i;	Rect r;	for (i=1; i< 255; i++)		s[i] = str[i-1];	s[255] = '\0';	s[0] = strlen(s+1);	VGetPort(&savePort,&saveDevice);	OpenPort(&meta);	SetPortBits(&screenBits);	VSetPort(&meta,NULL);	PenMode(patCopy);	r.top = 0;	r.bottom = 19;	r.left = 300;	r.right = 460;	EraseRect(&r);	MoveTo(300,15);	r.left = h; r.right = h + 300;	r.top = v - 15; r.bottom = v+3;	EraseRect(&r);	DrawString((StringPtr)s);	VSetPort(savePort,saveDevice);	ClosePort(&meta);	}void ShowNum(long num){GrafPort meta;char str[255];Rect r;GrafPtr savePort;GDHandle saveDevice;	VGetPort(&savePort,&saveDevice);	OpenPort(&meta);	SetPortBits(&screenBits);	VSetPort(&meta,0L);	PenMode(patCopy);	r.top=0;	r.bottom=19;	r.left=400;	r.right=560;	EraseRect(&r);	MoveTo(400,18);	NumToString(num,(StringPtr)str);	DrawString((StringPtr)str);	VSetPort(savePort,saveDevice);	ClosePort(&meta);}#endif // MACINTOSHvoid ShowOffscreen(V_Offscreen *off){Rect r,rscreen;V_Window * win;VCGrafPort	savePort;VGrafDevice saveDevice;int cx,cy;Point p;int style;#if MACINTOSHEventRecord	myEvent;style = BORDERLESS;#elif WINDOWSstyle = MODALWINDOW;#endif // MACINTOSHp.h=p.v=0;VGetPort( &savePort,&saveDevice );GetScreen(&rscreen);cx=(rscreen.right+rscreen.left)>>1;cy=(rscreen.top+rscreen.bottom)>>1;off->GetRect(&r);if ((r.bottom - r.top) > (rscreen.bottom - rscreen.top))	r.bottom = r.top + (rscreen.bottom - rscreen.top);cx=cx-((r.right-r.left)>>1);cy=cy-((r.bottom-r.top-10)>>1);rscreen.left=r.left+cx;rscreen.right=r.right+cx;rscreen.top=r.top+cy;rscreen.bottom=r.bottom+cy;win=new(V_Window);win->cWindow(&rscreen,(strPtr)"Offscreen Display",p,p,p,style,WINDOW_CLOSE);win->Show();#if MACINTOSHwin->SetWPort();#endif // MACINTOSHoff->MetaTo(win,&r,&r);#if MACINTOSHdo { 	if(WaitNextEvent(mDownMask|mUpMask|keyDownMask|autoKeyMask, &myEvent,0,0L))		if(myEvent.what==keyDown)break;	} while ( !Button());	win->dWindow();do { /*nothing*/ } while ( Button() );VSetPort(savePort,saveDevice);FlushEvents(mDownMask|mUpMask|keyDownMask|keyUpMask|autoKeyMask,0);#elif WINDOWS{MSG msg;while (!PeekMessage(&msg, NULL, WM_LBUTTONDOWN, WM_MOUSELAST, PM_REMOVE))	{	}}win->dWindow();VSetPort(savePort,saveDevice);VFlushEvents(mDownMask|mUpMask);#endif // MACINTOSH}// jca 29 Sept 93void ShowOffscreenMore(V_Offscreen *off){Rect offR,offLeft, rscreen, winR, offNorm;V_Window *win, **winP;VCGrafPort	savePort;VGrafDevice saveDevice;int cx,cy;Point p;int style, i, size, leftOvers;V_Array	*winList;#if MACINTOSHEventRecord	myEvent;style = BORDERLESS;#elif WINDOWSstyle = MODALWINDOW;#endif // MACINTOSH// put the offscreen at the left top edge of the screen, so we can// wrap any others across the screen.winList = new(V_Array);winList->cArray(0, sizeof(V_Window *), 4);p.h=p.v=0;VGetPort( &savePort,&saveDevice );GetScreen(&rscreen);rscreen.top+=25;		// MERGE-Z1cx=(rscreen.right+rscreen.left)>>1;cy=(rscreen.top+rscreen.bottom)>>1;off->GetRect(&offLeft);leftOvers = TRUE;offR = offLeft;if ((offLeft.bottom - offLeft.top) > (rscreen.bottom - rscreen.top))	{	offR.bottom = offLeft.top + (rscreen.bottom - rscreen.top)-10;    offLeft.top = offR.bottom;	}offNorm = offR;while(leftOvers)	{	winR.left=(rscreen.left+offR.left);	winR.right=(rscreen.left+offR.right);	winR.top=offNorm.top+rscreen.top;	winR.bottom=offNorm.bottom + rscreen.top;	win=new(V_Window);	win->cWindow(&winR,(strPtr)"Offscreen Display",p,p,p,style,WINDOW_CLOSE);	win->Show();	#if MACINTOSH	win->SetWPort();	#endif // MACINTOSH	off->MetaTo(win,&offR,&offNorm);	winList->Append((void*)&win);	rscreen.left = winR.right+10;	if ((offLeft.bottom - offLeft.top) > 0)		{        offR.top = offR.bottom;		offR.bottom = offR.top + min(((rscreen.bottom - rscreen.top)-10), (offLeft.bottom-offLeft.top));		offLeft.top += offR.bottom;		offNorm.right = offNorm.left + (offR.right - offR.left);		offNorm.bottom = offNorm.top + (offR.bottom - offR.top);		}	else    	leftOvers = FALSE;	}#if MACINTOSHdo { 	if(WaitNextEvent(mDownMask|mUpMask|keyDownMask|autoKeyMask, &myEvent,0,0L))		if(myEvent.what==keyDown)break;	} while ( !Button());do { /*nothing*/ } while ( Button() );VSetPort(savePort,saveDevice);FlushEvents(mDownMask|mUpMask|keyDownMask|keyUpMask|autoKeyMask,0);#elif WINDOWS{MSG msg;while (!PeekMessage(&msg, NULL, WM_LBUTTONDOWN, WM_MOUSELAST, PM_REMOVE))	{	}}VSetPort(savePort,saveDevice);VFlushEvents(mDownMask|mUpMask);#endif // MACINTOSHsize = winList->ALength();winP = (V_Window**) winList->Use();for (i = 0; i < size; i++)	{	winP[i]->dWindow();	}    winList->Unuse();winList->dArray();}#endif // DEBUG