/*------------------------------------------------------------------------------ * VWINDOWSÂ - the window object toolbox * Version 1.0 * * Copyright Ñ 1989 by Virtus Corporation * All Rights Reserved * Written by David A. Smith * 111 Gold Meadow Drive * Cary, North Carolina    27513 * (919) 469-8485 *------------------------------------------------------------------------------ * VMath.c *------------------------------------------------------------------------------*/#include "VTypes.h"#include "VMath.h"#include "VAsm.h"#include "WTypes.h"#include <stdio.h>#include <string.h>#include <math.h>// the asm only works or real macs, not power pc's// from header vmath.h:// #define MAC_ASMABLE		(MACINTOSH && !__powerc)FFixed (* FFMult)(FFixed,FFixed) = FFMult_C;FFixed (*  FFDiv)(FFixed,FFixed) = FFDiv_C;/*.5 in fixed.  various uses, mostly involving rounding*/FFixed FixedPointFive = INITFIXXED(0x0000, 0x8000);	//GJR 10/11/93 // ABD MERGE-TEXTURE 9/13/93doubleVsqrt(double num)	{	double val;	if(num<0)    	num = 1;    val = sqrt(num);    return val;	}voidInitVMathAsm(){	#if MAC_ASMABLE	// mac only	if (gAsmM020)		{  // Then use 020 routines		FFMult = FFMult_M020;		FFDiv  = FFDiv_M020;		}	else		{  // else use 68k vanilla routines		FFMult = FFMult_M000;		FFDiv  = FFDiv_M000;		}#else	FFMult = FFMult_C;	FFDiv = FFDiv_C;#endif	// MACINTOSH} intBitWidth(register ULong a)	{	register int width = 0;	while (a != 0)		{		a >>= 1;		width++;		}	return(width);	}int LSqrt(long val){register int result;register long rsquare,top,bottom;if(val<=1)return val;rsquare=val;if(rsquare>0x7FFF)rsquare=0x0FFFF;top=rsquare>>1;	  /*val/2 as maximum*/bottom=1;	  /*minimum value can only be 1*/result=rsquare>>2;/*val/4 as initial test*/rsquare=(long)result*result;while(TRUE)	{	if(rsquare>val)		{		top=result;		result=(bottom+result)>>1;		}	else		{		bottom=result;		result=(top+result)>>1;		}	if(top<=bottom+1)return result;	rsquare=(long)result*result;	}}/*------------------------------------------------------------------------------ * FFixed library *------------------------------------------------------------------------------*/FFixed FFZero=INITFIXXED(0,0);    	// beware byte order	//GJR 10/11/93 FFixed FFMax=INITFIXXED(0x7FFF,0xFFFF);FFixed inchToMeter=INITFIXXED(0,0x0681);		/* 0.0254 *//* FFixed degreeToRadian=INITFIXXED(0,0x0478);*/  /* 0.017453292519943 */FFixed degreeToRadian=INITFIXXED(57,0x4BB8); /* 57.29577951 */long FFOver;int FFErr;FFixed FFMult_C(FFixed ffA, FFixed ffB)	{#if __powerc&&0	double d;	FFixed result;	FFErr=0;	d = (double)(ffA.l) * (double)(ffB.l);	// S16.16 * S16.16 => S32.32	//check for overflow	if(d > ((double)32767.0*65536.0))	{		FFErr=FFERR_OVERFLOW;	}	if(d < ((double)-32767.0*65536.0))	{		FFErr=FFERR_OVERFLOW;	}	result.l = d/((double)32768.0);		// .16 * .16 => .32; .32 / 16bits => .16	FFOver = d/((double)65536.0);		// change S32.32 into S32.0 into S32	return(result);	#else	ULong tmpReslt,top,middle1,middle2,bottom,fraction;	long	finResult;	FFixed result;	int	neg = 0;	FFErr=0;	FFOver=0;	if(FFZero(ffA) || FFZero(ffB)) return(FFZero);	if(FFOne(ffA)) return(ffB);	if(FFOne(ffB)) return(ffA);	if(ffA.intg < 0) 		{ 		ffA.intg = -ffA.intg; 		if(ffA.frac) { ffA.intg--; ffA.frac = ~ffA.frac + 1; } 		neg = 1; 		}	if(ffB.intg < 0) 		{ 		ffB.intg = -ffB.intg; 		if(ffB.frac) { ffB.intg--; ffB.frac = ~ffB.frac + 1; } 		neg ^= 1; 		}		top=(long)ffA.intg*ffB.intg;	middle1=(long)ffA.intg*ffB.frac;	middle2=(long)ffA.frac*ffB.intg;	bottom=(long)ffA.frac*ffB.frac;					fraction = middle1 + middle2 + (bottom >> 16) + ((bottom&0x8000)?1:0);	tmpReslt = (top << 16) + fraction;	FFOver=top+(fraction>>16);	if(FFOver>0x07FFF)FFErr=FFERR_OVERFLOW;	else FFErr=0;	if (neg){finResult = -tmpReslt;FFOver=-FFOver;}	else finResult = tmpReslt;	result.l=finResult;		return(result);#endif	}#if MAC_ASMABLE//--------------------------------------------------------------------------------#if 0Rounding:		Note that its purely an add of .5 (test next lower bit and inc)0001.F	00020001.8	00020001.7	00010000.F	00010000.8	00010000.7	00000000.1	00000000.0	0000FFFF.F	0000FFFF.8	0000FFFF.7	FFFFFFFF.1	FFFFFFFE.F	FFFFFFFE.8	FFFFFFFE.7	FFFEFFFE.1	FFFE#endif	#pragma options(mc68020)FFixed FFMult_M020(FFixed ffA, FFixed ffB){FFixed result;	asm {		move.l	ffA, d1		muls.l	ffB, d0:d1		;32x32 into 64.		move.l	d0,d2		tst.l	d1		bpl		@DoneRoundOverflow		add.l	#1,d2DoneRoundOverflow:		move.l	d2,FFOver		;top 32 (.intg portion) gets put away		bpl		@abs_overflow		neg.l	d2@abs_overflow:		cmp.l	#0x07FFF,d2		ble		@NoError		move.w	#FFERR_OVERFLOW,d2		bra		@StoreErrorCheck@NoError:		clr.w	d2@StoreErrorCheck:		move.w	d2,FFErr								;--- Round result		clr.l	d2				;prepare for add carry		add.l	#0x8000,d1		;rounding up for FFrac's		addx.l	d2,d0			;add in the carry								;--- Format as FFrac		swap	d0				// painful. get middle 32 of 64bit answer		clr.w	d0		clr.w	d1		swap	d1		or.l	d1,d0		move.l	d0,result	}	return(result);}#pragma options(!mc68020)//--------------------------------------------------------------------------------	FFixed FFMult_M000(FFixed ffA, FFixed ffB)	{	ULong tmpReslt,top,middle1,middle2,bottom,fraction;	long	finResult;	FFixed result;	int	neg = 0;	FFErr=0;	FFOver=0;	if(FFZero(ffA) || FFZero(ffB)) return(FFZero);	if(FFOne(ffA)) return(ffB);	if(FFOne(ffB)) return(ffA);	if(ffA.intg < 0) 		{ 		ffA.intg = -ffA.intg; 		if(ffA.frac) { ffA.intg--; ffA.frac = ~ffA.frac + 1; } 		neg = 1; 		}	if(ffB.intg < 0) 		{ 		ffB.intg = -ffB.intg; 		if(ffB.frac) { ffB.intg--; ffB.frac = ~ffB.frac + 1; } 		neg ^= 1; 		}		top=(long)ffA.intg*ffB.intg;	middle1=(long)ffA.intg*ffB.frac;	middle2=(long)ffA.frac*ffB.intg;	bottom=(long)ffA.frac*ffB.frac;					fraction = middle1 + middle2 + (bottom >> 16) + ((bottom&0x8000)?1:0);	tmpReslt = (top << 16) + fraction;	FFOver=top+(fraction>>16);	if(FFOver>0x07FFF)FFErr=FFERR_OVERFLOW;	else FFErr=0;	if (neg){finResult = -tmpReslt;FFOver=-FFOver;}	else finResult = tmpReslt;	result.l=finResult;		return(result);}//--------------------------------------------------------------------------------	#endif // MACINTOSHlong FFLongMult(FFixed ffA, FFixed ffB)	{	ULong top,middle1,middle2,bottom,tmpReslt,fraction;	long	finResult;	int	neg = 0;	FFErr=0;	if(ffA.intg < 0) 		{ 		FFFNeg(ffA);		neg ^= 1; 		}	if(ffB.intg < 0) 		{ 		FFFNeg(ffB);		neg ^= 1; 		}					top=(long)ffA.intg*ffB.intg;	middle1=(long)ffA.intg*ffB.frac;	middle2=(long)ffA.frac*ffB.intg;	bottom=(long)ffA.frac*ffB.frac;		fraction = middle1 + middle2 + (bottom >> 16) + ((bottom&0x8000)?1:0);	FFOver=tmpReslt = top + (fraction >> 16) + ((fraction&0x8000)?1:0);	if(FFOver>0x0FFFF)FFErr=FFERR_OVERFLOW;	else FFErr=0;			if (neg){finResult = -tmpReslt; FFOver=-FFOver;}	else finResult = tmpReslt;	return(finResult);	}	FFixed FFMultIntShift(FFixed ffA, short iB, short shift)	{	ULong tmpReslt,top,bottom;	long	finResult;	short	tmpHold;	FFixed 	result;	int		neg = 0;		FFErr=0;	if(ffA.intg < 0) 		{		FFFNeg(ffA);		neg ^= 1; 		}	if(iB < 0) 		{ 		iB = -iB; 		neg ^= 1; 		}		top=(long)ffA.intg*iB;	bottom=(long)ffA.frac*iB;		if(shift>0)		tmpReslt = (top << (16-shift)) + (bottom>>shift);	else tmpReslt =(top << (16-shift))+(bottom<<-shift);		if (neg) finResult = -tmpReslt;	else finResult = tmpReslt;			result.l=finResult;			return(result);	}FFixed FFAdd(FFixed ffA,FFixed ffB)	{	FFixed 	result;	long	a,b,tmpResult;		FFErr=0;	result.l=ffA.l+ffB.l;	FFOver=(long)ffA.intg+(long)ffB.intg;	return(result);	}FFixed FFSub(FFixed ffA,FFixed ffB)	{	FFixed 	result;	long	a,b,tmpResult;		FFErr=0;	result.l=ffA.l-ffB.l;	FFOver=(long)ffA.intg-(long)ffB.intg;	return(result);	}FFixedFFShift(FFixed ff,int sh)	{	FFixed 	result;	long	a;	FFErr=0;	a = ff.l;	if(sh>=0){		FFOver=(long)ff.intg<<sh;		a<<=sh;		if(ff.intg<0)if(0x07FFF<-FFOver)FFErr=FFERR_OVERFLOW;		else if(0x07FFF<FFOver)FFErr=FFERR_OVERFLOW;		}	else a>>=-sh;	result.l = a;	return(result);	}FFixedFFNeg(FFixed ffA)	{	FFixed 	result;	result.l=-ffA.l;	return(result);	}//--------------------------------------------------------------------------------	FFixed FFDiv_C(FFixed ffA,FFixed ffB)	{#if __powerc	double d;	FFixed result;		if(ffB.l==0){FFErr=FFERR_DIVZERO;return FFMax;}		d = (double)(ffA.l) / (double)(ffB.l);	//check for overflow	if(d > (double)32767.0)	{		return FFMax;	}	if(d < (double)-32767.0)	{		result.l = FFMax.l;		result.l = -result.l;		return(result);	}	result.l = d*(double)65536.0;	return(result);	#else	FFixed 	result;	long	a,b;	ULong tmpResult,remain;	int count,neg=0,w;		FFErr=0;	if(FFZero(ffA)) return(FFZero);	if(FFOne(ffB)) return(ffA);	if(ffA.intg < 0) 		{ 		FFFNeg(ffA);		neg ^= 1; 		}	if(ffB.intg < 0) 		{ 		FFFNeg(ffB);		neg ^= 1; 		}	a = ffA.l;	b = ffB.l;	if(b==0){FFErr=FFERR_DIVZERO;return FFMax;}	else FFErr=0;		tmpResult = a / b;	result.intg=tmpResult;	remain=a-(tmpResult*b);	if(remain<=0x0FFFFL)      // jca 16MAR94 Jeff's suggestion		{		remain<<=16;		tmpResult=remain/b;		}	else		{		BIT_WIDTH(remain,w);		w=32-w;		remain<<=w;			/*shift up as much as we can*/		w=16-w;		b += (1<<w)-1;		// jca 16MAR94 round up		b>>=w;					/*shift down what is left*/		tmpResult=remain/b;		}	result.frac=tmpResult;	if(tmpResult&0x10000)result.intg++;	if(neg)result=FFNeg(result);	return(result);#endif	}//--------------------------------------------------------------------------------	#if MAC_ASMABLEFFixed FFDiv_M000(FFixed ffA,FFixed ffB)	{	FFixed 	result;	long	a,b;	ULong tmpResult,remain;	int count,neg=0,w;		FFErr=0;	if(FFZero(ffA)) return(FFZero);	if(FFOne(ffB)) return(ffA);	if(ffA.intg < 0) 		{ 		FFFNeg(ffA);		neg ^= 1; 		}	if(ffB.intg < 0) 		{ 		FFFNeg(ffB);		neg ^= 1; 		}	a = ffA.l;	b = ffB.l;	if(b==0){FFErr=FFERR_DIVZERO;return FFMax;}	else FFErr=0;		tmpResult = a / b;	result.intg=tmpResult;	remain=a-(tmpResult*b);	if(remain<0x0FFFFL)		{		remain<<=16;		tmpResult=remain/b;		}	else		{		BIT_WIDTH(remain,w);		w=32-w;		remain<<=w;			/*shift up as much as we can*/		w=16-w;			b>>=w;					/*shift down what is left*/		tmpResult=remain/b;		}	result.frac=tmpResult;	if(tmpResult&0x10000)result.intg++;	if(neg)result=FFNeg(result);	return(result);	}//--------------------------------------------------------------------------------	#pragma options(mc68020)FFixed FFDiv_M020(FFixed ffA,FFixed ffB)	{	FFixed 	result;	asm {		MOVE.L	ffA,D0		MOVE.L	ffB,D2		BNE		@NotDivideByZero		MOVE.W	#FFERR_DIVZERO,D1	;Proclaim the error		MOVE.W	D1,FFErr		BRA		@DoInfinity		@NotDivideByZero:		CLR.W	D1		MOVE.W	D1,FFErr	;Clear out error indicator				MOVE.L	D0,D1		;prepare a 64-bit version, intg in d0, frac in d1		SWAP	D0		EXT.L	D0			;intg in lower part of d0		SWAP	D1		CLR.W	D1			;frac in upper part of d1				DIVS.L	D2,D0:D1	;(64bit*2^16) / 32bit ==> preshifted 32bit		BVC		@DoneDivide	@DoInfinity:		MOVE.L	FFMax,D1			;Setup for +- infinity		EOR.L	D2,D0				;For overflow, original regs are left alone		BPL		@GotInfinity		NEG.L	D1					;else get negative infinity@GotInfinity:@DoneDivide:		MOVE.L	D1,result		}		return(result);	}#pragma options(!mc68020)//--------------------------------------------------------------------------------	#endif // MACINTOSH int FFLogic(FFixed ffA,FFixed ffB)	{	if(ffA.l>ffB.l)return GRTR;	else if(ffA.l<ffB.l)return LESS;	else return EQUL;	}/*  jca 26 aug 93.  huh?  never used.pascal Fixed X2Fix(double* x)	= 0xA844; pascal double Fix2X(Fixed* x)	= 0xA843; */FFixedDblToFixed(double d)	{	FFixed 	result;	result.l=d*(double)65536.0;	return(result);	}doubleFixedToDbl(FFixed f)	{	double 	d;	d=f.l/(double)65536.0;	return(d);	}voidFixedToString(FFixed f,strPtr str,int precision)	{	long	val;	char	fracstr[255];	int	neg = 0,i,j;		if(f.intg < 0) 		{ 		f.intg++; 		f.frac = ~f.frac + 1; 		val = (long)f.frac * 10000 >> 16;			if(!val) f.intg--;#if MACINTOSH		if(f.intg) NumToString((long)f.intg,(StringPtr)str);#elif WINDOWS		if(f.intg) sprintf(str, "%ld", (long)f.intg);#endif // MACINTOSH		else { str[0] = 2; str[1] = '-'; str[2] = '0'; }		}	else		{		val = (long)f.frac * 10000 >> 16;			if(val >= 10000) { f.intg++; val -= 10000; }#if MACINTOSH		NumToString((long)f.intg,(StringPtr)str);#elif WINDOWS		sprintf(str, "%ld", (long)f.intg);#endif // MACINTOSH		}			#if MACINTOSH	NumToString(val,(StringPtr)fracstr);#elif WINDOWS	sprintf(fracstr, "%ld", (long)val);#endif // MACINTOSH	if(precision > fracstr[0]) precision = fracstr[0] +1; else precision++;		str[++(str[0])] = '.';	for(i = 0;i < 4; i++)str[++(str[0])] = '0';		j = str[0];	for(i = fracstr[0]; i > 0; i--)		str[j--] = fracstr[i];	}#define TOKENNUM 6#define IS_ERROR 0#define IS_NUMBER 1#define IS_END	2#define isdigit(c) (c>='0'&& c<='9')int GetToken(string **strHandle,long *tnum,long *bnum);int GetToken(string **strHandle,long *tnum,long *bnum){strPtr str;int i,len,magnitude,type;long n1,n2;double d;while(**strHandle==' ')(*strHandle)++;/*ignore blanks*/str=*strHandle;if(*str==0)return IS_END;if(isdigit(*str))	{	i=0;	while(isdigit(str[i]))i++;	len=i;	*tnum=0;	for(i=0;i<len;i++)		{		*tnum*=10;		*tnum+=(str[i]-'0');		}	*strHandle=str+len;	str=*strHandle;	type=GetToken(&str,&n1,&n2);/*find the other half*/	if(type=='.')		{		*strHandle=str;		magnitude=1;		while(magnitude<n1)magnitude*=10;		*bnum=65536*(double)n1/magnitude;		}	else if (type=='/')		{		*strHandle=str;		d=(double)(*tnum)/(*bnum);		*tnum=d;		*bnum=65536*(d-*tnum);		}	else *bnum=0;	return IS_NUMBER;	}else	switch(*str)		{		case '+': 		case '-': 		case '"': 		case '\'':*strHandle=str+1;	return *str; break;		case '.':			str++;			*strHandle=str;			if(IS_NUMBER!=GetToken(&str,tnum,bnum))				*tnum=0;			else *strHandle=str;/*set to after the number*/			return '.';			break;			case '/':			str++;			*strHandle=str;			if(IS_NUMBER!=GetToken(&str,tnum,bnum))				return IS_ERROR;			else *strHandle=str;/*set to after the number*/			return '/';			break;		default:			return IS_ERROR;/*I don't understand*/		}}/*This routine will parse strings of the following form:in feet:	2  6 1/4	2' 6 1/4"  	2' 6.25"	2  6	2.5'	2.5	30 1/4"		in meters:	2  1025	2.1025	2 1/10our base size is 65536 of an inch*/int String2FFixed(strPtr str,FFixed *fnum,int type){int first=TRUE,notDone=TRUE,neg=FALSE,lastToken=0,t;long total,number,tnum,bnum;int count=0;long ftintg,ftfrac,fbintg,fbfrac;double d;FFixed fval;ftintg=ftfrac=fbintg=fbfrac=0;while(notDone)	{	switch(t=GetToken(&str,&tnum,&bnum))		{		case IS_END:/*we have found the end of the string, start putting it all togethor*/			notDone=FALSE;			break;		case IS_NUMBER:			if(type==METRIC_FORM)notDone=TRUE;			if(count==0)				{				ftintg=tnum;				ftfrac=bnum;				count++;				}			else if(count==1)				{				fbintg=tnum;				fbfrac=bnum;				count++;				}			break;		case '+':/*ignore this unless it is in the middle*/			if(!first)return FALSE;			break;		case '-':			if(!first)return FALSE;			neg=TRUE;			break;		case '.':			break;		case '/':			return FALSE; /*this would be an error*/			break;		case '\'':			if(first)return FALSE;			if(!lastToken==IS_NUMBER)return FALSE;			if(type==METRIC_FORM)return FALSE;			if(count!=1)return FALSE;			break;		case '"':			if(first)return FALSE;			if(!lastToken==IS_NUMBER)return FALSE;			if(type==METRIC_FORM)return FALSE;			if(count==1)/*only the top*/				{				count++;				fbintg=ftintg;				fbfrac=ftfrac;				ftintg=ftfrac=0;				}			notDone=TRUE; /*this is guaranteed to terminate further search*/			break;		case IS_ERROR:			return FALSE;			break;		}	first=FALSE;	lastToken=t;	}if(type==METRIC_FORM)	{	/*need to do conversion!*/	if(ftintg>=32768)return FALSE;	fnum->intg=ftintg;	fnum->frac=ftfrac;	}else	{	if(ftintg>=32768)return FALSE;	if(fbintg>=32768)return FALSE;	fval.intg=12;	fval.frac=0;	fnum->intg=ftintg;	fnum->frac=ftfrac;		*fnum=FFMult(fval,*fnum);	fval.intg=fbintg;	fval.frac=fbfrac;	*fnum=FFAdd(fval,*fnum);	}if(neg)fnum->l=-fnum->l;return TRUE;}int FFixed2String(strPtr str,FFixed fnum,int type){int length,i,count;char neg;long tenThousandths,magnitude,check;int feet,inches,fraction,denominator;FFixed tweak;int lowbit;if(fnum.intg<0)	{	fnum.l=-fnum.l;	str[0]='-';	}else str[0]=' ';str[1]=0;length=1;switch(type&0x0F)	{	case ENGLISH_FORM: 		if(!(PRECISE&type))/*try to tweak to exactness*/			{			lowbit=0x010;			tweak.l=0x010;			fnum.frac&=0xFFF0;			while(fnum.frac&lowbit)				{				fnum=FFAdd(fnum,tweak);				lowbit<<=1;				tweak.l<<=1;				}			}		feet=fnum.intg/12;		if(feet)			sprintf((char *)&str[length],"%d'",feet);		length=strlen((char *)str);		inches=fnum.intg-feet*12;		if(inches)			sprintf((char *)&str[length],"%d ",inches);				length=strlen((char *)str);		if(fnum.frac)			{			if(!((PRECISE&type) ||(fnum.frac&0x0700)))/* if we have a reasonable number (down to 1/32"), use it*/				{				fraction=fnum.frac>>11;				if(fraction)					{					denominator=32;					while(!(fraction&0x01))						{						fraction>>=1;						denominator>>=1;						}					sprintf((char *)&str[length],"%d/%d\"",fraction,denominator);					}				}			else				{				if(inches)str[length-1]='.';				else {str[length]='.';length++;}				tenThousandths=(fnum.frac*10000L)>>16;				magnitude=1000;				for(i=0;i<4;i++)					{					count=0;					check=magnitude;					while(tenThousandths>check)						{						count++;						check+=magnitude;						}					tenThousandths-=check-magnitude;					str[length]='0'+count;					magnitude/=10;					length++;					}				str[length]='"';				length++;				str[length]=0;				}			}		else			{			if(inches==0){str[length]='0'; length++;}			else length--;			str[length]='"';			length++;			str[length]=0;			}		break;	case METRIC_FORM:		fnum=FFMult(fnum,inchToMeter);		sprintf((char *)&str[length],"%d.",fnum.intg);		length=strlen((char *)str);		tenThousandths=(fnum.frac*10000L)>>16;		magnitude=1000;		for(i=0;i<4;i++)			{			count=0;			check=magnitude;			while(tenThousandths>check)				{				count++;				check+=magnitude;				}			tenThousandths-=check-magnitude;			str[length]='0'+count;			magnitude/=10;			length++;			}		str[length]=0;		break;	case DEGREE_FORM:		fnum=FFMult(fnum,degreeToRadian);	case RADIAN_FORM:			sprintf((char *)&str[length],"%d.",fnum.intg);		length=strlen((char *)str);		tenThousandths=(fnum.frac*10000L)>>16;		magnitude=1000;		for(i=0;i<4;i++)			{			count=0;			check=magnitude;			while(tenThousandths>check)				{				count++;				check+=magnitude;				}			tenThousandths-=check-magnitude;			str[length]='0'+count;			magnitude/=10;			length++;			}		if((type&0x0F) == DEGREE_FORM)			str[length]='';		else str[length]='r';		length++;		str[length]=0;		break;	}}