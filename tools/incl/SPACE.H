#ifndef VSPACE#define VSPACE#include "VMath.h"typedef int matrix[3][3] ;struct Space:indirect	{	matrix m;	char	pinState;		/* --- */		Space * cSpace(void);	void dSpace(void);	void Normalize(void);	void Roll(int);	void Pitch(int);	void Yaw(int);	void DRoll(double);	void DPitch(double);	void DYaw(double);	void Update(int x, int y, int dx, int dy, int dd);	void Trans(int x, int y, int z, int *nx, int *ny, int *nz);	void SetMatrix(matrix);	void GetMatrix(matrix);	void Multiply(Space *);	void AngleToMatrix(double ,double ,double );	void MatrixToAngle(double *,double *,double *);	void SetPin(int);	int GetPin(void);	};#define fLongMult(r,s1,s2) {r=(long)s1*s2; r += 8192; r>>=14;}#define A 0 /* These are indices into the vector array, v */#define B 1#define C 2#define X 0#define Y 1#define Z 2/* NewX, NewY, and NewZ return the rotated coordinates */#define NewX(nx,m,x,y,z) {	\	int qa,qb;				\	long qx,qy,qz;			\	qa = x;					\	qb = m[A][X];			\	fLongMult(qx,qa,qb);	\	qa = y;					\	qb = m[B][X];			\	fLongMult(qy,qa,qb);	\	qa = z;					\	qb = m[C][X];			\	fLongMult(qz,qa,qb);	\	nx = (qx + qy + qz);		}#define NewY(ny,m,x,y,z) {	\	int qa,qb;				\	long qx,qy,qz;			\	qa = x;					\	qb = m[A][Y];			\	fLongMult(qx,qa,qb);	\	qa = y;					\	qb = m[B][Y];			\	fLongMult(qy,qa,qb);	\	qa = z;					\	qb = m[C][Y];			\	fLongMult(qz,qa,qb);	\	ny = (qx + qy + qz);		}#define NewZ(nz,m,x,y,z) {	\	int qa,qb;				\	long qx,qy,qz;			\	qa = x;					\	qb = m[A][Z];			\	fLongMult(qx,qa,qb);	\	qa = y;					\	qb = m[B][Z];			\	fLongMult(qy,qa,qb);	\	qa = z;					\	qb = m[C][Z];			\	fLongMult(qz,qa,qb);	\	nz = (qx + qy + qz);		}/* OldX, OldY, and OldZ return the un-rotated coordinates */#define OldX(nx,m,x,y,z) {	\	int qa,qb;				\	long qx,qy,qz;			\	qa = x;					\	qb = m[A][X];			\	fLongMult(qx,qa,qb);	\	qa = y;					\	qb = m[A][Y];			\	fLongMult(qy,qa,qb);	\	qa = z;					\	qb = m[A][Z];			\	fLongMult(qz,qa,qb);	\	nx = (qx + qy + qz);	}#define OldY(ny,m,x,y,z) {	\	int qa,qb;				\	long qx,qy,qz;			\	qa = x;					\	qb = m[B][X];			\	fLongMult(qx,qa,qb);	\	qa = y;					\	qb = m[B][Y];			\	fLongMult(qy,qa,qb);	\	qa = z;					\	qb = m[B][Z];			\	fLongMult(qz,qa,qb);	\	ny = (qx + qy + qz);	}#define OldZ(nz,m,x,y,z) {	\	int qa,qb;				\	long qx,qy,qz;			\	qa = x;					\	qb = m[C][X];			\	fLongMult(qx,qa,qb);	\	qa = y;					\	qb = m[C][Y];			\	fLongMult(qy,qa,qb);	\	qa = z;					\	qb = m[C][Z];			\	fLongMult(qz,qa,qb);	\	nz = (qx + qy + qz);	}/* FFOldX, FFOldY, and FFOldZ return the un-rotated coordinates of FFixed points*/#define FFOldX(nx,m,x,y,z) {	\	int q;						\	FFixed qx,qy,qz;			\	qx = x;						\	q = m[A][X];				\	qx=FFMultIntShift(qx,q,14);	\	qy = y;						\	q = m[A][Y];				\	qy=FFMultIntShift(qy,q,14);	\	qz = z;						\	q = m[A][Z];				\	qz=FFMultIntShift(qz,q,14);	\	nx = FFAdd(FFAdd(qx,qy),qz);}#define FFOldY(ny,m,x,y,z) {	\	int q;						\	FFixed qx,qy,qz;			\	qx = x;						\	q = m[B][X];				\	qx=FFMultIntShift(qx,q,14);	\	qy = y;						\	q = m[B][Y];				\	qy=FFMultIntShift(qy,q,14);	\	qz = z;						\	q = m[B][Z];				\	qz=FFMultIntShift(qz,q,14);	\	ny = FFAdd(FFAdd(qx,qy),qz);}#define FFOldZ(nz,m,x,y,z) {	\	int q;						\	FFixed qx,qy,qz;			\	qx = x;						\	q = m[C][X];				\	qx=FFMultIntShift(qx,q,14);	\	qy = y;						\	q = m[C][Y];				\	qy=FFMultIntShift(qy,q,14);	\	qz = z;						\	q = m[C][Z];				\	qz=FFMultIntShift(qz,q,14);	\	nz = FFAdd(FFAdd(qx,qy),qz);}#define Rot(coord,nx,m,x,y,z) {	\	int qa,qb;				\	long qx,qy,qz;			\	qa = x;					\	qb = m[A][coord];		\	fLongMult(qx,qa,qb);	\	qa = y;					\	qb = m[B][coord];		\	fLongMult(qy,qa,qb);	\	qa = z;					\	qb = m[C][coord];		\	fLongMult(qz,qa,qb);	\	nx = (qx + qy + qz);	}#define PIN_R 	0x01#define PIN_P 	0x02#define PIN_Y 	0x04#endif //VSPACE