/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "WalkList.h"#include "Cntrl.h"#include "AppMssgs.h"#include "AppDeflt.h"#include "ToolDef.h"#include "VGraphic.h"#include "VGUtil.h"#include "VDialog.h"#include "AppText.h"	//PRO-JAP#include <stdio.h>#include <string.h>#define LAYER_INDENT	3#define SCROLL_WIDTH	8void WalkList::cPane(int flag)	{	controller = NULL;		LayerList::cPane(flag);		SetVScroll();	SetBarWidth(SCROLL_WIDTH);	Draggable(TRUE);	}void WalkList::SetController(Controller *ctrl)	{	controller = ctrl;	}void WalkList::SetList(V_Array *newList)	{	EditItem *litm;	/*	if(theList == newList) return;		if(theList)theList->dArray();*/	theList = newList;	if(theList->ALength())		{		SetSelection(0);		litm = (EditItem *)GetCurrentItem();	// ABD added coersion 8/12/93		litm->SetHilite(TRUE);		}	}void WalkList::CalcSize(Rect *r,Point *p,int type,int warning)	{	controller->GetPlace(r,warning,toolLList);#if MACINTOSH	r->left += LAYER_INDENT;	r->top += LAYER_INDENT;	r->bottom -= LAYER_INDENT;	r->right -= LAYER_INDENT;#endif	}int listOffscr = FALSE;void WalkList::Display(int type,int x,int y)	{	Rect		data,gRect,r;	switch(type)		{		case SCROLL_DRAW:			LayerList::Display(type,x,y);			break;				default:				r = dataRect;			gRect = dataRect;			if(listOffscr)				{				SetMetaPort();				}				#if MACINTOSH			gRect.top-=LAYER_INDENT;			gRect.bottom+=LAYER_INDENT;			gRect.left-=LAYER_INDENT;			gRect.right+=(SCROLL_WIDTH+LAYER_INDENT);			VClipRect(&gRect);#endif			if(4 > depth)				VEraseRect(&gRect);			else				{				VForeColor(&vColorSlateM);				VPaintRect(&gRect);				}				#if MACINTOSH			VClipRect(&r);#endif			LayerList::Display(type,x,y);#if MACINTOSH			VClipRect(&gRect);#endif			VForeColor(&vBlack);			r = dataRect;			r.left--;			r.top--;			r.right+=SCROLL_WIDTH;			VMoveTo(r.left,r.top);			VLineTo(r.left,r.bottom);			VLineTo(r.right,r.bottom);			VLineTo(r.right,r.top);			VLineTo(r.left,r.top);			r.bottom++;			r.right++;			VMoveTo(r.left+1,r.bottom);			VLineTo(r.right,r.bottom);			VLineTo(r.right,r.top+1);							if(listOffscr)				{				MetaCopy(&gRect);				UnsetMetaPort(); 				}							break;		}			}	void WalkList::MouseDown(Point p,long modifiers)	{	delayTime = VGetTime();	doPopUp = TRUE;	LayerList::MouseDown(p,modifiers);	}voidWalkList::Track(Point p,long modifiers,int lastCall)	{	VSetCursor(vCursorArrow);	if((buttonDown & modifiers) && !dragging && (appDelayTime < (VGetTime() - delayTime)))		{		p.h += 5;		MenuSelection(p,modifiers);		doPopUp = FALSE;		}	else		LayerList::Track(p,modifiers,lastCall);	}void WalkList::MouseUp(Point p,long modifiers)	{	doPopUp = FALSE;	LayerList::MouseUp(p,modifiers);	}voidWalkList::SetVScroll()	{	SetVPage(5);		SetVMove(1);		}intWalkList::GetHeight()	{	return(LIST_MAGIC_HEIGHT);	}/*========================================================================= * int WalkList::GetAction(long action,long modifiers) *-------------------------------------------------------------------------*/int WalkList::GetAction(long action,long modifiers)	{		switch(action)		{		case MSG_NEWLAYER: controller->Request(NULL,msgCreate,objList,0); break;		case MSG_DELLAYER: controller->Request(NULL,msgDestroy,objList,0); break;		default: return(FALSE); break;		}			return(TRUE);	}	/*========================================================================= * int WalkList::AddItem() * int WalkList::RemoveItem() *-------------------------------------------------------------------------*/int WalkList::AddItem()	{ return(FALSE); }int WalkList::RemoveItem()	{ 	EditItem 		*item;	int				newSelection;	if(!theList->ALength()) return(FALSE);		if(item = (EditItem *)GetCurrentItem())		// ABD added coercion 8/12/93		{		theList->Remove(selection);		item->dListItem();		newSelection = selection - 1;		if(theList->ALength() && (0 > newSelection))			newSelection = 0;		SetSelection(newSelection);		}		Reset();	return(TRUE); 	}/*========================================================================= * void WalkList::GetDefaultName(char *str) *-------------------------------------------------------------------------*/void WalkList::GetDefaultName(char *str)	{		strcpy(str,TXT_DEFAULT);	// PRO-JAP	}	/*========================================================================= * int WalkList::ListName(char *str) *-------------------------------------------------------------------------*/int WalkList::ListName(char *str)	{		InputTextDialog *dialog = new(InputTextDialog);	dialog->cInputDialog("",TXT_LAYER_NAME,str,inputText);		// PRO-JAP//should have been rederived. //GJR 092493	}/*========================================================================= * void WalkList::MenuSelection(Point p,long modifiers) * This method sets up the pop up menu *-------------------------------------------------------------------------*/void WalkList::MenuSelection(Point p,long modifiers)	{	}voidListMenu::ctheMenu(EditItem *item,int inColor)	{	}voidListMenu::dtheMenu()	{	delete(this);	}