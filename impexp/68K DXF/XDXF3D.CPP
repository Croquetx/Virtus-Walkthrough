/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	 *				David W. Easter *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File: * Notes: * History: *------------------------------------------------------------------------------ add our own DXF-writing routines.  jca April 95 unresolved questions:  in WriteDXFPolyline: 	// should the pline flag for 3D be a pref, since none of our 3D polylinesare truly	// 3D polylines? (they're just 2D polyines in 3D space.  True 3D polylinescan be	// nonplanar)  QUIBBLE-1 jca 14APR95		  in OpenSurface:	// to emulate Ken's DXF output, cap the extruded polyline at both ends.	// This is more true 3D, but unlike some importers (form*Z, I think)	// QUIBBLE-2 jca 14APR95	if (1) // if (capExtruded) ?	  should we have options for splitting into quads or triangles, or forcontrolling the  splitting techniques?  can we find a better color map? */#include "VTypes.h"#if VWT// jca 17 Sept 93 {#include "XDXF3D.h"#include "Polyhdrn.h"#include "Surface.h"#include "SurfDef.h"#include "WalkBuff.h"#include "AppFiles.h"#include "AppText.h"#include "VArray.h"#include "VDialog.h"#include "VIO.h"#include "VMath.h"#include <stdio.h>#include <string.h>#include "BClrCnvt.h"voidExport_DXF3D::cExport()	{	ModelExport::cExport();	lineTermId = eMac;	colorMode = eByLayer;	geomStyle = e3DPolyline;	strcpy(lineTermination, TXT_MAC_LT);	extrude = TRUE;	layerList = NULL;	polyPoints = NULL;	polyLayer = 0;	polyColor.red = 0;	polyColor.green = 0;	polyColor.blue = 0;	polyColor.alpha = 0;	extrudable = 0;	baseSurf = NULL;	polyhedron = NULL;	surface = NULL;		colorMapper = NULL;	}voidExport_DXF3D::dExport()	{	ModelExport::dExport();		if (polyPoints)		polyPoints->dArray();		if (layerList)		layerList->dArray();		if (colorMapper)		colorMapper->dColorConverter();		polyPoints = NULL;	layerList = NULL;	colorMapper = NULL;	}voidExport_DXF3D::Options3D(int os, int clr, int geo, int extr)	{	lineTermId = os;	colorMode = clr;	geomStyle = geo;	extrude = extr;		switch(os)		{		case eMac:			strcpy(lineTermination, TXT_MAC_LT);			break;		case eUnix:			strcpy(lineTermination, TXT_UNIX_LT);			break;		case eDos:		default:			strcpy(lineTermination, TXT_DOS_LT);			break;		}	}int GetVersion(strPtr);intExport_DXF3D::Open(V_Buffer *buf, ExportUnit type, double size)	{	char string[256], version[256];	V_Array *acadColorMap;	int	i;		ModelExport::Open(buf, type, size);	/* step one:  can we allocate all that color remapping stuff? */	acadColorMap = new(V_Array);	acadColorMap->cArray(255, sizeof(RGBColor), 16);		DXFFillColorMap(acadColorMap);		colorMapper = new(TrueToPalConverter);	if (colorMapper->cColorConverter(acadColorMap, 24, 8, 4, RGB_ORDER))		{		AlertMessage(TXTW_MEMORY);		return(-1);		}	strcpy(string, TXTD_DXFHEADER);	if (GetVersion(version))		{		strcat(string, " v");		strcat(string, version);		}	OpenDXFFile();	WriteDXFHeader(string);		return(0);	}intExport_DXF3D::Close()	{	CloseDXFEntitiesSection();	CloseDXFFile();		ModelExport::Close();	return(0);	}intExport_DXF3D::Layers(V_Array *layers)	{	WriteDXFTables(layers);		layerList = new(V_Array);	layerList->cArray(0, sizeof(Layer), 4);	layers->CopyArray(layerList);	// keep a local copy		OpenDXFEntitiesSection();			return(0);	}voidExport_DXF3D::SetPolyhedron(Polyhedron *poly)	{	polyhedron = poly;	}intExport_DXF3D::OpenPolyhedron(V_Array *points, RGBAColor color, int layer)	{	polyPoints = new(V_Array);	polyPoints->cArray(0, sizeof(Point3DFFixed), 4);	TransformPoints(points, polyPoints);	polyLayer = layer;	polyColor = color;	extrudable = extrude && PolyExtrudable();	baseSurf = polyhedron->FindSurface(polyhedron->SurfCount()-1);	return(0);	}intExport_DXF3D::ClosePolyhedron()	{	polyPoints->dArray();	polyPoints = NULL;		return(ModelExport::ClosePolyhedron());	}voidExport_DXF3D::SetSurface(Surface *surf)	{	surface = surf;	}intExport_DXF3D::OpenSurface(V_Array *pointRefs, RGBAColor color,Point3DFFixed normal)	{	V_Array *surfPoints;	FFixed extrusion;	RGBColor dxfColor;	if (extrudable && surface != baseSurf)		return(0);			surfPoints = new(V_Array);	surfPoints->cArray(0, sizeof(Point3DFFixed), 4);	DerefPoints(polyPoints, pointRefs, surfPoints);	dxfColor.red = color.red;	dxfColor.green = color.green;	dxfColor.blue = color.blue;		if (extrudable)		{		int i, ptListLen;		Point3DFFixed	*pt3DFF, extrusionOffset;			extrusion = FFSub(polyhedron->point, polyhedron->base);		if (FFNegative(extrusion))			extrusion = FFNeg(extrusion);					WriteDXFPolyline(surfPoints, dxfColor, extrusion);						// to emulate Ken's DXF output, cap the extruded polyline at both ends.		// This is more true 3D, but unlike some importers (form*Z, I think)		// QUIBBLE-2 jca 14APR95		if (1) // if (capExtruded) ?			{			WriteDXFPolyline(surfPoints, dxfColor, FFZero);	// write the base						// now extrude the points (this must be *last* time we use surfPoints,			// since doing this spoils the points)			ptListLen = surfPoints->ALength();			pt3DFF = (Point3DFFixed*) surfPoints->Use();						/* calculate the offset.  This is equal to the extrusion * normal			   why?  (actually, this took me a long time to work out)						   		a normal is calculated as (I'll just use x.  Y and z are left as			   		an exercise to the reader)			   								   			x(n)  =  x / sqrt(x^2 + y^2 + z^2)			   						   		Actually, sqrt(x^2 + y^2 + z^2) is the distance of the vector, so			   		substitute:			   					   			x(n) = x / dist		   						   			Redistributing to solve for x:		   					   				x = dist * x(n)			   								   		QED.			*/			// Yes, but the normal is not [0..1] but [0..256], so we have to			// normalize the normal.			extrusionOffset.x = FFMult(extrusion, FFShift(normal.x, -8));			extrusionOffset.y = FFMult(extrusion, FFShift(normal.y, -8));			extrusionOffset.z = FFMult(extrusion, FFShift(normal.z, -8));						// actually, I think the normal points the wrong way for my extrusion...			// have to look into this.  Yup it does.  *Subtract* the offset.			for (i = 0; i < ptListLen; pt3DFF++, i++)				{				pt3DFF->x = FFSub(pt3DFF->x, extrusionOffset.x);				pt3DFF->y = FFSub(pt3DFF->y, extrusionOffset.y);				pt3DFF->z = FFSub(pt3DFF->z, extrusionOffset.z);				}			surfPoints->Unuse();							WriteDXFPolyline(surfPoints, dxfColor, FFZero);	// write the top			}		}	else		{		if (geomStyle == e3DFace)			WriteDXF3DFace(surfPoints, dxfColor);		else			WriteDXFPolyline(surfPoints, dxfColor, FFZero);					}	surfPoints->dArray();	surfPoints = NULL;		return(0);	}intExport_DXF3D::OpenFeature(V_Array *points, RGBAColor color, int where, intconnected)	{	V_Array *featPoints;	RGBColor dxfColor;	if (connected) return(0);	featPoints = new(V_Array);	featPoints->cArray(0, sizeof(Point3DFFixed), 4);	TransformPoints(points, featPoints);	dxfColor.red = color.red;	dxfColor.green = color.green;	dxfColor.blue = color.blue;	if (geomStyle == e3DFace)		WriteDXF3DFace(featPoints, dxfColor);	else		WriteDXFPolyline(featPoints, dxfColor, FFZero);					featPoints->dArray();	return(0);	}voidExport_DXF3D::Transform(void *in, void *out)	{	Point3DFFixed *pIn = (Point3DFFixed*)in, *pOut = (Point3DFFixed*)out;	*pOut = *pIn;	}intExport_DXF3D::PolyExtrudable()	{	if (polyhedron->inflate != INFL_EXTRUDE)		return(FALSE);	if (!PtFFZero(polyhedron->pointSkew) || !PtFFZero(polyhedron->baseSkew))		return(FALSE);	if (polyhedron->slices != NULL && polyhedron->slices->ALength() != 0)		return(FALSE);	if (polyhedron->surfDef)		{		int nSurfDefs, i;		SurfDef **sDef;		nSurfDefs = polyhedron->surfDef->ALength();		sDef = (SurfDef **)polyhedron->surfDef->Use();			for (i = 0; i < nSurfDefs; i++, sDef++)			{			if (*sDef && ((*sDef)->flags & SDEF_COLOR))				break;			}			polyhedron->surfDef->Unuse();			if (i != nSurfDefs)			return(FALSE);		}	return(TRUE);	}void	Export_DXF3D::WriteDXFHeader(char *version)	{	OpenDXFSection();	DXFWriteLabel(DXF_LABEL, TXT_DXF_HEADER);	DXFWriteLabel(999, TXT_DXF_BLURB);	DXFWriteLabel(999, version);	CloseDXFSection();	}	void	Export_DXF3D::WriteDXFTables(V_Array *layerL)	{	int nLayers = layerL->ALength(), i;	long flags;	Layer *layer;	OpenDXFSection();	DXFWriteLabel(DXF_LABEL, TXT_DXF_TABLES);	DXFWriteLabel(DXF_START, TXT_DXF_TABLE);	DXFWriteLabel(DXF_LABEL, TXT_DXF_LAYER);	DXFWriteLong(DXF_FLAGS, nLayers);	DXFWriteLabel(DXF_START, TXT_DXF_TABLE);	layer = (Layer *)layerL->Use();	for (i = 0; i < nLayers; i++, layer++)		{				DXFWriteLabel(DXF_LABEL, layer->name);				DXFWriteLong(DXF_FLAGS, DXF_LAYERF_OK);	// no AutoCAD flag for "locked"												// actually, release 12 has 0x04 for locked.				DXFWriteLayerColor(layer->color, !(layer->state & visible));				DXFWriteLabel(DXF_LINETYPE, TXT_DXF_CONTINUOUS);		}	layerL->Unuse();		DXFWriteLabel(DXF_START, TXT_DXF_ENDTAB);	CloseDXFSection();	}	void 	Export_DXF3D::WriteDXFBlocks(void)	{	OpenDXFSection();	DXFWriteLabel(DXF_LABEL, TXT_DXF_BLOCKS);	CloseDXFSection();	}void	Export_DXF3D::WriteDXFPolyline(V_Array *points, RGBColor dxfColor, FFixedheightFF)	{	long	plineFlags = DXF_PLF_CLOSED;	double	height;	int		extrudedPline, i, nPoints;	Point3DFFixed	*pt3DFF;		nPoints = points->ALength();	if (nPoints < 3)		return; // degenerate case		// should the pline flag for 3D be a pref, since none of our 3D polylines are truly	// 3D polylines? (they're just 2D polyines in 3D space.  True 3D polylines can be	// nonplanar)  QUIBBLE-1 jca 14APR95		if (FFZero(heightFF))		{		extrudedPline = FALSE;		plineFlags |= DXF_PLF_3D;		}	else		extrudedPline = TRUE;				height = FixedToDbl(heightFF);		DXFWriteLabel(DXF_START, TXT_DXF_POLYLINE);	DXFWriteLayer(polyLayer);	DXFWriteColor(dxfColor);		if (extrudedPline)		DXFWriteDouble(DXF_THICKNESS, height);			DXFWriteLong(DXF_FLAGS, plineFlags);	DXFWriteLong(DXF_POLYLINE_VERTEX, DXF_PLF_VERTEX);		pt3DFF = (Point3DFFixed *) points->Use();	for (i = 0; i < nPoints; i++, pt3DFF++)		{		DXFWritePolylineVertex(i, !(extrudedPline), height, pt3DFF, dxfColor);		}	points->Unuse();	DXFWriteLabel(DXF_START, TXT_DXF_SEQEND);	}void	Export_DXF3D::WriteDXF3DFace(V_Array *points, RGBColor dxfColor)	{	int nPoints = points->ALength();	Point3DFFixed *pt3DFF;		pt3DFF = (Point3DFFixed *) points->Use();	if (nPoints > 4)		{	//break up into quads/tris		int i, n;		long flags;				i = 1; n = 0;		while (i < nPoints - 1)			{			flags = 0;						if (n > 0)				flags |= 0x01;	// first edge is invisible if not first face							if (nPoints - i > 3)				flags |= 0x08;	// last edge invisible if not last face							DXFWriteLabel(DXF_START, TXT_DXF_3DFACE);			DXFWriteLayer(polyLayer);			DXFWriteColor(dxfColor);			DXFWriteLong(DXF_FLAGS, flags);			DXFWrite3DFaceVertex(0, &pt3DFF[0]);			DXFWrite3DFaceVertex(1, &pt3DFF[i]);			DXFWrite3DFaceVertex(2, &pt3DFF[i+1]);			if (nPoints - i > 2)				{				DXFWrite3DFaceVertex(3, &pt3DFF[i+2]);				i += 2;				}			else				{				DXFWrite3DFaceVertex(3, &pt3DFF[i+1]);				i += 1;				}							n++;			}		}	else if (nPoints > 2)		{		DXFWriteLabel(DXF_START, TXT_DXF_3DFACE);		DXFWriteLayer(polyLayer);		DXFWriteColor(dxfColor);		DXFWriteLong(DXF_FLAGS, DXF_FLAGS_NONE);		DXFWrite3DFaceVertex(0, &pt3DFF[0]);		DXFWrite3DFaceVertex(1, &pt3DFF[1]);		DXFWrite3DFaceVertex(2, &pt3DFF[2]);		if (nPoints == 4)			DXFWrite3DFaceVertex(3, &pt3DFF[3]);		else			DXFWrite3DFaceVertex(2, &pt3DFF[2]);		}	// else do nothing...		points->Unuse();	}	void	Export_DXF3D::DXFWritePolylineVertex(int code, int threeD, doublethickness, Point3DFFixed *pt, RGBColor rgb)	{	double x, y, z;	long	vertexFlags = 0;		DXFWriteLabel(DXF_START, TXT_DXF_VERTEX);	DXFWriteLayer(polyLayer);	DXFWriteColor(rgb);		if (threeD)		vertexFlags |= DXF_VRTXF_3D;	else		DXFWriteDouble(DXF_THICKNESS, thickness);	DXFWriteLong(DXF_FLAGS, vertexFlags);		x = FixedToDbl(pt->x);	y = FixedToDbl(pt->y);	z = FixedToDbl(pt->z);		DXFWriteDouble(DXF_VERTEX_X, x);	DXFWriteDouble(DXF_VERTEX_Y, y);	DXFWriteDouble(DXF_VERTEX_Z, z);	}void	Export_DXF3D::DXFWrite3DFaceVertex(int code, Point3DFFixed *pt)	{	double x, y, z;			x = FixedToDbl(pt->x);	y = FixedToDbl(pt->y);	z = FixedToDbl(pt->z);		DXFWriteDouble(DXF_VERTEX_X + code, x);	DXFWriteDouble(DXF_VERTEX_Y + code, y);	DXFWriteDouble(DXF_VERTEX_Z + code, z);	}	voidExport_DXF3D::DXFWriteLayer(int layerId)	{	int nLayers, layerNumber;	Layer *layerItem;		if (!layerList)		return; // bad			nLayers = layerList->ALength();		if ((layerId < 0) || (layerId >= nLayers))		layerNumber = 0;	else		layerNumber = layerId;			layerItem = (Layer*)layerList->Abuse();	DXFWriteLabel(DXF_LAYER, layerItem[layerNumber].name);	}void		Export_DXF3D::DXFWriteColor(RGBColor rgbColor)	{	long color;		if (colorMode == eByObject)		{		color = 1 + colorMapper-> MatchColor(&rgbColor);  // colors are 1-based			DXFWriteLong(DXF_COLOR, color);		}	}void		Export_DXF3D::DXFWriteLayerColor(RGBColor rgbColor, int invisible)	{	long color;			color = 1 + colorMapper-> MatchColor(&rgbColor);  // colors are 1-based			DXFWriteLong(DXF_COLOR, (invisible ? -color : color));	}void	Export_DXF3D::DXFWriteLong(int id, long l)	{	sprintf(localBuffer, "%3d%s%ld%s", id, lineTermination, l, lineTermination);	buffer->IOData(localBuffer, strlen(localBuffer));	}	voidExport_DXF3D::DXFWriteDouble(int id, double longFloat)	{	sprintf(localBuffer, "%3d%s%lg%s", id, lineTermination, longFloat, lineTermination);	buffer->IOData(localBuffer, strlen(localBuffer));	}	void	Export_DXF3D::DXFWriteLabel(int id, char *label)	{	sprintf(localBuffer, "%3d%s%s%s", id, lineTermination, label, lineTermination);	buffer->IOData(localBuffer, strlen(localBuffer));	}	voidExport_DXF3D::DXFFillColorMap(V_Array *cMap)	{	int i;	RGBColor *rgb;	UShort one[10] ={0xFFFF,0xFFFF,0xA6A6,0xA6A6,0x7F7F,0x7F7F,0x4C4C,0x4C4C,0x2626,0x2626};	UShort two[10] ={0x0000,0x7F7F,0x0000,0x5353,0x0000,0x3F3F,0x0000,0x1313,0x0000,0x1313};	UShort three[10] ={0x3F3F,0x9F9F,0x2929,0x6767,0x1F1F,0x4F4F,0x1313,0x2F2F,0x909,0x1717};	UShort four[10] ={0x7F7F,0xBFBF,0x5353,0x7C7C,0x3F3F,0x5F5F,0x2626,0x3939,0x1313,0x1C1C};	UShort five[10] ={0xBFBF,0xDFDF,0x7C7C,0x9191,0x5F5F,0x6F6F,0x3939,0x4343,0x1C1C,0x2121};	UShort grey[6] = {0x3232,0x5454,0x7676,0x9999,0xBBBB,0xDDDD};		RGBColor rgbTable[9] = { /* one trough 7 are traditional colors; 8 and 9are odd */					{ 0xFFFF, 0x0000, 0x0000 },	/* red */					{ 0xFFFF, 0xFFFF, 0x0000 }, /* yellow */					{ 0x0000, 0xFFFF, 0x0000 }, /* green */					{ 0x0000, 0xFFFF, 0xFFFF }, /* cyan */					{ 0x0000, 0x0000, 0xFFFF }, /* blue */					{ 0xFFFF, 0x0000, 0xFFFF }, /* magenta */					{ 0xFFFF, 0xFFFF, 0xFFFF }, /* white */					{ 0x0000, 0x0000, 0x0000 }, /* black */					{ 0x0000, 0x0000, 0xFFFF }, /* blue */					};						rgb = (RGBColor *) cMap->Use();	for (i = 0 ; i < 9; i++, rgb++)		*rgb = rgbTable[i];			for (i = 0; i < 10; i++, rgb++)	// 10 red		SetRGBColor(rgb, one[i], two[i], two[i]);			for (i = 0; i < 10; i++, rgb++) // 20 reddish-orange		SetRGBColor(rgb, one[i], three[i], two[i]);			for (i = 0; i < 10; i++, rgb++) // 30 orange		SetRGBColor(rgb, one[i], four[i], two[i]);			for (i = 0; i < 10; i++, rgb++) // 40 yellowish-orange		SetRGBColor(rgb, one[i], five[i], two[i]);			for (i = 0; i < 10; i++, rgb++) // 50 yellow		SetRGBColor(rgb, one[i], one[i], two[i]);			for (i = 0; i < 10; i++, rgb++) // 60 yellows, two		SetRGBColor(rgb, three[i], one[i], two[i]);			for (i = 0; i < 10; i++, rgb++) // 70 yellow-green		SetRGBColor(rgb, four[i], one[i], two[i]);			for (i = 0; i < 10; i++, rgb++) // 80 yellow-greens, two		SetRGBColor(rgb, five[i], one[i], two[i]);			for (i = 0; i < 10; i++, rgb++) // 90 green		SetRGBColor(rgb, two[i], one[i], two[i]);			for (i = 0; i < 10; i++, rgb++) // 100 greens, two		SetRGBColor(rgb, two[i], one[i], three[i]);			for (i = 0; i < 10; i++, rgb++) // 110 aquamarine		SetRGBColor(rgb, two[i], one[i], four[i]);			for (i = 0; i < 10; i++, rgb++) // 120 aquamarines, two		SetRGBColor(rgb, two[i], one[i], five[i]);			for (i = 0; i < 10; i++, rgb++) // 130 cyan		SetRGBColor(rgb, two[i], one[i], one[i]);			for (i = 0; i < 10; i++, rgb++) // 140 cyans. two		SetRGBColor(rgb, two[i], three[i], one[i]);			for (i = 0; i < 10; i++, rgb++) // 150 turquoise		SetRGBColor(rgb, two[i], four[i], one[i]);			for (i = 0; i < 10; i++, rgb++) // 160 turquoises, two		SetRGBColor(rgb, two[i], five[i], one[i]);			for (i = 0; i < 10; i++, rgb++) // 170 blue		SetRGBColor(rgb, two[i], two[i], one[i]);			for (i = 0; i < 10; i++, rgb++) // 180 blues, two		SetRGBColor(rgb, three[i], two[i], one[i]);			for (i = 0; i < 10; i++, rgb++) // 190 purple		SetRGBColor(rgb, four[i], two[i], one[i]);			for (i = 0; i < 10; i++, rgb++) // 200 purples, two		SetRGBColor(rgb, five[i], two[i], one[i]);			for (i = 0; i < 10; i++, rgb++) // 210 magenta		SetRGBColor(rgb, one[i], two[i], one[i]);			for (i = 0; i < 10; i++, rgb++) // 220 magentas, two		SetRGBColor(rgb, one[i], two[i], three[i]);			for (i = 0; i < 10; i++, rgb++) // 230 maroon		SetRGBColor(rgb, one[i], two[i], four[i]);			for (i = 0; i < 10; i++, rgb++) // 240 maroons, two		SetRGBColor(rgb, one[i], two[i], five[i]);	for (i = 0; i < 6; i++, rgb++)		SetRGBColor(rgb, grey[i], grey[i], grey[i]);		cMap->Unuse();	}	// jca 17 Sept 93 }#endif // VWT