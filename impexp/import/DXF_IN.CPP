/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	 *				David W. Easter *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#if VWT /* jca 17 Sept 93.  Not in VR { */#include "DXF_IN.h"#include "DXFINCOM.h"#include "WalkThru.h"#include "CVWCntrl.h"#include "CVLItem.h"#include "CVDraw.h"#include "CVPolyh.h"#include "SurfDef.h"#include "WalkDefs.h"#include "AppDeflt.h"#include "ScoreCrd.h"#include "VMath.h"#include "VWindow.h"#include "VFile.h"#include "VGraphic.h"#include "AppText.h"	//PRO-JAP#include <string.h>V_Document *documentX;CAVWalkController *controllerX;CAVDrawing *dwgX;short importFlagsX;ScoreRecord scorRec;voidImport1(V_File *file)	{	ScoreCard  *scoreCard;	AppPreference *appPreference;	TranslatorPreference *transPref;#if MACINTOSH	WindowPeek window;	SFReply reply;	MakeSFReply(&reply,file);	window = MyFrontWindow();	if (window == NULL) window = (WindowPeek)FrontWindow();	documentX = ((V_Window *)GetWRefCon((WindowPtr)window))->theDocument;#elif WINDOWS	char fileName[256];	MakeFileName(fileName,file);    documentX = GetCurrentDocument();#endif //MACINTOSH	controllerX = pwc(pdc(documentX)->walkController);	dwgX = (CAVDrawing*)controllerX->drawing;	scorRec.type = format3DDXF;	scorRec.dxfRec.numConstructed = 0;	scorRec.dxfRec.numSurfUsed = 0;	scorRec.dxfRec.numSurfDiscard = 0;		appPreference = controllerX->GetPreference();	transPref = (TranslatorPreference*)appPreference->GetPreference(preferTranslator);	importFlagsX = transPref->importFlag;	dxfinOptions = 0;	if (importFlagsX & IMPORT_PATCH) dxfinOptions |= DXFIN_PATCHALL;	if (importFlagsX & IMPORT_NONCONVEX) dxfinOptions |= DXFIN_TESTCONVEX;#if MACINTOSH#ifndef __powerc	Import(&reply); /* Ken's DXF import function */#endif //__powerc#elif WINDOWS	Import(fileName); /* Ken's DXF import function */#endif //WINDOWS	controllerX->Request(NULL,msgInit,objIO,0);		scorRec.dxfRec.numSurfDiscard -= scorRec.dxfRec.numSurfUsed;	scoreCard = new(ScoreCard);	scoreCard->cScoreCard(TXT_3D_DXF_STATUS,&scorRec);		// PRO-JAP	}#if MACINTOSHvoidMakeSFReply(SFReply *reply, V_File *file)	{	memset(reply, 0, sizeof(SFReply));	memcpy(reply->fName, file->filname, 64);	reply->vRefNum = file->pblk.ioVRefNum;	reply->version = file->pblk.ioVersNum;	reply->good = TRUE;	}#elif WINDOWSvoidMakeFileName(char *fileName, V_File *file)	{	file->GetFullPathStr(fileName);			//remove platform args		//GJR 10/06/93	}#endif //WINDOWS	//// Add a polyhedron to the model. Called by// Ken's Import() function.//intNewPoly(Point3DFFixed *points, int nPoints,	short **surfaces, int nSurfaces, short *nSurfPoints,	RGBAColor *colors, long status)	{	CAVPolyhedron *poly;	V_Array *p, *s, *sp;	LayerItem	*li;	Point3DFFixed *pnt;	short *spnt;	Point3DFFixed origin;	RGBColor color;	int i;	scorRec.dxfRec.numSurfDiscard += nSurfaces;	if ((importFlagsX & IMPORT_NONCONVEX) && !(status & DXFIN_CONVEX)) return TRUE;	if ((importFlagsX & IMPORT_DEGENERATE) && (status & DXFIN_DEGENERATE)) return TRUE;	if ((importFlagsX & IMPORT_ORPHANS) && (status & DXFIN_ORPHAN)) return TRUE;	scorRec.dxfRec.numSurfUsed += nSurfaces;	scorRec.dxfRec.numConstructed++;	controllerX->layerlist->Get(0,&li);		p = new(V_Array);	p->cArray(nPoints, sizeof(Point3DFFixed), 4);	pnt = (Point3DFFixed *)p->Use();	memcpy(pnt, points, sizeof(Point3DFFixed) * nPoints);	p->Unuse();	s = new(V_Array);	s->cArray(0, sizeof(V_Array *), 4);		for (i = 0; i < nSurfaces; i++)		{		sp = new(V_Array);		sp->cArray(nSurfPoints[i], sizeof(short), 4);				spnt = (short *)sp->Use();		memcpy(spnt, surfaces[i], sizeof(short) * nSurfPoints[i]);		sp->Unuse();		s->Append(&sp);		}	origin = CenterPoints(p);	color = PolyColor(colors, nSurfaces);	poly = (CAVPolyhedron*)dwgX->NewPolyhedron();	poly->cPolyhedron(dwgX);		poly->CreateMesh(p, s);	poly->Move(origin);	poly->SetColor(color, 0xffff, SURF_SHARED);	poly->SetLayer(li,TRUE);	for (i = 0; i < nSurfaces; i++)		{		SurfDef *sDef;		RGBColor clr;		if (colors[i].alpha == 0 || colors[i].red != color.red ||			colors[i].green != color.green || colors[i].blue != color.blue)			{			sDef = poly->GetSurfDef(i);			if (colors[i].alpha > 0)				{				clr.red = colors[i].red;				clr.green = colors[i].green;				clr.blue = colors[i].blue;				}			else clr = color;			sDef->SetColor(clr, colors[i].alpha, SURF_SHARED);			}		}	dwgX->polyhedron->Install(poly);	poly->ContainCleanUp();	return(0);	}Point3DFFixedCenterPoints(V_Array *p)	{	Point3DFFixed *pnt;	Point3DFFixed min, max, origin;	int nPoints, i;	nPoints = p->ALength();	pnt = (Point3DFFixed *)p->Use();	min = Pt3DFFMax;	max = Pt3DFFMin;	for (i = 0; i < nPoints; i++, pnt++)		{		if (FFLogic(pnt->x, min.x) < 0) min.x = pnt->x;		if (FFLogic(pnt->x, max.x) > 0) max.x = pnt->x;		if (FFLogic(pnt->y, min.y) < 0) min.y = pnt->y;		if (FFLogic(pnt->y, max.y) > 0) max.y = pnt->y;		if (FFLogic(pnt->z, min.z) < 0) min.z = pnt->z;		if (FFLogic(pnt->z, max.z) > 0) max.z = pnt->z;		}	origin.x = FFShift(FFAdd(min.x, max.x), -1);	origin.y = FFShift(FFAdd(min.y, max.y), -1);	origin.z = FFShift(FFAdd(min.z, max.z), -1);	pnt = (Point3DFFixed *)p->Abuse();	for (i = 0; i < nPoints; i++, pnt++)		{		pnt->x = FFSub(pnt->x, origin.x);		pnt->y = FFSub(pnt->y, origin.y);		pnt->z = FFSub(pnt->z, origin.z);		}	p->Unuse();	return(origin);	}typedef struct	{	RGBColor color;	short count;	} ColorCount;RGBColorPolyColor(RGBAColor *colors, int nColors)	{	V_Array *count;	ColorCount ccount, *cnt;	short maxCount, maxColor;	RGBColor color;	int nCounts, j;	int i;	count = new(V_Array);	count->cArray(0, sizeof(ColorCount), 4);	for (i = 0; i < nColors; i++, colors++)		{		if (colors->alpha == 0)			continue;		nCounts = count->ALength();		for (j = 0; j < nCounts; j++)			{			cnt = (ColorCount*)count->GetAddress(j);			if (cnt->color.red == colors->red && cnt->color.green == colors->green &&				cnt->color.blue == colors->blue)				{				cnt->count++;				break;				}			}		if (j == nCounts)			{			ccount.color.red = colors->red;			ccount.color.green = colors->green;			ccount.color.blue = colors->blue;			ccount.count = 1;			count->Append(&ccount);			}		}	if ((nCounts = count->ALength()) > 0)		{		maxCount = 0;		maxColor = 0;			for (j = 0; j < nCounts; j++)			{			cnt = (ColorCount*)count->GetAddress(j);				if (cnt->count > maxCount)				{				maxCount = cnt->count;				maxColor = j;				}			}		cnt = (ColorCount*)count->GetAddress(maxColor);		color = cnt->color;		}	else color = vBlack;	count->dArray();	return(color);	}#endif // VWT jca 17 Sept 93 }