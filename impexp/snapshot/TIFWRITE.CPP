/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	John C. Alspaugh * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#if VWT// jca 17 Sept 93.  Not in VR {#include "VIO.h"#include "VArray.h"#include "VDialog.h"#include "VGUtil.h"#include "VMemutil.h"#include "AppDeflt.h"#include "TIFConst.h"#include "TIFDefs.h" 		/* TIFF tags constants */#include "TIFCompr.h"#include "ImgHandl.h"#include "TIFHandl.h"	/* TIFFHandler class and constants */#include "AppText.h"#include <string.h>#include <stdio.h>#include <math.h>/* predictor for write-out #define USE_PREDICTOR 1	*/extern V_Meter *vMeter;		/* meter for the reading and writing progress */intTIFFWriter::cTIFFWriter(V_Buffer *theFile, V_Offscreen *theOffscreen){unsigned short tmp;char left, right, *a_ray;stripOffsets = new(V_Array);stripLengths = new(V_Array);stripOffsets->cArray(0, sizeof(long), 1);stripLengths->cArray(0, sizeof(long), 1);IFDPosition = 0;compression = NO_COMPRESSION;bufferSize = 0;rowsPerStrip = 1;Prediction = NO_PREDICTION;xscaleNum = yscaleNum = DEFAULT_IMAGE_SCALE;xscaleDenom = yscaleDenom = 1;fileStartPos = 0;flags = 0;/* test byte-ordering */tmp = 0x0001;a_ray = (char *) &tmp;		left = a_ray[0];//(tmp & 0xFF00) >> 4;right = a_ray[1];//tmp & 0xFF;if ((left) && (!right))	flags |= LITTLE_ENDIAN;else if ((!left) && (right))	flags |= BIG_ENDIAN;else	flags = 0;				/* error */	file = theFile;screen = theOffscreen;return 0;}voidTIFFWriter::dTIFFWriter(){stripOffsets->dArray();stripLengths->dArray();file = NULL;screen = NULL;delete this;}voidTIFFWriter::WriteIntel(void){flags &= ~MOTOROLA_BASED;flags |= INTEL_BASED;}voidTIFFWriter::WriteMotorolla(void){flags &= ~INTEL_BASED;flags |= MOTOROLA_BASED;}int	TIFFWriter::WriteImage(TranslatorPreference *transPref){/* set the translator preferences for the writer */#if THIS_WERE_A_BETTER_PLANNED_OUT_WORLDif (transPref->EPSFDevice==EPSForThePC)	{	flags |= INTEL_BASED;	if (flags & BIG_ENDIAN) flags |= BYTE_SWAP;			/* set byte-swapping flags */	else flags &= (unsigned short) ~BYTE_SWAP;	}else	{		flags |= MOTOROLA_BASED;	if (flags & LITTLE_ENDIAN) flags |= BYTE_SWAP;		/* set byte-swapping flags */	else flags &= (unsigned short) ~BYTE_SWAP;	}#elif MACINTOSH	flags |= MOTOROLA_BASED;	if (flags & LITTLE_ENDIAN) flags |= BYTE_SWAP;		/* set byte-swapping flags */	else flags &= (unsigned short) ~BYTE_SWAP;#elif WINDOWS	flags |= INTEL_BASED;	if (flags & BIG_ENDIAN) flags |= BYTE_SWAP;			/* set byte-swapping flags */	else flags &= (unsigned short) ~BYTE_SWAP;#endifif (transPref->TIFFCompression)	{	flags |= COMPRESS;	if (transPref->TIFFCompression == TIFFLZW)		compression = LZW_COMPRESSION;	else if (transPref->TIFFCompression == TIFFPackBits)		compression = PACKBITS_COMPRESSION;	else    	compression = NO_COMPRESSION;	}else	compression = NO_COMPRESSION;if (transPref->EPSColorFlag)	{	flags |= RGB_COLOR;	}else	{	if (transPref->outputColorDepth > 1)    	{		flags |= GRAYSCALE;		}	else		{		flags |= BILEVEL;		}    }WriteHeader();WritePixels();WriteTagsDirectory();return(0);}	/* 	Write the TIFF header appropriate to the destination device.*/voidTIFFWriter::WriteHeader(){char	header[9];if (flags & INTEL_BASED) 	{	header[0] = 'I';	header[1] = 'I';	header[2] = 0x2A;	header[3] = 0x0;	header[4] = header[5] = header[6] = header[7] = 0x0;	if (flags & BIG_ENDIAN) flags |= BYTE_SWAP;			/* set byte-swapping flags */	else flags &= (unsigned short) ~BYTE_SWAP;	}else if (flags & MOTOROLA_BASED)	{	header[0] = 'M';	header[1] = 'M';	header[2] = 0x0;	header[3] = 0x2A;	header[4] = header[5] = header[6] = header[7] = 0x0;		if (flags & LITTLE_ENDIAN) flags |= BYTE_SWAP;		/* set byte-swapping flags */	else flags &= (unsigned short) ~BYTE_SWAP;	}fileStartPos = file->IOGetPosition();file->IOData(header, 8);IFDPosition = fileStartPos + 8;}void	TIFFWriter::MakeIFDEntry(char* entry, unsigned short tag, unsigned short type, ULong count, ULong value){unsigned short short_value;char *ptr;CONVERT_SHORT_TO_CHAR(tag, entry);ptr = &entry[2];CONVERT_SHORT_TO_CHAR(type, ptr);ptr = &entry[4];CONVERT_LONG_TO_CHAR(count, ptr);ptr = &entry[8];if ((count == 1) && (type == TIFFSHORT))	{	short_value = (unsigned short) value;	CONVERT_SHORT_TO_CHAR(short_value, ptr);	}else	{	CONVERT_LONG_TO_CHAR(value, ptr);	}	}voidTIFFWriter::WriteTagsDirectory(){char			IFDEntry[IFDENTRY_SIZE], buffer[CODE_BUF_SIZE], *ptr;int				i;long 			length, offset;unsigned short 	tmp, bufferPos;unsigned short	IFDSize;V_Array			*IFDETable;	/* image file directory entry temp storage */Rect			localRect;IFDETable = new(V_Array);IFDETable->cArray(15, sizeof(char[12]), 1);VA_Truncate(IFDETable);bufferPos = 0;screen->GetRect(&localRect);/* Create the tag info by loading IFD entries into array in order of tag values, while writing any larger chunks of info into the file (sort of likea scratch buffer) *//* flags for full-size image */MakeIFDEntry(IFDEntry, NEWSUBFILETYPE, TIFFLONG, 1L, 0x00000000);IFDETable->Append(IFDEntry);MakeIFDEntry(IFDEntry, IMAGEWIDTH, TIFFLONG, 1L, (long)(localRect.right - localRect.left));IFDETable->Append(IFDEntry);MakeIFDEntry(IFDEntry, IMAGELENGTH, TIFFLONG, 1L, (long)(localRect.bottom - localRect.top));IFDETable->Append(IFDEntry);/* bits per sample */if (flags & RGB_COLOR) 	{	unsigned short bits = 8;		MakeIFDEntry(IFDEntry, BITSPERSAMPLE, TIFFSHORT, 3L, IFDPosition + bufferPos);	ptr = &buffer[bufferPos];	CONVERT_SHORT_TO_CHAR(bits, ptr);	bufferPos += 2; 	EmptyBufferIfNecessary(buffer, CODE_BUF_SIZE, bufferPos, IFDPosition, 2);	ptr = &buffer[bufferPos];	CONVERT_SHORT_TO_CHAR(bits, ptr);	bufferPos += 2; 	EmptyBufferIfNecessary(buffer, CODE_BUF_SIZE, bufferPos, IFDPosition, 2);	ptr = &buffer[bufferPos];	CONVERT_SHORT_TO_CHAR(bits, ptr);	bufferPos += 2; 	EmptyBufferIfNecessary(buffer, CODE_BUF_SIZE, bufferPos, IFDPosition, 2);	}else if (flags & GRAYSCALE) 	{	MakeIFDEntry(IFDEntry, BITSPERSAMPLE, TIFFSHORT, 1L, 8L);	}else /* if (flags & BILEVEL) */	{	MakeIFDEntry(IFDEntry, BITSPERSAMPLE, TIFFSHORT, 1L, 1L);	}IFDETable->Append(IFDEntry);if(flags & COMPRESS)	{	MakeIFDEntry(IFDEntry, COMPRESSION, TIFFSHORT, 1L, compression);	IFDETable->Append(IFDEntry);	}/* how to interpret the data */if (flags & RGB_COLOR)	MakeIFDEntry(IFDEntry, PHOTOMETRICINTERP, TIFFSHORT, 1L,2L);else /* if (flags & GRAYSCALE) */	MakeIFDEntry(IFDEntry, PHOTOMETRICINTERP, TIFFSHORT, 1L,1L);IFDETable->Append(IFDEntry);length = VA_Length(stripOffsets);if (length == 1)		{	stripOffsets->Get(0, &offset);	MakeIFDEntry(IFDEntry, STRIPOFFSETS, TIFFLONG, length, offset);	}else	/* write elsewhere in file */	{	MakeIFDEntry(IFDEntry, STRIPOFFSETS, TIFFLONG, length, IFDPosition + bufferPos);	stripOffsets->Use();	for (i = 0; i < length; i++)		{		stripOffsets->Get(i, &offset);		ptr = &buffer[bufferPos];		CONVERT_LONG_TO_CHAR(offset, ptr);		bufferPos += 4;				EmptyBufferIfNecessary(buffer, CODE_BUF_SIZE, bufferPos, IFDPosition, 4);		}	stripOffsets->Unuse();	}IFDETable->Append(IFDEntry);/* how many shorts per pixel */if (flags & RGB_COLOR)	MakeIFDEntry(IFDEntry, SAMPLESPERPIXEL, TIFFSHORT, 1L, 3L);else /* if (flags & GRAYSCALE) */	MakeIFDEntry(IFDEntry, SAMPLESPERPIXEL, TIFFSHORT, 1L, 1L);IFDETable->Append(IFDEntry);MakeIFDEntry(IFDEntry, ROWSPERSTRIP, TIFFLONG, 1L, (long) rowsPerStrip);IFDETable->Append(IFDEntry);length = VA_Length(stripLengths);if (length == 1)		{	stripLengths->Get(0, &offset);	tmp = (short) offset;	MakeIFDEntry(IFDEntry, STRIPBYTECOUNTS, TIFFSHORT, length, tmp);	}else	/* write elsewhere in file */	{	MakeIFDEntry(IFDEntry, STRIPBYTECOUNTS, TIFFSHORT, length, IFDPosition + bufferPos);	stripLengths->Use();	for (i = 0; i < length; i++)		{		stripLengths->Get(i, &offset);		tmp = (unsigned short) offset;		ptr = &buffer[bufferPos];		CONVERT_SHORT_TO_CHAR(tmp, ptr);		bufferPos += 2;				EmptyBufferIfNecessary(buffer, CODE_BUF_SIZE, bufferPos, IFDPosition, 2);		}	stripLengths->Unuse();	}IFDETable->Append(IFDEntry);/* resolution, in the form of n:m, like 72:1 */MakeIFDEntry(IFDEntry, XRESOLUTION, TIFFRATIONAL, 1L, IFDPosition + bufferPos);ptr = &buffer[bufferPos];CONVERT_LONG_TO_CHAR(xscaleNum, ptr);bufferPos += 4;EmptyBufferIfNecessary(buffer, CODE_BUF_SIZE, bufferPos, IFDPosition, 4);ptr = &buffer[bufferPos];CONVERT_LONG_TO_CHAR(xscaleDenom, ptr);bufferPos += 4;EmptyBufferIfNecessary(buffer, CODE_BUF_SIZE, bufferPos, IFDPosition, 4);IFDETable->Append(IFDEntry);MakeIFDEntry(IFDEntry, YRESOLUTION, TIFFRATIONAL, 1L, IFDPosition + bufferPos);ptr = &buffer[bufferPos];CONVERT_LONG_TO_CHAR(yscaleNum, ptr);bufferPos += 4;EmptyBufferIfNecessary(buffer, CODE_BUF_SIZE, bufferPos, IFDPosition, 4);ptr = &buffer[bufferPos];CONVERT_LONG_TO_CHAR(yscaleDenom, ptr);bufferPos += 4;EmptyBufferIfNecessary(buffer, CODE_BUF_SIZE, bufferPos, IFDPosition, 4);IFDETable->Append(IFDEntry);if (flags & RGB_COLOR) 	{	MakeIFDEntry(IFDEntry, PLANARCONFIG, TIFFSHORT, 1L, 1L);	IFDETable->Append(IFDEntry);	}	MakeIFDEntry(IFDEntry, RESOLUTIONUNITS, TIFFSHORT, 1L, 2L);IFDETable->Append(IFDEntry);if (compression == LZW_COMPRESSION)	{#if USE_PREDICTOR	/* for now, do not use predictors */	MakeIFDEntry(IFDEntry, PREDICTOR, TIFFSHORT, 1L, (long)HORIZONTAL_DIFF);	IFDETable->Append(IFDEntry);#else	/* for now, do not use predictors */	MakeIFDEntry(IFDEntry, PREDICTOR, TIFFSHORT, 1L, (long)NO_PREDICTION);	IFDETable->Append(IFDEntry);#endif	}else	{	/* for now, do not use predictors */	MakeIFDEntry(IFDEntry, PREDICTOR, TIFFSHORT, 1L, (long)NO_PREDICTION);	IFDETable->Append(IFDEntry);	}	if (bufferPos)		file->IOData(buffer, bufferPos);IFDPosition += bufferPos;	/* whew!  Now to write all this tag info out... */	tmp = (unsigned short) VA_Length(IFDETable);CONVERT_SHORT_TO_CHAR(tmp,buffer);		/* convert number of fields to chars */file->IOData(buffer,2);				/* write out number of fields */for (i = 0, IFDSize = 2; i < tmp; i++)		/* IFDSize = 2 to account for the short we just wrote (# IFD Entries) */	{	IFDETable->Get(i, IFDEntry);	file->IOData(IFDEntry, IFDENTRY_SIZE);	IFDSize += IFDENTRY_SIZE;	}/* write out the four null bytes to indicate EOF */buffer[0] = buffer[1] = buffer[2] = buffer[3] = (char) 0x0;	file->IOData(buffer, 4);	/* write the start of the IFD info to start of file */CONVERT_LONG_TO_CHAR(IFDPosition, buffer);file->IOPosition(buffer, 4, fileStartPos + 4);}intTIFFWriter::WritePixels(){int 					err, depth;Rect					r;BaseCompressor			*theWriter;Compressor				*pwriter;LZWCompressor			*lzwpwriter;PackBitsCompressor 	*packbitspwriter;depth = screen->GetDepth();screen->GetRect(&r);if (compression == LZW_COMPRESSION)	{	lzwpwriter = new(LZWCompressor);	lzwpwriter->cLZWCompressor(file);    theWriter = lzwpwriter;	}else if (compression == PACKBITS_COMPRESSION)	{	packbitspwriter = new(PackBitsCompressor);	packbitspwriter->cPackBitsCompressor(file);	theWriter = packbitspwriter;	}else if (compression == NO_COMPRESSION)	{	pwriter = new(Compressor);	pwriter->cCompressor(file);	theWriter = pwriter;	}if (flags & RGB_COLOR)	{	int i;		bufferSize = 3 * (r.right - r.left);	if ((bufferSize < TIFF_RECOMMENDED_BUFFER_SIZE) && (compression != PACKBITS_COMPRESSION))		{		rowsPerStrip = (int) (TIFF_RECOMMENDED_BUFFER_SIZE / bufferSize);		if (rowsPerStrip > (r.bottom - r.top))			rowsPerStrip = (r.bottom - r.top);		bufferSize *= rowsPerStrip;		}	else rowsPerStrip = 1;	#if MACINTOSH		if (depth == 32)				err = WritePixels32RGB(theWriter);	else if (depth == 16)		err = WritePixels16RGB(theWriter);	else if (depth == 8)		err = WritePixels8RGB(theWriter);	else		{		err = -1;		}	#elif WINDOWS	err = WritePixelsDIBColor(theWriter);#endif	}else if (flags & GRAYSCALE)	{	bufferSize = (r.right - r.left);	if ((bufferSize < TIFF_RECOMMENDED_BUFFER_SIZE) && (compression != PACKBITS_COMPRESSION))		{		rowsPerStrip = (int) (TIFF_RECOMMENDED_BUFFER_SIZE / bufferSize);		if (rowsPerStrip > (r.bottom - r.top))			rowsPerStrip = (r.bottom - r.top);		bufferSize *= rowsPerStrip;		}	else rowsPerStrip = 1;		#if MACINTOSH	if (depth == 32)		err = WritePixels32Grayscale(theWriter);	else if (depth == 16)		err = WritePixels16Grayscale(theWriter);	else if (depth == 8)		err = WritePixels8Grayscale(theWriter);	else		{		err = -1;		}#elif WINDOWS	err = WritePixelsDIBGrayscale(theWriter);#endif	}else /* BILEVEL */	{	bufferSize = ((r.right - r.left) + 7) >> 3;	if ((bufferSize < TIFF_RECOMMENDED_BUFFER_SIZE) && (compression != PACKBITS_COMPRESSION))		{		rowsPerStrip = (int) (TIFF_RECOMMENDED_BUFFER_SIZE/ bufferSize);		if (rowsPerStrip > (r.bottom - r.top))			rowsPerStrip = (r.bottom - r.top);#if MACINTOSH		bufferSize *= rowsPerStrip;#endif		}	else 		{		rowsPerStrip = 1;		}#if MACINTOSH	if (depth == 8)		err = WritePixels8Bilevel(theWriter);	else if ((depth == 1) || (depth == 0))		err = WritePixels1Bilevel(theWriter);	else		{		err = -1;		}#elif WINDOWS	err = WritePixelsDIBBilevel(theWriter);#endif	// MACINTOSH	}if (compression == LZW_COMPRESSION)	lzwpwriter->dLZWCompressor();else if (compression == PACKBITS_COMPRESSION)	packbitspwriter->dPackBitsCompressor();else if (compression == NO_COMPRESSION)	pwriter->dCompressor();return(err);}#if WINDOWS/* this #def inverted because of the mounds of memory the mac routines take */intTIFFWriter::WritePixelsDIBColor(BaseCompressor *writer){V_Array *buffer;BITMAPINFO	bmi;HDC	HDeviceContext;HBITMAP tempBits;long i, Iter, clockIter;char *bytes;int	ok = TRUE;Rect	dcRect;ULong lastFPosition;/* init the buffer */buffer = new(V_Array);buffer->cArray(0, sizeof(char), 1);/* evilness strikes.  The windows bitmaps are drawn faster iflong word aligned.  So, we long-word align */if (buffer->SetLength(3*rowsPerStrip*screen->wBmWidth))	{	AlertMessage(TXTW_MEMORY);	buffer->dArray();    return(-1);	}bytes = (char *) buffer->Use();/* get the windows device context */HDeviceContext = screen->GetMetaPort(&dcRect);screen->SetMetaPort();/* init the BITMAPINFO */bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);bmi.bmiHeader.biWidth = screen->wBmWidth; // this is the width the bitmap thinks it hasbmi.bmiHeader.biHeight = screen->wBmHeight; bmi.bmiHeader.biPlanes = 1;bmi.bmiHeader.biBitCount = 24;bmi.bmiHeader.biCompression = BI_RGB;i = (screen->rect.bottom - screen->rect.top) - 1;clockIter = 0;// We're not supposed to have the bitmap selected//when we do SetDIBits calls, so let's unselect it.tempBits = SelectObject(HDeviceContext, screen->oldBitmap);ASSERT(tempBits == screen->bitmap);lastFPosition = IFDPosition;while ((i >= 0) && ok) {	long length, LineCount = 0;	long bufferPos;#if USE_PREDICTOR	long jIterator;#endif	/* init the buffer, write the strip start position */	bufferPos = 0;	while (((LineCount < rowsPerStrip) && (i - LineCount >= 0)) && ok)		{		 if (0 >= (GetDIBits(HDeviceContext, tempBits, (i-LineCount),1,			(void FAR *)&bytes[bufferPos], (BITMAPINFO FAR*) &bmi, DIB_RGB_COLORS)))			{			/* mega error */			AlertMessage(TIFF_WRITE_ERROR);			buffer->Unuse();			buffer->dArray();			screen->UnsetMetaPort();			screen->ReleaseMetaPort(HDeviceContext);            return(-1);			}		LineCount++;		bufferPos += 3*(screen->rect.right - screen->rect.left);		if ((clockIter++ & 0xFF) == 0)			if (MeterUpdate(VGetTime())) 	ok = FALSE;		}	for (Iter = 0; Iter < bufferPos; Iter += 3)		{		bytes[Iter] ^= bytes[Iter+2];		bytes[Iter+2] ^= bytes[Iter];        bytes[Iter] ^= bytes[Iter+2];		}#if USE_PREDICTOR	for (jIterator = bufferPos - 1; jIterator > 4; jIterator-= 3)		{		bytes[jIterator] -= bytes[jIterator-3];		bytes[jIterator-1] -= bytes[jIterator-4];		bytes[jIterator-2] -= bytes[jIterator-5];		}#endif	/* do the TIFF stuff */	buffer->Unuse();	buffer->SetLength(bufferPos);	length = writer->WritePixels(buffer, &IFDPosition);	stripOffsets->Append(&lastFPosition);	stripLengths->Append(&length);    lastFPosition = IFDPosition;	bytes = (char *) buffer->Use();	i -= LineCount;	}/* end on a word boundary */if (IFDPosition % sizeof(int) > 0)	{	int addOn, i;	char	charbuf[sizeof(int)];		addOn = IFDPosition % sizeof(int);	for (i=0; i< addOn;i++)		{		charbuf[i] = '\0';		}	writer->buffer->IOData(charbuf, addOn);	IFDPosition += addOn;	}SelectObject(HDeviceContext, tempBits);buffer->Unuse();buffer->dArray();screen->UnsetMetaPort();screen->ReleaseMetaPort(HDeviceContext);return(!ok);}intTIFFWriter::WritePixelsDIBGrayscale(BaseCompressor *writer){V_Array *buffer, *colorBuffer;BITMAPINFO	bmi;HDC	HDeviceContext;HBITMAP	tempBits;long i, clockIter;char *bytes, *colorBytes;int	ok = TRUE;Rect	dcRect;ULong lastFPosition;/* init the grayscale buffer */buffer = new(V_Array);buffer->cArray(0, sizeof(char), 1);if (buffer->SetLength(bufferSize))	{	AlertMessage(TXTW_MEMORY);	buffer->dArray();    return(-1);	}bytes = (char *) buffer->Use();/* init the color dib buffer */colorBuffer = new(V_Array);colorBuffer->cArray(0, sizeof(char), 1);if (colorBuffer->SetLength(3*screen->wBmWidth*rowsPerStrip))	{	AlertMessage(TXTW_MEMORY);	colorBuffer->dArray();	buffer->Unuse();    buffer->dArray();    return(-1);	}colorBytes = (char *) colorBuffer->Use();clockIter = 0;/* get the windows device context *///HDeviceContext = GetDC(NULL);HDeviceContext = screen->GetMetaPort(&dcRect);screen->SetMetaPort();/* init the BITMAPINFO */bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);bmi.bmiHeader.biWidth = screen->wBmWidth;bmi.bmiHeader.biHeight = screen->wBmHeight;bmi.bmiHeader.biPlanes = 1;bmi.bmiHeader.biBitCount = 24;bmi.bmiHeader.biCompression = BI_RGB;i = (screen->rect.bottom - screen->rect.top) - 1;// We're not supposed to have the bitmap selected//when we do SetDIBits calls, so let's unselect it.tempBits = SelectObject(HDeviceContext, screen->oldBitmap);ASSERT(tempBits == screen->bitmap);lastFPosition = IFDPosition;while ((i >= 0) && ok)	{	long length, LineCount = 0;	long bufferPos;#if USE_PREDICTOR	long jIterator;#endif	/* init the buffer, write the strip start position */	bufferPos = 0;	while (((LineCount < rowsPerStrip) && (i - LineCount >= 0)) && ok)		{        long It;		if (0 >= (GetDIBits(HDeviceContext, tempBits, (i-LineCount),1,			(void FAR *)colorBytes, (BITMAPINFO FAR*) &bmi, DIB_RGB_COLORS)))			{			/* mega error */			AlertMessage(TIFF_WRITE_ERROR);			buffer->Unuse();			buffer->dArray();			colorBuffer->Unuse();			colorBuffer->dArray();//			ReleaseDC(NULL, HDeviceContext);			screen->UnsetMetaPort();			screen->ReleaseMetaPort(HDeviceContext);			return(-1);			}		LineCount++;		for (It = 0; It < 3*(screen->rect.right - screen->rect.left); It+=3)			bytes[bufferPos++] = (unsigned char) ((short)(colorBytes[It] + colorBytes[It+1] + colorBytes[It+2])/3);		if ((clockIter++ & 0xFF) == 0)			if (MeterUpdate(VGetTime())) 	ok = FALSE;		}#if USE_PREDICTOR		for (jIterator = bufferPos - 1; jIterator > 4; jIterator-= 3)			{			bytes[jIterator] -= bytes[jIterator-3];			bytes[jIterator-1] -= bytes[jIterator-4];			bytes[jIterator-2] -= bytes[jIterator-5];			}#endif	/* do the TIFF stuff */	buffer->Unuse();	buffer->SetLength(bufferPos);	length = writer->WritePixels(buffer, &IFDPosition);	stripOffsets->Append(&lastFPosition);	stripLengths->Append(&length);	lastFPosition = IFDPosition;	bytes = (char *) buffer->Use();	i -= LineCount;	}/* end on a word boundary */if (IFDPosition % sizeof(int) > 0)	{	int addOn, i;	char	charbuf[sizeof(int)];		addOn = IFDPosition % sizeof(int);	for (i=0; i< addOn;i++)		{		charbuf[i] = '\0';		}	writer->buffer->IOData(charbuf, addOn);	IFDPosition += addOn;	}SelectObject(HDeviceContext, tempBits);buffer->Unuse();buffer->dArray();colorBuffer->Unuse();colorBuffer->dArray();//ReleaseDC(NULL, HDeviceContext);screen->UnsetMetaPort();screen->ReleaseMetaPort(HDeviceContext);return(!ok);}intTIFFWriter::WritePixelsDIBBilevel(BaseCompressor *writer){V_Array *buffer, *bmapinfo;LPBITMAPINFO	bmi;HDC	HDeviceContext;HBITMAP	tempBits;long i, bufferPos, DIBbufferSize, clockIter;char *bytes;int	ok = TRUE;Rect	dcRect;ULong lastFPosition;/* init the buffer */buffer = new(V_Array);buffer->cArray(0, sizeof(char), 1);DIBbufferSize = 3*screen->wBmWidth*rowsPerStrip; //((bufferSize + 3) & ~0x3) * rowsPerStrip;if (buffer->SetLength(DIBbufferSize))	{	AlertMessage(TXTW_MEMORY);	buffer->dArray();    return(-1);	}bytes = (char *) buffer->Use();/* get the windows device context *///HDeviceContext = GetDC(NULL);HDeviceContext = screen->GetMetaPort(&dcRect);screen->SetMetaPort();/* init the BITMAPINFO */bmapinfo = new(V_Array);bmapinfo->cArray(0, sizeof(char), 1);if (bmapinfo->SetLength(sizeof(BITMAPINFOHEADER)+2*sizeof(RGBQUAD)))	{	AlertMessage(TXTW_MEMORY);	bmapinfo->dArray();	screen->UnsetMetaPort();	screen->ReleaseMetaPort(HDeviceContext);	buffer->Unuse();	buffer->dArray();    return(-1);	}bmi = (LPBITMAPINFO) bmapinfo->Use();bmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);bmi->bmiHeader.biWidth = screen->wBmWidth;bmi->bmiHeader.biHeight = screen->wBmHeight;bmi->bmiHeader.biPlanes = 1;bmi->bmiHeader.biBitCount = 1;bmi->bmiHeader.biCompression = BI_RGB;i = (screen->rect.bottom - screen->rect.top) - 1;clockIter = 0;// We're not supposed to have the bitmap selected//when we do SetDIBits calls, so let's unselect it.tempBits = SelectObject(HDeviceContext, screen->oldBitmap);ASSERT(tempBits == screen->bitmap);lastFPosition = IFDPosition;while ((i >= 0) && ok) {	long length, LineCount = 0;#if USE_PREDICTOR	long jIterator;#endif	/* init the buffer, write the strip start position */	bufferPos = 0;	while (((LineCount < rowsPerStrip) && (i - LineCount >= 0)) && ok)		{		if (0 >= (GetDIBits(HDeviceContext, tempBits, (i-LineCount),1,			(void FAR *)&bytes[bufferPos], (BITMAPINFO FAR*) bmi, DIB_RGB_COLORS)))			{			/* mega error */			AlertMessage(TIFF_WRITE_ERROR);			buffer->Unuse();			buffer->dArray();			bmapinfo->Unuse();            bmapinfo->dArray();			screen->UnsetMetaPort();			screen->ReleaseMetaPort(HDeviceContext);	 //		ReleaseDC(NULL, HDeviceContext);            return(-1);			}		bufferPos += bufferSize;		LineCount++;		if ((clockIter++ & 0xFF) == 0)			if (MeterUpdate(VGetTime())) 	ok = FALSE;		}	/* do the TIFF stuff */	buffer->Unuse();	buffer->SetLength(bufferPos);	length = writer->WritePixels(buffer, &IFDPosition);	stripOffsets->Append(&lastFPosition);	stripLengths->Append(&length);    lastFPosition = IFDPosition;	bytes = (char *) buffer->Use();	i -= LineCount;	}/* end on a word boundary */if (IFDPosition % sizeof(int) > 0)	{	int addOn, i;	char	charbuf[sizeof(int)];		addOn = IFDPosition % sizeof(int);	for (i=0; i< addOn;i++)		{		charbuf[i] = '\0';		}	writer->buffer->IOData(charbuf, addOn);	IFDPosition += addOn;	}SelectObject(HDeviceContext, tempBits);buffer->Unuse();buffer->dArray();bmapinfo->Unuse();bmapinfo->dArray();//ReleaseDC(NULL, HDeviceContext);screen->UnsetMetaPort();screen->ReleaseMetaPort(HDeviceContext);return(0);}#elif MACINTOSHintTIFFWriter::WritePixels32RGB(BaseCompressor *writer){V_Array *buffer;unsigned char	r,g,b;int 	i,j, positionInBuffer, ok;long	color32,length;ULong 	lastFPosition;unsigned char *framebuffer, *loc;unsigned char	*bufferPtr;#if USE_PREDICTORunsigned char	rPredictor, gPredictor, bPredictor;#endifint xOffset=colorQD?-(*screen->metaPort->portPixMap)->bounds.left:-screen->metaPort->portRect.left;int yOffset=colorQD?-(*screen->metaPort->portPixMap)->bounds.top:-screen->metaPort->portRect.top;long screenRowBytes=colorQD?0x1FFF&(*screen->metaPort->portPixMap)->rowBytes:(*screen->bitmap)->rowBytes;/* add in start and yoffset.  xoffset will come later */framebuffer = (xOffset<<2) + (unsigned char *)screen->GetBaseAddr() + ((yOffset)*screenRowBytes);positionInBuffer = 0;buffer = new(V_Array);buffer->cArray(bufferSize, sizeof(char), 1);VA_Use(buffer, bufferPtr, unsigned char);ok = TRUE;lastFPosition = IFDPosition;for(i=0;i<(screen->rect.bottom - screen->rect.top) && ok != FALSE;i++)	{	loc = framebuffer + (i*screenRowBytes);	#if USE_PREDICTOR	rPredictor = gPredictor = bPredictor = 0;#endif	for(j=0;j<(screen->rect.right-screen->rect.left) && ok != FALSE;j++)		{		if (j>0) loc += 4;		color32 = *(ULong *)loc;		r = (unsigned char) ((color32 & 0x00FF0000) >> 16);		g = (unsigned char) ((color32 & 0x0000FF00) >> 8);		b = (unsigned char) (color32 & 0x000000FF);		#if USE_PREDICTOR		unsigned char tr,tg,tb;				tr = r; tg = g; tb = b;		r -= rPredictor; g -= gPredictor; b -= bPredictor;		rPredictor = tr; gPredictor = tg; bPredictor = tb;#endif		bufferPtr[positionInBuffer++] = r;		bufferPtr[positionInBuffer++] = g;		bufferPtr[positionInBuffer++] = b;			/* if the buffer is full, write out this strip */		if (positionInBuffer == bufferSize)			{			length = writer->WritePixels(buffer, &IFDPosition);			stripLengths->Append(&length);			stripOffsets->Append(&lastFPosition);			lastFPosition = IFDPosition;			positionInBuffer = 0;			}		/* check that the user still wants us to be writing this out, and 		update the meter */		if ((j & 0xFF) == 0)			if (MeterUpdate(TickCount())) 	ok = FALSE;		}				}if (positionInBuffer > 0)		{	buffer->SetLength(positionInBuffer);	length = writer->WritePixels(buffer, &IFDPosition);	stripLengths->Append(&length);	stripOffsets->Append(&lastFPosition);	}/* end on a word boundary */if (IFDPosition % sizeof(int) > 0)	{	int addOn, i;	char	charbuf[sizeof(int)];		addOn = IFDPosition % sizeof(int);	for (i=0; i< addOn;i++)		{		charbuf[i] = '\0';		}	writer->buffer->IOData(charbuf, addOn);	IFDPosition += addOn;	}VA_Unuse(buffer);buffer->dArray();}intTIFFWriter::WritePixels16RGB(BaseCompressor *writer){V_Array *buffer;unsigned char	r,g,b;int 	i,j, positionInBuffer, ok;unsigned short color16;long	length;unsigned char *framebuffer, *loc;unsigned char	*bufferPtr;ULong 	lastFPosition;#if USE_PREDICTORunsigned char	rPredictor, gPredictor, bPredictor;#endifint xOffset=colorQD?-(*screen->metaPort->portPixMap)->bounds.left:-screen->metaPort->portRect.left;int yOffset=colorQD?-(*screen->metaPort->portPixMap)->bounds.top:-screen->metaPort->portRect.top;long screenRowBytes=colorQD?0x1FFF&(*screen->metaPort->portPixMap)->rowBytes:(*screen->bitmap)->rowBytes;/* add in start and yoffset.  xoffset will come later */framebuffer = (xOffset<<1) + (unsigned char *)screen->GetBaseAddr() + ((yOffset)*screenRowBytes);positionInBuffer = 0;buffer = new(V_Array);buffer->cArray(bufferSize, sizeof(char), 1);VA_Use(buffer, bufferPtr, unsigned char);ok = TRUE;lastFPosition = IFDPosition;for(i=0;i<(screen->rect.bottom - screen->rect.top) && ok != FALSE;i++)	{	loc = framebuffer + (i*screenRowBytes);	#if USE_PREDICTOR	rPredictor = gPredictor = bPredictor = 0;#endif	for(j=0;j<(screen->rect.right-screen->rect.left) && ok != FALSE;j++)		{		if (j>0) loc += 2;		color16 = *(unsigned short *)loc;		r = (unsigned char) ((color16 & 0x7C00) >> 7);		g = (unsigned char) ((color16 & 0x03E0) >> 2);		b = (unsigned char) ((color16 & 0x001F) << 3);		#if USE_PREDICTOR		unsigned char tr,tg,tb;				tr = r; tg = g; tb = b;		r -= rPredictor; g -= gPredictor; b -= bPredictor;		rPredictor = tr; gPredictor = tg; bPredictor = tb;#endif		bufferPtr[positionInBuffer++] = r;		bufferPtr[positionInBuffer++] = g;		bufferPtr[positionInBuffer++] = b;			/* if the buffer is full, write out this strip */		if (positionInBuffer == bufferSize)			{			length = writer->WritePixels(buffer, &IFDPosition);			stripLengths->Append(&length);			stripOffsets->Append(&lastFPosition);            lastFPosition = IFDPosition;			positionInBuffer = 0;			}		/* check that the user still wants us to be writing this out, and 		update the meter */		if ((j & 0xFF) == 0)			if (MeterUpdate(TickCount())) 	ok = FALSE;		}				}	if (positionInBuffer > 0)		{	buffer->SetLength(positionInBuffer);	length = writer->WritePixels(buffer, &IFDPosition);	stripLengths->Append(&length);	stripOffsets->Append(&lastFPosition);	}/* end on a word boundary */if (IFDPosition % sizeof(int) > 0)	{	int addOn, i;	char	charbuf[sizeof(int)];		addOn = IFDPosition % sizeof(int);	for (i=0; i< addOn;i++)		{		charbuf[i] = '\0';		}	writer->buffer->IOData(charbuf, addOn);	IFDPosition += addOn;	}VA_Unuse(buffer);buffer->dArray();}intTIFFWriter::WritePixels8RGB(BaseCompressor *writer){V_Array *buffer;unsigned char	r,g,b;int 	i,j, positionInBuffer, ok;CTabPtr theTable;unsigned char	index;ColorSpec *ctTable;long	length;ULong 	lastFPosition;unsigned char *framebuffer, *loc;unsigned char	*bufferPtr;#if USE_PREDICTORunsigned char	rPredictor, gPredictor, bPredictor;#endifint xOffset=colorQD?-(*screen->metaPort->portPixMap)->bounds.left:-screen->metaPort->portRect.left;int yOffset=colorQD?-(*screen->metaPort->portPixMap)->bounds.top:-screen->metaPort->portRect.top;long screenRowBytes=colorQD?0x1FFF&(*screen->metaPort->portPixMap)->rowBytes:(*screen->bitmap)->rowBytes;/* add in start and yoffset.  xoffset will come later */framebuffer = xOffset + (unsigned char *)screen->GetBaseAddr() + ((yOffset)*screenRowBytes);positionInBuffer = 0;buffer = new(V_Array);buffer->cArray(bufferSize, sizeof(char), 1);/* set up color table stuff */theTable=screen->UseColorTable();ctTable=theTable->ctTable;ok = TRUE;lastFPosition = IFDPosition;for(i=0;i<(screen->rect.bottom - screen->rect.top) && ok != FALSE;i++)	{	loc = framebuffer + (i*screenRowBytes);	#if USE_PREDICTOR	rPredictor = gPredictor = bPredictor = 0;#endif	for(j=0;j<(screen->rect.right-screen->rect.left) && ok != FALSE;j++)		{				if (j>0) loc++;		r = (unsigned char) (ctTable[*loc].rgb.red >> 8);		g = (unsigned char) (ctTable[*loc].rgb.green >> 8);		b = (unsigned char) (ctTable[*loc].rgb.blue >> 8);		#if USE_PREDICTOR		unsigned char tr,tg,tb;				tr = r; tg = g; tb = b;		r -= rPredictor; g -= gPredictor; b -= bPredictor;		rPredictor = tr; gPredictor = tg; bPredictor = tb;#endif		bufferPtr = (unsigned char *)VA_Abuse(buffer);		bufferPtr[positionInBuffer++] = r;		bufferPtr[positionInBuffer++] = g;		bufferPtr[positionInBuffer++] = b;			/* if the buffer is full, write out this strip */		if (positionInBuffer == bufferSize)			{			length = writer->WritePixels(buffer, &IFDPosition);			stripLengths->Append(&length);			stripOffsets->Append(&lastFPosition);            lastFPosition = IFDPosition;			positionInBuffer = 0;			}		/* check that the user still wants us to be writing this out, and 		update the meter */		if ((j & 0xFF) == 0)			if (MeterUpdate(TickCount())) 	ok = FALSE;		}				}if (positionInBuffer > 0)		{	buffer->SetLength(positionInBuffer);	length = writer->WritePixels(buffer, &IFDPosition);	stripLengths->Append(&length);	stripOffsets->Append(&lastFPosition);	}/* end on a word boundary */if (IFDPosition % sizeof(int) > 0)	{	int addOn, i;	char	charbuf[sizeof(int)];		addOn = IFDPosition % sizeof(int);	for (i=0; i< addOn;i++)		{		charbuf[i] = '\0';		}	writer->buffer->IOData(charbuf, addOn);	IFDPosition += addOn;	}	screen->UnuseColorTable();buffer->dArray();}intTIFFWriter::WritePixels32Grayscale(BaseCompressor *writer){V_Array 		*buffer;unsigned char	r,g,b;int 			i,j, positionInBuffer, ok;long			color32,length;ULong			lastFPosition;unsigned char 	*framebuffer, *loc;unsigned char	*bufferPtr;#if USE_PREDICTORunsigned char	gPredictor;#endifint xOffset=colorQD?-(*screen->metaPort->portPixMap)->bounds.left:-screen->metaPort->portRect.left;int yOffset=colorQD?-(*screen->metaPort->portPixMap)->bounds.top:-screen->metaPort->portRect.top;long screenRowBytes=colorQD?0x1FFF&(*screen->metaPort->portPixMap)->rowBytes:(*screen->bitmap)->rowBytes;/* add in start and yoffset.  xoffset will come later */framebuffer = (xOffset<<2) + (unsigned char *)screen->GetBaseAddr() + ((yOffset)*screenRowBytes);positionInBuffer = 0;buffer = new(V_Array);buffer->cArray(bufferSize, sizeof(char), 1);VA_Use(buffer, bufferPtr, unsigned char);ok = TRUE;lastFPosition = IFDPosition;for(i=0;i<(screen->rect.bottom - screen->rect.top) && ok != FALSE;i++)	{	loc = framebuffer + (i*screenRowBytes);	#if USE_PREDICTOR	rPredictor = gPredictor = bPredictor = 0;#endif	for(j=0;j<(screen->rect.right-screen->rect.left) && ok != FALSE;j++)		{		if (j>0) loc += 4;		color32 = *(ULong *)loc;		r = (unsigned char) ((color32 & 0x00FF0000) >> 16);		g = (unsigned char) ((color32 & 0x0000FF00) >> 8);		b = (unsigned char) (color32 & 0x000000FF);				/* for now, use (r+g+b)/3 to make gray */		g = (unsigned char) (r+g+b)/3;		#if USE_PREDICTOR		unsigned char tg;				tg = g;		g -= gPredictor;		gPredictor = tg;#endif		bufferPtr[positionInBuffer++] = g;			/* if the buffer is full, write out this strip */		if (positionInBuffer == bufferSize)			{			length = writer->WritePixels(buffer, &IFDPosition);			stripLengths->Append(&length);			stripOffsets->Append(&lastFPosition);            lastFPosition = IFDPosition;			positionInBuffer = 0;			}		/* check that the user still wants us to be writing this out, and 		update the meter */		if ((j & 0xFF) == 0)			if (MeterUpdate(TickCount())) 	ok = FALSE;		}				}if (positionInBuffer > 0)		{	buffer->SetLength(positionInBuffer);	length = writer->WritePixels(buffer, &IFDPosition);	stripLengths->Append(&length);	stripOffsets->Append(&lastFPosition);	}/* end on a word boundary */if (IFDPosition % sizeof(int) > 0)	{	int addOn, i;	char	charbuf[sizeof(int)];		addOn = IFDPosition % sizeof(int);	for (i=0; i< addOn;i++)		{		charbuf[i] = '\0';		}	writer->buffer->IOData(charbuf, addOn);	IFDPosition += addOn;	}	VA_Unuse(buffer);buffer->dArray();}intTIFFWriter::WritePixels16Grayscale(BaseCompressor *writer){V_Array 		*buffer;unsigned char	r,g,b;int 			i,j, positionInBuffer, ok;unsigned short	color16;long			length;ULong 			lastFPosition;unsigned char 	*framebuffer, *loc;unsigned char	*bufferPtr;#if USE_PREDICTORunsigned char	gPredictor;#endifint xOffset=colorQD?-(*screen->metaPort->portPixMap)->bounds.left:-screen->metaPort->portRect.left;int yOffset=colorQD?-(*screen->metaPort->portPixMap)->bounds.top:-screen->metaPort->portRect.top;long screenRowBytes=colorQD?0x1FFF&(*screen->metaPort->portPixMap)->rowBytes:(*screen->bitmap)->rowBytes;/* add in start and yoffset.  xoffset will come later */framebuffer = (xOffset<<1) + (unsigned char *)screen->GetBaseAddr() + ((yOffset)*screenRowBytes);positionInBuffer = 0;buffer = new(V_Array);buffer->cArray(bufferSize, sizeof(char), 1);VA_Use(buffer, bufferPtr, unsigned char);ok = TRUE;lastFPosition = IFDPosition;for(i=0;i<(screen->rect.bottom - screen->rect.top) && ok != FALSE;i++)	{	loc = framebuffer + (i*screenRowBytes);	#if USE_PREDICTOR	rPredictor = gPredictor = bPredictor = 0;#endif	for(j=0;j<(screen->rect.right-screen->rect.left) && ok != FALSE;j++)		{		if (j>0) loc += 2;		color16 = *(unsigned short *)loc;		r = (unsigned char) ((color16 & 0x7C00) >> 7);		g = (unsigned char) ((color16 & 0x03E0) >> 2);		b = (unsigned char) ((color16 & 0x001F) << 3);				g = (unsigned char) (r+g+b)/3;		#if USE_PREDICTOR		unsigned char tg;				tg = g;		g -= gPredictor;		gPredictor = tg;#endif		bufferPtr[positionInBuffer++] = g;			/* if the buffer is full, write out this strip */		if (positionInBuffer == bufferSize)			{			length = writer->WritePixels(buffer, &IFDPosition);			stripLengths->Append(&length);			stripOffsets->Append(&lastFPosition);            lastFPosition = IFDPosition;			positionInBuffer = 0;			}		/* check that the user still wants us to be writing this out, and 		update the meter */		if ((j & 0xFF) == 0)			if (MeterUpdate(TickCount())) 	ok = FALSE;		}				}if (positionInBuffer > 0)		{	buffer->SetLength(positionInBuffer);	length = writer->WritePixels(buffer, &IFDPosition);	stripLengths->Append(&length);	stripOffsets->Append(&lastFPosition);	}/* end on a word boundary */if (IFDPosition % sizeof(int) > 0)	{	int addOn, i;	char	charbuf[sizeof(int)];		addOn = IFDPosition % sizeof(int);	for (i=0; i< addOn;i++)		{		charbuf[i] = '\0';		}	writer->buffer->IOData(charbuf, addOn);	IFDPosition += addOn;	}VA_Unuse(buffer);buffer->dArray();}intTIFFWriter::WritePixels8Grayscale(BaseCompressor *writer){V_Array *buffer;unsigned char	r,g,b;int 	i,j, positionInBuffer, ok;CTabPtr theTable;unsigned char	index;ColorSpec *ctTable;ULong 	lastFPosition;long	length;unsigned char *framebuffer, *loc;unsigned char	*bufferPtr;#if USE_PREDICTORunsigned char	gPredictor;#endifint xOffset=colorQD?-(*screen->metaPort->portPixMap)->bounds.left:-screen->metaPort->portRect.left;int yOffset=colorQD?-(*screen->metaPort->portPixMap)->bounds.top:-screen->metaPort->portRect.top;long screenRowBytes=colorQD?0x1FFF&(*screen->metaPort->portPixMap)->rowBytes:(*screen->bitmap)->rowBytes;/* add in start and yoffset.  xoffset will come later */framebuffer = xOffset + (unsigned char *)screen->GetBaseAddr() + ((yOffset)*screenRowBytes);positionInBuffer = 0;buffer = new(V_Array);buffer->cArray(bufferSize, sizeof(char), 1);VA_Use(buffer, bufferPtr, unsigned char);/* set up color table stuff */theTable=screen->UseColorTable();ctTable=theTable->ctTable;ok = TRUE;lastFPosition = IFDPosition;for(i=0;i<(screen->rect.bottom - screen->rect.top) && ok != FALSE;i++)	{	loc = framebuffer + (i*screenRowBytes);	#if USE_PREDICTOR	rPredictor = gPredictor = bPredictor = 0;#endif	for(j=0;j<(screen->rect.right-screen->rect.left) && ok != FALSE;j++)		{				if (j>0) loc++;		r = (unsigned char) (ctTable[*loc].rgb.red >> 8);		g = (unsigned char) (ctTable[*loc].rgb.green >> 8);		b = (unsigned char) (ctTable[*loc].rgb.blue >> 8);				g = (unsigned char) (r+g+b)/3;		#if USE_PREDICTOR		unsigned char tg;				tg = g;		g -= gPredictor;		gPredictor = tg;#endif		bufferPtr[positionInBuffer++] = g;			/* if the buffer is full, write out this strip */		if (positionInBuffer == bufferSize)			{			length = writer->WritePixels(buffer, &IFDPosition);			stripLengths->Append(&length);			stripOffsets->Append(&lastFPosition);            lastFPosition = IFDPosition;			positionInBuffer = 0;			}		/* check that the user still wants us to be writing this out, and 		update the meter */		if ((j & 0xFF) == 0)			if (MeterUpdate(TickCount())) 	ok = FALSE;		}				}if (positionInBuffer > 0)		{	buffer->SetLength(positionInBuffer);	length = writer->WritePixels(buffer, &IFDPosition);	stripLengths->Append(&length);	stripOffsets->Append(&lastFPosition);	}/* end on a word boundary */if (IFDPosition % sizeof(int) > 0)	{	int addOn, i;	char	charbuf[sizeof(int)];		addOn = IFDPosition % sizeof(int);	for (i=0; i< addOn;i++)		{		charbuf[i] = '\0';		}	writer->buffer->IOData(charbuf, addOn);	IFDPosition += addOn;	}	VA_Unuse(buffer);screen->UnuseColorTable();buffer->dArray();}intTIFFWriter::WritePixels8Bilevel(BaseCompressor *writer){V_Array *buffer;int	r,g,b;int 	i,j, positionInBuffer, ok, bCount;CTabPtr theTable;unsigned char	index;ColorSpec *ctTable;long	length;ULong 	lastFPosition;unsigned char *framebuffer, *loc;unsigned char	*bufferPtr;int xOffset=colorQD?-(*screen->metaPort->portPixMap)->bounds.left:-screen->metaPort->portRect.left;int yOffset=colorQD?-(*screen->metaPort->portPixMap)->bounds.top:-screen->metaPort->portRect.top;long screenRowBytes=colorQD?0x1FFF&(*screen->metaPort->portPixMap)->rowBytes:(*screen->bitmap)->rowBytes;/* add in start and yoffset.  xoffset will come later */framebuffer = xOffset + (unsigned char *)screen->GetBaseAddr() + ((yOffset)*screenRowBytes);positionInBuffer = 0;buffer = new(V_Array);buffer->cArray(bufferSize, sizeof(char), 1);VA_Use(buffer, bufferPtr, unsigned char);/* set up color table stuff */theTable=screen->UseColorTable();ctTable=theTable->ctTable;ok = TRUE;bCount = 0;/*ShowMem(0);*/lastFPosition = IFDPosition;for(i=0;i<(screen->rect.bottom - screen->rect.top) && ok != FALSE;i++)	{	loc = framebuffer + (i*screenRowBytes);			if (bCount > 0)		{		bCount = 0;		positionInBuffer++;		if (positionInBuffer < bufferSize)			bufferPtr[positionInBuffer] = 0x00;		}			for(j=0;j<(screen->rect.right-screen->rect.left) && ok != FALSE;j++)		{		if (j>0) loc++;		r = (ctTable[*loc].rgb.red >> 8);		g = (ctTable[*loc].rgb.green >> 8);		b = (ctTable[*loc].rgb.blue >> 8);				g = ((long)(r+g+b))/3;				if (g > 127)			switch (bCount)				{				case 0:					bufferPtr[positionInBuffer] |= 0x80;					break;				case 1:					bufferPtr[positionInBuffer] |= 0x40;					break;				case 2:					bufferPtr[positionInBuffer] |= 0x20;					break;				case 3:					bufferPtr[positionInBuffer] |= 0x10;					break;				case 4:					bufferPtr[positionInBuffer] |= 0x08;					break;				case 5:					bufferPtr[positionInBuffer] |= 0x04;					break;				case 6:					bufferPtr[positionInBuffer] |= 0x02;					break;				case 7:					bufferPtr[positionInBuffer] |= 0x01;					break;				}		if (bCount == 7)				{			bCount = 0;			positionInBuffer++;			if (positionInBuffer < bufferSize)				bufferPtr[positionInBuffer] = 0x00;			}		else bCount++;						/* if the buffer is full, write out this strip */		if (positionInBuffer == bufferSize)			{			length = writer->WritePixels(buffer, &IFDPosition);			stripLengths->Append(&length);			stripOffsets->Append(&lastFPosition);            lastFPosition = IFDPosition;			positionInBuffer = 0;			}		/* check that the user still wants us to be writing this out, and 		update the meter */		if ((j & 0xFF) == 0)			if (MeterUpdate(TickCount())) 	ok = FALSE;		}				}if (bCount > 0)	positionInBuffer++;if (positionInBuffer > 0)		{	buffer->SetLength(positionInBuffer);	length = writer->WritePixels(buffer, &IFDPosition);	stripLengths->Append(&length);	stripOffsets->Append(&lastFPosition);	}/* end on a word boundary */if (IFDPosition % sizeof(int) > 0)	{	int addOn, i;	char	charbuf[sizeof(int)];		addOn = IFDPosition % sizeof(int);	for (i=0; i< addOn;i++)		{		charbuf[i] = '\0';		}	writer->buffer->IOData(charbuf, addOn);	IFDPosition += addOn;	}	VA_Unuse(buffer);screen->UnuseColorTable();buffer->dArray();}intTIFFWriter::WritePixels1Bilevel(BaseCompressor *writer){V_Array *buffer;unsigned char	b;int 	i,j, positionInBuffer, ok,bCount;CTabPtr theTable;unsigned char	index;ColorSpec *ctTable;long	length;ULong lastFPosition;unsigned char *framebuffer, *loc;unsigned char	*bufferPtr;int xOffset=colorQD?-(*screen->metaPort->portPixMap)->bounds.left:-screen->metaPort->portRect.left;int yOffset=colorQD?-(*screen->metaPort->portPixMap)->bounds.top:-screen->metaPort->portRect.top;long screenRowBytes=colorQD?0x1FFF&(*screen->metaPort->portPixMap)->rowBytes:(*screen->bitmap)->rowBytes;/* add in start and yoffset.  xoffset will come later */framebuffer = (xOffset>>3) + (unsigned char *)screen->GetBaseAddr() + ((yOffset)*screenRowBytes);positionInBuffer = 0;buffer = new(V_Array);buffer->cArray(bufferSize, sizeof(char), 1);VA_Use(buffer, bufferPtr, unsigned char);/* set up color table stuff */theTable=screen->UseColorTable();ctTable=theTable->ctTable;bCount = 0;ok = TRUE;lastFPosition = IFDPosition;for(i=0;i<(screen->rect.bottom - screen->rect.top) && ok != FALSE;i++)	{	loc = framebuffer + (i*screenRowBytes);		for(j=0;j<(screen->rect.right-screen->rect.left) && ok != FALSE;j++)		{					switch (bCount)			{			case 0:				if (*loc & 0x80)					bufferPtr[positionInBuffer] |= 0x80;				break;			case 1:				if (*loc & 0x40)					bufferPtr[positionInBuffer] |= 0x40;				break;			case 2:				if (*loc & 0x20)					bufferPtr[positionInBuffer] |= 0x20;				break;			case 3:				if (*loc & 0x10)					bufferPtr[positionInBuffer] |= 0x10;				break;			case 4:				if (*loc & 0x08)					bufferPtr[positionInBuffer] |= 0x08;				break;			case 5:				if (*loc & 0x04)					bufferPtr[positionInBuffer] |= 0x04;				break;			case 6:				if (*loc & 0x02)					bufferPtr[positionInBuffer] |= 0x02;				break;			case 7:				if (*loc & 0x01)					bufferPtr[positionInBuffer] |= 0x01;				break;			}			if (bCount == 7)					{				loc++;				bCount = 0;				positionInBuffer++;				if (positionInBuffer < bufferSize)					bufferPtr[positionInBuffer] = 0x00;				}			else bCount++;				bufferPtr[positionInBuffer++] = (unsigned char) *loc;			/* if the buffer is full, write out this strip */		if (positionInBuffer == bufferSize)			{			length = writer->WritePixels(buffer, &IFDPosition);			stripLengths->Append(&length);			stripOffsets->Append(&lastFPosition);            lastFPosition = IFDPosition;			positionInBuffer = 0;			}		/* check that the user still wants us to be writing this out, and 		update the meter */		if ((j & 0xFF) == 0)			if (MeterUpdate(TickCount())) 	ok = FALSE;		}				}if (bCount > 0)	positionInBuffer++;if (positionInBuffer > 0)		{	buffer->SetLength(positionInBuffer);	length = writer->WritePixels(buffer, &IFDPosition);	stripLengths->Append(&length);	stripOffsets->Append(&lastFPosition);	}/* end on a word boundary */if (IFDPosition % sizeof(int) > 0)	{	int addOn, i;	char	charbuf[sizeof(int)];		addOn = IFDPosition % sizeof(int);	for (i=0; i< addOn;i++)		{		charbuf[i] = '\0';		}	writer->buffer->IOData(charbuf, addOn);	IFDPosition += addOn;	}	VA_Unuse(buffer);screen->UnuseColorTable();buffer->dArray();}#endif //MACINTOSH// jca 17 Spet 93 }#endif // VWT