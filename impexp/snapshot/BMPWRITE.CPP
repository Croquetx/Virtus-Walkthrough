/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	John C. Alspaugh * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VIO.h"#include "VFile.h"#include "VDisplay.h"#include "VArray.h"#include "VDialog.h"#include "VGUtil.h"#include "VMemutil.h"#include "AppText.h"#include "AppDeflt.h"#include "ImgHandl.h"#include "BmpHandl.h"/*	BMP files come in many unpleasant flavors.  Currently (as of	the Nov 10, 1992 "DIB FormatExtensions for Microsoft Windows"	document) there are 1, 4, 8, 16, 24, and 32-bit DIB's.	16 and 32-bit are new formats, so I'm ignoring them for now.	There are two standard Windows-supported compression modes;	one for 4-bit DIB's (RLE_4) and one for 8-bit DIB's (RLE_8).	There are also a lot of newer, special-purpose methods for	video compression, JPEG, MPEG, and all that jazz.  We don't    support 'em.  */voidBMPWriter::cBMPWriter(struct V_Buffer *theFile, struct V_Offscreen *theScreen){file = theFile;screen = theScreen;flags = 0x00;xscaleNum = yscaleNum = DEFAULT_IMAGE_SCALE;xscaleDenom = yscaleDenom = 1;}voidBMPWriter::dBMPWriter(void){file = NULL;screen = NULL;delete(this);}#if WINDOWSintBMPWriter::CreateBMPHeader(V_Array *headerStore){LPBITMAPINFOHEADER	lpbmih;long				length, nColorEntries;Rect				r;screen->GetRect(&r);/* calculate the amount of memory we need for this depth bitmap */if (depth == 1) 		nColorEntries = 2;    /* 2 entries:  black and white */else if (depth == 4) 	nColorEntries = 16;   /* 16 colors */else if (depth == 8)	nColorEntries = 256;  /* 256 colors */else if ((depth == 16) ||		(depth == 24) ||		(depth == 32))						nColorEntries = 0;    /* 24-bit colors stored in pixels */else	{     /* unsupported depth */	ReportBMPError(BMP_BADWRITE_DEPTH);    return(-1);	}/* we need this much memory for the header */length = sizeof(BITMAPINFOHEADER) + (nColorEntries*sizeof(RGBQUAD));/* allocate memory for the header and the color palette */if (headerStore->SetLength(length))	{    /* can't allocate it */	headerStore->dArray();	AlertMessage(TXTW_MEMORY);    return -1;	}lpbmih = (LPBITMAPINFOHEADER) headerStore->Use();memset((char *) lpbmih, 0, length);				/* init the memory *//* init the header.  According to the pre-release of the_WIN32_Application_Programming_Interface_, only the first 6 fieldsneed to be filled in (the rest are filled in by the GetDIBits call) */lpbmih->biSize = sizeof(BITMAPINFOHEADER);lpbmih->biWidth = r.right - r.left;		lpbmih->biHeight = r.bottom - r.top;lpbmih->biPlanes = 1;	/* always one plane */lpbmih->biBitCount = depth;lpbmih->biCompression = compression;/* store the real length and height here */theWidth = screen->rect.right - screen->rect.left;theHeight = screen->rect.bottom - screen->rect.top;headerStore->Unuse();return(0);} intBMPWriter::WriteBMPHeader(LPBITMAPINFO lpbmi, ULong where){int 				headerSize, i, clrCount;long				gray, grayRGB;/* init */if (lpbmi->bmiHeader.biBitCount > 8)	clrCount = 0;else	clrCount = 1 << (lpbmi->bmiHeader.biBitCount);if (lpbmi->bmiHeader.biClrUsed)	{	headerSize = sizeof(BITMAPINFOHEADER) + (lpbmi->bmiHeader.biClrUsed * sizeof(RGBQUAD));	}else	{	headerSize = sizeof(BITMAPINFOHEADER);	if (lpbmi->bmiHeader.biBitCount < BMP_SMALLEST_TRUECOLOR_DEPTH)		headerSize += ((1 << (lpbmi->bmiHeader.biBitCount)) * sizeof(RGBQUAD));	}/* step two:  write the BITMAPHEADER */file->IOTypePosition(&lpbmi->bmiHeader.biSize, IO_LONG_I, where);file->IOType(&lpbmi->bmiHeader.biWidth, IO_LONG_I);file->IOType(&lpbmi->bmiHeader.biHeight, IO_LONG_I);file->IOType(&lpbmi->bmiHeader.biPlanes, IO_SHORT_I);file->IOType(&lpbmi->bmiHeader.biBitCount, IO_SHORT_I);file->IOType(&lpbmi->bmiHeader.biCompression, IO_LONG_I);file->IOType(&lpbmi->bmiHeader.biSizeImage, IO_LONG_I);file->IOType(&lpbmi->bmiHeader.biXPelsPerMeter, IO_LONG_I);file->IOType(&lpbmi->bmiHeader.biYPelsPerMeter, IO_LONG_I);file->IOType(&lpbmi->bmiHeader.biClrUsed, IO_LONG_I);file->IOType(&lpbmi->bmiHeader.biClrImportant, IO_LONG_I);if (grayScale)	{	for (i = 0; i < clrCount; i++)		{		gray = ((long)lpbmi->bmiColors[i].rgbRed + lpbmi->bmiColors[i].rgbGreen + lpbmi->bmiColors[i].rgbBlue)/3;    	grayRGB = RGB(gray, gray, gray);		file->IOType(&grayRGB, IO_LONG_I);		}	}else	{	for (i = 0; i < clrCount; i++)		file->IOType(&lpbmi->bmiColors[i], IO_LONG_I);	}return(0);}intBMPWriter::UpdateColorTable(LPBITMAPINFO lpbmi, int bitDepth, ULong where){int 				headerSize, i, clrCount;long				gray, grayRGB;/* init */if (bitDepth > 8)	return(0);else	clrCount = 1 << (bitDepth);/*  Not done this way nowif (lpbmi->bmiHeader.biClrUsed)	{	headerSize = sizeof(BITMAPINFOHEADER) + (lpbmi->bmiHeader.biClrUsed * sizeof(RGBQUAD));	}else	{	headerSize = sizeof(BITMAPINFOHEADER);	if (lpbmi->bmiHeader.biBitCount < BMP_SMALLEST_TRUECOLOR_DEPTH)		headerSize += ((1 << (lpbmi->bmiHeader.biBitCount)) * sizeof(RGBQUAD));	}*//* step two:  update the BITMAPHEADER */file->IOTypePosition(&lpbmi->bmiHeader.biSize, IO_LONG_I, where+36);/* where does the "36" -----------------------------------------^come from?  Here:	file->IOType(&lpbmi->bmiHeader.biWidth, IO_LONG_I);   //4	file->IOType(&lpbmi->bmiHeader.biHeight, IO_LONG_I);  //8	file->IOType(&lpbmi->bmiHeader.biPlanes, IO_SHORT_I);    //10	file->IOType(&lpbmi->bmiHeader.biBitCount, IO_SHORT_I);     //12	file->IOType(&lpbmi->bmiHeader.biCompression, IO_LONG_I);   //16	file->IOType(&lpbmi->bmiHeader.biSizeImage, IO_LONG_I);     //20	file->IOType(&lpbmi->bmiHeader.biXPelsPerMeter, IO_LONG_I);  //24	file->IOType(&lpbmi->bmiHeader.biYPelsPerMeter, IO_LONG_I);   //28	file->IOType(&lpbmi->bmiHeader.biClrUsed, IO_LONG_I);         //32	file->IOType(&lpbmi->bmiHeader.biClrImportant, IO_LONG_I);    //36	jca 23AUG94 VR1.0.1 */if (grayScale)	{	for (i = 0; i < clrCount; i++)		{		gray = ((long)lpbmi->bmiColors[i].rgbRed + lpbmi->bmiColors[i].rgbGreen + lpbmi->bmiColors[i].rgbBlue)/3;    	grayRGB = RGB(gray, gray, gray);		file->IOType(&grayRGB, IO_LONG_I);		}	}else	{	for (i = 0; i < clrCount; i++)		file->IOType(&lpbmi->bmiColors[i], IO_LONG_I);	}return(0);}intBMPWriter::WriteFileHeader(LPBITMAPINFO lpbmi, ULong  where){BITMAPFILEHEADER	bmfh;/* step zero:  create the BITMAPFILEHEADER */bmfh.bfType = BFT_BITMAP; bmfh.bfSize = 0;     	/* this is filled in later */bmfh.bfReserved1 = bmfh.bfReserved2 = 0;bmfh.bfOffBits = 0;		/* this is also filled in later *//* pad the offset so it starts on a 4-byte boundary *//*if ((bmfh.bfOffBits % 4) != 0)	{	bmfh.bfOffBits = (bmfh.bfOffBits + 3) & -4;	}  *//* step one:  write the BITMAPFILEHEADER */file->IOTypePosition(&bmfh.bfType, IO_SHORT_I, where);file->IOType(&bmfh.bfSize, IO_LONG_I);file->IOType(&bmfh.bfReserved1, IO_SHORT_I);file->IOType(&bmfh.bfReserved2, IO_SHORT_I);file->IOType(&bmfh.bfOffBits, IO_LONG_I);return(0);}intBMPWriter::UpdateHeaders(LPBITMAPINFO lpbmi, ULong  where){BITMAPFILEHEADER	bmfh;int 				headerSize;long 				compress = compression;long				wid = theWidth, hei = theHeight;/* step zero:  recreate the header */if (lpbmi->bmiHeader.biClrUsed)	headerSize = sizeof(BITMAPINFOHEADER) + (lpbmi->bmiHeader.biClrUsed * sizeof(RGBQUAD));else	{	headerSize = sizeof(BITMAPINFOHEADER);	if (lpbmi->bmiHeader.biBitCount < BMP_SMALLEST_TRUECOLOR_DEPTH)		headerSize += ((1 << (lpbmi->bmiHeader.biBitCount)) * sizeof(RGBQUAD));	}bmfh.bfType = BFT_BITMAP;bmfh.bfReserved1 = bmfh.bfReserved2 = 0;bmfh.bfOffBits = headerSize + sizeof(BITMAPFILEHEADER);/* pad the offset so it starts on a 4-byte boundary *//*if ((bmfh.bfOffBits % 4) != 0)	{	bmfh.bfOffBits = (bmfh.bfOffBits + 3) & -4;	}*//* this is what we're updating */bmfh.bfSize = (DWORD)(file->IOGetPosition() - where);lpbmi->bmiHeader.biSizeImage = (DWORD)(file->IOGetPosition() - bmfh.bfOffBits);/* write the header */file->IOTypePosition(&bmfh.bfType, IO_SHORT_I, where);file->IOType(&bmfh.bfSize, IO_LONG_I);file->IOType(&bmfh.bfReserved1, IO_SHORT_I);file->IOType(&bmfh.bfReserved2, IO_SHORT_I);file->IOType(&bmfh.bfOffBits, IO_LONG_I);/* step two:  write the BITMAPHEADER */file->IOType(&lpbmi->bmiHeader.biSize, IO_LONG_I);file->IOType(&wid, IO_LONG_I);file->IOType(&hei, IO_LONG_I);file->IOType(&lpbmi->bmiHeader.biPlanes, IO_SHORT_I);file->IOType(&lpbmi->bmiHeader.biBitCount, IO_SHORT_I);file->IOType(&compress, IO_LONG_I);file->IOType(&lpbmi->bmiHeader.biSizeImage, IO_LONG_I);return(0);}#endifintBMPWriter::WriteImage(TranslatorPreference *transPref){#if WINDOWSV_Array			*bmiStore, *fakeBmiStore;LPBITMAPINFO	bitmapInfo, fakeBitmapInfo;long			fileStartPos;/* get the starting file position */fileStartPos = file->IOGetPosition();/* do the translator pref things */if (transPref->outputColorDepth <= 1)	depth = 1;else if (transPref->outputColorDepth <= 4)	depth = 4;else if (transPref->outputColorDepth <= 8)	depth = 8;else if (transPref->outputColorDepth <= 24)	depth = 24;else	depth = 24;if ((!transPref->EPSColorFlag) && (transPref->outputColorDepth > 1))	grayScale = 1;else	grayScale = 0;/* set up compression */if ((transPref->TIFFCompression) && (depth == 4))	compression = BI_RLE4;   else if ((transPref->TIFFCompression) && (depth == 8))	compression = BI_RLE8;else        	compression = BI_RGB;/* make the header */bmiStore = new(V_Array);bmiStore->cArray(0, sizeof(char), 1);if (CreateBMPHeader(bmiStore))	return(-1);bitmapInfo = (LPBITMAPINFO) bmiStore->Use();/* make a header to use in the GetDIBits call.  This one must bevery vanilla (no compression, offscreen internal sizing, etc) */fakeBmiStore = new(V_Array);fakeBmiStore->cArray(0, sizeof(char), 1);if (CreateBMPHeader(fakeBmiStore))	return(-1);/* set the info that GetDIBits wants to see */fakeBitmapInfo = (LPBITMAPINFO) fakeBmiStore->Use();fakeBitmapInfo->bmiHeader.biWidth = screen->wBmWidth;		// width of the internal bitmap, not the image to write outfakeBitmapInfo->bmiHeader.biHeight = screen->wBmHeight;fakeBitmapInfo->bmiHeader.biBitCount = depth;fakeBitmapInfo->bmiHeader.biCompression = BI_RGB;/* write the file header */WriteFileHeader(bitmapInfo, fileStartPos);/* write the bitmap header, or at least save space for it */WriteBMPHeader(bitmapInfo, fileStartPos + sizeof(BITMAPFILEHEADER));/* write the bitmap bits */WriteBitmapBits(fakeBitmapInfo, fileStartPos);/* update the file header */UpdateHeaders(bitmapInfo, fileStartPos);/* update the bitmap header.  Only the colortable needs updating, so we usethe fakeBitmapInfo.  The bitmapInfo has never been inited properly, but thefakeBitmapInfo has.  We should pass in the true color depth, though. */UpdateColorTable(fakeBitmapInfo, depth, fileStartPos + sizeof(BITMAPFILEHEADER));bmiStore->Unuse();bmiStore->dArray();#endifreturn(0);}#if WINDOWSintBMPWriter::WriteBitmapBits(LPBITMAPINFO bitmapInfo, ULong fileStart){V_Array			*buffer;long			i, j, bufferSize, theImageWidth;ULong 	fileDist;HDC				HDeviceContext;char			*bufferPtr;#if WINDOWSRect			dcRect;HBITMAP			tempBits;#endif/* set the bufferSize (pad to the byte) */bufferSize = (((bitmapInfo->bmiHeader.biBitCount * bitmapInfo->bmiHeader.biWidth) + 7)>>3);theImageWidth = (((bitmapInfo->bmiHeader.biBitCount * theWidth) + 7)>>3);/* pad to the 4-byte boundary */bufferSize = (bufferSize + 3) & -4;theImageWidth = (theImageWidth + 3) & -4;if (compression != BI_RGB)	{	bufferSize *= 2;      /* if we are compressing, allocate more space */	}/* init the copying buffer */buffer = new(V_Array);buffer->cArray(0, sizeof(char), 1);if (buffer->SetLength(bufferSize))	{	AlertMessage(TXTW_MEMORY);	buffer->dArray();	return -1;    }/* make sure the strip starts on a 4-byte boundary *//*fileDist = file->IOGetPosition() - fileStartPos;if ((fileDist & 3) != 0)	{	fileDist = (fileDist + 3) & -4;	file->IOSetPosition(fileDist);	}*/bufferPtr = (char *) buffer->Use();HDeviceContext = screen->GetMetaPort(&dcRect);screen->SetMetaPort();// We're not supposed to have the bitmap selected//when we do SetDIBits calls, so let's unselect it.tempBits = SelectObject(HDeviceContext, screen->oldBitmap);ASSERT(tempBits == screen->bitmap);/* Get the scan lines */for (i = 0; i < bitmapInfo->bmiHeader.biHeight; i++)	{	if (0 >= (GetDIBits(HDeviceContext, tempBits, i, 1,		(void FAR*)bufferPtr, (BITMAPINFO FAR*) bitmapInfo, DIB_RGB_COLORS)))		{		ReportBMPError(BMP_GETDIBITS_ERROR);		screen->UnsetMetaPort();		screen->ReleaseMetaPort(HDeviceContext);		buffer->Unuse();		buffer->dArray();		return(-1);		}	else		{		/* do all the saving */	   if (compression == BI_RGB)       		{			file->IOData(bufferPtr, theImageWidth);			}		else			{			long bufLength = 0;			/* do the compression */			if (compression == BI_RLE8)				bufLength = CompressRLE8(bufferPtr, theWidth, theWidth);			else if (compression == BI_RLE4)				bufLength = CompressRLE4(bufferPtr, theWidth, theWidth);			/* write out the strip */			if (bufLength)				{				if (i != bitmapInfo->bmiHeader.biHeight - 1)					{                    char	eol = 0;					file->IOData(&eol, 1);					file->IOData(&eol, 1);                    bufLength += 2;					}				else                	{					char	eof = 0;					file->IOData(&eof, 1);					eof = 1;					file->IOData(&eof, 1);					bufLength += 2;					}				}			else	/* whoops!  error in strip */				{				ReportBMPError(BMP_COMPRESS_ERROR);                screen->UnsetMetaPort();				screen->ReleaseMetaPort(HDeviceContext);				buffer->Unuse();				buffer->dArray();				return(-1);				}			} 		}	}SelectObject(HDeviceContext, tempBits);screen->UnsetMetaPort();screen->ReleaseMetaPort(HDeviceContext);buffer->Unuse();buffer->dArray();return(0);}intBMPWriter::CompressRLE8(char *uncompressed, long length, long imageWidth){	register int 	uncompIter;	int		pixCount, copyBegin, copyCount, state;	unsigned char lastPixel;	char	filler = 0;	ULong	stripStart, stripEnd;	/* initialize the variables of the state machine */	lastPixel = uncompressed[0];	pixCount = 1;	uncompIter = 1;	copyBegin = 0;	copyCount = 1;    stripStart = file->IOGetPosition();	if (lastPixel == uncompressed[uncompIter])		state = REPLICATE_STATE;	else    	state = COPY_STATE;	/* 	COPY:  copy the next -n pixels to the file		REPLICATE:  replicate the next pixel n times	*/while (uncompIter < length)	{	if (state == REPLICATE_STATE)		{		if (lastPixel == uncompressed[uncompIter])			{			uncompIter++;			pixCount++;			if (pixCount == RLE_PACKET_MAX)				{				file->IOData(&pixCount, 1);				file->IOData(&lastPixel, 1);				pixCount = 0;				if (uncompIter < length)					{                    copyBegin = uncompIter;					lastPixel = uncompressed[uncompIter++];					pixCount++;					copyCount = 1;					}				state = COPY_STATE;				}			}		else			{			state = COPY_STATE;			if (pixCount)				{				file->IOData(&pixCount, 1);				file->IOData(&lastPixel, 1);				copyBegin = uncompIter;				lastPixel = uncompressed[uncompIter++];				pixCount = 1;				copyCount = 1;				}			}		}	else /* if (state == COPY_STATE)  */		{		if (lastPixel != uncompressed[uncompIter])			{            copyCount++;			lastPixel = uncompressed[uncompIter++];			pixCount++;				if (pixCount == RLE_PACKET_MAX)				{				file->IOData(&filler, 1);				file->IOData(&pixCount, 1);				file->IOData(&uncompressed[copyBegin], copyCount);				if ((copyCount % 2) == 1)					{					file->IOData(&filler, 1);                    }				pixCount = 0;				if (uncompIter < length)					{                    copyBegin = uncompIter;					lastPixel = uncompressed[uncompIter++];					pixCount++;                    copyCount = 1;					}				}			}		else			{			state = REPLICATE_STATE;            /* backtrack one location */			if (pixCount - 1 > 0)				{				pixCount--;				copyCount--;				if (pixCount < 3)					{					filler = 1;					file->IOData(&filler, 1);					file->IOData(&uncompressed[copyBegin], 1);					if (pixCount == 2)						{						file->IOData(&filler, 1);						file->IOData(&uncompressed[copyBegin+1], 1);						}            		filler = 0;					}				else                	{					file->IOData(&filler, 1);					file->IOData(&pixCount, 1);					file->IOData(&uncompressed[copyBegin], copyCount);					if ((copyCount % 2) == 1)						{						file->IOData(&filler, 1);                    	}					}				pixCount = 1;				if (uncompIter < length)					{                    copyBegin = uncompIter;					lastPixel = uncompressed[uncompIter++];					pixCount++;                    copyCount = 1;                    }				}			}		}	}if (pixCount)	{	if (state == REPLICATE_STATE)		{		file->IOData(&pixCount, 1);		file->IOData(&lastPixel, 1);		}	else  /* state == COPY_STATE */		{		if (pixCount < 3)			{			filler = 1;			file->IOData(&filler, 1);			file->IOData(&uncompressed[copyBegin], 1);			if (pixCount == 2)				{				file->IOData(&filler, 1);				file->IOData(&uncompressed[copyBegin+1], 1);				}            filler = 0;			}		else            {			file->IOData(&filler, 1);			file->IOData(&pixCount, 1);			file->IOData(&uncompressed[copyBegin], copyCount);			if ((copyCount % 2) == 1)				{				file->IOData(&filler, 1);				}			}		}	}stripEnd = file->IOGetPosition();return(stripEnd-stripStart);}intBMPWriter::CompressRLE4(char *uncompressed, long length, long imageWidth){	ULong	stripStart, stripEnd;	register int 	uncompIter, pixUncompPos;	int		pixPacketCount, pixBufCount, bufPos, state;	unsigned char prev1, prev2, curr1, curr2, copyBuf[128];	char	filler, lastPixel;	/* initialize the variables of the state machine */	stripStart = file->IOGetPosition();	pixPacketCount = 2;  /* count of pixels in this packet */    pixBufCount = 2;     /* count of pixels in the copy out buffer */	uncompIter = 0;      /* byte position in uncompressed copyBuf */	pixUncompPos = 0;    /* pixel position in uncompressed copyBuf */	prev1 = GET_NEXT_PIXEL(uncompIter, pixUncompPos, uncompressed);	prev2 = GET_NEXT_PIXEL(uncompIter, pixUncompPos, uncompressed);	curr1 = GET_NEXT_PIXEL(uncompIter, pixUncompPos, uncompressed);	curr2 = GET_NEXT_PIXEL(uncompIter, pixUncompPos, uncompressed);	copyBuf[0] = prev1 << 4 | prev2;      /* init output copyBuf */	if (prev1 == curr1)		state = REPLICATE_STATE;	else    	state = COPY_STATE;	/* 	COPY:  copy the next n pixels to the buffer		REPLICATE:  replicate the next two pixels n times	*//* in the standard case, we get two pixels from the buffer.  We makespecial enquiries for the non-standard cases. */while (pixUncompPos + 1 < imageWidth)	{	if (state == REPLICATE_STATE)		{		if ((prev1 == curr1) && (pixPacketCount < RLE_PACKET_MAX))			{			pixPacketCount++;          /* add pixel to packet */			if ((prev2 != curr2) || (pixPacketCount == RLE_PACKET_MAX))				{ /* change state */				lastPixel = prev1 << 4 | prev2;				file->IOData(&pixPacketCount, 1);				file->IOData(&lastPixel, 1);				/* a non-standard case */				if (pixUncompPos + 2 < imageWidth)					{					pixPacketCount = 2;                	prev1 = curr2;					prev2 = GET_NEXT_PIXEL(uncompIter, pixUncompPos, uncompressed); 					curr1 = GET_NEXT_PIXEL(uncompIter, pixUncompPos, uncompressed);					curr2 = GET_NEXT_PIXEL(uncompIter, pixUncompPos, uncompressed);					bufPos = 0;                    pixBufCount = 0;					STUFF_PIXEL(copyBuf, bufPos, pixBufCount, prev1);					STUFF_PIXEL(copyBuf, bufPos, pixBufCount, prev2);					}				else					{                    /* prev1, prev2, and curr1 are left */					prev1 = curr2;					prev2 = GET_NEXT_PIXEL(uncompIter, pixUncompPos, uncompressed); 					curr1 = GET_NEXT_PIXEL(uncompIter, pixUncompPos, uncompressed);					pixPacketCount = 0;                					if (prev1 == curr1)						{  /* replicate */						filler = 3;                        lastPixel = prev1 << 4 | prev2;						file->IOData(&filler, 1);						file->IOData(&lastPixel, 1);						}					else						{  /* copy */						filler = 0;						copyBuf[0] = prev1 << 4 | prev2;						copyBuf[1] = curr1 << 4;						file->IOData(&filler, 1);                        filler = 3;						file->IOData(&filler, 1);						file->IOData(&copyBuf[0], 2);						}					}				state = COPY_STATE;				}			else /* (prev2 == curr2) */				{ /* add next another pixel to packet, no state change */				pixPacketCount++;				prev1 = curr1;                prev2 = curr2;				curr1 = GET_NEXT_PIXEL(uncompIter, pixUncompPos, uncompressed);				curr2 = GET_NEXT_PIXEL(uncompIter, pixUncompPos, uncompressed);				}			}		else  /* (prev1 != curr1) or (pixPacketCount == MAX_RLE_PACKET) */			{ /* change state */			state = COPY_STATE;			if (pixPacketCount)				{				lastPixel = prev1 << 4 | prev2;				file->IOData(&pixPacketCount, 1);                file->IOData(&lastPixel, 1);				prev1 = curr1;				prev2 = curr2;				curr1 = GET_NEXT_PIXEL(uncompIter, pixUncompPos, uncompressed);				curr2 = GET_NEXT_PIXEL(uncompIter, pixUncompPos, uncompressed);				pixPacketCount = 2;				bufPos = 0;                pixBufCount = 0;				STUFF_PIXEL(copyBuf, bufPos, pixBufCount, prev1);				STUFF_PIXEL(copyBuf, bufPos, pixBufCount, prev2);				}			}		}	else /* if (state == COPY_STATE) */		{		if ((prev1 == curr1) && (prev2 == curr2))			{			/* backtrack and change states to REPLICATE state */			pixPacketCount -= 2;			bufPos -= 1;			state = REPLICATE_STATE;			/* the absolute mode (COPY) must have 3 pixels or more			in a strip.  Make this an encoded (REPLICATE) packet */			if (pixPacketCount < 3)				{				if (pixPacketCount == 1)					{  /* write the packet */					filler = 1;					lastPixel = copyBuf[0] & 0xF0;					file->IOData(&filler, 1);					file->IOData(&lastPixel, 1);					}				else if (pixPacketCount == 2)					{  /* write the packet */                    filler = 2;					file->IOData(&filler, 1);					file->IOData(&copyBuf[0], 1);					}                /* else pixPacketCount <= 0.  Whoops! */				}			else				{ /* absolute mode.  Write dem pixels */				filler = 0;				file->IOData(&filler, 1);				filler = pixPacketCount;				file->IOData(&filler, 1);				file->IOData(&copyBuf[0], (pixPacketCount+1)/2);				if (((pixPacketCount+1)/2) & 0x01)					{ /* word-align the packet */					filler = 0;                    file->IOData(&filler, 1);                    }				}			/* set-up right counter info */			prev1 = curr1;			prev2 = curr2;			curr1 = GET_NEXT_PIXEL(uncompIter, pixUncompPos, uncompressed);			curr2 = GET_NEXT_PIXEL(uncompIter, pixUncompPos, uncompressed);			bufPos = 0;            pixBufCount = 0;			STUFF_PIXEL(copyBuf, bufPos, pixBufCount, prev1);			STUFF_PIXEL(copyBuf, bufPos, pixBufCount, prev2);			pixPacketCount = 4;			}		else			{			/* keep copying */			STUFF_PIXEL(copyBuf, bufPos, pixBufCount, curr1);			pixPacketCount++;			if (pixPacketCount == RLE_PACKET_MAX)				{ /* write out, start over */				filler = 0;				file->IOData(&filler, 1);				filler = pixPacketCount;				file->IOData(&filler, 1);				file->IOData(&copyBuf[0], (pixPacketCount+1)/2);				if (((pixPacketCount+1)/2) & 0x01)					{ /* word-align the packet */					filler = 0;                    file->IOData(&filler, 1);					}				/* special exotic case */				if (pixUncompPos + 2 < imageWidth)					{/* reset the pixel counters */					prev1 = curr2;					prev2 = GET_NEXT_PIXEL(uncompIter, pixUncompPos, uncompressed);					curr1 = GET_NEXT_PIXEL(uncompIter, pixUncompPos, uncompressed);					curr2 = GET_NEXT_PIXEL(uncompIter, pixUncompPos, uncompressed);					pixPacketCount = 2;					bufPos = 0;           			pixBufCount = 0;					STUFF_PIXEL(copyBuf, bufPos, pixBufCount, prev1);					STUFF_PIXEL(copyBuf, bufPos, pixBufCount, prev2);					}				else					{					/* prev1, prev2, and curr1 are left */					prev1 = curr2;					prev2 = GET_NEXT_PIXEL(uncompIter, pixUncompPos, uncompressed); 					curr1 = GET_NEXT_PIXEL(uncompIter, pixUncompPos, uncompressed);					pixPacketCount = 0;                					if (prev1 == curr1)						{  /* replicate */						filler = 3;                        lastPixel = prev1 << 4 | prev2;						file->IOData(&filler, 1);						file->IOData(&lastPixel, 1);						}					else						{  /* copy */						filler = 0;						copyBuf[0] = prev1 << 4 | prev2;						copyBuf[1] = curr1 << 4;						file->IOData(&filler, 1);                        filler = 3;						file->IOData(&filler, 1);						file->IOData(&copyBuf[0], 2);						}					}				}			else  /* we have not filled the buffer */				{				/* keep copying */				STUFF_PIXEL(copyBuf, bufPos, pixBufCount, curr2);				pixPacketCount++;				prev1 = curr1;				prev2 = curr2;				curr1 = GET_NEXT_PIXEL(uncompIter, pixUncompPos, uncompressed);				curr2 = GET_NEXT_PIXEL(uncompIter, pixUncompPos, uncompressed);				}			}		}	}/* check that doing the final write-out and clean ups will not cause the packet to over flow.If so, do a special case */if (pixPacketCount + 3 >= RLE_PACKET_MAX)	{	int nLeft = imageWidth - pixUncompPos;	char final;	if (nLeft) final = GET_NEXT_PIXEL(uncompIter, pixUncompPos, uncompressed);	if (state == REPLICATE_STATE)		{        lastPixel = prev1 << 4 | prev2;		file->IOData(&pixPacketCount, 1);        file->IOData(&lastPixel, 1);		}	else		{        filler = 0;		file->IOData(&filler, 1);		file->IOData(&pixPacketCount, 1);		file->IOData(&copyBuf[0], ((pixPacketCount+1)/2));		if (((pixPacketCount+1)/2) & 0x01)			file->IOData(&filler, 1);		}    /* write out a packet to end stuff */	if (nLeft)		{        pixPacketCount = 3;        lastPixel = curr1 << 4 | curr2;		if (final == curr1)			{ /* write a replicate packet */			file->IOData(&pixPacketCount, 1);            file->IOData(&lastPixel, 1);			}		else			{ /* write a copy packet */			filler = 0;            final <<= 4;			file->IOData(&filler, 1);			file->IOData(&pixPacketCount, 1);			file->IOData(&lastPixel, 1);			file->IOData(&final, 1);			}		}	else		{  /* write a replicate packet */       	pixPacketCount = 2;		lastPixel = curr1 << 4 | curr2;		file->IOData(&pixPacketCount, 1);        file->IOData(&lastPixel, 1);		}        pixPacketCount = 0;	}/* there are 0 or 1 pixels left.  The variables [prev1,prev2,curr1,curr2]are all filled, but there are not enough pixels to fill them anothertime.  pixPacketCount >= 2.  imageWidth <= pixUncompPos + 1 */if (pixPacketCount)	{	int nLeft = imageWidth - pixUncompPos;	char final;	if (nLeft) final = GET_NEXT_PIXEL(uncompIter, pixUncompPos, uncompressed);	if (pixPacketCount < 3)	state = REPLICATE_STATE;	if (state == REPLICATE_STATE)		{		if (prev1 == curr1)			{            pixPacketCount++;			if (prev2 == curr2)				{				pixPacketCount++;				if (nLeft)					{  /* one pixel to go */					if (final == curr1)						{  /* we have one packet */						pixPacketCount++;						lastPixel = prev1 << 4 | prev2;						file->IOData(&pixPacketCount, 1);						file->IOData(&lastPixel, 1);						}					else  /* write two replicate packets */						{						lastPixel = prev1 << 4 | prev2;						filler = 1;                        final <<= 4;						file->IOData(&pixPacketCount, 1);						file->IOData(&lastPixel, 1);						file->IOData(&filler, 1);						file->IOData(&final, 1);						}					}				else /* no pixels left */					{					lastPixel = prev1 << 4 | prev2;					file->IOData(&pixPacketCount, 1);					file->IOData(&lastPixel, 1);					}				}			else   /* (prev1 == curr1) but (prev2 != curr2) */				{                /* write one replicate packet */				lastPixel = prev1 << 4 | prev2;				file->IOData(&pixPacketCount, 1);				file->IOData(&lastPixel, 1);				/* write a replicate packet for the one or two pixels left */				lastPixel = curr2 << 4;                pixPacketCount = 1;				if (nLeft)					{					lastPixel |= final;					pixPacketCount++;                    }				file->IOData(&pixPacketCount, 1);				file->IOData(&lastPixel, 1);				}			}		else   /* prev1 != curr1 */			{			/* write one replicate packet */			lastPixel = prev1 << 4 | prev2;			file->IOData(&pixPacketCount, 1);			file->IOData(&lastPixel, 1);			/* if final, then write a copy packet.  Otherwise, write a replicate */			if (nLeft)				{				copyBuf[0] = curr1 << 4 | curr2;				copyBuf[1] = final << 4;				filler = 0;                pixPacketCount = 3;				file->IOData(&filler, 1);				file->IOData(&pixPacketCount, 1);				file->IOData(&copyBuf[0], 2);				}			else         /* two pixels left; write a replicate packet */				{				lastPixel = curr1 << 4 | curr2;                pixPacketCount = 2;				file->IOData(&pixPacketCount, 1);				file->IOData(&lastPixel, 1);				}			}		}	else   /* in COPY_STATE */		{		/* If we get to this point, pixPacketCount >= 3 and neither curr1 nor		curr2 have been added to the packet yet.  if (curr1 == prev1), then		backtrack and make a replicate packet in addition to any copy packets. */		if (prev1 == curr1)			{			pixPacketCount -= 2;			pixBufCount -= 2;			bufPos--;			/* if pixPacketCount >= 3, write a copy packet for it.  Otherwise,			break the stuff into replicate packets */			if (pixPacketCount >= 3)				{                filler = 0;				file->IOData(&filler, 1);				file->IOData(&pixPacketCount, 1);				file->IOData(&copyBuf[0], ((pixPacketCount+1)/2));				if (((pixPacketCount+1)/2) & 0x01)					file->IOData(&filler, 1);				}			else if (pixPacketCount > 0)				{				if (pixPacketCount == 2)					lastPixel = copyBuf[0];				else					lastPixel = copyBuf[0] & 0xF0;				file->IOData(&pixPacketCount, 1);				file->IOData(&lastPixel, 1);				}			if (prev2 == curr2)    /* add to the replicate packet if possible */				{				lastPixel = prev1 << 4 | prev2;                pixPacketCount = 4;				if (nLeft)                	{					if (final == prev1)						{						pixPacketCount = 5;						file->IOData(&pixPacketCount, 1);						file->IOData(&lastPixel, 1);						}					else						{						final <<= 4;                        filler = 1;						file->IOData(&pixPacketCount, 1);						file->IOData(&lastPixel, 1);						file->IOData(&filler, 1);						file->IOData(&final, 1);						}					}				else    /* no extra pixels to tack on.  Write out the existing ones */					{					file->IOData(&pixPacketCount, 1);					file->IOData(&lastPixel, 1);					}				}			else                   /* make another packet */				{				lastPixel = curr2 << 4;				pixPacketCount = 1;				if (nLeft)					{					pixPacketCount++;                    lastPixel |= final;					}				file->IOData(&pixPacketCount, 1);				file->IOData(&lastPixel, 1);				}			}		else   /* make copy packets */			{ 			filler = 0;        	pixPacketCount += 2;			STUFF_PIXEL(copyBuf, bufPos, pixBufCount, curr1);			STUFF_PIXEL(copyBuf, bufPos, pixBufCount, curr2);			if (nLeft)				{            	pixPacketCount++;				STUFF_PIXEL(copyBuf, bufPos, pixBufCount, final);				}			file->IOData(&filler, 1);			filler = pixPacketCount;			file->IOData(&filler, 1);			file->IOData(&copyBuf[0], (pixPacketCount+1)/2);			if (((pixPacketCount+1)/2) & 0x01)				{ /* word-align the packet */				filler = 0;           	 	file->IOData(&filler, 1);            	}			}		}	}stripEnd = file->IOGetPosition();return(stripEnd-stripStart);}voidBMPWriter::SetScreen(V_Offscreen *scr){	screen = scr;}V_Offscreen *BMPWriter::GetScreen(){	return(screen);}voidBMPWriter::SetCompression(int compr){	if ((depth == 8) && (compr == BI_RLE8))		compression = compr;	else if ((depth == 4) && (compr == BI_RLE4))		compression = compr;	else		compression = BI_RGB;}intBMPWriter::GetCompression(){	return(compression);}voidBMPWriter::SetDepth(int d){	depth = d;}intBMPWriter::GetDepth(){	return(depth);}/* 13 Dec 93 jcaReport the error, with the name of the file it failed on*/voidBMPWriter::ReportBMPError(char *errStr){	char fname[64], errorMsg[256];	if (file->GetBufferType() == V_FILETYPE)    	{		((V_File*)file)->GetFName(fname);		}	else		fname[0] = 0;    sprintf(errorMsg, errStr, fname);	AlertMessage(errorMsg);}#endif