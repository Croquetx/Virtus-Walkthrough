/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	John C. Alspaugh * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include <stdio.h>#include "VTypes.h"#if VWT /* jca 17 Sept 93. Not in VR { */#include "VArray.h"#include "VDisplay.h"#include "VDialog.h"#include "VGUtil.h"#include "VMemUtil.h"#include "AppText.h"#include "AppDeflt.h"#include "ImgHandl.h"#include "TIFCompr.h"/* there is a max of 8 bits per sample *//*#define PROFILE_HASH_EFFICIENCY 1#define PROFILE_TIFF_TIME 1*/#ifdef PROFILE_HASH_EFFICIENCYstatic long CollisionsInAdd = 0;static long NumAdds = 0;static long AddAvgDepth = 0;static long SearchAvgDepth = 0;static long NumSearches = 0;static long CollisionsInSearch = 0;static long TotalCollisions = 0;static long TotalSearches = 0;static long AvgSearchDepth = 0;#endifvoidBaseCompressor::cCompressor(V_Buffer *theBuffer){buffer = theBuffer;}voidBaseCompressor::dCompressor(){delete this;}intBaseCompressor::WritePixels(V_Array* clearBuf, ULong *filePosition){}voidCompressor::cCompressor(V_Buffer *theBuffer){buffer = theBuffer;}voidCompressor::dCompressor(){delete this;}int Compressor::WritePixels(V_Array* clearBuf, ULong *filePosition){char	*bufAccess;bufAccess = (char *) clearBuf->Use();buffer->IOPosition(bufAccess, VA_Length(clearBuf), *filePosition);clearBuf->Unuse();*filePosition += VA_Length(clearBuf);return(VA_Length(clearBuf));}voidPackBitsCompressor::cPackBitsCompressor(V_Buffer *theBuffer){buffer = theBuffer;}voidPackBitsCompressor::dPackBitsCompressor(){delete this;}intPackBitsCompressor::WritePixels(V_Array *unCompBuf, ULong *filePosition){	register int 	uncompIter;	int		pixCount, copyBegin, copyCount, state;	unsigned char lastPixel;	char	*uncompressed, counter;	ULong	stripStart, stripEnd;	uncompressed = (char *)unCompBuf->Use();	/* initialize the variables of the state machine */	lastPixel = uncompressed[0];	pixCount = 1;	uncompIter = 1;	copyBegin = 0;	copyCount = 1;	// !!!!! stripStart = file->IOGetPosition();    stripStart = *filePosition;	if (lastPixel == uncompressed[uncompIter])		state = REPLICATE_STATE;	else    	state = COPY_STATE;	/* 	COPY:  copy the next -n pixels to the file		REPLICATE:  replicate the next pixel n times	*/while (uncompIter < VA_Length(unCompBuf))	{	if (state == REPLICATE_STATE)		{		if (lastPixel == uncompressed[uncompIter])			{			uncompIter++;			pixCount++;			if (pixCount == PACKBITS_MAX)				{                counter = 1-pixCount;				buffer->IOData(&counter, 1);				buffer->IOData(&lastPixel, 1);				pixCount = 0;				if (uncompIter < VA_Length(unCompBuf))					{                    copyBegin = uncompIter;					lastPixel = uncompressed[uncompIter++];					pixCount++;					copyCount = 1;					}				state = COPY_STATE;				}			}		else			{			state = COPY_STATE;			if (pixCount)				{				counter = 1-pixCount;				buffer->IOData(&counter, 1);				buffer->IOData(&lastPixel, 1);				copyBegin = uncompIter;				lastPixel = uncompressed[uncompIter++];				pixCount = 1;				copyCount = 1;				}			}		}	else /* if (state == COPY_STATE)  */		{		if (lastPixel != uncompressed[uncompIter])			{            copyCount++;			lastPixel = uncompressed[uncompIter++];			pixCount++;				if (pixCount == PACKBITS_MAX+1)				{                counter = pixCount-1;				buffer->IOData(&counter, 1);				buffer->IOData(&uncompressed[copyBegin], copyCount);				pixCount = 0;				if (uncompIter < VA_Length(unCompBuf))					{                    copyBegin += copyCount;					lastPixel = uncompressed[uncompIter++];					pixCount++;                    copyCount = 1;					}				}			}		else			{			state = REPLICATE_STATE;            /* backtrack one location */			if (pixCount - 1 > 0)				{				pixCount--;				copyCount--;                counter = pixCount-1;				buffer->IOData(&counter, 1);				buffer->IOData(&uncompressed[copyBegin], copyCount);				pixCount = 1;				if (uncompIter < VA_Length(unCompBuf))					{					copyBegin += copyCount;					lastPixel = uncompressed[uncompIter++];					pixCount++;                    copyCount = 1;                    }				}			}		}	}if (pixCount)	{	if (state == REPLICATE_STATE)		{		counter = 1-pixCount;		buffer->IOData(&counter, 1);		buffer->IOData(&lastPixel, 1);		}	else  /* state == COPY_STATE */		{		counter = pixCount - 1;		if (counter >= 0)			{			buffer->IOData(&counter, 1);			buffer->IOData(&uncompressed[copyBegin], copyCount);            }		}	}stripEnd = buffer->IOGetPosition();*filePosition = stripEnd; //!!!!!!unCompBuf->Unuse();return(stripEnd-stripStart);}voidLZWCompressor::cLZWCompressor(V_Buffer *theBuffer){buffer = theBuffer;BuildCRCTable();}voidLZWCompressor::dLZWCompressor(){delete this;}/* compression routines */intLZWCompressor::WritePixels(V_Array *clearBuf, ULong *filePosition){short			code[CODE_BUF_SIZE];char			*string, currChar;int 			i, posInCode, change, codeLength;ULong	hashValue, numEntries;char			*clearBufPtr;unsigned char	bitCount, bits;int				nBits;HashTableEntry	currString;V_Array			*hashTable;#ifdef PROFILE_TIFF_TIMElong	LocalTickTemp = TickCount();#endif/*ShowMem(0);*/change = 0; codeLength = 0; posInCode = 0;bitCount = bits = 0x0; hashValue = 0;/* set up all the string table stuff */hashTable = new (V_Array);hashTable->cArray(HASH_TABLE_SIZE, sizeof(HashTableEntry), 1);	InitHashTable(hashTable, &numEntries);currString.discriminator = '\0';currString.id = EMPTY;currString.parent = NO_PARENT;nBits = 9;clearBufPtr = (char *) clearBuf->Use();/* end init *//* we will write the output codes as 16-bit bytes into the code buffer, and then -- when it gets full -- convert the 16-bit bytes into 9,10,11,or12-bit bytes in the writeout procedure. */code[posInCode++] = CLEAR_CODE;	/* write the Clear code */for (i = 0; i < VA_Length(clearBuf); i++)	{	currChar = clearBufPtr[i];	AddtoString(currString, currChar);	hashValue = (short) Hash(hashValue, currChar);	if (-1 == InTable(hashTable,numEntries,&currString, hashValue))		{		code[posInCode++] = currString.parent;			change = AddToTable(hashTable, numEntries++, &currString, hashValue);		currString.discriminator = currChar;		currString.id = (((int) currChar) & 0x00FF);		currString.parent = NO_PARENT;		hashValue = Hash(0xFFFF, currChar);				/* write to file if near full or if we're just about to go to 		   the next size code */		if ((posInCode >= CODE_BUF_SIZE) || (change))			{			clearBuf->Unuse();			codeLength += CompactCodes(code, posInCode, nBits, &bitCount, &bits, filePosition, SAVE_LEFTOVERS);			if (change) nBits++;			posInCode = 0;									if (change == TIME_TO_CLEAR_TABLE)				{				/* store the current string and the EOI code to the buffer */				code[posInCode++] = currString.id;				code[posInCode++] = CLEAR_CODE;				/* write out the contents of the buffer as 12-bit words */				codeLength += CompactCodes(code, posInCode, 12, &bitCount, &bits, filePosition, SAVE_LEFTOVERS);					posInCode = 0;				nBits = 9;				currString.id = currString.parent = NO_PARENT;				InitHashTable(hashTable, &numEntries);#ifdef PROFILE_HASH_EFFICIENCY				printf("Search:  entered %ld times, collisions %ld times, avg search depth %g\n", NumSearches, CollisionsInSearch, (float) SearchAvgDepth/NumSearches);				printf("Add:     entered %ld times, collisions %ld times, avg search depth %g\n", NumAdds, CollisionsInAdd, (float) AddAvgDepth/NumAdds);				TotalSearches += NumSearches + NumAdds;				TotalCollisions += CollisionsInSearch + CollisionsInAdd;				AvgSearchDepth += AddAvgDepth + SearchAvgDepth;				CollisionsInSearch = NumSearches = CollisionsInAdd = 0;				NumAdds = AddAvgDepth = SearchAvgDepth = 0;#endif					}			clearBufPtr = (char *) clearBuf->Use();			}		}	}clearBuf->Unuse();/* Write the remaining codes, the EndOfInput code, and clear out buffer */if (posInCode > 0)       // is there anything in the code buffer to write out?	{	if (posInCode < CODE_BUF_SIZE - 2)		{ // if there is room in the code buffer, add in the last two codes.		code[posInCode++] = currString.id;		code[posInCode++] = END_OF_INPUT;		codeLength += CompactCodes(code, posInCode, nBits, &bitCount, &bits, filePosition, EMPTY);		}	else		{  // if there is not room in the code buffer for the remaining codes, then write the stuff in the buffer.		codeLength += CompactCodes(code, posInCode, nBits, &bitCount, &bits, filePosition, SAVE_LEFTOVERS);        // now poke in the last code and the end of input code, and write them out.		code[0] = currString.id;		code[1] = END_OF_INPUT;		codeLength += CompactCodes(code, 2, nBits, &bitCount, &bits, filePosition, EMPTY);		}	}else // write the remaining codes, and the end of input code.	{	code[0] = currString.id;	code[1] = END_OF_INPUT;	codeLength += CompactCodes(code, 2, nBits, &bitCount, &bits, filePosition, EMPTY);	}	#ifdef PROFILE_HASH_EFFICIENCYprintf("Search:  entered %ld times, collisions %ld times, avg search depth %g\n", NumSearches, CollisionsInSearch, (float) SearchAvgDepth/NumSearches);printf("Add:     entered %ld times, collisions %ld times, avg search depth %g\n", NumAdds, CollisionsInAdd, (float) AddAvgDepth/NumAdds);TotalSearches += NumSearches + NumAdds;TotalCollisions += CollisionsInSearch + CollisionsInAdd;AvgSearchDepth += AddAvgDepth + SearchAvgDepth;CollisionsInSearch = NumSearches = CollisionsInAdd = 0;NumAdds = AddAvgDepth = SearchAvgDepth = 0;#endifhashTable->dArray();	/* deallocate the hash table */#ifdef PROFILE_TIFF_TIMECompressTicks += TickCount() - LocalTickTemp;#endifreturn(codeLength);}intLZWCompressor::CompactCodes(short *str, int len, int numBits, unsigned char *residueCount, unsigned char *residue, ULong *filePos, int toDo){int	shift, byteNo, i, offset, newBits;char localBuf[ENCODED_BUF_SIZE];#ifdef PROFILE_TIFF_TIMElong	LocalTickTemp = TickCount();#endifbyteNo = 0; offset = 0;for (i = 0; i < ENCODED_BUF_SIZE; i++)		/* init the buffer */	localBuf[i] = '\x0';if (*residueCount)	{	offset = *residueCount;	localBuf[byteNo] |= *residue;	/* put the oh-so-carefully saved residue into the buffer */	}for (i = 0; i < len; i++) 	{	shift = SHORTBITS - (offset + numBits);	if (shift >= 0)		{		newBits = (str[i] << shift) & 0xFF00;		localBuf[byteNo++]  |= (unsigned char) (newBits >> 8);		newBits = (str[i] << shift) & 0x00FF;		localBuf[byteNo] |= (unsigned char) newBits;		offset = (CHARBITS - shift) % CHARBITS;		}	else		{		shift = 0 - shift;		newBits = (str[i] >> shift) & 0xFF00;		localBuf[byteNo++] |= (unsigned char) (newBits >> 8);		newBits = (str[i] >> shift) & 0x00FF;		localBuf[byteNo++] |= (unsigned char) newBits;		newBits = (str[i] << (SHORTBITS - shift)) & 0xFF00;		localBuf[byteNo] |= newBits >> 8;		offset = shift;				}	if (offset == 0) byteNo++;	}if (toDo == SAVE_LEFTOVERS)	{	*residueCount = offset;	if (offset != 0)		*residue = localBuf[byteNo];	}else if (toDo == EMPTY)			{	if (offset != 0)		byteNo++;		*residueCount = 0;	*residue = 0x00;	}buffer->IOPosition(localBuf, byteNo, *filePos);*filePos += byteNo;#ifdef PROFILE_TIFF_TIMEPackTicks += TickCount() - LocalTickTemp;#endifreturn(byteNo);}int	LZWCompressor::AddToTable(V_Array *table, ULong count, HashTableEntry *hte, ULong where){int i,ok,secondHash;HashTableEntry *htePtr;#ifdef PROFILE_TIFF_TIMElong LocalTickTemp = TickCount();#endif#ifdef PROFILE_HASH_EFFICIENCYint tmp = 1;NumAdds++;#endifhtePtr = (HashTableEntry *) table->Abuse();if (htePtr[where].id == NEVER_FILLED)	{	htePtr[where].id = (unsigned int) count;	htePtr[where].parent = hte->parent;	htePtr[where].discriminator = hte->discriminator;	}else	{	secondHash = where;	for (i = 0, ok = 1; i < HASH_TABLE_SIZE && ok; i++)		{#ifdef PROFILE_HASH_EFFICIENCY		CollisionsInAdd++;		tmp++;#endif		RetryHash(secondHash, secondHash);		if (htePtr[secondHash].id == NEVER_FILLED)			{			htePtr[secondHash].id = (unsigned int) count;			htePtr[secondHash].parent = hte->parent;			htePtr[secondHash].discriminator = hte->discriminator;			ok = 0;			}		else if ((htePtr[secondHash].parent == hte->parent) && (htePtr[secondHash].discriminator == hte->discriminator))				{			ok = 0;	/* we're in the table already */			}		}	}#ifdef PROFILE_HASH_EFFICIENCYAddAvgDepth += tmp;#endif	#ifdef PROFILE_TIFF_TIMEAddTableTicks += TickCount() - LocalTickTemp;#endifif (count == 511)			return(10);else if (count == 1023)		return(11);else if (count == 2047)		return(12);else if (count == 4093)		return(TIME_TO_CLEAR_TABLE);else						return(0);}voidLZWCompressor::InitHashTable(V_Array *table, ULong *entryCount){int i, hash;HashTableEntry	hte, *htePtr;#ifdef PROFILE_TIFF_TIMElong LocalTickTemp = TickCount();#endifhte.id = NEVER_FILLED;hte.parent = NO_PARENT;hte.discriminator = '/0';htePtr = (HashTableEntry *) table->Abuse();for (i = 0; i < HASH_TABLE_SIZE; i++)	htePtr[i] = hte;*entryCount = 258; /*start with entry number 258, since we have "filled" the first 257 */#ifdef PROFILE_TIFF_TIMEInitTableTicks += TickCount() - LocalTickTemp;#endif}int	LZWCompressor::InTable(V_Array *table, ULong entries, HashTableEntry *hte, ULong hash){int 	i, which, ok, secondHash;#ifdef PROFILE_TIFF_TIMElong LocalTickTemp = TickCount();#endif#ifdef PROFILE_HASH_EFFICIENCYint tmp = 1;NumSearches++;#endifif (hte->parent == NO_PARENT)	/* this is a single byte string */	{	hte->id = (int) hte->discriminator;	which = (int) hte->discriminator;	}else	{	HashTableEntry	*htePtr;		htePtr = (HashTableEntry *) table->Abuse();	if (htePtr[hash].id == NEVER_FILLED)	/* there has never been such an entry */		which = -1;	else 		{		/* if we have the same parent and have just added the same char, we are equal */		if ((htePtr[hash].parent == hte->parent) && (htePtr[hash].discriminator == hte->discriminator))				{			which = hash; 			hte->id = htePtr[hash].id;			}		else 			{	/* we have to search the table */			which = -1;			secondHash = hash;			for (i = 0, ok = 1; i < HASH_TABLE_SIZE && ok; i++)				{#ifdef PROFILE_HASH_EFFICIENCY				CollisionsInSearch++;				tmp++;#endif				RetryHash(secondHash, secondHash);				if ((htePtr[secondHash].parent == hte->parent) && (htePtr[secondHash].discriminator == hte->discriminator))						{					which = i; 					hte->id = htePtr[secondHash].id;					ok = 0;					}				else if (htePtr[secondHash].id == NEVER_FILLED)					{					ok = 0;					}				}			}		}	}#ifdef PROFILE_HASH_EFFICIENCYSearchAvgDepth += tmp;#endif	#ifdef PROFILE_TIFF_TIMEInTableTicks += TickCount() - LocalTickTemp;#endifreturn (which);}/***********************************************************************Cyclic Redundancy Code routines to do the hashing effectively.***********************************************************************/#if 0/*------------------------------------------------------------------------------*/CRC32		see dr. dobbs may '92  pg 64+; aug '92 pg 12+32-bit CRC as spec'd by CCITTTerms are	 32    26    23    22    16    12    11    10    8    7    5    4    2    1   X^  + X^  + X^  + X^  + X^  + X^  + X^  + X^  + X^ + X^ + X^ + X^ + X^ + X^ + 1   Note that this is implemented by shifting RIGHT -> hi bit is to the right.If viewed as a series of hardware xor latches, the next xor is selected by thebit being shifted OUT of the crc.  To make this faster, a syndrome table is precomputed.  Since its easier to work with bytes at the low end of the register,we flip the msb to be the rightmost position, ready for shifting RIGHT and OUT.Any crc could be used, just copy and use a different poly specifier.  Again,note that the x^0 etc is on the left, and x^23 is to the right./*------------------------------------------------------------------------------*/#endif#define CRC32_POLYNOMIAL (0xEDB88320L)#define CRC16_POLYNOMIAL (0x50080000L)voidLZWCompressor::BuildCRCTable(){int i;int j;ULong crc;for (i=0; i<= 255; i++)	{  /* for each possible 8-bit value */	crc = i;	/* pretend the low byte started with the value 'i' */		for (j=0; j<8; j++)		{  /* if the incoming is 'i', find all the repercussions */		if (crc & 1)			{  /* if the bit shifting out is 1, xor the poly again */			crc >>= 1;  /* shift the selector bit out */			crc &= 0x7FFFFFFFL;  /* (don't trust unsigned shifting) */			crc ^= CRC16_POLYNOMIAL;			}		else			{  /* else no change, just get next bit */			crc >>= 1;			crc &= 0x7FFFFFFFL;			}		}			CRCTable[i] = crc;	}}	/*------------------------------------------------------------------------------*//* CalculateCRC/*------------------------------------------------------------------------------*/#if 0This is the routine that calculates the CRC.  We precondition the CRC with all onesto start the series going.  Note that if the input chars happen to exactly match thecurrent CRC, then the beginning of the file is missed mod 32 (bits).  The originalchose all ones to match some other utilities and to 'generate' even with zeroed files.Actually, this is where a key could be used -- just set the CRC to start with the keyvalue.#endifULongLZWCompressor::Hash(ULong crc, unsigned char ichar){int crcTable_idx;ULong temp1;ULong temp2;retry = 0; /* mix the input with the crc, use to select the actual mixing values to use */crcTable_idx = (crc ^ ichar) & 0xff;temp1 = CRCTable[crcTable_idx];  /* get the changing bits */temp2 = (crc >> 8) & 0x00FFFFFFL;	/* shift out the 8 bits we just used */crc = temp1 ^ temp2;  /* mix back together */return (crc%HASH_TABLE_SIZE);}// jca 17 Sept 93.  }#endif // VWT