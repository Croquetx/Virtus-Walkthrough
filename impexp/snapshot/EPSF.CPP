/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				John C. Alspaugh *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "EPSF.h"#include "Clip.h"#include "VIO.h"#include "VArray.h"#include "AppFiles.h"#include "AppText.h"#include <stdio.h>#include <string.h>int polyFilter=FALSE;#if VWT	/* jca 17 Sept 93.  Not in VR { */Filter *filter;extern int GetVersion(char *);#define IBM_AVAILABLE 1char *LINE_TERM_MAC	="\r";	/* mac takes a CR for its newline */char *LINE_TERM_PC	="\r";	/* PC takes CR for its newline in AI and EPS files. *//* the strings are grouped by which data type they go with.  Strings used only   for the EPSF writeout are grouped under "EPSF," strings used only in the    Adobe Illustrator file formats are under "Adobe," and strings common to both   Adbode and EPSF formats are in the common section. --JCA 14 july 92 *//* common strings */char *Adobe3_0_intro="%%!PS-Adobe-3.0 EPSF-3.0%s";char *boundingBox="%%%%BoundingBox: %d %d %d %d%s" ;	/* 0 0 500 500 */char *title="%%%%Title: (%s %s)%s" ;		/* (MINIMAL.EPS) */char *creationDate="%%%%CreationDate: (%d/%d/%d)%s";	/* (20/12/91) (6:15 AM) */char *endComments="%%%%EndComments%s";char *endProlog="%%%%EndProlog%s";char *beginSetup="%%%%BeginSetup%s";char *endSetup="%%%%EndSetup%s";char *pageTrailer="%%%%PageTrailer%s";char *trailer="%%%%Trailer%s";char *eof="%%%%EOF%s";   /* EPSF strings */char *gsave="gsave%s";char *grestore="grestore%s";char *setlinewidth= "1.0 setlinewidth%s";char *setmiterlimit = "4.0 setmiterlimit%s";char *setdef="/polygon{0 setlinejoin	newpath%s";/*30 30 moveto 0 90 rlineto 45 -45 rlineto 45 45 rlineto 0 -90 rlineto*/char *closedef="closepath }def%s";char *polyfillgray= "polygon %4.2lf setgray fill%s";char *polyfillcolor="polygon %4.2lf %4.2lf %4.2lf setrgbcolor fill%s";char *polylinegray= "polygon %4.2lf setgray stroke%s";char *polylinecolor="polygon %4.2lf %4.2lf %4.2lf setrgbcolor stroke%s";char *polyclip=		"polygon clip%s";char *epsMoveto=	"%d %d moveto ";char *epsLineto=	"%d %d lineto ";/* Adobe Illustrator strings */const char *Adobe1_1_intro="%%!PS-Adobe-2.0 EPSF-1.2%s";const char *fillgray= 	"%4.2lf g%s";const char *fillcmykcolor="%4.2lf %4.2lf %4.2lf %4.2lf k%s";const char *strokegray= 	"%4.2lf G%s";const char *strokecmykcolor="%4.2lf %4.2lf %4.2lf %4.2lf K%s";const char *Adobe_setlinewidth= "1.0 w%s";const char *Adobe_setmiterlimit = "4.0 M%s";char *aiMoveto=	"%d %d m%s";char *aiLineto=	"%d %d L%s";char *aiCharLineterm= 	"%c%s";#define STROKE 	's'#define FILL 	'f'#define GROUP	'u'#define UNGROUP	'U'#define FILLANDSTROKE	'b'/* PC-related things */const char *pcEpsHeader = "\xC5\xD0\xD3\xC6\x1E\x0\x0\x0'";const char *pcEpsNulls = "\x0\x0\x0\x0\x0\x0\x0\x0";const char *pcEpsFF = "\xFF\xFF";const char *pc_fourbytes = "%c%c%c%c";void Filter::cFilter(V_Buffer *buf){buffer=buf;SetDisplayType(DISPLAY_PICT);/*this is just because of the convenience*/}void Filter::dFilter(void){delete this;}/* virtual functions do not need definitions, except in think c     */#if MACINTOSHvoid Filter::MakeHeader(void){}void Filter::SavePoly(V_Array *points,RGBColor *color,RGBColor *lineColor, int mode){}void Filter::MakeFooter(void){}#endifint Filter::Begin(void){if(offscreen)	{	offscreen->dOffscreen();	offscreen=0;	}filter=this;polyFilter=TRUE;return FALSE;}int Filter::End(void){filter=0;polyFilter=FALSE;return FALSE;}void EPSBase::cEPSBase(V_Buffer *buf){buffer=buf;SetDisplayType(DISPLAY_PICT);/*this is just because of the convenience*/tiffSize = tiffStart = 0;postscriptSize = 0;checkSum = '\0';flags = 0;lineTerm = LINE_TERM_MAC;	/* default line termination */}void EPSBase::dEPSBase(void){delete this;}/* virtual functions do not need definitionsvoid EPSBase::MakeHeader(void){}void EPSBase::SavePoly(V_Array *points,RGBColor *color,RGBColor *lineColor, int mode){}void EPSBase::MakeFooter(void){}*/void EPSBase::UpdateHeader(void){#if IBM_AVAILABLEchar	str[256], pbyte[4], tstart[4], tlength[4];if ((flags & EPSF_PC) && (flags & PREVIEW))	{		/* byte swap the useful info */	buffer->IOLength(&tiffSize);	tiffSize -= tiffStart;		pbyte[0] = (postscriptSize & 0x000000FF);	pbyte[1] = (postscriptSize & 0x0000FF00)>>8;	pbyte[2] = (postscriptSize & 0x00FF0000)>>16;	pbyte[3] = (postscriptSize & 0xFF000000)>>24;	tstart[0] = (tiffStart & 0x000000FF);	tstart[1] = (tiffStart & 0x0000FF00)>>8;	tstart[2] = (tiffStart & 0x00FF0000)>>16;	tstart[3] = (tiffStart & 0xFF000000)>>24;	tlength[0] = (tiffSize & 0x000000FF);	tlength[1] = (tiffSize & 0x0000FF00)>>8;	tlength[2] = (tiffSize & 0x00FF0000)>>16;	tlength[3] = (tiffSize & 0xFF000000)>>24;	/* ignore checksum for now	checkSum ^= (((pbyte[0] ^ pbyte[1]) ^ pbyte[2]) ^ pbyte[3]);	checkSum ^= (((tstart[0] ^ tstart[1]) ^ tstart[2]) ^ tstart[3]);	checkSum ^= (((tlength[0] ^ tlength[1]) ^ tlength[2]) ^ tlength[3]);*/		memcpy(str, pcEpsHeader, 8);	sprintf(&str[8], pc_fourbytes, pbyte[0], pbyte[1], pbyte[2], pbyte[3]);	/* postscriptSize */	memcpy(&str[12], pcEpsNulls, 8); /* metafile stuff (unused) */	sprintf(&str[20], pc_fourbytes, tstart[0], tstart[1], tstart[2], tstart[3]); /* tiff start */	sprintf(&str[24], pc_fourbytes, tlength[0],tlength[1], tlength[2], tlength[3]);  /* tiff length */	memcpy(&str[28], pcEpsFF, 2);	/* ignore checkSum for now */	buffer->IOPosition(str, 30, 0);		}#endif}void	EPSBase::SetPCFlags(void){flags |= EPSF_PC;lineTerm = LINE_TERM_PC;}void 	EPSBase::SetMacFlags(void){flags |= EPSF_MAC;lineTerm = LINE_TERM_MAC;}void 	EPSBase::SetPreviewFlag(int value){if (value == TRUE)	flags |= PREVIEW;else	flags &= ~PREVIEW;}void EPSF::MakeHeader(void){char str[255], version[255];polyFilter = TRUE;#if IBM_AVAILABLEif ((flags & EPSF_PC) && (flags & PREVIEW))	{	memcpy(str, pcEpsHeader, 8);	sprintf(&str[8], pc_fourbytes, '\0','\0','\0','\0');	/* postscriptSize */	memcpy(&str[12], pcEpsNulls, 8); /* metafile stuff (unused) */	memcpy(&str[20], pcEpsNulls, 8); /* clear the tiff stuff */	memcpy(&str[28], pcEpsFF, 2);	/* ignore checkSum for now */	buffer->IOData(str,30);/* ignore checksum for now	checkSum = (char) (((0xC5 ^ 0xD0) ^ 0xD3) ^ 0xC6);	checkSum ^= (char) 0x1E;*/	}#endifsprintf(str, Adobe3_0_intro, lineTerm);buffer->IOData(str,strlen(str));GetVersion(version);sprintf(str,title,TXT_APPNAME, version, lineTerm);buffer->IOData(str,strlen(str));sprintf(str,boundingBox,rect.left,rect.top,rect.right,rect.bottom, lineTerm);buffer->IOData(str,strlen(str));sprintf(str, endComments, lineTerm);buffer->IOData(str,strlen(str));sprintf(str, gsave, lineTerm);buffer->IOData(str,strlen(str));sprintf(str, setlinewidth, lineTerm);buffer->IOData(str,strlen(str));sprintf(str, setmiterlimit, lineTerm);buffer->IOData(str,strlen(str));sprintf(str, setdef, lineTerm);buffer->IOData(str,strlen(str));sprintf(str,epsMoveto,rect.left,rect.top);buffer->IOData(str,strlen(str));sprintf(str,epsLineto,rect.right,rect.top);buffer->IOData(str,strlen(str));sprintf(str,epsLineto,rect.right,rect.bottom);buffer->IOData(str,strlen(str));sprintf(str,epsLineto,rect.left,rect.bottom);buffer->IOData(str,strlen(str));sprintf(str, closedef, lineTerm);buffer->IOData(str,strlen(str));sprintf(str, polyclip, lineTerm);buffer->IOData(str,strlen(str));}void EPSF::MakeFooter(void){char	str[255];filter=0;polyFilter=FALSE;sprintf(str, grestore, lineTerm);buffer->IOData(str,strlen(str));sprintf(str, eof, lineTerm);buffer->IOData(str,strlen(str));tiffStart = buffer->IOGetPosition();postscriptSize = tiffStart -30;}void EPSF::SavePoly(V_Array *points,RGBColor *color,RGBColor *lineColor, int mode){int frame;Point p;char str[255];double gray;int i;/* to map the image from a mac window to an EPS file, you have to invert the   image (mac window has +Y axis going down; EPS has it going up, like in the   cartesian coordintate system).  But the rectangle is in the cartesian    coordinate system, so EPS.y = rect.bottom - MAC.y  *//*this creates the polygon definition*/sprintf(str,setdef, lineTerm);buffer->IOData(str,strlen(str));points->Get(0,&p);sprintf(str,epsMoveto,p.h,rect.bottom - p.v);buffer->IOData(str,strlen(str));for(i=1;i<points->ALength();i++)	{	points->Get(i,&p);	sprintf(str,epsLineto,p.h,rect.bottom - p.v);	buffer->IOData(str,strlen(str));	}sprintf(str, closedef, lineTerm);buffer->IOData(str,strlen(str));/*this fills and frames the polygon*/if(mode&CLIP_FILL)	{	if(bitDepth)		sprintf(str,polyfillcolor,(double)color->red/65535.0,(double)color->green/65535.0,(double)color->blue/(double)65535.0, lineTerm);	else		{		/* use NTSC color encoding */		gray=0.3*((double)color->red+0.11*(double)color->blue+0.59*(double)color->green)/(double)(65535.0);		sprintf(str,polyfillgray,gray, lineTerm);		}	buffer->IOData(str,strlen(str));	}	if(mode&CLIP_FRAME)	{	if(bitDepth)		sprintf(str,polylinecolor,(double)lineColor->red/65535.0,(double)lineColor->green/65535.0,(double)lineColor->blue/65535.0, lineTerm);	else		{		gray=0.3*((double)lineColor->red+0.11*(double)lineColor->blue+0.59*(double)lineColor->green)/(double)(65535.0);		sprintf(str,polylinegray,gray, lineTerm);		}	buffer->IOData(str,strlen(str));	}		}/* these are the Adobe Illustrator 1.1 EPSF file-making routines.     Adobe 3.0, the current one (as of July 92) is substantially the same */void EPSF_Adobe1_1::MakeHeader(void){char str[255], version[255];polyFilter = TRUE;#if IBM_AVAILABLEif ((flags & EPSF_PC) && (flags & PREVIEW))	{	/* pc binary header */	memcpy(str, pcEpsHeader, 8);	sprintf(&str[8], pc_fourbytes, '\0','\0','\0','\0');	/* postscriptSize */	memcpy(&str[12], pcEpsNulls, 8); /* metafile stuff (unused) */	memcpy(&str[18], pcEpsNulls, 8); /* make the tiff header clear */	memcpy(&str[28], pcEpsFF, 2);	/* ignore checkSum for now */	buffer->IOData(str,30);/* ignore checksum for now	checkSum = (char) (((0xC5 ^ 0xD0) ^ 0xD3) ^ 0xC6);	checkSum ^= (char) 30;*/	}#endifsprintf(str, Adobe1_1_intro, lineTerm);buffer->IOData(str,strlen(str));GetVersion(version);sprintf(str,title,TXT_APPNAME, version, lineTerm);buffer->IOData(str,strlen(str));sprintf(str,boundingBox,rect.left,rect.top,rect.right,rect.bottom, lineTerm);buffer->IOData(str,strlen(str));sprintf(str, endComments, lineTerm);buffer->IOData(str,strlen(str));sprintf(str, endProlog, lineTerm);buffer->IOData(str,strlen(str));sprintf(str, beginSetup, lineTerm);buffer->IOData(str,strlen(str));sprintf(str, endSetup, lineTerm);buffer->IOData(str,strlen(str));sprintf(str, Adobe_setlinewidth, lineTerm);buffer->IOData(str,strlen(str));sprintf(str, Adobe_setmiterlimit, lineTerm);buffer->IOData(str,strlen(str));}void EPSF_Adobe1_1::MakeFooter(void){char str[255];filter=0;polyFilter=FALSE;sprintf(str, trailer, lineTerm);buffer->IOData(str,strlen(str));sprintf(str, eof, lineTerm);buffer->IOData(str,strlen(str));tiffStart = buffer->IOGetPosition();postscriptSize = tiffStart - 30;}void EPSF_Adobe1_1::SavePoly(V_Array *points,RGBColor *color,RGBColor *lineColor, int mode){int frame;Point p, start_p;char str[255];double gray;double cyan, magenta, yellow, black;int i;int	grouping;/*    Adobe Illustrator uses a very, very limited subset of eps.     To be Adobe-compliant, we must do all color information in    CMYK colorspace, and draw only simple lines.  No procedure calls,   no path-manipulation.      The format is:         c m y k strokecolor      start_point m next_point L next_point L ... stroke      c m y k fillcolor      start_point m next_point L next_point L ... fill      or             group      c m y k strokecolor      c m y k fillcolor      start_point m next_point L next_point L ... stroke_n_fill   	  ungroup            color information preceeds path information.  Stroke and fill destroy   the path information, so the path must be recreated between strokes and   fills.  If the path is to be used for a stroke and a fill, you can use   the group operators to set up a single drawing operation.        this is exceptionally simplistic and makes for exceptionally large   files, but it will work.       To map the image from a mac window to an EPS file, you have to invert the   image (mac window has +Y axis going down; EPS has it going up, like in the   cartesian coordintate system).  But the rectangle is in the cartesian    coordinate system, so EPS.y = rect.bottom - MAC.y  */if ((mode & CLIP_FRAME) && (mode & CLIP_FILL))	{	sprintf(str, aiCharLineterm, GROUP, lineTerm);	/* init grouping */	buffer->IOData(str, strlen(str)); 	grouping = TRUE;	}else	{	grouping = FALSE;	}		/* convert rgb->cmyk and print color info */if(mode&CLIP_FRAME)	{	cyan = 1 - (double)lineColor->red/65535.0;	magenta = 1 - (double) lineColor->green/65535.0;	yellow = 1 - (double) lineColor->blue/65535.0;		/* black = min(cyan, magenta, yellow); */	black = (cyan < magenta) ? cyan : magenta;	black = (yellow < black) ? yellow : black;		cyan -= black;	magenta -= black;	yellow -= black;	if(bitDepth)		sprintf(str,strokecmykcolor,(double) cyan,(double) magenta,(double) yellow,(double) black,lineTerm);		else		{		/*do the NTSC color->intensity mapping (.3r + .59g + .11b) */		gray=(0.3*(double)lineColor->red+0.11*(double)lineColor->blue+0.59*(double)lineColor->green)/(double)(65535.0);		sprintf(str,strokegray,gray, lineTerm);		}	buffer->IOData(str,strlen(str));		if (!grouping)	/* if this is part of a group, draw later. */		{		/*this creates the polygon definition*/		points->Get(0,&start_p);		sprintf(str,aiMoveto,start_p.h, rect.bottom - start_p.v, lineTerm);		buffer->IOData(str,strlen(str));		for(i=1;i<points->ALength();i++)			{			points->Get(i,&p);			sprintf(str,aiLineto,p.h, rect.bottom - p.v, lineTerm);			buffer->IOData(str,strlen(str));			}			/* duplicate the start point, because adobe can be brain-dead about paths */		if ((p.h != start_p.h) || (p.v != start_p.v)) 			{			sprintf(str,aiLineto,start_p.h, rect.bottom - start_p.v, lineTerm);			buffer->IOData(str,strlen(str));				}			sprintf(str,aiCharLineterm, STROKE, lineTerm);		buffer->IOData(str,strlen(str));		}	}if(mode&CLIP_FILL)	{	cyan = 1 - (double)color->red/65535.0;	magenta = 1 - (double) color->green/65535.0;	yellow = 1 - (double) color->blue/65535.0;		/* black = min(cyan, magenta, yellow); */	black = (cyan < magenta) ? cyan : magenta;	black = (yellow < black) ? yellow : black;		cyan -= black;	magenta -= black;	yellow -= black;		if(bitDepth)		sprintf(str,fillcmykcolor,(double) cyan,(double) magenta,(double) yellow,(double) black, lineTerm);	else		{		/*do the NTSC color->intensity mapping (.3r + .59g + .11b) */		gray=(0.3*(double)color->red+0.11*(double)color->blue+0.59*(double)color->green)/(double)(65535.0);		sprintf(str,fillgray,gray, lineTerm);		}	buffer->IOData(str,strlen(str));		/*this creates the polygon definition*/	points->Get(0,&start_p);	sprintf(str,aiMoveto,start_p.h, rect.bottom - start_p.v, lineTerm);	buffer->IOData(str,strlen(str));	for(i=1;i<points->ALength();i++)		{		points->Get(i,&p);		sprintf(str,aiLineto,p.h,rect.bottom - p.v, lineTerm);		buffer->IOData(str,strlen(str));		}	/* duplicate the start point, because adobe can be brain-dead about paths */	if ((p.h != start_p.h) || (p.v != start_p.v))		{		sprintf(str,aiLineto,start_p.h, rect.bottom - start_p.v, lineTerm);		buffer->IOData(str,strlen(str));		}			if (!grouping)		{		sprintf(str,aiCharLineterm, FILL, lineTerm);		buffer->IOData(str,strlen(str));		}	else 		{		sprintf(str,aiCharLineterm, FILLANDSTROKE, lineTerm);		buffer->IOData(str,strlen(str));		}			}	if (grouping)		{		sprintf(str,aiCharLineterm, UNGROUP, lineTerm);		buffer->IOData(str,strlen(str));		}}// jca 17 Sept 93 }#endif // VWT