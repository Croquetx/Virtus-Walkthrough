/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				 *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VDisplay.h"#include "VError.h"#include "VGraphic.h"#include "VMemUtil.h"#if MACINTOSH#include <movies.h>#include <MoviesFormat.h>#include <QuickTimeComponents.h>#endif#include "QuickTim.h"/*------------------------------------------------------------------------------ * void QuickTime::cQuickTime(int q,long tp,long crt,strPtr qstr) *------------------------------------------------------------------------------*/void QuickTime::cQuickTime(int q,long tp,long crt,strPtr filt,strPtr qstr){cFile(q,tp,crt,filt,qstr);#if MACINTOSHqtMovie=0;compressionBuffer=0;idescH=0;#endif //MACINTOSH}/*------------------------------------------------------------------------------ * void QuickTime::dQuickTime(void) *------------------------------------------------------------------------------*/void QuickTime::dQuickTime(void){dFile();}/*------------------------------------------------------------------------------ * int QuickTime::OpenMovie(int createFlag) * Opens the QuickTime file for I/O. *------------------------------------------------------------------------------*/int QuickTime::OpenMovie(int createFlag){int err=0;#if MACINTOSHFSSpec movieFSSpec;short actualResID;ObjLock((ObjectHandle)this);pblk.ioNamePtr=(StringPtr)fname;/* Get the FSSpec record */err=FSMakeFSSpec(pblk.ioVRefNum,0,pblk.ioNamePtr,&movieFSSpec);if(direction==DATA_IN)/*load the file*/	{	if(err){ObjUnlock((ObjectHandle)this); qtMovie=0; return err;}	err=OpenMovieFile(&movieFSSpec,&resource, fsRdPerm);	if(err){ObjUnlock((ObjectHandle)this); return err;}	actualResID=DoTheRightThing;	err=NewMovieFromFile(&qtMovie,resource,&actualResID,(StringPtr)0,		newMovieActive,(Boolean *)0);	if(err){ ObjUnlock((ObjectHandle)this); qtMovie=0; return err;}	err=CloseMovieFile(resource);	if(err){ObjUnlock((ObjectHandle)this); qtMovie=0; return err;}	}else if(direction==DATA_OUT)/*save the file*/	{	if(err==fileNotFoundErr)err=0; /*Filter out file not found*/	if(err){ObjUnlock((ObjectHandle)this); qtMovie=0; return err;}	err=CreateMovieFile(&movieFSSpec,create,0,createFlag?createMovieFileDeleteCurFile:0,		&resource,&qtMovie);	if(err){ ObjUnlock((ObjectHandle)this); qtMovie=0; return err;}	}else err= -1;ObjUnlock((ObjectHandle)this);#elif WINDOWSerr = -1;#endifreturn(err);/*no problems*/}/*------------------------------------------------------------------------------ * int QuickTime::CloseMovie(void) * Close the QuickTime file for I/O. *------------------------------------------------------------------------------*/int QuickTime::CloseMovie(void){#if MACINTOSHif(direction==DATA_OUT)/*we were saving a movie*/	{	CloseMovieFile(resource);	}if(qtMovie)DisposeMovie(qtMovie);#endif //MACINTIOSH   return(0);}/*------------------------------------------------------------------------------ * int QuickTime::BeginMovie(V_Offscreen *data) *------------------------------------------------------------------------------*/int QuickTime::BeginMovie(Rect *rsize,int depth,int sp){OSErr err = 0;#if MACINTOSHTimeValue duration;long maxCompressedSize;CodecQ theQuality = 0x300;							/* Quality is 0x100 to 0x300 */CodecQ mQuality = 0x300;Rect r;ObjLock((ObjectHandle)this);if(direction==DATA_IN)	{	/*free up some unused space*/	if(offscreen)offscreen->dOffscreen();	offscreen=0;	}theOffscreen=new(V_Offscreen);err=theOffscreen->cOffscreen(rsize,depth,NULL,NULL);if(err)	{	theOffscreen->dOffscreen();	return err;	}r=rect=*rsize;kVideoWidth=r.right-r.left;kVideoWidth<<=16;kVideoHeight=r.bottom-r.top;kVideoHeight<<=16;speed=sp;if(direction==DATA_IN)	{	GetMovieBox(qtMovie,&rect);	VOffsetRect(&rect,-rect.left,-rect.top);	SetMovieBox(qtMovie,&rect);	*rsize=rect;	SetMovieGWorld(qtMovie,theOffscreen->metaPort, 0);	if(err=GetMoviesError())return err;	StartMovie(qtMovie);	}else if(direction==DATA_OUT)	{	qtTrack = NewMovieTrack(qtMovie, kVideoWidth,kVideoHeight, 0);	if(err=GetMoviesError()){ObjUnlock((ObjectHandle)this); return err;}		qtMedia=NewTrackMedia(qtTrack,VIDEO_TYPE,speed,0,0);	if(err=GetMoviesError()){ObjUnlock((ObjectHandle)this); return err;}	err=BeginMediaEdits(qtMedia);	if(err=GetMoviesError()){ObjUnlock((ObjectHandle)this); return err;}		theOffscreen->SetMetaPort();	err=GetMaxCompressionSize(theOffscreen->metaPort->portPixMap,&r,theOffscreen->GetDepth(),		codecNormalQuality, 'rle ', anyCodec, &maxCompressedSize);	GrowMemory(FALSE);	compressionBuffer=NewHandle(maxCompressedSize);	GrowMemory(TRUE);	if(!compressionBuffer){ObjUnlock((ObjectHandle)this); return err;}	MoveHHi((Handle)compressionBuffer);		idescH=(ImageDescriptionHandle)NewHandle(4);	if(!idescH){ObjUnlock((ObjectHandle)this); return err;}/*pascal OSErr CompressSequenceBegin(ImageSequence *seqID,PixMapHandle src,PixMapHandle prev,Rect *srcRect,Rect *prevRect,short colorDepth,CodecType cType,CompressorComponent codec,CodecQ spatialQuality,CodecQ temporalQuality,long keyFrameRate,CTabHandle clut,CodecFlags flags,ImageDescriptionHandle desc)*/	err = CompressSequenceBegin( &seqID,				theOffscreen->metaPort->portPixMap, 				nil,				&r, nil,				theOffscreen->GetDepth(),				'rle ',				anyCodec,				theQuality, 				mQuality,				sp,				nil /* no clut */, 				codecFlagUpdatePrevious, 				idescH);	theOffscreen->UnsetMetaPort();	}else err=-1;ObjUnlock((ObjectHandle)this);#elif WINDOWSerr = -1;#endifreturn err;}/*------------------------------------------------------------------------------ * int QuickTime::EndMovie(void) *------------------------------------------------------------------------------*/#define kSmallestArray 1#define kFix1 0x00010000#if __powerc#define kFix1 0x00010000#endif //__powerc#define gestaltComponentMgr 'cpnt'#define DoTheRightThing 0Lint QuickTime::EndMovie(int lastErr){OSErr err=0;#if MACINTOSHRect r;FSSpec movieFSSpec;short resID;ObjLock((ObjectHandle)this);if(offscreen==theOffscreen)offscreen=0;if(theOffscreen)	theOffscreen->dOffscreen();if(direction==DATA_OUT)	{	err = CDSequenceEnd(seqID);/* Tell the codec we're done with the sequence */	if(compressionBuffer)DisposHandle((Handle)compressionBuffer); compressionBuffer=0;	if(idescH)DisposHandle((Handle)idescH);	idescH=0;	EndMediaEdits(qtMedia);	err=InsertMediaIntoTrack(qtTrack,0L,0L,GetMediaDuration(qtMedia),kFix1);	resID = 1;	if(!err)err=AddMovieResource(qtMovie,resource,&resID,(StringPtr)filname);	if(err==dirFulErr || err==dskFulErr || err==ioErr)lastErr=err;	UpdateResFile(resource);		if(lastErr!=dirFulErr && lastErr!=dskFulErr && lastErr!=ioErr)		MakeFilePreview(resource, 0L);	}else if(direction==DATA_IN)	{	/*not much happening here*/	}else err=-1;ObjUnlock((ObjectHandle)this);#elif WINDOWSerr = -1;#endifreturn err;}/*------------------------------------------------------------------------------ * V_Offscreen *QuickTime::GetOffscreen(void) * Returns V_Offscreen object currently in use. *------------------------------------------------------------------------------*/V_Offscreen *QuickTime::GetOffscreen(void){return theOffscreen;}/*------------------------------------------------------------------------------ * int QuickTime::IORect(Rect *r) * Reads/writes the rectangular size of the movie. *------------------------------------------------------------------------------*/int QuickTime::IORect(Rect *r){#if MACINTOSHif(direction==DATA_IN)/*this is really the important thing*/	{	if(qtMovie)		{		GetMovieBox(qtMovie,r);		VOffsetRect(r,-r->left,-r->top);		rect=*r;		}	else *r=rect;	}else if(direction==DATA_OUT)/*this is really set by the size of the V_Offscreen*/	{	rect=*r;	}else return -1;#endif //MACINTOSHreturn 0;/*no errors*/}/*------------------------------------------------------------------------------ * int QuickTime::IOFrame(void) * Reads/writes next frame of the movie. *------------------------------------------------------------------------------*/int QuickTime::IOFrame(void){VGrafPort savePort;			// MERGE25VGrafDevice saveDevice;		// MERGE25OSErr err=0;#if MACINTOSHTimeValue mediaDuration;long compressedFrameSize;	/* Size of current compressed frame */unsigned char	similarity;	/* Measure of how similar the frame is to the previous one */ObjLock((ObjectHandle)this);VGetPort(&savePort,&saveDevice);		// MERGE25theOffscreen->SetMetaPort();if(direction==DATA_IN)	{	if(IsMovieDone(qtMovie))/*set back to the beginning*/		GoToBeginningOfMovie(qtMovie);	MoviesTask(qtMovie,DoTheRightThing);	}else if(direction==DATA_OUT)	{	HLock((Handle)compressionBuffer);	err = CompressSequenceFrame(seqID,			theOffscreen->metaPort->portPixMap,			&rect,			codecFlagUpdatePrevious,			StripAddress(*compressionBuffer),			&compressedFrameSize,			&similarity,			nil);	HUnlock((Handle)compressionBuffer);	if(!err)		{		err=AddMediaSample(qtMedia,(Handle)StripAddress(compressionBuffer),0L,compressedFrameSize,		1,(SampleDescriptionHandle)StripAddress(idescH),1L,similarity?mediaSampleNotSync:0,		&mediaDuration);		}	}else err= -1;theOffscreen->UnsetMetaPort();VSetPort(savePort,saveDevice);		// MERGE25ObjUnlock((ObjectHandle)this);#elif WINDOWSerr = -1;#endifreturn err;}