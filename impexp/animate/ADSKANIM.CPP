/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	John C. Alspaugh * * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  * Platform: 	 *				WINDOWS		 *------------------------------------------------------------------------------ */#include <stdio.h>#include <math.h>#include "VTypes.h"#include "VIO.h"#include "VPane.h"#include "VGraphic.h"#include "VArray.h"#include "VDialog.h"#include "VGUtil.h"#include "VMemutil.h"#include "Clip.h"#include "AppDeflt.h"#include "AppText.h"#include "View.h"#include "observer.h"#include "AdskAnim.h"#if WINDOWS#include "pjfli.h"#endif/*---------------------------------------------------- Useful Things to Know: -- There are two kinds of animator files: fli and flc. fli is a 320x200 pixel image; flc is everything else. -- There is a max of 4000 frames. -- The animation is stored as a first frame and a series of incremental changes.  The last frame in the animation is called a ring frame, and is the changes required to transform the final frame of the animation into the first frame. -- The first frame of a flc may be accompanied by a reduced size image called a postage stamp. Procedure call sequence:	cWalkMovie()	BeginMovie()	AnimateMovie()	EndMovie()	dWalkMovie() You should test the return values of the movie routines to make sure there has not been an error.  You must call dAdeskAnimator() whether there has been an error or not. AnimateMovie does this:	WriteFirstMovieFrame()	while frames:		WriteMovieFrame()	WriteMovieFrame()		// ring frame----------------------------------------------------*/intAnimatorMovie::cWalkMovie(TranslatorPreference *transPref, V_Buffer *buffer){#if WINDOWS	/* use the prefs to set things up */	framesPerSecond = transPref->frameRate;	grayScale = !(transPref->EPSColorFlag);	if (framesPerSecond <= 0)		{		AlertMessage(WrongFrameRate);		err = -1;        return(err);        }	movieBuffer = buffer;	fileStart = buffer->IOGetPosition();	screen0 = screen1 = NULL;	currFrame = prevFrame = NULL;	currStrip = prevStrip = NULL;	currHeader = prevHeader = NULL;	stripsPerSegment = 0;	flcHeader = NULL;	err = 0;#elif MACINTOSH	err = -1;		// to stop anything from happening#endif	return(err);}voidAnimatorMovie::dWalkMovie(){#if WINDOWS	if (flcHeader)		delete(flcHeader);	EmergencyCleanUp(0);#endif	delete(this);}intAnimatorMovie::BeginMovie(Rect *rect, long bitDepth, long frames){#if WINDOWS	long				length;    BITMAPINFOHEADER	*cFrame, *pFrame;#endif	int offDepth;	if (err) return(err);	r = *rect;	depth = bitDepth;#if WINDOWS      // jca 23AUG94 VR1.0.1 bug in newText8 chooses wrong texture fill unless offdepth = -1	offDepth = -1;#else	offDepth = bitDepth;#endif // WINDOWS	if (frames > ANIMATOR_MAX_FRAMES)		{		AlertMessage(TXTW_TOO_MANY_FRAMES);		err = -1;        return(err);		}	nFrames = frames;	/* if the bounds are 320x200, then make an fli file.	otherwise, make an flc file */	if (((r.right - r.left) == 320) && ((r.bottom - r.top) == 200))		flc = FALSE;	else		flc = TRUE;#if WINDOWS	screen0 = new(V_Offscreen);	screen1 = new(V_Offscreen);	if (screen0->cOffscreen(rect, offDepth, NULL,NULL) ||		screen1->cOffscreen(rect, offDepth, NULL,NULL))		{   	 	AlertMessage(TXTW_MEMORY);		EmergencyCleanUp(-1);		return (err);		}	/* do the dib headers */	length = sizeof(BITMAPINFOHEADER) + 256*sizeof(RGBQUAD);	currHeader = NewHandle(length);	prevHeader = NewHandle(length);    if ((!currHeader) || (!prevHeader))		{		AlertMessage(TXTW_MEMORY);		EmergencyCleanUp(-1);		return(err);		}	HLock(currHeader);	HLock(prevHeader);	cFrame = (LPBITMAPINFOHEADER) HDeref(currHeader);	pFrame = (LPBITMAPINFOHEADER) HDeref(prevHeader);	cFrame->biSize = pFrame->biSize = sizeof(BITMAPINFOHEADER);	cFrame->biWidth = pFrame->biWidth = screen0->wBmWidth;	cFrame->biHeight = pFrame->biHeight = screen0->wBmHeight;	cFrame->biPlanes = pFrame->biPlanes = 1;	cFrame->biBitCount = pFrame->biBitCount = 8;   /* must have 256 color palette */	cFrame->biCompression = pFrame->biCompression = BI_RGB;   /* no compression */	HUnlock(currHeader);	HUnlock(prevHeader);	/* do the strips */	stripsPerSegment = (long)floor(SEGMENT_SIZE/screen0->wBmWidth);	currStrip = NewHandle(stripsPerSegment*screen0->wBmWidth);	prevStrip = NewHandle(stripsPerSegment*screen0->wBmWidth);    if ((!currStrip) || (!prevStrip))		{		// failed to get it.  Fall back to smaller size		if (currStrip)	DisposHandle(currStrip);		if (prevStrip)	DisposHandle(prevStrip);		stripsPerSegment = 1;		currStrip = NewHandle(screen0->wBmWidth);		prevStrip = NewHandle(screen0->wBmWidth);		if (!currStrip || !prevStrip)        	{			AlertMessage(TXTW_MEMORY);			EmergencyCleanUp(-1);			return(err);        	}		}	/* all ok; start writing */	CreateHeader();	currFrame = screen0;    prevFrame = screen1;#endif	return(err);}intAnimatorMovie::AnimateMovie(V_Pane *window, Observer *eye){	ULong 	offset1, offset2, i;	char			str[256];	V_Offscreen		*tempPtr;	Handle			tempH;	if (err) return(err);#if WINDOWS	MeterSetTotal(nFrames+1);	/* get the first frame's offset */	offset1 = offset2 = movieBuffer->IOGetPosition();    /* meter */	sprintf(str,NFramesRemaining,nFrames);	MeterSetCountTitle(str);	/* write the first frame.  Pass the window in in case we need to	render a postage stamp of the image */	eye->SetFrame(0);	window->VOutput(currFrame);	WriteFirstMovieFrame(window, currFrame);	tempPtr = prevFrame;    /* swap the screens */    prevFrame = currFrame;	currFrame = tempPtr;	tempH = prevHeader;	prevHeader = currHeader;    currHeader = tempH;	MeterSetCount(1);      /* handle the meter */	MeterUpdate(0);	/* set the 2nd frame offset */	offset2 = movieBuffer->IOGetPosition();	/* do the rest of the animation */	for (i = 1; !err && i < nFrames; i++)		{		sprintf(str,NFramesRemaining,nFrames-i);		MeterSetCountTitle(str);		/* standard stuff.  Get the position/look info, render the frame,    	write the frame */		eye->SetFrame(i);		err = err ? err : window->VOutput(currFrame);		err = err ? err : WriteMovieFrame(currFrame);		tempPtr = prevFrame;    /* swap the screens */    	prevFrame = currFrame;		currFrame = tempPtr;		tempH = prevHeader;		prevHeader = currHeader;		currHeader = tempH;		MeterSetCount(i+1);      /* handle the meter */		err = err ? err : MeterUpdate(0);		}	sprintf(str,NFramesRemaining,0L);	MeterSetCountTitle(str);	if (!err)    	{		/* do the ring frame:  render the first frame again, then		difference it with the last frame */		eye->SetFrame(0);		window->VOutput(currFrame);		WriteMovieFrame(currFrame);    	}	MeterSetCount(i+1);      /* handle the meter */	MeterUpdate(0);	if (flc)   // do flc-specific things		{        flcHeader->flags = AA_OK;   // set the "file properly finished and closed" flag		/* store the correct 1st and 2nd frame file offsets */		flcHeader->frame1_oset = offset1;		flcHeader->frame2_oset = offset2;		}#endif	return(err);}intAnimatorMovie::WriteMovieFrame(V_Offscreen *newFrame){#if WINDOWS	long 			i;	ULong 	chunkBegin, chunkEnd, chunkHeaderPos;	Fli_frame		frameChunk;	Chunk_id		chunkHeader;	int				update;	short			lineCount, lineSkip, blanks;	long			diffPos, currPos;	LPBITMAPINFO	bmpi, oldBmpi;    char FAR		*bmap, *oldBmap;	HDC				HDCCurr, HDCPrev;	long 			rowSize, stripCount, linesReturned;	Rect			dcRect;    HBITMAP			currBits, prevBits;#endif	if (err)	return(err);#if WINDOWS	chunkBegin = movieBuffer->IOGetPosition();	/* init the frame chunk, and write it as a placeholder */	frameChunk.size = 0L;	frameChunk.type = FCID_FRAME;	frameChunk.chunks = 0;	memset(&frameChunk.pad[0], 0, 8);	movieBuffer->IOType(&frameChunk.size, IO_LONG_I);	movieBuffer->IOType(&frameChunk.type, IO_SHORT_I);    movieBuffer->IOType(&frameChunk.chunks, IO_SHORT_I);	movieBuffer->IOData(&frameChunk.pad, 8);	chunkCount = 0;    VSetCursor(vCursorEarth);#if WINDOWS	rowSize = screen0->wBmWidth; // this is what it would be, except that we align to 4-byte boundaries  ((r.right - r.left) + 0x3) & ~0x3;	HLock(currHeader);	HLock(prevHeader);	bmpi = (LPBITMAPINFO) HDeref(currHeader);	oldBmpi = (LPBITMAPINFO) HDeref(prevHeader);	HDCCurr = currFrame->GetMetaPort(&dcRect);	currFrame->SetMetaPort();	// some device drivers (eg, Matrox) don't implement GetDIBits correctly	// and will not correctly process the call unless a buffer is provided.	// So we provide a scatch buffer.   jca 25AUG94	HLock(currStrip);	bmap = (char *)HDeref(currStrip);	// We're not supposed to have the bitmap selected	//when we do SetDIBits calls, so let's unselect it.	currBits = SelectObject(HDCCurr, currFrame->oldBitmap);	ASSERT(currBits == currFrame->bitmap);	/* Get the bitmap header, the palette */	linesReturned = GetDIBits(HDCCurr, currBits, 0, stripsPerSegment, bmap,		(LPBITMAPINFO) bmpi, DIB_RGB_COLORS);#if DEBUG	if (linesReturned != stripsPerSegment)    	DEBUGGER();#endif //DEBUG	if (linesReturned <= 0)		{    // this should never happen.  We have the memory allocated.		AlertMessage(AA_GETDIBITS_ERROR);		HUnlock(currHeader);		HUnlock(prevHeader);		currFrame->UnsetMetaPort();		currFrame->ReleaseMetaPort(HDCCurr);		EmergencyCleanUp(-1);        err = -1; 		return(err);		}	SelectObject(HDCCurr, currBits);	currFrame->UnsetMetaPort();	currFrame->ReleaseMetaPort(HDCCurr);	HUnlock(currStrip);  // incorrect Matrox device drivers  jca 25AUG94#endif	/* write the color map changes, if any */	WriteChangedPalette(bmpi, oldBmpi);	/* get the data from the two frames */#if WINDOWS	chunkHeaderPos = movieBuffer->IOGetPosition();	update = FALSE;	if (flc)		{		chunkHeader.size = 0;		chunkHeader.type = FLI_SS2;		}	else		{		chunkHeader.size = 0;		chunkHeader.type = FLI_LC;		}	movieBuffer->IOType(&chunkHeader.size, IO_LONG_I);	movieBuffer->IOType(&chunkHeader.type, IO_SHORT_I);	HLock(currStrip);	HLock(prevStrip);	bmap = (char *) HDeref(currStrip);	oldBmap = (char *) HDeref(prevStrip);    /* do positioning and set the start of the strip */	lineCount = lineSkip = blanks = 0;	diffPos = movieBuffer->IOGetPosition();	if (!flc)		{		movieBuffer->IOType(&lineSkip, IO_SHORT_I);		}	movieBuffer->IOType(&lineCount, IO_SHORT_I);	stripCount = stripsPerSegment;	VSetCursor(vCursorEarth);	for (i = (currFrame->wBmHeight) - 1; (!err) && i >= 0; i--)		{        unsigned int	howManyLines;		if (stripCount == stripsPerSegment)			{  // time to make the doughnuts!            // how many lines to get			howManyLines = min(stripsPerSegment, i+1);			HDCCurr = currFrame->GetMetaPort(&dcRect);			currFrame->SetMetaPort();			// We're not supposed to have the bitmap selected			//when we do SetDIBits calls, so let's unselect it.			// stupidly, we can't select curr and prev out simultaneously.            // Select out curr, then prev.			currBits = SelectObject(HDCCurr, currFrame->oldBitmap);			ASSERT(currBits == currFrame->bitmap);			linesReturned = GetDIBits(HDCCurr, currBits, max((i+1)-stripsPerSegment, 0),				howManyLines, bmap,(LPBITMAPINFO) bmpi, DIB_RGB_COLORS);#if DEBUG			if (linesReturned != howManyLines)    			DEBUGGER();#endif //DEBUG			if (linesReturned <= 0)				{    // this should never happen.  We have the memory allocated.				AlertMessage(AA_GETDIBITS_ERROR);				HUnlock(currStrip);				HUnlock(prevStrip);				HUnlock(currHeader);				HUnlock(prevHeader);				currFrame->UnsetMetaPort();				currFrame->ReleaseMetaPort(HDCCurr);				err = -1;				EmergencyCleanUp(-1);				return(err);				}			SelectObject(HDCCurr, currBits);			currFrame->UnsetMetaPort();			currFrame->ReleaseMetaPort(HDCCurr);			HDCPrev = prevFrame->GetMetaPort(&dcRect);			prevFrame->SetMetaPort();			// We're not supposed to have the bitmap selected			//when we do SetDIBits calls, so let's unselect it.			prevBits = SelectObject(HDCPrev, prevFrame->oldBitmap);			ASSERT(prevBits == prevFrame->bitmap);			linesReturned = GetDIBits(HDCPrev, prevBits, max((i+1)-stripsPerSegment, 0),				howManyLines, oldBmap,(LPBITMAPINFO) oldBmpi, DIB_RGB_COLORS);#if DEBUG			if (linesReturned != howManyLines)    			DEBUGGER();#endif //DEBUG			if (linesReturned <= 0)				{    // this should never happen.  We have the memory allocated.				AlertMessage(TXTW_MEMORY);				HUnlock(currStrip);				HUnlock(prevStrip);				HUnlock(currHeader);				HUnlock(prevHeader);				prevFrame->UnsetMetaPort();				prevFrame->ReleaseMetaPort(HDCPrev);				err = -1;				EmergencyCleanUp(-1);				return(err);				}			SelectObject(HDCPrev, prevBits);			prevFrame->UnsetMetaPort();			prevFrame->ReleaseMetaPort(HDCPrev);            stripCount = 0;        	}		VSetCursor(vCursorEarth);		if (flc)			{			WordDiffFar(&lineCount, &lineSkip, r.right - r.left,				&bmap[(howManyLines-stripCount-1)*rowSize],				&oldBmap[(howManyLines-stripCount-1)*rowSize]);			}		else    		{			ByteDiffFar(&lineCount, &blanks, r.right - r.left,				&bmap[(howManyLines-stripCount-1)*rowSize],				&oldBmap[(howManyLines-stripCount-1)*rowSize]);			if (!lineCount)	lineSkip++;			}	   	stripCount++;		}	HUnlock(currStrip);	HUnlock(prevStrip);	HUnlock(currHeader);	HUnlock(prevHeader);#endif	/* update the line skip and line count (but only if we have	written something out!) */	if (lineCount)		{		chunkCount++;		currPos = movieBuffer->IOGetPosition();		if (flc)			{			movieBuffer->IOTypePosition(&lineCount, IO_SHORT_I, diffPos);			}        else            {			movieBuffer->IOTypePosition(&lineSkip, IO_SHORT_I, diffPos);		movieBuffer->IOTypePosition(&lineCount, IO_SHORT_I, diffPos + 2);			}		movieBuffer->IOSetPosition(currPos);		update = TRUE;        }	else		movieBuffer->IOSetPosition(chunkHeaderPos);	/* update the compressed frame chunk header info */	chunkEnd = movieBuffer->IOGetPosition();	if (update)		{		chunkHeader.size = chunkEnd - chunkHeaderPos;		/* chunks must be on word boundaries */		if ((chunkHeader.size % 2) == 1)			{            char filler = 0;			chunkHeader.size++;			chunkEnd++;            movieBuffer->IOData(&filler, 1);        	}		movieBuffer->IOTypePosition(&chunkHeader.size, IO_LONG_I, chunkHeaderPos);		}	frameChunk.size = chunkEnd - chunkBegin;	frameChunk.chunks = chunkCount;	movieBuffer->IOTypePosition(&(frameChunk.size), IO_LONG_I, chunkBegin);	movieBuffer->IOType(&(frameChunk.type), IO_SHORT_I);	movieBuffer->IOType(&(frameChunk.chunks), IO_SHORT_I);	movieBuffer->IOSetPosition(chunkEnd);#endif	return(err);}intAnimatorMovie::EndMovie(){	ULong endOfFile;	if (err)	return(err);#if WINDOWS	/* update the header */	endOfFile = movieBuffer->IOGetPosition();	flcHeader->size = (ULong)endOfFile - fileStart;	movieBuffer->IOSetPosition(fileStart);	WriteHeader();	movieBuffer->IOSetPosition(endOfFile);	EmergencyCleanUp(0);#endif	return(err);}intAnimatorMovie::WriteFirstMovieFrame(struct V_Pane *win, V_Offscreen *newFrame){#if WINDOWS	int				i;	ULong 	chunkBegin, chunkEnd, chunkHeaderPos;	Fli_frame		frameChunk;    Chunk_id		chunkHeader;	V_Offscreen		*postageStamp;	LPBITMAPINFO	bmpi;    char 			*bmap;	HDC				HDCCurr, HDCPrev;	Rect			dcRect;	long			rowSize, stripCount, linesReturned;	ULong	stripBegin, stripEnd;    HBITMAP			tempBits;#endif	if (err)	return(err);#if WINDOWS	/* push the starting location of the file */    chunkBegin = movieBuffer->IOGetPosition();	/* init the frame chunk, and write it as a placeholder */	frameChunk.size = 0L;	frameChunk.type = FCID_FRAME;	frameChunk.chunks = 0;	memset(&frameChunk.pad[0], 0, 8);	movieBuffer->IOType(&frameChunk.size, IO_LONG_I);	movieBuffer->IOType(&frameChunk.type, IO_SHORT_I);    movieBuffer->IOType(&frameChunk.chunks, IO_SHORT_I);	movieBuffer->IOData(&frameChunk.pad, 8);	chunkCount = 1;	VSetCursor(vCursorEarth);#if 0	/* write the postage stamp, if appropriate */	if (flc)		{		Rect psRect;        int	 cmapOnly = FALSE;		psRect.top = psRect.left = 0;		/* write the postage stamp image only if the regular image        is bigger than the postage stamp size */		if (((r.right - r.left) > 100) || ((r.bottom - r.top) > 63))			{			int	diff;			/* caluclate the size the postage stamp should be to            keep the same perspective */			diff = (r.right - r.left) - (r.bottom - r.top);			if (diff < 0)				{				psRect.bottom = 63;            	psRect.right = (int) (((r.right - r.left) * 63)/(r.bottom - r.top) + 1);				}			else if (diff > 0)				{				psRect.right = 100;            	psRect.bottom = (int) (((r.bottom - r.top) * 100)/(r.right - r.left) + 1);				}			else				psRect.bottom = psRect.right = 63;			}		else			{			psRect.right = r.right - r.left;			psRect.bottom = r.bottom - r.top;            cmapOnly = TRUE;			}		postageStamp = new(V_Offscreen);		postageStamp->cOffscreen(&psRect, 8, NULL);        win->VOutput(postageStamp);		WritePostageStamp(postageStamp, cmapOnly);		postageStamp->dOffscreen();		}#endif#if WINDOWS	rowSize = currFrame->wBmWidth; //((r.right - r.left) + 0x3) & ~0x3;	HLock(currHeader);	bmpi = (LPBITMAPINFO) HDeref(currHeader);	HDCCurr = currFrame->GetMetaPort(&dcRect);	currFrame->SetMetaPort();	// some device drivers (eg, Matrox) don't implement GetDIBits correctly	// and will not correctly process the call unless a buffer is provided.	// So we provide a scatch buffer.   jca 25AUG94	HLock(currStrip);	bmap = (char *)HDeref(currStrip);	// We're not supposed to have the bitmap selected	//when we do SetDIBits calls, so let's unselect it.	tempBits = SelectObject(HDCCurr, currFrame->oldBitmap);	ASSERT(tempBits == currFrame->bitmap);	/* Get the bitmap header, the palette */	linesReturned = GetDIBits(HDCCurr, tempBits, 0, stripsPerSegment,		bmap, (LPBITMAPINFO)bmpi, DIB_RGB_COLORS);#if DEBUG	if (linesReturned != stripsPerSegment)    	DEBUGGER();#endif //DEBUG	if (linesReturned <= 0)		{    // this should never happen.  We have the memory allocated.		AlertMessage(TXTW_MEMORY);		currFrame->UnsetMetaPort();		currFrame->ReleaseMetaPort(HDCCurr);        HUnlock(currHeader);		err = -1;		EmergencyCleanUp(-1);		return(err);		}    SelectObject(HDCCurr, tempBits);	currFrame->UnsetMetaPort();	currFrame->ReleaseMetaPort(HDCCurr);	HUnlock(currStrip);  // incorrect Matrox device drivers  jca 25AUG94#endif	/* color palette */	WriteCompletePalette(bmpi);	/* write the chunk header */	chunkHeader.size = 0;	chunkHeader.type = FLI_BRUN;    /* push the header starting point on the stack */    chunkHeaderPos = movieBuffer->IOGetPosition();	movieBuffer->IOType(&chunkHeader.size, IO_LONG_I);    movieBuffer->IOType(&chunkHeader.type, IO_SHORT_I); 	VSetCursor(vCursorEarth);#if WINDOWS	/* set up for the frame compression */	stripBegin = movieBuffer->IOGetPosition();    HLock(currStrip);	bmap = (char *)HDeref(currStrip);	stripCount = stripsPerSegment;  // handle the ugly Windows segments	tempBits = SelectObject(HDCCurr, currFrame->oldBitmap);	ASSERT(tempBits == currFrame->bitmap);	if (tempBits != currFrame->bitmap)		{		err = -1;        HUnlock(currStrip);		HUnlock(currHeader);		return(err);		}	/* frame */	for (i = (currFrame->wBmHeight) - 1; i >= 0; i--)		{		unsigned char	packetCount = 0;        unsigned int	howManyLines;		if (stripCount == stripsPerSegment)			{            // how many lines should we get?			howManyLines = min(stripsPerSegment, i+1);			HDCCurr = currFrame->GetMetaPort(&dcRect);			currFrame->SetMetaPort();			// We're not supposed to have the bitmap selected			//when we do SetDIBits calls, so let's unselect it.			linesReturned = GetDIBits(HDCCurr, tempBits, max((i+1)-stripsPerSegment, 0),				howManyLines, bmap,(LPBITMAPINFO) bmpi, DIB_RGB_COLORS);#if DEBUG			if (linesReturned != howManyLines)    			DEBUGGER();#endif //DEBUG			if (linesReturned <= 0)				{    // this should never happen.  We have the memory allocated.				AlertMessage(TXTW_MEMORY);				currFrame->ReleaseMetaPort(HDCCurr);				EmergencyCleanUp(-1);				return(err);				}			currFrame->UnsetMetaPort();			currFrame->ReleaseMetaPort(HDCCurr);			stripCount = 0;            }		/* write the packetCount placeholder */		movieBuffer->IOData(&packetCount, 1);		packetCount = (unsigned char) ByteCompressFar(BRUN, 0, (long)(r.right-r.left),			&bmap[(howManyLines-stripCount-1)*rowSize]);		VSetCursor(vCursorEarth);		stripCount++;        /* update the packetCount */		stripEnd = movieBuffer->IOGetPosition();		movieBuffer->IOPosition(&packetCount, 1, stripBegin);		movieBuffer->IOSetPosition(stripEnd);		stripBegin = stripEnd;		}	SelectObject(HDCCurr, tempBits);	HUnlock(currHeader);	HUnlock(currStrip);#endif	/* update the BRUN frame chunk header info */	chunkEnd = movieBuffer->IOGetPosition();	chunkHeader.size = chunkEnd - chunkHeaderPos;	if ((chunkHeader.size % 2) == 1)		{        char byte = 0;		chunkHeader.size++;        movieBuffer->IOData(&byte, 1);        chunkEnd++;        }    movieBuffer->IOTypePosition(&(chunkHeader.size), IO_LONG_I, chunkHeaderPos);	/* update the whole frame chunk info */	frameChunk.size = chunkEnd - chunkBegin;	frameChunk.chunks = chunkCount;	movieBuffer->IOTypePosition(&(frameChunk.size), IO_LONG_I, chunkBegin);	movieBuffer->IOType(&(frameChunk.type), IO_SHORT_I);	movieBuffer->IOType(&(frameChunk.chunks), IO_SHORT_I);	movieBuffer->IOSetPosition(chunkEnd);#endif	return(err);}voidAnimatorMovie::EmergencyCleanUp(int	errorCode){#if WINDOWS	if (screen0)	screen0->dOffscreen();	if (screen1)	screen1->dOffscreen();	if (currHeader)	DisposHandle(currHeader);	if (prevHeader)	DisposHandle(prevHeader);	if (currStrip)	DisposHandle(currStrip);	if (prevStrip)	DisposHandle(prevStrip);	screen0 = screen1 = NULL;	currHeader = prevHeader = NULL;	currStrip = prevStrip = NULL;    currFrame = prevFrame = NULL;	err = errorCode;#endif}PointAnimatorMovie::CalcAspectRatio(){	Point returnVal;	long	width, height;    int		i, max, min;	returnVal.h = returnVal.v = 1;		// default#if WINDOWS	width = r.right - r.left;	height = r.bottom - r.top;	if (width > height)		{	max = width; min = height;	}	else if (width < height)		{	min = width; max = height;	}	else /* width == height */		return(returnVal);	i = sqrt(max);	if (i > min)		i = min;	while (i > 1)		{		if (((width % i) == 0) && ((height % i) == 0))			{			width /= i;			height /= i;			if (i - 1 > min(width, height))				i = min(width, height);			else				i--;			}        else        	i--;		}	returnVal.h = width;	returnVal.v = height;#endif	return(returnVal);}intAnimatorMovie::CreateHeader(){	Point	aspectRatio;	if (err) 	return(err);#if WINDOWS	flcHeader = new(Fli_head);         			/* allocate */	memset(flcHeader, 0, sizeof(Fli_head));      /* initalize */	aspectRatio = CalcAspectRatio();	/* flc and fli headers are identical except for the	extra fields in the FLC header and the different time	interpretation */	if (flc)           					/* flc file */		{        flcHeader->size = 0;		flcHeader->type = FLIHR_MAGIC;		flcHeader->frame_count = (short) nFrames;		flcHeader->width = (short)r.right - r.left;		flcHeader->height = (short)r.bottom - r.top;		flcHeader->bits_a_pixel = (short)8;		flcHeader->speed = (short) MILLISECS/framesPerSecond;		flcHeader->id.create_time = 1; // creation in msdos format		flcHeader->id.create_user = AA_CREATOR; // "fliclib"		flcHeader->aspect_dx = aspectRatio.h;  //aspectx		flcHeader->aspect_dy = aspectRatio.v; 		}	else                                /* fli file */		{		flcHeader->size = 0;		flcHeader->type = FLIH_MAGIC;		flcHeader->frame_count = (short) nFrames;		flcHeader->width = 320;		flcHeader->height = 200;		flcHeader->bits_a_pixel = 8;		flcHeader->speed = JIFFIES/framesPerSecond;  		}	/* write out the header */	WriteHeader();#endif	return(err);}intAnimatorMovie::WriteHeader(){#if WINDOWS	movieBuffer->IOType(&(flcHeader->size), IO_LONG_I);	movieBuffer->IOType(&(flcHeader->type), IO_SHORT_I);	movieBuffer->IOType(&(flcHeader->frame_count), IO_SHORT_I);	movieBuffer->IOType(&(flcHeader->width), IO_SHORT_I);	movieBuffer->IOType(&(flcHeader->height), IO_SHORT_I);	movieBuffer->IOType(&(flcHeader->bits_a_pixel), IO_SHORT_I);	movieBuffer->IOType(&(flcHeader->flags), IO_SHORT_I);	movieBuffer->IOType(&(flcHeader->speed), IO_LONG_I);	movieBuffer->IOType(&(flcHeader->unused), IO_SHORT_I);	movieBuffer->IOType(&(flcHeader->id.create_time), IO_LONG_I);	movieBuffer->IOType(&(flcHeader->id.create_user), IO_LONG_I);	movieBuffer->IOType(&(flcHeader->id.update_time), IO_LONG_I);	movieBuffer->IOType(&(flcHeader->id.update_user), IO_LONG_I);	movieBuffer->IOType(&(flcHeader->aspect_dx), IO_SHORT_I);	movieBuffer->IOType(&(flcHeader->aspect_dy), IO_SHORT_I);	movieBuffer->IOData(&(flcHeader->commonpad[0]), 38);	movieBuffer->IOType(&(flcHeader->frame1_oset), IO_LONG_I);	movieBuffer->IOType(&(flcHeader->frame2_oset), IO_LONG_I);	movieBuffer->IOData(&(flcHeader->padfill[0]), 40);#endif	return(err);}#if WINDOWSintAnimatorMovie::WriteCompletePalette(BITMAPINFO *bmpi){	int i;	char byte, noPad = TRUE;	short	packets;    long	gray;	RGB8BitColor	rgb;	Chunk_id chunkHead;	chunkHead.size = sizeof(Chunk_id) + 256*3/*sizeof(RGB8BitColor)*/ + 4;	chunkHead.type = FLI_COLOR256;	if ((chunkHead.size % 2) == 1)    	{		chunkHead.size++;		noPad = FALSE;        }	movieBuffer->IOType(&(chunkHead.size), IO_LONG_I);	movieBuffer->IOType(&(chunkHead.type), IO_SHORT_I);	packets = 1;	movieBuffer->IOType(&packets, IO_SHORT_I); /* one packet */	byte = 0;	movieBuffer->IOType(&byte, IO_CHAR); /* no skips in cmap */	movieBuffer->IOType(&byte, IO_CHAR); /* n entries */	if (grayScale)		{		for (i = 0; i < 256; i++)			{			gray = (bmpi->bmiColors[i].rgbRed + bmpi->bmiColors[i].rgbGreen +				bmpi->bmiColors[i].rgbBlue)/3;			rgb.red = (int)gray;			rgb.green = (int)gray;			rgb.blue = (int)gray;			movieBuffer->IOData(&rgb, 3);			}		}	else    	{		for (i = 0; i < 256; i++)			{			rgb.red = bmpi->bmiColors[i].rgbRed;			rgb.green = bmpi->bmiColors[i].rgbGreen;			rgb.blue = bmpi->bmiColors[i].rgbBlue;    			movieBuffer->IOData(&rgb, 3);			}        }    chunkCount++;	/* always end chunk on a word boundary */	if (!noPad)    	movieBuffer->IOData(&noPad, 1);	return(err);}#endif#if WINDOWSintAnimatorMovie::WriteChangedPalette(BITMAPINFO *cbmpi, BITMAPINFO *pbmpi){	char			byte;	short			i, pixelSkipCount, changeCount, packetCount; 	ULong	chunkPos, countPos, changePos, returnPos, gray;	Chunk_id		chunk;            		pixelSkipCount = changeCount = packetCount = 0;	changePos = returnPos = 0;	chunk.size = 0;	chunk.type = FLI_COLOR256;	for (i = 0; i < 256; i++)		{		if (!(EQUAL(cbmpi->bmiColors[i], pbmpi->bmiColors[i])))			{			if (changeCount)     // we're within a change section				{				changeCount++;				if (grayScale)					{					gray = (cbmpi->bmiColors[i].rgbRed + cbmpi->bmiColors[i].rgbGreen +						cbmpi->bmiColors[i].rgbBlue)/3;					if (gray > 255)	byte = 255;					else			byte = (unsigned char)	gray; 				   	movieBuffer->IOData(&byte, 1);				   	movieBuffer->IOData(&byte, 1);				   	movieBuffer->IOData(&byte, 1);					}				else					{					movieBuffer->IOData(&(cbmpi->bmiColors[i].rgbRed), 1);					movieBuffer->IOData(&(cbmpi->bmiColors[i].rgbGreen), 1);					movieBuffer->IOData(&(cbmpi->bmiColors[i].rgbBlue), 1);                	}				}			else				{                 // inside a skip section				if (packetCount == 0)    // first packet					{					chunkPos = movieBuffer->IOGetPosition();					movieBuffer->IOType(&(chunk.size), IO_LONG_I);					movieBuffer->IOType(&(chunk.type), IO_SHORT_I);					countPos = movieBuffer->IOGetPosition();           	 	    movieBuffer->IOType(&packetCount, IO_SHORT_I);					}				movieBuffer->IOType(&pixelSkipCount, IO_CHAR);				changePos = movieBuffer->IOGetPosition();				movieBuffer->IOType(&changeCount, IO_CHAR);				pixelSkipCount = 0;           	 	changeCount++;				packetCount++;				if (grayScale)					{					gray = (cbmpi->bmiColors[i].rgbRed + cbmpi->bmiColors[i].rgbGreen +						cbmpi->bmiColors[i].rgbBlue)/3;					if (gray > 255)	byte = 255;					else			byte = (unsigned char)	gray; 				   	movieBuffer->IOData(&byte, 1);				   	movieBuffer->IOData(&byte, 1);				   	movieBuffer->IOData(&byte, 1);					}				else					{					movieBuffer->IOData(&(cbmpi->bmiColors[i].rgbRed), 1);					movieBuffer->IOData(&(cbmpi->bmiColors[i].rgbGreen), 1);					movieBuffer->IOData(&(cbmpi->bmiColors[i].rgbBlue), 1);                	}				}			}		else			{			if (changeCount)  // within a change section				{				/* update the change count */				returnPos = movieBuffer->IOGetPosition();				movieBuffer->IOTypePosition(&changeCount, IO_CHAR, changePos);   				movieBuffer->IOSetPosition(returnPos);				changeCount = 0;            	pixelSkipCount = 1;				}			else             // a skip section				pixelSkipCount++;			}		}	/* update */	if (changeCount)		{		returnPos = movieBuffer->IOGetPosition();		movieBuffer->IOTypePosition(&changeCount, IO_CHAR, changePos);   		movieBuffer->IOSetPosition(returnPos);		}	/* clean up */	if (packetCount > 0)		{ 	  	ULong dist;		chunkCount++;		returnPos = movieBuffer->IOGetPosition();		dist = returnPos - chunkPos;		if ((dist % 2) == 1)        	{			dist++;            byte = 0;            movieBuffer->IOData(&byte, 1);            returnPos++;            }		movieBuffer->IOTypePosition(&packetCount, IO_SHORT_I, countPos);		movieBuffer->IOTypePosition(&dist, IO_LONG_I, chunkPos);    	movieBuffer->IOSetPosition(returnPos);		}	return(err);}#endif/* byteDiff is very much like BRUNCompress, except for the skips(which are rather messy).  The skipcount can be > 255 (sincerows can be 320 pixels long) and larger than the resolution of abyte.  We must check for long skips and store the pixel at the254th position, to be written as a copy packet */intAnimatorMovie::ByteDiffFar(short *lineCounter, short *blankCounter, long length, char *currBuf, char *prevBuf){#if WINDOWS	register int 	i;	long	pixelSkipCount, diffCount, stripStart, packetCounter;	ULong	packetCountPos, endPos;    char	arcaneCopyByte = 0;	int		state = SAME_STATE;   	/* init vars */	pixelSkipCount = 0;	diffCount = stripStart = packetCounter = 0;    /* diff the pixel values */	for (i = 0; i < length; i++)		{        /* we're in a run of similar pixels */		if (state == SAME_STATE)			{			if (currBuf[i] == prevBuf[i])            	{				if (++pixelSkipCount == 255)            		arcaneCopyByte = currBuf[i];				}			else				{				stripStart = i;				state = DIFF_STATE;				diffCount++;				}			}        /* we are in a run of differing pixels */ 		else if (state == DIFF_STATE)			{			if (currBuf[i] == prevBuf[i])				{				state = UNDECIDED_STATE;				} 			else	            diffCount++;			}		/* we may be still within a strip, but we may not */		else if (state == UNDECIDED_STATE)			{            /* we're no longer in the strip; write it out */			if (currBuf[i] == prevBuf[i])				{				/* if packetCounter == 0, then we have yet to write                out anything on this line.  Do all the placeholding things */				if (!packetCounter)					{					long 	j;                	char	byte = 0;					char packetCount = (unsigned char) packetCounter;					/* write out any placeholding (blank) lines */					for (j = 0; j < (*blankCounter); j++)						{						movieBuffer->IOData(&byte, 1);                    	(*lineCounter)++;						}                	(*blankCounter) = 0;					/* we haven't written out the placeholder, so do so */					packetCountPos = movieBuffer->IOGetPosition();					movieBuffer->IOData(&packetCount, 1);					}				/* handle the arcane problem of skipcounts larger                than the resoluion of the byte.  */				if (pixelSkipCount >= 255)					{					char	arcaneSkip = 254;                    char	arcaneCount = 1;					movieBuffer->IOData(&arcaneSkip, 1);					movieBuffer->IOData(&arcaneCount, 1);					movieBuffer->IOData(&arcaneCopyByte, 1);					pixelSkipCount -= 255;					packetCounter++;					}				/* write out */				packetCounter += ByteCompressFar(BDELTA, pixelSkipCount, diffCount, &currBuf[stripStart]);				state = SAME_STATE;				pixelSkipCount = 2;				diffCount = 0;				}            /* we're still in the strip */			else				{              	state = DIFF_STATE;				diffCount += 2;  				}			}		}	if ((state == DIFF_STATE) || (state == UNDECIDED_STATE))    	{		if (!packetCounter)			{			long 	j;			char	byte = 0;			char packetCount = (unsigned char) packetCounter;			/* write out any placeholding lines */			for (j = 0; j < (*blankCounter); j++)				{				movieBuffer->IOData(&byte, 1);				(*lineCounter)++;				}			(*blankCounter) = 0;			packetCountPos = movieBuffer->IOGetPosition();			movieBuffer->IOData(&packetCount, 1);			}		/* handle the arcane problem of skipcounts larger        than the resoluion of the byte.  */		if (pixelSkipCount >= 255)			{			char	arcaneSkip = 254;            char	arcaneCount = 1;			movieBuffer->IOData(&arcaneSkip, 1);			movieBuffer->IOData(&arcaneCount, 1);			movieBuffer->IOData(&arcaneCopyByte, 1);			pixelSkipCount -= 255;            packetCounter++;			}		packetCounter += ByteCompressFar(BDELTA, pixelSkipCount, diffCount, &currBuf[stripStart]);		pixelSkipCount = 0;		}	else /* if (state == SAME_STATE) */		{		/* four cases:			we have written out no lines, and wrote no packets				this time (do nothing)			we have written out no lines, but wrote packets				out for this line (do nothing)			we have written out lines previously, but wrote no				packets for this line (increment blankCounter)			we have written out lines previously, and wrote				packets for this line, too (do nothing)		check for case three, and increment the counter */		if ((*lineCounter) && (!packetCounter))			(*blankCounter)++;		}    /* update the packet count */	if (packetCounter)		{		char packetCount = (unsigned char) packetCounter;		endPos = movieBuffer->IOGetPosition();		movieBuffer->IOTypePosition(&packetCount, IO_CHAR, packetCountPos);		movieBuffer->IOSetPosition(endPos);		(*lineCounter)++;		return(1);		}	else#endif    	return(0);}/* WordDiff is very much like ByteDiff, except it's word-oriented andmay have multiple pixel-skip packets to the line (lines can be > 320pixels wide).  So we use a V_Array to hold the arcaneCopy bytesA Word-Diffed image is made up of:                   |          per line                    |   packets ------>|--------|---------|--------------------------------------|-----------------------------| header | # lines | line skip | last byte | packet count | col skip + packet type ||--------|---------|--------------------------------------|-------------------------------| ...... | word    | word      | word      | word         |       word             |last byte and line skip are optional.  They appear only if necessary.*/intAnimatorMovie::WordDiffFar(short *lineCounter, short *skipCount, long length, char *currBuf, char *prevBuf){#if WINDOWS	register int	i;	long	pixelSkipCount, diffCount, stripStart, wordLength;    ULong	packetCountPos, endPos;	int		state = SAME_STATE, odd;	short	*currSBuf, *prevSBuf, packetCounter;	V_Array	*arcaneCopyWords;    aaWordDiffPacket packet;   	/* init vars */	pixelSkipCount = 0;	arcaneCopyWords = new(V_Array);	arcaneCopyWords->cArray(2, sizeof(aaWordDiffPacket), 2);	VA_Truncate(arcaneCopyWords);	diffCount = stripStart = packetCounter = 0;	odd = length % 2;	wordLength = (length-odd)/2; 	// number of words in the line.	currSBuf = (short*) currBuf;    prevSBuf = (short*) prevBuf;	/* diff the pixel values	   Two basic cases:  the pixels in the two strips are the same, or the pixels in the	   two strips are different.  If they are the same, increment the skip count.	   If the skip count is greater than 255, then we have to put in a copy packet or       something as a place-holder.	*/	for (i = 0; i < wordLength; i++)		{        /* we are in a run of similar pixels */		if (state == SAME_STATE)			{			if (currSBuf[i] == prevSBuf[i])				{				pixelSkipCount += 2;				if (pixelSkipCount == 256)					{					packet.skip = 254;					packet.typeCount = 1;					packet.data = currSBuf[i];					arcaneCopyWords->Append(&packet);					pixelSkipCount = 0;                    }				}			else				{				stripStart = i;				state = DIFF_STATE;				diffCount++;				}			}        /* we are in a run of differing pixels */ 		else if (state == DIFF_STATE)			{			if (currSBuf[i] == prevSBuf[i])				{				if (!packetCounter)					{                    short packetCount = 0;					if (*skipCount)						{						short lineSkip = -(*skipCount);						movieBuffer->IOType(&lineSkip, IO_SHORT_I);                        *skipCount = 0;						}					if ((odd) && (currBuf[length-1] != prevBuf[length-1]))						{						short lastPixel = ((short) currBuf[length-1]) && 0x00FF;						lastPixel |= LASTPIXEL;						movieBuffer->IOType(&lastPixel, IO_SHORT_I);						}                    /* we haven't written out the placeholder, so do so */					packetCountPos = movieBuffer->IOGetPosition();					movieBuffer->IOType(&packetCount, IO_SHORT_I);					}				/* handle the arcane problem of skipcounts larger        		than the resoluion of the byte.  */				if (arcaneCopyWords->ALength() > 0)					{					int		j;					aaWordDiffPacket *packets;                    packets = (aaWordDiffPacket *) arcaneCopyWords->Use();					for (j = 0; j < arcaneCopyWords->ALength(); j++)						{						movieBuffer->IOData(&(packets[j].skip), 1);						movieBuffer->IOData(&(packets[j].typeCount), 1);						movieBuffer->IOType(&(packets[j].data), IO_SHORT_I);						packetCounter++;						}					arcaneCopyWords->Unuse();					VA_Truncate(arcaneCopyWords);					} 				/* write out */				packetCounter += WordCompressFar(pixelSkipCount, diffCount, &currSBuf[stripStart]);				state = SAME_STATE;				pixelSkipCount = 2;				diffCount = 0;				}			else	            diffCount++;			}		}    /* clean up */	if (state == DIFF_STATE)		{		if (!packetCounter)			{			if (*skipCount)				{				short lineSkip = -(*skipCount);				movieBuffer->IOType(&lineSkip, IO_SHORT_I);                *skipCount = 0;				}			if ((odd) && (currBuf[length-1] != prevBuf[length-1]))				{				short lastPixel = ((short) currBuf[length-1]) && 0x00FF;				lastPixel |= LASTPIXEL;				movieBuffer->IOType(&lastPixel, IO_SHORT_I);				}			packetCountPos = movieBuffer->IOGetPosition();			movieBuffer->IOType(&packetCounter, IO_SHORT_I);			}		/* handle the arcane problem of skipcounts larger        than the resoluion of the byte.  */		if (arcaneCopyWords->ALength() > 0)			{			int		j;			aaWordDiffPacket *packets;            packets = (aaWordDiffPacket *) arcaneCopyWords->Use();			for (j = 0; j < arcaneCopyWords->ALength(); j++)				{				movieBuffer->IOData(&(packets[j].skip), 1);				movieBuffer->IOData(&(packets[j].typeCount), 1);				movieBuffer->IOType(&(packets[j].data), IO_SHORT_I);				packetCounter++;				}			arcaneCopyWords->Unuse();			VA_Truncate(arcaneCopyWords);			}		packetCounter += WordCompressFar(pixelSkipCount, diffCount, &currSBuf[stripStart]);		}	else /* if (state == SAME_STATE) */		{		/* if we have written out any packets for this line, then		everything's fine.  Otherwise, we must handle the "last		pixel on the row changed" problem */		if (!packetCounter) /* no packets written for this line */        	{			if ((odd) && (currBuf[length-1] != prevBuf[length-1]))        		{				if (*skipCount)					{					short lineSkip = -(*skipCount);					movieBuffer->IOType(&lineSkip, IO_SHORT_I);					(*skipCount) = 0;					}				short lastPixel = ((short) currBuf[length-1]) && 0x00FF;				lastPixel |= LASTPIXEL;				movieBuffer->IOType(&lastPixel, IO_SHORT_I);				packetCountPos = movieBuffer->IOGetPosition();				movieBuffer->IOType(&packetCounter, IO_SHORT_I);				(*lineCounter)++;				}			else    /* we've skipped a line */				(*skipCount)++;        	}		}	arcaneCopyWords->dArray();      // delete the copy buf    /* update the packet count */	if (packetCounter)		{		endPos = movieBuffer->IOGetPosition();		movieBuffer->IOTypePosition(&packetCounter, IO_SHORT_I, packetCountPos);		movieBuffer->IOSetPosition(endPos);		(*lineCounter)++;		return(1);		}	else#endif    	return(0);}#if 0intAnimatorMovie::WordDiffFar(short *lineCounter, short *skipCount, long length, char *currBuf, char *prevBuf){#if WINDOWS	register int	i;	long	pixelSkipCount, diffCount, stripStart, wordLength;    ULong	packetCountPos, endPos;	int		state = SAME_STATE, odd, arcaneCounter;	short	*currSBuf, *prevSBuf, packetCounter;    V_Array	*arcaneCopyWords;   	/* init vars */	pixelSkipCount = 0;	arcaneCopyWords = new(V_Array);	arcaneCopyWords->cArray(2, sizeof(short), 1);	VA_Truncate(arcaneCopyWords);	diffCount = stripStart = packetCounter = 0;    arcaneCounter = 0;	odd = length % 2;	wordLength = (length-odd)/2; 	// number of words in the line.	currSBuf = (short*) currBuf;    prevSBuf = (short*) prevBuf;    /* diff the pixel values */	for (i = 0; i < wordLength; i++)		{        /* we are in a run of similar pixels */		if (state == SAME_STATE)			{			if (currSBuf[i] == prevSBuf[i])				{				pixelSkipCount += 2;				arcaneCounter += 2;				if (arcaneCounter == 256)					{					arcaneCopyWords->Append(&currSBuf[i]);                    arcaneCounter = 0;                    }				}			else				{				stripStart = i;				state = DIFF_STATE;				diffCount++;				}			}        /* we are in a run of differing pixels */ 		else if (state == DIFF_STATE)			{			if (currSBuf[i] == prevSBuf[i])				{				state = UNDECIDED_STATE;				} 			else	            diffCount++;			}		/* we may be still within a strip, but we may not */		else if (state == UNDECIDED_STATE)			{            /* we're no longer in the strip; write it out */			if (currSBuf[i] == prevSBuf[i])				{				if (!packetCounter)					{                    short packetCount = 0;					if (*skipCount)						{						short lineSkip = -(*skipCount);						movieBuffer->IOType(&lineSkip, IO_SHORT_I);                        *skipCount = 0;						}					if ((odd) && (currBuf[length-1] != prevBuf[length-1]))						{						short lastPixel = ((short) currBuf[length-1]) && 0x00FF;						lastPixel |= LASTPIXEL;						movieBuffer->IOType(&lastPixel, IO_SHORT_I);						}                    /* we haven't written out the placeholder, so do so */					packetCountPos = movieBuffer->IOGetPosition();					movieBuffer->IOType(&packetCount, IO_SHORT_I);					}				/* handle the arcane problem of skipcounts larger        		than the resoluion of the byte.  */				if (pixelSkipCount > 255)					{					char	arcaneSkip = 254;					char	arcaneCount = 1;            		short	arcaneWord;					int		j = 0;					while (pixelSkipCount > 255)						{               		 	arcaneCopyWords->Get(j, &arcaneWord);						movieBuffer->IOData(&arcaneSkip, 1);						movieBuffer->IOData(&arcaneCount, 1);						movieBuffer->IOType(&arcaneWord, IO_SHORT_I);						pixelSkipCount -= 256;						j++;                        packetCounter++;						}                    VA_Truncate(arcaneCopyWords);					} 				/* write out */				packetCounter += WordCompressFar(pixelSkipCount, diffCount, &currSBuf[stripStart]);				state = SAME_STATE;				pixelSkipCount = 4;                arcaneCounter = 4;				diffCount = 0;				}            /* we're still in the strip */			else				{              	state = DIFF_STATE;				diffCount += 2;  				}			}		}    /* clean up */	if ((state == DIFF_STATE) || (state == UNDECIDED_STATE))		{		if (!packetCounter)			{			if (*skipCount)				{				short lineSkip = -(*skipCount);				movieBuffer->IOType(&lineSkip, IO_SHORT_I);                *skipCount = 0;				}			if ((odd) && (currBuf[length-1] != prevBuf[length-1]))				{				short lastPixel = ((short) currBuf[length-1]) && 0x00FF;				lastPixel |= LASTPIXEL;				movieBuffer->IOType(&lastPixel, IO_SHORT_I);				}			packetCountPos = movieBuffer->IOGetPosition();			movieBuffer->IOType(&packetCounter, IO_SHORT_I);			}		/* handle the arcane problem of skipcounts larger        than the resoluion of the byte.  */		if (pixelSkipCount > 255)			{			char	arcaneSkip = 254;			char	arcaneCount = 1;            short	arcaneWord;			int		j = 0;			while (pixelSkipCount > 255)				{                arcaneCopyWords->Get(j, &arcaneWord);				movieBuffer->IOData(&arcaneSkip, 1);				movieBuffer->IOData(&arcaneCount, 1);				movieBuffer->IOType(&arcaneWord, IO_SHORT_I);				pixelSkipCount -= 256;                packetCounter++;                j++;                }			VA_Truncate(arcaneCopyWords);			}		packetCounter += WordCompressFar(pixelSkipCount, diffCount, &currSBuf[stripStart]);		}	else /* if (state == SAME_STATE) */		{		/* if we have written out any packets for this line, then		everything's fine.  Otherwise, we must handle the "last		pixel on the row changed" problem */		if (!packetCounter) /* no packets written for this line */        	{			if ((odd) && (currBuf[length-1] != prevBuf[length-1]))        		{				if (*skipCount)					{					short lineSkip = -(*skipCount);					movieBuffer->IOType(&lineSkip, IO_SHORT_I);					(*skipCount) = 0;					}				short lastPixel = ((short) currBuf[length-1]) && 0x00FF;				lastPixel |= LASTPIXEL;				movieBuffer->IOType(&lastPixel, IO_SHORT_I);				packetCountPos = movieBuffer->IOGetPosition();				movieBuffer->IOType(&packetCounter, IO_SHORT_I);				(*lineCounter)++;				}			else    /* we've skipped a line */				(*skipCount)++;        	}		}	arcaneCopyWords->dArray();      // delete the copy buf    /* update the packet count */	if (packetCounter)		{		endPos = movieBuffer->IOGetPosition();		movieBuffer->IOTypePosition(&packetCounter, IO_SHORT_I, packetCountPos);		movieBuffer->IOSetPosition(endPos);		(*lineCounter)++;		return(1);		}	else#endif    	return(0);}#endif // 0intAnimatorMovie::ByteCompressFar(int type, long skip, long length, char *uncompressed){#if WINDOWS	register int 	uncompIter;	long	pixCount, copyBegin, copyCount, packetCounter;	unsigned char lastPixel, skipCount;	int 	state = COPY_STATE;	/* initialize the variables of the state machine */	lastPixel = uncompressed[0];	packetCounter = 0;	pixCount = 1;	uncompIter = 1;	copyBegin = 0;	copyCount = 1;    skipCount = (unsigned char) skip;	/* 	COPY:  copy the next -n pixels to the buffer		REPLICATE:  replicate the next pixel n times	*/while (uncompIter < length)	{	if (state == REPLICATE_STATE)		{		if (lastPixel == uncompressed[uncompIter])			{			uncompIter++;			pixCount++;			if (pixCount == 127)				{				if (type == BDELTA)                	{					pixCount = -pixCount;					movieBuffer->IOData(&skipCount, 1);                	}				movieBuffer->IOData(&pixCount, 1);                movieBuffer->IOData(&lastPixel, 1);				pixCount = 0;				skipCount = 0;				packetCounter++;				if (uncompIter < length)					{                    copyBegin = uncompIter;					lastPixel = uncompressed[uncompIter++];					pixCount++;                    copyCount = 1;                    }				state = COPY_STATE;				}			}		else			{			state = COPY_STATE;			if (pixCount)				{				if (type == BDELTA)                	{					pixCount = -pixCount;					movieBuffer->IOData(&skipCount, 1);                	}				movieBuffer->IOData(&pixCount, 1);				movieBuffer->IOData(&lastPixel, 1);                copyBegin = uncompIter;				lastPixel = uncompressed[uncompIter++];				skipCount = 0;                packetCounter++;				pixCount = 1;				copyCount = 1;				}			}		}	else /* if (state == COPY_STATE)  */		{		if (lastPixel != uncompressed[uncompIter])			{            copyCount++;			lastPixel = uncompressed[uncompIter++];			pixCount++;				if (pixCount == 127)				{                if (type == BDELTA)					movieBuffer->IOData(&skipCount, 1);				else if (type == BRUN)                	pixCount = -pixCount;                movieBuffer->IOData(&pixCount, 1);				movieBuffer->IOData(&uncompressed[copyBegin], copyCount);				packetCounter++;				pixCount = 0;                skipCount = 0;				if (uncompIter < length)					{                    copyBegin = uncompIter;					lastPixel = uncompressed[uncompIter++];					pixCount++;                    copyCount = 1;					}				}			}		else			{			state = REPLICATE_STATE;            /* backtrack one location */			if (pixCount - 1 > 0)				{				if (type == BDELTA)                	{                	pixCount--;					movieBuffer->IOData(&skipCount, 1);					}				else if (type == BRUN)					pixCount = 1 - pixCount;                movieBuffer->IOData(&pixCount, 1);				movieBuffer->IOData(&uncompressed[copyBegin], copyCount-1);				packetCounter++;				pixCount = 1;				skipCount = 0;				if (uncompIter < length)					{                    copyBegin = uncompIter;					lastPixel = uncompressed[uncompIter++];					pixCount++;                    copyCount = 1;                    }				}			}		}	}if (pixCount)	{	if (state == REPLICATE_STATE)		{		if (type == BDELTA)        	{			pixCount = -pixCount;			movieBuffer->IOData(&skipCount, 1);            }		movieBuffer->IOData(&pixCount, 1);		movieBuffer->IOData(&lastPixel, 1);        packetCounter++;		}	else		{		if (type == BDELTA)			movieBuffer->IOData(&skipCount, 1);		else if (type == BRUN)            pixCount = -pixCount;		movieBuffer->IOData(&pixCount, 1);		movieBuffer->IOData(&uncompressed[copyBegin], copyCount);		packetCounter++;		}	}	return(packetCounter);#endif}intAnimatorMovie::WordCompressFar(long skip, long length, short *uncompressed){#if WINDOWS	register int 	uncompIter;	long	pixCount, copyBegin, copyCount, packetCounter;	unsigned char skipCount;	int 	state = COPY_STATE, i;	short 	lastPixel;	/* initialize the variables of the state machine */	lastPixel = uncompressed[0];	packetCounter = 0;	pixCount = 1;	uncompIter = 1;    copyBegin = 0;	copyCount = 1;    skipCount = (unsigned char) skip;	/* 	COPY:  copy the next -n pixels to the buffer		REPLICATE:  replicate the next pixel n times	*/while (uncompIter < length)	{	if (state == REPLICATE_STATE)		{		if (lastPixel == uncompressed[uncompIter])			{			uncompIter++;			pixCount++;			if (pixCount == 127)				{				pixCount = -pixCount;                movieBuffer->IOData(&skipCount, 1);				movieBuffer->IOData(&pixCount, 1);                movieBuffer->IOType(&lastPixel, IO_SHORT_I);				pixCount = 0;				skipCount = 0;				packetCounter++;				if (uncompIter < length)					{                    copyBegin = uncompIter;					lastPixel = uncompressed[uncompIter++];					pixCount++;                    copyCount = 1;                    }				state = COPY_STATE;				}			}		else			{			state = COPY_STATE;			if (pixCount)				{				pixCount = -pixCount;                movieBuffer->IOData(&skipCount, 1);				movieBuffer->IOData(&pixCount, 1);				movieBuffer->IOType(&lastPixel, IO_SHORT_I);                copyBegin = uncompIter;				lastPixel = uncompressed[uncompIter++];				skipCount = 0;                packetCounter++;				pixCount = 1;				copyCount = 1;				}			}		}	else /* if (state == COPY_STATE)    */		{		if (lastPixel != uncompressed[uncompIter])			{			copyCount++;			lastPixel = uncompressed[uncompIter++];			pixCount++;				if (pixCount == 127)				{ 				movieBuffer->IOData(&skipCount, 1);				movieBuffer->IOData(&pixCount, 1);				for (i = 0; i < copyCount; i++)                	{					movieBuffer->IOType(&(uncompressed[copyBegin++]), IO_SHORT_I);                    }				pixCount = 0;				skipCount = 0;				packetCounter++;				if (uncompIter < length)					{                    copyBegin = uncompIter;					lastPixel = uncompressed[uncompIter++];					pixCount++;                    copyCount = 1;                    }				}			}		else			{			state = REPLICATE_STATE;			if (pixCount - 1 > 0)				{                pixCount--;				movieBuffer->IOData(&skipCount, 1);                movieBuffer->IOData(&pixCount, 1);				for (i = 0; i < copyCount-1; i++)                	{					movieBuffer->IOType(&(uncompressed[copyBegin++]), IO_SHORT_I);                    }				pixCount = 1;				skipCount = 0;				packetCounter++;				if (uncompIter < length)					{                    copyBegin = uncompIter;					lastPixel = uncompressed[uncompIter++];					pixCount++;                    copyCount = 1;                    }				}						}		}	}if (pixCount)	{	if (state == REPLICATE_STATE)		{		pixCount = -pixCount;		movieBuffer->IOData(&skipCount, 1);		movieBuffer->IOData(&pixCount, 1);		movieBuffer->IOType(&lastPixel, IO_SHORT_I);        packetCounter++;		}	else		{		movieBuffer->IOData(&skipCount, 1);		movieBuffer->IOData(&pixCount, 1);		for (i = 0; i < copyCount; i++)            {			movieBuffer->IOType(&(uncompressed[copyBegin++]), IO_SHORT_I);            }		packetCounter++;		}	}	return(packetCounter);#endif}intAnimatorMovie::NoCompress(long length, char *uncompressed){#if WINDOWS	movieBuffer->IOData(uncompressed, length);	return(err);#endif}#if 0intAnimatorMovie::WritePostageStamp(struct V_Offscreen *pStamp, int cmapOnlyFlag){	Pstamp_chunk	chunk;	Rect			psRect;	int 			i, j;	char			cube6Lookup[256], pixBuf[104];    ULong	chunkPos, returnPos;#if WINDOWS	HDC				HDevCon;	LPBITMAPINFO	bmpi;    HBITMAP			tempBits;	pStamp->GetRect(&psRect);	bmpi = (LPBITMAPINFO) aHeader->Use();	bmpi->bmiHeader.biWidth = psRect.right;	bmpi->bmiHeader.biHeight = psRect.bottom;	HDevCon = GetDC(NULL);	// We're not supposed to have the bitmap selected	//when we do SetDIBits calls, so let's unselect it.	tempBits = SelectObject(HDevCon, pStamp->oldBitmap);	ASSERT(tempBits == pStamp->bitmap);	if (tempBits != pStamp->bitmap)		{		ReleaseDC(NULL, HDevCon);		aHeader->Unuse();		err = -1;        return(err);		}	/* init the color table, other header things */	GetDIBits(HDevCon, tempBits, 0, bmpi->bmiHeader.biHeight, NULL, (BITMAPINFO FAR*) bmpi, DIB_RGB_COLORS);	/* create a color lookup table for the 6-cube color space of	the postage stamp */	for (i = 0; i < 256; i++)		cube6Lookup[i] = (((6 * bmpi->bmiColors[i].rgbRed)/256) * 36)				+ (((6 * bmpi->bmiColors[i].rgbGreen)/256) * 6)				+ ((6 * bmpi->bmiColors[i].rgbBlue)/256);#endif	if (cmapOnlyFlag)		/* just write a color translation table for the regular        image.  Do not write a separate image */		{		chunk.size = sizeof(Pstamp_chunk) + 256;		chunk.type = FLI_PSTAMP;		chunk.width = r.right - r.left;		chunk.height = r.bottom - r.top;		chunk.xlat_type = 1;		chunk.data.size = 256 * 3 /*sizeof(RGB8BitColor)*/;		chunk.data.type = FPS_XLAT256;		movieBuffer->IOType(&(chunk.size), IO_LONG_I);		movieBuffer->IOType(&(chunk.type), IO_SHORT_I);		movieBuffer->IOType(&(chunk.width),  IO_SHORT_I);		movieBuffer->IOType(&(chunk.height), IO_SHORT_I);		movieBuffer->IOType(&(chunk.xlat_type), IO_SHORT_I);		movieBuffer->IOType(&(chunk.data.size), IO_LONG_I);		movieBuffer->IOType(&(chunk.data.type), IO_SHORT_I);		movieBuffer->IOData(&(cube6Lookup[0]), 256);		}	else    	/* write the postage stamp.  Do the image */    	{		chunk.size = 0;		chunk.type = FLI_PSTAMP;		chunk.width = psRect.right - psRect.left;		chunk.height = psRect.bottom - psRect.top;		chunk.xlat_type = 1;    	chunk.data.size = 0;		chunk.data.type = FPS_BRUN;		chunkPos = movieBuffer->IOGetPosition();		movieBuffer->IOType(&(chunk.size), IO_LONG_I);		movieBuffer->IOType(&(chunk.type), IO_SHORT_I);		movieBuffer->IOType(&(chunk.width), IO_SHORT_I);		movieBuffer->IOType(&(chunk.height), IO_SHORT_I);		movieBuffer->IOType(&(chunk.xlat_type), IO_SHORT_I);		movieBuffer->IOType(&(chunk.data.size), IO_LONG_I);		movieBuffer->IOType(&(chunk.data.type), IO_SHORT_I);		for (i = chunk.height; i >= 0; i--)			{			GetDIBits(HDevCon, tempBits, i, 1,				(void FAR*) pixBuf, (BITMAPINFO FAR*) bmpi, DIB_RGB_COLORS);            /* convert to the cube-6 color space */			for (j = 0; j < chunk.width; j++)				pixBuf[j] = cube6Lookup[pixBuf[j]];			BRUNCompress(chunk.width, pixBuf);			}		returnPos = movieBuffer->IOGetPosition();		chunk.size = returnPos - chunkPos;		chunk.data.size = chunk.size - 12;		movieBuffer->IOTypePosition(&(chunk.size), IO_LONG_I, chunkPos);		movieBuffer->IOTypePosition(&(chunk.data.size), IO_LONG_I, chunkPos+12);        movieBuffer->IOSetPosition(returnPos);		}	SelectObject(HDevCon, tempBits); 	aHeader->Unuse();	ReleaseDC(NULL, HDevCon);	return(err);}#endif 