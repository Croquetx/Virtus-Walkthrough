/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				 *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * Catmull-Rom spline curve.  We are using the interpolatory version here as described * by Barry "A Recursive Evaluation Algorithm for a Class of Catmull-Rom Splines" in * Siggraph 1988 pp 199-204. * NOTE: * 	This method guarantees that the new curve will include the original points as * 	well as the interpolated points. * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "SmthPath.h"#include "VMath.h"#include "WTypes.h"#include "Observer.h"#include "VArray.h"#include <math.h>Point3DFFixed ExtendPoint(Point3DFFixed pf, Point3DFFixed pt);Angle3DFFixed ExtendAngle(Angle3DFFixed af, Angle3DFFixed at);void DoCatmullRom(V_Array *outPath,	Point3DFFixed p0,Point3DFFixed p1,Point3DFFixed p2,Point3DFFixed p3,	Angle3DFFixed a0,Angle3DFFixed a1,Angle3DFFixed a2,Angle3DFFixed a3,	int tDelta);void CatmullRomPoint(V_Array *out,	Point3DFFixed pf0,Point3DFFixed pf1,Point3DFFixed pf2,Point3DFFixed pf3,	Angle3DFFixed af0,Angle3DFFixed af1,Angle3DFFixed af2,Angle3DFFixed af3,	double t);double CalcCR1(double p0, double p1, double p2, double p3, double t);double CalcACR1(double p0, double p1, double p2, double p3, double t);double SegDistance(Point3DFFixed p1,Angle3DFFixed a1,Point3DFFixed p2,Angle3DFFixed a2);/*------------------------------------------------------------------------------ * V_Array *SmoothPath(V_Array *inPath,int f, int t, int ef) * V_Array *inPath; -------V_Array of ObserverStep (see Observer.c). * int f;			-------from frame * int t;			-------to frame * int ef;			-------expansion factor for average frame distance *------------------------------------------------------------------------------*/V_Array *SmoothPath(V_Array *inPath,int f, int t, int ef){V_Array *outPath;ObserverStep *os;Point3DFFixed p0,p1,p2,p3;Angle3DFFixed a0,a1,a2,a3;int i,tDelta;int delta=f<t?1:-1;int totalFrames=1+delta*(t-f);double pLength=0,avLength, sLength;if(totalFrames>inPath->ALength())return 0;/*there are too many frames*/outPath = new(V_Array);outPath->cArray(0,sizeof(ObserverStep*),4);if(totalFrames<=1)	{inPath->Get(f,&os); outPath->Append(&os); return outPath;}for(i=f;i!=t;i+=delta)	{	ObserverStep *s1,*s2;	inPath->Get(i,&s1); s1->GetStep(&p1,&a1);	inPath->Get(i+delta,&s2);s2->GetStep(&p2,&a2);	pLength+=SegDistance(p1,a1,p2,a2);	}avLength=pLength/totalFrames; /*avLength is the average length of a segment. We divide the current segment distance  by this value and multiply it by the expansion factor to determine the number of  interpolated frames we will have.  A value less than one indicates that we don't   bother interpolating. *//*unfortunately, with the Catmull-Rom spline curve, you lose both the first and the  last points of the original curve.  Since these may be important, let's manufacture  some new "ends" just outside of where ours are using ExtendPoint() and ExtendAngle.*/  inPath->Get(f,&os); os->GetStep(&p1,&a1);/*first key frame*/inPath->Get(f+delta,&os); os->GetStep(&p2,&a2); /*second key frame*/p0=ExtendPoint(p2,p1);a0=ExtendAngle(a2,a1);/*we may only have two points, so let's just make sure!*/if(totalFrames==2)/*manufacture p3*/	{	p3=ExtendPoint(p1,p2);	a3=ExtendAngle(a1,a2);	tDelta=ef*SegDistance(p1,a1,p2,a2)/avLength;		DoCatmullRom(outPath,p0,p1,p2,p3,a0,a1,a2,a3,tDelta);	/*add the last frame!*/	os=new(ObserverStep);	os->SetStep(p2,a2);	outPath->Append(&os); 	return outPath;	}else	{inPath->Get(f+(2*delta),&os); os->GetStep(&p3,&a3);}/*third key frame*/tDelta=ef*SegDistance(p1,a1,p2,a2)/avLength;DoCatmullRom(outPath,p0,p1,p2,p3,a0,a1,a2,a3,tDelta);if(totalFrames>3)/*interpolate all these others*/for(i=f+(3*delta);i!=t;i+=delta)	{	p0=p1; p1=p2; p2=p3; 	a0=a1; a1=a2; a2=a3;	inPath->Get(i,&os); os->GetStep(&p3,&a3);	tDelta=ef*SegDistance(p1,a1,p2,a2)/avLength;	DoCatmullRom(outPath,p0,p1,p2,p3,a0,a1,a2,a3,tDelta);	}/*do the last segment*/p0=p1; p1=p2; p2=p3; a0=a1; a1=a2; a2=a3;p3=ExtendPoint(p1,p2);a3=ExtendAngle(a1,a2);tDelta=ef*SegDistance(p1,a1,p2,a2)/avLength;DoCatmullRom(outPath,p0,p1,p2,p3,a0,a1,a2,a3,tDelta);/*add the last frame!*/os=new(ObserverStep);os->SetStep(p2,a2);outPath->Append(&os); return outPath;}  /*------------------------------------------------------------------------------ * Point3DFFixed ExtendPoint(Point3DFFixed pf, Point3DFFixed pt) *------------------------------------------------------------------------------*/Point3DFFixed ExtendPoint(Point3DFFixed pf, Point3DFFixed pt){Point3DFFixed rp;rp.x=FFAdd(pt.x,FFShift(FFSub(pt.x,pf.x),-1));rp.y=FFAdd(pt.y,FFShift(FFSub(pt.y,pf.y),-1));rp.z=FFAdd(pt.z,FFShift(FFSub(pt.z,pf.z),-1));return rp;}/*------------------------------------------------------------------------------ * Angle3DFFixed ExtendAngle(Angle3DFFixed pf, Angle3DFFixed pt) *------------------------------------------------------------------------------*/Angle3DFFixed ExtendAngle(Angle3DFFixed af, Angle3DFFixed at){Angle3DFFixed ra;FFixed dif;dif=FFSub(at.roll,af.roll); ra.roll=FFAdd(at.roll,dif);dif=FFSub(at.pitch,af.pitch); ra.pitch=FFAdd(at.pitch,dif);dif=FFSub(at.yaw,af.yaw); ra.yaw=FFAdd(at.yaw,dif);return ra;}/*------------------------------------------------------------------------------ * void DoCatmullRom(...) * This simply iterates through t. *------------------------------------------------------------------------------*/void DoCatmullRom(V_Array *outPath,	Point3DFFixed p0,Point3DFFixed p1,Point3DFFixed p2,Point3DFFixed p3,	Angle3DFFixed a0,Angle3DFFixed a1,Angle3DFFixed a2,Angle3DFFixed a3,	int tDelta){double t;ObserverStep *os;int i;/*we add p1 and a1 no matter what anyway!*/os=new(ObserverStep);os->SetStep(p1,a1);outPath->Append(&os);if(tDelta>0)	{	t=1.0/(tDelta+1);	for(i=1;i<=tDelta;i++)		CatmullRomPoint(outPath,p0,p1,p2,p3,a0,a1,a2,a3,t*i);	}}	/*------------------------------------------------------------------------------ * void CatmullRomPoint(...) * This simply breaks the problem into its component parts, recombines the  * results into one place and then adds it into the array. *------------------------------------------------------------------------------*/#define F2D(x) FixedToDbl(x)void CatmullRomPoint(V_Array *out,	Point3DFFixed pf0,Point3DFFixed pf1,Point3DFFixed pf2,Point3DFFixed pf3,	Angle3DFFixed af0,Angle3DFFixed af1,Angle3DFFixed af2,Angle3DFFixed af3,	double t){Point3DFFixed rp;Angle3DFFixed ra;ObserverStep *nextStep;rp.x=DblToFixed(CalcCR1(F2D(pf0.x),F2D(pf1.x),F2D(pf2.x),F2D(pf3.x),t));rp.y=DblToFixed(CalcCR1(F2D(pf0.y),F2D(pf1.y),F2D(pf2.y),F2D(pf3.y),t));rp.z=DblToFixed(CalcCR1(F2D(pf0.z),F2D(pf1.z),F2D(pf2.z),F2D(pf3.z),t));ra.roll=DblToFixed(CalcACR1(F2D(af0.roll),F2D(af1.roll),F2D(af2.roll),F2D(af3.roll),t));ra.pitch=DblToFixed(CalcACR1(F2D(af0.pitch),F2D(af1.pitch),F2D(af2.pitch),F2D(af3.pitch),t));ra.yaw=DblToFixed(CalcACR1(F2D(af0.yaw),F2D(af1.yaw),F2D(af2.yaw),F2D(af3.yaw),t));nextStep=new(ObserverStep);nextStep->SetStep(rp,ra);out->Append(&nextStep);}/*------------------------------------------------------------------------------ * double CalcCR1(double p0, double p1, double p2, double p3, double t) * double CalcACR1(double p0, double p1, double p2, double p3, double t) * Calculate Catmull-Rom in 1 dimension. * Calculate Angular Catmull-Rom in 1 dimension. * This is being written using doubles essentially for readability sake.  This is * obviously not the most efficient methd t do this, but since this is not part of * code that is going to be running very fast anyway, I don't care yet.  *------------------------------------------------------------------------------*/double CalcCR1(double p0, double p1, double p2, double p3, double t){double pp0,pp1,pp2;pp0=p0*(-t)+p1*(t+1); pp1=p1*(1-t)+p2*t; pp2=p2*(2-t)+p3*(t-1);p0=pp0*(1-t)+pp1*(t+1); p1=pp1*(2-t)+pp2*t;return (p0*(1-t)+p1*t)/2;}double CalcACR1(double p0, double p1, double p2, double p3, double t){double pp0,pp1,pp2,dp;/*first, put all of the numbers into range*/while(p0>MAXRANGE)p0-=FULLRANGE;while(p0<MINRANGE)p0+=FULLRANGE;while(p1>MAXRANGE)p1-=FULLRANGE;while(p1<MINRANGE)p1+=FULLRANGE;while(p2>MAXRANGE)p2-=FULLRANGE;while(p2<MINRANGE)p2+=FULLRANGE;while(p3>MAXRANGE)p3-=FULLRANGE;while(p3<MINRANGE)p3+=FULLRANGE;dp=p0-p1;if(dp>HALFRANGE)p0-=FULLRANGE; if(dp<-HALFRANGE)p0+=FULLRANGE;pp0=p0*(-t)+p1*(t+1);dp=p1-p2;if(dp>HALFRANGE)p1-=FULLRANGE; if(dp<-HALFRANGE)p1+=FULLRANGE;pp1=p1*(1-t)+p2*t;dp=p2-p3;if(dp>HALFRANGE)p2-=FULLRANGE; if(dp<-HALFRANGE)p2+=FULLRANGE;pp2=p2*(2-t)+p3*(t-1);/*get the numbers back into range*/while(pp0>MAXRANGE)pp0-=FULLRANGE;while(pp0<MINRANGE)pp0+=FULLRANGE;while(pp1>MAXRANGE)pp1-=FULLRANGE;while(pp1<MINRANGE)pp1+=FULLRANGE;while(pp2>MAXRANGE)pp2-=FULLRANGE;while(pp2<MINRANGE)pp2+=FULLRANGE;dp=pp0-pp1;if(dp>HALFRANGE)pp0-=FULLRANGE; if(dp<-HALFRANGE)pp0+=FULLRANGE;p0=pp0*(1-t)+pp1*(t+1);p0/=2;dp=pp1-pp2;if(dp>HALFRANGE)pp1-=FULLRANGE; if(dp<-HALFRANGE)pp1+=FULLRANGE;p1=pp1*(2-t)+pp2*t;p1/=2;/*get the numbers back into range*/while(p0>MAXRANGE)p0-=FULLRANGE;while(p0<MINRANGE)p0+=FULLRANGE;while(p1>MAXRANGE)p1-=FULLRANGE;while(p1<MINRANGE)p1+=FULLRANGE;dp=p0-p1;if(dp>HALFRANGE)p0-=FULLRANGE; if(dp<-HALFRANGE)p0+=FULLRANGE;return (p0*(1-t)+p1*t);}double SegDistance(Point3DFFixed p1,Angle3DFFixed a1,Point3DFFixed p2,Angle3DFFixed a2){double rval,dx,dy,dz,ar,ap,ay,dp;double ar1,ap1,ay1,ar2,ap2,ay2;/*lets do the simple one first!*/dx=FixedToDbl(p1.x)-FixedToDbl(p2.x);dy=FixedToDbl(p1.y)-FixedToDbl(p2.y);dz=FixedToDbl(p1.z)-FixedToDbl(p2.z);/*now it gets a bit more complex because we want the angular distance, the short way  around*/ar1=FixedToDbl(a1.roll); ap1=FixedToDbl(a1.pitch); ay1=FixedToDbl(a1.yaw);ar2=FixedToDbl(a2.roll); ap2=FixedToDbl(a2.pitch); ay2=FixedToDbl(a2.yaw);while(ar1>MAXRANGE)ar1-=FULLRANGE; while(ar1<MINRANGE)ar1+=FULLRANGE;while(ap1>MAXRANGE)ap1-=FULLRANGE; while(ap1<MINRANGE)ap1+=FULLRANGE;while(ay1>MAXRANGE)ay1-=FULLRANGE; while(ay1<MINRANGE)ay1+=FULLRANGE;while(ar2>MAXRANGE)ar2-=FULLRANGE; while(ar2<MINRANGE)ar2+=FULLRANGE;while(ap2>MAXRANGE)ap2-=FULLRANGE; while(ap2<MINRANGE)ap2+=FULLRANGE;while(ay2>MAXRANGE)ay2-=FULLRANGE; while(ay2<MINRANGE)ay2+=FULLRANGE;ar=ar1-ar2;if(ar>HALFRANGE)ar-=FULLRANGE;if(ar<-HALFRANGE)ar+=FULLRANGE;ar*=ANGLETOLENGTH;ap=ap1-ap2;if(ap>HALFRANGE)ap-=FULLRANGE;if(ap<-HALFRANGE)ap+=FULLRANGE;ap*=ANGLETOLENGTH;ay=ay1-ay2;if(ay>HALFRANGE)ay-=FULLRANGE;if(ay<-HALFRANGE)ay+=FULLRANGE;ay*=ANGLETOLENGTH;rval=dx*dx + dy*dy + dz*dz + ar*ar + ap*ap + ay*ay;return sqrt(rval);}