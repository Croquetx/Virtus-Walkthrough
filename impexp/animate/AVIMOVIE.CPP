/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	John C. Alspaugh * * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  * Platform: 	 *				WINDOWS		 *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VIO.h"#include "VPane.h"#include "VGraphic.h"#include "VArray.h"#include "VDialog.h"#include "VGUtil.h"#include "VMemutil.h"#include "Clip.h"#include "AppDeflt.h"#include "AppText.h"#include "View.h"#include "observer.h"#include "ImgHandl.h"#include "BMPHandl.h"#if WINDOWS && V_AVI#include "mmsystem.h"#include "avifile.h"#include "compddk.h"#include "compman.h"#endif#include "AVIMovie.h"#include <stdio.h>#define ELVIS	10		// hack//#define DEBUG	1// these must go elsewhere	// PRO-JAP moved some stringsvoidV_AVIFile::cAVIFile(int q,long tp,long crt,strPtr filts,strPtr qstr){	cFile(q,tp,crt,filts,qstr);	err = 0;}voidV_AVIFile::dAVIFile(void){	dFile();}intV_AVIFile::Open(int dummyFlag){#if WINDOWS && V_AVI	string	fullPath[256];	ULong	openFlags;	HRESULT	aviErr;#if DEBUG	if(openFlag)AlertMessage((strPtr)"This file is already open!");#endif	ObjLock(this);	if (strlen(fileExt))		sprintf(fullPath, "%s%s.%s", path, filname, fileExt);    else		sprintf(fullPath, "%s%s", path, filname);	if (direction == DATA_OUT) 	openFlags = OF_WRITE | OF_CREATE;	else openFlags = OF_READ;	AVIFileInit();	aviErr = AVIFileOpen(&aviFilePtr, fullPath, openFlags, NULL); // NULL is the handler.  Not used	if (aviErr != AVIERR_OK)		{		AlertMessage(AVI_ERROR_OPENING_FILE);		err = -1;        }	if(!err)		{		position=0;		openFlag = TRUE;		}	ObjUnlock(this);#endif	return(err);}intV_AVIFile::Close(void){#if WINDOWS && V_AVI	used=TRUE;    openFlag = FALSE;	ObjLock(this);	if (!err)		err = AVIFileClose(aviFilePtr);	AVIFileExit();	ObjUnlock(this);#endif	return(err);}intAVIMovie::cWalkMovie(TranslatorPreference *transPref, V_Buffer *buffer){#if WINDOWS && V_AVI	movieBuffer = NULL;	aviFilePtr = (V_AVIFile*)buffer;   // this had better be an V_AVIFile...	compression = BI_RGB; 	// something from transPref	depth = 8;				// something from transPref	framesPerSecond = transPref->frameRate;	keyFrame = 7;	// something from transPref	if ((transPref->AVICompressorQuality < 0) || (transPref->AVICompressorQuality > 10000))    	comprQuality = 10000;	// no quality, so set it real high.	else		comprQuality = transPref->AVICompressorQuality;	compressorCodec = transPref->AVICompressorId; 	if (framesPerSecond <= 0)   /* frames per sec must be > 0 */		{		AlertMessage(WrongFrameRate);		err = -1;		return(-1);		}	streamId = 0;	vidStream = NULL;	comprVidStream = NULL;    frameSize = 0;	err = 0;#else	err = -1;#endif	return(err);}voidAVIMovie::dWalkMovie(){#if WINDOWS && V_AVI	if (frame)	frame->dOffscreen();	if (vidStream)	AVIStreamClose(vidStream);	if (comprVidStream)	AVIStreamClose(comprVidStream);	frame = NULL;	vidStream = NULL;	comprVidStream = NULL;#endif	delete(this);}intAVIMovie::BeginMovie(Rect *rect, long bitDepth, long frames){#if WINDOWS && V_AVI	Rect   nRect;    int offDepth;	if (err) 	return(err);	r = *rect;	nRect = *rect;// ideally....	depth = bitDepth;   // jca VR1.0.1 23AUG let depth be this, which is from the prefs	depth = 8;   // jca PRO 18OCT94 safer this way.#if MACINTOSH	offDepth = depth;#else	offDepth = -1;      // bug in newtext8:  depth must be -1#endif // MACINTOSH	nFrames = frames;	/* allocate frame */	frame = new(V_Offscreen);	if (frame->cOffscreen(&nRect, offDepth, NULL, NULL))		{		err = -1;		frame->dOffscreen();        frame = NULL;		}	if (!err)		{		LPBITMAPINFO	lpbmi;        LPBITMAPINFOHEADER lpbmiHeader;		ULong	bmpAllocSize;        int 	nColors;		if (depth <= 8)			nColors = 1<<depth;		else			nColors = 0;		frameSize = (nRect.bottom - nRect.top) * (LWORD_ALIGN((Long)depth * (nRect.right - nRect.left)));		bmpAllocSize = frameSize + sizeof(BITMAPINFOHEADER) + nColors * sizeof(RGBQUAD);		BMPHandle = NewHandle(bmpAllocSize);		if (!BMPHandle)			err = -1;		else			{			// init the header stuff         	HLock(BMPHandle);			lpbmi = (LPBITMAPINFO) HDeref(BMPHandle);			lpbmiHeader = &(lpbmi->bmiHeader);			memset(lpbmiHeader, 0, sizeof(BITMAPINFOHEADER));			// set the six important parameters			lpbmiHeader->biSize = sizeof(BITMAPINFOHEADER);			lpbmiHeader->biBitCount = depth;			lpbmiHeader->biHeight = nRect.bottom - nRect.top;			lpbmiHeader->biWidth = nRect.right - nRect.left;			lpbmiHeader->biPlanes = 1;			lpbmiHeader->biCompression = BI_RGB;         	HUnlock(BMPHandle);        	}		}#endif	return(err);}intAVIMovie::AnimateMovie(struct V_Pane *window, struct Observer *eye){	char	str[256];	long 	location, val;#if WINDOWS && V_AVI	if (err)	return(err);	/* meter */	sprintf(str,NFramesRemaining,nFrames);	MeterSetCountTitle(str);	eye->SetFrame(0);	window->VOutput(frame);	MakeVideoStream();  	// init the video stream (after we draw one frame)	MeterSetCount(frameCount);      /* handle the meter */	MeterUpdate(0);	/* we've already rendered the first frame, so go ahead and    write it out */	err = err?err:WriteMovieFrame((V_Offscreen *) frame);	for (frameCount = 1; (!err) && frameCount < nFrames; frameCount++)		{		sprintf(str,NFramesRemaining,nFrames-frameCount);		MeterSetCountTitle(str);		eye->SetFrame(frameCount);		err = err ? err : window->VOutput(frame);		err = err ? err : WriteMovieFrame(frame);		MeterSetCount(frameCount);      /* handle the meter */		err = err ? err : MeterUpdate(0);		}	sprintf(str,NFramesRemaining,0L);	MeterSetCountTitle(str);	MeterSetCount(frameCount);      /* handle the meter */	MeterUpdate(0);    CloseVideoStream();#endif	return(err);}intAVIMovie::WriteMovieFrame(V_Offscreen *newFrame){#if WINDOWS && V_AVI	HRESULT aviErr;        // this is a void *.  Weird	LPBITMAPINFO	lpbmi;	LPBITMAPINFOHEADER	lpbmiHeader;    HBITMAP	tempBits;    Rect	someRect;    HDC		hDevCon;	void	*theData;	ULong	offset, aviFlags, linesConverted;	if (err)	return(err);	// set the flags	if ((frameCount % keyFrame) == 0)		aviFlags = AVIIF_KEYFRAME;	else		aviFlags = 0;    // get a pointer to the data	HLock(BMPHandle);	theData = (void *)HDeref(BMPHandle);	lpbmi = (LPBITMAPINFO) theData;	lpbmiHeader = &(lpbmi->bmiHeader);	hDevCon = frame->GetMetaPort(&someRect);	// calculate the offset from the start of the structure to the bits	offset = lpbmiHeader->biSize;	if (lpbmiHeader->biClrUsed == 0)   // if we're using the max num colors		{    // figure out how many colors that really should be		if (lpbmiHeader->biBitCount <= 8)			offset += (1<<(lpbmiHeader->biBitCount)) * sizeof(RGBQUAD);		//otherwise, no table		}	else     // otherwise, use the obvious number of colors		offset += lpbmiHeader->biClrUsed * sizeof(RGBQUAD);	// set theData to point to the bits, that is, the bmap pointer + the offset for the header	theData = (void *)((ULong)theData + offset);	//okay, now convert the offscreen to a DIB	frame->SetMetaPort();	// We're not supposed to have the bitmap selected	//when we do SetDIBits calls, so let's unselect it.	tempBits = SelectObject(hDevCon, frame->oldBitmap);//JAM ALTERED TO COMPILE--CORRECT?//	ASSERT(tempBits == screen->bitmap);	ASSERT(tempBits == frame->bitmap);	linesConverted = GetDIBits(hDevCon, tempBits, 0,		lpbmiHeader->biHeight, theData, lpbmi, DIB_RGB_COLORS);	SelectObject(hDevCon, tempBits);	frame->UnsetMetaPort();	if (linesConverted <= 0)     // be less picky for bad drivers jca 25AUG94		{        AlertMessage(AVI_DIBITS_ERROR);		err = -1;	// this should give a warning, what?        }	aviErr = AVIStreamWrite(theStream, frameCount,		1, theData, frameSize, aviFlags, NULL, NULL);	if (aviErr != AVIERR_OK)		{		ReportAVIError((ULong)aviErr);		err = -1;        }	HUnlock(BMPHandle);	frame->ReleaseMetaPort(hDevCon);#endif	return(err);}intAVIMovie::EndMovie(){#if WINDOWS && V_AVI	if (frame)		{		frame->dOffscreen();		frame = NULL;		}	if (BMPHandle)		{		DisposHandle(BMPHandle);      BMPHandle = NULL;      }#endif	return(err);}intAVIMovie::MakeVideoStream(void){#if WINDOWS && V_AVI	AVISTREAMINFO	strInfo;	// this is a streamHeader	ULong			bSize;	HRESULT aviErr;	if (err) 	return(err);	bSize = (r.bottom - r.top);    bSize *= (r.right - r.left);	// fill in the stream info (it used to be the old streamHeader stuff)	memset(&strInfo, 0, sizeof(strInfo));	strInfo.fccType 	= streamtypeVIDEO;	strInfo.fccHandler 	= 0;	strInfo.dwScale 	= 1;	strInfo.dwRate 		= framesPerSecond;	strInfo.dwSuggestedBufferSize = ((unsigned long)depth*bSize + 7L)/8L;	SetRect(&strInfo.rcFrame, 0, 0, (r.right-r.left), (r.bottom-r.top));	if (!err)    	{		aviErr = AVIFileCreateStream(aviFilePtr->aviFilePtr, &vidStream, &strInfo);		if (aviErr != AVIERR_OK)			{			ReportAVIError((ULong)aviErr);			err = -1;			vidStream = NULL;			}      }	if (!err)   	{	 	if (compressorCodec != NO_AVI_COMPRESSOR)   // this is my constant...I'm so proud.			{  // do the compression things			AVICOMPRESSOPTIONS	aviCompressOpts;			memset(&aviCompressOpts, 0, sizeof(aviCompressOpts));			aviCompressOpts.dwFlags = AVICOMPRESSF_VALID;			aviCompressOpts.fccType = streamtypeVIDEO;			aviCompressOpts.fccHandler = compressorCodec;			aviCompressOpts.dwQuality = comprQuality;			aviCompressOpts.dwKeyFrameEvery = keyFrame;			aviErr = AVIMakeCompressedStream(&comprVidStream, vidStream, &aviCompressOpts, NULL);			if (aviErr != AVIERR_OK)    			{				ReportAVIError((ULong)aviErr);				err = -1;				AVIStreamClose(vidStream);				vidStream = NULL;				}			else         	theStream = comprVidStream;			}		else   // no compression			{			theStream = vidStream;			comprVidStream = NULL;			}      }	if (!err)		{		LPBITMAPINFO	bmapInfo;		Rect 			someRect;		ULong  			headerSize, offset;		HDC				hDevCon;		int				nColorsUsed;		HBITMAP			tempBits;		void 			*theData;		// get the bitmap header stuff		HLock(BMPHandle);		bmapInfo = (LPBITMAPINFO) HDeref(BMPHandle);		hDevCon = frame->GetMetaPort(&someRect);		frame->SetMetaPort();		// We're not supposed to have the bitmap selected		//when we do SetDIBits calls, so let's unselect it.//JAM ALTERED TO COMPILE--CORRECT?//		tempBits = SelectObject(hDevCon, screen->oldBitmap);//		ASSERT(tempBits == screen->bitmap);		tempBits = SelectObject(hDevCon, frame->oldBitmap);		ASSERT(tempBits == frame->bitmap);		/* JCA 25AUG94 for bad matrox drivers (they don't deal with a NULL        buffer parameter) */		theData = bmapInfo;    // data will be the bitmap area		offset = bmapInfo->bmiHeader.biSize;     // it is offset by the size of the header		if (bmapInfo->bmiHeader.biBitCount <= 8)     // plus the max size of the colortable, if it exists			offset += (1<<(bmapInfo->bmiHeader.biBitCount)) * sizeof(RGBQUAD);		// set theData to point to the bits, that is, the bmap pointer + the offset for the header		theData = (void *)((ULong)theData + offset);		GetDIBits(hDevCon, tempBits, 0,			bmapInfo->bmiHeader.biHeight, theData, bmapInfo, DIB_RGB_COLORS);		SelectObject(hDevCon, tempBits);		HUnlock(BMPHandle);		frame->UnsetMetaPort();		frame->ReleaseMetaPort(hDevCon);		if (bmapInfo->bmiHeader.biBitCount <= 8)			nColorsUsed = 1 << (bmapInfo->bmiHeader.biBitCount);		else         nColorsUsed = 0;		headerSize = bmapInfo->bmiHeader.biSize + nColorsUsed * sizeof(RGBQUAD);		aviErr = AVIStreamSetFormat(theStream, 0/*streamId?*/,			&(bmapInfo->bmiHeader), headerSize);		HUnlock(BMPHandle);		if (aviErr != AVIERR_OK)			{			err = -1;			ReportAVIError((ULong)aviErr);			if (vidStream)			AVIStreamClose(vidStream);			if (comprVidStream)	AVIStreamClose(comprVidStream);         	comprVidStream = NULL;			vidStream = NULL;			}		}#endif	return(err);}intAVIMovie::CloseVideoStream(void){#if WINDOWS && V_AVI// even if there's an error, we should still clean upif (comprVidStream)		AVIStreamClose(comprVidStream);if (vidStream)				AVIStreamClose(vidStream);vidStream = NULL;comprVidStream = NULL;#endifreturn(err);}intAVIMovie::ReportAVIError(ULong code){	int	known = TRUE;#if WINDOWS && V_AVI   // find the right string, and print it.	switch(code)		{      	case AVIERR_OK:			/* how did this get here? */		break;		case AVIERR_READONLY:	AlertMessage(V_AVIERR_READONLY);	break;		case AVIERR_MEMORY:			if (compressorCodec != NO_AVI_COMPRESSOR)	AlertMessage(V_AVIERR_MEMORY_COMPR);			else										AlertMessage(V_AVIERR_MEMORY);            break;			break;		default:        	known = HandleAVISpecialErrorCases(code);			break;		}#endif // WINDOWS && V_AVI   return(known);}// handle the special cases:  things which may go wrong, but aren't// a problem, debug cases, etc.intAVIMovie::HandleAVISpecialErrorCases(ULong spCode){	int	known = TRUE;#if WINDOWS && V_AVI   // find the right string, and print it.	switch(spCode)    	{#if DEBUG		case AVIERR_UNSUPPORTED:	AlertMessage("AVIERR_UNSUPPORTED"); 	break;		case AVIERR_BADFORMAT:		AlertMessage("AVIERR_BADFORMAT");		break;		case AVIERR_INTERNAL:		AlertMessage("AVIERR_INTERNAL");		break;		case AVIERR_BADFLAGS:		AlertMessage("AVIERR_BADFLAGS");		break;		case AVIERR_BADPARAM:		AlertMessage("AVIERR_BADPARAM");		break;		case AVIERR_BADSIZE:		AlertMessage("AVIERR_BADSIZE");			break;		case AVIERR_BADHANDLE:		AlertMessage("AVIERR_BADHANDLE");		break;		case AVIERR_FILEREAD:		AlertMessage("AVIERR_FILEREAD");		break;		case AVIERR_FILEOPEN:		AlertMessage("AVIERR_FILEOPEN");		break;		case AVIERR_COMPRESSOR:		AlertMessage("AVIERR_COMPRESSOR");		break;		case AVIERR_NOCOMPRESSOR:	AlertMessage("AVIERR_NOCOMPRESSOR");	break;		case AVIERR_NODATA:			AlertMessage("AVIERR_NODATA");			break;		case AVIERR_BUFFERTOOSMALL:	AlertMessage("AVIERR_BUFFERTOOSMALL");	break;		case AVIERR_CANTCOMPRESS:	AlertMessage("AVIERR_CANTCOMPRESS");	break;		case AVIERR_USERABORT:		AlertMessage("AVIERR_USERABORT");		break;		case AVIERR_ERROR:			AlertMessage("AVIERR_ERROR");			break;		default:			AlertMessage(V_AVIERR_UNKNOWN);			known = FALSE;            break;#else		case AVIERR_UNSUPPORTED:		case AVIERR_BADFORMAT:		case AVIERR_INTERNAL:		case AVIERR_BADFLAGS:		case AVIERR_BADPARAM:		case AVIERR_BADSIZE:		case AVIERR_BADHANDLE:		case AVIERR_FILEREAD:		case AVIERR_FILEOPEN:		case AVIERR_COMPRESSOR:		case AVIERR_NOCOMPRESSOR:		case AVIERR_NODATA:		case AVIERR_BUFFERTOOSMALL:		case AVIERR_CANTCOMPRESS:		case AVIERR_USERABORT:		case AVIERR_ERROR:			AlertMessage(V_AVIERR_UNKNOWN);			known = FALSE;			break;		default:			AlertMessage(V_AVIERR_UNKNOWN);			known = FALSE;			break;#endif // DEBUG		}#endif // WINDOWS && V_AVI    return(known);}// what are the compression codecs available to us?intFindCodecs(V_Array *list, ULong compressorType){#if WINDOWS && V_AVI	ICINFO				comprInfo;   	HIC					hic;	// handle to compressor	AVICompressorCodec	aviCC;	int 				i;	list->SetLength(0);	memset(&comprInfo, 0, sizeof(comprInfo));	comprInfo.dwSize = sizeof(comprInfo);	for (i = 0; ICInfo(compressorType, i, &comprInfo); i++)		{		hic = ICOpen(comprInfo.fccType, comprInfo.fccHandler, ICMODE_QUERY);		if (hic)			{			ICGetInfo(hic, &comprInfo, sizeof(comprInfo));         	ICClose(hic);			aviCC.ic = comprInfo;			aviCC.works = TRUE;		// assume everything works			list->Append(&aviCC);			}		// else no such compressor.  Whoops!		}	return(list->ALength());#else	return(0);#endif // WINDOWS && V_AVI}intCanCodecsCompressVideo(V_Array *list, Rect *rect, int depth){#if WINDOWS && V_AVI	ICINFO				comprInfo;	AVICompressorCodec	*aviCC;   	Handle				bmapHeaderH;	LPBITMAPINFO		bmapHeader;   	HIC					hic;	// handle to compressor	int 				i, size, lastState, areThereChanges = FALSE;	// init the bmapinfo with representative data   	size = sizeof(BITMAPINFOHEADER);	switch (depth)		{		case 1:		case 4:		case 8:			size += (1<<depth)* sizeof(RGBQUAD);	break;		case 16:		case 24:		case 32:		default:			break;    // size += 0;		}	bmapHeaderH = NewHandle(size);	if (!bmapHeader)		return -1;	else		{      HLock(bmapHeaderH);      bmapHeader = (LPBITMAPINFO) HDeref(bmapHeaderH);		memset(bmapHeader, 0, size);		bmapHeader->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);		bmapHeader->bmiHeader.biWidth = rect->right - rect->left;		bmapHeader->bmiHeader.biHeight = rect->bottom - rect->top;		bmapHeader->bmiHeader.biPlanes = 1;		bmapHeader->bmiHeader.biBitCount = depth;		bmapHeader->bmiHeader.biCompression = BI_RGB;		}	// for each codec...	aviCC = (AVICompressorCodec *) list->Use();	for (i = 0; i < list->ALength(); i++)		{		// ...get a handle to the codec for testing...      	hic = ICOpen(aviCC[i].ic.fccType, aviCC[i].ic.fccHandler, ICMODE_QUERY);		if (hic && aviCC[i].ic.fccType == ICTYPE_VIDEO)  			{  	// ...if we can get the compressor...			// .. save the last state			lastState = aviCC[i].works;			// ...test for writing...			if (ICCompressQuery(hic, bmapHeader, NULL) == ICERR_OK)				aviCC[i].works = TRUE;   			// ...record the result			else				aviCC[i].works = FALSE;  			// ...record the result            // if the lastState != the current one, things have changed.			if (lastState != aviCC[i].works)            	areThereChanges = TRUE;			}		else   // ...if we can't get the compressor...			{			// ...record the result (this is really bad)			aviCC[i].works = FALSE;            areThereChanges = TRUE;	// set this since things are weird.			}		if (hic)			ICClose(hic);		// close the compressor		}	list->Unuse();	if (bmapHeader)		{		HUnlock(bmapHeaderH);      	DisposHandle(bmapHeaderH);		}	return(areThereChanges);#else	return(0);#endif// WINDOWS && V_AVI}longFindCodecFromType(V_Array *list, ULong which){#if WINDOWS && V_AVI	AVICompressorCodec	*aviCC;   	long				whichOne;	int 				i, ok;	whichOne = -1;	aviCC = (AVICompressorCodec *) list->Use();	for (i = 0, ok = 0; i < list->ALength() && !ok; i++)		{		if (which == aviCC[i].ic.fccHandler)      	whichOne = i;    	}	list->Unuse();	return(whichOne);#else	return(-1);#endif// WINDOWS && V_AVI}intGetRecommendedQuality(AVICompressorCodec *aviCC){#if WINDOWS && V_AVI	ICINFO	comprInfo;	HIC		hic;	// handle to compressor	ULong	qual;	int		defQuality = -1;	memset(&comprInfo, 0, sizeof(comprInfo));	comprInfo.dwSize = sizeof(comprInfo);	// ...get a handle to the codec for testing...    hic = ICOpen(aviCC->ic.fccType, aviCC->ic.fccHandler, ICMODE_QUERY);	if (hic && aviCC->ic.fccType == ICTYPE_VIDEO)  		{  	// ...if we can get the compressor...		ICGetInfo(hic, &comprInfo, sizeof(comprInfo));		if (comprInfo.dwFlags & VIDCF_QUALITY)			{			LRESULT result;            result = ICSendMessage(hic, ICM_GETDEFAULTQUALITY,((DWORD)(&qual)), 0L); 			if (result == ICERR_OK)				defQuality = (int) qual;            // else, the driver doesn't support quality, even though it claims to.			}        // else, this driver doesn't support quality.  Sad but true.		}	if (hic)	ICClose(hic);    return(defQuality);#else	return(-1);#endif // WINDOWS && V_AVI}