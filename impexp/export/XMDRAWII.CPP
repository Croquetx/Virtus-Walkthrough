/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				David W. Easter *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "XMDrawII.h"#include "Polyhdrn.h"#include "WalkBuff.h"#include "VIO.h"#include "VArray.h"#include "VFile.h"#include "VGraphic.h"#include "VMath.h"#if VWTvoidExport_MacDrawII::cExport()	{	ModelExport::cExport();	x2d = NULL;	fill = fillObject;	frame = frameBlack;	layerCount = 0;	polyPoints = NULL;	polyLayer = 0;	surfVisible = FALSE;	}voidExport_MacDrawII::Options(ClarisFill fl, ClarisFrame frm, Point3DFFixed v)	{	fill = fl;	frame = frm;	SetView(v);	}intExport_MacDrawII::Open(V_Buffer *buffer, ExportUnit type, double size)	{	short mdUnit;	ModelExport::Open(buffer, type, size);#if MACINTOSH	x2d = OpenX2D(md2, (color_mode)0);#endif //MACINTOSH	switch (type)		{		case exportInch:		case exportFoot:		case exportYard:		case exportMile:			mdUnit = RULER_INCH;			break;		case exportMillimeter:		case exportCentimeter:		case exportMeter:		case exportKilometer:			mdUnit = RULER_CM;			break;		default:			mdUnit = RULER_INCH;			break;		}	/* X2DRuler(&mdUnit, &size); -- ruler calls don't work yet */	return(0);	}intExport_MacDrawII::Close()	{	long resType, size;	int resID;	void *data;	char *handlePtr;	V_File *file = (V_File *)buffer;#if MACINTOSH	X2DEnd(x2d);	while (X2DGetData(x2d, &data, &size))		buffer->IOData(data, size);	file->OpenResource(FALSE);	while (X2DGetRsrc(x2d, &resType, &resID, &size, &data))		{		Handle handle;		if (resType == 'vers')			continue;		handle = NewHandle(size);		HLock(handle);		handlePtr = (char *)HDeref(handle);		if (size > 0) BlockMove(data, handlePtr, size);		HUnlock(handle);		file->IOResource(&handle, resType, resID, NULL);		DisposHandle((Handle)handle);		}	file->CloseResource();	CloseX2D(x2d);	DisposX2D(x2d);	x2d = NULL;#endif //MACINTOSH	ModelExport::Close();	return(0);	}intExport_MacDrawII::Layers(V_Array *layers)	{	Layer *layer;	int i;	layerCount = layers->ALength();#if MACINTOSH	X2DInitLayers(x2d, layerCount);	layer = (Layer *)layers->Use();	layer += layerCount;	for (i = layerCount; i > 0; i--)		{		layer--;		X2DLayerData(x2d, layer->name, &layer->color);		}	layers->Unuse();	X2DEndLayers(x2d);#endif //MACINTOSH	return(0);	}intExport_MacDrawII::OpenPolyhedron(V_Array *points, RGBAColor color, int layer)	{	polyPoints = new(V_Array);	polyPoints->cArray(0, sizeof(PointFFixed), 4);	TransformPoints(points, polyPoints);	polyLayer = (layerCount-1) - layer;	return(0);	}intExport_MacDrawII::ClosePolyhedron()	{	polyPoints->dArray();	return(ModelExport::ClosePolyhedron());	}intExport_MacDrawII::OpenSurface(V_Array *pointRefs, RGBAColor color, Point3DFFixed normal)	{#if MACINTOSH	V_Array *surfPoints;	X2DPBRec pb;	RGBColor clr;	surfVisible = Visible(normal);	if (!surfVisible) return(-1);	surfPoints = new(V_Array);	surfPoints->cArray(0, sizeof(PointFFixed), 4);	DerefPoints(polyPoints, pointRefs, surfPoints);	pb.layerIndex = polyLayer;	pb.bits = (fill == fillNone ? 0 : 1); /* bit 0 == fill flag */	clr.red = color.red;	clr.green = color.green;	clr.blue = color.blue;	pb.edgeColor = (frame == frameObject ? clr : vBlack);	pb.fillColor = (fill == fillObject ? clr : vWhite);	pb.nrPoints = surfPoints->ALength();	pb.thePoints = (PointFFixed*)surfPoints->Use();	X2DPolygon(x2d, &pb);	surfPoints->Unuse();	surfPoints->dArray();#endif //MACINTOSH	return(0);	}intExport_MacDrawII::OpenFeature(V_Array *points, RGBAColor color, int where, int connected)	{#if MACINTOSH	V_Array *featPoints;	X2DPBRec pb;	RGBColor clr;	if (!surfVisible || connected) return(-1);	featPoints = new(V_Array);	featPoints->cArray(0, sizeof(PointFFixed), 4);	TransformPoints(points, featPoints);	pb.layerIndex = polyLayer;	pb.bits = (fill == fillNone ? 0 : 1); /* bit 0 == fill flag */	clr.red = color.red;	clr.green = color.green;	clr.blue = color.blue;	pb.edgeColor = (frame == frameObject ? clr : vBlack);	pb.fillColor = (fill == fillObject ? clr : vWhite);	pb.nrPoints = featPoints->ALength();	pb.thePoints = (PointFFixed*)featPoints->Use();	X2DPolygon(x2d, &pb);	featPoints->Unuse();	featPoints->dArray(); #endif //MACINTOSH	return(0);	}voidExport_MacDrawII::Transform(void *in, void *out)	{	Point3DFFixed *pIn = (Point3DFFixed *)in, tmp;	PointFFixed *pOut = (PointFFixed*)out;	tmp = Translate(*pIn);	pOut->h = tmp.x;	pOut->v = tmp.y;	}intExport_MacDrawII::SortPolyhedra()	{	return(TRUE);	}intExport_MacDrawII::ComparePoly(Polyhedron *a, Polyhedron *b)	{	Point3DFFixed pntA, pntB;	pntA = Pt3DFFZero;	pntA.x.intg = a->posnBoundMin.x;	pntA.y.intg = a->posnBoundMin.y;	pntA.z.intg = a->posnBoundMin.z;	pntA = Translate(pntA);	pntB = Pt3DFFZero;	pntB.x.intg = b->posnBoundMin.x;	pntB.y.intg = b->posnBoundMin.y;	pntB.z.intg = b->posnBoundMin.z;	pntB = Translate(pntB);	return(FFLogic(pntA.z, pntB.z));	}#endif // VWT