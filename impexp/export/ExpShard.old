/*------------------------------------------------------------------------------ * Copyright _ 1995 by Virtus Corporation * All Rights Reserved * Written by  David A. Smith * Virtus Corporation * 118 MacKenan Drive, Suite 250 * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File: ExpShard.CPP * Notes: This file is used to export a WalkThrough database out in multiple formats. *  It is a base class and must be derived to be useful. See ExpVRML.CPP for more info. * 	It is based upon a divide and conquer strategy. A hole is cut into a surface in *  the following way: *  1. Clip the hole to the surface. After this, we have two convex polygons, one *     inside the other. *  2. Create a non-convex polygon by finding an edge between the two polygons that *     acts as a starting point. The top point of each is sufficient. Connecting these *     two points creates a non-convex polygon. *  3. Cut the non-convex polygon into a set of convex pieces. This is done by creating the *     largest convex polygons by incrementing each point along the edges until it is no  *     convex. *  4. Repeat for the next hole, now applying it to each of the new convex surfaces. * * When we create the non-convex polygon, it is made up of a set of polygon points and * of the surface feature points. The polygon points are referred to by a positive value * greater than 0 (1 + the true index value). The surface points are referred to by a * negative value less than 0 (the negative of the true index value -1). The new polygons * generated are then made up of collections of positive and negative indices. * History: Created July, 1995 *------------------------------------------------------------------------------ * Things to do: * *		Dialog box: *			Buttons: *				Save File *				Upload File *				Cancel *			Check Boxes: *				Two sided polygons *			Texture Radio Buttons: *				JPEG *				GIF *			Text Boxes: *				Feature Offset z-value		 *				 *		Add camera position. *		Add focal length. *		Add texture indices. *		Add texture exports.  *    PRO25 == ABD added stuff marked with PRO25 *  Created DAS 95.09.28 *------------------------------------------------------------------------------ */#include "ExpShard.h"//#define TINY_NUMBER 0.0000000000001#define TINY_NUMBER 0.00000001#define DXP  1#define DXN -1#define DYP  2#define DYN -2#define DZP  3#define DZN -3#define COUNTERCLOCKWISE	0#define CLOCKWISE			1#define LINEAR				2#define UNKNOWN				3P3D Normalize(P3D p3d);P3D Normalize(P3D p3d)	{	double d;	d=sqrt(p3d.x*p3d.x+p3d.y*p3d.y+p3d.z*p3d.z);	p3d.x/=d;	p3d.y/=d;	p3d.z/=d;	return p3d;	}// ABD-VRML4 [[[#if THINK_Cdouble dabs(double d);double dabs(double d){ return d<0?-d:d;}double dmax(double d1, double d2);double dmax(double d1, double d2){return d1<d2?d2:d1;}int next(int cval, int lval);int next(int cval, int lval){cval++; if(cval==lval)cval=0; return cval;}int previous(int cval, int lval);int previous(int cval, int lval){cval--;if(cval==-1)cval=lval-1; return cval;}P3D Export_Shard::GetPoint(int index)	{	P3D p3d; 	if(index>0)polyPoints->Get(index-1,&p3d);	else surfPoints->Get(-(index+1),&p3d);	return p3d;	}void Export_Shard::PutPoint(int index, P3D p3d)	{	if(index>0)polyPoints->Put(index-1,&p3d);	else surfPoints->Put(-(index+1),&p3d);	}#elseinline double dabs(double d){ return d<0?-d:d;}inline double dmax(double d1, double d2){return d1<d2?d2:d1;}	inline int next(int cval, int lval){cval++; if(cval==lval)cval=0; return cval;}inline int previous(int cval, int lval){cval--;if(cval==-1)cval=lval-1; return cval;}#endif// ABD-VRML4 ]]]int 	Export_Shard::ExportOpen(struct V_Buffer *b, ExportUnit e, double d){return 0;}int 	Export_Shard::ExportClose(void){return 0;}int 	Export_Shard::ExportLevel(void){return 0; }int 	Export_Shard::ExportGroup(void){return 0;}int 	Export_Shard::ExportPolyhedron(void){return 0;}int 	Export_Shard::ExportSurface(void){return 0;}int 	Export_Shard::ExportFeature(void){return 0;}voidExport_Shard::cExport()	{	ModelExport::cExport();	polyPoints = NULL;	polyLayer = 0;	polyColor.red = 0;	polyColor.green = 0;	polyColor.blue = 0;	polyColor.alpha = 0;		zOffset=.1;	/* ... initialize additional object data ... *///	polyhedron = NULL;//	surface = NULL;	}voidExport_Shard::dExport()	{	/* ... clean up before deleting object ... */	ModelExport::dExport();	}intExport_Shard::Open(V_Buffer *buf, ExportUnit type, double size)	{	ModelExport::Open(buf, type, size);	ExportOpen(buf,type,size); // call the derived class setup method	return(0);	}intExport_Shard::Close()	{	/* ... close export channel ... */	ExportClose(); // call the derived class cleanup method	return(ModelExport::Close());	}/* *	Layers() * *	layers -	the layer list for the model (V_Array of type Layer) */intExport_Shard::Layers(V_Array *layers)	{	int nLayers = layers->ALength(), i;	Layer *layer;	layer = (Layer*)layers->Use();	for (i = 0; i < nLayers; i++, layer++)		/* ... do something with layer->name, layer->color, and layer->state ... */ ;	layers->Unuse();	return(0);	}voidExport_Shard::OpenLevel()	{	}voidExport_Shard::CloseLevel()	{	ExportLevel();	}/* *	OpenGroup() * *	layer -		group's layer; index into layer list from Layers() *	name -		group's name; NULL if none; string is not terminated; get length from V_Array *	data -		group's data; NULL if none; get length from V_Array */intExport_Shard::OpenGroup(int layer, V_Array *name, V_Array *data)	{	return(0);	}intExport_Shard::CloseGroup()	{	return(ExportGroup());	}/* *	OpenPolyhedron() * *	points -	polyhedron's points (V_Array of type Point3DFFixed) *	color -		polyhedron's color & opacity *	layer -		polyhedron's layer; index into layer list from Layers() */intExport_Shard::OpenPolyhedron(V_Array *points, RGBAColor color, int layer)	{	int len;		// ABD-VRML4	int i;			// ABD-VRML4	Point3DFFixed* poly;			// ABD-VRML4	// pPoints is a temporary V_Array of Point3DFFixed	V_Array *pPoints = new(V_Array);	pPoints->cArray(0, sizeof(Point3DFFixed), 4);		// polyPoints is a long term V_Array of P3D which is written out	polyPoints = new(V_Array);	polyPoints->cArray(0, sizeof(P3D), 4);		// surfArray is the V_Array of SurfInfo which is written out 	surfArray = new(V_Array);	surfArray->cArray(0, sizeof(SurfInfo),4);		TransformPoints(points, pPoints);	len=pPoints->ALength();		// ABD-VRML4	poly=(Point3DFFixed*)pPoints->Use();		// ABD-VRML4		for( i=0;i<len;i++)	// ABD-VRML4		{		P3D p3d;				p3d.x=FixedToDbl(poly[i].x);		p3d.y=FixedToDbl(poly[i].y);		p3d.z=FixedToDbl(poly[i].z);		polyPoints->Append(&p3d);		}			pPoints->Unuse();	pPoints->dArray();		polyLayer = layer;	polyColor = color;	return(0);	}intExport_Shard::ClosePolyhedron()	{	int i;	int slen=surfArray->ALength();	// PRO25 delete the stuff 		ExportPolyhedron();	for(i=0;i<slen;i++)	{	SurfInfo sInfo;		surfArray->Get(i,&sInfo);		sInfo.surface->dArray();	}		surfArray->dArray();	// PRO25 MOVED THESE DOWN HERE	surfArray=NULL;	polyPoints->dArray();	polyPoints=NULL;	return(0);	}/* *	OpenSurface() * *	pointRefs -	surface's points by reference into polyhedron point list (V_Array of type short) *	color -		surface's color & opacity; usually same as polyhedron color *	normal -	outward pointing normal vector; magnitude == 256 */intExport_Shard::OpenSurface(V_Array *pointRefs, RGBAColor color, Point3DFFixed normal)	{	SurfInfo surfInfo;	double ax, ay, az;		// ABD-VRML4	int i;		// ABD-VRML4	int len;		// ABD-VRML4	short *pRefs;		// ABD-VRML4		surfInfo.surface=surfInfo.surfaces=NULL;	// base surface definition...	surfInfo.sColor=color;		surfInfo.surf = surface;	// PRO25	surfInfo.surfDef = surface->surfDef;	// PRO25	surfInfo.surfFeat = NULL;	surfInfo.surfType = ksurface; // DAS 95.10.04		// ABD FIXED MORONIC BUG HERE!  surfDef instead of surfType!	surfInfo.surfWhere=surfBase;  // DAS 95.10.02		surfNormal.x = FixedToDbl(normal.x);	surfNormal.y = FixedToDbl(normal.y);	surfNormal.z = FixedToDbl(normal.z);	surfNormal=Normalize(surfNormal);	ax=dabs(surfNormal.x);		// ABD-VRML4	ay=dabs(surfNormal.y);		// ABD-VRML4	az=dabs(surfNormal.z);		// ABD-VRML4	if(ax>ay && ax>az)		{if(surfNormal.x>0)sDimension=DXP; else sDimension=DXN;}	else if(ay>ax && ay>az)		{if(surfNormal.y>0)sDimension=DYP; else sDimension=DYN;}	else if(az>ax && az>ay)		{if(surfNormal.z>0)sDimension=DZP; else sDimension=DZN;}	surfInfo.sNormal=surfNormal;	surfInfo.surface = new(V_Array);	surfInfo.surface->cArray(0, sizeof(short), 4);		 len=pointRefs->ALength();	// ABD-VRML4	pRefs= (short*)pointRefs->Use();	// ABD-VRML4	for( i=0;i<len; i++)		{		short index=pRefs[i]+1;		surfInfo.surface->Append(&index);		}	pointRefs->Unuse();	sArray=new(V_Array);	sArray->cArray(0,sizeof(SurfInfo),4);	sArray->Append(&surfInfo);	surfIn= surfOut=0;		surfPoints=new(V_Array);	surfPoints->cArray(0,sizeof(P3D),4);	return(0);	}intExport_Shard::CloseSurface()	{	int i;    SurfInfo surfInfo;		// ABD-VRML4	int len=surfPoints->ALength();		surfIndex=new(V_Array);	surfIndex->cArray(0, sizeof(short), 4);	for(i=0;i<len;i++)		{		short ind=0;		surfIndex->Append(&ind);		}	len=sArray->ALength();			// ABD-VRML4	surfInfo.surface=surfInfo.surfaces=NULL;#if SHOWSURFACE && MACINTOSH	MakeWindow();//XYZZY#endif	for(i=0;i<len;i++)		{		sArray->Get(i,&surfInfo);		AppendSurfInfo(&surfInfo);		}	ExportSurface();	#if SHOWSURFACE && MACINTOSH	KillWindow();//XYZZY#endif	sArray->dArray(); // all sArrays have been appended to surfArray	sArray=NULL;	surfPoints->dArray(); // all surfPoints that were used were appended to polyPoints 	surfPoints=NULL;	surfIndex->dArray(); // surfIndex is no longer necessary	surfIndex=NULL;		return(0);	}/* *	OpenFeature() * *	points -	feature's points (V_Array of type Point3DFFixed) *	color -		feature's color & opacity *	where -		feature placement; SURF_INSIDE, SURF_SHARED, or SURF_OUTSIDE *	connected -	0 if feature is on current polyhedron;  *				1 if on connected outside polyhedron *				2 if on connected inside polyhedron */intExport_Shard::OpenFeature(V_Array *points, RGBAColor color, int where, int connected)	{	int len;		// ABD-VRML4	int i;			// ABD-VRML4Point3DFFixed* fpoly;			// ABD-VRML4	V_Array *featPoints;			// ABD-VRML4	SurfInfo feat,feat2;			// ABD-VRML4int sBase;			// ABD-VRML4	if (connected==1 && color.alpha>=OPAQUE_THRESH) return (0); //not interested unless NOT opaque				// ABD-VRML4	if(points->ALength()<=2)return (0); // no surface	 sBase=surfPoints->ALength();			// ABD-VRML4		feat.sColor=color;//	feat.sColor.red=feature->outsideShade.red;//	feat.sColor.green=feature->outsideShade.green;//	feat.sColor.blue=feature->outsideShade.blue;	feat.sNormal=surfNormal; // same normal as the current surface		feat.surface=new(V_Array);	feat.surface->cArray(0,sizeof(short),4);	feat.surfaces=NULL;	feat.surfFeat=feature; // DAS 95.10.04 	feat.surfDef = NULL;	feat.surf = NULL;		// ABD PRO25	feat.surfType=kfeature; // DAS 95.10.04	featPoints = new(V_Array);	featPoints->cArray(0, sizeof(Point3DFFixed), 4);	TransformPoints(points, featPoints);	// make the P3D version	 len = featPoints->ALength();		// ABD-VRML4	 i;									// ABD-VRML4	fpoly=(Point3DFFixed*)featPoints->Use();	if(connected == 1)// reverse the order of the polygon and convert to P3D		{		short index;		for(i=0;i<len;i++)			{			P3D p3d;						p3d.x=FixedToDbl(fpoly[(len-1)-i].x);			p3d.y=FixedToDbl(fpoly[(len-1)-i].y);			p3d.z=FixedToDbl(fpoly[(len-1)-i].z);			surfPoints->Append(&p3d);			index= -(sBase+i+1);			feat.surface->Append(&index);			}					if(!CheckWidth(feat.surface))// really check for at least one Clockwise turn			feat.surface->Reverse();		feat.surfWhere=surfInside; // DAS 95.10.02		}	else  // just convert to P3D		{		for(i=0;i<len;i++)			{			P3D p3d;			short index;		// ABD-VRML4						p3d.x=FixedToDbl(fpoly[i].x);			p3d.y=FixedToDbl(fpoly[i].y);			p3d.z=FixedToDbl(fpoly[i].z);			surfPoints->Append(&p3d);			 index= -(sBase+i+1);		// ABD-VRML4			feat.surface->Append(&index);			}		if(where==SURF_SHARED && color.alpha>=OPAQUE_THRESH)	// Make a second duplicate polygon			{			sBase=surfPoints->ALength();			feat.surfWhere=surfOutside; // DAS 95.10.02			feat2=feat;			feat2.surfWhere=surfInside; // DAS 95.10.02			//	feat2.sColor.red=feature->insideShade.red;//	feat2.sColor.green=feature->insideShade.green;//	feat2.sColor.blue=feature->insideShade.blue;			feat2.surface=new (V_Array);			feat2.surface->cArray(0,sizeof(short),4);			feat2.surfaces=NULL;			for(i=0;i<len;i++)				{				P3D p3d;				short index;		// ABD-VRML4								p3d.x=FixedToDbl(fpoly[i].x);				p3d.y=FixedToDbl(fpoly[i].y);				p3d.z=FixedToDbl(fpoly[i].z);				surfPoints->Append(&p3d);				 index= -(sBase+i+1);		// ABD-VRML4				feat2.surface->Append(&index);				}			}		else if (where==SURF_INSIDE)			feat.surfWhere=surfInside;		else if (where==SURF_OUTSIDE)			feat.surfWhere=surfOutside;		}	featPoints->Unuse();	featPoints->dArray();				if(color.alpha>=OPAQUE_THRESH)// opaque feature, offset from base surface, save poly		{		switch(where)			{			case SURF_INSIDE://				surfIn--;				OffsetSurface(&feat,-1); 				ClipSurface(sArray, &feat, surfInside);// DAS 95.10.02				sArray->Append(&feat);				break;			case SURF_SHARED:// offset both directions, create two polygons and save them both //				surfOut++;					OffsetSurface(&feat,1);				ClipSurface(sArray, &feat, surfOutside);// DAS 95.10.02//				surfIn--;					OffsetSurface(&feat2,-1);				ClipSurface(sArray, &feat2, surfInside);				sArray->Append(&feat);				sArray->Append(&feat2);				break;			case SURF_OUTSIDE: //offset out				surfOut++;				OffsetSurface(&feat,1);				ClipSurface(sArray, &feat, surfOutside);// DAS 95.10.02				sArray->Append(&feat);				break;			}		}	else if(color.alpha>=TRANSL_THRESH)// translucent feature, clip base surface, save poly		{		SurfInfo surfInfo;		sArray->Get(0,&surfInfo);				if(surfInfo.sColor.alpha>=TRANSL_THRESH)// clip base surface if it is even visible			ClipSurface(sArray, &feat, surfBase);		sArray->Append(&feat); // save poly		}	else // transparent feature, clip base surface, don't save poly		{		SurfInfo surfInfo;		sArray->Get(0,&surfInfo);				if(surfInfo.sColor.alpha>=TRANSL_THRESH)// clip base surface if it is even visible			ClipSurface(sArray, &feat, surfBase);		}	return(0);	}intExport_Shard::CloseFeature()	{	return ExportFeature();	}/* *	Transform() * *	Called by TransformPoints() to copy and transform each point from the *	'in' array to the 'out' array. */voidExport_Shard::Transform(void *in, void *out)	{	Point3DFFixed *pIn = (Point3DFFixed *)in, *pOut = (Point3DFFixed *)out;	*pOut = *pIn;	}/* *	OffsetSurface() * Offsets the surface feature by the offset value multiplied by the offset index */void Export_Shard::OffsetSurface(SurfInfo *info, int layer)	{	// this needs to be offset to deal with the z-buffer properly	// offset is the layer that we are putting this polygon into	// zOffset is the distance between the layers	// sNormal is the normal vector of this surface	int len=info->surface->ALength();	short *ind=(short*)info->surface->Use();	int i;		// ABD-VRML4	for( i=0;i<len;i++)		// ABD-VRML4		{		P3D p3d;		p3d=GetPoint(ind[i]);		p3d.x+=zOffset*layer*info->sNormal.x;		p3d.y+=zOffset*layer*info->sNormal.y;		p3d.z+=zOffset*layer*info->sNormal.z;		PutPoint(ind[i],p3d);		}	info->surface->Unuse();	}/* *	ClipSurface() *  Clips the current surface subtracting away this surface feature */void Export_Shard::ClipSurface(V_Array *sInfo, SurfInfo *info, int faceClip)	{	// clip all of the surface features	int len=sInfo->ALength();	int i;		 	// ABD-VRML4	for( i=0;i<len;i++)	// ABD-VRML4		{		SurfInfo si;		sInfo->Get(i,&si);		if(si.surface && (si.surfWhere==faceClip || faceClip==surfBase))			{			V_Array *sclip;			// Subtract info from si.surface this is where the real work occurs...			if(sclip=Intersect(si.surface,info->surface)) //intersection is non-NULL				Shard(&si,sclip);			}		else if (si.surfaces)			ClipSurface(si.surfaces,info,faceClip);		sInfo->Put(i,&si); // put it back when we are done...		}	}/* *	Intersect() *  This will create a new polygon which is the intersection of the two argument polygons. */V_Array* Export_Shard::Intersect(V_Array *s1, V_Array *s2)	{	V_Array * intersect;		// ABD-VRML4	int len;		// ABD-VRML4	P3D p0,p1;		// ABD-VRML4	short index;		// ABD-VRML4	int i;		// ABD-VRML4		RemoveSame(s1);	if(s1->ALength()<=2)return 0;	intersect=new(V_Array);		// ABD-VRML4	intersect->cArray(0,sizeof(short),4);	s2->CopyArray(intersect);	 len=s1->ALength();		// ABD-VRML4			// ABD-VRML4	s1->Get(0,&index);	p0=GetPoint(index);	for( i=0;i<len;i++)		{		if(i<len-1)s1->Get(i+1,&index);		else s1->Get(0,&index);		p1=GetPoint(index);		Slice(intersect,p0,p1);		if(intersect->ALength()==0)break;		p0=p1;		}	RemoveSame(intersect);	if(intersect->ALength()<=2) // no intersection		{		intersect->dArray();		intersect=NULL;		}	return intersect;	}void Export_Shard::RemoveSame(V_Array *poly)	{	P3D p0,p1,ps;	short index;	int len, i;		// ABD-VRML4		if(poly->ALength()>2)		{		 len=poly->ALength();		// ABD-VRML4		poly->Get(0,&index);		ps=p0=GetPoint(index);				for( i=1;i<len;i++)		// ABD-VRML4			{			poly->Get(i,&index);			p1=GetPoint(index);			if(dabs(p0.x-p1.x)<TINY_NUMBER && 				dabs(p0.y-p1.y)<TINY_NUMBER && 				dabs(p0.z-p1.z)<TINY_NUMBER) // same point!					{					poly->Remove(i); //get rid of the identical one					i--;					len--;					}			else p0=p1;			}		if(poly->ALength()>2)		if(dabs(ps.x-p1.x)<TINY_NUMBER && 			dabs(ps.y-p1.y)<TINY_NUMBER && 			dabs(ps.z-p1.z)<TINY_NUMBER) // first and last are the same point!			poly->Remove(poly->ALength()-1); 		}	}/* *	Slice() *  This slices a polygon, pIndex by the line defined by p0 and p1. This is a 3-D slice, *  and the calculation is performed based upon the maximal normal index. For example, if *  the max normal value is in the z direction, we perform the slice in the x-y projection *  plane. *  This method looks for edges of the polygon that cross the specified line. If it finds such *  a line, it calculates the intersection point and adds it to the SurfArray and adds its *  new index value to the pIndex array. */void Export_Shard::Slice(V_Array* pIndex,P3D p0,P3D p1)	{	int len=pIndex->ALength();	short index,nindex;	P3D p3d, lp3d, zp3d,np3d;	int side,lside,zside,i,count;		// ABD-VRML4	pIndex->Get(0,&index);	zp3d=lp3d=GetPoint(index);	zside=lside=CheckSide(lp3d,p0,p1);	 count=1;		// ABD-VRML4	for( i=0;i<len;i++)		// ABD-VRML4		{		P3D p3d;		double d;		if(i<len-1)			{			pIndex->Get(count,&index); 			p3d=GetPoint(index);			side=CheckSide(p3d,p0,p1);			}		else // back to the original point			{			p3d=zp3d;			side=zside;			}				if(side>=CLOCKWISE && lside>=CLOCKWISE) // this line is just fine			{			count++; 			}		else if(side>=CLOCKWISE && lside==COUNTERCLOCKWISE) // last point is clipped			{// clip this line and replace the last point with the new one			d=CrissCross3D(p3d, lp3d,p0,p1);			np3d.x=lp3d.x+(p3d.x-lp3d.x)*d;			np3d.y=lp3d.y+(p3d.y-lp3d.y)*d;			np3d.z=lp3d.z+(p3d.z-lp3d.z)*d;			// clip texture coordinates here...						nindex= -(surfPoints->ALength()+1);			surfPoints->Append(&np3d);			pIndex->Put(count-1,&nindex);			count++;			}		else if(side==COUNTERCLOCKWISE && lside>=CLOCKWISE) // this point is clipped			{// clip this line and insert it			d=CrissCross3D(p3d, lp3d,p0,p1);			np3d.x=lp3d.x+(p3d.x-lp3d.x)*d;			np3d.y=lp3d.y+(p3d.y-lp3d.y)*d;			np3d.z=lp3d.z+(p3d.z-lp3d.z)*d;			// clip texture coordinates here...						nindex= -(surfPoints->ALength()+1);			surfPoints->Append(&np3d);			pIndex->Insert(count,&nindex);			count+=2;			}		else if(side==COUNTERCLOCKWISE && side==COUNTERCLOCKWISE) // both points are clipped away			{//kill the last point, don't increment count...			pIndex->Remove(count-1);			}		lp3d=p3d;		lside=side;		}	}/* *	AppendSurfInfo() *  This adds the SurfInfo objects recursively to the surfArray. It also adds any new points *  to the polyPoints array and updates the index value appropriately. *  This is a destructive algorithm. It is used to flatten the sArray into the surfArray  *  so it flattens and then destroys the sInfo->surfaces V_Arrays that it finds. */voidExport_Shard::AppendSurfInfo(SurfInfo *sInfo)	{	int len;		// ABD-VRML4	short *index;		// ABD-VRML4	short *index2;		// ABD-VRML4	P3D *sp;		// ABD-VRML4	int topIndex;		// ABD-VRML4	int i;		// ABD-VRML4		// Add any new points to the pointPoly V_Array, set new index values to sInfo->surface	if(sInfo->surface)		{#if SHOWSURFACE && MACINTOSH 		DrawSurface(sInfo,sDimension); //XYZZY#endif		 len=sInfo->surface->ALength();		// ABD-VRML4		index= (short*)sInfo->surface->Use();		// ABD-VRML4		index2=(short*)surfIndex->Use();		// ABD-VRML4		sp = (P3D*)surfPoints->Use();		// ABD-VRML4				 topIndex=polyPoints->ALength();		// ABD-VRML4		for( i=0;i<len;i++)		// ABD-VRML4			{			if(index[i]<0) // we need to add this point...				{				P3D p3d;				short ind=-(1+index[i]); // calculate the actual location in the surfPoints				short ind2=index2[ind];				if(ind2==0)// this point has not been used yet...					{     // so add this point to the polyPoints array					surfPoints->Get(ind,&p3d); // get the as yet unused point					index2[ind]=polyPoints->ALength(); // this is where we will put it					index[i]=1+polyPoints->ALength(); // new location of the point					polyPoints->Append(&p3d); // add this point to the list...					}				else index[i]=1+index2[ind]; // this is where the point is currently				}			}		sInfo->surface->Unuse();		surfIndex->Unuse();		surfPoints->Unuse();		surfArray->Append(sInfo);		}	else if(sInfo->surfaces)		{		int len=sInfo->surfaces->ALength();		int i;		// ABD-VRML4		for( i=0; i<len;i++)		// ABD-VRML4			{			SurfInfo si;			sInfo->surfaces->Get(i,&si);			AppendSurfInfo(&si);			}		sInfo->surfaces->dArray();		sInfo->surfaces=NULL;		}	}double Export_Shard::CrissCross3D(P3D p1, P3D p2, P3D q1, P3D q2)	{	double px,py,qx,qy,pqx,pqy,d;		switch(sDimension)		{		case DXP:		case DXN:			px=p1.y-p2.y;			py=p1.z-p2.z;			qx=q2.y-q1.y;			qy=q2.z-q1.z;			break;		case DYP:		case DYN:			px=p1.x-p2.x;			py=p1.z-p2.z;			qx=q2.x-q1.x;			qy=q2.z-q1.z;			break;		case DZP:		case DZN:			px=p1.x-p2.x;			py=p1.y-p2.y;			qx=q2.x-q1.x;			qy=q2.y-q1.y;			break;		}	 	d=px*qy-py*qx;	if(d==0)return 0;	else	    {	    switch(sDimension)	    	{	    	case DXP:	    	case DXN:			    pqx=q2.y-p2.y;			    pqy=q2.z-p2.z;	    		break;	    	case DYP:	    	case DYN:			    pqx=q2.x-p2.x;			    pqy=q2.z-p2.z;	    		break;	    	case DZP:	    	case DZN:			    pqx=q2.x-p2.x;			    pqy=q2.y-p2.y;			    break;			}		return (qy*pqx-qx*pqy)/d;	    }	}int Export_Shard::CheckSide(P3D p0, P3D p1, P3D p2){double dx, dz, dxp, dzp;double b1, b2;	int rval;switch(sDimension)	{	case DXP:		dx = p2.y - p1.y;		dz = p2.z - p1.z;		dxp = p0.y - p1.y;		dzp = p0.z - p1.z;		break;	case DXN:		dx = p2.y - p1.y;		dz = p1.z - p2.z;		dxp = p0.y - p1.y;		dzp = p1.z - p0.z;		break;	case DYP:		dx = p2.x - p1.x;		dz = p1.z - p2.z;		dxp = p0.x - p1.x;		dzp = p1.z - p0.z;		break;	case DYN:		dx = p2.x - p1.x;		dz = p2.z - p1.z;		dxp = p0.x - p1.x;		dzp = p0.z - p1.z;		break;	case DZP:		dx = p2.x - p1.x;		dz = p2.y - p1.y;		dxp = p0.x - p1.x;		dzp = p0.y - p1.y;		break;	case DZN:		dx = p2.x - p1.x;		dz = p1.y - p2.y;		dxp = p0.x - p1.x;		dzp = p1.y - p0.y;		break;	}if(dx==0 && dz==0)rval= UNKNOWN;else if(dxp==0 && dzp==0)rval= UNKNOWN;else	{	b1=dz*dxp;	b2=dx*dzp;	if(dabs(b1-b2)<TINY_NUMBER)rval = UNKNOWN;	else if(dabs(b1)<TINY_NUMBER && dabs(b2)<TINY_NUMBER)rval = UNKNOWN;	else if (b1 > b2) rval= CLOCKWISE;	else if (b1 < b2) rval= COUNTERCLOCKWISE;	else rval= LINEAR;	}return rval;}void Export_Shard::Shard(SurfInfo *out,V_Array *in){// subtract the in array from out->surface by creating an array of convex polygons// that we put in out->surfaces. We then destroy out->surface.// first, find the top points of both. Create an edge from the inside to the outside short *po, *pi;P3D p3d,lp3d;int lo=out->surface->ALength();int li=in->ALength();int i,loindex,liindex,roindex,riindex,soindex,siindex;P3D plo,pro,pli,pri;		// ABD-VRML4int toindex,lloindex,lliindex;		// ABD-VRML4int notDoneEdge=TRUE;		// ABD-VRML4int latch=TRUE;		// ABD-VRML4SurfInfo subPoly;		// ABD-VRML4if(!CheckWidth(out->surface))return;if(!CheckWidth(in))return;out->surfaces=new(V_Array);out->surfaces->cArray(0, sizeof(SurfInfo), 4);po=(short*)out->surface->Use();pi=(short*)in->Use();switch(sDimension)	{	case DXP: // find the minimal z (we need a consistent starting point)	case DXN: 		loindex=liindex=0;		lp3d=GetPoint(po[0]);		for(i=1; i<lo; i++)			{			p3d=GetPoint(po[i]);			if(p3d.z<lp3d.z){lp3d=p3d; loindex=i;}			}		lp3d=GetPoint(pi[0]);		for(i=1;i<li;i++)			{			p3d=GetPoint(pi[i]);			if(p3d.z<lp3d.z){lp3d=p3d; liindex=i;}			}		break;	case DYP: // find the minimal x	case DYN: 		loindex=liindex=0;		lp3d=GetPoint(po[0]);		for(i=1; i<lo; i++)			{			p3d=GetPoint(po[i]);			if(p3d.x<lp3d.x){lp3d=p3d; loindex=i;}			}		lp3d=GetPoint(pi[0]);		for(i=1;i<li;i++)			{			p3d=GetPoint(pi[i]);			if(p3d.x<lp3d.x){lp3d=p3d; liindex=i;}			}		break;	case DZP: // find the minimal y	case DZN: 		loindex=liindex=0;		lp3d=GetPoint(po[0]);		for(i=1; i<lo; i++)			{			p3d=GetPoint(po[i]);			if(p3d.y<lp3d.y){lp3d=p3d; loindex=i;}			}		lp3d=GetPoint(pi[0]);		for(i=1;i<li;i++)			{			p3d=GetPoint(pi[i]);			if(p3d.y<lp3d.y){lp3d=p3d; liindex=i;}			}		break;	}// find the largest convex polygon that we can by moving in the reverse direction// using the three point convexity test. // set the saved base line to be this new left line.		// ABD-VRML4roindex=loindex;riindex=next(liindex,li); plo=GetPoint(po[loindex]);pli=GetPoint(pi[liindex]);pri=GetPoint(pi[riindex]);while(COUNTERCLOCKWISE==CheckSide(pri,pli,plo)) // move to next exterior side	{	loindex=next(loindex,lo);	plo=GetPoint(po[loindex]);	}// find the left most point on the exterior edge		// ABD-VRML4		while(notDoneEdge)	{	toindex=previous(loindex,lo);	plo=GetPoint(po[toindex]);	if(COUNTERCLOCKWISE!=CheckSide(pri,pli,plo))		loindex=toindex;	else notDoneEdge=FALSE;	}lloindex=loindex; // save the outside left for comparison laterlliindex=liindex;// once the left most original point is found, cut the rest of the polygons.		// ABD-VRML4for(i=0;i<li;i++)	{	notDoneEdge=TRUE;	plo=GetPoint(po[loindex]);	// first, cut off the leading triangular piece if necessary	if(COUNTERCLOCKWISE==CheckSide(pri,pli,plo)) 		{		SurfInfo subPoly;// ABD-VRML4		while(notDoneEdge)			{			if(roindex!=lloindex)latch=FALSE;			if(latch || roindex!=lloindex)				roindex=next(roindex,lo);			else notDoneEdge=FALSE;			pro=GetPoint(po[roindex]);			if(COUNTERCLOCKWISE!=CheckSide(pri,pli,pro))				notDoneEdge=FALSE;			}			// ABD-VRML4		subPoly=*out;		subPoly.surfaces=0;		subPoly.surface=new(V_Array);		subPoly.surface->cArray(0,sizeof(short),4);		// add the inside point.		subPoly.surface->Append(&pi[liindex]);				// add the outside points		toindex=loindex;		subPoly.surface->Append(&po[toindex]);		while(toindex!=roindex)			{			toindex=next(toindex,lo);			subPoly.surface->Append(&po[toindex]);			}		if(CheckWidth(subPoly.surface))			out->surfaces->Append(&subPoly);		else // kill the new array			subPoly.surface->dArray();		loindex=roindex;		}	roindex=loindex;	notDoneEdge=TRUE;	while(notDoneEdge)		{		if(roindex==lloindex && riindex==lliindex)			notDoneEdge=FALSE; 		else			{			if(roindex!=lloindex)latch=FALSE;			if(latch || roindex!=lloindex)				toindex=next(roindex,lo);			else {toindex=roindex; notDoneEdge=FALSE;}			pro=GetPoint(po[toindex]);			if(COUNTERCLOCKWISE!=CheckSide(pro,pri,pli))				roindex=toindex;			else notDoneEdge=FALSE;			}		}	// make the new poly...	// ABD-VRML4	subPoly=*out;	subPoly.surfaces=0;	subPoly.surface=new(V_Array);	subPoly.surface->cArray(0, sizeof(short), 4);	// add the inside points (right to left)	subPoly.surface->Append(&pi[riindex]);	subPoly.surface->Append(&pi[liindex]);	// add the outside points (left to right)	toindex=loindex;	subPoly.surface->Append(&po[toindex]);	while(toindex!=roindex)		{		toindex=next(toindex,lo);		subPoly.surface->Append(&po[toindex]);		}	if(CheckWidth(subPoly.surface))		out->surfaces->Append(&subPoly);	else // kill the new array		subPoly.surface->dArray();	//right side becomes the left side and we repeat...	liindex=riindex;	riindex=next(riindex,li);	pli=pri;	pri=GetPoint(pi[riindex]);		loindex=roindex;	}//if(roindex==lloindex && riindex==lliindex)if(lloindex!=loindex)// add the last surface	{	SurfInfo subPoly;	subPoly=*out;	subPoly.surfaces=0;	subPoly.surface=new(V_Array);	subPoly.surface->cArray(0, sizeof(short), 4);	subPoly.surface->Append(&pi[liindex]);	toindex=loindex;	subPoly.surface->Append(&po[toindex]);	while(toindex!=lloindex)		{		toindex=next(toindex,lo);		subPoly.surface->Append(&po[toindex]);		}	if(CheckWidth(subPoly.surface))		out->surfaces->Append(&subPoly);	else // kill the new array		subPoly.surface->dArray();	}out->surface->Unuse();out->surface->dArray();out->surface=0;in->Unuse();}int Export_Shard::CheckWidth(V_Array* surface){short *ind;		// ABD-VRML4short i0,i1,i2;		// ABD-VRML4// if this poly has any width, then we get to keep itint subLen=surface->ALength();int valid=FALSE;int j;	// ABD-VRML4if(subLen<=2)return FALSE;ind=(short*)surface->Use();		// ABD-VRML4i0=ind[subLen-3]; i1=ind[subLen-2]; i2=ind[subLen-1];		// ABD-VRML4for( j=0;j<subLen;j++)	// ABD-VRML4	{	P3D p0=GetPoint(i0);	P3D p1=GetPoint(i1);	P3D p2=GetPoint(i2);	if(CLOCKWISE==CheckSide(p0,p1,p2))// this is all we need		{		valid=TRUE;		break;		}	i0=i1; i1=i2; i2=ind[j];	}surface->Unuse();return valid;}//---------------------------------------------------------------------------------#if SHOWSURFACE && MACINTOSH#include "VWINDOW.H"void GetScreen(Rect *);V_Window * win;VCGrafPort	savePort;VGrafDevice saveDevice;#define SCALE 2#define OFFSET_AMT 2void Export_Shard::DrawSurface(SurfInfo *surf,int dimension)	{	int len=surf->surface->ALength();	short *ind=(short*)surf->surface->Use();	P3D p3d;	int i;		// ABD-VRML4    PolyHandle poly;	RGBColor col;	 poly=OpenPoly();	switch(dimension)		{		case DXP:		case DXN:			p3d=GetPoint(ind[0]);			MoveTo(OFFSET_AMT+p3d.y*SCALE,OFFSET_AMT+p3d.z*SCALE);			for ( i=1;i<len;i++)				{				p3d=GetPoint(ind[i]);				LineTo(OFFSET_AMT+p3d.y*SCALE,OFFSET_AMT+p3d.z*SCALE);				}			p3d=GetPoint(ind[0]);			LineTo(OFFSET_AMT+p3d.y*SCALE,OFFSET_AMT+p3d.z*SCALE);			break;		case DYP:		case DYN:			p3d=GetPoint(ind[0]);			MoveTo(OFFSET_AMT+p3d.x*SCALE,OFFSET_AMT+p3d.z*SCALE);			for ( i=1;i<len;i++)				{				p3d=GetPoint(ind[i]);				LineTo(OFFSET_AMT+p3d.x*SCALE,OFFSET_AMT+p3d.z*SCALE);				}			p3d=GetPoint(ind[0]);			LineTo(OFFSET_AMT+p3d.x*SCALE,OFFSET_AMT+p3d.z*SCALE);			break;		case DZP:		case DZN:				p3d=GetPoint(ind[0]);			MoveTo(OFFSET_AMT+p3d.x*SCALE,OFFSET_AMT+p3d.y*SCALE);			for ( i=1;i<len;i++)				{				p3d=GetPoint(ind[i]);				LineTo(OFFSET_AMT+p3d.x*SCALE,OFFSET_AMT+p3d.y*SCALE);				}			p3d=GetPoint(ind[0]);			LineTo(OFFSET_AMT+p3d.x*SCALE,OFFSET_AMT+p3d.y*SCALE);			break;					}	col.red=surf->sColor.red;	col.green=surf->sColor.green;	col.blue=surf->sColor.blue;	RGBForeColor(&col);     	ClosePoly();	PaintPoly(poly);	col.red=col.green=col.blue=0;	RGBForeColor(&col);     	FramePoly(poly);		    KillPoly(poly);	surf->surface->Unuse();	EventRecord	myEvent;		do { 		if(WaitNextEvent(mDownMask|mUpMask|keyDownMask|autoKeyMask, &myEvent,0,0L))			if(myEvent.what==keyDown)break;		} while ( !Button());	do { /*nothing*/ } while ( Button() );	}void Export_Shard::MakeWindow(void){Rect r,rscreen;int cx,cy;Point p;int style;style = BORDERLESS;p.h=p.v=0;VGetPort( &savePort,&saveDevice );GetScreen(&rscreen);rscreen.top+=50;win=new(V_Window);win->cWindow(&rscreen,(strPtr)"Surface Display",p,p,p,style,WINDOW_CLOSE);win->Show();win->SetWPort();}void Export_Shard::KillWindow(void){/*EventRecord	myEvent;do { 	if(WaitNextEvent(mDownMask|mUpMask|keyDownMask|autoKeyMask, &myEvent,0,0L))		if(myEvent.what==keyDown)break;	} while ( !Button());	*/win->dWindow();VSetPort(savePort,saveDevice);FlushEvents(mDownMask|mUpMask|keyDownMask|keyUpMask|autoKeyMask,0);}#endif