/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	 *				David W. Easter *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "Export.h"#include "VIO.h"#include "VArray.h"#include "VDialog.h"#include "VMemUtil.h"#include "VMath.h"#include "Polyhdrn.h"#include "Surface.h"voidModelExport::cExport()	{	buffer = NULL;	view = (ExportView) 0;  // MSVC is pretty finicky...	}voidModelExport::dExport()	{	}intModelExport::Open(V_Buffer *buf, ExportUnit type, double size)	{	buffer = buf;	return(0);	}intModelExport::Close()	{	buffer = NULL;	return(0);	}intModelExport::Layers(V_Array *layers)	{	return(0);	}voidModelExport::SetPolyhedron(Polyhedron *poly)	{    polyhedron = poly;	// ABD-VRML	}intModelExport::OpenPolyhedron(V_Array *points, RGBAColor color, int layer)	{	return(0);	}intModelExport::ClosePolyhedron()	{	MeterSetCount(MeterGetCount() + 1);	MeterUpdate(0);	if (MeterUpdate(0)) return(-2);	else if (lowMemory) return(-3);	return(0);	}voidModelExport::SetSurface(Surface *surf)	{    surface = surf;	// ABD-VRML	}intModelExport::OpenSurface(V_Array *pointRefs, RGBAColor color, Point3DFFixed normal)	{	return(0);	}intModelExport::CloseSurface()	{	return(0);	}voidModelExport::Feature(struct SurfFeature *feat)	{	feature = feat;		// ABD-VRML	}intModelExport::OpenFeature(V_Array *points, RGBAColor color, int where, int connected)	{	return(0);	}intModelExport::CloseFeature()	{	return(0);	}voidModelExport::TransformPoints(V_Array *in, V_Array *out)	{	int nPoints, i;	nPoints = in->ALength();	out->SetLength(nPoints);	in->Use(); out->Use();	for (i = 0; i < nPoints; i++)		Transform(in->GetAddress(i), out->GetAddress(i));	in->Unuse(); out->Unuse();	}voidModelExport::DerefPoints(V_Array *points, V_Array *refs, V_Array *deref)	{	int nPoints, i;	Point3DFFixed *pnt;	short *ref;	nPoints = refs->ALength();	deref->SetLength(nPoints);	points->Use();	ref = (short*)refs->Use();	for (i = 0; i < nPoints; i++)		deref->Put(i, points->GetAddress(*ref++));	points->Unuse();	refs->Unuse();	}voidModelExport::SetView(Point3DFFixed vector)	{	if (FFPositive(vector.x)) view = right;	else if (FFNegative(vector.x)) view = left;	else if (FFPositive(vector.y)) view = back;	else if (FFNegative(vector.y)) view = front;	else if (FFPositive(vector.z)) view = top;	else if (FFNegative(vector.z)) view = bottom;	else view = top;	}Point3DFFixedModelExport::Translate(Point3DFFixed in)	{	Point3DFFixed out;	switch (view)		{		case top: out.x = in.x; out.y = in.y; out.z = in.z; break;		case bottom: out.x = FFNeg(in.x); out.y = in.y; out.z = FFNeg(in.z); break;		case front: out.x = in.x; out.y = in.z; out.z = FFNeg(in.y); break;		case back: out.x = FFNeg(in.x); out.y = in.z; out.z = in.y; break;		case left: out.x = FFNeg(in.y); out.y = in.z; out.z = FFNeg(in.x); break;		case right: out.x = in.y; out.y = in.z; out.z = in.x; break;		}	return(out);	}intModelExport::Visible(Point3DFFixed normal)	{	Point3DFFixed n = Translate(normal);	FFixed limit = INITFIXXED(5,0);		return(FFLogic(n.z, limit) > 0);	}voidModelExport::Transform(void *in, void *out)	{	}int ModelExport::SortPolyhedra() { return(FALSE); }int ModelExport::ComparePoly(struct Polyhedron *a, struct Polyhedron *b) { return(0); }int ModelExport::SortSurfaces() { return(FALSE); }int ModelExport::CompareSurf(struct Surface *a, struct Surface *b) { return(0); }int ModelExport::SortFeatures() { return(FALSE); }int ModelExport::CompareFeat(struct SurfFeature *a, struct SurfFeature *b) { return(0); }