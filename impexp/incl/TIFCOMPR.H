#ifndef TIFF_PIXEL_HANDLER_#define TIFF_PIXEL_HANDLER_#include "VTYPES.H"#if VWT/* routine to extract the bits from an array.  Sort of a barrel shifter.Used in CCITT and the variable bits grabbers */extern long	ExtractBits(struct V_Array *, long *, int, int *);/* these routines write out char data (pixels) to a V_File.  The routine thatassembles the pixel values into the clearBuf is responsible for passing oneentire strip to the writer, since the Compressor can't assemble the stripsitself (it doesn't know the size of the offsreen, for one).  */struct BaseCompressor:indirect {	struct V_Buffer	*buffer;		virtual void	cCompressor(struct V_Buffer*);	virtual void	dCompressor(void);		virtual int 	WritePixels(struct V_Array *, ULong *);	/* returns number of bytes written */	};struct Compressor:BaseCompressor {	void	cCompressor(struct V_Buffer*);	void	dCompressor(void);		int 	WritePixels(struct V_Array *, ULong *);	/* returns number of bytes written */	};#define PACKBITS_MAX	127#define REPLICATE_STATE	0x1#define COPY_STATE		0x2struct PackBitsCompressor:BaseCompressor {	void	cPackBitsCompressor(V_Buffer*);	void	dPackBitsCompressor(void);		int 	WritePixels(V_Array*, ULong *);	/* returns number of bytes written */	};typedef struct 	{	unsigned short	id;	unsigned short	parent;	unsigned char	discriminator;	} HashTableEntry;				/* write-out table entry */#define REHASH_TABLE_SIZE	10struct LZWCompressor:BaseCompressor {		int				retry, RehashTable[REHASH_TABLE_SIZE];	ULong 	CRCTable[256];		void			cLZWCompressor(struct V_Buffer*);	void			dLZWCompressor(void);	void			BuildCRCTable(void);		int				InTable(V_Array *, ULong, HashTableEntry *, ULong);	void			InitHashTable(V_Array *, ULong *);	int				AddToTable(V_Array *, ULong, HashTableEntry *, ULong);	int				CompactCodes(short*, int, int, unsigned char *, unsigned char *, ULong *, int);	ULong			Hash(ULong, unsigned char);		int 			WritePixels(V_Array *,ULong *);	};#define MAX_TABLE_SIZE		4096#define CODE_BUF_SIZE		256		/* size of output buffer */#define ENCODED_BUF_SIZE	(CODE_BUF_SIZE * 3)/2 + 1	/* 1.5 * CODE_BUF_SIZE */#define	CLEAR_CODE			256		/* special compression codes */#define END_OF_INPUT		257#define TIME_TO_CLEAR_TABLE	4094#define NEVER_FILLED		16384	/* the table can't get this big */#define NO_PARENT			8192#define EMPTY				8192#define SAVE_LEFTOVERS		1#define HASH_TABLE_SIZE		8191#define SHORTBITS			16#define CHARBITS			8#define AddtoString(string, byte)	\	string.discriminator = byte;	\	string.parent = string.id;#define RetryHash(newHash, oldHash)	\	if (retry >= REHASH_TABLE_SIZE) newHash = (oldHash+1L)%HASH_TABLE_SIZE; \	else newHash = (oldHash + RehashTable[retry++])%HASH_TABLE_SIZE;struct BaseUncompressor:indirect {	V_Buffer	*buffer;			virtual void	cUncompressor(struct V_Buffer*);	virtual void	dUncompressor(void);		virtual long 	ReadPixels(V_Array*, long, long, long);	/* returns number of bytes written */	};struct Uncompressor:BaseUncompressor {	void	cUncompressor(struct V_Buffer*);	void	dUncompressor(void);		long 	ReadPixels(V_Array*, long, long, long);	/* returns number of bytes written */	};typedef struct {	short	runLength, shift;	} CCITTLut;#define WHITE0_MASK		0x003F#define WHITE0_SHIFT	5#define WHITE1_MASK		0x007F#define WHITE1_SHIFT	4#define WHITE2_MASK		0x001F#define WHITE2_SHIFT	7#define BLACK0_MASK		0x003F#define BLACK0_SHIFT	0#define BLACK1_MASK		0x00FF#define BLACK1_SHIFT	1#define BLACK2_MASK		0x003F#define BLACK2_SHIFT	7#define MAKEUPS_MASK	0x000F#define MAKEUPS_SHIFT	1#define CCITT_WHITE		1#define CCITT_BLACK		0#define TOGGLE_COLOR(c)		(!c)struct CCITTUncompressor:BaseUncompressor {	V_Array			*codeBuffer;	long			codeBufferPos, counter, stripPosCounter;	int				which, flags;	unsigned char	residue, residueCount;	CCITTLut		white0[64], white1[128], white2[32];	CCITTLut		black0[64], black1[256], black2[64], makeUps[16];		void			cCCITTUncompressor(V_Buffer *);	void			dUncompressor(void);		long 			ReadPixels(V_Array*, long, long, long);	/* returns number of bytes read */	int				StuffBits(V_Array *, long *);};#define COPY_BYTES				0x1#define REPEAT_THIS_BYTE		0x2#define DEFAULT_BUFFER_SIZE		512struct PackBitsUncompressor:BaseUncompressor {		V_Array	*codeBuffer;	int		codeBufferPos, counter, flags;		void	cPackBitsUncompressor(V_Buffer *);	void	dUncompressor(void);		long 	ReadPixels(V_Array*, long, long, long);	/* returns number of bytes read */};#define	CLEAR_CODE			256		/* special compression codes */#define END_OF_INPUT		257#define TIME_TO_CLEAR_TABLE	4094#define SAVE_LEFTOVERS		1#define HASH_TABLE_SIZE		8191#define	REHASH_TABLE_SIZE	10#define ADDTNL_MEM_SIZE		512/* constants for extraction.  R_ means bits from the right-hand side, L_ meansbits from the left */#define R_ONE		0x01#define R_TWO		0x03#define R_THREE		0x07#define R_FOUR		0x0F#define R_FIVE		0x1F#define R_SIX		0x3F#define R_SEVEN		0x7F#define ALL			0xFF#define L_ONE		0x80#define L_TWO		0xC0#define L_THREE		0xE0#define L_FOUR		0xF0#define L_FIVE		0xF8#define L_SIX		0xFC#define L_SEVEN		0xFEtypedef struct	{	unsigned short length, offset;	} InputTableEntry;				/* read-in table entry */struct LZWUncompressor:BaseUncompressor {		V_Array	*codeBuffer, *stringSpace, *table;	int		nBits, bitCount;	long	clearBufferPos, codeBufferPos, stringSpacePos;		void	cLZWUncompressor(V_Buffer *);	void	dUncompressor(void);		long 	ReadPixels(V_Array*, long, long, long);	/* returns number of bytes read */	int		UncompactCodes(void);	void	InitInputTable(void);	int		WriteStringFromCode(V_Array *, int);	int		AddStringToTable(int, int);};#endif // VWT#endif// TIFF_PIXEL_HANDLER_