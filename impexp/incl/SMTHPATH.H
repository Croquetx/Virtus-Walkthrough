/*------------------------------------------------------------------------------ * Catmull-Rom spline curve.  We are using the interpolatory version here as described * by Barry "A Recursive Evaluation Algorithm for a Class of Catmull-Rom Splines" in * Siggraph 1988 pp 199-204. * NOTE: * 	This method guarantees that the new curve will include the original points as * 	well as the interpolated points. *------------------------------------------------------------------------------*//*------------------------------------------------------------------------------ * V_Array *SmoothPath(V_Array *inPath,int f, int t, int ef) * V_Array *inPath; -------V_Array of ObserverStep (see Observer.c). * int f;			-------from frame * int t;			-------to frame * int ef;			-------expansion factor for average frame distance * This routine returns an Observer path made up of ObserverStep objects. *Notes:1. This function is a strict interpolation function.  That is, every originalpoint is still part of the resulting V_Array.  Additional points areinterpolated, with the number depending upon the expansion factor.  Thisnumber is the average number of new points that you want between segmentsand is not the resulting V_Array size, thus if th expansion factor is 4, theresulting V_Array is actually 5 times the size of the original. It has the originalpoints plus, on average 4 new points per segment.  The actual number of pointsbetween segments varies and depends upon the distance (including angular distance)between the points.  The greater the distance, the more points placed between.2. The range values in SmoothPath.h are used to smooth the angular components.  It is currently set to be 256 pseudo-degrees.  If you change to radians, you mustalso change these values.3. ANGLETOLENGTH is used to determine the value of an angular unit to a distanceunit.  For 256 pseudo-degrees I have set it (somewhat arbitrarily) to 1.0.  Ifyou change to another angular unit such as radians, it would be a good idea tochange this as well, otherwise large angular changes will not be properly interpolated.4.  The resulting path may not be terribly nice.  This is because our angularresolution is too low to take advantage of the interpolation though our spatialresolution does an adequate job.  The result is percieved discontinuities inthe path due to angular changes of one pseudo degree.   Think of it this way,by inserting points between frames, we have smoothed the path.  Since the angleis also being smoothed, but most of this is being ignored, the effect is thatthe observor appears to be going in a straight line and then suddenly shiftsslightly to one side and continues until it happens again.  The best thing todo is simply use the entire range for the angle (which is calculated but ignoredin the fractional part).  This may not happen so try to keep the expansion factorlow, for example set it to one.5.  The V_Meter will have trouble with this guy since you are no longer dealingdirectly with the frame you are saving but many in between as well.  6.  Remember that the resulting array is the path SEGMENT specified with thef and t indices. Thus it should be used completely and sequentially (start atzero go to length-1).7.  For those of you who care, this is a (semi-recursive) Catmull-Rom splinealgorithm.  For more info see Siggraph '88, pp 199-204.  It has some nice featuresthat lend themselves especially to path smoothing. 11.  This one is actually in there. *------------------------------------------------------------------------------*/#ifndef SMOOTH_PATH#define SMOOTH_PATHstruct V_Array *SmoothPath(struct V_Array *inPath, int from,int to, int expansion);#define MINRANGE 0.0#define MAXRANGE 256.0#define FULLRANGE 256.0#define HALFRANGE 128.0#define ANGLETOLENGTH 1.0#endif //SMOOTH_PATH