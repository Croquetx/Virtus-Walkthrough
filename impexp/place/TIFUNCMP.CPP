/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	John C. Alspaugh * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#if VWT /* jca 17 Sept 93. Not in VR { */#include "VArray.h"#include "VDisplay.h"#include "VDialog.h"#include "VGUtil.h"#include "VMemUtil.h"#include "AppText.h"#include "AppDeflt.h"#include "ImgHandl.h"#include "TIFCompr.h"#include "TIFHandl.h"	/* TIFFHandler class and constants */#include "TIFDefs.h" 		/* TIFF tags constants */#include "TIFConst.h"#include <string.h>/* Uncompressors.  They read one "strip" from the file, uncompress it completely, and hand it back to the caller.  They do not, under any circumstances, 	-- change the size of the uncompressed text buffer.	-- return incomplete parts of the uncompressed strip to the caller.	They do	-- set the size of their internal buffer.	-- return the strip, the whole strip, and nothing but the uncompressed strip.	*//* uncmpressor base class *//* make them virtual    */voidBaseUncompressor::cUncompressor(V_Buffer *theBuffer){buffer = theBuffer;}voidBaseUncompressor::dUncompressor(){delete this;}long BaseUncompressor::ReadPixels(V_Array* clearBuf, long fromWhere, long lengthToRead, long NumberOfPixelsInStrip){}/* plain vanila pixel reader.  Just grabs from the file, and passes the	values back */void	Uncompressor::cUncompressor(V_Buffer *theBuffer){buffer = theBuffer;}void Uncompressor::dUncompressor(){ delete this; }long Uncompressor::ReadPixels(V_Array* clearBuf, long fromWhere, long lengthToRead, long NumberOfPixelsInStrip){char 	*charPtr;/* always read in a complete strip.  Period. */if ((!(clearBuf->SetLength(lengthToRead))) && (clearBuf->array != NULL))	{	charPtr = (char*) clearBuf->Use();	buffer->IOPosition(charPtr, lengthToRead, fromWhere);	clearBuf->Unuse();	}else	{	AlertMessage(TXTW_MEMORY);	clearBuf->length = 0; clearBuf->allocLength = 0;	return(-1);	}return(lengthToRead);}void	CCITTUncompressor::cCCITTUncompressor(V_Buffer *theBuffer){int i;buffer = theBuffer;codeBuffer = new(V_Array);codeBuffer->cArray(DEFAULT_BUFFER_SIZE, sizeof(char), 1);codeBufferPos = 0;counter = 0;flags = 0x0;/* make the tables */makeUps[0].runLength = 1792;	makeUps[0].shift = 11;makeUps[1].runLength = 1792;	makeUps[1].shift = 11;makeUps[2].runLength = 1984;	makeUps[2].shift = 11;makeUps[3].runLength = 2048;	makeUps[3].shift = 12;makeUps[4].runLength = 2112;	makeUps[4].shift = 12;makeUps[5].runLength = 2176;	makeUps[5].shift = 12;makeUps[6].runLength = 2240;	makeUps[6].shift = 12;makeUps[7].runLength = 2304;	makeUps[7].shift = 12;makeUps[8].runLength = 1856;	makeUps[8].shift = 12;makeUps[9].runLength = 1856;	makeUps[9].shift = 12;makeUps[10].runLength = 1920;	makeUps[10].shift = 12;makeUps[11].runLength = 1920;	makeUps[11].shift = 12;makeUps[12].runLength = 2368;	makeUps[12].shift = 12;makeUps[13].runLength = 2432;	makeUps[13].shift = 12;makeUps[14].runLength = 2496;	makeUps[14].shift = 12;makeUps[15].runLength = 2560;	makeUps[15].shift = 12;white0[0].runLength		= -1;	white0[0].shift = -1;white0[1].runLength		= -1;	white0[1].shift = -1;white0[2].runLength		= 29;	white0[2].shift = 8;white0[3].runLength		= 30;	white0[3].shift = 8;white0[4].runLength		= 45;	white0[4].shift = 8;white0[5].runLength		= 46;	white0[5].shift = 8;white0[6].runLength		= 22;	white0[6].shift = 7;white0[7].runLength		= 22;	white0[7].shift = 7;white0[8].runLength		= 23;	white0[8].shift = 7;white0[9].runLength		= 23;	white0[9].shift = 7;white0[10].runLength	= 47;	white0[10].shift = 8;white0[11].runLength	= 48;	white0[11].shift = 8;white0[12].runLength	= 13;	white0[12].shift = 6;white0[13].runLength	= 13;	white0[13].shift = 6;white0[14].runLength	= 13;	white0[14].shift = 6;white0[15].runLength	= 13;	white0[15].shift = 6;white0[16].runLength	= 20;	white0[16].shift = 7;white0[17].runLength	= 20;	white0[17].shift = 7;white0[18].runLength	= 33;	white0[18].shift = 8;white0[19].runLength	= 34;	white0[19].shift = 8;white0[20].runLength	= 35;	white0[20].shift = 8;white0[21].runLength	= 36;	white0[21].shift = 8;white0[22].runLength	= 37;	white0[22].shift = 8;white0[23].runLength	= 38;	white0[23].shift = 8;white0[24].runLength	= 19;	white0[24].shift = 7;white0[25].runLength	= 19;	white0[25].shift = 7;white0[26].runLength	= 31;	white0[26].shift = 8;white0[27].runLength	= 32;	white0[27].shift = 8;white0[28].runLength	= 1;	white0[28].shift = 6;white0[29].runLength	= 1;	white0[29].shift = 6;white0[30].runLength	= 1;	white0[30].shift = 6;white0[31].runLength	= 1;	white0[31].shift = 6;white0[32].runLength	= 12;	white0[32].shift = 6;white0[33].runLength	= 12;	white0[33].shift = 6;white0[34].runLength	= 12;	white0[34].shift = 6;white0[35].runLength	= 12;	white0[35].shift = 6;white0[36].runLength	= 53;	white0[36].shift = 8;white0[37].runLength	= 54;	white0[37].shift = 8;white0[38].runLength	= 26;	white0[38].shift = 7;white0[39].runLength	= 26;	white0[39].shift = 7;white0[40].runLength	= 39;	white0[40].shift = 8;white0[41].runLength	= 40;	white0[41].shift = 8;white0[42].runLength	= 41;	white0[42].shift = 8;white0[43].runLength	= 42;	white0[43].shift = 8;white0[44].runLength	= 43;	white0[44].shift = 8;white0[45].runLength	= 44;	white0[45].shift = 8;white0[46].runLength	= 21;	white0[46].shift = 7;white0[47].runLength	= 21;	white0[47].shift = 7;white0[48].runLength	= 28;	white0[48].shift = 7;white0[49].runLength	= 28;	white0[49].shift = 7;white0[50].runLength	= 61;	white0[50].shift = 8;white0[51].runLength	= 61;	white0[51].shift = 8;white0[52].runLength	= 63;	white0[52].shift = 8;white0[53].runLength	= 0;	white0[53].shift = 8;white0[54].runLength	= 68;	white0[54].shift = 8;white0[55].runLength	= 69;	white0[55].shift = 8;white0[56].runLength	= 10;	white0[56].shift = 5;white0[57].runLength	= 10;	white0[57].shift = 5;white0[58].runLength	= 10;	white0[58].shift = 5;white0[59].runLength	= 10;	white0[59].shift = 5;white0[60].runLength	= 10;	white0[60].shift = 5;white0[61].runLength	= 10;	white0[61].shift = 5;white0[62].runLength	= 10;	white0[62].shift = 5;white0[63].runLength	= 10;	white0[63].shift = 5;for (i=0; i < 8; i++)	{	black0[i].runLength	= 18;	black0[i].shift = 10;	}black0[8].runLength		= 52;	black0[8].shift = 12;black0[9].runLength		= 52;	black0[9].shift = 12;black0[10].runLength	= 640;	black0[10].shift = 13;black0[11].runLength	= 704;	black0[11].shift = 13;black0[12].runLength	= 768;	black0[12].shift = 13;black0[13].runLength	= 832;	black0[13].shift = 13;black0[14].runLength	= 55;	black0[14].shift = 12;black0[15].runLength	= 55;	black0[15].shift = 12;black0[16].runLength	= 56;	black0[16].shift = 12;black0[17].runLength	= 56;	black0[17].shift = 12;black0[18].runLength	= 1280;	black0[18].shift = 13;black0[19].runLength	= 1344;	black0[19].shift = 13;black0[20].runLength	= 1408;	black0[20].shift = 13;black0[21].runLength	= 1472;	black0[21].shift = 13;black0[22].runLength	= 59;	black0[22].shift = 12;black0[23].runLength	= 59;	black0[23].shift = 12;black0[24].runLength	= 60;	black0[24].shift = 12;black0[25].runLength	= 60;	black0[25].shift = 12;black0[26].runLength	= 1536;	black0[26].shift = 13;black0[27].runLength	= 1600;	black0[27].shift = 13;black0[28].runLength	= 24;	black0[28].shift = 11;black0[29].runLength	= 24;	black0[29].shift = 11;black0[30].runLength	= 24;	black0[30].shift = 11;black0[31].runLength	= 24;	black0[31].shift = 11;black0[32].runLength	= 25;	black0[32].shift = 11;black0[33].runLength	= 25;	black0[33].shift = 11;black0[34].runLength	= 25;	black0[34].shift = 11;black0[35].runLength	= 25;	black0[35].shift = 11;black0[36].runLength	= 1664;	black0[36].shift = 13;black0[37].runLength	= 1728;	black0[37].shift = 13;black0[38].runLength	= 320;	black0[38].shift = 12;black0[39].runLength	= 320;	black0[39].shift = 12;black0[40].runLength	= 384;	black0[40].shift = 12;black0[41].runLength	= 384;	black0[41].shift = 12;black0[42].runLength	= 448;	black0[42].shift = 12;black0[43].runLength	= 448;	black0[43].shift = 12;black0[44].runLength	= 512;	black0[44].shift = 13;black0[45].runLength	= 576;	black0[45].shift = 13;black0[46].runLength	= 53;	black0[46].shift = 12;black0[47].runLength	= 53;	black0[47].shift = 12;black0[48].runLength	= 54;	black0[48].shift = 12;black0[49].runLength	= 54;	black0[49].shift = 12;black0[50].runLength	= 896;	black0[50].shift = 13;black0[51].runLength	= 960;	black0[51].shift = 13;black0[52].runLength	= 1024;	black0[52].shift = 13;black0[53].runLength	= 1088;	black0[53].shift = 13;black0[54].runLength	= 1152;	black0[54].shift = 13;black0[55].runLength	= 1216;	black0[55].shift = 13;for (i=56;i<64;i++)	{	black0[i].runLength	= 64;	black0[i].shift = 10;	}black2[0].runLength		= -1;	black2[0].shift = -1;black2[1].runLength		= -1;	black2[1].shift = -1;black2[2].runLength		= -1;	black2[2].shift = -1;black2[3].runLength		= -1;	black2[3].shift = -1;black2[4].runLength		= 9;	black2[4].shift = 6;black2[5].runLength		= 8;	black2[5].shift = 6;black2[6].runLength		= 7;	black2[6].shift = 5;black2[7].runLength		= 7;	black2[7].shift = 5;black2[8].runLength		= 6;	black2[8].shift = 4;black2[9].runLength		= 6;	black2[9].shift = 4;black2[10].runLength	= 6;	black2[10].shift = 4;black2[11].runLength	= 6;	black2[11].shift = 4;black2[12].runLength	= 5;	black2[12].shift = 4;black2[13].runLength	= 5;	black2[13].shift = 4;black2[14].runLength	= 5;	black2[14].shift = 4;black2[15].runLength	= 5;	black2[15].shift = 4;for (i=16;i<24;i++)	{	black2[i].runLength	= 1;	black2[i].shift = 3;	}for (i=24;i<32;i++)	{	black2[i].runLength	= 4;	black2[i].shift = 3;	}for (i=32;i<48;i++)	{	black2[i].runLength	= 3;	black2[i].shift = 2;	}for (i=48;i<64;i++)	{	black2[i].runLength	= 2;	black2[i].shift = 2;	}white2[0].runLength		= 3;	white2[0].shift = 4;white2[1].runLength		= 3;	white2[1].shift = 4;white2[2].runLength		= 3;	white2[2].shift = 4;white2[3].runLength		= 3;	white2[3].shift = 4;white2[4].runLength		= 128;	white2[4].shift = 5;white2[5].runLength		= 128;	white2[5].shift = 5;white2[6].runLength		= 8;	white2[6].shift = 5;white2[7].runLength		= 8;	white2[7].shift = 5;white2[8].runLength		= 9;	white2[8].shift = 5;white2[9].runLength		= 9;	white2[9].shift = 5;white2[10].runLength	= 16;	white2[10].shift = 6;white2[11].runLength	= 17;	white2[11].shift = 6;white2[12].runLength	= 4;	white2[12].shift = 4;white2[13].runLength	= 4;	white2[13].shift = 4;white2[14].runLength	= 4;	white2[14].shift = 4;white2[15].runLength	= 4;	white2[15].shift = 4;white2[16].runLength	= 5;	white2[16].shift = 4;white2[17].runLength	= 5;	white2[17].shift = 4;white2[18].runLength	= 5;	white2[18].shift = 4;white2[19].runLength	= 5;	white2[19].shift = 4;white2[20].runLength	= 14;	white2[20].shift = 6;white2[21].runLength	= 15;	white2[21].shift = 6;white2[22].runLength	= 64;	white2[22].shift = 5;white2[23].runLength	= 64;	white2[23].shift = 5;white2[24].runLength	= 6;	white2[24].shift = 4;white2[25].runLength	= 6;	white2[25].shift = 4;white2[26].runLength	= 6;	white2[26].shift = 4;white2[27].runLength	= 6;	white2[27].shift = 4;white2[28].runLength	= 7;	white2[28].shift = 4;white2[29].runLength	= 7;	white2[29].shift = 4;white2[30].runLength	= 7;	white2[30].shift = 4;white2[31].runLength	= 7;	white2[31].shift = 4;for (i=0;i<64;i++)	{	black1[i].runLength	= -1;	black1[i].shift = -1;	}for(i=64;i<80;i++)	{	black1[i].runLength	= 13;	black1[i].shift = 8;	}black1[80].runLength	= 23;	black1[80].shift = 11;black1[81].runLength	= 23;	black1[81].shift = 11;black1[82].runLength	= 50;	black1[82].shift = 12;black1[83].runLength	= 51;	black1[83].shift = 12;black1[84].runLength	= 44;	black1[84].shift = 12;black1[85].runLength	= 45;	black1[85].shift = 12;black1[86].runLength	= 46;	black1[86].shift = 12;black1[87].runLength	= 47;	black1[87].shift = 12;black1[88].runLength	= 57;	black1[88].shift = 12;black1[89].runLength	= 58;	black1[89].shift = 12;black1[90].runLength	= 61;	black1[90].shift = 12;black1[91].runLength	= 256;	black1[91].shift = 12;black1[92].runLength	= 16;	black1[92].shift = 10;black1[93].runLength	= 16;	black1[93].shift = 10;black1[94].runLength	= 16;	black1[94].shift = 10;black1[95].runLength	= 16;	black1[95].shift = 10;black1[96].runLength	= 17;	black1[96].shift = 10;black1[97].runLength	= 17;	black1[97].shift = 10;black1[98].runLength	= 17;	black1[98].shift = 10;black1[99].runLength	= 17;	black1[99].shift = 10;black1[100].runLength	= 48;	black1[100].shift = 12;black1[101].runLength	= 49;	black1[101].shift = 12;black1[102].runLength	= 62;	black1[102].shift = 12;black1[103].runLength	= 63;	black1[103].shift = 12;black1[104].runLength	= 30;	black1[104].shift = 12;black1[105].runLength	= 31;	black1[105].shift = 12;black1[106].runLength	= 32;	black1[106].shift = 12;black1[107].runLength	= 33;	black1[107].shift = 12;black1[108].runLength	= 40;	black1[108].shift = 12;black1[109].runLength	= 41;	black1[109].shift = 12;black1[110].runLength	= 22;	black1[110].shift = 11;black1[111].runLength	= 22;	black1[111].shift = 11;for(i=112;i<128;i++)	{	black1[i].runLength	= 14;	black1[i].shift = 8;	}for(i=128;i<161;i++)	{	black1[i].runLength	= 10;	black1[i].shift = 7;	}for(i=160;i<192;i++)	{	black1[i].runLength	= 11;	black1[i].shift = 7;	}black1[192].runLength	= 15;	black1[192].shift = 9;black1[193].runLength	= 15;	black1[193].shift = 9;black1[194].runLength	= 15;	black1[194].shift = 9;black1[195].runLength	= 15;	black1[195].shift = 9;black1[196].runLength	= 15;	black1[196].shift = 9;black1[197].runLength	= 15;	black1[197].shift = 9;black1[198].runLength	= 15;	black1[198].shift = 9;black1[199].runLength	= 15;	black1[199].shift = 9;black1[200].runLength	= 128;	black1[200].shift = 12;black1[201].runLength	= 192;	black1[201].shift = 12;black1[202].runLength	= 26;	black1[202].shift = 12;black1[203].runLength	= 27;	black1[203].shift = 12;black1[204].runLength	= 28;	black1[204].shift = 12;black1[205].runLength	= 29;	black1[205].shift = 12;black1[206].runLength	= 19;	black1[206].shift = 11;black1[207].runLength	= 19;	black1[207].shift = 11;black1[208].runLength	= 20;	black1[208].shift = 11;black1[209].runLength	= 20;	black1[209].shift = 11;black1[210].runLength	= 34;	black1[210].shift = 12;black1[211].runLength	= 35;	black1[211].shift = 12;black1[212].runLength	= 36;	black1[212].shift = 12;black1[213].runLength	= 37;	black1[213].shift = 12;black1[214].runLength	= 38;	black1[214].shift = 12;black1[215].runLength	= 39;	black1[215].shift = 12;black1[216].runLength	= 21;	black1[216].shift = 11;black1[217].runLength	= 21;	black1[217].shift = 11;black1[218].runLength	= 42;	black1[218].shift = 12;black1[219].runLength	= 43;	black1[219].shift = 12;black1[220].runLength	= 0;	black1[220].shift = 10;black1[221].runLength	= 0;	black1[221].shift = 10;black1[222].runLength	= 0;	black1[222].shift = 10;black1[223].runLength	= 0;	black1[223].shift = 10;for(i=224;i<256;i++)	{	black1[i].runLength	= 12;	black1[i].shift = 7;	}for(i=0;i<16;i++)	{	white1[i].runLength		= 11;	white1[i].shift = 5;	}white1[16].runLength	= 27;	white1[16].shift = 7;white1[17].runLength	= 27;	white1[17].shift = 7;white1[18].runLength	= 27;	white1[18].shift = 7;white1[19].runLength	= 27;	white1[19].shift = 7;white1[20].runLength	= 59;	white1[20].shift = 8;white1[21].runLength	= 59;	white1[21].shift = 8;white1[22].runLength	= 60;	white1[22].shift = 8;white1[23].runLength	= 60;	white1[23].shift = 8;white1[24].runLength	= 1472;	white1[24].shift = 9;white1[25].runLength	= 1536;	white1[25].shift = 9;white1[26].runLength	= 1600;	white1[26].shift = 9;white1[27].runLength	= 1728;	white1[27].shift = 9;white1[28].runLength	= 18;	white1[28].shift = 7;white1[29].runLength	= 18;	white1[29].shift = 7;white1[30].runLength	= 18;	white1[30].shift = 7;white1[31].runLength	= 18;	white1[31].shift = 7;white1[32].runLength	= 24;	white1[32].shift = 7;white1[33].runLength	= 24;	white1[33].shift = 7;white1[34].runLength	= 24;	white1[34].shift = 7;white1[35].runLength	= 24;	white1[35].shift = 7;white1[36].runLength	= 49;	white1[36].shift = 8;white1[37].runLength	= 49;	white1[37].shift = 8;white1[38].runLength	= 50;	white1[38].shift = 8;white1[39].runLength	= 50;	white1[39].shift = 8;white1[40].runLength	= 51;	white1[40].shift = 8;white1[41].runLength	= 51;	white1[41].shift = 8;white1[42].runLength	= 52;	white1[42].shift = 8;white1[43].runLength	= 52;	white1[43].shift = 8;white1[44].runLength	= 25;	white1[44].shift = 7;white1[45].runLength	= 25;	white1[45].shift = 7;white1[46].runLength	= 25;	white1[46].shift = 7;white1[47].runLength	= 25;	white1[47].shift = 7;white1[48].runLength	= 55;	white1[48].shift = 8;white1[49].runLength	= 55;	white1[49].shift = 8;white1[50].runLength	= 56;	white1[50].shift = 8;white1[51].runLength	= 56;	white1[51].shift = 8;white1[52].runLength	= 57;	white1[52].shift = 8;white1[53].runLength	= 57;	white1[53].shift = 8;white1[54].runLength	= 58;	white1[54].shift = 8;white1[55].runLength	= 58;	white1[55].shift = 8;white1[56].runLength	= 192;	white1[56].shift = 7;white1[57].runLength	= 192;	white1[57].shift = 7;white1[58].runLength	= 192;	white1[58].shift = 7;white1[59].runLength	= 192;	white1[59].shift = 7;white1[60].runLength	= 192;	white1[60].shift = 7;white1[61].runLength	= 192;	white1[61].shift = 7;white1[62].runLength	= 192;	white1[62].shift = 7;white1[63].runLength	= 192;	white1[63].shift = 7;white1[64].runLength	= 1664;	white1[64].shift = 6;white1[65].runLength	= 1664;	white1[65].shift = 6;white1[66].runLength	= 1664;	white1[66].shift = 6;white1[67].runLength	= 1664;	white1[67].shift = 6;white1[68].runLength	= 1664;	white1[68].shift = 6;white1[69].runLength	= 1664;	white1[69].shift = 6;white1[70].runLength	= 1664;	white1[70].shift = 6;white1[71].runLength	= 1664;	white1[71].shift = 6;white1[72].runLength	= 448;	white1[72].shift = 8;white1[73].runLength	= 448;	white1[73].shift = 8;white1[74].runLength	= 512;	white1[74].shift = 8;white1[75].runLength	= 512;	white1[75].shift = 8;white1[76].runLength	= 704;	white1[76].shift = 9;white1[77].runLength	= 768;	white1[77].shift = 9;white1[78].runLength	= 640;	white1[78].shift = 8;white1[79].runLength	= 640;	white1[79].shift = 8;white1[80].runLength	= 576;	white1[80].shift = 8;white1[81].runLength	= 576;	white1[81].shift = 8;white1[82].runLength	= 832;	white1[82].shift = 9;white1[83].runLength	= 896;	white1[83].shift = 9;white1[84].runLength	= 960;	white1[84].shift = 9;white1[85].runLength	= 1024;	white1[85].shift = 9;white1[86].runLength	= 1088;	white1[86].shift = 9;white1[87].runLength	= 1152;	white1[87].shift = 9;white1[88].runLength	= 1216;	white1[88].shift = 9;white1[89].runLength	= 1280;	white1[89].shift = 9;white1[90].runLength	= 1344;	white1[90].shift = 9;white1[91].runLength	= 1408;	white1[91].shift = 9;white1[92].runLength	= 256;	white1[92].shift = 7;white1[93].runLength	= 256;	white1[93].shift = 7;white1[94].runLength	= 256;	white1[94].shift = 7;white1[95].runLength	= 256;	white1[95].shift = 7;for(i=96;i<128;i++)	{	white1[i].runLength	= 2;	white1[i].shift = 4;	}}void CCITTUncompressor::dUncompressor(){ codeBuffer->dArray();delete this; }long CCITTUncompressor::ReadPixels(V_Array* clearBuf, long fromWhere, long lengthToRead, long NumberOfPixelsInStrip){char 	*codePtr;int		nLeftovers, toGet, err, bitCount;long	holder, clearBufferPos, lastCount;/* set the buffer length */if ((codeBuffer->SetLength(lengthToRead)) || (codeBuffer->array == NULL))	{	AlertMessage(TXTW_MEMORY);	codeBuffer->length = 0; codeBuffer->allocLength = 0;	return(-1);	}codePtr = (char *) codeBuffer->Use();buffer->IOPosition(codePtr, lengthToRead, fromWhere);codeBuffer->Unuse();counter = 0; holder = 0x0;codeBufferPos = 0;clearBufferPos = 0;nLeftovers = 0;toGet = 13;which = CCITT_WHITE;residueCount = 0x0;residue = 0x0;bitCount = 0;err = 0;while ((bitCount < NumberOfPixelsInStrip) && !err)	{	/* extract 13 bits */	holder |= ExtractBits(codeBuffer, &codeBufferPos, toGet, &nLeftovers);		/* check for huge make-up counts */	if (holder < 32)		{		AlertMessage(TIFF_UNCOMPRESS);		err = -1;		}	else if ((holder > 31) && (holder < 64))		{		counter += makeUps[((holder >> MAKEUPS_SHIFT) & MAKEUPS_MASK)].runLength;		toGet    = makeUps[((holder >> MAKEUPS_SHIFT) & MAKEUPS_MASK)].shift;		if (toGet == -1)			{			AlertMessage(TIFF_UNCOMPRESS);			err = -1;			}		}			else 			{		if (which == CCITT_WHITE)			{			if ((holder > 63) && (holder < 2048))				{				lastCount= white0[((holder >> WHITE0_SHIFT) & WHITE0_MASK)].runLength;				toGet    = white0[((holder >> WHITE0_SHIFT) & WHITE0_MASK)].shift;				}			else if ((holder > 2047) && (holder < 4096))				{				lastCount= white1[((holder >> WHITE1_SHIFT) & WHITE1_MASK)].runLength;				toGet    = white1[((holder >> WHITE1_SHIFT) & WHITE1_MASK)].shift;				}			else if ((holder > 4095) && (holder < 8192))				{				lastCount= white2[((holder >> WHITE2_SHIFT) & WHITE2_MASK)].runLength;				toGet    = white2[((holder >> WHITE2_SHIFT) & WHITE2_MASK)].shift;				}						if ((lastCount < 64) && (lastCount >= 0))				{				counter += lastCount;				err = StuffBits(clearBuf, &clearBufferPos);				which = CCITT_BLACK;							bitCount += counter;				counter = 0;								}			else if (toGet >= 0)				counter += lastCount;			else				{				AlertMessage(TIFF_UNCOMPRESS);				err = -1;				}							}		else 			{			if ((holder >= 0) && (holder < 128))				{				lastCount= black0[((holder >> BLACK0_SHIFT) & BLACK0_MASK)].runLength;				toGet    = black0[((holder >> BLACK0_SHIFT) & BLACK0_MASK)].shift;				}			else if ((holder > 127) && (holder < 512))				{				lastCount= black1[((holder >> BLACK1_SHIFT) & BLACK1_MASK)].runLength;				toGet    = black1[((holder >> BLACK1_SHIFT) & BLACK1_MASK)].shift;				}			else if ((holder > 511) && (holder < 8192))				{				lastCount= black2[((holder >> BLACK2_SHIFT) & BLACK2_MASK)].runLength;				toGet    = black2[((holder >> BLACK2_SHIFT) & BLACK2_MASK)].shift;				}						if ((lastCount < 64) && (lastCount >= 0))				{				counter += lastCount;				err = StuffBits(clearBuf, &clearBufferPos);				which = CCITT_WHITE;				bitCount += counter;				counter = 0;								}			else if (toGet >= 0)				counter += lastCount;			else				{				AlertMessage(TIFF_UNCOMPRESS);				err = -1;				}						}		}		holder = (holder << toGet) & 0x00001FFF;	}if (residueCount)	{	char 	*clearPtr;	clearPtr = (char *) clearBuf->Abuse();	clearPtr[clearBufferPos] = residue;	}if ((clearBufferPos + 1 < (NumberOfPixelsInStrip + 7)/8) && !err)	{	AlertMessage(TIFF_UNCOMPRESS);	return(-1);	}		return(((err)?err:(NumberOfPixelsInStrip + 7)/8));}intCCITTUncompressor::StuffBits(V_Array *buffer, long *currPos){int	bits;long stuffCounter;char *bufferPtr, pattern;/* only stuff as much as there is room for */if (counter > 8*(VA_Length(buffer) - *currPos))	{	AlertMessage(TIFF_ERROR);	return -1;	}stuffCounter = counter;bufferPtr = (char *) buffer->Use();/* CCITT compression (for TIFF) has white interpreted as '0' and black as '1'.  */if (which == CCITT_WHITE)	pattern = 0x00;else 						pattern = 0xFF;bits = CHARBITS - residueCount;if (bits > stuffCounter)	{	char next;		switch(stuffCounter)		{		case 0:	next = 0x00; break;		case 1:	next = (pattern & 0x80) >> residueCount; break;		case 2:	next = (pattern & 0xC0) >> residueCount; break;		case 3:	next = (pattern & 0xE0) >> residueCount; break;		case 4:	next = (pattern & 0xF0) >> residueCount; break;		case 5:	next = (pattern & 0xF8) >> residueCount; break;		case 6:	next = (pattern & 0xFC) >> residueCount; break;		case 7:	next = (pattern & 0xFE) >> residueCount; break;		}			residue |= next;		bits = residueCount + stuffCounter;	if (bits < CHARBITS)		{		residueCount = bits;		stuffCounter = 0;		}	else if (bits == CHARBITS)		{		bufferPtr[(*currPos)++] = residue;		residue = 0x00;		residueCount = 0x00;		stuffCounter = 0;		}	else /* if (bits > CHARBITS) */		{		AlertMessage(TIFF_ERROR);		stuffCounter = -1;		}			}else	{	if (residueCount)		{		switch (bits)			{			case 1:	bufferPtr[(*currPos)++] = residue | (0x01 & pattern); break;			case 2:	bufferPtr[(*currPos)++] = residue | (0x03 & pattern); break;			case 3:	bufferPtr[(*currPos)++] = residue | (0x07 & pattern); break;			case 4:	bufferPtr[(*currPos)++] = residue | (0x0F & pattern); break;			case 5:	bufferPtr[(*currPos)++] = residue | (0x1F & pattern); break;			case 6:	bufferPtr[(*currPos)++] = residue | (0x3F & pattern); break;			case 7:	bufferPtr[(*currPos)++] = residue | (0x7F & pattern); break;			case 8:	bufferPtr[(*currPos)++] = residue | (0xFF & pattern); break;			case 0:	(*currPos)++;			}		stuffCounter -= bits;		}			while (stuffCounter > 7)		{		bufferPtr[(*currPos)++] = pattern;		stuffCounter -=  8;		}		if (stuffCounter > 0)		{			switch (stuffCounter)			{			case 1:	residue = 0x80 & pattern; break;			case 2:	residue = 0xC0 & pattern; break;			case 3:	residue = 0xE0 & pattern; break;			case 4:	residue = 0xF0 & pattern; break;			case 5:	residue = 0xF8 & pattern; break;			case 6:	residue = 0xFC & pattern; break;			case 7:	residue = 0xFE & pattern; break;			}		residueCount = (unsigned char) stuffCounter;		stuffCounter -= stuffCounter;		}	else if (stuffCounter == 0)		{		residueCount = 0;		residue = 0x00;		}	}buffer->Unuse();return(stuffCounter);}/*-------------------------------------------------------------------------Although there is an UnpackBits routine in the mac toolbox, we should have an implementation available to run on the PC.-------------------------------------------------------------------------*/voidPackBitsUncompressor::cPackBitsUncompressor(V_Buffer *theBuffer){buffer = theBuffer;codeBuffer = new(V_Array);codeBuffer->cArray(DEFAULT_BUFFER_SIZE, sizeof(char), 1);codeBufferPos = 0;counter = 0;flags = 0x0;}voidPackBitsUncompressor::dUncompressor(){codeBuffer->dArray();delete(this);}longPackBitsUncompressor::ReadPixels(V_Array *clearBuf, long fromWhere, long lengthToRead, long NumberOfPixelsInStrip){int 	whichByte, err;char	*codePtr, *clearPtr;err = 0;/* set the buffer length */if ((codeBuffer->SetLength(lengthToRead)) || (codeBuffer->array == NULL))	{	AlertMessage(TXTW_MEMORY);	codeBuffer->length = 0; codeBuffer->allocLength;	return(-1);	}codePtr = (char *) codeBuffer->Use();clearPtr = (char *) clearBuf->Use();buffer->IOPosition(codePtr, lengthToRead, fromWhere);counter = 0; codeBufferPos = 0;	whichByte = 0; /* we will almost always fill the out buffer, except on the last line of the image (where it is quite possible we won't come close to filling it).We must have several ways to terminate the loop */while (((codeBufferPos < VA_Length(codeBuffer)) &&	   (whichByte < VA_Length(clearBuf))) && !err)	{				/* if n >= 0 and n <= 127, copy the next n bytes directly to the output */	if (( codePtr[codeBufferPos] >= 0) && ((short)codePtr[codeBufferPos] <= 127))		{		int spaceLeft;		int nTimes = codePtr[codeBufferPos] + 1;				codeBufferPos++;		spaceLeft = VA_Length(clearBuf) - whichByte;		if (nTimes > spaceLeft)	/* not enough room in outBuffer */			{			err = -1;			AlertMessage(TIFF_UNCOMPRESS);			nTimes = 0;			}				memcpy(&clearPtr[whichByte], &codePtr[codeBufferPos], nTimes);		whichByte += nTimes;		codeBufferPos += nTimes;				}	/* if n >= -127 and n <= -1, copy the next byte in fabs(n) times */	else if ((codePtr[codeBufferPos] >= -127) && (codePtr[codeBufferPos] <= -1))		{		int spaceLeft;		int	nTimes = 1 - (codePtr[codeBufferPos]);				codeBufferPos++;				spaceLeft = VA_Length(clearBuf) - whichByte;		if (nTimes > spaceLeft)	/* not enough room in outBuffer */			{			err = -1;			AlertMessage(TIFF_UNCOMPRESS);			nTimes = 0;			}				memset(&clearPtr[whichByte], codePtr[codeBufferPos], nTimes);		whichByte += nTimes;				codeBufferPos++;				}	/* else, do nothing */	else		codeBufferPos++;			}	clearBuf->Unuse();codeBuffer->Unuse();clearBuf->SetLength(whichByte);return(((err)?err:whichByte));}void	LZWUncompressor::cLZWUncompressor(V_Buffer *theBuffer){buffer = theBuffer;codeBuffer = new(V_Array);stringSpace = new(V_Array);table = new(V_Array);codeBuffer->cArray(DEFAULT_BUFFER_SIZE, sizeof(char), 1);stringSpace->cArray(DEFAULT_BUFFER_SIZE, sizeof(char), 512);table->cArray(MAX_TABLE_SIZE, sizeof(InputTableEntry), 1);VA_Truncate(codeBuffer);nBits = 9;codeBufferPos = 0;bitCount = 0;}void	LZWUncompressor::dUncompressor(void){codeBuffer->dArray();stringSpace->dArray();table->dArray();delete(this);}/*-------------------------------------------------------------------------LZWUncompressV_Array *clear and int *length are return parameters.  They are the uncompressedbytes of the strip and the length of the strip (which should tally withthe class variable bufferSize)-------------------------------------------------------------------------*/long	LZWUncompressor::ReadPixels(V_Array *clearBuf, long fromWhere, long lengthToRead, long NumberOfPixelsInStrip){int		err;char 	*buf;int 	code, oldCode;if ((codeBuffer->SetLength(lengthToRead)) || (codeBuffer->array == NULL))	{	AlertMessage(TXTW_MEMORY);	codeBuffer->length = 0; codeBuffer->allocLength = 0;	return(-1);	}/* now get the strip */buf = (char *) codeBuffer->Use();buffer->IOPosition(buf, lengthToRead, fromWhere);codeBuffer->Unuse();err = FALSE;bitCount = 0;codeBufferPos = 0;clearBufferPos = 0;nBits = 9;InitInputTable();stringSpacePos = 0;code = UncompactCodes();	/* peek at code *//*code = (unsigned int) ExtractBits(codeBuffer, &codeBufferPos, nBits, &bitCount);*/ bitCount = 0;	codeBufferPos = 0;			/* rewind the strip, as it were */if (code != CLEAR_CODE)		{	err = -1;	AlertMessage(TIFF_LZWUNCOMPRESS);	}/* uncompress the strip */while ((!err) && ((code = UncompactCodes()) != END_OF_INPUT))	{		if ((codeBufferPos & 0xFF) == 0)#if WINDOWS		if (MeterUpdate(VGetTime())) err = -2;#elif MACINTOSH		if (MeterUpdate(TickCount())) err = -2;#endif		if (code == CLEAR_CODE)			{		nBits = 9;		InitInputTable();		stringSpacePos = 0;		code = UncompactCodes();		if (code == END_OF_INPUT)			break;				err = WriteStringFromCode(clearBuf, code);				oldCode = code;		}	else 		{		if (VA_Length(table) > code)		/* in table, no error */			{			err = WriteStringFromCode(clearBuf, code);			AddStringToTable(oldCode, code);			}		else if (VA_Length(table) == code)	/* not in table, so add it and write this code */			{			err = WriteStringFromCode(clearBuf, AddStringToTable(oldCode, oldCode));						}		else	/* this is a weird code.  Perhaps a file corruption error ? */			{			AlertMessage(TIFF_UNCOMPRESS);			err = -1;			}					if ((VA_Length(table) == 511) || (VA_Length(table) == 1023) ||			(VA_Length(table) == 2047))			nBits++;		else if (VA_Length(table) == 4095)				{			AlertMessage(TIFF_UNCOMPRESS);			err = -1; /* AlertMessage("Danger, Will Robinson!  Danger!");	*/				}		oldCode = code;		}	}	clearBuf->SetLength(clearBufferPos);return(((err)?err:VA_Length(clearBuf)));}intLZWUncompressor::UncompactCodes(){short	bitsLeftToGrab, extractedCode;unsigned char *code;extractedCode = 0x0;code = (unsigned char *) codeBuffer->Use();/* the code can be, at most, spread over 3 bytes.  We must be prepared to extract the code in three segments (or two segments) and composite it.Step one:  grab the bits from the leftmost byte, shift them, and stuff them into	into extractedCode.  Use the R_-prefixed constants to extract the rightmost	bits from the byte.	Step two:  if there are 8 or more bits left to grab, then grab them in a	chunk _now_, and shift and bit-OR them into extractedCode.  	Step three:  if there are any bits left (there can be no more than 7 left) 	then extract them and shift them down to the lowest part of the byte,	and bit-Or into extractedCode.  Use the L_-prefixed constants to extract	the leftmost bits from the byte.	*//* residue_count is the number of bits left in this byte we didn't get last time */bitsLeftToGrab = nBits; if (bitCount)	{	/* grab the bits from the first word */	switch(bitCount)		{		case 1:			extractedCode |= code[codeBufferPos++] & R_ONE;			bitsLeftToGrab -= 1;			break;		case 2:			extractedCode |= code[codeBufferPos++] & R_TWO;			bitsLeftToGrab -= 2;			break;		case 3:			extractedCode |= code[codeBufferPos++] & R_THREE;			bitsLeftToGrab -= 3;			break;		case 4:			extractedCode |= code[codeBufferPos++] & R_FOUR;			bitsLeftToGrab -= 4;			break;		case 5:			extractedCode |= code[codeBufferPos++] & R_FIVE;			bitsLeftToGrab -= 5;			break;		case 6:			extractedCode |= code[codeBufferPos++] & R_SIX;			bitsLeftToGrab -= 6;			break;		case 7:			extractedCode |= code[codeBufferPos++] & R_SEVEN;			bitsLeftToGrab -= 7;			break;		}	extractedCode <<= bitsLeftToGrab;		}/* if there are 8 or more bits left, grab'em (this is where we would loop if we allowed > 8-bit codes) */if (bitsLeftToGrab >= 8)	{	bitsLeftToGrab -= 8;	extractedCode |= (((unsigned short)code[codeBufferPos++] & 0xFF) << bitsLeftToGrab);	}/* extract any bits left */if (bitsLeftToGrab > 0)	{	switch (bitsLeftToGrab)		{		case 1:			extractedCode |= (((unsigned short)code[codeBufferPos] & L_ONE) >> 7);			bitCount = 7;			break;		case 2:			extractedCode |= (((unsigned short)code[codeBufferPos] & L_TWO) >> 6);			bitCount = 6;			break;		case 3:			extractedCode |= (((unsigned short)code[codeBufferPos] & L_THREE) >> 5);			bitCount = 5;			break;		case 4:			extractedCode |= (((unsigned short)code[codeBufferPos] & L_FOUR) >> 4);			bitCount = 4;			break;		case 5:			extractedCode |= (((unsigned short)code[codeBufferPos] & L_FIVE) >> 3);			bitCount = 3;			break;		case 6:			extractedCode |= (((unsigned short)code[codeBufferPos] & L_SIX) >> 2);			bitCount = 2;			break;		case 7:			extractedCode |= (((unsigned short)code[codeBufferPos] & L_SEVEN) >> 1);			bitCount = 1;			break;		}	}else		bitCount = 0;	codeBuffer->Unuse();return(extractedCode);}voidLZWUncompressor::InitInputTable(){InputTableEntry	*ptr;ptr = (InputTableEntry *) table->Use();memset(ptr, 0x0, MAX_TABLE_SIZE);table->Unuse();table->SetLength(258);}int	LZWUncompressor::WriteStringFromCode(V_Array *out, int code){int err;err = 0;if (code < 0)	/* police invalid codes */	return -1;	/* the code has already been validated; we know this to be an acceptable code */if (code < 256)		{	char *outPtr;	outPtr = (char *)out->Abuse();	if (clearBufferPos < VA_Length(out))		outPtr[clearBufferPos++] = (char)code;	else 		err = -1;	}else	{	char 			*stringPtr, *outPtr;	InputTableEntry ite, *iteTablePtr;		iteTablePtr = (InputTableEntry *) table->Abuse();	ite = iteTablePtr[code];	if (clearBufferPos + ite.length <= VA_Length(out))		{		outPtr = (char *) out->Use();        stringPtr = (char *) stringSpace->Use();		memcpy(&outPtr[clearBufferPos], &stringPtr[ite.offset], ite.length);		out->Unuse();		stringSpace->Unuse();		clearBufferPos += ite.length;	}	else 		{		AlertMessage(TIFF_UNCOMPRESS);		err = -1;		}	}return(err);}int	LZWUncompressor::AddStringToTable(int base, int tip){char 			finalChar, *storePtr;InputTableEntry	ite, newIte;/*newIte.offset = VA_Length(stringSpace);*/newIte.offset = stringSpacePos;if (tip < 256)	{	finalChar = (unsigned char) tip;	}else	{	/* get the first char of the 2nd string */	InputTableEntry	*tablePtr;	char			*stringPtr;		tablePtr = (InputTableEntry *) table->Abuse();	stringPtr = (char *) stringSpace->Abuse();	finalChar = (char) stringPtr[tablePtr[tip].offset];/*	table->Get(tip, &ite);	stringSpace->Get(ite.offset, &finalChar);*/	}if (base < 256)	{	/*	byte = (unsigned char) base;	VA_Append(stringSpace, byte, char);	*/	/* do we need to allocate more space? */	if (stringSpacePos + 1 >= VA_Length(stringSpace))		{		GrowMemory(FALSE);	/* don't try to relaim */				if (0 > (stringSpace->SetLength(VA_Length(stringSpace) + ADDTNL_MEM_SIZE)))			{			GrowMemory(TRUE);			// Dialog box may need the memory 	//GJR 10/26/93			AlertMessage(TXTW_MEMORY);			return -1;		/* can't get the extra memory.  bye-bye! */			}					GrowMemory(TRUE);		}			storePtr = (char *)stringSpace->Abuse();	storePtr[stringSpacePos++] = (unsigned char) base;	storePtr[stringSpacePos++] = (unsigned char) finalChar;	ite.length = 1;	}else 	{	/* get the whole first string */	table->Get(base, &ite);	/*	length = stringSpace->ALength();	stringSpace->SetLength(length+ite.length);*/	if (stringSpacePos + ite.length + 1 >= VA_Length(stringSpace))		{		GrowMemory(FALSE);	/* don't try to relaim */				if (0 > (stringSpace->SetLength(VA_Length(stringSpace) + ite.length + ADDTNL_MEM_SIZE)))			{			GrowMemory(TRUE);			// Dialog box may need the memory 	//GJR 10/26/93			AlertMessage(TXTW_MEMORY);			return -1;		/* can't get the extra memory.  bye-bye! */			}					GrowMemory(TRUE);		}			/* make a new entry of the first string, plus the first char of the second string */	storePtr = (char *) stringSpace->Use();	memcpy(&storePtr[stringSpacePos], &storePtr[ite.offset], ite.length);	stringSpacePos += ite.length;	storePtr[stringSpacePos++] = (unsigned char) finalChar;	stringSpace->Unuse();		}	/*VA_Append(stringSpace, finalChar, char);*/newIte.length = ite.length + 1;VA_Append(table, newIte, InputTableEntry);/* return the new entry number */return(VA_Length(table) - 1);}longExtractBits(V_Array *codeBuffer, long *byteNo, int numBits, int *residueCount){short	bitsLeftToGrab;long	extractedCode;unsigned char *code;extractedCode = 0x0000;code = (unsigned char *)codeBuffer->Use();	/* the code can be, at most, spread over 5 bytes.  We must be prepared to extract the code in as many as 5 segments and composite it.Step one:  grab the bits from the leftmost byte, shift them, and stuff them into	into extractedCode.  Use the R_-prefixed constants to extract the rightmost	bits from the byte.	Step two:  if there are 8 or more bits left to grab, then grab them in a	chunk _now_, and shift and bit-OR them into extractedCode.  	Step three:  if there are any bits left (there can be no more than 7 left) 	then extract them and shift them down to the lowest part of the byte,	and bit-Or into extractedCode.  Use the L_-prefixed constants to extract	the leftmost bits from the byte.	*//* residue_count is the number of bits left in this byte we didn't get last time */bitsLeftToGrab = numBits; if (*residueCount)	{	/* grab the bits from the first word */	switch(*residueCount)		{		case 1:			extractedCode |= code[*byteNo] & R_ONE;			bitsLeftToGrab -= 1;			break;		case 2:			extractedCode |= code[*byteNo] & R_TWO;			bitsLeftToGrab -= 2;			break;		case 3:			extractedCode |= code[*byteNo] & R_THREE;			bitsLeftToGrab -= 3;			break;		case 4:			extractedCode |= code[*byteNo] & R_FOUR;			bitsLeftToGrab -= 4;			break;		case 5:			extractedCode |= code[*byteNo] & R_FIVE;			bitsLeftToGrab -= 5;			break;		case 6:			extractedCode |= code[*byteNo] & R_SIX;			bitsLeftToGrab -= 6;			break;		case 7:			extractedCode |= code[*byteNo] & R_SEVEN;			bitsLeftToGrab -= 7;			break;		}		/* mask off any bits we shouldn't have gotten */	if (bitsLeftToGrab < 0)		{		switch (bitsLeftToGrab)				{			case -1:				extractedCode >>= -bitsLeftToGrab;				*residueCount = 1;				break;			case -2:				extractedCode >>= -bitsLeftToGrab;				*residueCount = 2;				break;			case -3:				extractedCode >>= -bitsLeftToGrab;				*residueCount = 3;				break;			case -4:				extractedCode >>= -bitsLeftToGrab;				*residueCount = 4;				break;			case -5:				extractedCode >>= -bitsLeftToGrab;				*residueCount = 5;				break;			case -6:				extractedCode >>= -bitsLeftToGrab;				*residueCount = 6;				break;			case -7:				extractedCode >>= -bitsLeftToGrab;				*residueCount = 7;				break;				}		}	else		{		extractedCode <<= bitsLeftToGrab;		*residueCount = 0;		(*byteNo)++;		}	}/* if there are 8 or more bits left, grab'em (this is where we would loop if we allowed > 8-bit codes) */while (bitsLeftToGrab >= 8)	{	if (*byteNo < VA_Length(codeBuffer))		{		bitsLeftToGrab -= 8;		extractedCode = (extractedCode | ((ULong)code[(*byteNo)++] & 0xFF)) << bitsLeftToGrab;		}	else		{		bitsLeftToGrab -= 8;		extractedCode =  (extractedCode | 0x0L) << bitsLeftToGrab;		}	}/* extract any bits left */if (bitsLeftToGrab > 0)	{	switch (bitsLeftToGrab)		{		case 1:			if (*byteNo < VA_Length(codeBuffer))				extractedCode |= (((ULong)code[*byteNo] & L_ONE) >> 7);			*residueCount = 7;			break;		case 2:			if (*byteNo < VA_Length(codeBuffer))				extractedCode |= (((ULong)code[*byteNo] & L_TWO) >> 6);			*residueCount = 6;			break;		case 3:			if (*byteNo < VA_Length(codeBuffer))				extractedCode |= (((ULong)code[*byteNo] & L_THREE) >> 5);			*residueCount = 5;			break;		case 4:			if (*byteNo < VA_Length(codeBuffer))				extractedCode |= (((ULong)code[*byteNo] & L_FOUR) >> 4);			*residueCount = 4;			break;		case 5:			if (*byteNo < VA_Length(codeBuffer))				extractedCode |= (((ULong)code[*byteNo] & L_FIVE) >> 3);			*residueCount = 3;			break;		case 6:			if (*byteNo < VA_Length(codeBuffer))				extractedCode |= (((ULong)code[*byteNo] & L_SIX) >> 2);			*residueCount = 2;			break;		case 7:			if (*byteNo < VA_Length(codeBuffer))				extractedCode |= (((ULong)code[*byteNo] & L_SEVEN) >> 1);			*residueCount = 1;			break;		}	}	codeBuffer->Unuse();return(extractedCode);}// jca 17 Sept 93 }#endif