/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   John C. Alspaugh * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include <stdio.h>#include "VTypes.h"#if VWT /* jca 17 Sept 93.  Not in VR { */#include "VArray.h"#include "VDisplay.h"#include "VDialog.h"#include "VGUtil.h"#include "VMemUtil.h"#include "AppText.h"#include "AppDeflt.h"#include "ImgHandl.h"#include "TIFCompr.h"#include "TIFHandl.h"   /* TIFFHandler class and constants */#include "TIFDefs.h"        /* TIFF tags constants */#include "TIFConst.h"#include "BClrCnvt.h"int TIFFReader::cTIFFReader(V_Buffer *theFile){short tmp;char top, bottom;flags = 0x0;compression = NO_COMPRESSION;rowsPerStrip = 1;imageDepth = 0;Prediction = NO_PREDICTION;/* test byte-ordering */tmp = 0x1;top = ((char *)&tmp)[0]; //(tmp & 0xFF00) >> 4;bottom = ((char *) &tmp)[1]; //tmp & 0xFF;if ((top) && (!bottom))    flags |= LITTLE_ENDIAN;else if ((!top) && (bottom))    flags |= BIG_ENDIAN;else    flags = 0;              /* error */stripOffsets = new(V_Array);stripLengths = new(V_Array);colorResponseCurves = NULL;colorMap = NULL;stripOffsets->cArray(0, sizeof(ULong), 8);stripLengths->cArray(0, sizeof(ULong), 8);xscaleNum = yscaleNum = DEFAULT_IMAGE_SCALE;xscaleDenom = yscaleDenom = 1;file = theFile;screen = NULL;return(0);}voidTIFFReader::dTIFFReader(){if (stripOffsets)           stripOffsets->dArray();if (stripLengths)           stripLengths->dArray();if (colorMap)               colorMap->dArray();if (colorResponseCurves)    colorResponseCurves->dArray();delete this;}int TIFFReader::ReadImage(int forceDepth){int     err;Rect    r;Point   scale;BaseUncompressor *pixelReader;      /* reads and uncompresses pixels */ColorConverterBase *pixelConverter; /* converts from image to screen depth */if (!(ReadHeader()))    if (!(ReadTagsDirectory()))        {        /* can't pass the class variable rect to the cOffscreen() routine;          must pass a variable that is on the stack */        r = rect;   #if MACINTOSH                    if (forceDepth == -1)            {            if (flags & BILEVEL)                screenDepth = 1;            else                screenDepth = imageDepth;            }        else            screenDepth = forceDepth;#elif WINDOWS_AND_DIB_OFFSCREENS        if (forceDepth == -1)            {            if (flags & BILEVEL)                screenDepth = 1;            else                 screenDepth = min(MainDepth(), imageDepth);            }        else            screenDepth = forceDepth;   #elif WINDOWS        screenDepth = 24;   /* the screen depth is not something                            we can currently control */#endif        pixelReader = MakePixelReader();        pixelConverter = MakePixelConverter(screenDepth);        screen = new(V_Offscreen);        err = screen->cOffscreen(&r, screenDepth, NULL, colorMap);		        if (err)            {            //screen->dOffscreen();		// JCA if there's an error, we couldn't allocate the screen.  Don't deallocate.            screen = NULL;            AlertMessage(TXTW_MEMORY);            }        else             {            /* set offscreen resolution */            scale.v = (short) ((long)yscaleNum/(long)yscaleDenom);            scale.h = (short) ((long)xscaleNum/(long)xscaleDenom);            screen->PutResolution(&scale);            err = ReadPixels(pixelReader, pixelConverter);			}		pixelConverter->dColorConverter();		pixelReader->dUncompressor();		}    else err = -1;else err = -1;return(err);}intTIFFReader::ReadHeader(){char header[9], *ptr;long startTags;short version;file->IOPosition(header, 8, 0);if ((header[0] == 'I') && (header[1] == 'I'))    {    if (flags & BIG_ENDIAN) flags |= BYTE_SWAP;         /* set byte-swapping flags */    else flags &= (unsigned short) ~BYTE_SWAP;    }else if ((header[0] == 'M') && (header[1] == 'M'))    {    if (flags & LITTLE_ENDIAN) flags |= BYTE_SWAP;          /* set byte-swapping flags */    else flags &= (unsigned short) ~BYTE_SWAP;    }else    {    AlertMessage(NOT_A_VALID_TIFF_FILE);    return(-1);    }    ptr = &header[2];CONVERT_CHAR_TO_SHORT(version, ptr);if (version != 0x2A)    {    AlertMessage(CORRUPT_HEADER);    return(-1);    }ptr = &header[4];CONVERT_CHAR_TO_LONG(startTags, ptr);IFDPosition = startTags;return(0);}voidTIFFReader::InterpIFDEntry(char *buffer,unsigned short *tag, unsigned short *type, ULong *length, ULong *value) {short tmp;char    *ptr;CONVERT_CHAR_TO_SHORT(*tag, buffer);ptr = &buffer[2];CONVERT_CHAR_TO_SHORT(*type, ptr);ptr = &buffer[4];CONVERT_CHAR_TO_LONG(*length, ptr);ptr = &buffer[8];if ((*type == TIFFSHORT) && (*length == 1))    {    CONVERT_CHAR_TO_SHORT(tmp, ptr);    *value = ((long) tmp & 0x0000FFFF);    }else     CONVERT_CHAR_TO_LONG(*value, ptr);}intTIFFReader::ReadTagsDirectory(){char    buffer[IFDENTRY_SIZE], *ptr;V_Array *dataBuf;int i,j;unsigned short  local_short, tag, type, samplesPerPixel;ULong   local_long, length, value;int     aProblem, anUnresolvedProblem;/* assume file is uncompressed B+W */bitsPerSample[SINGLE_SAMPLE] = 1;samplesPerPixel = 1;dataBuf = new(V_Array);dataBuf->cArray(0, sizeof(char), 1);aProblem = anUnresolvedProblem = 0x0;   /* set up problem flag */file->IOPosition(buffer, 2, IFDPosition);CONVERT_CHAR_TO_SHORT(IFDSize, buffer);IFDPosition += 2;/* get the tags info, and look for problems with it.  If theproblem is fatal but handled by a specific error message, thenincrement aProblem (which will kick us out of the loop, but won'tcause extra error messages).  increment anUnresolvedProblem (inaddition to aProblem) if there is no specific error message forthe error */for (i = 0; i < IFDSize && !aProblem; i++)    {    file->IOPosition(buffer, IFDENTRY_SIZE, IFDPosition);    InterpIFDEntry(buffer, &tag, &type, &length, &value);        /* do whatever it is we need to do */    switch (tag)        {        case NewSubfileType:        /* TIFFLONG */        case SubfileType:           /* TIFFSHORT */            break;                    case ImageWidth:            /* TIFFSHORT or _TIFFLONG_ */            rect.right = value;     break;        case ImageLength:           /* TIFFSHORT or _TIFFLONG_ */            rect.bottom = value;    break;                case BitsPerSample:         /* TIFFSHORT */            if (length == 1)                {                if ((value > 8) || (value <= 0))                    aProblem++;                else bitsPerSample[SINGLE_SAMPLE] = (int) value;                                switch(value)                    {                    case 1:     imageDepth = 1;     break;#if MACINTOSH                    case 2:     imageDepth = 2;     break;#elif WINDOWS                           case 2:     imageDepth = 4;     break;#endif                    case 4:     imageDepth = 4;     break;                    case 8:     imageDepth = 8;     break;                    default:    aProblem++;         break;                    }                if (aProblem)                    {                    AlertMessage(TIFF_BIT_DEPTH);                    }                }            else if (length == 3)                {                file->IOPosition(buffer, 6, value);                CONVERT_CHAR_TO_SHORT(local_short, buffer);                bitsPerSample[RED_SAMPLE] = (int) local_short;                ptr = &buffer[2];                CONVERT_CHAR_TO_SHORT(local_short, ptr);                bitsPerSample[GREEN_SAMPLE] = (int) local_short;                ptr = &buffer[4];                CONVERT_CHAR_TO_SHORT(local_short, ptr);                bitsPerSample[BLUE_SAMPLE] = (int) local_short;                if ((bitsPerSample[RED_SAMPLE] != bitsPerSample[GREEN_SAMPLE])                    && (bitsPerSample[GREEN_SAMPLE] != bitsPerSample[BLUE_SAMPLE])                    && (bitsPerSample[BLUE_SAMPLE] != 8))                    flags |= VARIABLE_BITS;#if MACINTOSH                imageDepth = 32;#elif WINDOWS                   imageDepth = 24;#endif                }            else                {                aProblem++;                anUnresolvedProblem++;                }            break;        case Compression:           /* TIFFSHORT */            if ((value == CCITT_COMPRESSION)||(value == LZW_COMPRESSION)||(value == PACKBITS_COMPRESSION))                flags |= COMPRESS;            else if (value != NO_COMPRESSION)                {                aProblem++;                AlertMessage(TIFF_COMPRESS_ERROR);                }               compression = value;                break;                case PhotometricInterp:     /* TIFFSHORT */            flags &= (~BILEVEL & ~INVERTED);            if (value == 0)                 {                if (bitsPerSample[SINGLE_SAMPLE] > 1)       flags |= (GRAYSCALE | INVERTED);                else                                        flags |= (BILEVEL | INVERTED);                }            else if (value == 1)                {                if (bitsPerSample[SINGLE_SAMPLE] > 1)       flags |= GRAYSCALE;                else                                        flags |= BILEVEL;                }               else if (value == 2)            flags |= RGB_COLOR;            else if (value == 3)            flags |= PALETTE_COLOR;            else                {                aProblem++;                anUnresolvedProblem++;                }            break;        case Threshholding:         /* TIFFSHORT */        case CellWidth:             /* TIFFSHORT */        case CellLength:            /* TIFFSHORT */        case FillOrder:             /* TIFFSHORT */        case DocumentName:          /* ASCII */        case ImageDescription:      /* TIFFASCII */        case Make:                  /* ASCII */        case Model:                 /* TIFFASCII */            /* ignore */    break;                case StripOffsets:          /* TIFFSHORT or _TIFFLONG_ */            if (length > 1)                {                int bSize;                char *tmp;                if (type & TIFFSHORT)                    {                    bSize = length*2;                    if (VA_Length(dataBuf) < bSize) dataBuf->SetLength(bSize);                    tmp = (char *)dataBuf->Use();                    file->IOPosition(tmp, bSize, value);                    for (j = 0; j < length; j++)                        {                        ptr = &tmp[j<<1];                        CONVERT_CHAR_TO_SHORT(local_short, ptr);                        local_long = (long) local_short;                        stripOffsets->Append(&local_long);                        }                    dataBuf->Unuse();                    }                else                    {                    bSize = length*4;                    if (VA_Length(dataBuf) < bSize) dataBuf->SetLength(bSize);                    tmp = (char *)dataBuf->Use();                    file->IOPosition(tmp, bSize, value);                    for (j = 0; j < length; j++)                        {                        ptr = &tmp[j<<2];                        CONVERT_CHAR_TO_LONG(local_long, ptr);                        stripOffsets->Append(&local_long);                        }                    dataBuf->Unuse();                    }                }            else                 {                stripOffsets->Append(&value);                }            break;                    case Orientation:           /* TIFFSHORT */            /* ignore */    break;                case SamplesPerPixel:       /* TIFFSHORT */            samplesPerPixel = (short) value;            break;        case RowsPerStrip:          /* TIFFSHORT or _TIFFLONG_ */            rowsPerStrip = value;            break;        case StripByteCounts:       /* _TIFFSHORT_ or TIFFLONG */            if (length > 1)                {                int bSize;                char *tmp;                if (type & TIFFSHORT)                    {                    bSize = length*2;                    if (VA_Length(dataBuf) < bSize) dataBuf->SetLength(bSize);                    tmp = (char *) dataBuf->Use();                    file->IOPosition(tmp, bSize, value);                    for (j = 0; j < length; j++)                        {                        ptr = &tmp[j<<1];                        CONVERT_CHAR_TO_SHORT(local_short, ptr);                        local_long = (long) local_short;                        if (local_long == 0)                            {                            AlertMessage(TIFF_ZERO_LENGTH_STRIP);                            dataBuf->Unuse();                            dataBuf->dArray();                            return -1;                            }                        stripLengths->Append(&local_long);                        }                    dataBuf->Unuse();                    }                else                    {                    bSize = length*4;                    if (VA_Length(dataBuf) < bSize) dataBuf->SetLength(bSize);                    tmp = (char*) dataBuf->Use();                    file->IOPosition(tmp, bSize, value);                    for (j = 0; j < length; j++)                        {                        ptr = &tmp[j<<2];                        CONVERT_CHAR_TO_LONG(local_long, ptr);                        if (local_long == 0)                            {                            AlertMessage(TIFF_ZERO_LENGTH_STRIP);                            dataBuf->Unuse();                            dataBuf->dArray();                            return -1;                            }                        stripLengths->Append(&local_long);                        }                    dataBuf->Unuse();                    }                }            else if (value != 0)                {                stripLengths->Append(&value);                }            break;                case MinSampleValue:        /* TIFFSHORT */        case MaxSampleValue:        /* TIFFSHORT */            /* ignore */    break;                    case XResolution:           /* TIFFRATIONAL */            file->IOPosition(buffer, 8, value);            CONVERT_CHAR_TO_LONG(xscaleNum, buffer);            ptr = &buffer[4];            CONVERT_CHAR_TO_LONG(xscaleDenom, ptr);            break;        case YResolution:           /* TIFFRATIONAL */            file->IOPosition(buffer, 8, value);            CONVERT_CHAR_TO_LONG(yscaleNum, buffer);            ptr = &buffer[4];            CONVERT_CHAR_TO_LONG(yscaleDenom, ptr);            break;                case PlanarConfig:          /* TIFFSHORT */            if (value == 2) flags |= NASTY_PLANAR_CONFIG;            break;        case PageName:              /* TIFFASCII */            /* ignore */    break;                    case XPosition:             /* TIFFRATIONAL */        case YPosition:             /* TIFFRATIONAL */        case FreeOffsets:           /* TIFFLONG */        case FreeByteCounts:        /* TIFFLONG */        case GrayResponseUnit:      /* TIFFSHORT */        case GrayResponseCurve:     /* TIFFSHORT */        case Group3Options:         /* TIFFLONG */        case Group4Options:         /* TIFFLONG */            break;                    case ResolutionUnit:        /* TIFFSHORT */            /* we want to use this at some later point */            break;                    case PageNumber:            /* TIFFSHORT */            break;                    case ColorResponseCurves:   /* TIFFSHORT */            colorResponseCurves = new(V_Array);            colorResponseCurves->cArray(0, sizeof(RGBColor), 1);            flags |= COLOR_CORRECTION;            if (length > 1)                {                int bSize;                char *tmp;                RGBColor rgbEntry;                int nEntries;                                nEntries = length/3;                if (nEntries > (2<<bitsPerSample[SINGLE_SAMPLE]))                    aProblem++;                else                    {                    colorResponseCurves->SetLength(nEntries);                    VA_Truncate(colorResponseCurves);                    if (type & TIFFSHORT)                        {                        bSize = length*2;                        if (VA_Length(dataBuf) < bSize) dataBuf->SetLength(bSize);                        tmp = (char*) dataBuf->Use();                        file->IOPosition(tmp, bSize, value);                        for (j = 0; j < nEntries; j++)                            {                            ptr = &tmp[j<<1];                            CONVERT_CHAR_TO_SHORT(rgbEntry.red, ptr);                            ptr = &tmp[(j+nEntries)<<1];                            CONVERT_CHAR_TO_SHORT(rgbEntry.green, ptr);                            ptr = &tmp[(j+(nEntries<1))<<1];                            CONVERT_CHAR_TO_SHORT(rgbEntry.blue, ptr);                            colorResponseCurves->Append(&rgbEntry);                            }                        dataBuf->Unuse();                        }                    else                        aProblem++;     /* colorResponseCurves are TIFFSHORT, only */                    }                }            else                aProblem++;            if (aProblem)                anUnresolvedProblem++;            break;                    case Software:              /* TIFFASCII (20 chars) */        case DateTime:              /* TIFFASCII */        case Artist:                /* TIFFASCII */        case HostComputer:          /* TIFFASCII */            /* ignore */    break;                    case Predictor:             /* TIFFSHORT */            if (value == NO_PREDICTION)         /* no prediction */                Prediction = value;            else if (value == HORIZONTAL_DIFF)  /* horizontal differencing */                Prediction = value;            else                {                aProblem++; anUnresolvedProblem++;                }            break;                    case WhitePoint:            /* TIFFRATIONAL */        case PrimaryChromaticities: /* TIFFRATIONAL */            break;                    case ColorMap:              /* TIFFSHORT */            colorMap = new(V_Array);            colorMap->cArray(0, sizeof(RGBColor), 1);            if (length > 1)                {                int bSize;                char *tmp;                RGBColor rgbEntry;                int nEntries;                                nEntries = length/3;                colorMap->SetLength(nEntries);                VA_Truncate(colorMap);                if (type & TIFFSHORT)                    {                    bSize = length*2;                    if (VA_Length(dataBuf) < bSize) dataBuf->SetLength(bSize);                    tmp = (char*) dataBuf->Use();                    file->IOPosition(tmp, bSize, value);                    for (j = 0; j < nEntries; j++)                        {                        ptr = &tmp[j<<1];                        CONVERT_CHAR_TO_SHORT(rgbEntry.red, ptr);                        ptr = &tmp[(j+nEntries)<<1];                        CONVERT_CHAR_TO_SHORT(rgbEntry.green, ptr);                        ptr = &tmp[(j+(2*nEntries))<<1];                        CONVERT_CHAR_TO_SHORT(rgbEntry.blue, ptr);                        colorMap->Append(&rgbEntry);                        }                    dataBuf->Unuse();                    }                else                    aProblem++;     /* colormaps are TIFFSHORT, only */                }            else                aProblem++;            if (aProblem)                anUnresolvedProblem++;            break;                    default:    /* ignore the field */            break;        }        IFDPosition += IFDENTRY_SIZE;    }dataBuf->dArray();/* if we've had a problem, but not an unresolved problem, then return -1now.  Do not get bogged down in other, unimportant considerations like thefollowing tests */if (aProblem && !anUnresolvedProblem)    return(-1);file->IOPosition(buffer, 4, IFDPosition);CONVERT_CHAR_TO_LONG(value, buffer);if (value != 0x0)     {    /* subfiles */    IFDPosition = value;        /* we ignore subfiles */    }    /* alert if there are any problems, like zero-size area or no strips */if ((anUnresolvedProblem) || (((rect.right - rect.left) == 0) ||    ((rect.bottom - rect.top) == 0)) || (0 == VA_Length(stripOffsets)))    {    AlertMessage(TIFF_ERROR);    return(-1);    }/* currently, we're not able to handle variable numbers of bits per pixel */if (flags & VARIABLE_BITS)    {    AlertMessage(TOO_HARD);    return(-1);    }/* it is possible for pre TIFF 5.0 files to lack strip length counts.  We canapproximate the length by subtracting the strip start offset from the size of the file.  This is not the exact size; unless we're going to calculate outthe size of all other image file directories, we can't really approximate thereal strip size (and that would be rather complicated, since we'd have to check to make sure there were no overlapping references -- things like xresolution and yresolution are sometimes overlapped).  But we can guaranteethe length - stripStart is not shorter than the real strip length */if (0 == VA_Length(stripLengths))    {    long    start, lastStart, strpLngth;    int     iterator;            stripOffsets->Get(0, &lastStart);    for (iterator = 1; iterator < VA_Length(stripOffsets); iterator++)        {        stripOffsets->Get(iterator, &start);        strpLngth = start - lastStart;        if (strpLngth <= 0)            {            AlertMessage(TIFF_STRIP_WEIRDNESS);            return -1;            }        stripLengths->Append(&strpLngth);        lastStart = start;        }            rowsPerStrip = (rect.bottom - rect.top)/VA_Length(stripOffsets);    /* set the right number of rows per strip */    rowsPerStrip += (((rect.bottom - rect.top)%VA_Length(stripOffsets))?1:0);        file->IOLength(&start);    strpLngth = start - lastStart;    stripLengths->Append(&strpLngth);    }/* for PALETTE_COLOR, BILEVEL, and GRAYSCALE images we need a palette.One is provided for PALETTE_COLOR (it _must_ be provided); the othertwo we create here, in the basement, without telling anyone (the colormapis necessary for the color conversion routines */if (!colorMap)    {    /* palette color files must have a color map.  Return an error if this is     not so */    if (flags & PALETTE_COLOR)        {        AlertMessage(TIFF_NO_PALETTE);        return(-1);        }    /* if this is a BILEVEL tiff file, add a quickie color map to make     things easier for the depth converter.  Do any color inversion necessary */    else if (flags & BILEVEL)        {        RGBColor    *bwRgb;                colorMap = new(V_Array);        if (colorMap->cArray(2, sizeof(RGBColor), 1))            {            AlertMessage(TXTW_MEMORY);            return(-1);            }        bwRgb = (RGBColor *)colorMap->Use();        if (flags & INVERTED)            {            bwRgb[0].red = bwRgb[0].green = bwRgb[0].blue = 0xFFFF;            bwRgb[1].red = bwRgb[1].green = bwRgb[1].blue = 0x0000;            }        else            {            bwRgb[0].red = bwRgb[0].green = bwRgb[0].blue = 0x0000;            bwRgb[1].red = bwRgb[1].green = bwRgb[1].blue = 0xFFFF;            }                    colorMap->Unuse();        }    /* make up a color map appropriate for the depth of this image */    else if (flags & GRAYSCALE)        {        unsigned int    i, max, gray, increment;        RGBColor    *cMap;        if (flags & INVERTED)	gray = 0xFFFF;		else					gray = 0;        max = 1 << imageDepth;        increment = (unsigned)0xFFFF/(max-1);                colorMap = new(V_Array);        if (colorMap->cArray(max, sizeof(RGBColor), 1))            {            AlertMessage(TXTW_MEMORY);            return(-1);            }        cMap = (RGBColor *)colorMap->Use();                for (i = 0; i < max; i++)            {            cMap[i].red = cMap[i].green = cMap[i].blue = gray;			if (flags & INVERTED)		gray -= increment;			else						gray += increment;            }                /* tidy the ends */		if (flags & INVERTED)			{			cMap[0].red = cMap[0].green = cMap[0].blue = 0xFFFF;        	cMap[max-1].red = cMap[max-1].green = cMap[max-1].blue = 0x0000;			}		else        	{			cMap[0].red = cMap[0].green = cMap[0].blue = 0x0000;        	cMap[max-1].red = cMap[max-1].green = cMap[max-1].blue = 0xFFFF;            }		colorMap->Unuse();                }    }/* lastly, check that we have the same number of strips and offsets */if (VA_Length(stripLengths) != VA_Length(stripOffsets))    {    AlertMessage(TIFF_ERROR);    return -1;    }    return(0);}BaseUncompressor *TIFFReader::MakePixelReader(void){BaseUncompressor    *pixReader=NULL;if (compression == LZW_COMPRESSION)    {    LZWUncompressor     *lzwpreader;    lzwpreader = new(LZWUncompressor);    lzwpreader->cLZWUncompressor(file);    pixReader = lzwpreader;    }else if (compression == PACKBITS_COMPRESSION)    {    PackBitsUncompressor *pbpreader;    pbpreader = new(PackBitsUncompressor);    pbpreader->cPackBitsUncompressor(file);    pixReader = pbpreader;    }else if (compression == CCITT_COMPRESSION)    {    CCITTUncompressor   *ccittpreader;    ccittpreader = new(CCITTUncompressor);    ccittpreader->cCCITTUncompressor(file);    pixReader = ccittpreader;    }else /* if (compression == NO_COMPRESSION) */    {    Uncompressor    *plainReader;    plainReader = new(Uncompressor);    plainReader->cUncompressor(file);    pixReader = plainReader;    }return(pixReader);}ColorConverterBase *TIFFReader::MakePixelConverter(int depth){int             ok, imgDepth;long            width;ColorConverterBase *pixConverter = NULL;width = (long)(rect.right - rect.left);if (flags & RGB_COLOR)	imgDepth = 3 * bitsPerSample[0];else	imgDepth = bitsPerSample[0];if (depth <= 8)    if (flags & RGB_COLOR)        {        TrueToPalConverter  *tpConvert;        tpConvert = new(TrueToPalConverter);        colorMap = new(V_Array);                // make a color map to put things in        colorMap->cArray(1<<depth, sizeof(RGBColor), 1);		tpConvert->cColorConverter(colorMap, imgDepth, depth, width, RGB_ORDER);        pixConverter = tpConvert;        }    else        {        PalToPalConverter   *ppConvert;        ppConvert = new(PalToPalConverter);        ppConvert->cColorConverter(colorMap, imgDepth, depth, width, RGB_ORDER);        pixConverter = ppConvert;        }else if (depth > 8)    if (flags & RGB_COLOR)        {        TrueToTrueConverter *ttConvert;        ttConvert = new(TrueToTrueConverter);        ttConvert->cColorConverter(colorMap, imgDepth, depth, width, RGB_ORDER);        pixConverter = ttConvert;        }    else        {        PalToTrueConverter  *ptConvert;        ptConvert = new(PalToTrueConverter);        ptConvert->cColorConverter(colorMap, imgDepth, depth, width, RGB_ORDER);        pixConverter = ptConvert;        }return(pixConverter);}int     TIFFReader::HorizontalDiff(char *strip, long stripLength, long imageWidth, int depth){char    r,g,b, other;int     err;long    i, j;err = 0;if (flags & RGB_COLOR)    {    i = 0;    j = 0;    r = g = b = 0;    if (depth != 8)        {        AlertMessage(IMAGE_UNSUPPORTED_DEPTH);        return(-1);        }    while (i < stripLength)        {        strip[i] += r;        strip[i+1] += g;        strip[i+2] += b;        r = strip[i++];        g = strip[i++];        b = strip[i++];        j++;        if (j == imageWidth)            {            j = 0;            r = g = b = 0;            }        }    }else if ((flags & GRAYSCALE) || (flags & PALETTE_COLOR))    {    other = 0;    i = 0;    j = 0;    switch (depth)        {        case 1:        case 2:		case 4: 			AlertMessage(IMAGE_UNSUPPORTED_DEPTH);			err = -1;            break;        case 8:            while (i < stripLength)                {                strip[i] += other;                other = strip[i++];                j++;                if (j == imageWidth)                    {                    j = 0;                    other = 0;                    }                }            break;        default:            AlertMessage(IMAGE_UNSUPPORTED_DEPTH);			err = -1;            break;        }    }else    {    AlertMessage(IMAGE_UNSUPPORTED_DEPTH);    err = -1;    }return(err);}intTIFFReader::ReadPixels(BaseUncompressor *pixelReader, ColorConverterBase *pixelConverter){V_Array         *buffer;            /* pointers to the incoming pixels */char            *bufferPtr;int             err, whichStrip;    /* error flag and strip counter */long            lengthOfStrip, startOfStrip;                /* strip length and start point */long            bufSize, bufPos, stripPos, stripSize;       /* counters for strips */long            screenWidth, screenLength, rowByteWidth;long            i,pixOffset, pixChange;RGBColor        rgb;#if MACINTOSHunsigned char   *framebuffer, *loc; /* pointers into the framebuffer */int             xOffset, yOffset;   /* offsets into the buffer */long            screenRowBytes;     /* width of a row */#elif WINDOWSLPBITMAPINFO    bmpi;HDC             HDevCon;Rect            dcRect;char            *imageBuffer;V_Array         *imBuf;V_Array         *bmpHeader;HBITMAP			tempBits;#endif/* init the simple vars */whichStrip = 0;bufPos = stripPos = 0;screenWidth = rect.right - rect.left;screenLength = rect.bottom - rect.top;pixChange = 0;stripSize = rowsPerStrip * screenWidth;buffer = new(V_Array);              /* init the pixel buffer */buffer->cArray(0, sizeof(char), 1);GrowMemory(FALSE);/* set the buffer to be ((width*depth (the width in bits) + 31 (0x1F)) & ~0x19(which effectively divides by 4)) >> 3 (divide by 8 to convert to bytes)This yields the byte-length of a row rounded up to the next multiple of 4 */if (buffer->SetLength(((((screenWidth * imageDepth) + 0x1F) & ~0x1F) * rowsPerStrip) >> 3))    {	GrowMemory(TRUE);			// Dialog box may need the memory 	//GJR 10/26/93    /* we can't allocate that much:  Bye! */    AlertMessage(TXTW_MEMORY);    buffer->dArray();	return -1;    }GrowMemory(TRUE);rowByteWidth = ((screenWidth * screenDepth) + 7) >> 3;#if MACINTOSH/* get x and y offsets, if any, and the row width of the buffer */xOffset=colorQD?-(*screen->metaPort->portPixMap)->bounds.left:-screen->metaPort->portRect.left;yOffset=colorQD?-(*screen->metaPort->portPixMap)->bounds.top:-screen->metaPort->portRect.top;screenRowBytes=colorQD?0x1FFF&(*screen->metaPort->portPixMap)->rowBytes:(*screen->bitmap)->rowBytes;/* add in start and yoffset.  xoffset will come later */framebuffer = xOffset + (unsigned char *)screen->GetBaseAddr() + ((yOffset)*screenRowBytes);#elif WINDOWSbmpHeader = new(V_Array);imBuf = new(V_Array);if (bmpHeader->cArray(1, (sizeof(BITMAPINFOHEADER) + 256*sizeof(RGBQUAD)), 1) ||	imBuf->cArray(((rowByteWidth + 0x3) & ~0x3), sizeof(RGBQUAD), 1))        {        /* we can't allocate that much:  Bye! */        AlertMessage(TXTW_MEMORY);        imBuf->dArray();        bmpHeader->dArray();        return -1;        }bmpi = (LPBITMAPINFO) bmpHeader->Use();imageBuffer = (char *) imBuf->Use();memset(bmpi, 0, sizeof(BITMAPINFOHEADER) + 256*sizeof(RGBQUAD));bmpi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);bmpi->bmiHeader.biWidth = screen->wBmWidth; //screenWidth;bmpi->bmiHeader.biHeight = screen->wBmHeight; //screenLength;bmpi->bmiHeader.biPlanes = 1;bmpi->bmiHeader.biBitCount = screenDepth;bmpi->bmiHeader.biCompression = BI_RGB;HDevCon = screen->GetMetaPort(&dcRect);screen->SetMetaPort();if (colorMap)    {    RGBColor    *rgb;    rgb = (RGBColor *)VA_Abuse(colorMap);    for (i = 0; i < VA_Length(colorMap); i++)        {        bmpi->bmiColors[i].rgbRed = rgb[i].red;        bmpi->bmiColors[i].rgbGreen = rgb[i].green;        bmpi->bmiColors[i].rgbBlue = rgb[i].blue;        bmpi->bmiColors[i].rgbReserved = 0;        }    }#endif                /* init the strip things */stripOffsets->Get(whichStrip, &startOfStrip);stripLengths->Get(whichStrip++, &lengthOfStrip);bufSize = pixelReader->ReadPixels(buffer, startOfStrip, lengthOfStrip, stripSize);bufferPtr = (char *)  buffer->Use();/* do the horizontal diff */if (Prediction == HORIZONTAL_DIFF)    HorizontalDiff(bufferPtr, bufSize, screenWidth, bitsPerSample[0]);    #if WINDOWS     // jca 10 Dec 93// We're not supposed to have the bitmap selected//when we do SetDIBits calls, so let's unselect it.tempBits = SelectObject(HDevCon, screen->oldBitmap);ASSERT(tempBits == screen->bitmap);#endiffor(i=0; bufSize > -1 && i<screenLength;i++)    {#if MACINTOSH    loc = framebuffer + (i*screenRowBytes);#endif    pixOffset = 0;    while(pixChange > -1 && pixOffset < rowByteWidth)        {        /* check meter */        if ((i&0xFF) == 0)#if WINDOWS            if (MeterUpdate(VGetTime())) #elif MACINTOSH            if (MeterUpdate(TickCount())) #endif                pixChange = -2;         /* do the conversion and put the results in the buffer */#if MACINTOSH        pixChange = pixelConverter->Convert(bufferPtr, bufSize, &bufPos, (char *)loc, rowByteWidth, &pixOffset); #elif WINDOWS		pixChange = pixelConverter->Convert(bufferPtr, bufSize, &bufPos, (char *)imageBuffer, rowByteWidth, &pixOffset);        		SetDIBits(HDevCon, tempBits, screenLength - i-1, 1,            imageBuffer, bmpi, DIB_RGB_COLORS);#endif        stripPos += pixChange;                                /* check if we need more pixels */        if (bufSize == bufPos)            {            if (stripPos == stripSize)                {                stripOffsets->Get(whichStrip, &startOfStrip);                stripLengths->Get(whichStrip++, &lengthOfStrip);                stripPos = 0;                }            buffer->Unuse();			bufSize = pixelReader->ReadPixels(buffer, startOfStrip, lengthOfStrip, stripSize);            bufPos = 0;            bufferPtr = (char *) buffer->Use();                        if (Prediction == HORIZONTAL_DIFF)                HorizontalDiff(bufferPtr, bufSize, screenWidth, bitsPerSample[0]);            }        }        if (pixChange < -1)        bufSize = -1;	}#if WINDOWSSelectObject(HDevCon, tempBits);         // jca 10 Dec 93#endifif ((bufSize > -1) && (i != screenLength))    {    AlertMessage(TIFF_ERROR);    bufSize = -1;    }#if WINDOWSscreen->UnsetMetaPort();screen->ReleaseMetaPort(HDevCon);imBuf->Unuse();bmpHeader->Unuse();imBuf->dArray();bmpHeader->dArray();#endifbuffer->Unuse();buffer->dArray();return(((bufSize < 0)?bufSize:0));}// jca 17 Sept 93.  }#endif // VWT