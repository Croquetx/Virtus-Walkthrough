/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	John C. Alspaugh * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VError.h"#include "VIO.h"#include "VFile.h"#include "VDisplay.h"#include "VArray.h"#include "VDialog.h"#include "VGUtil.h"#include "VGraphic.h"#include "VMemutil.h"#include "AppText.h" #include "ImgHandl.h"#include "BmpHandl.h"#include "VColor.h"/*	BMP files come in many unpleasant flavors.  Currently (as of	the Nov 10, 1992 "DIB FormatExtensions for Microsoft Windows"	document) there are 1, 4, 8, 16, 24, and 32-bit DIB's.	16 and 32-bit are new formats, so I'm ignoring them for now.	There are two standard Windows-supported compression modes;	one for 4-bit DIB's (RLE_4) and one for 8-bit DIB's (RLE_8).	There are also a lot of newer, special-purpose methods for	video compression, JPEG, MPEG, and all that jazz.  We don't    support 'em.  */intBMPReader::cBMPReader(struct V_Buffer *theFile){	file = theFile;	xscaleNum = yscaleNum = DEFAULT_IMAGE_SCALE;	xscaleDenom = yscaleDenom = 1;	inSide = outSide = 0;    useFiller = 0;	return(0);}voidBMPReader::dBMPReader(void){	file = NULL;	screen = NULL;	delete(this);}	intBMPReader::ReadImage(int depth){#if WINDOWS	BITMAPFILEHEADER	fileHeader;	BITMAPINFO			*bmapInfo;	V_Array				*bmapStore;	Rect				r;    long				scanLength;	/* read file header */	file->IOType(&fileHeader.bfType, IO_SHORT_I);	file->IOType(&fileHeader.bfSize, IO_LONG_I);	file->IOType(&fileHeader.bfReserved1, IO_SHORT_I);	file->IOType(&fileHeader.bfReserved2, IO_SHORT_I);	file->IOType(&fileHeader.bfOffBits, IO_LONG_I);	if ((fileHeader.bfType != BFT_ICON) &&		(fileHeader.bfType != BFT_BITMAP) &&		(fileHeader.bfType != BFT_CURSOR))		{		ReportBMPError(UNRECOGNIZED_BMP_TYPE);			{			return(-1);            }		}	/* allocate space for a 8-bit deep bitmapinfo, since it is the	largest thing we could come across */	bmapInfo = (BITMAPINFO *) NewHandle(sizeof(BITMAPINFOHEADER) + 256*sizeof(RGBQUAD));	if (!bmapInfo)		{		AlertMessage(TXTW_MEMORY);		return(-1);		}	/* prep the memory */	memset(bmapInfo, 0, (sizeof(BITMAPINFOHEADER) + 256*sizeof(RGBQUAD)));	/* get size of next structure, because that tells what	kind of structure it is */	file->IOType(&(bmapInfo->bmiHeader.biSize), IO_LONG_I);	if (bmapInfo->bmiHeader.biSize == sizeof(BITMAPCOREHEADER))		{		/* interpret the BITMAPCOREHEADER in the file as a		BITMAPINFOHEADER */		if (ReadBITMAPCOREHeader(fileHeader.bfOffBits, bmapInfo))			{            DisposHandle(bmapInfo);			return(-1);            }		}	else if (bmapInfo->bmiHeader.biSize == sizeof(BITMAPINFOHEADER))		{        /* interpret the BITMAPINFOHEADER in the file */		if (ReadBITMAPINFOHeader(fileHeader.bfOffBits, bmapInfo))        	{			DisposHandle(bmapInfo);			return(-1);            }		}	else		{		ReportBMPError(BMP_UNRECOGNIZED_FORMAT);		DisposHandle(bmapInfo);		return(-1);		}	/* We don't read compression well.  Set the internal var, and	change the header parameter */	compression = bmapInfo->bmiHeader.biCompression;	bmapInfo->bmiHeader.biCompression = BI_RGB;    /* make a V_Array version of the color map */	/* allocate the offscreen.  Allocate the requested size or	the smaller of [the monitor depth, the BMP depth] */	r.left = r.top = 0;	r.right = bmapInfo->bmiHeader.biWidth;	r.bottom = bmapInfo->bmiHeader.biHeight;	depth = bmapInfo->bmiHeader.biBitCount;	if (CreateScreen(&r, depth))		{		AlertMessage(TXTW_MEMORY);        DestroyScreen();		DisposHandle(bmapInfo);		return(-1);        }	/* should we pad at the end of scanlines? */	if (compression == BI_RGB)		{        /* 0x1F == 31.  We want to make the length a multiple of four */		scanLength = (((bmapInfo->bmiHeader.biWidth * depth) + 0x1F) & ~0x1F)>>3;		if ((scanLength > (bmapInfo->bmiHeader.biWidth * depth + 7)>>3) &&			(fileHeader.bfSize >= fileHeader.bfOffBits + scanLength*bmapInfo->bmiHeader.biHeight))			useFiller = scanLength - ((bmapInfo->bmiHeader.biWidth * depth) + 0x7)>>3;        else useFiller = 0;        }    /* go to the start of the bitmap data */	file->IOSetPosition((ULong)fileHeader.bfOffBits);	/* read in the bitmap data */	if (ReadBits(bmapInfo))		{		DestroyScreen();		DisposHandle(bmapInfo);		return(-1);        }	DisposHandle(bmapInfo);// do not call DestroyScreen();  the screen will be used by someone else later....	return(0);#elif MACINTOSH	return(-1);#endif}#if WINDOWSintBMPReader::ReadBITMAPINFOHeader(ULong headerSize, BITMAPINFO *bmapInfo){	file->IOType(&(bmapInfo->bmiHeader.biWidth), IO_LONG_I);	file->IOType(&(bmapInfo->bmiHeader.biHeight), IO_LONG_I);	file->IOType(&(bmapInfo->bmiHeader.biPlanes), IO_SHORT_I);	file->IOType(&(bmapInfo->bmiHeader.biBitCount), IO_SHORT_I);	file->IOType(&(bmapInfo->bmiHeader.biCompression), IO_LONG_I);	file->IOType(&(bmapInfo->bmiHeader.biSizeImage), IO_LONG_I);	file->IOType(&(bmapInfo->bmiHeader.biXPelsPerMeter), IO_LONG_I);	file->IOType(&(bmapInfo->bmiHeader.biYPelsPerMeter), IO_LONG_I);	file->IOType(&(bmapInfo->bmiHeader.biClrUsed), IO_LONG_I);	file->IOType(&(bmapInfo->bmiHeader.biClrImportant), IO_LONG_I);	/* read in the color map */	if (bmapInfo->bmiHeader.biBitCount <= 8)		{		int i;        long colorsUsed;        RGBQUAD	color;		// the number of colors used may be less than the max number for that bitdepth		colorsUsed = bmapInfo->bmiHeader.biClrUsed;		if (colorsUsed == 0) // all colors used			colorsUsed = (1 << bmapInfo->bmiHeader.biBitCount);		/* make sure the color map is the right size */		if (headerSize < (sizeof(BITMAPINFOHEADER) +			(colorsUsed * sizeof(RGBQUAD)) +			sizeof(BITMAPFILEHEADER)))			{			ReportBMPError(BMP_CMAP_SIZE);			return(-1);			}		for (i = 0; i < 1 << bmapInfo->bmiHeader.biBitCount; i++)			{			file->IOType((ULong *)&color, IO_LONG_I);            bmapInfo->bmiColors[i].rgbRed = color.rgbRed;		    bmapInfo->bmiColors[i].rgbGreen = color.rgbGreen;			bmapInfo->bmiColors[i].rgbBlue = color.rgbBlue;			}		}	return(0);}intBMPReader::ReadBITMAPCOREHeader(ULong headerSize, BITMAPINFO *bmapInfo){	short	bcWidth, bcHeight, bcPlanes, bcBitCount;	file->IOType(&bcWidth, IO_SHORT_I);	file->IOType(&bcHeight, IO_SHORT_I);	file->IOType(&bcPlanes, IO_SHORT_I);	file->IOType(&bcBitCount, IO_SHORT_I);	bmapInfo->bmiHeader.biWidth = (long) bcWidth;	bmapInfo->bmiHeader.biHeight = (long) bcHeight;	bmapInfo->bmiHeader.biPlanes = bcPlanes;	bmapInfo->bmiHeader.biBitCount = bcBitCount;	/* set the bmapInfo->bmiHeader.biSize field to be the real size, not the coreheader size */	bmapInfo->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);	/* read in the color map */	if (bmapInfo->bmiHeader.biBitCount <= 8)		{		int i;        RGBTRIPLE	color;		/* make sure the colormap is the right size */		if (headerSize < (sizeof(BITMAPCOREHEADER) +			((1 << bmapInfo->bmiHeader.biBitCount) * sizeof(RGBTRIPLE)) +			sizeof(BITMAPFILEHEADER)))			{			ReportBMPError(BMP_CMAP_SIZE);			return(-1);			}		for (i = 0; i < 1 << bmapInfo->bmiHeader.biBitCount; i++)			{			file->IOData(&color, 3);            bmapInfo->bmiColors[i].rgbRed = color.rgbtRed;		    bmapInfo->bmiColors[i].rgbGreen = color.rgbtGreen;			bmapInfo->bmiColors[i].rgbBlue = color.rgbtBlue;			}		}	return(0);}intBMPReader::ReadBits(BITMAPINFO *bmapInfo){	int err = noErr;	ULong localRowSize, toRead, fPos;	int 	i, bDepth;	char	*bits, *compr;	Handle	bitbuf, compressed;	RGBColor *rgb;	ULong nLinesMax, nLinesLeft, nLinesThisTime;// ->	int		uncompBSize, bPos, uncompBPos, allOk;	int		widthOfOffscreen;	long	nScanLines, nLinesToDo, bmpScanSize;	HDC		port;    HBITMAP	tempBits;    Rect	r;	inSide = outSide = 0;	// bmpScanSize can be long-word aligned, or not.  Depends on the bmp we're reading.	bmpScanSize = LWORD_ALIGN(bmapInfo->bmiHeader.biBitCount * bmapInfo->bmiHeader.biWidth);	/*set the internals to use the aligned sizes */	widthOfOffscreen = (((bmapInfo->bmiHeader.biBitCount * ScreenWidth()) + 0x1F) & ~0x1F) >> 3;	bmapInfo->bmiHeader.biWidth = ScreenWidth();    // adjust for the alignment within the offscreen	bmapInfo->bmiHeader.biHeight = ScreenHeight();// <-	bDepth = bmapInfo->bmiHeader.biBitCount;	if (CheckDepthCompression(bDepth))		return(-1);    // bad depth/compression mode	nLinesToDo = bmapInfo->bmiHeader.biHeight;	localRowSize = ((bmapInfo->bmiHeader.biWidth*bDepth)+7)/8;	// Bad Drivers Need matching widths													//  tween DIB and DDB   //GJR 11/22/93//  !ELVIS - Does this work for 4x1 Planar organization?  NO. ONLY sizes matching display.	// try to allocate the largest possible buffer for the data.	if (compression == BI_RGB)   // only speed up uncompressed rows    	{		nLinesMax = nLinesToDo;		if (useFiller)	bmpScanSize - useFiller; /* adjust bmpScanSize */		}	else    	{		nLinesMax = 1;		// compression is too messy to speed up.        }       // Avoid the 64K edge.	while ((localRowSize*nLinesMax >= 65000L) && (nLinesMax > 0))		nLinesMax /= 2;	bitbuf = NewHandle(localRowSize*nLinesMax);	// Keep trying to get a big buffer.  Halve the requested buffer	// size each time until either we get a buffer or the size is	// less than a single scan line.	while ((bitbuf == NULL) && (nLinesMax > 0))		{		nLinesMax /= 2;		bitbuf = NewHandle(widthOfOffscreen*nLinesMax);		}	if ((bitbuf == NULL) || (nLinesMax <= 0))	err = err?err:-1;	nLinesLeft = nLinesToDo;	// now get the bits, and stuff them into the bitmap.	if (!err)		{		// if compression is used, allocate a buffer for that		if (compression != BI_RGB)			{			uncompBSize = localRowSize;			compressed = NewHandle(uncompBSize);			if (compressed == NULL)				{   // out of memory!				AlertMessage(TXTW_MEMORY);				DisposHandle(bitbuf);                bitbuf = NULL;				err = -1;                return(err);				}			else				{				HLock(compressed);				compr = (char *) HDeref(compressed);				}			}		else        	compressed = NULL;		HLock(bitbuf);		bits = (char *) HDeref(bitbuf);		memset(bits, 0, localRowSize*nLinesMax);  // clear the buffer		toRead = min(localRowSize, bmpScanSize);        fPos = file->IOGetPosition();		if (compressed != BI_RGB)			{			err = err?err:file->IOData(compr, uncompBSize);   // read the scan line _now_			uncompBPos = 0;			}		err = err ? err : InitBitmap(&port, &tempBits, bmapInfo);		/* Get the scans, in clumps, and then write them.  Note that		   the scans are retrieved and written from bottom to top.		*/		while (nLinesLeft > 0 && !err)			{            // figure out how many lines to get			if (nLinesLeft >= nLinesMax)				{				nLinesThisTime = nLinesMax;				nLinesLeft -= nLinesMax;				}			else				{				nLinesThisTime = nLinesLeft;				nLinesLeft = 0;                }			// get the scans            bPos = 0;			for (i = 0; i < nLinesThisTime && !err; i++)				{				switch(compression)					{					case BI_RGB: // easy case						err = err?err:file->IOData((void *)(&bits[i*widthOfOffscreen]), bmpScanSize);						fPos += bmpScanSize;						file->IOSetPosition(fPos);                        break;					case BI_RLE4:					case BI_RLE8:						/* allOk < 0 if there's an error						 * allOk == 0  if we need more data to finish the scan						 * allOk > 0  if we've uncompressed the scan						 */						allOk = 0;						outSide = 0;						bPos = 0;						while ((allOk == 0) && (err == 0))                        	{ 							allOk = DecompressRLE(compr, &uncompBPos, uncompBSize, bits, &bPos, bmpScanSize, bDepth);							if (allOk < 0)								err = -1;							if (uncompBPos == uncompBSize)								{								file->IOData(compr, uncompBSize);								uncompBPos = 0;								inSide = 0;								}                            }						break;					default:						err = -1;                        break;					}					if (!(i & 0x0F))		VSetCursor(vCursorEarth);				}			if (!err)				err = WriteToBitmap(&port, &tempBits, nLinesToDo-(nLinesLeft+nLinesThisTime),		   			nLinesThisTime, bits, bmapInfo);			}		CleanUpBitmap(&port, &tempBits, bmapInfo);		HUnlock(bitbuf);		DisposHandle(bitbuf);		if (compressed)			{			HUnlock(compressed);            DisposHandle(compressed);            }	}    return(err);}/* Note that the uncompressed buffer will _always_ be the length of along-padded row.  It will never, ever, have leftovers.  The input buffer,though, may have leftovers (because the compressed rows may be anarbitrary length)*/intBMPReader::DecompressRLE(char *compressed, int *comprPos, int comprLength,char *uncompressed, int *uncomprPos, int uncomprLength, int rleDepth){	int val, timeToGo, results;	timeToGo = FALSE;	/* if there are any leftovers */	if (leftOvers)		{		switch (leftOversState)			{			case COPY_STATE:				if ((leftOversCount == 0) && (leftOversFiller == 0))					{					if (*comprPos < comprLength)						{						leftOversCount = compressed[(*comprPos)++];						if (rleDepth == 4)							leftOversFiller = ((leftOversCount + 1)/2)%2;						else							leftOversFiller = leftOversCount % 2;						}					else						{						ReportBMPError(BMP_UNCOMPRESS_ERROR);						return(-1);                        }					}				results = DoCopyBytes(compressed, comprLength, comprPos, uncompressed,					uncomprLength, uncomprPos, leftOversCount, leftOversFiller, rleDepth);				if (results >= 0)					{     // things are still ok					if ((results < leftOversCount) || leftOversFiller)	// LeftOvers!						{   // do we need to set a leftovers state?                        SetLeftOversState(COPY_STATE, leftOversCount - results);						}					else                    	ClearLeftOversState();					}				else	/* oops! */                	{					ReportBMPError(BMP_UNRECOGNIZED_FORMAT);					timeToGo = -1;					} 				break;			case REPLICATE_STATE:				results = DoReplicateBytes(compressed, comprLength, comprPos, uncompressed,					uncomprLength, uncomprPos, leftOversCount, rleDepth);				if (results > 0)					{                    ClearLeftOversState();                	}				else if (results == 0)					{                	SetLeftOversState(REPLICATE_STATE, 1); // only 1 byte used in a replicate                	}				else // if (result < 0)            		{					ReportBMPError(BMP_UNRECOGNIZED_FORMAT);					timeToGo = -1;					}				break;			case DELTA_STATE:				//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!				// 13 Dec 93 jca for now, do an error.				ReportBMPError(BMP_ICKY_COMPRESSION);            	timeToGo = -1;            	break;			}		}	while ((*comprPos < comprLength) && !timeToGo)		{		if ((unsigned char) compressed[*comprPos] == 0)    /* absolute mode */			{			(*comprPos)++;			if (*comprPos < comprLength)            	{				val = 0xFF & compressed[(*comprPos)++];				if (val >= 0x03)	/* copy bytes */					{					int filler;					if (rleDepth == 4) 	filler = ((((val+1)/2)&0x1)?1:0);					else				filler = ((val&0x01)?1:0);					results = DoCopyBytes(compressed, comprLength, comprPos, uncompressed,						uncomprLength, uncomprPos, val, filler, rleDepth);					if (results >= 0)						{     // things are still ok						if ((results < val) || leftOversFiller)	// LeftOvers!							{   // do we need to set a leftovers state?                        	SetLeftOversState(COPY_STATE, val - results);                        	}						}					else	/* oops! */                		{						ReportBMPError(BMP_UNRECOGNIZED_FORMAT);						timeToGo = -1;                    	}					}				else    /* escape codes */					{					results = DoEscapeCodes(compressed, comprLength, comprPos, uncompressed,						uncomprLength, uncomprPos, val);					if (results > 0)		timeToGo = 1;					}				}			else				{				SetLeftOversState(COPY_STATE, 0);                timeToGo = 1;                }			}		else  /* encoded mode */			{			val = 0xFF & compressed[(*comprPos)++];			results = DoReplicateBytes(compressed, comprLength, comprPos, uncompressed,				uncomprLength, uncomprPos, val, rleDepth);			if (results > 0)				{                }			else if (results == 0)				{				SetLeftOversState(REPLICATE_STATE, 1);  // only one byte used in a replicate                }			else // if (result < 0)            	{				ReportBMPError(BMP_UNRECOGNIZED_FORMAT);				timeToGo = -1;				}			}		}	return(((timeToGo)?timeToGo:0));}intBMPReader::CheckDepthCompression(int validDepth){	int	err = noErr;	switch(validDepth)       // check out the depths and compression		{		case 1:			if (compression != BI_RGB)				{				ReportBMPError(BMP_ICKY_COMPRESSION);				err = -1;                }			break;		case 4:			if ((compression != BI_RGB) && (compression != BI_RLE4))				{				ReportBMPError(BMP_ICKY_COMPRESSION);				err = -1;                }			break;		case 8:			if ((compression != BI_RGB) && (compression != BI_RLE8))				{				ReportBMPError(BMP_ICKY_COMPRESSION);				err = -1;                }			break;		case 16:		case 24:		case 32:			if (compression != BI_RGB)				{				ReportBMPError(BMP_ICKY_COMPRESSION);				err = -1;                }			break;		default:			ReportBMPError(BMP_NASTY_DEPTH);			err = -1;            break;		}	return(err);}/* 13 Dec 93 jcaReport the error, with the name of the file it failed on*/voidBMPReader::ReportBMPError(char *errStr){	char fname[64], errorMsg[256];	if (file->GetBufferType() == V_FILETYPE)    	{		((V_File*)file)->GetFName(fname);		}	else		fname[0] = 0;    sprintf(errorMsg, errStr, fname);	AlertMessage(errorMsg);}/* *  CreateScreen and DestroyScreen help get us some datastructure-independence. *  BMPReader can be derived to use any offscreen subclass, like the *  V_Pixel8 (which is why I've done this).		jca 18 Dec 93 */intBMPReader::CreateScreen(Rect *r, int d){	int result;	screen = new(V_Offscreen);	result = screen->cOffscreen(r, d, 0L, 0L);    return(result);}intBMPReader::DestroyScreen(){	if (screen)	screen->dOffscreen();	screen = NULL;	return(0);}/* *  InitBitmap, WriteToBitmap, CleanUpBitmap all try to help with the *  offscreen-independence. They all mask the ugly details of offscreens *  V_Pixel8s, and so on. * *  InitBitmap and CleanUpBitmap take pointers to the bit array and the * 	graphics port. (Init gets them, CleanUp removes them) * 	 */intBMPReader::InitBitmap(VCGrafPort *port, VPictHandle *bits, BITMAPINFO *bmpi){	Rect r;	*port = screen->GetMetaPort(&r);   // get the port	screen->SetMetaPort();             // set the metaport to ensure things work	// select the bitmap out of the offscreen, and ASSERT that	// it's not gone peculiar.	if (*port)    // no port, no select.    	{		*bits = SelectObject(*port, screen->oldBitmap);		ASSERT(*bits == screen->bitmap);        }	if (*port && (*bits == screen->bitmap))	return(0);	else		{		ReportBMPError(BMP_BITMAP_ERROR);		return(-1);        }}intBMPReader::CleanUpBitmap(VCGrafPort *port, VPictHandle *bits, BITMAPINFO *bmpi){	if (*port)	SelectObject(*port, *bits);  // if we fail, things are terrible.	screen->UnsetMetaPort();	screen->ReleaseMetaPort(*port);    return(0);}intBMPReader::WriteToBitmap(VCGrafPort *port, VPictHandle *bits, long start,long toDo, char *buffer, BITMAPINFO *specific){	long linesDone;	linesDone = (long)SetDIBits(*port, *bits, start,toDo, buffer,		specific, DIB_RGB_COLORS);	if (linesDone != toDo)		{		ReportBMPError(BMP_BITMAP_ERROR);		return(-1);		}	else		return(0);}/* read da bytes from one buffer to another.  The only side-effect is that it setsleftOversFiller */intinline BMPReader::DoCopyBytes(char *in, int inLength, int *inPos, char *out, int outLength, int *outPos, int get, int filler, int depth){	int nPixels, useFiller;	/* we copy the next (compressed[pos]) bytes directly.    Note that the run must be word-aligned, so if the run	has an odd number of bytes, there is a place-holder	tacked on the end */	if (depth == 4)		{		unsigned char pix;		int i, inP, outP;		inP = *inPos;		outP = *outPos;		nPixels = (inLength - inP)*2 + ((inSide&0x1)?1:0);		if (nPixels >= get)			{			nPixels = get;            useFiller = 1;			}		else        	{			useFiller = 0;			if (!leftOversFiller)	leftOversFiller = filler;            }		if (outP*2 + nPixels + ((outSide&0x1)?1:0) <= outLength*2)        	{				for (i = 0; i < nPixels; i++)				{				pix = GET_NEXT_PIXEL(inP, inSide, in);            	STUFF_PIXEL(out, outP, outSide, pix);				}			if (useFiller)				{				if (inSide & 0x01) inP++;   // round up to full byte					inSide = 0;					// reset				inP += filler;                leftOversFiller = 0;				}			*inPos = inP;			*outPos = outP;            }		else 	/* give a warning and stop.  This BMP file has	       	 	too many pixels on this line */			{			return(-1);			}		}	else		{		/* check that we have all the bytes of the run in		the buffer */		if (*inPos + get + filler <= inLength)    		{			nPixels = get;        	useFiller = 1;        	}		else  /* if we do not have all the bytes, only copy			the bytes we have, and set flags to indicate there			were bytes uncopied */			{			nPixels = inLength - *inPos;			useFiller = 0;        	if (!leftOversFiller) leftOversFiller = filler;			}            			/* if we have not exceeded the number of pixels for this		row, copy the bytes */		if (*outPos + nPixels <= outLength)    		{			memcpy(&out[*outPos], &in[*inPos], nPixels);			*outPos += nPixels;			*inPos += nPixels;			if (useFiller)            	{				*inPos += filler;				leftOversFiller = 0;				}			}		else 	/* give a warning and stop.  This BMP file has	       	 	too many pixels on this line */			{			return(-1);			}		}    return(nPixels);}intinline BMPReader::DoEscapeCodes(char *in, int inLength, int *inPos, char *out, int outLength, int *outPos, int value){	int x,y;	if (value == 0)   /* EOL */		{        inSide = outSide = 0;		return(1);        }	else if (value == 1)  /* EOF */    	{		inSide = outSide = 0;		return(1);        }	else               /* DELTA */		{		if (!leftOvers || (leftOvers && (leftOversCount == 2)))        	{			if (*inPos < inLength)				{            	x = in[(*inPos)++];				if (*inPos < inLength)					{					y = in[(*inPos)++];					//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!                	return(1);					}				else					{    // got the x, but not the y                	return(0);                	}				}			else				{ 	// it's a delta, but we can't get to the x or y skips            	return(0);				}			}		else if ((leftOvers) && (leftOversCount == 1))			{ 			if (*inPos < inLength)				{				y = in[(*inPos)++];                //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!                return(1);				}			else				{    // got the x, but not the y                return(0);				}		   }		}    return(0);}intinline BMPReader::DoReplicateBytes(char *in, int inLength, int *inPos, char *out, int outLength, int *outPos, int val, int depth){	unsigned char 	pix;    int i;	if (depth == 4)		{		int inP, outP;		inP = *inPos;		outP = *outPos;		if (val + outP*2 + ((outSide&0x1)?1:0) > outLength*2)			{  // this should never happen; uncompressed should always be the size of the strip  			return(-1);        	}		if (inP < inLength)			{ 	// then all ok			for (i = 0; i < val; i++)				{				pix = EXTRACT(inP, inSide, in);    // get but don't increment				STUFF_PIXEL(out, outP, outSide, pix);				}				(*inPos)++;                *outPos = outP;			return(val);			}		else			{            return(0);	// have to save state			}        }	else  // depth == 8		{		if (val + *outPos > outLength)			{  // this should never happen; uncompressed should always be the size of the strip  			return(-1);        	}		if (*inPos < inLength)			{ 	// then all ok            pix = in[(*inPos)++];			for (i = 0; i < val; i++)				{				out[(*outPos)++] = pix;				}        	return(val);			}		else			{        	return(0);  // have to save state			}    	}}// BILBIL - no inline functions w/ Think CV_Pixel8 *BMPReaderPixel8::GetScreen(void){	return(screen8);}intBMPReaderPixel8::CreateScreen(Rect *r, int d){	screen8 = new(V_Pixel8);	return(screen8->cPixel8(r, d, NULL, NULL));}intBMPReaderPixel8::DestroyScreen(void){	if (screen8)	screen8->dPixel8();    screen8 = NULL;    return(0);}intBMPReaderPixel8::InitBitmap(VCGrafPort *port, VPictHandle *bits, BITMAPINFO *bmpi){	long *clr;    RGBColor rgb;	int i, nColors, bitDepth;#if 0	// buggy.  Very buggy.  jca 31 Dec 93	bitDepth = bmpi->bmiHeader.biBitCount;	screen8->SetMetaPort();	if (bitDepth <= 8)    	{		tranTable = new(V_Array);		tranTable->cArray(256, sizeof(long), 1);		translation = (char *) tranTable->Use();        clr = (long *)((ULong)bmpi + (ULong)bmpi->bmiHeader.biSize);		nColors = bmpi->bmiHeader.biClrUsed;        if (nColors == 0)	nColors = 1 << bitDepth;        			if (bitDepth == 1)			{			rgb.red = GetRValue(clr[0]) << 8;			rgb.green = GetGValue(clr[0]) << 8;			rgb.blue = GetBValue(clr[0]) << 8;			translation[0] = GetClosestColor(&rgb);			rgb.red = GetRValue(clr[1]) << 8;			rgb.green = GetGValue(clr[1]) << 8;			rgb.blue = GetBValue(clr[1]) << 8;			translation[1] = GetClosestColor(&rgb);            // set up these for speed, so we won't have to shift			translation[4] = translation[2] = translation[1];			translation[16] = translation[8] = translation[1];			translation[64] = translation[32] = translation[1];			translation[128] = translation[1];			}		else if (bitDepth == 4)			{			for (i = 0; i < nColors; i++)				{  // again, to avoid shifting				rgb.red = GetRValue(clr[i]) << 8;				rgb.green = GetGValue(clr[i]) << 8;				rgb.blue = GetBValue(clr[i]) << 8;				translation[i*16] = translation[i] = GetClosestColor(&rgb);                }			}		else if (bitDepth == 8)			{			for (i = 0; i < nColors; i++)				{  // again, to avoid shifting				rgb.red = GetRValue(clr[i]) << 8;				rgb.green = GetGValue(clr[i]) << 8;				rgb.blue = GetBValue(clr[i]) << 8;				translation[i] = GetClosestColor(&rgb);                }			}		}	else		{		tranTable = NULL;		translation = NULL;        }	port = NULL;    // doesn't matter	bits = NULL;#endif	return(0);}intBMPReaderPixel8::CleanUpBitmap(VCGrafPort *port, VPictHandle *bits, BITMAPINFO *bmpi){#if 0	// buggy.  Very buggy.  jca 31 Dec 93	screen8->UnsetMetaPort();	if (tranTable)		{		translation = NULL;		tranTable->Unuse();        tranTable->dArray();        }#endif       	return(0);}intBMPReaderPixel8::WriteToBitmap(VCGrafPort *port, VPictHandle *bitmap, long toStart, long toDo, char *bits, BITMAPINFO *special){	RGBColor rgb;	int it, bitDepth, err, toRead;	long i,j,k;	ULong rowWidth;	char *bitsPtr;	bitDepth = special->bmiHeader.biBitCount;    toRead = ScreenWidth();	rowWidth = ((special->bmiHeader.biWidth*bitDepth)+7)/8;	// dib row width.  bits is a multiple	bitsPtr = bits;	err = 0;#if 0	// buggy.  Very buggy.  jca 31 Dec 93	switch (bitDepth)		{		case 1:			for (i = toStart; i < toDo + toStart; i++)				{				for (j = 0, it = 0, k = 0; j < toRead; j++, it++)					{  // translation values are all pre-shifted					if (it == 0)		screen8->lpbBmRowAddresses[i][j] = translation[bitsPtr[k]&0x01];					else if (it == 1)	screen8->lpbBmRowAddresses[i][j] = translation[bitsPtr[k]&0x02];					else if (it == 2)	screen8->lpbBmRowAddresses[i][j] = translation[bitsPtr[k]&0x04];					else if (it == 3)	screen8->lpbBmRowAddresses[i][j] = translation[bitsPtr[k]&0x08];					else if (it == 4)	screen8->lpbBmRowAddresses[i][j] = translation[bitsPtr[k]&0x010];					else if (it == 5)	screen8->lpbBmRowAddresses[i][j] = translation[bitsPtr[k]&0x020];					else if (it == 6)	screen8->lpbBmRowAddresses[i][j] = translation[bitsPtr[k]&0x040];					else {				screen8->lpbBmRowAddresses[i][j] = translation[bitsPtr[k]&0x080]; k++; it = -1;}					}				bitsPtr += rowWidth;				}			break;		case 4:			for (i = toStart; i < toDo + toStart; i++)            	{				for (j = 0, k = 0; j < toRead; j++)					{					if (j&0x01)						{						screen8->lpbBmRowAddresses[i][j] = translation[bitsPtr[k]&0x0F0];						k++;                    	}					else						screen8->lpbBmRowAddresses[i][j] = translation[bitsPtr[k]&0x00F];					 } 				bitsPtr += rowWidth;			   }			break;		case 8:			for (i = toStart; i < toDo + toStart; i++)            	{				for (j = 0; j < toRead; j++)					screen8->lpbBmRowAddresses[i][j] = translation[bitsPtr[j]];				bitsPtr += rowWidth;				}			break;		case 16:			for (i = toStart; i < toDo + toStart; i++)            	{				for (j = 0, k = 0; j < toRead; j++, k += 2)					{					rgb.red = (bitsPtr[k] >> 2) & 0x1F;					rgb.green = ((bitsPtr[k+1] << 3) & 0x18) | ((bits[k+2] >> 5) & 0x03);            		rgb.blue = (bitsPtr[k+2] & 0x1F);					screen8->lpbBmRowAddresses[i][j] = GetClosestColor(&rgb);					}				bitsPtr += rowWidth;				}			break;		case 24:			for (i = toStart; i < toDo + toStart; i++)            	{				for (j = 0, k= 0; j < toRead; j++, k += 3)					{					rgb.red = bitsPtr[k];					rgb.green = bitsPtr[k+1];                	rgb.blue = bitsPtr[k+2];					screen8->lpbBmRowAddresses[i][j] = GetClosestColor(&rgb);;					}				bitsPtr += rowWidth;				}			break;		case 32:			for (i = toStart; i < toDo + toStart; i++)            	{				for (j = 0, k = 0; j < toRead; j++, k += 4)              		{					rgb.red = bitsPtr[k];					rgb.green = bitsPtr[k+1]; 					rgb.blue = bitsPtr[k+2];					screen8->lpbBmRowAddresses[i][j] = GetClosestColor(&rgb);					}				bitsPtr += rowWidth;				}			break;		default:			err = -1;            break;	}#endif    return(err);}// BILBIL - no inline functions w/ Think CintBMPReaderPixel8::ScreenWidth(){	return(screen8->wBmWidth);}// BILBIL - no inline functions w/ Think CintBMPReaderPixel8::ScreenHeight(){	return(screen8->wBmHeight);}#endif