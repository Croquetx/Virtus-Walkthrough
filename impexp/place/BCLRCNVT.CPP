/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1993 by Virtus Corporation * All Rights Reserved * Written by  	John C. Alspaugh * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#if VWT /* jca 17 Sept 93. Not in VR { */#include "VArray.h"#include "VDisplay.h"#include "VDialog.h"#include "VGUtil.h"#include "VMemUtil.h"#include "AppText.h"#include "AppDeflt.h"#include "TifCompr.h"#include "BClrCnvt.h"#undef abs#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>char *IMAGE_UNSUPPORTED_DEPTH	=TXT_IMAGE_UNSUPPORTED_DEPTH;	// PRO-JAP/*	The BitmapColorConverter converts bitmapped images from one	colordepth to another.  So, if you've got a 24-bit deep image	and a 4-bit monitor, it converts the 24-bit colors into as	close a set of colors as possible, using the windowing system's	color conversion routines.  This is more for Windows than the	mac, since under windows your color depth is limited by the	resolution of your (one) monitor (the mac lets you change color	depths on the fly, providing your monitor can handle it.  You can	also have multiple monitors of varying color depths).  This can	potentially give the user choice over the color resolution of the	image (trade color complexity for memory use).	a few rules:		-- the input buffer contains 0 or more pixels.        -- the output buffer _must_ be > 32 bytes, and the bigger the better.		-- the converter consumes the input buffer entirely before        requesting more pixels.		-- the routines return 0 for all ok, negative for an error,		and positive when it needs more pixels.    **	-- all color converters rely on truncation being the		default rounding scheme.  If truncation is not the default		scheme, redefine ROUND().  *//* avoid a call to floor(), since truncation is the default roundingscheme on this machine */#define ROUND(a)	(a)/* local, static routines */int		RGBtoHSVLocal(int r,int g,int b,int *h,int *s,int *v);int		RGBtoHSLLocal(int r,int g,int b,int *h,int *s,int *l);int		LessHSLLocal(const void *l, const void *r);void	BuildCtabIndexLocal(TableIndex *, indexedHSL *, int);void	CalcIndexStartLength(TableIndex *, int, int *, int *);int		MemoryErrorCall(void);  /* string macros eat memory!! *//*color converters */intColorConverterBase::cColorConverter(V_Array *cMap, int inDepth, int outDepth, long imageWidth, int rgbOrder){	ULong	rgb32;	imageDepth = inDepth;	screenDepth = outDepth;	width = imageWidth;	order = rgbOrder;	/* if this is a true-to-true change or a true-to-palette,	change, then there is no colormap */	colorTable = NULL;    return(0);}voidColorConverterBase::dColorConverter(){	if (colorTable)	colorTable->dArray();	delete(this);}/* this would be a virtual function */intColorConverterBase::Convert(char *inBuf, long inLength, long *inPos, char *outBuf, long outLength, long *outPos){} intPalToPalConverter::cColorConverter(V_Array *cMap, int inDepth, int outDepth, long imageWidth, int rgbOrder){	imageDepth = inDepth;	screenDepth = outDepth;	width = imageWidth;	order = rgbOrder;	colorTable = new(V_Array);	shiftCount = -1;	CreateConversionTable(cMap);    return(0);}/*This is where the dirty work occurs.  We call up a system color map appropriate to the depth of the image. For each color entry in the imagecolor map, find a similar color in the system color map.  Put the id number for this system color into the newId table (in the entry for theimage color's id number).  Each entry in the newId table maps one imagecolor id number into a system palette id number. */intPalToPalConverter::MapColors(V_Array *map, unsigned char *newId){#if MACINTOSH	CTabHandle	HCtab;	ColorSpec	*macCtab;	RGBColor	closestRgb, testRgb;	int			whichRgb;	long		dist, lastDist;#elif WINDOWS	HDC			hdc;#endif	RGBColor	*cMap;	int 		i,j;	if (screenDepth == imageDepth)		{		for (i = 0; i < (1 << imageDepth); i++)			{			newId[i] = i;			}		}	else		{#if MACINTOSH		/* for some reason, Walkthrough appears to use macintosh color table		resources 65, 66, 68, and 72 for its 1, 2, 4, and 8-bit color maps, 		respectively. Thus, we have an offset. */ 		cMap = (RGBColor *) map->Use();		HCtab = GetCTable(screenDepth + CONVERTER_MAGIC_OFFSET);				if (HCtab)			{			HLock((Handle)HCtab);			macCtab = ((ColorTable*)(*HCtab))->ctTable;						/* for each entry in the color map */			for (i = 0; i < (1 << imageDepth); i++)				{								closestRgb.red = closestRgb.green = closestRgb.blue = 0xFFFF;				whichRgb = 0;				dist =  lastDist = 0x0FFFFFFF;								/* compare this color against each color in the system color				map.  */				for (j = 0; j < ((ColorTable*)(*HCtab))->ctSize+1; j++)					{					dist = 0x0000FFFF & labs((long)cMap[i].red - macCtab[j].rgb.red);					dist += 0x0000FFFF & labs((long)cMap[i].green - macCtab[j].rgb.green);					dist += 0x0000FFFF & labs((long)cMap[i].blue - macCtab[j].rgb.blue);										if (dist < lastDist)						{						whichRgb = j;						lastDist = dist;						}					}				/* set up the alias */				newId[i] = whichRgb;				}						/* remap the current colorMap */			map->Unuse();			map->SetLength(((ColorTable*)(*HCtab))->ctSize+1);			cMap = (RGBColor *) map->Use();			for (i = 0; i < ((ColorTable*)(*HCtab))->ctSize+1; i++)				{				cMap[i].red = macCtab[i].rgb.red;				cMap[i].green = macCtab[i].rgb.green;				cMap[i].blue = macCtab[i].rgb.blue;				}			map->Unuse();			HUnlock((Handle)HCtab);			DisposeCTable(HCtab);			}#elif WINDOWS#endif	}}#define NEW_STUFF 1intPalToPalConverter::CreateConversionTable(V_Array *colorMap){	/* if this is a palette-to-palette change, then remap	the color table to match the system colors.  Also,	while we're at it, set the amount to shift or copy.	*/	RGBColor	*rgb;	int 		i,j;	char 		*cTable;	unsigned char 	alias[256];	ULong 	rgb32;    unsigned short 	rgb16;	int				tableLoc, shifter, tabSize, multiplier;    int				left, midLeft, midRight, right;	MapColors(colorMap, alias);	if (((imageDepth < 1) || (imageDepth > 8)) ||		((screenDepth < 1) || (screenDepth > 8)))		{		AlertMessage(IMAGE_UNSUPPORTED_DEPTH);		return(-1);		}	if (imageDepth < screenDepth)		{		mode = PAL_SHIFT_UP;        tabSize = ROUND(screenDepth/imageDepth) * 256;		}	else if (imageDepth == screenDepth)		{		mode = PAL_NO_SHIFT;        tabSize = 256;		}	else /* imageDepth > screenDepth */		{		mode = PAL_SHIFT_DOWN;        tabSize = 256;		}		colorTable = new(V_Array);		if (colorTable->cArray(tabSize, sizeof(char), 1))			{			AlertMessage(TXTW_MEMORY);			return(-1);			}        cTable = (char *)colorTable->Use();		memset(cTable, 0, tabSize);	switch (imageDepth)		{		case 1:#ifdef NEW_STUFF			switch (screenDepth)				{				case 1:					tableLoc = 0;					shifter = 7;					shift = 0;                    break;				case 2:					tableLoc = 1;                	shifter = 6;					shift = 1;                    break;				case 4:					tableLoc = 2;                	shifter = 4;					shift = 2;                    break;				case 8:					tableLoc = 3;                	shifter = 0;					shift = 3;					break;                }			for (i = 0; i < 256; i++)				{				cTable[i<<tableLoc]                     	   = ((i&0x80)?alias[1]:alias[0])<<((shifter)& 0x0007);				cTable[(i<<tableLoc)+ROUND((screenDepth)/8)]   = ((i&0x40)?alias[1]:alias[0])<<((2*shifter)& 0x0007);				cTable[(i<<tableLoc)+ROUND((screenDepth)/4)]   = ((i&0x20)?alias[1]:alias[0])<<((3*shifter)& 0x0007);				cTable[(i<<tableLoc)+ROUND((3*screenDepth)/8)] = ((i&0x10)?alias[1]:alias[0])<<((4*shifter)& 0x0007);				cTable[(i<<tableLoc)+ROUND((screenDepth)/2)]   = ((i&0x08)?alias[1]:alias[0])<<((5*shifter)& 0x0007);				cTable[(i<<tableLoc)+ROUND((5*screenDepth)/8)] = ((i&0x04)?alias[1]:alias[0])<<((6*shifter)& 0x0007);				cTable[(i<<tableLoc)+ROUND((6*screenDepth)/8)] = ((i&0x02)?alias[1]:alias[0])<<((7*shifter)& 0x0007);				cTable[(i<<tableLoc)+ROUND((7*screenDepth)/8)] = ((i&0x01)?alias[1]:alias[0])<<((8*shifter)& 0x0007);                }#endif#ifdef OLDSTUFF			switch(screenDepth)				{				case 1:                    mode = PAL_NO_SHIFT;					shift = 0;					colorTable = new(V_Array);					if (colorTable->cArray(256, sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}                    cTable = (char *)colorTable->Use();					memset(cTable, 0, 256);					for (i = 0; i < 256; i++)						{						cTable[i] = ((i&0x80)?alias[1]:alias[0])<<7;						cTable[i] |= ((i&0x40)?alias[1]:alias[0])<<6;						cTable[i] |= ((i&0x20)?alias[1]:alias[0])<<5;						cTable[i] |= ((i&0x10)?alias[1]:alias[0])<<4;						cTable[i] |= ((i&0x08)?alias[1]:alias[0])<<3;						cTable[i] |= ((i&0x04)?alias[1]:alias[0])<<2;						cTable[i] |= ((i&0x02)?alias[1]:alias[0])<<1;						cTable[i] |= ((i&0x01)?alias[1]:alias[0]);						}					colorTable->Unuse();                    break;				case 2:					mode = PAL_SHIFT_UP;					shift = 1;					colorTable = new(V_Array);					if (colorTable->cArray(512, sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}                    cTable = (char *)colorTable->Use();					memset(cTable, 0, 512);					for (i = 0; i < 256; i++)						{						cTable[i<<1] = ((i&0x80)?alias[1]:alias[0])<<6;						cTable[i<<1] |= ((i&0x40)?alias[1]:alias[0])<<4;						cTable[i<<1] |= ((i&0x20)?alias[1]:alias[0])<<2;						cTable[i<<1] |= ((i&0x10)?alias[1]:alias[0]);						cTable[(i<<1)+1] = ((i&0x08)?alias[1]:alias[0])<<6;						cTable[(i<<1)+1] |= ((i&0x04)?alias[1]:alias[0])<<4;						cTable[(i<<1)+1] |= ((i&0x02)?alias[1]:alias[0])<<2;						cTable[(i<<1)+1] |= ((i&0x01)?alias[1]:alias[0]);						}                    colorTable->Unuse();					break;				case 4:					mode = PAL_SHIFT_UP;					shift = 2;					if (colorTable->cArray(1024, sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}                    cTable = (char *)colorTable->Use();					memset(cTable, 0, 1024);					for (i = 0; i < 256; i++)						{						cTable[i<<2] = ((i&0x80)?alias[1]:alias[0])<<4;						cTable[i<<2] |= ((i&0x40)?alias[1]:alias[0]);						cTable[(i<<2)+1] = ((i&0x20)?alias[1]:alias[0])<<4;						cTable[(i<<2)+1] |= ((i&0x10)?alias[1]:alias[0]);						cTable[(i<<2)+2] = ((i&0x08)?alias[1]:alias[0])<<4;						cTable[(i<<2)+2] |= ((i&0x04)?alias[1]:alias[0]);						cTable[(i<<2)+3] = ((i&0x02)?alias[1]:alias[0])<<4;						cTable[(i<<2)+3] |= ((i&0x01)?alias[1]:alias[0]);						}                    colorTable->Unuse();					break;				case 8:					mode = PAL_SHIFT_UP;					shift = 3;					if (colorTable->cArray(2048, sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}                    cTable = (char *)colorTable->Use();					memset(cTable, 0, 2048);					for (i = 0; i < 256; i++)						{						cTable[i<<3] = ((i&0x80)?alias[1]:alias[0]);						cTable[(i<<3)+1] = ((i&0x40)?alias[1]:alias[0]);						cTable[(i<<3)+2] = ((i&0x20)?alias[1]:alias[0]);						cTable[(i<<3)+3] = ((i&0x10)?alias[1]:alias[0]);						cTable[(i<<3)+4] = ((i&0x08)?alias[1]:alias[0]);						cTable[(i<<3)+5] = ((i&0x04)?alias[1]:alias[0]);						cTable[(i<<3)+6] = ((i&0x02)?alias[1]:alias[0]);						cTable[(i<<3)+7] = ((i&0x01)?alias[1]:alias[0]);						}                    colorTable->Unuse();					break;				default:                    AlertMessage(IMAGE_UNSUPPORTED_DEPTH);                    return(-1);					break;				}#endif			break;		case 2:#ifdef NEW_STUFF			switch (screenDepth)				{				case 1:					tableLoc = 0;					shifter = 1;					shift = 1;					break;				case 2:					tableLoc = 0;					shifter = 2;					shift = 0;					break;				case 4:					tableLoc = 2;					shifter = 4;                    shift = 1;				case 8:					tableLoc = 4;					shifter = 0;                    shift = 2;					break;				}			for (i = 0; i < 256; i++)				{				left = (i >> 6) & 0x03;				midLeft = (i >> 4) & 0x03;				midRight = (i >> 2) & 0x03;				right = i & 0x03;                // memset(&cTable[0], 0, ROUND(4/tableLoc));				cTable[i<<tableLoc] = alias[left] << ((shifter*3)&0x07);				cTable[(i<<tableLoc)+ROUND(screenDepth/8)] |= alias[midLeft] << ((shifter*2)&0x07);				cTable[(i<<tableLoc)+ROUND(screenDepth/4)] |= alias[midRight] << ((shifter*1)&0x07);				cTable[(i<<tableLoc)+ROUND((3*screenDepth)/8)] |= alias[right];				}#endif#ifdef OLD_STUFF			switch(screenDepth)				{				case 1:					mode = PAL_SHIFT_DOWN;					shift = 1; 					if (colorTable->cArray(256, sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}                    cTable = (char *)colorTable->Use();					memset(cTable, 0, 256);					for (i = 0; i < 256; i++)						{						unsigned short 	right2, midRight2, midLeft2, left2;						left2 = (i & 0xC0)>>6;						midLeft2 = (i & 0x30)>>4;						midRight2 = (i & 0x0C)>>2;						right2 = (i & 0x03);						cTable[i] = (unsigned char) (alias[left2] << 3) |							(alias[midLeft2] << 2) | (alias[midRight2] << 1) | 							(alias[right2]);                    	}					colorTable->Unuse();					break;				case 2:                    mode = PAL_NO_SHIFT;					shift = 0;					if (colorTable->cArray(512, sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}                    cTable = (char *)colorTable->Use();					memset(cTable, 0, 512);					for (i = 0; i < 256; i++)						{						unsigned short 	right2, midRight2, midLeft2, left2;						left2 = (i & 0xC0)>>6;						midLeft2 = (i & 0x30)>>4;						midRight2 = (i & 0x0C)>>2;						right2 = (i & 0x03);						cTable[2*i] = (alias[left2] << 6) & 0xC0 | (alias[midLeft2] << 4) & 0x30 |							(alias[midRight2] << 4) & 0x0C | (alias[right2]) & 0x03;                    	}					colorTable->Unuse();				case 4:					mode = PAL_SHIFT_UP;					shift = 1;					if (colorTable->cArray(512, sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}                    cTable = (char *)colorTable->Use();					memset(cTable, 0, 512);					for (i = 0; i < 256; i++)						{						unsigned short 	right2, midRight2, midLeft2, left2;						left2 = (i & 0xC0)>>6;						midLeft2 = (i & 0x30)>>4;						midRight2 = (i & 0x0C)>>2;						right2 = (i & 0x03);						cTable[2*i] = (unsigned char) alias[left2] << 4 | alias[midLeft2];						cTable[(2*i)+1] = (unsigned char) alias[midRight2] << 4 | alias[right2];                    	}					colorTable->Unuse();					break;				case 8:					shift = 2;					mode = PAL_SHIFT_UP;					if (colorTable->cArray(1024, sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}                    cTable = (char *)colorTable->Use();					memset(cTable, 0, 1024);					for (i = 0; i < 256; i++)						{						unsigned short 	right2, midRight2, midLeft2, left2;						left2 = (i & 0xC0)>>6;						midLeft2 = (i & 0x30)>>4;						midRight2 = (i & 0x0C)>>2;						right2 = (i & 0x03);						cTable[4*i] = (unsigned char) alias[left2];						cTable[(4*i)+1] = (unsigned char) alias[midLeft2];						cTable[(4*i)+2] = (unsigned char) alias[midRight2];						cTable[(4*i)+3] = (unsigned char) alias[right2];						}					colorTable->Unuse();					break;				default:					AlertMessage(IMAGE_UNSUPPORTED_DEPTH);                	return(-1);					break;				}#endif			break;		case 4:#ifdef NEW_STUFF			switch (screenDepth)				{				case 1:					tableLoc = 0;					shift = 1;                    shifter = 1;					break;				case 2:			 		tableLoc = 0;					shift = 2;                    shifter = 2;					break;				case 4:					tableLoc = 0;					shift = 0;					shifter = 4;					break;				case 8:					tableLoc = 1;					shift = 1;                    shifter = 0;					break;				}			for (i = 0; i < 256; i++)				{				left = (i >> 4) & 0x0F;				right = i & 0x0F;				// memset(&cTable[0], 0, ROUND(2/tableLoc));				cTable[(i<<tableLoc)] = alias[left] << (shifter&0x07);				cTable[(i<<tableLoc)+ROUND(screenDepth/8)] |= alias[right];				}#endif#ifdef OLD_STUFF			switch(screenDepth)				{				case 1:					mode = PAL_SHIFT_DOWN;					shift = 1;					if (colorTable->cArray(256, sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}                    cTable = (char *)colorTable->Use();					memset(cTable, 0, 256);					for (i = 0; i < 256; i++)						{						unsigned char	topNibble, bottomNibble;												topNibble = (i >> 4) & 0x0F;						bottomNibble = i & 0x0F;												cTable[i] = (unsigned char) (alias[topNibble]) << 1 |							alias[bottomNibble];                    	}					colorTable->Unuse();					break;				case 2:					mode = PAL_SHIFT_DOWN;					shift = 2; 					if (colorTable->cArray(256, sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}						                    cTable = (char *)colorTable->Use();					memset(cTable, 0, 256);					for (i = 0; i < 256; i++)						{						unsigned char	topNibble, bottomNibble;												topNibble = (i >> 4) & 0x0F;						bottomNibble = i & 0x0F;												cTable[i] = (unsigned char) (alias[topNibble]) << 2 |							alias[bottomNibble];                    	}					colorTable->Unuse();					break;				case 4:                	mode = PAL_NO_SHIFT;					shift = 0;					if (colorTable->cArray(256, sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}                    cTable = (char *)colorTable->Use();					memset(cTable, 0, 256);					for (i = 0; i < 256; i++)						{						unsigned short 	topByte, bottomByte;                        topByte = (i & 0xF0)>>4;						bottomByte = (i & 0x0F);						cTable[2*i] = (alias[topByte] << 4) & 0xF0 |                        	bottomByte & 0x0F;                    }					colorTable->Unuse();					break;				case 8:					mode = PAL_SHIFT_UP;					shift = 1;					if (colorTable->cArray(512, sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}                    cTable = (char *)colorTable->Use();					memset(cTable, 0, 512);					for (i = 0; i < 256; i++)						{						unsigned short 	topByte, bottomByte;                        topByte = (i & 0xF0)>>4;						bottomByte = (i & 0x0F);						cTable[2*i] = (unsigned char) topByte;                        cTable[(2*i)+1] = (unsigned char) bottomByte;	                    }					colorTable->Unuse();					break;				default:					AlertMessage(IMAGE_UNSUPPORTED_DEPTH);                    return(-1);					break;				}#endif			break;		case 8:#ifdef NEW_STUFF			shift = screenDepth;			if (screenDepth == 8)				shift = 0;			for (i = 0; i < 256; i++)				{				cTable[i] = (unsigned char) alias[i];				}#endif#ifdef OLD_STUFF			switch(screenDepth)				{				case 1:					mode = PAL_SHIFT_DOWN;					shift = 1; 					if (colorTable->cArray(256, sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}                    cTable = (char *)colorTable->Use();					memset(cTable, 0, 256);					for (i = 0; i < 256; i++)						{						cTable[i] = (unsigned char) alias[i];                    	}					colorTable->Unuse();					break;				case 2:					mode = PAL_SHIFT_DOWN;					shift = 2; 					if (colorTable->cArray(256, sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}                    cTable = (char *)colorTable->Use();					memset(cTable, 0, 256);					for (i = 0; i < 256; i++)						{						cTable[i] = (unsigned char) alias[i];                    	}					colorTable->Unuse();					break;				case 4:					mode = PAL_SHIFT_DOWN;					shift = 4;					if (colorTable->cArray(256, sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}                    cTable = (char *)colorTable->Use();					memset(cTable, 0, 256);					for (i = 0; i < 256; i++)						{						cTable[i] = (unsigned char) alias[i];                    	}					colorTable->Unuse();					break;                                                                                                                                                                               					break;				case 8:                    mode = PAL_NO_SHIFT;					shift = 0;					if (colorTable->cArray(256, sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}                    cTable = (char *)colorTable->Use();					memcpy(cTable, &alias[0], 256);					colorTable->Unuse();					break;				default:					AlertMessage(IMAGE_UNSUPPORTED_DEPTH);                    return(-1);					break;				}#endif			break;		default:			AlertMessage(IMAGE_UNSUPPORTED_DEPTH);            return(-1);			break;		}	colorTable->Unuse();}intPalToPalConverter::Convert(char *inBuf, long inLength, long *inPos, char *outBuf, long outLength, long *outPos){	int		err, nToCopy, pixToCopy, pixelsPerByte, index, nPixels;	unsigned char	*cTable, composite;    err = 0;    nPixels = 0;    pixelsPerByte = 8/imageDepth;    cTable = (unsigned char *) colorTable->Use();	/* 	Shifting from a low res image to a high res screen.  Each byte		from the low res image is converted into several bytes in the        high res image.		count = number of high res bytes to each low res byte		count = 2**shift (shift is used to index into the color			mapping table).     */	if (mode == PAL_SHIFT_UP)		{		pixCount = 0;		while (!err)			{			if (*inPos >= inLength)				{                err = 1;				}			else				{				if (pixCount + pixelsPerByte > width)					{					pixToCopy = width - pixCount;					nToCopy = ((pixToCopy * (screenDepth/imageDepth)) +  7)/8;					}				else					{					nToCopy = screenDepth/imageDepth;					pixToCopy = pixelsPerByte;					}								index = (((unsigned int)inBuf[*inPos]) & 0x00FF) << shift;                memcpy(&outBuf[*outPos], &cTable[index], nToCopy);				*outPos += nToCopy;                pixCount += pixToCopy;                nPixels += pixToCopy;				(*inPos)++;				}			if (pixCount == width)            	{				err = pixCount;				(*outPos)++;                }			else if (pixCount > width)				{                err = IMAGE_ERROR;                }			}		}	/*	Shifting from a high res to a low res image is the reverse		of the above case:  multiple bytes of the high res image		are compressed to make the bytes of the low res image.		It is possible to consume multiple inBufs to fill one		outBuf, so we must remember the shift count across buffers.		We must also remember to check for the end of row (so we don't		run over).	*/	else if (mode == PAL_SHIFT_DOWN)		{		while (((*outPos < outLength) && (*inPos < inLength)) && !err)			{			if ((shiftCount < 0) || (pixCount == width))				{				if (pixCount == width)					{					(*outPos)++;					shiftCount = -1;					pixCount = 0;					}				else					{    /* move to the next pixel and start */                    if (pixCount != 0)                    	(*outPos)++;					shiftCount = 8 - shift;					outBuf[*outPos] = cTable[inBuf[(*inPos)++]] << shiftCount;					shiftCount -= shift;					pixCount += pixelsPerByte;					nPixels += pixelsPerByte;					}				}			else				{				outBuf[*outPos] |= cTable[inBuf[(*inPos)++]] << shiftCount;				shiftCount -= shift;               	nPixels += pixelsPerByte;               	pixCount += pixelsPerByte;  				}			}			if (pixCount > width)                	err = IMAGE_ERROR;		}	else		{		while ((*outPos < outLength) && (*inPos < inLength))			{			outBuf[(*outPos)++] = cTable[((unsigned int)inBuf[(*inPos)++])&0xFF];            pixCount += pixelsPerByte;            nPixels += pixelsPerByte;            }		}	colorTable->Unuse();    return(nPixels);}intPalToTrueConverter::cColorConverter(V_Array *cMap, int inDepth, int outDepth, long imageWidth, int rgbOrder){	imageDepth = inDepth;	screenDepth = outDepth;	width = imageWidth;	order = rgbOrder;	count = 0;	colorTable = new(V_Array);    RemapPalToTrueColors(cMap);    return(0);}intPalToTrueConverter::RemapPalToTrueColors(V_Array *imgCMap){	int				i, j, err = IMAGE_ALL_OK;	RGBColor		*rgb;	char			*reMap;	unsigned short	rgb16, rgb16b;	unsigned char	r,g,b,a,rb,gb,bb,ab;	rgb = (RGBColor *) imgCMap->Use();	switch(imageDepth)		{		case 1:			switch (screenDepth)				{				case 16:					pixelBytes = 16; 					if (mode = RGB_ORDER)                    	{						rgb16b = ((rgb[0].red>>1)&0x7C00) |							((rgb[0].green>>6)&0x03E0) |							((rgb[0].blue>>11)&0x001F); 						rgb16 = ((rgb[1].red>>1)&0x7C00) |							((rgb[1].green>>6)&0x03E0) |							((rgb[1].blue>>11)&0x001F);						}					else /* BGR_ORDER */						{						rgb16b = ((rgb[0].red>>10)&0x003E) |							((rgb[0].green>>5)&0x07C0) |							((rgb[0].blue)&0xF800); 						rgb16 = ((rgb[1].red>>10)&0x003E) |							((rgb[1].green>>5)&0x07C0) |							((rgb[1].blue)&0xF800);						}					if (colorTable->cArray(256, 16*sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}					reMap = (char *) colorTable->Use();					for (i = 0, j = 0; i < 256; i++)						{ 					   	reMap[j++] = (unsigned char)((((i&0x80)?rgb16:rgb16b)>>8)&0xFF);					   	reMap[j++] = (unsigned char)(((i&0x80)?rgb16:rgb16b)&0xFF);					   	reMap[j++] = (unsigned char)((((i&0x40)?rgb16:rgb16b)>>8)&0xFF);					   	reMap[j++] = (unsigned char)(((i&0x40)?rgb16:rgb16b)&0xFF);					   	reMap[j++] = (unsigned char)((((i&0x20)?rgb16:rgb16b)>>8)&0xFF);					   	reMap[j++] = (unsigned char)(((i&0x20)?rgb16:rgb16b)&0xFF);					   	reMap[j++] = (unsigned char)((((i&0x10)?rgb16:rgb16b)>>8)&0xFF);					   	reMap[j++] = (unsigned char)(((i&0x10)?rgb16:rgb16b)&0xFF);					   	reMap[j++] = (unsigned char)((((i&0x08)?rgb16:rgb16b)>>8)&0xFF);					   	reMap[j++] = (unsigned char)(((i&0x08)?rgb16:rgb16b)&0xFF);					   	reMap[j++] = (unsigned char)((((i&0x04)?rgb16:rgb16b)>>8)&0xFF);					   	reMap[j++] = (unsigned char)(((i&0x04)?rgb16:rgb16b)&0xFF);					   	reMap[j++] = (unsigned char)((((i&0x02)?rgb16:rgb16b)>>8)&0xFF);						reMap[j++] = (unsigned char)(((i&0x02)?rgb16:rgb16b)&0xFF);						reMap[j++] = (unsigned char)((((i&0x01)?rgb16:rgb16b)>>8)&0xFF);						reMap[j++] = (unsigned char)(((i&0x01)?rgb16:rgb16b)&0xFF);						}                    colorTable->Unuse();					break;				case 24:					pixelBytes = 24;					if (colorTable->cArray(256, 24*sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}					reMap = (char *) colorTable->Use();					r = rgb[0].red;					g = rgb[0].green;					b = rgb[0].blue;					rb = rgb[1].red;					gb = rgb[1].green;					bb = rgb[1].blue;					for (i = 0, j = 0; i < 256; i++)						{						reMap[j++] = (unsigned char)((i&0x80)?rb:r);						reMap[j++] = (unsigned char)((i&0x80)?gb:g);						reMap[j++] = (unsigned char)((i&0x80)?bb:b);						reMap[j++] = (unsigned char)((i&0x40)?rb:r);						reMap[j++] = (unsigned char)((i&0x40)?gb:g);						reMap[j++] = (unsigned char)((i&0x40)?bb:b);						reMap[j++] = (unsigned char)((i&0x20)?rb:r);						reMap[j++] = (unsigned char)((i&0x20)?gb:g);						reMap[j++] = (unsigned char)((i&0x20)?bb:b);						reMap[j++] = (unsigned char)((i&0x10)?rb:r);						reMap[j++] = (unsigned char)((i&0x10)?gb:g);						reMap[j++] = (unsigned char)((i&0x10)?bb:b);						reMap[j++] = (unsigned char)((i&0x08)?rb:r);						reMap[j++] = (unsigned char)((i&0x08)?gb:g);						reMap[j++] = (unsigned char)((i&0x08)?bb:b);						reMap[j++] = (unsigned char)((i&0x04)?rb:r);						reMap[j++] = (unsigned char)((i&0x04)?gb:g);						reMap[j++] = (unsigned char)((i&0x04)?bb:b);						reMap[j++] = (unsigned char)((i&0x02)?rb:r);						reMap[j++] = (unsigned char)((i&0x02)?gb:g);						reMap[j++] = (unsigned char)((i&0x02)?bb:b);						reMap[j++] = (unsigned char)((i&0x01)?rb:r);						reMap[j++] = (unsigned char)((i&0x01)?gb:g);					   	reMap[j++] = (unsigned char)((i&0x01)?bb:b);						}                    colorTable->Unuse();					break;				case 32:                	pixelBytes = 32;					if (mode = RGB_ORDER)						{ 					  	r = rgb[1].red >> 8;					   	g = rgb[1].green >> 8;						b = rgb[1].blue >> 8;						a = ab = 0;						rb = rgb[0].red >> 8;					   	gb = rgb[0].green >> 8;						bb = rgb[0].blue >> 8;						}					else /* BGR_ORDER */						{						g = rgb[1].red >> 8;					   	r = rgb[1].green >> 8;						a = rgb[1].blue >> 8;						b = bb = 0;						gb = rgb[0].red >> 8;					   	rb = rgb[0].green >> 8;						ab = rgb[0].blue >> 8;						}					if (colorTable->cArray(256, 32*sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}					reMap = (char *) colorTable->Use();					for (i = 0, j = 0; i < 256; i++)						{ 					   	reMap[j++] = (unsigned char)((i&0x80)?a:ab);						reMap[j++] = (unsigned char)((i&0x80)?r:rb);					   	reMap[j++] = (unsigned char)((i&0x80)?g:gb);					   	reMap[j++] = (unsigned char)((i&0x80)?b:bb);					   	reMap[j++] = (unsigned char)((i&0x40)?a:ab);					   	reMap[j++] = (unsigned char)((i&0x40)?r:rb);					   	reMap[j++] = (unsigned char)((i&0x40)?g:gb);					   	reMap[j++] = (unsigned char)((i&0x40)?b:bb);					   	reMap[j++] = (unsigned char)((i&0x20)?a:ab);					   	reMap[j++] = (unsigned char)((i&0x20)?r:rb);						reMap[j++] = (unsigned char)((i&0x20)?g:gb);						reMap[j++] = (unsigned char)((i&0x20)?b:bb);					   	reMap[j++] = (unsigned char)((i&0x10)?a:ab);						reMap[j++] = (unsigned char)((i&0x10)?r:rb);						reMap[j++] = (unsigned char)((i&0x10)?g:gb);						reMap[j++] = (unsigned char)((i&0x10)?b:bb);						reMap[j++] = (unsigned char)((i&0x08)?a:ab);					   	reMap[j++] = (unsigned char)((i&0x08)?r:rb);					   	reMap[j++] = (unsigned char)((i&0x08)?g:gb);						reMap[j++] = (unsigned char)((i&0x08)?b:bb);						reMap[j++] = (unsigned char)((i&0x04)?a:ab);						reMap[j++] = (unsigned char)((i&0x04)?r:rb);						reMap[j++] = (unsigned char)((i&0x04)?g:gb);					   	reMap[j++] = (unsigned char)((i&0x04)?b:bb);					   	reMap[j++] = (unsigned char)((i&0x02)?a:ab);						reMap[j++] = (unsigned char)((i&0x02)?r:rb);						reMap[j++] = (unsigned char)((i&0x02)?g:gb);						reMap[j++] = (unsigned char)((i&0x02)?b:bb);						reMap[j++] = (unsigned char)((i&0x01)?a:ab);					   	reMap[j++] = (unsigned char)((i&0x01)?r:rb);					   	reMap[j++] = (unsigned char)((i&0x01)?g:gb);						reMap[j++] = (unsigned char)((i&0x01)?b:bb);						}                    colorTable->Unuse();					break;				default:					AlertMessage(IMAGE_UNSUPPORTED_DEPTH);                    err = IMAGE_ERROR;					break;                }			break;		case 2: 			switch (screenDepth)				{				case 16:                	pixelBytes = 8; 					if (colorTable->cArray(256, 8*sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}					reMap = (char *) colorTable->Use();					if (order == RGB_ORDER)						{						for (i = 0, j = 0; i < 256; i++)							{							rgb16 = (rgb[HIGH2(i)].red >> 1) & 0x7C00 |								(rgb[HIGH2(i)].green >> 6) & 0x03E0 |								(rgb[HIGH2(i)].blue >> 11) & 0x001F;							memcpy(&reMap[j], &rgb16, 2);							j += 2;							rgb16 = (rgb[MIDHIGH2(i)].red >> 1) & 0x7C00 |								(rgb[MIDHIGH2(i)].green >> 6) & 0x03E0 |								(rgb[MIDHIGH2(i)].blue >> 11) & 0x001F;							memcpy(&reMap[j], &rgb16, 2);							j += 2;							rgb16 = (rgb[MIDLOW2(i)].red >> 1) & 0x7C00 |								(rgb[MIDLOW2(i)].green >> 6) & 0x03E0 |								(rgb[MIDLOW2(i)].blue >> 11) & 0x001F;							memcpy(&reMap[j], &rgb16, 2);							j += 2;							rgb16 = (rgb[LOW2(i)].red >> 1) & 0x7C00 |								(rgb[LOW2(i)].green >> 6) & 0x03E0 |								(rgb[LOW2(i)].blue >> 11) & 0x001F;							memcpy(&reMap[j], &rgb16, 2);							j += 2;							}						}					else /* BGR_ORDER */                    	{						for (i = 0, j = 0; i < 256; i++)							{							rgb16 = (rgb[HIGH2(i)].blue) & 0xF800 |								(rgb[HIGH2(i)].green >> 5) & 0x07C0 |								(rgb[HIGH2(i)].red >> 10) & 0x003E;							memcpy(&reMap[j], &rgb16, 2);							j += 2;							rgb16 = (rgb[MIDHIGH2(i)].blue) & 0xF800 |								(rgb[MIDHIGH2(i)].green >> 5) & 0x07C0 |								(rgb[MIDHIGH2(i)].red >> 10) & 0x003E;							memcpy(&reMap[j], &rgb16, 2);							j += 2;							rgb16 = (rgb[MIDLOW2(i)].blue) & 0xF800 |								(rgb[MIDLOW2(i)].green >> 5) & 0x07C0 |								(rgb[MIDLOW2(i)].red >> 10) & 0x003E;							memcpy(&reMap[j], &rgb16, 2);							j += 2;							rgb16 = (rgb[LOW2(i)].blue) & 0xF800 |								(rgb[LOW2(i)].green >> 5) & 0x07C0 |								(rgb[LOW2(i)].red >> 10) & 0x003E;							memcpy(&reMap[j], &rgb16, 2);							j += 2;							}						}                    colorTable->Unuse();					break;				case 24:                	pixelBytes = 12;					if (colorTable->cArray(256, 12*sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}					reMap = (char *) colorTable->Use();					for (i = 0, j = 0; i < 256; i++)						{#if MACINTOSH						reMap[j++] = (char) ((rgb[HIGH2(i)].red >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[HIGH2(i)].green >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[HIGH2(i)].blue >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[MIDHIGH2(i)].red >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[MIDHIGH2(i)].green >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[MIDHIGH2(i)].blue >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[MIDLOW2(i)].red >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[MIDLOW2(i)].green >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[MIDLOW2(i)].blue >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[LOW2(i)].red >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[LOW2(i)].green >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[LOW2(i)].blue >> 8) & 0xFF);#elif WINDOWS						reMap[j++] = (char) ((rgb[HIGH2(i)].blue >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[HIGH2(i)].green >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[HIGH2(i)].red >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[MIDHIGH2(i)].blue >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[MIDHIGH2(i)].green >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[MIDHIGH2(i)].red >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[MIDLOW2(i)].blue >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[MIDLOW2(i)].green >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[MIDLOW2(i)].red >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[LOW2(i)].blue >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[LOW2(i)].green >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[LOW2(i)].red >> 8) & 0xFF);#endif						}                    colorTable->Unuse();					break;				case 32:                	pixelBytes = 16;					if (colorTable->cArray(256, 16*sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}					reMap = (char *) colorTable->Use();					for (i = 0, j = 0; i < 256; i++)						{#if MACINTOSH						reMap[j++] = 0;						reMap[j++] = (char)(rgb[HIGH2(i)].red >> 8) & 0xFF;						reMap[j++] = (char)(rgb[HIGH2(i)].green >> 8) & 0xFF;						reMap[j++] = (char)(rgb[HIGH2(i)].blue >> 8) & 0xFF;						reMap[j++] = 0;						reMap[j++] = (char)(rgb[MIDHIGH2(i)].red >> 8) & 0xFF;						reMap[j++] = (char)(rgb[MIDHIGH2(i)].green >> 8) & 0xFF;						reMap[j++] = (char)(rgb[MIDHIGH2(i)].blue >> 8) & 0xFF;						reMap[j++] = 0;						reMap[j++] = (char)(rgb[MIDLOW2(i)].red >> 8) & 0xFF;						reMap[j++] = (char)(rgb[MIDLOW2(i)].green >> 8) & 0xFF;						reMap[j++] = (char)(rgb[MIDLOW2(i)].blue >> 8) & 0xFF;						reMap[j++] = 0;						reMap[j++] = (char)(rgb[LOW2(i)].red >> 8) & 0xFF;						reMap[j++] = (char)(rgb[LOW2(i)].green >> 8) & 0xFF;						reMap[j++] = (char)(rgb[LOW2(i)].blue >> 8) & 0xFF;#elif WINDOWS						reMap[j++] = (char)(rgb[HIGH2(i)].blue >> 8) & 0xFF;						reMap[j++] = (char)(rgb[HIGH2(i)].green >> 8) & 0xFF;						reMap[j++] = (char)(rgb[HIGH2(i)].red >> 8) & 0xFF;                        reMap[j++] = 0;						reMap[j++] = (char)(rgb[MIDHIGH2(i)].blue >> 8) & 0xFF;						reMap[j++] = (char)(rgb[MIDHIGH2(i)].green >> 8) & 0xFF;						reMap[j++] = (char)(rgb[MIDHIGH2(i)].red >> 8) & 0xFF;                        reMap[j++] = 0;						reMap[j++] = (char)(rgb[MIDLOW2(i)].blue >> 8) & 0xFF;						reMap[j++] = (char)(rgb[MIDLOW2(i)].green >> 8) & 0xFF;						reMap[j++] = (char)(rgb[MIDLOW2(i)].red >> 8) & 0xFF;                        reMap[j++] = 0;						reMap[j++] = (char)(rgb[LOW2(i)].blue >> 8) & 0xFF;						reMap[j++] = (char)(rgb[LOW2(i)].green >> 8) & 0xFF;						reMap[j++] = (char)(rgb[LOW2(i)].red >> 8) & 0xFF;                        reMap[j++] = 0;#endif						}                    colorTable->Unuse();					break;				default:					AlertMessage(IMAGE_UNSUPPORTED_DEPTH);                    err = IMAGE_ERROR;					break;				}			break;		case 4:			switch (screenDepth)				{				case 16:                	pixelBytes = 4; 					if (colorTable->cArray(256, 4*sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}					reMap = (char *) colorTable->Use();					for (i = 0, j = 0; i < 256; i++)						{#if MACINTOSH 						rgb16 = (rgb[HIGH4(i)].red >> 1) & 0x7C00 | 								(rgb[HIGH4(i)].green >> 6) & 0x03E0 |								(rgb[HIGH4(i)].blue >> 11) & 0x001F;						rgb16b= (rgb[LOW4(i)].red >> 1) & 0x7C00 | 								(rgb[LOW4(i)].green >> 6) & 0x03E0 |								(rgb[LOW4(i)].blue >> 11) & 0x001F;#elif WINDOWS						rgb16 = (rgb[HIGH4(i)].blue) & 0xF800 |								(rgb[HIGH4(i)].green >> 5) & 0x07C0 |								(rgb[HIGH4(i)].red >> 10) & 0x003E;						rgb16b= (rgb[LOW4(i)].blue) & 0xF800 | 								(rgb[LOW4(i)].green >> 5) & 0x07C0 |								(rgb[LOW4(i)].red >> 10) & 0x003E;#endif						memcpy(&reMap[j], &rgb16, 2);						j += 2;						memcpy(&reMap[j], &rgb16b, 2);						j += 2;						}					colorTable->Unuse();					break;				case 24:                	pixelBytes = 6;					if (colorTable->cArray(256, 6*sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}					reMap = (char *) colorTable->Use();					for (i = 0, j = 0; i < 256; i++)						{#if MACINTOSH						reMap[j++] = (char) ((rgb[HIGH4(i)].red >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[HIGH4(i)].green >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[HIGH4(i)].blue >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[LOW4(i)].red >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[LOW4(i)].green >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[LOW4(i)].blue >> 8) & 0xFF);#elif WINDOWS						reMap[j++] = (char) ((rgb[HIGH4(i)].blue >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[HIGH4(i)].green >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[HIGH4(i)].red >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[LOW4(i)].blue >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[LOW4(i)].green >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[LOW4(i)].red >> 8) & 0xFF);#endif						}                    colorTable->Unuse();					break;				case 32:                	pixelBytes = 8;					if (colorTable->cArray(256, 8*sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}					reMap = (char *) colorTable->Use();					for (i = 0, j = 0; i < 256; i++)						{#if MACINTOSH                        reMap[j++] = 0;						reMap[j++] = (unsigned char)(rgb[HIGH4(i)].red >> 8) & 0xFF;						reMap[j++] = (unsigned char)(rgb[HIGH4(i)].green >> 8) & 0xFF;						reMap[j++] = (unsigned char)(rgb[HIGH4(i)].blue >> 8) & 0xFF;						reMap[j++] = 0;						reMap[j++] = (unsigned char)(rgb[LOW4(i)].red >> 8) & 0xFF;						reMap[j++] = (unsigned char)(rgb[LOW4(i)].green >> 8) & 0xFF;						reMap[j++] = (unsigned char)(rgb[LOW4(i)].blue >> 8) & 0xFF;#elif WINDOWS						reMap[j++] = (unsigned char)(rgb[HIGH4(i)].blue >> 8) & 0xFF;						reMap[j++] = (unsigned char)(rgb[HIGH4(i)].green >> 8) & 0xFF;						reMap[j++] = (unsigned char)(rgb[HIGH4(i)].red >> 8) & 0xFF;                        reMap[j++] = 0;						reMap[j++] = (unsigned char)(rgb[LOW4(i)].blue >> 8) & 0xFF;						reMap[j++] = (unsigned char)(rgb[LOW4(i)].green >> 8) & 0xFF;						reMap[j++] = (unsigned char)(rgb[LOW4(i)].red >> 8) & 0xFF;                        reMap[j++] = 0;#endif						}                    colorTable->Unuse();					break;				default:					AlertMessage(IMAGE_UNSUPPORTED_DEPTH);                    err = IMAGE_ERROR;					break;				}			break;		case 8:			switch (screenDepth)				{				case 16:                	pixelBytes = 2; 					if (colorTable->cArray(256, 2*sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}					reMap = (char *) colorTable->Use();					for (i = 0, j = 0; i < 256; i++)						{#if MACINTOSH						rgb16 = (rgb[i].red >> 1) & 0x7C00 | 							(rgb[i].green >> 6) & 0x03E0 | 							(rgb[i].blue >> 11) & 0x001F;#elif WINDOWS						rgb16 = (rgb[i].blue) & 0xF800 |							(rgb[i].green >> 5) & 0x07C0 | 							(rgb[i].blue >> 10) & 0x003E;#endif						memcpy(&reMap[j], &rgb16, 2);						j += 2;						}                    colorTable->Unuse();					break;				case 24:                	pixelBytes = 3;					if (colorTable->cArray(256, 3*sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}					reMap = (char *) colorTable->Use();					for (i = 0, j = 0; i < 256; i++)						{#if MACINTOSH						reMap[j++] = (char) ((rgb[i].red >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[i].green >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[i].blue >> 8) & 0xFF);#elif WINDOWS						reMap[j++] = (char) ((rgb[i].blue >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[i].green >> 8) & 0xFF);						reMap[j++] = (char) ((rgb[i].red >> 8) & 0xFF);#endif						}                    colorTable->Unuse();					break;				case 32:                	pixelBytes = 4;					if (colorTable->cArray(256, 4*sizeof(char), 1))						{						AlertMessage(TXTW_MEMORY);						return(-1);						}					reMap = (char *) colorTable->Use();					for (i = 0, j = 0; i < 256; i++)						{#if MACINTOSH						reMap[j++] = 0;						reMap[j++] = (char)(rgb[i].red >> 8) & 0xFF;						reMap[j++] = (char)(rgb[i].green >> 8) & 0xFF;						reMap[j++] = (char)(rgb[i].blue >> 8) & 0xFF;#elif WINDOWS						reMap[j++] = (char)(rgb[i].blue >> 8) & 0xFF;						reMap[j++] = (char)(rgb[i].green >> 8) & 0xFF;						reMap[j++] = (char)(rgb[i].red >> 8) & 0xFF;						reMap[j++] = 0;#endif						}                    colorTable->Unuse();					break;				default:					AlertMessage(IMAGE_UNSUPPORTED_DEPTH);                    err = IMAGE_ERROR;					break;				}			break;		default:			AlertMessage(IMAGE_UNSUPPORTED_DEPTH);            err = IMAGE_ERROR;			break;        }	imgCMap->Use();	return(err);}intPalToTrueConverter::Convert(char *inBuf, long inLength, long *inPos, char *outBuf, long outLength, long *outPos){	char	*cTable;	int		nToCopy, nPixels, whereToStart;	cTable = (char *) colorTable->Use();	nPixels = 0;				while ((*outPos + pixelBytes < outLength) && (*inPos < inLength))		{		whereToStart = pixelBytes * ((unsigned int)inBuf[*inPos] & 0x00FF);		memcpy(&outBuf[*outPos], &cTable[whereToStart], pixelBytes);		(*outPos) += pixelBytes;		(*inPos)++;		nPixels += pixelBytes/(screenDepth/8);		}			if (((*outPos < outLength) && (*outPos + pixelBytes >= outLength)) &&		(*inPos < inLength))		{		nToCopy = outLength - *outPos;		whereToStart = pixelBytes * ((unsigned int)inBuf[*inPos] & 0x00FF);		memcpy(&outBuf[*outPos], &cTable[whereToStart], nToCopy);		(*outPos) += nToCopy;		(*inPos)++;		nPixels += nToCopy/(screenDepth/8);		}		    colorTable->Unuse();	return(nPixels);}intTrueToPalConverter::cColorConverter(V_Array *cMap, int inDepth, int outDepth, long imageWidth, int rgbOrder){	imageDepth = inDepth;	screenDepth = outDepth;	width = imageWidth;	order = rgbOrder;	pixCount = 0;	count = 0;		switch(screenDepth)		{		case 1:			shift = 7;			shiftIncr = 1;			break;		case 2:			shift = 6;			shiftIncr = 2;			break;		case 4:			shift = 4;			shiftIncr = 4;			break;		case 8:			shift = 0;			shiftIncr = 8;			break;		default:			AlertMessage(IMAGE_UNSUPPORTED_DEPTH);			return(-1);			break;		}	MakeColorMap(cMap);		    return(0);}intTrueToPalConverter::MakeColorMap(V_Array *cMap){#if MACINTOSH	CTabHandle	HCtab;	ColorSpec	*macCtab;#elif WINDOWS	HDC			hdc;#endif	int 	i,j, index, start, maxLoc;	int		r,g,b, err, which, delta;	int		hslMax, black, white, count, indexMax;	int		h,s,v, hDist, sDist, vDist;	unsigned char	*cTab;	V_Array	*hslTab, *indices;    RGBColor	*rgbCol;	indexedHSL	*hsl;	TableIndex	*indexTable;	int 		startCountTable[256][2];	hslTab = new(V_Array);	hslTab->cArray(256, sizeof(indexedHSL), 1);	hsl = (indexedHSL *) hslTab->Use();		indices = new(V_Array);	indices->cArray(N_TABLE_INDEX_ENTRIES, sizeof(TableIndex), 1);	indexTable = (TableIndex *)indices->Use();	memset(indexTable, 0, N_TABLE_INDEX_ENTRIES*sizeof(TableIndex));			#if MACINTOSH	HCtab = GetCTable(screenDepth + CONVERTER_MAGIC_OFFSET);	if (!HCtab)		{		AlertMessage(TXT_COLORMAP_TROUBLE);		// PRO-JAP this should _never_ happen		return(-1);		}	else		{		HLock((Handle)HCtab);		macCtab = ((ColorTable*)(*HCtab))->ctTable;		rgbCol = (RGBColor *) cMap->Use();						/* for each entry in the color map */		hslMax = ((ColorTable*)(*HCtab))->ctSize+1;		for (i = 0; i < hslMax; i++)			{			r = macCtab[i].rgb.red >> 8;			g = macCtab[i].rgb.green >> 8;			b = macCtab[i].rgb.blue >> 8;			rgbCol[i].red = macCtab[i].rgb.red;			rgbCol[i].green = macCtab[i].rgb.green;			rgbCol[i].blue = macCtab[i].rgb.blue;			RGBtoHSLLocal(r,g,b, &(hsl[i].hsl.h),&(hsl[i].hsl.s),&(hsl[i].hsl.l));			hsl[i].id = i;			}        cMap->Unuse();		}	HUnlock((Handle)HCtab);	DisposeCTable(HCtab);#elif WINDOWS#endif					qsort(hsl, hslMax, sizeof(indexedHSL), LessHSLLocal);				BuildCtabIndexLocal(indexTable, hsl, hslMax);		/* get the end of the color entries */	if (indexTable[GRAY_INDEX].start > 0)		indexMax = indexTable[GRAY_INDEX].start;	else		indexMax = hslMax;		/* get the indices for black and white */	for (i = indexTable[GRAY_INDEX].start; i < indexTable[GRAY_INDEX].start + indexTable[GRAY_INDEX].count; i++)		{		if ((hsl[i].hsl.h == GRAY) && (hsl[i].hsl.l == 0))			black = hsl[i].id;		else if ((hsl[i].hsl.h == GRAY) && (hsl[i].hsl.l == 255))	white = hsl[i].id;		}			colorTable = new(V_Array);	if (colorTable->cArray(TRUE_TO_PAL_TABLE_SIZE, sizeof(char), 1))		{		AlertMessage(TXTW_MEMORY);		return(-1);		}	cTab = (unsigned char *) colorTable->Use();		memset(cTab, 0x0, TRUE_TO_PAL_TABLE_SIZE);			/* a lookup table for the start locations and the count of things	to check */	for (i = 0; i < 256; i++)		{		CalcIndexStartLength(indexTable, i, &startCountTable[i][0], &startCountTable[i][1]);		}							for (i = 0; i < TRUE_TO_PAL_TABLE_SIZE; i++)		{		r = (i >> 4) & 0x00F0 | (i >> 8) & 0x000F;		g = i & 0x00F0 | (i >> 4) & 0x000F;		b = (i << 4) & 0x00F0 | i & 0x000F;						RGBtoHSLLocal(r,g,b, &h,&s,&v);				/* init vars */		hDist = sDist = vDist = 0x7FFF;		which = -1;							if (h != GRAY)			{						start = startCountTable[h][0];			count = startCountTable[h][1];						for (j = start; j < (start + count); j++)				{				int		hTemp, sTemp, vTemp;								if (j > indexMax)					index = j - indexMax;				else					index = j;												hTemp = h - hsl[index].hsl.h;				sTemp = s - hsl[index].hsl.s;				vTemp = v - hsl[index].hsl.l;				if (hTemp < 0)	hTemp = -hTemp;				if (sTemp < 0)	sTemp = -sTemp;				if (vTemp < 0)	vTemp = -vTemp;				if ((long) hTemp + sTemp + vTemp < (long) hDist + sDist + vDist)					{					hDist = hTemp;					sDist = sTemp;					vDist = vTemp;					which = index;					} 				}			}					if (which == -1)	/* this is a gray, not a color OR this								is a color with no close matches */			{			start = indexTable[GRAY_INDEX].start;			count = indexTable[GRAY_INDEX].count;						for (j = start; j < start + count; j++)				{				int		vTemp;												vTemp = v - hsl[j].hsl.l;				if (vTemp < 0)	vTemp = -vTemp;				if (vTemp < vDist)					{					vDist = vTemp;					which = j;					}				}			cTab[i] = hsl[which].id;			}		else		/* this is a color, but we should double-check it */			{			/* check if the lightness is actually closer to the lightness			bounds than to the thing we selected */			delta = v - hsl[which].hsl.l;			if (delta < 0) delta = -delta;			if (v < delta) 				cTab[i] = black;	/* black */			else if (255 - v < delta)				cTab[i] = white;	/* white */			else					cTab[i] = hsl[which].id;			}								}	colorTable->Unuse();	hslTab->Unuse();	hslTab->dArray();	indices->Unuse();	indices->dArray();	return(0);}intTrueToPalConverter::MatchColor(RGBColor	*rgb){	char		*table;	long	index, ret;		table = (char *)VA_Abuse(colorTable);	index = (rgb->red >> 4) & 0x0F00 | (rgb->green >> 8) & 0x00F0 |		(rgb->blue >> 12) & 0x000F;	ret = (int) table[index] & 0x00FF;		return(ret);}voidTrueToPalConverter::ShiftIntoDaBuffer(char *oBuf, long *count, long length, RGBColor *rgb){	if (shift == 0)		{		oBuf[(*count)++] |= (char) MatchColor(rgb) & 0x00FF;		shift = 8 - shiftIncr;		if (*count < length)			oBuf[*count] = 0;		}	else		{		oBuf[*count] |= ((char) MatchColor(rgb) & 0x00FF) << shift;		shift -= shiftIncr;		}	pixCount++;	if (pixCount == width)		{		pixCount = 0;		if (*count < length)		/* init */			oBuf[++(*count)] = 0;		}}intTrueToPalConverter::Convert(char *inBuf, long inLength, long *inPos, char *outBuf, long outLength, long *outPos){	long 		nPixels;    RGBColor	rgb;    	nPixels = 0;	if (pixCount == 0)		/* init */		outBuf[*outPos] = 0;			if (imageDepth == 24)		{		if (count)			{			rgb.red = (unsigned short)leftovers[0] << 8;			if (count > 1)				rgb.green = (unsigned short)leftovers[1] << 8;			else				rgb.green = (unsigned short)inBuf[(*inPos)++] << 8;			rgb.blue = (unsigned short)inBuf[(*inPos)++] << 8;			count = 0;			ShiftIntoDaBuffer(outBuf, outPos, outLength, &rgb);			nPixels++;				}		while ((*outPos < outLength) && (*inPos + 2 < inLength))			{			if (order == RGB_ORDER)                {				rgb.red = ((unsigned int)inBuf[(*inPos)++] & 0x00FF) << 8;				rgb.green = ((unsigned int)inBuf[(*inPos)++] & 0x00FF) << 8;				rgb.blue = ((unsigned int)inBuf[(*inPos)++] & 0x00FF) << 8;				}			else  /* BGR_ORDER */				{				rgb.blue = ((unsigned int)inBuf[(*inPos)++] & 0x00FF) << 8;				rgb.green = ((unsigned int)inBuf[(*inPos)++] & 0x00FF) << 8;				rgb.red = ((unsigned int)inBuf[(*inPos)++] & 0x00FF) << 8;				}			ShiftIntoDaBuffer(outBuf, outPos, outLength, &rgb);			nPixels++;							}		if ((*inPos + 2 > inLength) && (*inPos < inLength))			{			count = inLength - *inPos;			strncpy(leftovers, &inBuf[*inPos], count);			*inPos += count;			}		}	else if (imageDepth == 16)		{		unsigned short rgb16;		if (count)			{			rgb16 = ((unsigned short)leftovers[0] << 8) | inBuf[(*inPos)++];			count = 0;			if (order == RGB_ORDER)				{				rgb.red = (rgb16 << 1) & 0xF800;				rgb.green = (rgb16 << 6) & 0xF800;				rgb.blue = (rgb16 << 11) & 0xF800;				}			else  /* BGR_ORDER */				{				rgb.blue = rgb16 & 0xF800;				rgb.green = (rgb16 << 5) & 0xF800;				rgb.red = (rgb16 << 10) & 0xF800;				}			ShiftIntoDaBuffer(outBuf, outPos, outLength, &rgb);			nPixels++;				}		while ((*outPos < outLength) && (*inPos + 1 < inLength))			{			rgb16 = ((unsigned short)inBuf[*inPos] << 8) |                	(inBuf[*inPos+1]);			if (order == RGB_ORDER)				{				rgb.red = (rgb16 << 1) & 0xF800;				rgb.green = (rgb16 << 6) & 0xF800;				rgb.blue = (rgb16 << 11) & 0xF800;				}			else  /* BGR_ORDER */				{				rgb.blue = rgb16 & 0xF800;				rgb.green = (rgb16 << 5) & 0xF800;				rgb.red = (rgb16 << 10) & 0xF800;				}			ShiftIntoDaBuffer(outBuf, outPos, outLength, &rgb);			nPixels++;				}		if ((*inPos + 1 > inLength) && (*inPos < inLength))			{			count = inLength - *inPos;			strncpy(leftovers, &inBuf[*inPos], count);			*inPos += count;			}		}	else if (imageDepth == 32)		{		if (count)			{			if (order == RGB_ORDER)				{				if (count > 1)	rgb.red = (unsigned short)leftovers[1] << 8;				else 			rgb.red = ((unsigned int)inBuf[(*inPos)++] & 0x00FF) << 8;				if (count > 2)	rgb.green = (unsigned short)leftovers[2] << 8;				else 			rgb.green = ((unsigned int)inBuf[(*inPos)++] & 0x00FF) << 8;				rgb.blue = ((unsigned int)inBuf[(*inPos)++] & 0x00FF) << 8;				}			else				{				rgb.blue = (unsigned short)leftovers[0] << 8;				if (count > 0)	rgb.green = (unsigned short)leftovers[1] << 8;				else 			rgb.green = ((unsigned int)inBuf[(*inPos)++] & 0x00FF) << 8;				if (count > 2)	rgb.red = (unsigned short)leftovers[2] << 8;				else 			rgb.red = ((unsigned int)inBuf[(*inPos)++] & 0x00FF) << 8;				(*inPos)++;				}				ShiftIntoDaBuffer(outBuf, outPos, outLength, &rgb);			nPixels++;				}					while ((*outPos < outLength) && (*inPos + 3 < inLength))			{			if (order == RGB_ORDER)				{                (*inPos)++;				rgb.red = ((unsigned int)inBuf[(*inPos)++] & 0x00FF) << 8;				rgb.green = ((unsigned int)inBuf[(*inPos)++] & 0x00FF) << 8;				rgb.blue = ((unsigned int)inBuf[(*inPos)++] & 0x00FF) << 8;				}			else  /* BGR_ORDER */				{				rgb.blue = ((unsigned int)inBuf[(*inPos)++] & 0x00FF) << 8;				rgb.green = ((unsigned int)inBuf[(*inPos)++] & 0x00FF) << 8;				rgb.red = ((unsigned int)inBuf[(*inPos)++] & 0x00FF) << 8;                (*inPos)++;				}			ShiftIntoDaBuffer(outBuf, outPos, outLength, &rgb);			nPixels++;				}		if ((*inPos + 3 > inLength) && (*inPos < inLength))			{			count = inLength - *inPos;			strncpy(leftovers, &inBuf[*inPos], count);			*inPos += count;			}		}	else		{		AlertMessage(IMAGE_UNSUPPORTED_DEPTH);        return(-1);		}    return(nPixels);}intTrueToTrueConverter::cColorConverter(V_Array *cMap, int inDepth, int outDepth, long imageWidth, int rgbOrder){	imageDepth = inDepth;	screenDepth = outDepth;	width = imageWidth;	order = rgbOrder;	count = 0;	inBytesPerPixel = inDepth/8;	outBytesPerPixel = outDepth/8;		if (imageDepth < screenDepth)		mode = TRUE_SHIFT_UP;	else if (screenDepth < imageDepth)		mode = TRUE_SHIFT_DOWN;	else		mode = TRUE_NO_SHIFT;    return(0);}/* Convert a true-color image of one bit-depth to a true-color image ofanother bit-depth.    If the depths are equal, do memcpy */intTrueToTrueConverter::Convert(char *inBuf, long inLength, long *inPos, char *outBuf, long outLength, long *outPos){	int				nPixels;	ULong	rgb32;    unsigned short	rgb16;    nPixels = 0;	if (mode == TRUE_SHIFT_UP)		{		if (imageDepth == 16)			{			if (screenDepth == 24)				{				if (count)					{					memcpy(&leftovers[count], &inBuf[*inPos], 2-count);					(*inPos) += 2-count;					#if MACINTOSH					rgb16 = leftovers[0] << 8 | leftovers[1];					if (order == RGB_ORDER)						{						outBuf[(*outPos)++] = (unsigned char)((rgb16 >> 7) & 0xF8);						outBuf[(*outPos)++] = (unsigned char)((rgb16 >> 2) & 0xF8);						outBuf[(*outPos)++] = (unsigned char)((rgb16 << 3) & 0xF8);						}					else /* if (order == BGR_ORDER) */                        {						outBuf[(*outPos)++] = (unsigned char)((rgb16 << 2) & 0xF8);						outBuf[(*outPos)++] = (unsigned char)((rgb16 >> 3) & 0xF8);						outBuf[(*outPos)++] = (unsigned char)((rgb16 >> 8) & 0xF8);						}#elif WINDOWS					rgb16 = leftovers[1] << 8 | leftovers[0];					if (order == RGB_ORDER)						{						outBuf[(*outPos)++] = (unsigned char)((rgb16 << 3) & 0xF8);						outBuf[(*outPos)++] = (unsigned char)((rgb16 >> 2) & 0xF8);						outBuf[(*outPos)++] = (unsigned char)((rgb16 >> 7) & 0xF8);						}					else /* if (order == BGR_ORDER) */                        {						outBuf[(*outPos)++] = (unsigned char)((rgb16 >> 8) & 0xF8);						outBuf[(*outPos)++] = (unsigned char)((rgb16 >> 3) & 0xF8);						outBuf[(*outPos)++] = (unsigned char)((rgb16 << 2) & 0xF8);						}#endif					count = 0;					nPixels++;					}									while ((*outPos + 2 < outLength) && (*inPos + 1 < inLength))					{#if MACINTOSH					if (order == RGB_ORDER)						{						outBuf[(*outPos)++] = (unsigned char)((((unsigned short)inBuf[*inPos]) >> 7) & 0xF8);						outBuf[(*outPos)++] = (unsigned char)((((unsigned short)inBuf[*inPos]) >> 2) & 0xF8);						outBuf[(*outPos)++] = (unsigned char)((((unsigned short)inBuf[*inPos]) << 3) & 0xF8);						}					else /* if (order == BGR_ORDER) */                        {						outBuf[(*outPos)++] = (unsigned char)((((unsigned short)inBuf[*inPos]) << 2) & 0xF8);						outBuf[(*outPos)++] = (unsigned char)((((unsigned short)inBuf[*inPos]) >> 3) & 0xF8);						outBuf[(*outPos)++] = (unsigned char)((((unsigned short)inBuf[*inPos]) >> 8) & 0xF8);						}#elif WINDOWS					if (order == RGB_ORDER)						{						outBuf[(*outPos)++] = (unsigned char)((((unsigned short)inBuf[*inPos]) << 3) & 0xF8);						outBuf[(*outPos)++] = (unsigned char)((((unsigned short)inBuf[*inPos]) >> 2) & 0xF8);						outBuf[(*outPos)++] = (unsigned char)((((unsigned short)inBuf[*inPos]) >> 7) & 0xF8);						}					else /* if (order == BGR_ORDER) */                        {						outBuf[(*outPos)++] = (unsigned char)((((unsigned short)inBuf[*inPos]) >> 8) & 0xF8);						outBuf[(*outPos)++] = (unsigned char)((((unsigned short)inBuf[*inPos]) >> 3) & 0xF8);						outBuf[(*outPos)++] = (unsigned char)((((unsigned short)inBuf[*inPos]) << 2) & 0xF8);						}#endif					*inPos += 2;					*outPos += 3;					nPixels++;					}				if ((inLength - *inPos > 0) && (inLength - *inPos < 2))					{					leftovers[0] = inBuf[(*inPos)++];					count = 1;					}				}			else   /* 32-bit */				{				if (count)					{					memcpy(&leftovers[count], &inBuf[*inPos], 2-count);					(*inPos) += 2-count;					#if MACINTOSH					rgb16 = leftovers[0] << 8 | leftovers[1];					if (order == RGB_ORDER)						{						rgb32 = ARGB((unsigned char)((rgb16 >> 7) & 0xF8),							(unsigned char)((rgb16 >> 2) & 0xF8),							(unsigned char)((rgb16 << 3) & 0xF8));						}					else /* if (order == BGR_ORDER) */                        {						rgb32 = ABGR((unsigned char)((rgb16 >> 8) & 0xF8),							(unsigned char)((rgb16 >> 3) & 0xF8),							(unsigned char)((rgb16 << 2) & 0xF8));						}#elif WINDOWS					rgb16 = leftovers[1] << 8 | leftovers[0];					if (order == RGB_ORDER)						{						rgb32 = ARGB((unsigned char)((rgb16 >> 7) & 0xF8),							(unsigned char)((rgb16 >> 2) & 0xF8),							(unsigned char)((rgb16 << 3) & 0xF8));						}					else /* if (order == BGR_ORDER) */                        {						rgb32 = ABGR((unsigned char)((rgb16 >> 8) & 0xF8),							(unsigned char)((rgb16 >> 3) & 0xF8),							(unsigned char)((rgb16 << 2) & 0xF8));						}#endif					count = 0;					nPixels++;					}				while ((*outPos + 3 < outLength) && (*inPos +1 < inLength))					{					if (order == RGB_ORDER)						{						rgb32 = ARGB((unsigned char)((((unsigned short)inBuf[*inPos]) >> 7) & 0xF8),							(unsigned char)((((unsigned short)inBuf[*inPos]) >> 2) & 0xF8),							(unsigned char)((((unsigned short)inBuf[*inPos]) << 3) & 0xF8));						}					else /* if (order == BGR_ORDER) */                        {						rgb32 = ABGR((unsigned char)((((unsigned short)inBuf[*inPos]) >> 8) & 0xF8),							(unsigned char)((((unsigned short)inBuf[*inPos]) >> 3) & 0xF8),							(unsigned char)((((unsigned short)inBuf[*inPos]) << 2) & 0xF8));						}					memcpy(&outBuf[*outPos], &rgb32, 4);					*inPos += 2;					*outPos += 4;					nPixels++;					}									if ((inLength - *inPos > 0) && (inLength - *inPos < 2))					{					leftovers[0] = inBuf[(*inPos)++];					count = 1;					}				}            }		else /* depth = 24 and we're shifting up to a 32-bit screen */			{			if (count)				{				memcpy(&leftovers[count], &inBuf[*inPos], 3-count);				(*inPos) += 3-count;				if (order == RGB_ORDER)					rgb32 = ARGB(leftovers[0], leftovers[1], leftovers[2]);				else /* if (order == BGR_ORDER) */					rgb32 = ABGR(leftovers[0], leftovers[1], leftovers[2]);				count = 0;				nPixels++;				}			while ((*outPos + 3 < outLength) && (*inPos + 2 < inLength))				{ 				if (order == RGB_ORDER)					rgb32 = ARGB(inBuf[*inPos], inBuf[*inPos+1], inBuf[*inPos+2]);				else /* if (order == BGR_ORDER) */					rgb32 = ABGR(inBuf[*inPos], inBuf[*inPos+1], inBuf[*inPos+2]);				*inPos += 3;				memcpy(&outBuf[*outPos], &rgb32, 4);				*outPos += 4;				nPixels++;				}			if (((inLength - *inPos) > 0) && ((inLength - *inPos) < 3))				{				count = inLength - *inPos;				memcpy(&leftovers[0], &inBuf[*inPos], count);				*inPos += count;				}			}		}	else if (mode == TRUE_SHIFT_DOWN)    	/* convert from a higher-resolution mode to a lower */		{		if (imageDepth == 32)			{			if (screenDepth == 16)				{				if (count)					{					memcpy(&leftovers[count], &inBuf[*inPos], 4-count);					(*inPos) += 4-count;#if MACINTOSH					if (order == RGB_ORDER)						{						rgb16 = (unsigned short)(((short)leftovers[1] << 7) & 0x7C00);						rgb16 |= (unsigned short)(((short)leftovers[2] << 2) & 0x03E0);						rgb16 |= (unsigned short)((leftovers[3] >> 3) & 0x001F);						}					else /* if (order == BGR_ORDER) */						{						rgb16 = (unsigned short)(((short)leftovers[3] << 8) & 0xF800);						rgb16 |= (unsigned short)(((short)leftovers[2] << 3) & 0x07C0);                        rgb16 |= (unsigned short)((leftovers[1] >> 2) & 0x003E); 						}#elif WINDOWS					if (order == RGB_ORDER)						{						rgb16 = (unsigned short)(((short)leftovers[3] << 7) & 0x7C00);						rgb16 |= (unsigned short)(((short)leftovers[2] << 2) & 0x03E0);						rgb16 |= (unsigned short)((leftovers[1] >> 3) & 0x001F);						}					else /* if (order == BGR_ORDER) */						{						rgb16 = (unsigned short)(((short)leftovers[1] << 8) & 0xF800);						rgb16 |= (unsigned short)(((short)leftovers[2] << 3) & 0x07C0);                        rgb16 |= (unsigned short)((leftovers[3] >> 2) & 0x003E); 						}#endif					memcpy(&outBuf[*outPos], &rgb16, 2);					count = 0;					nPixels++;					}				while ((*outPos + 1 < outLength) && (*inPos + 3 < inLength))					{					rgb32 = ((ULong)inBuf[*inPos]);#if MACINTOSH					if (order == RGB_ORDER)						{						rgb16 = (unsigned short)((rgb32 >> 9) & 0x7C00);						rgb16 |= (unsigned short)((rgb32 >> 6) & 0x03E0);						rgb16 |= (unsigned short)((rgb32 >> 3) & 0x001F);						}					else /* if (order == BGR_ORDER) */						{						rgb16 = (unsigned short)((rgb32) & 0xF800);						rgb16 |= (unsigned short)((rgb32 >> 13) & 0x07C0);                        rgb16 |= (unsigned short)((rgb32 >> 18) & 0x003E); 						}#elif WINDOWS					if (order == RGB_ORDER)						{						rgb16 = (unsigned short)((rgb32 >> 10) & 0x7C00);						rgb16 |= (unsigned short)((rgb32 >> 13) & 0x03E0);						rgb16 |= (unsigned short)((rgb32 >> 16) & 0x001F);						}					else /* if (order == BGR_ORDER) */						{						rgb16 = (unsigned short)((rgb32 >> 8) & 0xF800);						rgb16 |= (unsigned short)((rgb32 >> 5) & 0x07C0);                        rgb16 |= (unsigned short)((rgb32 >> 2) & 0x003E); 						}#endif					memcpy(&outBuf[*outPos], &rgb16, 2);					*inPos += 4;					*outPos += 2;					nPixels++;					}				}			else   /* 24-bit */				{				if (count)					{					memcpy(&leftovers[count], &inBuf[*inPos], 4-count);					(*inPos) += 4-count;										if (order == RGB_ORDER)						rgb32 = ARGB(leftovers[1], leftovers[2], leftovers[3]);					else /* if (order == BGR_ORDER) */						rgb32 = ABGR(leftovers[1], leftovers[2], leftovers[3]);					count = 0;					nPixels++;					}				while ((*outPos + 2 < outLength) && (*inPos + 3 < inLength))					{					rgb32 = ((ULong)inBuf[*inPos]);					if (order == RGB_ORDER)						{						outBuf[(*outPos)++] = (unsigned char)((rgb32 >> 16) & 0x00FF);						outBuf[(*outPos)++] = (unsigned char)((rgb32 >> 8) & 0x00FF);						outBuf[(*outPos)++] = (unsigned char)(rgb32 & 0x00FF);						}					else /* if (order == BGR_ORDER) */						{						outBuf[(*outPos)++] = (unsigned char)((rgb32 >> 24) & 0x00FF);						outBuf[(*outPos)++] = (unsigned char)((rgb32 >> 16) & 0x00FF);						outBuf[(*outPos)++] = (unsigned char)((rgb32 >> 8) & 0x00FF);						}					*inPos += 4;					*outPos += 3;					nPixels++;					}				if (((inLength - *inPos) > 0) && ((inLength - *inPos) < 4))					{					count = inLength - *inPos;					memcpy(&leftovers[0], &inBuf[*inPos], count);					*inPos += count;					}				}			}		else /* depth = 24 and we're shifting down to a 16-bit screen */			{			if (count)				{				memcpy(&leftovers[count], &inBuf[*inPos], 3-count);				(*inPos) += 3-count;				#if MACINTOSH				if (order == RGB_ORDER)					{					rgb16 = ((unsigned short)leftovers[0] << 7) & 0x7C00;					rgb16 |= ((unsigned short)leftovers[1] << 2) & 0x03E0;					rgb16 |= ((unsigned short)leftovers[2] >> 3) & 0x001F;					}				else /* if (order == BGR_ORDER) */					{					rgb16 = ((unsigned short)leftovers[2] << 8) & 0xF800;					rgb16 |= ((unsigned short)leftovers[1] << 3) & 0x07C0;					rgb16 |= ((unsigned short)leftovers[0] >> 2) & 0x002E;					}#elif WINDOWS				if (order == RGB_ORDER)					{					rgb16 = ((unsigned short)leftovers[2] << 7) & 0x7C00;					rgb16 |= ((unsigned short)leftovers[1] << 2) & 0x03E0;					rgb16 |= ((unsigned short)leftovers[0] >> 3) & 0x001F;					}				else /* if (order == BGR_ORDER) */					{					rgb16 = ((unsigned short)leftovers[0] << 8) & 0xF800;					rgb16 |= ((unsigned short)leftovers[1] << 3) & 0x07C0;					rgb16 |= ((unsigned short)leftovers[2] >> 2) & 0x002E;					}#endif				memcpy(&outBuf[*outPos], &rgb16, 2);				(*outPos) += 2;				count = 0;				nPixels++;				}			while ((*outPos + 1 < outLength) && (*inPos + 2 < inLength))				{#if MACINTOSH				if (order == RGB_ORDER)					{					rgb16 = ((unsigned short)inBuf[(*inPos)++] << 7) & 0x7C00;					rgb16 |= ((unsigned short)inBuf[(*inPos)++] << 2) & 0x03E0;					rgb16 |= ((unsigned short)inBuf[(*inPos)++] >> 3) & 0x001F;					}				else /* if (order == BGR_ORDER) */					{					rgb16 = ((unsigned short)inBuf[(*inPos)++] >> 2) & 0x003E;					rgb16 |= ((unsigned short)inBuf[(*inPos)++] << 3) & 0x07C0;					rgb16 |= ((unsigned short)inBuf[(*inPos)++] << 8) & 0xF800;					}#elif WINDOWS				if (order == RGB_ORDER)					{					rgb16 = ((unsigned short)inBuf[(*inPos)++] >> 3) & 0x001F;					rgb16 |= ((unsigned short)inBuf[(*inPos)++] << 2) & 0x03E0;					rgb16 |= ((unsigned short)inBuf[(*inPos)++] << 7) & 0x7C00;					}				else /* if (order == BGR_ORDER) */					{					rgb16 = ((unsigned short)inBuf[(*inPos)++] << 8) & 0xF800;					rgb16 |= ((unsigned short)inBuf[(*inPos)++] << 3) & 0x07C0;					rgb16 |= ((unsigned short)inBuf[(*inPos)++] >> 2) & 0x003E;					}#endif				memcpy(&outBuf[*outPos], &rgb16, 2);								(*outPos) += 2;				nPixels++;				}							if (((inLength - *inPos) > 0) && ((inLength - *inPos) < 2))				{				count = inLength - *inPos;				memcpy(&leftovers[0], &inBuf[*inPos], count);				*inPos += count;				}			}		}	else  	/* we can just byte-copy the strip (providing no swapping needs to be done) */		{		long outPix, inPix, copyCount;		short rgb61;        int stopPoint;				if (count)			{			memcpy(&leftovers[count], &inBuf[*inPos], (imageDepth/8 - count));			(*inPos) += (imageDepth/8 - count);			if (imageDepth == 16)				{#if MACINTOSH				if (order == RGB_ORDER)					memcpy(&outBuf[*outPos], leftovers, 2);				else	// order == BGR_ORDER                	{					memcpy(&rgb16, leftovers, 2);					rgb61 = (rgb16 >> 11) & 0x001F | (rgb16 >> 1) & 0x03E0 | (rgb16 << 9) & 0x7C00;					memcpy(&outBuf[*outPos], &rgb61, 2);                	}#elif WINDOWS				if (order == RGB_ORDER)					{					memcpy(&rgb16, &inBuf[*inPos], 2);					rgb61 = (rgb16 >> 9) & 0x003E | (rgb16 << 1) & 0x07C0 | (rgb16 << 11) & 0xF100;					memcpy(&outBuf[*outPos], &rgb61, 2);					}				else // order == BGR_ORDER                	memcpy(&outBuf[*outPos], leftovers, 2);#endif                				(*outPos) += 2;				}			else if (imageDepth == 24)				{#if MACINTOSH				if (order == RGB_ORDER)#elif WINDOWS				if (order == BGR_ORDER)#endif					{					memcpy(&outBuf[*outPos], leftovers, 3);					}				else					{					outBuf[(*outPos)] = leftovers[2];					outBuf[(*outPos)+1] = leftovers[1];					outBuf[(*outPos)+2] = leftovers[0];					}				(*outPos) += 3;				}			else	// imageDepth == 32				{#if MACINTOSH				if (order == RGB_ORDER)#elif WINDOWS				if (order == BGR_ORDER)#endif					{					memcpy(&outBuf[*outPos], leftovers, 4);					}				else					{					outBuf[(*outPos)] = leftovers[3];					outBuf[(*outPos)+1] = leftovers[2];					outBuf[(*outPos)+2] = leftovers[1];					outBuf[(*outPos)+3] = leftovers[0];					}				(*outPos) += 4;				}			nPixels += count/(screenDepth/8);			}					outPix = outLength - *outPos;		inPix = inLength - *inPos;				if (outPix < inPix)			/* the outbuf is the limiting factor */			copyCount = outPix;		else if (outPix > inPix) 	/* the inbuf is the limiting factor */        	copyCount = inPix;		else						/* both buffers are the same size */			copyCount = inPix;				if (copyCount % inBytesPerPixel)			{			count = copyCount % inBytesPerPixel;			copyCount /= inBytesPerPixel;			copyCount *= inBytesPerPixel;			}		stopPoint = *inPos + copyCount;#if MACINTOSH		if (order == RGB_ORDER)        	{			memcpy(&outBuf[*outPos], &inBuf[*inPos], copyCount);			*outPos += copyCount;			*inPos += copyCount;        	}		else	// BGR_ORDER			{			if (imageDepth == 16)				{				for (	; *inPos < stopPoint; (*inPos)+=2, (*outPos)+=2)					{					memcpy(&rgb16, &inBuf[*inPos], 2);					rgb61 = (rgb16 >> 11) & 0x001F | (rgb16 >> 1) & 0x03E0 | (rgb16 << 9) & 0x7C00;					memcpy(&outBuf[*outPos], &rgb61, 2);					}				}			else if (imageDepth == 24)				{				for (   ; *inPos < stopPoint; (*inPos)+=3)					{					outBuf[(*outPos)++] = inBuf[(*inPos)+2];					outBuf[(*outPos)++] = inBuf[(*inPos)+1];					outBuf[(*outPos)++] = inBuf[*inPos];					}				}			else	// imagedepth == 32				{				for (	; *inPos < stopPoint; (*inPos)+=4)					{					outBuf[(*outPos)++] = inBuf[(*inPos)+3];					outBuf[(*outPos)++] = inBuf[(*inPos)+2];					outBuf[(*outPos)++] = inBuf[(*inPos)+1];					outBuf[(*outPos)++] = inBuf[*inPos];					}				}			}#elif WINDOWS		if (order == RGB_ORDER)			{			if (imageDepth == 16)				{                short	rgb61;				for (	; *inPos < stopPoint; (*inPos)+=2, (*outPos)+=2)					{					memcpy(&rgb16, &inBuf[*inPos], 2);					rgb61 = (rgb16 >> 9) & 0x003E | (rgb16 << 1) & 0x07C0 | (rgb16 << 11) & 0xF100;					memcpy(&outBuf[*outPos], &rgb61, 2);					}				}			else if (imageDepth == 24)				{				for (   ; *inPos < stopPoint; (*inPos)+=3)					{					outBuf[(*outPos)++] = inBuf[(*inPos)+2];					outBuf[(*outPos)++] = inBuf[(*inPos)+1];					outBuf[(*outPos)++] = inBuf[*inPos];					}				}			else	// imagedepth == 32				{				for (	; *inPos < stopPoint; (*inPos)+=4)					{					outBuf[(*outPos)++] = inBuf[(*inPos)+3];					outBuf[(*outPos)++] = inBuf[(*inPos)+2];					outBuf[(*outPos)++] = inBuf[(*inPos)+1];					outBuf[(*outPos)++] = inBuf[(*inPos)];					}				}			}		else 	// BGR_ORDER			{			memcpy(&outBuf[*outPos], &inBuf[*inPos], copyCount);			*outPos += copyCount;			*inPos += copyCount;        	}#endif		nPixels += copyCount/(screenDepth/8);				if (count >= 1)			{			memcpy(&leftovers[0], &inBuf[*inPos], count);			(*inPos) += count;			}		}   	return(nPixels);}/* a few local routines for manipulating the colors *//* convert rgb bytes to hsv bytes */int	RGBtoHSVLocal(int r,int g,int b,int *h,int *s,int *v){	int	min, max, delta;		min = min(r, min(g,b));	max = max(r, max(g,b));		*v = max;	if (max != 0)		{			delta = max-min;		*s = ((255L)*delta + (max - 1))/max;		}	else		*s = 0;	if (*s == 0)		*h = GRAY;	else		{					if (r == max)			*h = (255L * (g - b) + (delta - 1))/delta;		else if (g == max)			*h = 0x01FE + (255L * (b - r) + (delta - 1))/delta;		else if (b == max)			*h = 0x03FC + (255L * (r - g) + (delta - 1))/delta;				*h = (*h + 5)/6 ;		if (*h < 0.0)			*h += 255;		}	return(0);}/* convert rgb bytes to hsl bytes */int	RGBtoHSLLocal(int r,int g,int b,int *h,int *s,int *l){	int	min, max, delta, gamma;		min = min(r, min(g,b));	max = max(r, max(g,b));		gamma = max+min;	*l = (gamma + 1)/2;	if (max == min)		{		*s = 0;		*h = GRAY;		}	else		{			delta = max-min;		if (*l <= 0x0080)			{			*s = ((255L)*delta + (gamma-1))/gamma;			}		else			{			*s = ((255L)*delta + (0x01FD-gamma))/(0x01FE - gamma);			}					if (r == max)			*h = (255L * (g - b) + (delta - 1))/delta;		else if (g == max)			*h = 0x01FE + (255L * (b - r) + (delta - 1))/delta;		else if (b == max)			*h = 0x03FC + (255L * (r - g) + (delta - 1))/delta;				*h = (*h + 5)/6 ;		if (*h < 0.0)			*h += 255;		}	return(0);}intLessHSLLocal(const void *l, const void *r){	if (((HSLColorInt*)l)->h < ((HSLColorInt*)r)->h)		return(-1);	else if (((HSLColorInt*)l)->h > ((HSLColorInt*)r)->h)		return(1);	else 		if (((HSLColorInt*)l)->s < ((HSLColorInt*)r)->s)			return(-1);		else if (((HSLColorInt*)l)->s > ((HSLColorInt*)r)->s)			return(1);		else			if (((HSLColorInt*)l)->l < ((HSLColorInt*)r)->l)				return(-1);			else if (((HSLColorInt*)l)->l > ((HSLColorInt*)r)->l)				return(1);			else				return(0);	}voidBuildCtabIndexLocal(TableIndex *indexTable, indexedHSL *hsl, int maxTabEntries){	int i;		i = 0;	indexTable[RED_INDEX].start = i;	while ((hsl[i].hsl.h < RED_YELLOW) && (i < maxTabEntries))		{		i++; 		indexTable[RED_INDEX].count++;		}	indexTable[RED_YELLOW_INDEX].start = i;	while ((hsl[i].hsl.h < YELLOW) && (i < maxTabEntries))		{		i++; 		indexTable[RED_YELLOW_INDEX].count++;		}	indexTable[YELLOW_INDEX].start = i;	while ((hsl[i].hsl.h < YELLOW_GREEN) && (i < maxTabEntries))		{		i++;		indexTable[YELLOW_INDEX].count++;		}	indexTable[YELLOW_GREEN_INDEX].start = i;	while ((hsl[i].hsl.h < GREEN) && (i < maxTabEntries))		{		i++;		indexTable[YELLOW_GREEN_INDEX].count++;		}	indexTable[GREEN_INDEX].start = i;	while ((hsl[i].hsl.h < GREEN_CYAN) && (i < maxTabEntries))		{		i++;		indexTable[GREEN_INDEX].count++;		}	indexTable[GREEN_CYAN_INDEX].start = i;	while ((hsl[i].hsl.h < CYAN) && (i < maxTabEntries))		{		i++;		indexTable[GREEN_CYAN_INDEX].count++;		}	indexTable[CYAN_INDEX].start = i;	while ((hsl[i].hsl.h < CYAN_BLUE) && (i < maxTabEntries))		{		i++;		indexTable[CYAN_INDEX].count++;		}	indexTable[CYAN_BLUE_INDEX].start = i;	while ((hsl[i].hsl.h < BLUE) && (i < maxTabEntries))		{		i++;		indexTable[CYAN_BLUE_INDEX].count++;		}	indexTable[BLUE_INDEX].start = i;	while ((hsl[i].hsl.h < BLUE_MAGENTA) && (i < maxTabEntries))		{		i++;		indexTable[BLUE_INDEX].count++;		}	indexTable[BLUE_MAGENTA_INDEX].start = i;	while ((hsl[i].hsl.h < MAGENTA) && (i < maxTabEntries))		{		i++;		indexTable[BLUE_MAGENTA_INDEX].count++;		}	indexTable[MAGENTA_INDEX].start = i;	while ((hsl[i].hsl.h < MAGENTA_RED) && (i < maxTabEntries))		{		i++;		indexTable[MAGENTA_INDEX].count++;		}	indexTable[MAGENTA_RED_INDEX].start = i;	while ((hsl[i].hsl.h < GRAY) && (i < maxTabEntries))		{		i++;		indexTable[MAGENTA_RED_INDEX].count++;		}	indexTable[GRAY_INDEX].start = i;	while ((hsl[i].hsl.h == GRAY) && (i < maxTabEntries))		{		i++; 		indexTable[GRAY_INDEX].count++;		}}voidCalcIndexStartLength(TableIndex *indices, int hue, int *start, int *count){	int lower, upper;		if (hue != GRAY)		{		lower = hue - HALF_RANGE;		upper = hue + HALF_RANGE;		if (lower < RED)			{			*start = indices[MAGENTA_RED_INDEX].start;			*count = indices[MAGENTA_RED_INDEX].count;			if (upper > RED)				*count += indices[RED_INDEX].count;			}		else if (lower < RED_YELLOW)			{			*start = indices[RED_INDEX].start;			*count = indices[RED_INDEX].count;			if (upper > RED_YELLOW)				*count += indices[RED_YELLOW_INDEX].count;			}		else if (lower < YELLOW)			{			*start = indices[RED_YELLOW_INDEX].start;			*count = indices[RED_YELLOW_INDEX].count;			if (upper > YELLOW)				*count += indices[YELLOW_INDEX].count;			}		else if (lower < YELLOW_GREEN)			{			*start = indices[YELLOW_INDEX].start;			*count = indices[YELLOW_INDEX].count;			if (upper > YELLOW_GREEN)				*count += indices[YELLOW_GREEN_INDEX].count;			}		else if (lower < GREEN)			{			*start = indices[YELLOW_GREEN_INDEX].start;			*count = indices[YELLOW_GREEN_INDEX].count;			if (upper > GREEN)				*count += indices[GREEN_INDEX].count;			}		else if (lower < GREEN_CYAN)			{			*start = indices[GREEN_INDEX].start;			*count = indices[GREEN_INDEX].count;			if (upper > GREEN_CYAN)				*count += indices[GREEN_CYAN_INDEX].count;			}		else if (lower < CYAN)			{			*start = indices[GREEN_CYAN_INDEX].start;			*count = indices[GREEN_CYAN_INDEX].count;			if (upper > CYAN)				*count += indices[CYAN_INDEX].count;			}		else if (lower < CYAN_BLUE)			{			*start = indices[CYAN_INDEX].start;			*count = indices[CYAN_INDEX].count;			if (upper > CYAN_BLUE)				*count += indices[CYAN_BLUE_INDEX].count;			}		else if (lower < BLUE)			{			*start = indices[CYAN_BLUE_INDEX].start;			*count = indices[CYAN_BLUE_INDEX].count;			if (upper > BLUE)				*count += indices[BLUE_INDEX].count;			}		else if (lower < BLUE_MAGENTA)			{			*start = indices[BLUE_INDEX].start;			*count = indices[BLUE_INDEX].count;			if (upper > BLUE_MAGENTA)				*count += indices[BLUE_MAGENTA_INDEX].count;			}		else if (lower < MAGENTA)			{			*start = indices[BLUE_MAGENTA_INDEX].start;			*count = indices[BLUE_MAGENTA_INDEX].count;			if (upper > MAGENTA)				*count += indices[MAGENTA_INDEX].count;			}		else if (lower < MAGENTA_RED)			{			*start = indices[MAGENTA_INDEX].start;			*count = indices[MAGENTA_INDEX].count;			if (upper > MAGENTA_RED)				*count += indices[MAGENTA_RED_INDEX].count;			}		else /* lower > MAGENTA_RED && lower < MAX_HUE */			{			*start = indices[MAGENTA_RED_INDEX].start;			*count = indices[MAGENTA_RED_INDEX].count;			if (upper > MAX_HUE)				*count += indices[RED_INDEX].count;			}		}}/* this just calls AlertMEssage with a memory shortage error.  Itgets called around 25 times in this module, which really adds up(1800 bytes).  Kudos to Borland for putting a 64KB cap on thedata for the program.  */int		MemoryErrorCall(void){	AlertMessage(TXTW_MEMORY);   }// jca 17 Sept 93.  }#endif // VWT