/*------------------------------------------------------------------------------ * Copyright _ 1995 by Virtus Corporation * All Rights Reserved * Written by  David A. Smith, Drew Davidson * Virtus Corporation * 118 MacKenan Drive, Suite 250 * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------      SpotLight {      # Light from above        location 0 4 0        direction 0 -1 0        intensity       0.9        cutOffAngle     0.7    } */#include "Exp2VRML.h"//#define TXT_VPRODUCT "Virtus WalkThrough VRML 1.0" EOL#define TXT_VPRODUCT "Virtus WalkThrough Pro 2.5" EOL				// PRO25#define TXT_VFILTER TAB "VRML Export Filter" EOL#define TXT_VCORP TAB "Virtus Corporation" EOL#define TXT_VSTREET TAB "118 MacKenan Drive, Suite 250" EOL#define TXT_VCITY TAB "Cary, NC 27511" EOL#define TXT_VPHONE TAB "919-467-9700" // Export_VRML::OpenExp// After the stream is opened via Export_Shard, we save all pertinent preamble information// If required, we can call IOLighting() and IOCamera() at this time...intExport_VRML::ExportOpen(V_Buffer *buf, ExportUnit type, double size)	{	/* ... open export channel ... */	IOString(buffer,(strPtr)"#VRML V1.0 ascii" EOL);	IOString(buffer,EOL);	IOIndentString(buffer,(strPtr)"Separator {"  EOL,indent); indent++;	IOIndentString(buffer,(strPtr)"Info { string " QUOTE TXT_VPRODUCT TXT_VFILTER TXT_VCORP TXT_VSTREET TXT_VCITY TXT_VPHONE QUOTE CBRACE EOL,indent);	IOString(buffer,EOL);		IOLighting();			// ABD PRO25	IOIndentString(buffer,(strPtr)"ShapeHints {" EOL,indent); indent++;	IOIndentString(buffer,(strPtr)"vertexOrdering	CLOCKWISE" EOL,indent);	IOIndentString(buffer,(strPtr)"shapeType	SOLID" EOL,indent); 	IOIndentString(buffer,(strPtr)"}" EOL,indent); indent--;	IOString(buffer,EOL);	IOIndentString(buffer,(strPtr)"Transform {" EOL, indent); indent++;	IOIndentString(buffer,(strPtr)"translation 0 0 0" EOL, indent); 	IOIndentString(buffer,(strPtr)"scaleFactor 1.0 1.0 1.0" EOL, indent);	IOIndentString(buffer,(strPtr)"}" EOL,indent); indent--;	IOString(buffer,EOL);	indent=0; // DAS 95.09.29	coordnum=0;	return(0);	}// Export_VRML::Close()// Finalize file output for closing by Export_Shard.intExport_VRML::ExportClose()	{	/* ... close export channel ... */	indent--; IOIndentString(buffer,(strPtr)"}"  EOL, indent); 	return 0;	}// Export_VRML::IOLighting()// Export the lighting characteristics of this model. Most likely these will// be either a standard default, or more appropriately, they will be the actual// lighting values of the global model.// PRO25 [[[intExport_VRML::IOLighting()	{	char str[256];	int val;		IOIndentString(buffer,(strPtr)"DirectionalLight {"  EOL,indent); indent++;		//------	sprintf(str, "on         TRUE       # SFBool%s", EOL);	IOIndentString(buffer,(strPtr)str, indent);	sprintf(str, "intensity  1          # SFFloat%s", EOL);	IOIndentString(buffer,(strPtr)str, indent);	sprintf(str, "color      1 1 1      # SFColor%s", EOL);	IOIndentString(buffer,(strPtr)str, indent);	sprintf(str, "direction  0 0 -1     # SFVec3f%s", EOL);	IOIndentString(buffer,(strPtr)str, indent);	//------		indent--; IOIndentString(buffer,(strPtr)"}"  EOL, indent); 	IOString(buffer,EOL);	return(0);	}// PRO25 ]]]//  Export_VRML::ExportPolyhedron2()		// PRO25//  Duh...intExport_VRML::ExportPolyhedron2()		// PRO25	{	int i;	char defstr[256];	char usestr[256];	char str[256];	long plen;		// ABD-VRML4	P3D* poly;		// ABD-VRML4	int slen;		// ABD-VRML4	RGBAColor acolor;		// ABD-VRML4	SurfInfo* psInfo;		// ABD-VRML4	if(polyhedron->HasVRMLAnchor())		{		int i;		V_Array *anchor=polyhedron->GetVRMLAnchor();		char *a=(char*)anchor->Use();		int len=anchor->ALength();		for(i=0;i<len && i<254;i++)str[i]=a[i];		anchor->Unuse();		str[len]=0;		IOIndentString(buffer,(strPtr)"WWWAnchor {" EOL,indent); indent++;    	IOIndentString(buffer,(strPtr)"name ",indent);		// write out URL string here...		IOString(buffer,QUOTE);		IOString(buffer,(strPtr)str);        IOString(buffer,QUOTE EOL);    	IOIndentString(buffer,(strPtr)"map NONE" EOL,indent);    	}	IOIndentString(buffer,(strPtr)"Separator { #Polyhedron"  EOL,indent); indent++;	// Save the overall polyhedron color		sprintf(defstr, "DEF COORD%d Coordinate3 {" EOL,coordnum); 	// PRO25 don't immediately USE; DEF already creates an instance	// PRO25 sprintf(usestr, "USE COORD%d" EOL,coordnum); coordnum++;	IOIndentString(buffer,(strPtr)defstr,indent);indent++;		// First, save all of the points of this polyhedron...	IOIndentString(buffer,(strPtr)"point [",indent);	plen=polyPoints->ALength();		// ABD-VRML4	poly=(P3D*)polyPoints->Use();		// ABD-VRML4		for(i=0;i<plen;i++)		{		IOString(buffer,  EOL);		sprintf(str,"%lf %lf %lf",poly[i].x,poly[i].z,-poly[i].y);		IOIndentString(buffer,(strPtr)str,indent);		if(i==plen-1)IOString(buffer,(strPtr)" ]"  EOL);		else IOString(buffer,(strPtr)" ,");		}	indent--; IOIndentString(buffer,(strPtr)"} #Coordinate3"  EOL,indent);	polyPoints->Unuse();	// PRO25 don't immediately USE; DEF already creates an instance	// PRO25 // IOIndentString(buffer,(strPtr)usestr,indent);		// Save SURFACE information	slen=surfArray->ALength();	// Save all of the surface materials...	IOIndentString(buffer,(strPtr)"Material {" EOL, indent); indent++;	// ABD-VRML4	psInfo=(SurfInfo*)surfArray->Use();	// ABD-VRML4				// ambient color	IOIndentString(buffer,(strPtr)"ambientColor [",indent);	for(i=0;i<slen;i++)		{		char str[256];		acolor=psInfo[i].sColor;		sprintf(str," %lf %lf %lf",	acolor.red/(4*BIT32F), 		// PRO25									acolor.green/(4*BIT32F), 	// PRO25									acolor.blue/(4*BIT32F));	// PRO25		if(i!=0)IOIndentString(buffer,(strPtr)"              ",indent); 		IOString(buffer,str);		if(i<slen-1)IOString(buffer, "," EOL);		else IOString(buffer,"] #ambientColor" EOL);		}	//diffuse color	IOIndentString(buffer,(strPtr)"diffuseColor [",indent);	for(i=0;i<slen;i++)		{		char str[256];		acolor=psInfo[i].sColor;		sprintf(str," %lf %lf %lf",	acolor.red/BIT32F,		// PRO25									acolor.green/BIT32F,	// PRO25									acolor.blue/BIT32F);	// PRO25		if(i!=0)IOIndentString(buffer,(strPtr)"              ",indent); 		IOString(buffer,str);		if(i<slen-1)IOString(buffer, "," EOL);		else IOString(buffer,"] #diffuseColor" EOL);		}	// transparency	IOIndentString(buffer,(strPtr)"transparency [",indent);	for(i=0;i<slen;i++)		{		char str[256];		acolor=psInfo[i].sColor;		sprintf(str," %lf",	acolor.alpha/BIT32F);		// PRO25		if(i!=0)IOIndentString(buffer,(strPtr)"              ",indent); 		IOString(buffer,str);		if(i<slen-1)IOString(buffer, "," EOL);		else IOString(buffer,"] #transparency" EOL);		}	IOIndentString(buffer, (strPtr)"} #Material" EOL EOL,indent); indent--;	surfArray->Unuse(); // 95.09.29 DAS Don't forget to Unuse the VArray	//---------------------	// TEXTURE STUFF		// Save SURFACE information	slen=surfArray->ALength();	// Save all of the surface materials...	IOIndentString(buffer,(strPtr)"Texture2 {" EOL, indent); indent++;	// ABD-VRML4	psInfo=(SurfInfo*)surfArray->Use();	// ABD-VRML4				// texture name	IOIndentString(buffer,(strPtr)"filename [",indent);	for(i=0;i<slen;i++)	{	char str[256];	char txname[256];						if (psInfo[i].surfDef != NULL)		{			psInfo[i].surfDef->GetTextureName(SURF_SHARED, txname);			sprintf(str," \"%s%s\"", txname, texture_ext);	// PRO25			if(i!=0)IOIndentString(buffer,(strPtr)"              ",indent); 			IOString(buffer,str);			IOString(buffer, "," EOL);		}		else		{			sprintf(str," \"\"");	// PRO25			if(i!=0)IOIndentString(buffer,(strPtr)"              ",indent); 			IOString(buffer,str);			IOString(buffer, "," EOL);		}				// else IOString(buffer,"] #filename" EOL);	}	IOString(buffer,"] #filename" EOL);		//wrapS	IOIndentString(buffer,(strPtr)"wrapS [",indent);	for(i=0;i<slen;i++)	{	char str[256];				sprintf(str," REPEAT");		if(i!=0)IOIndentString(buffer,(strPtr)"              ",indent); 		IOString(buffer,str);		IOString(buffer, "," EOL);		//else IOString(buffer,"] #wrapS" EOL);	}	IOString(buffer,"] #wrapS" EOL);			// wrapT	IOIndentString(buffer,(strPtr)"wrapT [",indent);	for(i=0;i<slen;i++)	{	char str[256];		sprintf(str," REPEAT");		// PRO25		if(i!=0)IOIndentString(buffer,(strPtr)"              ",indent); 		IOString(buffer,str);		IOString(buffer, "," EOL);	}	IOString(buffer,"] #wrapT" EOL);				IOIndentString(buffer, (strPtr)"} #Texture2" EOL EOL,indent); indent--;	surfArray->Unuse();	//---------------------	//	IOIndentString(buffer,(strPtr)"MaterialBinding {" EOL, indent); indent++;//	IOIndentString(buffer,(strPtr)"value PER_FACE" EOL,indent);//	IOIndentString(buffer,(strPtr)"} #MaterialBinding" EOL EOL,indent); indent--;	// Save all of the surface indices...	IOIndentString(buffer,(strPtr)"IndexedFaceSet {"  EOL,indent); indent++;	IOIndentString(buffer,(strPtr)"	coordIndex [ ",indent);	for(i=0;i<slen;i++)		{		SurfInfo sInfo;		int j;		// ABD-VRML4		int len;		// ABD-VRML4				V_Array *surface;		short *indices;		sInfo.surface=sInfo.surfaces=NULL;		// ABD-VRML4 moved this		surfArray->Get(i,&sInfo);		// save the color of the individual surface 		//		IOIndentString(buffer,(strPtr)usestr,indent);		 len=sInfo.surface->ALength();		// ABD-VRML4		indices=(short*) sInfo.surface->Use();//		IOIndentString(buffer,(strPtr)"IndexedFaceSet {"  EOL,indent); indent++;//		IOIndentString(buffer,(strPtr)"	coordIndex [ ",indent);		if(i!=0)IOIndentString(buffer,(strPtr)"              ",indent); 		for( j=0;j<len;j++)		// ABD-VRML4			{			sprintf(str,"%d,",indices[j]-1);			IOString(buffer,(strPtr)str);			}		sInfo.surface->Unuse();//		sInfo.surface->dArray(); // DAS 95.09.29 this is taken care of in ClosePolyhedron...				if(i==slen-1)			IOString(buffer,(strPtr)"-1]" EOL);		else			IOString(buffer, (strPtr)"-1," EOL);//		indent--; IOIndentString(buffer,(strPtr)"} #IndexedFaceSet"  EOL,indent);		}	indent--; IOIndentString(buffer,(strPtr)"} #IndexedFaceSet"  EOL,indent);		indent--; IOIndentString(buffer,(strPtr)"} #Polyhedron"  EOL,indent);	if(polyhedron->HasVRMLAnchor())		{indent--; IOIndentString(buffer,(strPtr)"} #WWWAnchor"  EOL,indent);}		return(0);	}// Export_VRML::ClosePolyhedron()// Finalize output of polyhedron object. Note that Export_Shard::ClosePolyhedron is called at// the end to finalize output and perform cleanup tasks.intExport_VRML::ExportPolyhedron()	{	int i;	char defstr[256];	char usestr[256];	char str[256];	long plen;		// ABD-VRML4	P3D* poly;		// ABD-VRML4	int slen;		// ABD-VRML4	RGBAColor acolor;		// ABD-VRML4	SurfInfo* psInfo;		// ABD-VRML4	int num_surf_anchors = 1;		// PRO25 one repeat by default	int poly_repeat_num;			// PRO25	V_Array *surf_anchors[256];		// PRO25	// PRO25 if poly has URL, then only do it and forget about surface URLs	if(polyhedron->HasVRMLAnchor())		{		return ExportPolyhedron2();    	}			// PRO25 [[[	// get a count of the number of surfaces with URLs	// then we export this same polyhedron that # of times plus one, each time	// omitting the surfaces with no URLs and/or different URLs.  This is due	// to the completely moronic method of assigning URLs to objects in VRML.		if (polyhedron->surfDef)	{	int i;			surf_anchors[0] = NULL;				for (i = 0 ; i < polyhedron->surfDef->ALength() ; i++ )		{		SurfDef *sd;			polyhedron->surfDef->Get(i, &sd);			if (sd != NULL)				if (sd->HasVRMLAnchor())				{					surf_anchors[num_surf_anchors] = sd->GetVRMLAnchor();					num_surf_anchors++;				}		}	}	// PRO25 ]]]			// PRO25		for ( poly_repeat_num = 0 ; poly_repeat_num < num_surf_anchors ; poly_repeat_num++ )	{			// if poly_repeat_num == 0, we export all surfaces without URLs		// if poly_repeat_num == 1, we export all surfaces with URL == surf_anchors[1]		// if poly_repeat_num == 2, we export all surfaces with URL == surf_anchors[2]		// etc.		// write out the anchor		if(poly_repeat_num > 0)		{		int i;		V_Array *anchor=surf_anchors[poly_repeat_num];		char *a=(char*)anchor->Use();		int len=anchor->ALength();		for(i=0;i<len && i<254;i++)str[i]=a[i];		anchor->Unuse();		str[len]=0;		IOIndentString(buffer,(strPtr)"WWWAnchor {" EOL,indent); indent++;    	IOIndentString(buffer,(strPtr)"name ",indent);		// write out URL string here...		IOString(buffer,QUOTE);		IOString(buffer,(strPtr)str);        IOString(buffer,QUOTE EOL);    	IOIndentString(buffer,(strPtr)"map NONE" EOL,indent);		}						// PRO25 OK now we have to write out only those surfaces that match this URL							IOIndentString(buffer,(strPtr)"Separator { #Polyhedron"  EOL,indent); indent++;		// Save the overall polyhedron color								// OK we only do the DEF the first time, other times we do a USE				if (poly_repeat_num == 0)		{			sprintf(defstr, "DEF COORD%d Coordinate3 {" EOL,coordnum); 					// PRO25 don't immediately USE; DEF already creates an instance			// PRO25 sprintf(usestr, "USE COORD%d" EOL,coordnum); coordnum++;					IOIndentString(buffer,(strPtr)defstr,indent);indent++;						// First, save all of the points of this polyhedron...			IOIndentString(buffer,(strPtr)"point [",indent);					plen=polyPoints->ALength();		// ABD-VRML4			poly=(P3D*)polyPoints->Use();		// ABD-VRML4						for(i=0;i<plen;i++)			{				IOString(buffer,  EOL);				sprintf(str,"%lf %lf %lf",poly[i].x,poly[i].z,-poly[i].y);						IOIndentString(buffer,(strPtr)str,indent);				if(i==plen-1)IOString(buffer,(strPtr)" ]"  EOL);				else IOString(buffer,(strPtr)" ,");			}			indent--; IOIndentString(buffer,(strPtr)"} #Coordinate3"  EOL,indent);			polyPoints->Unuse();			// PRO25 MOVED DOWN polyPoints->dArray();			// PRO25 MOVED DOWN polyPoints=NULL;					// PRO25 don't immediately USE; DEF already creates an instance			// PRO25 // IOIndentString(buffer,(strPtr)usestr,indent);		}		else		{			sprintf(usestr, "USE COORD%d" EOL,coordnum);			IOIndentString(buffer,(strPtr)usestr,indent);		}				// Save SURFACE information		slen=surfArray->ALength();		// Save all of the surface materials...		IOIndentString(buffer,(strPtr)"Material {" EOL, indent); indent++;		// ABD-VRML4		psInfo=(SurfInfo*)surfArray->Use();			// ABD-VRML4						// ambient color		IOIndentString(buffer,(strPtr)"ambientColor [",indent);		for(i=0;i<slen;i++)		{		char str[256];					// PRO25 [[[			if (poly_repeat_num == 0)			{				// skip surfaces with URLs on first pass				if ((psInfo[i].surfDef) && (psInfo[i].surfDef->HasVRMLAnchor()))					goto next_surf1;			}			else			{				// only do surfaces with the current URL (surf_anchors[poly_repeat_num])				// that is, if 				if (psInfo[i].surfDef == NULL)					goto next_surf1;									if (psInfo[i].surfDef->GetVRMLAnchor() != surf_anchors[poly_repeat_num])					goto next_surf1;			}			// PRO25 ]]]							acolor=psInfo[i].sColor;			sprintf(str," %lf %lf %lf",	acolor.red/(4*BIT32F), 		// PRO25										acolor.green/(4*BIT32F), 	// PRO25										acolor.blue/(4*BIT32F));	// PRO25			if(i!=0)IOIndentString(buffer,(strPtr)"              ",indent); 			IOString(buffer,str);			IOString(buffer, "," EOL);						next_surf1:				;			// else IOString(buffer,"] #ambientColor" EOL);		}		IOString(buffer,"] #ambientColor" EOL);				//diffuse color		IOIndentString(buffer,(strPtr)"diffuseColor [",indent);		for(i=0;i<slen;i++)		{		char str[256];						// PRO25 [[[			if (poly_repeat_num == 0)			{				// skip surfaces with URLs on first pass				if ((psInfo[i].surfDef) && (psInfo[i].surfDef->HasVRMLAnchor()))					goto next_surf2;			}			else			{				// only do surfaces with the current URL (surf_anchors[poly_repeat_num])				// that is, if 				if (psInfo[i].surfDef == NULL)					goto next_surf2;									if (psInfo[i].surfDef->GetVRMLAnchor() != surf_anchors[poly_repeat_num])					goto next_surf2;			}			// PRO25 ]]]			acolor=psInfo[i].sColor;			sprintf(str," %lf %lf %lf",	acolor.red/BIT32F,		// PRO25										acolor.green/BIT32F,	// PRO25										acolor.blue/BIT32F);	// PRO25			if(i!=0)IOIndentString(buffer,(strPtr)"              ",indent); 			IOString(buffer,str);			IOString(buffer, "," EOL);			next_surf2:				;			//else IOString(buffer,"] #diffuseColor" EOL);		}		IOString(buffer,"] #diffuseColor" EOL);						// transparency		IOIndentString(buffer,(strPtr)"transparency [",indent);		for(i=0;i<slen;i++)		{		char str[256];			// PRO25 [[[			if (poly_repeat_num == 0)			{				// skip surfaces with URLs on first pass				if ((psInfo[i].surfDef) && (psInfo[i].surfDef->HasVRMLAnchor()))					goto next_surf3;			}			else			{				// only do surfaces with the current URL (surf_anchors[poly_repeat_num])				// that is, if 				if (psInfo[i].surfDef == NULL)					goto next_surf3;									if (psInfo[i].surfDef->GetVRMLAnchor() != surf_anchors[poly_repeat_num])					goto next_surf3;			}			// PRO25 ]]]			acolor=psInfo[i].sColor;			sprintf(str," %lf",	acolor.alpha/BIT32F);		// PRO25			if(i!=0)IOIndentString(buffer,(strPtr)"              ",indent); 			IOString(buffer,str);			IOString(buffer, "," EOL);			next_surf3:				;		}		IOString(buffer,"] #transparency" EOL);		surfArray->Unuse();		// DAS 95.09.29 Unuse the VArray				IOIndentString(buffer, (strPtr)"} #Material" EOL EOL,indent); indent--;				//---------------------		// TEXTURE STUFF				// Save SURFACE information		slen=surfArray->ALength();		// Save all of the surface materials...		IOIndentString(buffer,(strPtr)"Texture2 {" EOL, indent); indent++;		// ABD-VRML4		psInfo=(SurfInfo*)surfArray->Use();			// ABD-VRML4						// texture name		IOIndentString(buffer,(strPtr)"filename [",indent);		for(i=0;i<slen;i++)		{		char str[256];		char txname[256];					// PRO25 [[[			if (poly_repeat_num == 0)			{				// skip surfaces with URLs on first pass				if ((psInfo[i].surfDef) && (psInfo[i].surfDef->HasVRMLAnchor()))					goto next_surf1t;			}			else			{				// only do surfaces with the current URL (surf_anchors[poly_repeat_num])				// that is, if 				if (psInfo[i].surfDef == NULL)					goto next_surf1t;									if (psInfo[i].surfDef->GetVRMLAnchor() != surf_anchors[poly_repeat_num])					goto next_surf1t;			}			// PRO25 ]]]							if (psInfo[i].surfDef != NULL)			{				psInfo[i].surfDef->GetTextureName(SURF_SHARED, txname);				sprintf(str," \"%s%s\"", txname, texture_ext);	// PRO25				if(i!=0)IOIndentString(buffer,(strPtr)"              ",indent); 				IOString(buffer,str);				IOString(buffer, "," EOL);			}			else			{				sprintf(str," \"\"");	// PRO25				if(i!=0)IOIndentString(buffer,(strPtr)"              ",indent); 				IOString(buffer,str);				IOString(buffer, "," EOL);			}						next_surf1t:				;			// else IOString(buffer,"] #filename" EOL);		}		IOString(buffer,"] #filename" EOL);				//wrapS		IOIndentString(buffer,(strPtr)"wrapS [",indent);		for(i=0;i<slen;i++)		{		char str[256];						// PRO25 [[[			if (poly_repeat_num == 0)			{				// skip surfaces with URLs on first pass				if ((psInfo[i].surfDef) && (psInfo[i].surfDef->HasVRMLAnchor()))					goto next_surf2t;			}			else			{				// only do surfaces with the current URL (surf_anchors[poly_repeat_num])				// that is, if 				if (psInfo[i].surfDef == NULL)					goto next_surf2t;									if (psInfo[i].surfDef->GetVRMLAnchor() != surf_anchors[poly_repeat_num])					goto next_surf2t;			}			// PRO25 ]]]			sprintf(str," REPEAT");			if(i!=0)IOIndentString(buffer,(strPtr)"              ",indent); 			IOString(buffer,str);			IOString(buffer, "," EOL);			next_surf2t:				;			//else IOString(buffer,"] #wrapS" EOL);		}		IOString(buffer,"] #wrapS" EOL);						// wrapT		IOIndentString(buffer,(strPtr)"wrapT [",indent);		for(i=0;i<slen;i++)		{		char str[256];			// PRO25 [[[			if (poly_repeat_num == 0)			{				// skip surfaces with URLs on first pass				if ((psInfo[i].surfDef) && (psInfo[i].surfDef->HasVRMLAnchor()))					goto next_surf3t;			}			else			{				// only do surfaces with the current URL (surf_anchors[poly_repeat_num])				// that is, if 				if (psInfo[i].surfDef == NULL)					goto next_surf3t;									if (psInfo[i].surfDef->GetVRMLAnchor() != surf_anchors[poly_repeat_num])					goto next_surf3t;			}			// PRO25 ]]]			sprintf(str," REPEAT");		// PRO25			if(i!=0)IOIndentString(buffer,(strPtr)"              ",indent); 			IOString(buffer,str);			IOString(buffer, "," EOL);			next_surf3t:				;		}		IOString(buffer,"] #wrapT" EOL);								IOIndentString(buffer, (strPtr)"} #Texture2" EOL EOL,indent); indent--;		surfArray->Unuse();		//---------------------			//	IOIndentString(buffer,(strPtr)"MaterialBinding {" EOL, indent); indent++;	//	IOIndentString(buffer,(strPtr)"value PER_FACE" EOL,indent);	//	IOIndentString(buffer,(strPtr)"} #MaterialBinding" EOL EOL,indent); indent--;			// Save all of the surface indices...		IOIndentString(buffer,(strPtr)"IndexedFaceSet {"  EOL,indent); indent++;		IOIndentString(buffer,(strPtr)"	coordIndex [ ",indent);		for(i=0;i<slen;i++)		{		SurfInfo sInfo;		int j;		// ABD-VRML4		int len;		// ABD-VRML4		V_Array *surface;		short *indices;			// PRO25 [[[			if (poly_repeat_num == 0)			{				// skip surfaces with URLs on first pass				if ((psInfo[i].surfDef) && (psInfo[i].surfDef->HasVRMLAnchor()))					goto next_surf4;			}			else			{				// only do surfaces with the current URL (surf_anchors[poly_repeat_num])				// that is, if 				if (psInfo[i].surfDef == NULL)					goto next_surf4;									if (psInfo[i].surfDef->GetVRMLAnchor() != surf_anchors[poly_repeat_num])					goto next_surf4;			}			// PRO25 ]]]						sInfo.surface=sInfo.surfaces=NULL;		// ABD-VRML4 moved this			surfArray->Get(i,&sInfo);			// save the color of the individual surface 				//		IOIndentString(buffer,(strPtr)usestr,indent);			 len=sInfo.surface->ALength();		// ABD-VRML4			indices=(short*) sInfo.surface->Use();	//		IOIndentString(buffer,(strPtr)"IndexedFaceSet {"  EOL,indent); indent++;	//		IOIndentString(buffer,(strPtr)"	coordIndex [ ",indent);				if(i!=0)IOIndentString(buffer,(strPtr)"              ",indent); 			for( j=0;j<len;j++)		// ABD-VRML4			{				sprintf(str,"%d,",indices[j]-1);				IOString(buffer,(strPtr)str);			}			sInfo.surface->Unuse();			// sInfo.surface->dArray();			IOString(buffer, (strPtr)"-1," EOL);			next_surf4:				;							//if(i==slen-1)			//	IOString(buffer,(strPtr)"-1]" EOL);			//else			//	IOString(buffer, (strPtr)"-1," EOL);			//		indent--; IOIndentString(buffer,(strPtr)"} #IndexedFaceSet"  EOL,indent);			// PRO25 MOVED DOWN surfArray->dArray();			// PRO25 MOVED DOWN surfArray=NULL;		}				IOString(buffer,(strPtr)"]" EOL);				indent--; IOIndentString(buffer,(strPtr)"} #IndexedFaceSet"  EOL,indent);				indent--; IOIndentString(buffer,(strPtr)"} #Polyhedron"  EOL,indent);		if(poly_repeat_num > 0)			{indent--; IOIndentString(buffer,(strPtr)"} #WWWAnchor"  EOL,indent);}		}	// end of for poly_repeat_num PRO25	// PRO25 delete the stuff 		coordnum++;		return(0);	}// Export_VRML::ExportSurface()// Export surface objects. Note Export_Shard::CloseSurface() is called for final cleanup.intExport_VRML::ExportSurface()	{	int i;    SurfInfo surfInfo;		// ABD-VRML4	int len=surfPoints->ALength();	#if 0	// PRO25 [[[	if ((surface->surfDef) && (surface->surfDef->HasVRMLAnchor()))	{	int i;	V_Array *anchor=surface->surfDef->GetVRMLAnchor();	char *a=(char*)anchor->Use();	int len=anchor->ALength();	char str[256];			for(i=0;i<len && i<254;i++)str[i]=a[i];		anchor->Unuse();		str[len]=0;		IOIndentString(buffer,(strPtr)"WWWAnchor {" EOL,indent); indent++;    	IOIndentString(buffer,(strPtr)"name ",indent);		// write out URL string here...		IOString(buffer,QUOTE);		IOString(buffer,(strPtr)str);        IOString(buffer,QUOTE EOL);    	IOIndentString(buffer,(strPtr)"map NONE" EOL,indent);    }	if ((surface->surfDef) && (surface->surfDef->HasVRMLAnchor()))		{indent--; IOIndentString(buffer,(strPtr)"} #WWWAnchor"  EOL,indent);}	// PRO25 ]]]	#endif		return(0);	}// Export_VRML::ExportFeature()// Export a surface feature. Note final cleanup done by Export_Shard::CloseFeature()intExport_VRML::ExportFeature()	{	// PRO25 [[[	if(feature->HasVRMLAnchor())	{	V_Array *anchor=feature->GetVRMLAnchor();	char *a=(char*)anchor->Use();	int len=anchor->ALength();	char str[256];	int i;		for(i=0;i<len && i<254;i++)str[i]=a[i];		anchor->Unuse();		str[len]=0;		IOIndentString(buffer,(strPtr)"WWWAnchor {" EOL,indent); indent++;    	IOIndentString(buffer,(strPtr)"name ",indent);		// write out URL string here...		IOString(buffer,QUOTE);		IOString(buffer,(strPtr)str);        IOString(buffer,QUOTE EOL);    	IOIndentString(buffer,(strPtr)"map NONE" EOL,indent);    }	// PRO25 ]]]	// PRO25 do some other stuff with features here ??	// PRO25 [[[	if(feature->HasVRMLAnchor())		{indent--; IOIndentString(buffer,(strPtr)"} #WWWAnchor"  EOL,indent);}	// PRO25 ]]]	return(0);	}