/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	 *				David W. Easter *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#if VWT // jca 17 Sept 93 {#if THINK_C			// PRO25#error don't use this file#else#include "XDXF3D-PPC.h"#endif#include "Polyhdrn.h"#include "Surface.h"#include "SurfDef.h"#include "WalkBuff.h"#include "AppFiles.h"#include "VArray.h"#include "VIO.h"#include "VMath.h"#include <string.h>voidExport_DXF3D::cExport()	{	ModelExport::cExport();	dxf = NULL;	osMode = mac_os;	colorMode = by_layer;	this->dxf_geometry = poly3d;	extrude = TRUE;	polyPoints = NULL;	polyLayer = 0;	polyColor.red = 0;	polyColor.green = 0;	polyColor.blue = 0;	polyColor.alpha = 0;	extrudable = 0;	baseSurf = NULL;	polyhedron = NULL;	surface = NULL;	}voidExport_DXF3D::Options3D(int os, int clr, int geo, int extr)	{	osMode = os;	colorMode = clr;	this->dxf_geometry = geo;	extrude = extr;	}int GetVersion(strPtr);intExport_DXF3D::Open(V_Buffer *buf, ExportUnit type, double size)	{	char string[256], version[256];	ModelExport::Open(buf, type, size);	dxf = OpenDxf((os_id)osMode, (color_mode)colorMode, (geometry)dxf_geometry);	strcpy(string, TXTD_DXFHEADER);	if (GetVersion(version))		{		strcat(string, " v");		strcat(string, version);		}   	OpenDxfHdr(dxf);   	DxfComment(dxf, string);   	CloseDxfHdr(dxf);	IOType(buffer, dxf, IO_DXFOUT);	return(0);	}intExport_DXF3D::Close()	{	CloseDxf(dxf);	IOType(buffer, dxf, IO_DXFOUT);   	DisposDxf(dxf);	dxf = NULL;	ModelExport::Close();	return(0);	}intExport_DXF3D::Layers(V_Array *layers)	{	int nLayers = layers->ALength(), i;	Layer *layer;	DxfInitLayers(dxf, nLayers);	layer = (Layer *)layers->Use();	for (i = 0; i < nLayers; i++, layer++)		DxfLayerData(dxf, layer->name, &layer->color);	layers->Unuse();	DxfEndLayers(dxf);	IOType(buffer, dxf, IO_DXFOUT);	return(0);	}voidExport_DXF3D::SetPolyhedron(Polyhedron *poly)	{	polyhedron = poly;	}intExport_DXF3D::OpenPolyhedron(V_Array *points, RGBAColor color, int layer)	{	polyPoints = new(V_Array);	polyPoints->cArray(0, sizeof(Point3DFFixed), 4);	TransformPoints(points, polyPoints);	polyLayer = layer;	polyColor = color;	extrudable = extrude && PolyExtrudable();	baseSurf = polyhedron->FindSurface(polyhedron->SurfCount()-1);	return(0);	}intExport_DXF3D::ClosePolyhedron()	{	polyPoints->dArray();	return(ModelExport::ClosePolyhedron());	}voidExport_DXF3D::SetSurface(Surface *surf)	{	surface = surf;	}intExport_DXF3D::OpenSurface(V_Array *pointRefs, RGBAColor color, Point3DFFixed normal)	{	V_Array *surfPoints;	DxfPBRec pb;	if (extrudable && surface != baseSurf)		return(0);	surfPoints = new(V_Array);	surfPoints->cArray(0, sizeof(Point3DFFixed), 4);	DerefPoints(polyPoints, pointRefs, surfPoints);	pb.h = dxf;	pb.layerIndex = polyLayer;	pb.nrPoints = surfPoints->ALength();	pb.thePoints = (Point3DFFixed*)surfPoints->Use();	if (!extrudable)		{		pb.color.red = color.red;		pb.color.green = color.green;		pb.color.blue = color.blue;		DxfPoly(&pb);		}	else		{		pb.color.red = polyColor.red;		pb.color.green = polyColor.green;		pb.color.blue = polyColor.blue;		pb.height = FFSub(polyhedron->point, polyhedron->base);		if (FFNegative(pb.height))			pb.height = FFNeg(pb.height);		DxfBase(&pb);		}	while (pb.status & 1)		{		GetDxfData(&pb);		IOType(buffer, dxf, IO_DXFOUT);		}	surfPoints->Unuse();	surfPoints->dArray();	return(0);	}intExport_DXF3D::OpenFeature(V_Array *points, RGBAColor color, int where, int connected)	{	V_Array *featPoints;	DxfPBRec pb;	if (connected) return(0);	featPoints = new(V_Array);	featPoints->cArray(0, sizeof(Point3DFFixed), 4);	TransformPoints(points, featPoints);	pb.h = dxf;	pb.layerIndex = polyLayer;	pb.color.red = color.red;	pb.color.green = color.green;	pb.color.blue = color.blue;	pb.nrPoints = featPoints->ALength();	pb.thePoints = (Point3DFFixed*)featPoints->Use();	DxfPoly(&pb);	while (pb.status & 1)		{		GetDxfData(&pb);		IOType(buffer, dxf, IO_DXFOUT);		}	featPoints->Unuse();	featPoints->dArray();	return(0);	}voidExport_DXF3D::Transform(void *in, void *out)	{	Point3DFFixed *pIn = (Point3DFFixed*)in, *pOut = (Point3DFFixed*)out;	*pOut = *pIn;	}intExport_DXF3D::PolyExtrudable()	{	if (polyhedron->inflate != INFL_EXTRUDE)		return(FALSE);	if (!PtFFZero(polyhedron->pointSkew) || !PtFFZero(polyhedron->baseSkew))		return(FALSE);	if (polyhedron->slices != NULL && polyhedron->slices->ALength() != 0)		return(FALSE);	if (polyhedron->surfDef)		{		int nSurfDefs, i;		SurfDef **sDef;		nSurfDefs = polyhedron->surfDef->ALength();		sDef = (SurfDef **)polyhedron->surfDef->Use();			for (i = 0; i < nSurfDefs; i++, sDef++)			{			if (*sDef && ((*sDef)->flags & SDEF_COLOR))				break;			}			polyhedron->surfDef->Unuse();			if (i != nSurfDefs)			return(FALSE);		}	return(TRUE);	}// jca 17 Sept 93 }#endif // VWT