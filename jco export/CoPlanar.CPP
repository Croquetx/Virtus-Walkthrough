/* *	CoPlanar.cpp * *	Copyright 1995 Virtus Corporation *	All rights reserved. *  Jonathan C. Owen *  Created 95.12.15 */ #include "COPLANAR.h"#include "VArray.h"#include "SurfDef.h"#include "SURFFEAT.h"#include "POLYHDRN.h"#include "math.h"#include "stdio.h"#include "ExpStr.h"#define POINT_TOL .01#define NORMAL_THRESHOLD .99  // direction check for coplanarity#define DISTANCE_THRESHOLD POINT_TOL // distance check for coplanarity#define SAME_DIR 2#define OPPOSITE 1double DotP3Dd( Point3Ddouble *a, Point3Ddouble *b ){    return (a->x*b->x + a->y*b->y + a->z*b->z);}void CrossP3Dd( Point3Ddouble *a, Point3Ddouble *b, Point3Ddouble *c){		c->x = a->y*b->z - a->z*b->y;		c->y = a->z*b->x - a->x*b->z;		c->z = a->x*b->y - a->y*b->x;}void NormalizeP3Dd( Point3Ddouble *pi, Point3Ddouble *po ){	double mag = DotP3Dd( pi, pi );	po->x = pi->x;po->y = pi->y;po->z = pi->z;	if (mag < JCOSMALL) {	    return;// bad -- too small to normalize	}	mag = sqrt( mag );	po->x /= mag;po->y /= mag;po->z /= mag;}int CoPlanarSet::isClockwise( shardPoly *pptr, short first, short second, short third ){	Plane *cplanep;	Point3Ddouble a,b,c,*p1,*p2,swapped_normal;	int nverts=0;	double dprod;		cplanep = (Plane *) planes->GetAddress(pptr->planeIndex);	swapped_normal.x = cplanep->normal.x;	swapped_normal.y = cplanep->normal.z;	swapped_normal.z = -cplanep->normal.y;	if (pptr->pgon)	nverts = pptr->pgon->ALength();	if (nverts < 3) return (FALSE);	p1 = (Point3Ddouble *) vertices->GetAddress(*((int *) pptr->pgon->GetAddress(first)));	p2 = (Point3Ddouble *) vertices->GetAddress(*((int *) pptr->pgon->GetAddress(second)));	a.x = p1->x - p2->x;	a.y = p1->z - p2->z;	a.z = -(p1->y - p2->y);	NormalizeP3Dd( &a, &a );	p1 = (Point3Ddouble *) vertices->GetAddress(*((int *) pptr->pgon->GetAddress(third)));	b.x = p1->x - p2->x;	b.y = p1->z - p2->z;	b.z = -(p1->y - p2->y);	NormalizeP3Dd( &b, &b );	CrossP3Dd( &a, &b, &c );	NormalizeP3Dd( &c, &c );	dprod = DotP3Dd( &swapped_normal, &c );	if (dprod > 0) return (TRUE);	return (FALSE);}void TransfNOAP::TransP3D( Point3Ddouble *pin, Point3Ddouble *pout ){    pout->x = n.x*pin->x + o.x*pin->y + a.x*pin->z + p.x;    pout->y = n.y*pin->x + o.y*pin->y + a.y*pin->z + p.y;    pout->z = n.z*pin->x + o.z*pin->y + a.z*pin->z + p.z;}void TransfNOAP::transFromPlane( Plane *pln ) {	a.x  = pln->normal.x;	a.y  = pln->normal.y;	a.z  = pln->normal.z;// pick the smallest axis for the cross product		if (fabs(a.x) < fabs(a.y)) {		if (fabs(a.x) < fabs(a.z)) {			n.x = 1.0;			n.y = 0.0;			n.z = 0.0;		}		else {			n.x = 0.0;			n.y = 0.0;			n.z = 1.0;		}	}	else {		if (fabs(a.y) < fabs(a.z)) {			n.x = 0.0;			n.y = 1.0;			n.z = 0.0;		}		else {			n.x = 0.0;			n.y = 0.0;			n.z = 1.0;		}	}		NormalizeP3Dd( &n, &n );	NormalizeP3Dd( &a, &a );	CrossP3Dd( &a, &n, &o );	NormalizeP3Dd( &o, &o );	CrossP3Dd( &o, &a, &n );	NormalizeP3Dd( &n, &n );		p.x = pln->distToOrigin*a.x;	p.y = pln->distToOrigin*a.y;	p.z = pln->distToOrigin*a.z;};void TransfNOAP::invertTrans( TransfNOAP *t ) {	n.x = t->n.x;n.y = t->o.x;n.z = t->a.x;	o.x = t->n.y;o.y = t->o.y;o.z = t->a.y;	a.x = t->n.z;a.y = t->o.z;a.z = t->a.z;	p.x = -DotP3Dd( &(t->n), &(t->p) );	p.y = -DotP3Dd( &(t->o), &(t->p) );	p.z = -DotP3Dd( &(t->a), &(t->p) );}/* this is a version that uses FFixed mathdefine FABS(x)  (FFNegative(x)?(FFNeg(x)):(x))int CoPlanarSet::CoPlanar( Plane *p, Point3DFFixed *nrml, FFixed dist){	FFixed dp;	int npts;	// check normals// normal or posn_normal?	dp = FFAdd(FFAdd(FFMult(p->normal.x,nrml->x),FFMult(p->normal.y,nrml->y) ),	 				 FFMult(p->normal.z,nrml->z));	if (FFLogic(FABS(dp),NORMAL_THRESHOLD) < 0) return FALSE;// check distance	if (FFNegative(dp)) FFNeg(dist);	if (FFLogic(FABS(FFSub(dist,p->distToOrigin)),DISTANCE_THRESHOLD) > 0) return FALSE;	if (!FFNegative(dp)) return SAME_DIR;	return OPPOSITE;}*/int CoPlanarSet::CoPlanar( Plane p, Point3Ddouble nrml, double dist){	double dp,sdist=dist;	int npts;	// check normals	dp = p.normal.x*nrml.x +p.normal.y*nrml.y + p.normal.z*nrml.z;	if (fabs(dp) < NORMAL_THRESHOLD) return FALSE;// check distance	if (dp<0) sdist=-dist;	if ( (sdist=fabs((sdist-p.distToOrigin))) > DISTANCE_THRESHOLD) {	    return FALSE;	};	if (dp>0) return SAME_DIR;	return OPPOSITE;}int CoPlanarSet::vertIndex( Point3Ddouble pnt ){	int nverts, i;	Point3Ddouble *cp;		if (!vertices) {		vertices = new(V_Array);		if (!vertices) fprintf(stderr,"out of memory in vertIndex()\n");		vertices->cArray(0, sizeof(Point3Ddouble), 8);	}	nverts = vertices->ALength();	for (i=0;i<nverts;i++) {		cp = (Point3Ddouble *) vertices->GetAddress( i );		if ((fabs( (pnt.x - cp->x) ) < POINT_TOL) &&			(fabs( (pnt.y - cp->y) ) < POINT_TOL) &&			(fabs( (pnt.z - cp->z) ) < POINT_TOL) ) return i;	}	return vertices->Append( &pnt );}shardPoly CoPlanarSet::polyFromSfc( Surface *sfc ){	int i, nverts, vct;	Point3DFFixed *pf;	Point3Ddouble pnt;	short *pi;	shardPoly rval;	rval.pgon = new(V_Array);	if (!rval.pgon) 		fprintf(stderr,"uh-oh, out of memory in polyFromSfc\n");	rval.pgon->cArray(0, sizeof(int), 4);		nverts = sfc->points->ALength();	pi = (short *) (sfc->points->Use());	for (i=0;i<nverts;i++,pi++) {	    pf = (Point3DFFixed *) 	    	sfc->surfDef->polyhedron->posnPoints->GetAddress(*pi);		pnt.x = FixedToDbl(pf->x);pnt.y = FixedToDbl(pf->y);pnt.z = FixedToDbl(pf->z);		vct = vertIndex( pnt );		rval.pgon->Append( &vct );	}	sfc->points->Unuse();	return rval;}void CoPlanarSet::Add( Surface *sfc, RGBAColor clr ){	Facet *fptr, facet;	int inPlaneDir, connectionFound, planeFound, i,j;	Plane *pptr, plane;	short *pi;	Point3Ddouble nrml, pnt, a,b,p1,p2;	double dist;	int nplanes,nfacets,lastInPlane,firstInPlane,nfeatures;	inPlaneDir=FALSE; connectionFound=FALSE; planeFound=FALSE;	RGBColor c;	unsigned short o;		if (!sfc) return;// get vertices of this face	facet.face = polyFromSfc(sfc);	facet.face.clr = clr;	facet.sfc = sfc;	for (i=0;i<3;i++) {		SurfFeature *sfp;		shardPoly newp;		int ntotverts;				if ((sfc->surfDef)&&(nfeatures = sfc->surfDef->getSurfFeats(i))) {			facet.features[i] = new(V_Array);			facet.features[i]->cArray(0, sizeof(shardPoly), 4);			if (!facet.features[i]) fprintf(stderr,"out of memory in Add()\n"); // er, uh, what do we do? (out of memory)				for (j=0;j<nfeatures;j++) {				sfp = sfc->surfDef->getSurfFeats(i, j);				V_Array *verts = sfp->surfFeat3dVerts();				if (vertices) {					ntotverts=vertices->ALength();				}				else {					ntotverts=0;					vertices = new(V_Array);					if (!vertices) fprintf(stderr,"uh-oh, out of memory in Add()\n");					vertices->cArray(0, sizeof(Point3Ddouble), 4);				}				vertices->InsertArray( verts, ntotverts );				newp.pgon = new(V_Array);				if (!newp.pgon) fprintf(stderr,"uh-oh, out of memory in Add()\n");				newp.pgon->cArray(0, sizeof(int), 4);				for (int m=0;m<verts->ALength();m++,ntotverts++) {					newp.pgon->Append( &ntotverts );				}				verts->dArray();				c = sfp->GetColor();				o = sfp->GetOpacity();					newp.clr.red = c.red;newp.clr.green = c.green;				newp.clr.blue = c.blue;newp.clr.alpha = o;				// plane index should be set in psetfromfacet				facet.features[i]->Append( &newp );			}			}		else {			facet.features[i] = NULL;		}	}	// get plane info:  normal (assume clockwise ordering) and distance to origin	vertices->Get(*((int *)(facet.face.pgon->GetAddress(1))),  &p1);	vertices->Get(*((int *)(facet.face.pgon->GetAddress(0))),  &p2);	a.x = p2.x - p1.x;	a.y = p2.y - p1.y;	a.z = p2.z - p1.z;	NormalizeP3Dd( &a, &a );	vertices->Get(*((int *)(facet.face.pgon->GetAddress(2))),  &p2);	b.x = p2.x - p1.x;	b.y = p2.y - p1.y;	b.z = p2.z - p1.z;	NormalizeP3Dd( &b, &b );	CrossP3Dd( &a, &b, &nrml );	NormalizeP3Dd( &nrml, &nrml );// use first point for distance to origin	vertices->Get(*((int *)(facet.face.pgon->GetAddress(0))),  &pnt);	dist =  nrml.x*pnt.x + nrml.y*pnt.y + nrml.z*pnt.z;	// find plane index	if (planes) {		nplanes = planes->ALength();		pptr = (Plane *) planes->Use();		for (i=0;((i<nplanes)&&(!planeFound));i++,pptr++) {			if (inPlaneDir=CoPlanar(*pptr,nrml,dist)) {	// CoPlanar returns 0 if non-coplanar, 2 if directions match, 1 if they don't				planeFound=TRUE;	//     inPlaneDir should be a flag telling if the directions match				inPlaneDir--;				facet.face.planeIndex=i;				facet.inPlaneDir = inPlaneDir;			}		}		planes->Unuse();	}// 	if not found, add new plane, add this facet (anywhere), and return	if (!planeFound) {	//add new plane		if (!planes) {		// create new v_arrays for both planes and facets			planes = new(V_Array);			if (!planes) fprintf(stderr,"erk, out of memory in Add()\n"); // er, uh, what do we do? (out of memory)			planes->cArray(0, sizeof(Plane), 4);			facets = new(V_Array);			if (!facets) fprintf(stderr,"erk, out of memory in Add()\n"); // er, uh, what do we do? (out of memory)			facets->cArray(0, sizeof(Facet), 4);		}		plane.normal = nrml;		plane.distToOrigin = dist;		facet.face.planeIndex = planes->Append( &plane );		facet.inPlaneDir = TRUE;		facets->Append( &facet );		return;	}// step thru the list, looking for connections	if (!facets) return; // there should be facets by now (unless mem error)	planeFound = FALSE;	nfacets = facets->ALength();	fptr = (Facet *) facets->Use();	for (i=0;i<nfacets;i++,fptr++) {		if (facet.face.planeIndex == fptr->face.planeIndex) {			if (!planeFound) firstInPlane = i;			planeFound = TRUE;			lastInPlane = i;			if ((sfc->surfDef) &&				(fptr->sfc->surfDef) && 				(sfc->surfDef->Connected(NULL, fptr->sfc->surfDef, -1))) {				connectionFound = TRUE;//  if a parent connection is found, insert before or after parent				if (sfc->surfDef->Connected(NULL, fptr->sfc->surfDef, SDEF_CONTAINER)) {// insertions occur "before" if the facet normal matches the plane's direction and "after" if they are opposite.					if (inPlaneDir) {						facets->Unuse();						facets->Insert(i, &facet);						return;					}					else {						facets->Unuse();						facets->Insert(i+1, &facet);						return;					}				}				else {//  if a peer connection is found, insert before the peer or after the last facet in this plane 					if (inPlaneDir) {						facets->Unuse();						facets->Insert(i,&facet);						return;					}					else {						while ((i<nfacets)&&(fptr->face.planeIndex == facet.face.planeIndex)) {							fptr++;i++;						}						facets->Unuse();						facets->Insert( i, &facet);						return;					}				}			}		}	};	facets->Unuse();//  if no connections found, attach before the first or after the last facet//      in the plane	if (!connectionFound) {		if (inPlaneDir) {			facets->Insert( firstInPlane, &facet );		}		else {			facets->Insert( lastInPlane+1, &facet );		}	}}//  build coplanar set -- for now, try doing this recursivelyvoid CoPlanarSet::Build(Polyhedron *poly){/* method:   *	traverse the model, inserting every face that has a connection into a list. * the list is ordered by planes, then by connection relationship. */	int i,nSurfs,nChildren;	SurfDef **sdef;	Polyhedron **cpoly;	RGBAColor clr;	RGBColor c;	unsigned short o;// if this is a good polyhedron, add its sfcs	if ((poly->type & POLY_CLASS) != P_INTERNAL ) {		if (poly->surfDef) {			nSurfs = poly->surfDef->ALength();			sdef = (SurfDef **)poly->surfDef->Use();		// for now, ignore sfcs that don't have connections or sfc features		// this will work for virtus vr models, but not for some pro models			for (i = 0; i < nSurfs; i++,sdef++)				if ((*sdef)&&					(((*sdef)->Connected(NULL,NULL,-1)) ||					((*sdef)->FeatCount() > 0)))			 	{					c = (*sdef)->GetColor(SURF_OUTSIDE);					o = (*sdef)->GetOpacity();					clr.red = c.red;clr.green = c.green;clr.blue = c.blue;clr.alpha = o;					Add( (*sdef)->surface, clr );				}			poly->surfDef->Unuse();		};	}// add its children	if (poly->contents) {		nChildren = poly->contents->ALength();		cpoly = (Polyhedron **)poly->contents->Use();		for (i = 0; i < nChildren; i++,cpoly++) Build( *cpoly );		poly->contents->Unuse();	};}void CoPlanarSet::Create(Polyhedron *poly){	facets = NULL;	inside = NULL;	outside = NULL;	vertices = NULL;	planes = NULL;	Build( poly );	clipSfcs();}V_Array *CoPlanarSet::polySetFromFacet( Facet *fptr, int Forward ){	V_Array *currentClipSet=NULL, *features, *fpts, *leftovers=NULL, *thruClipSet=NULL;	int i,j,k,nverts,nfeatures,in_out;	shardPoly *pp;			in_out = SURF_OUTSIDE;	if (Forward == fptr->inPlaneDir) in_out = SURF_INSIDE;	// do "inside" surface features	if ((fptr->features[in_out])&&(nfeatures = fptr->features[in_out]->ALength())) {		for (j=0;j<nfeatures;j++) {			k = nfeatures-j-1;			pp = (shardPoly *) fptr->features[in_out]->GetAddress(k);			pp->planeIndex = fptr->face.planeIndex;			leftovers = clipPolySet( pp, currentClipSet );			if (leftovers) {				if (!currentClipSet) {					currentClipSet = new(V_Array);					if (!currentClipSet) fprintf(stderr,"out of mem in polySetFromFacet()\n");					currentClipSet->cArray(0, sizeof(shardPoly), 4);				}				currentClipSet->InsertArray( leftovers, 0 );				leftovers->dArray();			};		}	}	if ((fptr->features[SURF_SHARED])&&(nfeatures = fptr->features[SURF_SHARED]->ALength())) {	// thru features		thruClipSet = new(V_Array);		if (!thruClipSet) fprintf(stderr,"out of mem in polySetFromFacet()\n");		thruClipSet->cArray(0, sizeof(shardPoly), 4);		k = nfeatures-1;		pp = (shardPoly *) fptr->features[SURF_SHARED]->GetAddress(k);		pp->planeIndex = fptr->face.planeIndex;		thruClipSet->Append( pp );		for (j=1;j<nfeatures;j++) {			k = nfeatures-1-j;			pp = (shardPoly *) fptr->features[SURF_SHARED]->GetAddress(k);			pp->planeIndex = fptr->face.planeIndex;			leftovers = clipPolySet( pp, thruClipSet );			if (leftovers) {				thruClipSet->InsertArray( leftovers, 0 );				leftovers->dArray();			};		}		// the actual face		leftovers = clipPolySet( &fptr->face, thruClipSet );		if (leftovers) {			thruClipSet->InsertArray( leftovers, 0 );			leftovers->dArray();		};				leftovers = clipSetSet( thruClipSet, currentClipSet );		if (!currentClipSet) {			currentClipSet = leftovers;		}		else {			currentClipSet->InsertArray( leftovers, 0 );			leftovers->dArray();		}		thruClipSet->dArray();	}	else {	// just do polyhedron face		leftovers = clipPolySet( &fptr->face, currentClipSet );		if (leftovers) {			if (!currentClipSet) {				currentClipSet = new(V_Array);				if (!currentClipSet) fprintf(stderr,"out of mem in polySetFromFacet()\n");				currentClipSet->cArray(0, sizeof(shardPoly), 4);			}			currentClipSet->InsertArray( leftovers, 0 );			leftovers->dArray();		};	}			// do "other" surface features	if ((fptr->features[2-in_out])&&(nfeatures = fptr->features[2-in_out]->ALength())) {		for (j=0;j<nfeatures;j++) {			pp = (shardPoly *) fptr->features[2-in_out]->GetAddress(j);			pp->planeIndex = fptr->face.planeIndex;			leftovers = clipPolySet( pp, currentClipSet );			if (leftovers) {				if (!currentClipSet) {					currentClipSet = new(V_Array);					if (!currentClipSet) fprintf(stderr,"out of mem in polySetFromFacet()\n");					currentClipSet->cArray(0, sizeof(shardPoly), 4);				}				currentClipSet->InsertArray( leftovers, 0 );				leftovers->dArray();			};		}	}	return currentClipSet;}V_Array *CoPlanarSet::clipPolySet( shardPoly *bpoly, V_Array *front ){	V_Array *bset=NULL;	int i,j,npolys;	V_Array *workset=NULL,*rval=NULL;	shardPoly fpoly, tpoly, oneclip;		if (!bpoly) return NULL;		bset = new(V_Array);	if (!bset) fprintf(stderr,"out of mem in clipPolySet()\n");	bset->cArray(0, sizeof(shardPoly), 1);	bset->Append( bpoly );	if (!front) return bset;	workset = new(V_Array);	if (!workset) fprintf(stderr,"out of mem in clipPolySet()\n");	workset->cArray(0, sizeof(shardPoly), 4);	front->CopyArray( workset );	npolys = workset->ALength();	for (i=npolys-1;i>0;i--) {		workset->Get(i, &fpoly);		for (j=i-1;j>-1;j--) {			workset->Get(j, &tpoly);			if (clumpPolyPoly( &fpoly, &tpoly, &proj2d, &proj3d, &oneclip )) {//				tpoly.pgon->dArray();				workset->Put( j, &oneclip );//				fpoly.pgon->dArray();				workset->Remove(i);				break;			}		}	}		rval = clipSetSet( bset, workset);	bset->dArray();	workset->dArray();	return rval;}V_Array *CoPlanarSet::clipSetSet( V_Array *back, V_Array *front ){// this routine takes two sets as input.  they are both in the same// plane physically, but one is considered to be behind another.  it// is clipped against the front plane	shardPoly fpoly, bpoly;	int npolys,i,j,nbpolys;	V_Array *oneclip=NULL,*currentclipset=NULL,*nextclipset=NULL;		if (!back) return back;		// copy back to the current clipset	currentclipset = new(V_Array);	if (!currentclipset) fprintf(stderr,"out of mem in clipSetSet()\n");	currentclipset->cArray(0, sizeof(shardPoly), 4);	back->CopyArray( currentclipset );	if (!front) return currentclipset;	// set up the next array	nextclipset = new(V_Array);	if (!nextclipset) fprintf(stderr,"out of mem in clipSetSet()\n");	nextclipset->cArray(0, sizeof(shardPoly), 4);		// loop over the front	npolys = front->ALength();	for (i=0;i<npolys;i++) {		front->Get(i, &fpoly);				// loop over the set that gets clipped		nbpolys = currentclipset->ALength();		for (j=0;j<nbpolys;j++) {			currentclipset->Get(j, &bpoly);			oneclip = clipPolyPoly( &fpoly, &bpoly, &proj2d, &proj3d );			if (oneclip) {			// add these to the next clipset				nextclipset->InsertArray( oneclip, 0 );				oneclip->dArray();			}		}		// copy next to current		oneclip = currentclipset;		currentclipset = nextclipset;		nextclipset = oneclip;		nextclipset->SetLength(0);	}	nextclipset->dArray();	return currentclipset;}// "clip"V_Array *CoPlanarSet::clipInDir(int Forward){	int nfacets, currentPlane=-1, i,findex,finc=1;	Facet *fptr;	Plane *cplanep;	V_Array *currentClipSet=NULL, *fpolyset=NULL, *leftovers=NULL, *finalClipSet=NULL;		if (!facets) return NULL;	nfacets = facets->ALength();	fptr = (Facet *) facets->Use();	currentPlane = fptr->face.planeIndex;	facets->Unuse();	cplanep = (Plane *) planes->GetAddress(currentPlane);	proj3d.transFromPlane( cplanep );	proj2d.invertTrans( &proj3d );	if (Forward) {		findex = 0;		finc = 1;	}	else {		findex = nfacets-1;		finc = -1;	}	for (i=0;i<nfacets;i++,findex += finc) {		fptr = (Facet *) facets->GetAddress(findex);		if (fptr->face.planeIndex != currentPlane) {			currentPlane = fptr->face.planeIndex;			cplanep = (Plane *) planes->GetAddress(currentPlane);			proj3d.transFromPlane( cplanep );			proj2d.invertTrans( &proj3d );			if (currentClipSet) {			// add current clip set to "final" 				if (!finalClipSet) {					finalClipSet = new(V_Array);					if (!finalClipSet) fprintf(stderr,"out of mem in clipInDir()\n");					finalClipSet->cArray(0, sizeof(shardPoly), 4);				}			// add this plane's polygons to the display set				finalClipSet->InsertArray( currentClipSet, 0 );			// dispose of current clip set				currentClipSet->dArray;				currentClipSet = NULL;			}		}		// turn this facet into a set of polygons (surface features, etc.)		fpolyset = polySetFromFacet( fptr, Forward );						// clip this facet against the current clip set		leftovers = clipSetSet( fpolyset, currentClipSet );		if (leftovers) {			if (!currentClipSet) {				currentClipSet = new(V_Array);				if (!currentClipSet) fprintf(stderr,"out of mem in clipInDir()\n");				currentClipSet->cArray(0, sizeof(shardPoly), 4);			}			currentClipSet->InsertArray( leftovers, 0 );			leftovers->dArray();		};		fpolyset->dArray();	}	// take care of the last iteration	if (currentClipSet) {	// add current clip set to "final" 		if (!finalClipSet) {			finalClipSet = new(V_Array);			if (!finalClipSet) fprintf(stderr,"out of mem in clipInDir()\n");			finalClipSet->cArray(0, sizeof(shardPoly), 4);		}		finalClipSet->InsertArray( currentClipSet, 0 );	// dispose of current clip set		currentClipSet->dArray;		currentClipSet = NULL;	}	return (finalClipSet);}void CoPlanarSet::clipSfcs(){// clip forward	outside = clipInDir( FALSE );// clip backward	inside = clipInDir( TRUE );// get rid of facets	facets->dArray();}void CoPlanarSet::outputPolySet(double unit_conversion, V_Buffer *buf, V_Array *pset, int Clockwise){	char hah[200];	int npolys,nverts,i,j,k,noutpolys;	Point3Ddouble *p3dp;	shardPoly *pptr;	RGBAColor acolor;#ifndef CONVEX_ONLY_CLIPPER	int currentPlaneIndex=-1;	V_Array *connectivitySet, *vertSet;	short idx;#endif	if (pset) {		npolys = pset->ALength();		pptr = (shardPoly *) pset->Use();		for (i=0;i<npolys;i++,pptr++) {		    sprintf(hah,"Separator { #polygon\n\tDEF COORD0 Coordinate3 {\n\t\tpoint [");			IOString(buf, hah);		// coordinates			nverts = 0;			if (pptr->pgon)	nverts = pptr->pgon->ALength();			for (j=0;j<nverts;j++) {				p3dp = (Point3Ddouble *) vertices->GetAddress(*((int *) pptr->pgon->GetAddress(j)));			// for some reason, we're exporting < x, z, -y > for < x, y, z >...				if (j<nverts-1) {					sprintf(hah,"\t\t%f %f %f ,\n", 						unit_conversion*p3dp->x,						unit_conversion*p3dp->z,						-unit_conversion*p3dp->y);						IOString(buf, hah);				}				else {					sprintf(hah,"\t\t%f %f %f ]\n", 						unit_conversion*p3dp->x,						unit_conversion*p3dp->z,						-unit_conversion*p3dp->y);					IOString(buf, hah);				}			}		    sprintf(hah,"\t} #Coordinate3\n");			IOString(buf, hah);		// color			acolor = pptr->clr;		    sprintf(hah,"\tMaterial {\n");			IOString(buf, hah);			// ambient			sprintf(hah,"\t\tambientColor %lf %lf %lf\n",	acolor.red/(4*BIT32F), 		// PRO25										acolor.green/(4*BIT32F), 	// PRO25										acolor.blue/(4*BIT32F));	// PRO25			IOString(buf, hah);			// diffuse			sprintf(hah,"\t\tdiffuseColor %lf %lf %lf\n",	acolor.red/BIT32F,		// PRO25										acolor.green/BIT32F,	// PRO25										acolor.blue/BIT32F);	// PRO25			IOString(buf, hah);			// transparency			sprintf(hah,"\t\ttransparency %lf\n",	1.0-(acolor.alpha/BIT32F));			IOString(buf, hah);		    sprintf(hah,"\t} #Material\n");			IOString(buf, hah);		// indexed face set		    sprintf(hah,"\tIndexedFaceSet {\n\t\tcoordIndex [");			IOString(buf, hah);			if (pptr->planeIndex != currentPlaneIndex) {				currentPlaneIndex = pptr->planeIndex;				proj3d.transFromPlane( (Plane *) planes->GetAddress(currentPlaneIndex) );				proj2d.invertTrans( &proj3d );			}			connectivitySet = convexConnectivity(pptr, &proj2d);// need something here to get clockwise/ccw correct			noutpolys = 0;			if (connectivitySet) {				noutpolys = connectivitySet->ALength();				for (k=0;k<noutpolys;k++) {					connectivitySet->Get( k, &vertSet );					if (vertSet) {						nverts = vertSet->ALength();						if (Clockwise == isClockwise(pptr,													*((short *) vertSet->GetAddress(0)),													*((short *) vertSet->GetAddress(1)),													*((short *) vertSet->GetAddress(2)))) {							for (j=0;j<nverts;j++) {								vertSet->Get( j, &idx);								sprintf(hah,"%d,",idx);								IOString(buf, hah);							}						}						else {							for (j=nverts-1;j>-1;j--) {								vertSet->Get( j, &idx);								sprintf(hah,"%d,",idx);								IOString(buf, hah);							}						}						sprintf(hah,"-1, \n");						IOString(buf, hah);						vertSet->dArray();					}				}				connectivitySet->dArray();			}		    sprintf(hah,"\t]\n\t} #indexedfaceset\n} #polygon\n");			IOString(buf, hah);		}		pset->Unuse();	}}void CoPlanarSet::outputPolys(double unit_conversion, V_Buffer *buf){	if (inside) {		IOString(buf, "\n#inside polygons\n");		outputPolySet(unit_conversion, buf, inside, FALSE);		inside->dArray();		inside = NULL;	}	if (outside) {		IOString(buf, "\n#outside polygons\n");		outputPolySet(unit_conversion, buf, outside, TRUE);		outside->dArray();		outside = NULL;	}	if (planes) planes->dArray();	planes = NULL;	if (vertices) vertices->dArray();	vertices = NULL;}