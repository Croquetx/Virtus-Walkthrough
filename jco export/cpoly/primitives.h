#ifndef	PRIMITIVES_H#define	PRIMITIVES_H	"$Header: /home/mi7/klamer/src/c++/spie/RCS/primitives.h,v 1.1 1993/10/27 14:43:55 klamer Exp $"//    nclip: a polygon clip library//    Copyright (C) 1993  Klamer Schutte//    klamer@mi.el.utwente.nl//    This library is free software; you can redistribute it and/or//    modify it under the terms of the GNU Library General Public//    License as published by the Free Software Foundation; either//    version 2 of the License, or (at your option) any later version.//    This library is distributed in the hope that it will be useful,//    but WITHOUT ANY WARRANTY; without even the implied warranty of//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU//    Library General Public License for more details.//    You should have received a copy of the GNU Library General Public//    License along with this library; if not, write to the Free//    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.// $Log: primitives.h,v $// Revision 1.1  1993/10/27  14:43:55  klamer// Initial revision//// Revision 1.1  1993/10/27  14:43:55  klamer// Initial revision//// Revision 1.1  1992/12/07  10:46:35  klamer// Initial revision//#ifdef __GNUG__#pragma interface#endif#ifndef M_PI#include	<math.h>#endif#ifndef GRAPHMAT_INCLUDE#include	"graphmat.h"#endif#ifndef assert#include	<assert.h>#endifclass clipPoint {	double	_x, _y;	public:	clipPoint()		{ }	clipPoint( double x, double y )		: _x(x), _y(y)		{ }	clipPoint( const hvec2_t &h )		: _x(v_x(h)), _y(v_y(h))		{ }	double	x() const		{ return _x; }	double	&x()		{ return _x; }	double	y() const		{ return _y; }	double	&y()		{ return _y; }				// operator hvec2_t();	// Does crash g++ 2.2.1 when used :-(	hvec2_t	hvec() const//		{ hvec2_t res; v_fill2( x(), y(), 1.0, &res ); return res; }		{ hvec2_t res; v_x(res) = x(); v_y(res) = y(); v_w(res) = 1;			return res; }	const clipPoint &operator=( const hvec2_t &copy )		{ _x = v_x(copy); _y = v_y( copy); return *this; }	const clipPoint &operator=( const clipPoint &copy )		{ _x = copy.x(); _y = copy.y(); return *this; }};inline clipPoint	operator+( const clipPoint &p1, const clipPoint &p2 ){	return clipPoint( p1.x() + p2.x(), p1.y() + p2.y() );}	inline clipPoint	operator-( const clipPoint &p1, const clipPoint &p2 ){	return clipPoint( p1.x() - p2.x(), p1.y() - p2.y() );}inline doublelen( const clipPoint p ){	return sqrt( p.x() * p.x() + p.y() * p.y() );} inline clipPoint	operator/( const clipPoint &p, double div ){	return clipPoint( p.x() / div, p.y() / div );}inline intoperator==( const clipPoint &p1, const clipPoint &p2 ){	return (p1.x() == p2.x()) && (p1.y() == p2.y());}inline intoperator!=( const clipPoint &p1, const clipPoint &p2 ){	return (p1.x() != p2.x()) || (p1.y() != p2.y());}inline intoperator<( const clipPoint &p1, const clipPoint &p2 ){	return (p1.y() < p2.y()) || ((p1.y() == p2.y()) && (p1.x() < p2.x()));}inline intoperator>( const clipPoint &p1, const clipPoint &p2 ){	return (p1.y() > p2.y()) || ((p1.y() == p2.y()) && (p1.x() > p2.x()));}double	angle( const clipPoint &p1, const clipPoint &p2, const clipPoint &p3 );inline doubleatan( const clipPoint &p ){	if( (p.x() == 0) && (p.y() == 0) ) {		fprintf(stderr,"taking atan2(0,0)!\n");		return (0);	}	return atan2( p.y(), p.x() );}inline clipPoint point(const hvec3_t &p){	hvec3_t	pn;	v_homo3( &p, &pn );		return clipPoint( v_x(pn), v_y(pn) );}class PointList{	friend class PointListIter;		int	len, cur;	clipPoint	*points;	static const int	def_len; //	= 16;	// Make copy constructor and assignment unusable	PointList( PointList &copy );//	operator=( PointList copy );  better check to see where this overloading was used -- jco		public:	PointList( int nr = def_len );	~PointList();		void	add( const clipPoint &add );};class PointListIter{	const PointList	&pl;	int				cnt;	public:	PointListIter( const PointList &list )		: pl( list ), cnt( -1 )		{ }		int	operator() ()		{ if (++cnt < pl.cur) return 1; else return 0; }		const clipPoint	&point() const		{ return pl.points[cnt]; }};class Edge{	clipPoint	point1, point2;	// int		shared;	public:	Edge( const clipPoint &p1, const clipPoint &p2 ) //, int share = -1 )		: point1( p1 ), point2( p2 ) //, shared( share )		{ }	clipPoint	middle() const		{ return (point1 + point2) / 2.0; }	// void	set_shared( int val )	//	{ shared = val; }		const clipPoint	&p1() const		{ return point1; } 	const clipPoint 	&p2() const		{ return point2; }	};#endif	/* PRIMITIVES_H */