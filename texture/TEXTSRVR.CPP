#include "VTypes.h"#include "WTypes.h"#include <stdio.h>#include <string.h>#include <QuickTimeComponents.h>#include "VMDL.h"                                      #include "ShowTest.h"			// !!! DEBUG#include "VTimer.h"				// ABD DEBUG#include "VDebug.h"#include "AppText.h"			// needed for IO()#include "AppFiles.h"			// needed for IO()#include "WalkBuff.h"			// needed for IO_FFIXED#include "VGUtil.h"#include "VGraphic.h"#include "ToolDef.h"#include "CVWCNTRL.h"#include "VMemUtil.h"#include "VFile.h"#include "TextSrvr.h"					// keep after vfile			//GJR 10/06/93#include "TextArry.h"#include "TextItem.h"#include "TextType.h"#include "Texture.h"#include "VTextDef.h"#include "VDialog.h"#include "VError.h"				// jca 22 Sept 93#include "VColor.h"		// ABD MERGE-VSHA#if MACINTOSH#include <Components.h>#define NUM_TEXTURE_SHADING_INDICES 256         // BILBIL 1/15/93#endifstruct TextureServer *gTextureServer;	// the master texture server globalint gAlreadyLoadedOldStyle = FALSE;/**** hack...hack...hack...****//* this is a hack to remove the gBuildingThumbanils global variable.It is called gHigherPriorityMeterInUse because that's what's reallygoing on:  you can't call the meter because someone more importantthan you are is already using it.  If we ever sort out the meterweirdnesses THIS SHOULD GO AWAY!  jca 3MAR94 */int gHigherPriorityMeterInUse	= FALSE;extern int gComponentMgrPresent;TextureShader gMasterTextureShader;	// the master texture shader global MERGE-VSHATextureShader gTextureShader;			// the current texture shader global MERGE-VSHATextureShader gTextureUnshader;	// the master texture unshader global V_Array *gMTSVA;			// MASTER texture shader V_Array MERGE-VSHA V_Array *gTSVA;			// texture shader V_Array MERGE32extern int gUseAllOld;extern int gUseAllNew;extern int gRenameAllNew;extern int gAskAboutAll;int gReadingLibrary = FALSE;		// MERGE24/*------------------------------------------------------------------------------*//* TEXTURE SERVER ROUTINES *//*------------------------------------------------------------------------------*//*------------------------------------------------------------------------------*//*	This routine inits the texture server.*/voidTextureServer::cTextureServer(){	next_id = 1;	io_textures = NULL;	// create the array of Texture ptrs	textures = new(V_Array);	textures->cArray(0, sizeof(struct Texture *), 4);		lock_count = 0;		// open the video digitizers	OpenVDIGs();		if (offscreen)	{		CalcTextureShadeTable(offscreen);	}}/*------------------------------------------------------------------------------*//*	This routine deletes the texture server.*/voidTextureServer::dTextureServer(){	// MERGE-CLEANUP [[[	if (textures)	{	Texture **t = (Texture **)textures->Use();	int i;		// t[i]->dTexture() removes the texture from the array. Thus we        // should _not_ increment i, or we'll not delete all the textures.		// Heaven help us if it can't find the texture in the array --		// we'll loop forever.  jca 21APR94		for ( i = 0 ; i < textures->ALength() ; /*i++*/ )		{			t[i]->UnlockCompletely();			t[i]->dTexture();		}		textures->Unuse();		textures->dArray();	}	// MERGE-CLEANUP ]]]		// close the video digitizers	CloseVDIGs();	DeleteTextureShadeTable();		// MERGE32	delete(this);			// jca 8APR94 always clean up }		#if MACINTOSHvoid MakeVDIGTextureItem(TextureArray *, VideoDigitizerComponent vdig, char *, int);/*------------------------------------------------------------------------------*//*	This routine makes a texture item corresponding to a video digitizer, sets	its name to str, appends it to ta, and calls the setup routine for the texture	item.  It also appends it to the texture palette list.*/voidMakeVDIGTextureItem(TextureArray *ta, VideoDigitizerComponent vdig, char *str, int input_num){#if 0	// MERGE-PRO no vdigs for now#if VPRO// no vdigs in vr!! - BILBILTexture *t;TextureItem *ti;int err;		// make a new texture item	ti = new(TextureItem);	ti->cTextureItem(ta);			// does not create the texture itself		strcpy(ti->settings.name, str);		t = gTextureServer->NewTexture(TEXTURE_VDIG);	// set texture ptr to texture	ti->texture = t;				((TTVDIG*)(t->tt))->SetVDIG(vdig, input_num);		if (ta->controller)		ta->controller->AddTextureItem3(ti);#endif //VPRO#endif //0}#elif WINDOWS#if !ELVIS	// No Vdig Errors for Windows			//GJR 10/01/93//#error This needs your attention, Greg...#endif#endif/*------------------------------------------------------------------------------*//*	This routine opens all of the video digitizer components it can find and saves	them in an internal V_Array.  Documents will call AddVDIGs to add these components	to its texture picker.  */voidTextureServer::OpenVDIGs(){#if 0	// MERGE-PRO no vdigs for now#if MACINTOSHComponent vdigComp;ComponentDescription vdigDesc, vdigDesc2;VideoDigitizerComponent vdig = NULL;OSErr err;VideoDigitizerError verr;VDIGstruct vdigstruct;DigitizerInfo info;int i, j;long count;char str[256];short num_inputs;Handle nameH;// MERGE30 [[[#if VR	return;			// no vdigs in vr#endif // VR// MERGE30 ]]]	if (gComponentMgrPresent)	{		// create the array of video digitizer components		vdigs = new(V_Array);		vdigs->cArray(0, sizeof(VDIGstruct), 4);				// what kind of component are we looking for?		vdigDesc.componentType = videoDigitizerComponentType;		vdigDesc.componentSubType = (OSType)0;		vdigDesc.componentManufacturer = (OSType)0;		vdigDesc.componentFlags = 0;		vdigDesc.componentFlagsMask = 0;				// see how many there are		count = CountComponents(&vdigDesc);				for ( i = 0 ; i < count ; i++ )		{			// get the next component			vdigComp = FindNextComponent(NULL, &vdigDesc); 	 								// open it			vdigstruct.vdig = (VideoDigitizerComponent)OpenComponent(vdigComp);						// get some information about it			nameH = NewHandle(0);			err = GetComponentInfo(vdigComp, &vdigDesc2, nameH, NULL, NULL);			for (i=0;i<256;i++){ vdigstruct.name[i]= (*nameH)[i]; }			P2Cstr(vdigstruct.name);			DisposeHandle(nameH);						// add it to our list of vdigs			vdigs->Append(&vdigstruct);		}	}#elif WINDOWS#if !ELVIS	// No Vdig Errors for Windows			//GJR 10/01/93//#error This needs your attention, Greg...#endif#endif#endif //0}/*------------------------------------------------------------------------------*//*	This routine closes the video digitizer components and deletes the array.*/voidTextureServer::CloseVDIGs(){#if 0	// MERGE-PRO no vdigs for now#if MACINTOSHVideoDigitizerComponent *vd;int i;// MERGE30 [[[#if VR	return;		// no vdigs in vr#endif // VR// MERGE30 ]]]	if (gComponentMgrPresent)	{		vd = (VideoDigitizerComponent *)vdigs->Use();		for ( i = 0 ; i < vdigs->ALength() ; i++ )		{			CloseComponent(vd[i]);		}		vdigs->Unuse();		if (vdigs) vdigs->dArray();	}#elif WINDOWS#if !ELVIS	// No Vdig Errors for Windows			//GJR 10/01/93//#error This needs your attention, Greg...#endif#endif#endif //0}/*------------------------------------------------------------------------------*//*	This routine adds texture items corresponding to the video digitizers available	to the texture array ta.  */voidTextureServer::AddVDIGs(TextureArray *ta){#if 0	// MERGE-PRO no vdigs for now#if MACINTOSHVDIGstruct *vd;VideoDigitizerError verr;DigitizerInfo info;int i, j;char str[256];short num_inputs;	// MERGE30 [[[#if VR	return;		// no vdigs in VR#endif // VR// MERGE30 ]]]	if (gComponentMgrPresent)	{		vd = (VDIGstruct *)vdigs->Use();		for ( i = 0 ; i < vdigs->ALength() ; i++ )		{			verr = VDGetDigitizerInfo(vd[i].vdig, &info);						verr = VDGetNumberOfInputs(vd[i].vdig, &num_inputs);						for ( j = 0 ; j <= num_inputs ; j++ )			{				sprintf(str, "%s", vd[i].name);					//  083093				MakeVDIGTextureItem(ta, vd[i].vdig, str, j);			}		}		vdigs->Unuse();	}#elif WINDOWS#if !ELVIS	// No Vdig Errors for Windows			//GJR 10/01/93//#error This needs your attention, Greg...#endif#endif#endif //0}// MERGE32 [[[/*------------------------------------------------------------------------------*//* */voidTextureServer::DeleteTextureShadeTable(){int i;int k;	// gTSVA is already Used() (it is gTextureShader)	// gMTSVA is already Used() (it is gMasterTextureShader)   // jca 14 Dec 93	for ( i = 0 ; i < NUM_TEXTURE_SHADING_LEVELS ; i++ )	{		for ( k = 0 ; k < 4 ; k++) 		{				gTextureShader[i].va[k][0]->dArray();			gTextureShader[i].va[k][1]->dArray();			gTextureShader[i].va[k][2]->dArray();			gTextureShader[i].va[k][3]->dArray();#if WINDOWS			gMasterTextureShader[i].va[k][0]->dArray();   // jca 14 Dec 93 {			gMasterTextureShader[i].va[k][1]->dArray();         // must deallocate these too			gMasterTextureShader[i].va[k][2]->dArray();			gMasterTextureShader[i].va[k][3]->dArray();    // jca 14 Dec 93 }#endif //WINDOWS		}#if WINDOWS		gTextureShader[i].color4x1va[0]->dArray();          //4bit planar		//gjr 12/15/93		gTextureShader[i].color4x1va[1]->dArray();		gMasterTextureShader[i].color4x1va[0]->dArray();          //4bit planar		//gjr 12/15/93		gMasterTextureShader[i].color4x1va[1]->dArray();		gMasterTextureShader[i].truecolorva->dArray();     // jca 14 Dec 93		gMasterTextureShader[i].color16bitva->dArray();    // jca 14 Dec 93#endif //WINDOWS		gTextureShader[i].truecolorva->dArray();		gTextureShader[i].color16bitva->dArray();#if WINDOWS		gTextureShader[i].color24bitva->dArray();          //jca 17 Dec 93		gMasterTextureShader[i].color24bitva->dArray();          //jca 17 Dec 93#endif //WINDOWS	}	gTSVA->Unuse();	gTSVA->dArray();#if WINDOWS	gMTSVA->Unuse();     // jca 14 Dec 93	gMTSVA->dArray();    // jca 14 Dec 93#endif //WINDOWS}// MERGE32 ]]]// MERGE-GOURAUD [[[#define COLORS_EQUAL(a,b) 	(((a).red == (b).red) && ((a).green == (b).green) && ((a).blue == (b).blue))// MERGE-GOURAUD [[[/*------------------------------------------------------------------------------*//*	This routine inits the global texture shading table.*//*Altered by JAM to handle 32 bit, 24bit, 16bit, 8bit, 4bit, 2bit, and 1bit color depths*/voidTextureServer::CalcTextureShadeTable(V_Offscreen *off){#if MACINTOSHHandle shader = NULL;int i;register int k;V_Offscreen *temp_off;V_Offscreen *temp_off2;V_Offscreen *temp_offarray[4];V_Offscreen *temp_off2array[4];Rect r;long l;V_Array *va;ShadeEntry *ts;//PixPatHandle ppat = NULL;	// ¥			get into mac section //GJR 10/01/93Handle sha = NULL;Handle theData;	//StartTimingMilli();	#define USE_DITHERED_PIX_PATS#ifdef USE_DITHERED_PIX_PATS	for(k=0;k<4;k++) {		temp_offarray[k] = new(V_Offscreen);		VSetRect(&r, 0, 0, 2, 2);		temp_offarray[k]->cOffscreen(&r, 1<<k, NULL,NULL);		temp_off2array[k] = new(V_Offscreen);		VSetRect(&r, 0, 0, 2, 2);		temp_off2array[k]->cOffscreen(&r, 1<<k, NULL,NULL);	}#endif	// there are NUM_TEXTURE_SHADING_LEVELS shade entries.  Each shade entry contains 	// four arrays of unsigned char 	gTSVA = new(V_Array);													// MERGE32 	gTSVA->cArray(NUM_TEXTURE_SHADING_LEVELS, sizeof(ShadeEntry), 8);		// MERGE32 	ts = (ShadeEntry *)gTSVA->Use();										// MERGE32	for ( i = 0 ; i < NUM_TEXTURE_SHADING_LEVELS ; i++ )		{		register int j;		V_Array *tsva;				VSetCursor(vCursorEarth);					for ( k = 0 ; k < 4 ; k++)	/*do for each bit depth*/		{			// make the four arrays (for a/b/c/d dither values)			tsva = new(V_Array);			tsva->cArray(NUM_TEXTURE_SHADING_INDICES, sizeof(unsigned char), 8); 			ts[i].va[k][0] = tsva;		// MERGE32			ts[i].dith[k][0] = (UChar*)tsva->Use();			tsva = new(V_Array);			tsva->cArray(NUM_TEXTURE_SHADING_INDICES, sizeof(unsigned char), 8); 			ts[i].va[k][1] = tsva;		// MERGE32			ts[i].dith[k][1] = (UChar*)tsva->Use();			tsva = new(V_Array);			tsva->cArray(NUM_TEXTURE_SHADING_INDICES, sizeof(unsigned char), 8); 			ts[i].va[k][2] = tsva;		// MERGE32			ts[i].dith[k][2] = (UChar*)tsva->Use();			tsva = new(V_Array);			tsva->cArray(NUM_TEXTURE_SHADING_INDICES, sizeof(unsigned char), 8); 			ts[i].va[k][3] = tsva;		// MERGE32			ts[i].dith[k][3] = (UChar*)tsva->Use();			/*JAM 24 bit stuff*/		}		tsva = new(V_Array);		tsva->cArray(NUM_TEXTURE_SHADING_INDICES, sizeof(long), 8);		ts[i].truecolor = (long*)tsva->Use();		ts[i].truecolorva = tsva;		// MERGE32		tsva = new(V_Array);		tsva->cArray(NUM_TEXTURE_SHADING_INDICES, sizeof(short int), 8);		ts[i].color16bit = (short*)tsva->Use();		ts[i].color16bitva = tsva;		// MERGE32			// look for shading resource first		sha = Get1Resource('Vsha', (i*50));		if (sha)			{			for ( k = 0 ; k < 4 ; k++)	/*do for each bit depth*/				{				if(k != 0)					{					sha = Get1Resource('Vsha', (i*50) + (k*10) + 0);					}				HLock(sha);				BlockMove((Ptr)(*sha), (Ptr)(ts[i].dith[k][0]), NUM_TEXTURE_SHADING_INDICES * sizeof(unsigned char));				HUnlock(sha);				ReleaseResource(sha);					sha = Get1Resource('Vsha', (i*50) + (k*10) + 1);				HLock(sha);				BlockMove((Ptr)(*sha), (Ptr)(ts[i].dith[k][1]), NUM_TEXTURE_SHADING_INDICES * sizeof(unsigned char));				HUnlock(sha);				ReleaseResource(sha);								sha = Get1Resource('Vsha', (i*50) + (k*10) + 2);				HLock(sha);				BlockMove((Ptr)(*sha), (Ptr)(ts[i].dith[k][2]), NUM_TEXTURE_SHADING_INDICES * sizeof(unsigned char));				HUnlock(sha);				ReleaseResource(sha);								sha = Get1Resource('Vsha', (i*50) + (k*10) + 3);				HLock(sha);				BlockMove((Ptr)(*sha), (Ptr)(ts[i].dith[k][3]), NUM_TEXTURE_SHADING_INDICES * sizeof(unsigned char));				HUnlock(sha);				ReleaseResource(sha);				}			/*JAM 32 bit depth*/			sha = Get1Resource('Vsha', (i*50)+4);			HLock(sha);			BlockMove((Ptr)(*sha), (Ptr)(ts[i].truecolor), NUM_TEXTURE_SHADING_INDICES * sizeof(long));			HUnlock(sha);			ReleaseResource(sha);			/*JAM 16 bit depth*/			sha = Get1Resource('Vsha', (i*50)+5);			HLock(sha);			BlockMove((Ptr)(*sha), (Ptr)(ts[i].color16bit), NUM_TEXTURE_SHADING_INDICES * sizeof(short int));			HUnlock(sha);			ReleaseResource(sha);			}		else			{			for ( j = 0 ; j < NUM_TEXTURE_SHADING_INDICES ; j++ )				{				VCGrafPort p;				VGrafDevice d;				RGBColor rgb, rgb0, rgb1, rgb2, rgb3;				unsigned char c;				unsigned char dith_a,dith_b,dith_c,dith_d;					rgb = off->IndexToColor(j);		// MERGE-DITHER				// we want level 0 to be the actual texture, and level NUM_TEXTURE_SHADING_LEVELS				// to be pure black				rgb.red = (unsigned short)(((double)(rgb.red)) * ((double)(((double)NTSLMO-i) / (double)NTSLMO)));				rgb.green = (unsigned short)(((double)(rgb.green)) * ((double)(((double)NTSLMO-(double)i) / (double)NTSLMO)));				rgb.blue = (unsigned short)(((double)(rgb.blue)) * ((double)(((double)NTSLMO-(double)i) / (double)NTSLMO)));			#ifdef USE_DITHERED_PIX_PATS				for ( k = 0 ; k < 4 ; k++)	/*do for each bit depth*/					{	PixPatHandle ppat = NULL;	// ¥			get into mac section //GJR 10/01/93					temp_off2 = temp_off2array[k];					temp_off = temp_offarray[k];					// PRO-14 did this get merged?? [[[					if (k == 0)		// do for 1-bit only					{					double Y = ((0.299 * (double)rgb.red) +							(0.587 * (double)rgb.green) +							(0.114 * (double)rgb.blue)) / 65535.0;		// compute lightness of rgb													// fill in index values manually 0 = white, 255 = black						if (Y <= 0.125) // very black						{							dith_a = 255;							dith_b = 255;							dith_c = 255;							dith_d = 255;						}						else if (Y <= 0.375)						{							dith_a = 255;							dith_b = 0;							dith_c = 255;							dith_d = 255;						}						else if (Y <= 0.625)						{							dith_a = 255;							dith_b = 0;							dith_c = 0;							dith_d = 255;						}						else if (Y <= 0.875)						{							dith_a = 255;							dith_b = 0;							dith_c = 0;							dith_d = 0;						}						else // very white						{							dith_a = 0;							dith_b = 0;							dith_c = 0;							dith_d = 0;						}					}					else					{					// PRO-14 did this get merged?? ]]]										ppat = NewPixPat();					MakeRGBPat(ppat, &rgb);						VGetPort(&p,&d);					temp_off2->SetMetaPort();	// ¥					PenPixPat(ppat);					VPaintRect(&r);							// BILBIL - GetPixel->GetPixelColor - 11/15/93					rgb0 = temp_off2->GetPixelColor(0, 0);					rgb1 = temp_off2->GetPixelColor(0, 1);					rgb2 = temp_off2->GetPixelColor(1, 0);					rgb3 = temp_off2->GetPixelColor(1, 1);					// MERGE-GOURAUD [[[					// we want to make sure that rgb0 is the same rgb that we are attempting					// to dither here, so that gouraud shading can just grab that one when					// it needs a shaded rgb.  So if rgb0 is not equal to rgb, then swap rgb0					// with the color that is equal to rgb					if (!COLORS_EQUAL(rgb0, rgb))					{					RGBColor tmp;											if (COLORS_EQUAL(rgb, rgb1))						{							tmp = rgb0; rgb0 = rgb1; rgb1 = rgb0;						}						else if (COLORS_EQUAL(rgb, rgb2))						{							tmp = rgb0; rgb0 = rgb2; rgb2 = rgb0;						}						else if (COLORS_EQUAL(rgb, rgb3))						{							tmp = rgb0; rgb0 = rgb3; rgb3 = rgb0;						}					}					// MERGE-GOURAUD ]]]												temp_off2->UnsetMetaPort();	// ¥					VSetPort(p,d);					VGetPort(&p,&d);					temp_off->SetMetaPort();	// ¥										dith_a = (unsigned char)Color2Index(&rgb0);					dith_b = (unsigned char)Color2Index(&rgb1);					dith_c = (unsigned char)Color2Index(&rgb2);					dith_d = (unsigned char)Color2Index(&rgb3);									// eliminate "courdorouy" patterns by moving colors around so that similar					// colors are diagonally opposite -- MERGE-GOURAUD -- make sure we don't					// move the dith_a value around, because that is the actual closest color					// index and we want it to definitely be in the dith_a position.  Just move					// the other values around.					if ((dith_a == dith_c) || (dith_b == dith_d))						{						swap(dith_c, dith_d);		// MERGE-GOURAUD leave dith_a alone						}					else if ((dith_a == dith_b) || (dith_c == dith_d)) 						{						swap(dith_b, dith_d);		// MERGE-GOURAUD leave dith_a alone						}					}	// PRO-14 did this get merged? 										/*replicate the bit pattern 8, 4, or 2 times for bit depths					  1, 2, or 4.  lack of 'break' statements is INTENTIONAL*/					switch(k)						{						case 0:							dith_a |= dith_a << 1;							dith_b |= dith_b << 1;							dith_c |= dith_c << 1;							dith_d |= dith_d << 1;						case 1:							dith_a |= dith_a << 2;							dith_b |= dith_b << 2;							dith_c |= dith_c << 2;							dith_d |= dith_d << 2;						case 2:							dith_a |= dith_a << 4;							dith_b |= dith_b << 4;							dith_c |= dith_c << 4;							dith_d |= dith_d << 4;						}					ts[i].dith[k][0][j] = dith_a;					ts[i].dith[k][1][j] = dith_b;					ts[i].dith[k][2][j] = dith_c;					ts[i].dith[k][3][j] = dith_d;					/*JAM FOR 24 bit depth*/					if(k == 0)						{						ts[i].truecolor[j] = (((long)(rgb.red >> 8)) << 16) |											 (((long)(rgb.green >> 8)) << 8) |											 (((long)(rgb.blue >> 8)) << 0);						ts[i].color16bit[j] = (((short)(rgb.red >> 11)) << 10) |											  (((short)(rgb.green >> 11)) << 5) |											  (((short)(rgb.blue >> 11)) << 0);						}										 					//ts[i].dith[k][0][j] = (unsigned char)Color2Index(&rgb0);					//ts[i].dith[k][1][j] = (unsigned char)Color2Index(&rgb1);					//ts[i].dith[k][2][j] = (unsigned char)Color2Index(&rgb2);					//ts[i].dith[k][3][j] = (unsigned char)Color2Index(&rgb3);							ASSERT(ts[i].dith[k][0][j] >= 0);					ASSERT(ts[i].dith[k][0][j] < 256);					ASSERT(ts[i].dith[k][1][j] >= 0);					ASSERT(ts[i].dith[k][1][j] < 256);					ASSERT(ts[i].dith[k][2][j] >= 0);					ASSERT(ts[i].dith[k][2][j] < 256);					ASSERT(ts[i].dith[k][3][j] >= 0);					ASSERT(ts[i].dith[k][3][j] < 256);							if (k != 0)			// PRO-14 did this get merged?					{			// PRO-14					temp_off->UnsetMetaPort();	// ¥					VSetPort(p,d);					DisposPixPat(ppat);						}			// PRO-14 did this get merged?	#else					ts[i].dith[k][0][j] = 					ts[i].dith[k][1][j] = 					ts[i].dith[k][2][j] = 					ts[i].dith[k][3][j] = (unsigned char)Color2Index(&rgb);										ASSERT(ts[i].dith[k][0][j] >= 0);					ASSERT(ts[i].dith[k][0][j] < 256);					ASSERT(ts[i].dith[k][1][j] >= 0);					ASSERT(ts[i].dith[k][1][j] < 256);					ASSERT(ts[i].dith[k][2][j] >= 0);					ASSERT(ts[i].dith[k][2][j] < 256);					ASSERT(ts[i].dith[k][3][j] >= 0);					ASSERT(ts[i].dith[k][3][j] < 256);	#endif								}				}			}								// save a resource with this data	#define WRITE_SHADING_RESOURCES 0	#if WRITE_SHADING_RESOURCES		for(k=0;k<4;k++)			{			theData = NewHandle(NUM_TEXTURE_SHADING_INDICES * sizeof(unsigned char));			HLock(theData);			BlockMove((Ptr)(ts[i].dith[k][0]), (Ptr)(*theData), GetHandleSize(theData));			HUnlock(theData);			AddResource(theData, 'Vsha', (i*50) + (k*10) + 0, "\p");			WriteResource(theData);				theData = NewHandle(NUM_TEXTURE_SHADING_INDICES * sizeof(unsigned char));			HLock(theData);			BlockMove((Ptr)(ts[i].dith[k][1]), (Ptr)(*theData), GetHandleSize(theData));			HUnlock(theData);			AddResource(theData, 'Vsha', (i*50) + (k*10) + 1, "\p");			WriteResource(theData);				theData = NewHandle(NUM_TEXTURE_SHADING_INDICES * sizeof(unsigned char));			HLock(theData);			BlockMove((Ptr)(ts[i].dith[k][2]), (Ptr)(*theData), GetHandleSize(theData));			HUnlock(theData);			AddResource(theData, 'Vsha', (i*50) + (k*10) + 2, "\p");			WriteResource(theData);				theData = NewHandle(NUM_TEXTURE_SHADING_INDICES * sizeof(unsigned char));			HLock(theData);			BlockMove((Ptr)(ts[i].dith[k][3]), (Ptr)(*theData), GetHandleSize(theData));			HUnlock(theData);			AddResource(theData, 'Vsha', (i*50) + (k*10) + 3, "\p");			WriteResource(theData);			}					theData = NewHandle(NUM_TEXTURE_SHADING_INDICES * sizeof(long));		HLock(theData);		BlockMove((Ptr)(ts[i].truecolor), (Ptr)(*theData), GetHandleSize(theData));		HUnlock(theData);		AddResource(theData, 'Vsha', (i*50)+4, "\p");		WriteResource(theData);		theData = NewHandle(NUM_TEXTURE_SHADING_INDICES * sizeof(short int));		HLock(theData);		BlockMove((Ptr)(ts[i].color16bit), (Ptr)(*theData), GetHandleSize(theData));		HUnlock(theData);		AddResource(theData, 'Vsha', (i*50)+5, "\p");		WriteResource(theData);	#endif		}		// save the global pointer to it	gTextureShader = ts;#ifdef USE_DITHERED_PIX_PATS	for(k=0;k<4;k++)		{		temp_offarray[k]->dOffscreen();		temp_off2array[k]->dOffscreen();		}	//DisposPixPat(ppat);	// ¥#endif	//l = EndTimingMilli();//******************************************************************************#elif WINDOWS	Handle shader = NULL;	int i;	register int k;	Rect r;	long l;	V_Array *va;	ShadeEntry *ts;	ShadeEntry *tsm;      // MERGE-VSHA	Handle sha = NULL;	Handle theData;	extern V_Array *gColorTable;    int iNumTextureShadingIndices;	V_Offscreen *main_screen;	if (!gColorTable) MakeStandardColorTable();   	// MERGE-VSHA	iNumTextureShadingIndices = gColorTable->ALength();	//StartTimingMilli();		main_screen = NULL;	// init for existence test	screen->Get(0, &main_screen);	ASSERT(main_screen);	main_screen->SetMetaPort();  // get the color info accessible	// there are NUM_TEXTURE_SHADING_LEVELS shade entries.  Each shade entry contains	// four arrays of unsigned char 	gTSVA = new(V_Array);													// MERGE32	gTSVA->cArray(NUM_TEXTURE_SHADING_LEVELS, sizeof(ShadeEntry), 8);		// MERGE32	ts = (ShadeEntry *)gTSVA->Use();										// MERGE32	gMTSVA = new(V_Array);													// MERGE-VSHA	gMTSVA->cArray(NUM_TEXTURE_SHADING_LEVELS, sizeof(ShadeEntry), 8);		// MERGE-VSHA	tsm = (ShadeEntry *)gMTSVA->Use();										// MERGE-VSHA	for ( i = 0 ; i < NUM_TEXTURE_SHADING_LEVELS ; i++ )		{		register int j;		V_Array *tsva;			VSetCursor(vCursorEarth);				for ( k = 0 ; k < 4 ; k++) 	/*do for each bit depth*/			{			// make the four arrays (for a/b/c/d dither values)			tsva = new(V_Array);			tsva->cArray(iNumTextureShadingIndices, sizeof(unsigned char), 8);			ts[i].va[k][0] = tsva;		// MERGE32			ts[i].dith[k][0] = (UChar *) tsva->Use();			tsva = new(V_Array);      // MERGE-VSHA			tsva->cArray(iNumTextureShadingIndices, sizeof(unsigned char), 8);   // MERGE-VSHA			tsm[i].va[k][0] = tsva;		// MERGE-VSHA			tsm[i].dith[k][0] = (UChar *) tsva->Use();   // MERGE-VSHA			tsva = new(V_Array);			tsva->cArray(iNumTextureShadingIndices, sizeof(unsigned char), 8);			ts[i].va[k][1] = tsva;		// MERGE32			ts[i].dith[k][1] = (UChar *) tsva->Use();			tsva = new(V_Array);        // MERGE-VSHA			tsva->cArray(iNumTextureShadingIndices, sizeof(unsigned char), 8);     // MERGE-VSHA			tsm[i].va[k][1] = tsva;		// MERGE-VSHA			tsm[i].dith[k][1] = (UChar *) tsva->Use();   // MERGE-VSHA			tsva = new(V_Array);			tsva->cArray(iNumTextureShadingIndices, sizeof(unsigned char), 8);			ts[i].va[k][2] = tsva;		// MERGE32			ts[i].dith[k][2] = (UChar *) tsva->Use();			tsva = new(V_Array);               // MERGE-VSHA			tsva->cArray(iNumTextureShadingIndices, sizeof(unsigned char), 8);    // MERGE-VSHA			tsm[i].va[k][2] = tsva;		// MERGE-VSHA			tsm[i].dith[k][2] = (UChar *) tsva->Use();   // MERGE-VSHA			tsva = new(V_Array);			tsva->cArray(iNumTextureShadingIndices, sizeof(unsigned char), 8);			ts[i].va[k][3] = tsva;		// MERGE32			ts[i].dith[k][3] = (UChar *) tsva->Use();			tsva = new(V_Array);                  // MERGE-VSHA			tsva->cArray(iNumTextureShadingIndices, sizeof(unsigned char), 8);     // MERGE-VSHA			tsm[i].va[k][3] = tsva;		// MERGE-VSHA			tsm[i].dith[k][3] = (UChar *) tsva->Use();       // MERGE-VSHA			/*JAM 24 bit stuff*/			}		tsva = new(V_Array);		tsva->cArray(iNumTextureShadingIndices, sizeof(long), 8);		ts[i].color4x1va[0] = tsva;		// MERGE32		ts[i].color4x1[0] = (Long *) tsva->Use();		tsva = new(V_Array);        // MERGE-VSHA		tsva->cArray(iNumTextureShadingIndices, sizeof(long), 8);     // MERGE-VSHA		tsm[i].color4x1va[0] = tsva;		// MERGE-VSHA		tsm[i].color4x1[0] = (Long *) tsva->Use();    // MERGE-VSHA		tsva = new(V_Array);		tsva->cArray(iNumTextureShadingIndices, sizeof(long), 8);		ts[i].color4x1va[1] = tsva;		// MERGE32		ts[i].color4x1[1] = (Long *) tsva->Use();		tsva = new(V_Array);        // MERGE-VSHA		tsva->cArray(iNumTextureShadingIndices, sizeof(long), 8);     // MERGE-VSHA		tsm[i].color4x1va[1] = tsva;		// MERGE-VSHA		tsm[i].color4x1[1] = (Long *) tsva->Use();    // MERGE-VSHA		tsva = new(V_Array);		tsva->cArray(iNumTextureShadingIndices, sizeof(long), 8);		ts[i].truecolorva = tsva;		// MERGE32		ts[i].truecolor = (Long *) tsva->Use();		tsva = new(V_Array);        // MERGE-VSHA		tsva->cArray(iNumTextureShadingIndices, sizeof(long), 8);     // MERGE-VSHA		tsm[i].truecolorva = tsva;		// MERGE-VSHA		tsm[i].truecolor = (Long *) tsva->Use();    // MERGE-VSHA		tsva = new(V_Array);		tsva->cArray(iNumTextureShadingIndices, sizeof(Long), 8);		ts[i].color24bitva = tsva;		// MERGE32		ts[i].color24bit = (Long *) tsva->Use();		tsva = new(V_Array);		tsva->cArray(iNumTextureShadingIndices, sizeof(Long), 8);		tsm[i].color24bitva = tsva;		// MERGE32		tsm[i].color24bit = (Long *) tsva->Use();		tsva = new(V_Array);		tsva->cArray(iNumTextureShadingIndices, sizeof(short int), 8);		ts[i].color16bitva = tsva;		// MERGE32		ts[i].color16bit = (Short *) tsva->Use();		tsva = new(V_Array);		tsva->cArray(iNumTextureShadingIndices, sizeof(short int), 8);		tsm[i].color16bitva = tsva;		// MERGE32		tsm[i].color16bit = (Short *) tsva->Use();		{			for ( j = 0 ; j < iNumTextureShadingIndices ; j++ )				{				RGBColor rgb, rgb0, rgb1, rgb2, rgb3;				unsigned char c;				unsigned char dith_a,dith_b,dith_c,dith_d;                ULong ulDith;				UChar ucColor[4];				// get the color in this position from the standard global color table, then compute the				// shaded color based on this shading level.  Then we compute the closest colors in the				// global color table that are good to dither this shaded color.				gColorTable->Get(j, &rgb);   // AB				rgb.red   = (unsigned short)(((double)(rgb.red)) * ((double)(((double)NTSLMO-(double)i) / (double)NTSLMO)));				rgb.green = (unsigned short)(((double)(rgb.green)) * ((double)(((double)NTSLMO-(double)i) / (double)NTSLMO)));				rgb.blue  = (unsigned short)(((double)(rgb.blue)) * ((double)(((double)NTSLMO-(double)i) / (double)NTSLMO)));					for ( k = 0 ; k < 4 ; k++)	/*do for each bit depth*/					{					// MERGE-VSHA [[[					ULong dith;					if ( ((k==0) && (main_screen->bitDepth == 1))					  || ((k==1) && (main_screen->bitDepth == 2))					  || ((k==2) && (main_screen->bitDepth == 4))					  || ((k==3) && (main_screen->bitDepth == 8)) )            {	//only existing bit depths should have shades calced					if ( (k == 3)#if WINDOWS					  && (gwVgrHasPalette) && (gwVgrSizePalette >= 256-20)  // MUST MATCH REINITDITHER IN VCOLOR //GJR12/15/93	 //palettes less than 20 are fixed, and we can't use our standard palette.	 //palettes at 256 or above are variable, and we have to set it up     // so pick some value between the two.#endif //WINDOWS					   )// THEN  // 8bit, and if palette, use StandardDither					{					extern V_Array *gColorTable;					RGBColor real_rgb = { 0, 0, 0 };					// get the standard dither value					GetStandardDither(&rgb, &dith_a, &dith_b, &dith_c, &dith_d);					}					else               	{						((Long *)ucColor)[0] = main_screen->GetDither4Bytes(&rgb);						dith_a = ucColor[0];						dith_b = ucColor[1];						dith_c = ucColor[2];						dith_d = ucColor[3];						}					// MERGE-VHSA ]]]					if ((dith_a == dith_c) || (dith_b == dith_d))					{						swap(dith_a, dith_b);					}					else if ((dith_a == dith_b) || (dith_c == dith_d)) 					{						swap(dith_a, dith_c);					}								/*replicate the bit pattern 8, 4, or 2 times for bit depths				  1, 2, or 4.  lack of 'break' statements is INTENTIONAL*/					switch(k)						{						case 0:							dith_a |= dith_a << 1;							dith_b |= dith_b << 1;							dith_c |= dith_c << 1;							dith_d |= dith_d << 1;						case 1:							dith_a |= dith_a << 2;							dith_b |= dith_b << 2;							dith_c |= dith_c << 2;							dith_d |= dith_d << 2;						case 2:							dith_a |= dith_a << 4;							dith_b |= dith_b << 4;							dith_c |= dith_c << 4;							dith_d |= dith_d << 4;						}					ts[i].dith[k][0][j] = dith_a;					ts[i].dith[k][1][j] = dith_b;					ts[i].dith[k][2][j] = dith_c;					ts[i].dith[k][3][j] = dith_d;					tsm[i].dith[k][0][j] = dith_a; 		// MERGE-VSHA					tsm[i].dith[k][1][j] = dith_b; 		// MERGE-VSHA					tsm[i].dith[k][2][j] = dith_c;		// MERGE-VSHA					tsm[i].dith[k][3][j] = dith_d;		// MERGE-VSHA			}	//only existing bit depths should have shades calced				/*JAM FOR MORE THAN 8 bit depth*/					if(k == 2)  //k = 2 is for 4 bit					  {					  if (main_screen->bitDepth == 4)						{						// grab the nice dither from the 4bit chuncky.						// take each bit and planarize it.						// First dither line is a1b1a1b1a1b1a1b1 a2b2a2b2a2b2...                        // Second grab cdcdcd etc.						ulDith = 0;						if (tsm[i].dith[k][0][j] & 0x1) ulDith |= 0xAA000000L;						if (tsm[i].dith[k][1][j] & 0x1) ulDith |= 0x55000000L;						if (tsm[i].dith[k][0][j] & 0x2) ulDith |= 0x00AA0000L;						if (tsm[i].dith[k][1][j] & 0x2) ulDith |= 0x00550000L;						if (tsm[i].dith[k][0][j] & 0x4) ulDith |= 0x0000AA00L;						if (tsm[i].dith[k][1][j] & 0x4) ulDith |= 0x00005500L;						if (tsm[i].dith[k][0][j] & 0x8) ulDith |= 0x000000AAL;						if (tsm[i].dith[k][1][j] & 0x8) ulDith |= 0x00000055L;                        ts[i].color4x1[0][j] = ulDith;						ulDith = 0;						if (tsm[i].dith[k][2][j] & 0x1) ulDith |= 0xAA000000L;						if (tsm[i].dith[k][3][j] & 0x1) ulDith |= 0x55000000L;						if (tsm[i].dith[k][2][j] & 0x2) ulDith |= 0x00AA0000L;						if (tsm[i].dith[k][3][j] & 0x2) ulDith |= 0x00550000L;						if (tsm[i].dith[k][2][j] & 0x4) ulDith |= 0x0000AA00L;						if (tsm[i].dith[k][3][j] & 0x4) ulDith |= 0x00005500L;						if (tsm[i].dith[k][2][j] & 0x8) ulDith |= 0x000000AAL;						if (tsm[i].dith[k][3][j] & 0x8) ulDith |= 0x00000055L;						ts[i].color4x1[1][j] = ulDith;                        }					}					if(k == 0)					  {					  if (main_screen->bitDepth == 32)						{						ts[i].truecolor[j] = main_screen->GetNoDither(&rgb);						tsm[i].truecolor[j] = main_screen->GetNoDither(&rgb);						}#if 0	//don't waste time doing other bit depths					  else						{						ts[i].truecolor[j] = (((long)(rgb.red >> 8)) << 16) |											 (((long)(rgb.green >> 8)) << 8) |											 (((long)(rgb.blue >> 8)) << 0);						tsm[i].truecolor[j] = (((long)(rgb.red >> 8)) << 16) |											 (((long)(rgb.green >> 8)) << 8) |											 (((long)(rgb.blue >> 8)) << 0);						}#endif	//don't waste time doing other bit depths					  if (main_screen->bitDepth == 24)                        {						ts[i].color24bit[j] = main_screen->GetNoDither(&rgb);						tsm[i].color24bit[j] = main_screen->GetNoDither(&rgb);						}#if 0	//don't waste time doing other bit depths					  else						{						ts[i].color24bit[j] = (((long)(rgb.red >> 8)) << 16) |											 (((long)(rgb.green >> 8)) << 8) |											 (((long)(rgb.blue >> 8)) << 0);						tsm[i].color24bit[j] = (((long)(rgb.red >> 8)) << 16) |											 (((long)(rgb.green >> 8)) << 8) |											 (((long)(rgb.blue >> 8)) << 0);						}#endif	//don't waste time doing other bit depths					  if (main_screen->bitDepth == 16)                        {						ts[i].color16bit[j] = main_screen->GetNoDither(&rgb);						tsm[i].color16bit[j] = main_screen->GetNoDither(&rgb);						}#if 0	//don't waste time doing other bit depths					  else						{						ts[i].color16bit[j] = (((short)(rgb.red >> 11)) << 10) |											  (((short)(rgb.green >> 11)) << 5) |											  (((short)(rgb.blue >> 11)) << 0);						tsm[i].color16bit[j] = (((short)(rgb.red >> 11)) << 10) |											  (((short)(rgb.green >> 11)) << 5) |											  (((short)(rgb.blue >> 11)) << 0);						}#endif	//don't waste time doing other bit depths					  }					}				}			}			// save a resource with this data#define WRITE_SHADING_RESOURCES 0#if WRITE_SHADING_RESOURCES#error !elvis		// need writing resources		for(k=0;k<4;k++)			{			theData = NewHandle(iNumTextureShadingIndices * sizeof(unsigned char));			HLock(theData);			BlockMove((Ptr)(ts[i].dith[k][0]), (Ptr)(*theData), GetHandleSize(theData));			HUnlock(theData);			AddResource(theData, 'Vsha', (i*50) + (k*10) + 0, "\p");			WriteResource(theData);				theData = NewHandle(iNumTextureShadingIndices * sizeof(unsigned char));			HLock(theData);			BlockMove((Ptr)(ts[i].dith[k][1]), (Ptr)(*theData), GetHandleSize(theData));			HUnlock(theData);			AddResource(theData, 'Vsha', (i*50) + (k*10) + 1, "\p");			WriteResource(theData);				theData = NewHandle(iNumTextureShadingIndices * sizeof(unsigned char));			HLock(theData);			BlockMove((Ptr)(ts[i].dith[k][2]), (Ptr)(*theData), GetHandleSize(theData));			HUnlock(theData);			AddResource(theData, 'Vsha', (i*50) + (k*10) + 2, "\p");			WriteResource(theData);				theData = NewHandle(iNumTextureShadingIndices * sizeof(unsigned char));			HLock(theData);			BlockMove((Ptr)(ts[i].dith[k][3]), (Ptr)(*theData), GetHandleSize(theData));			HUnlock(theData);			AddResource(theData, 'Vsha', (i*50) + (k*10) + 3, "\p");			WriteResource(theData);			}				theData = NewHandle(iNumTextureShadingIndices * sizeof(long));		HLock(theData);		BlockMove((Ptr)(ts[i].color4x1[0]), (Ptr)(*theData), GetHandleSize(theData));		HUnlock(theData);		AddResource(theData, 'Vsha', (i*50)+4, "\p");		WriteResource(theData);		theData = NewHandle(iNumTextureShadingIndices * sizeof(long));		HLock(theData);		BlockMove((Ptr)(ts[i].color4x1[1]), (Ptr)(*theData), GetHandleSize(theData));		HUnlock(theData);		AddResource(theData, 'Vsha', (i*50)+4, "\p");		WriteResource(theData);		theData = NewHandle(iNumTextureShadingIndices * sizeof(long));		HLock(theData);		BlockMove((Ptr)(ts[i].truecolor), (Ptr)(*theData), GetHandleSize(theData));		HUnlock(theData);		AddResource(theData, 'Vsha', (i*50)+4, "\p");		WriteResource(theData);		theData = NewHandle(iNumTextureShadingIndices * sizeof(long));		HLock(theData);		BlockMove((Ptr)(ts[i].color24bit), (Ptr)(*theData), GetHandleSize(theData));		HUnlock(theData);		AddResource(theData, 'Vsha', (i*50)+4, "\p");		WriteResource(theData);		theData = NewHandle(iNumTextureShadingIndices * sizeof(short int));		HLock(theData);		BlockMove((Ptr)(ts[i].color16bit), (Ptr)(*theData), GetHandleSize(theData));		HUnlock(theData);		AddResource(theData, 'Vsha', (i*50)+5, "\p");		WriteResource(theData);#endif		}	main_screen->UnsetMetaPort();	// done with color info	// save the global pointer to it	gTextureShader = ts;	gMasterTextureShader = tsm;	ResetShadingTable();	//l = EndTimingMilli();#endif}/*------------------------------------------------------------------------------*//*	MERGE19	jca 20JAN94 this routine can only be called within	a BeginTextureIO and an EndTextureIO pair.  Else, evil things occur because	the io_textures variable is not set.	(this is from the VR-win ->VWT win conversion.  We want to rid ourselves	of the VR globals as much as possible.)*/TextureItem*TextureServer::VRFindTextureByName(char *name){/* extern TextureArray * gAllTextures;	return gAllTextures->FindByName(name);		// MERGE19    */    // jca 20JAN94 [[	if (io_textures)		return io_textures->FindByName(name);		// MERGE19	else		{		DEBUGGER();        return(NULL);      // ick-o.  jca 20JAN94 ]]		}}// MERGE24 [[[/*------------------------------------------------------------------------------*//*	MERGE24*/TextureItem*TextureServer::VRFindTextureByFileName(V_File *f){extern TextureArray *gCustomPicts;char fn[256];char fn0[256] = "", fn1[256] = "";VfsLocation *vfsLocation;//long dir1 = 0;//short vol1 = 0;//AliasHandle als1 = NULL;	struct TextureItem **ti;struct TextureItem *return_result = NULL;int i;	if (!f) return NULL;	f->GetFName(fn);	for ( i = 0 ; i < 64 ; i++ ) fn0[i] = fn[i];	P2Cstr(fn0);	vfsLocation = new(VfsLocation);	vfsLocation->cVfsLocation();	ti = (TextureItem **)gCustomPicts->Use();	for ( i = 0 ; i < gCustomPicts->ALength() ; i++ )	{		if (ti[i]->texture->tt->class_type == TEXTURE_FILE)		{			ti[i]->texture->GetFileLoc(vfsLocation);			VfsGetLocationFName(vfsLocation, fn1);						//GJR 10/06/93			if (strcmp(fn0, fn1) == 0) 				{ return_result = ti[i]; break; }		}	}	gCustomPicts->Unuse();    vfsLocation->dVfsLocation();		return(return_result);}// MERGE24 ]]]/*------------------------------------------------------------------------------*//*	This routine creates a new texture, sets the type to texture_type, and then returns	a pointer to it.  Use this routine instead of creating the texture yourself, because	this routine will register the texture in it's array so that the file is not loaded	twice, thus wasting memory.  */struct Texture *TextureServer::NewTexture(int texture_type){		struct Texture *t;int err;	t = new(Texture);	if (t == NULL) return NULL;   // ABD added error check 12/10/93	t->cTexture(texture_type);	textures->Append(&t);		return(t);}/*------------------------------------------------------------------------------*//**/voidTextureServer::RemoveTexture(struct Texture *t){struct Texture *local_t = t;	if (textures) textures->Remove(textures->Find(&local_t));}/*------------------------------------------------------------------------------*//*	This routine returns a pointer to a texture that is refered to by the file	ref info passed in if the texture has already been loaded (not necessarily in	memory or being used, just added) by some open document.		If the texture has not already been added, NULL is returned.  */struct Texture *TextureServer::GlobalFindByFileLoc(VfsLocation *findLocation){//MODIFY		//GJR 10/06/93	[[[VfsLocation *textureLocation;//char fn0[256] = "", fn1[256] = "";//long dir1 = 0, dir0 = dir;//short vol1 = 0, vol0 = vol;//AliasHandle als1 = NULL;	struct Texture **tx;struct Texture *return_result = NULL;int i;	textureLocation = new(VfsLocation);	textureLocation->cVfsLocation();	tx = (Texture **)textures->Use();	for ( i = 0 ; i < textures->ALength() ; i++ )	{		tx[i]->GetFileLoc(textureLocation);				if (VfsIsSameLocation(textureLocation, findLocation))			{ return_result = tx[i]; break; }	}	textures->Unuse();	textureLocation->dVfsLocation();	return(return_result);}//MODIFY		//GJR 10/06/93	]]]/*------------------------------------------------------------------------------*//*	This routine returns a pointer to a texture chunk that is refered to by the file	ref info passed in if the texture has already been loaded (not necessarily in	memory or being used, just added) by some open document.		If the texture chunk has not already been added, NULL is returned.*/struct Texture *TextureServer::GlobalFindChunkByLocAndPos(VfsLocation *findLocation, long io_position){//MODIFY		//GJR 10/06/93	[[[VfsLocation *textureLocation;//char fn0[256] = "", fn1[256] = "";//long dir1 = 0, dir0 = dir;//short vol1 = 0, vol0 = vol;//AliasHandle als1 = NULL;	struct Texture **tx;struct Texture *return_result = NULL;int i;	textureLocation = new(VfsLocation);	textureLocation->cVfsLocation();	tx = (Texture **)textures->Use();	for ( i = 0 ; i < textures->ALength() ; i++ )	{		if(tx[i]->type == TEXTURE_CHUNK)        {			tx[i]->GetFileLoc(textureLocation);					if ((tx[i]->GetTextureChunkPosition() == io_position) &&				(VfsIsSameLocation(textureLocation, findLocation)))				{ return_result = tx[i]; break; }        }	}	textures->Unuse();	textureLocation->dVfsLocation();	return(return_result);}//MODIFY		//GJR 10/06/93	]]]/*------------------------------------------------------------------------------*//*	This routine deletes the texture server.*/voidTextureServer::LockTextures(){struct Texture **tx;int i;	// increment the locks and only lock them if we locking for first time	lock_count++;	if (lock_count != 1) 		return;	tx = (Texture **)textures->Use();	for ( i = 0 ; i < textures->ALength() ; i++ )	{		if (tx[i]->global_use_count > 0)			tx[i]->Lock();	}	textures->Unuse();}		/*------------------------------------------------------------------------------*//*	This routine deletes the texture server.*/voidTextureServer::UnlockTextures(){struct Texture **tx;int i;	// decrement the locks and only unlock them if we are totally popped out	lock_count--;	if (lock_count != 0) 		return;	tx = (Texture **)textures->Use();	for ( i = 0 ; i < textures->ALength() ; i++ )	{		if (tx[i]->global_use_count > 0)			tx[i]->Unlock();	}	textures->Unuse();}		/*------------------------------------------------------------------------------*//* I/O ROUTINES *//*------------------------------------------------------------------------------*//*------------------------------------------------------------------------------*//*	This routine must be called before any of the other TextureServer I/O routines.*/void TextureServer::BeginTextureIO(V_Buffer *buf, struct TextureArray *ta){	// store pointer to texture array we will be using	io_textures = ta;	io_textures->ResetIDs();	next_id = 1;	gAlreadyLoadedOldStyle = FALSE;	gUseAllOld = FALSE;	gUseAllNew = FALSE;	gRenameAllNew = FALSE;	gAskAboutAll = TRUE;}// MERGE24 [[[/*------------------------------------------------------------------------------*//*	This routine must be called before any of the other TextureServer I/O routines.*/void TextureServer::BeginTextureIOLib(V_Buffer *buf, struct TextureArray *ta){	// store pointer to texture array we will be using	BeginTextureIO(buf, ta);	gReadingLibrary = TRUE;}// MERGE24 ]]]/*------------------------------------------------------------------------------*//*	Given an id, we need to determine its associated texture.  		If the id is in the table, then we return the texture item associated with 	the id in the table.  		If the id is not in the table, then we set up a blank	texture item with the given id and set up an entry in the table mapping the	id to the new blank texture item.  We will return a pointer to the new blank	texture item.  Later, when we read the mapping from id to texture, we will fill 	in the real info for the blank texture item we created.  		This routine will return NULL only if io_textures has not been initialized,	in which case there is a programming error somewhere -- BeginTextureIO must	be called before calling this routine.*/struct TextureItem *TextureServer::IDtoTexture(long find_id){struct TextureItem *ti;	if (!io_textures) return (NULL);	if (find_id == NO_TEXTURE_IO_ID)		return NULL;		ti = io_textures->FindByID(find_id);	if (ti == NULL)	{		// if we can't find the texture by id, then create a new texture item		ti = new(TextureItem);		ti->cTextureItem(io_textures);		// does not create the texture itself		ti->id = find_id;		// note that we do not add the newly created texture item to the texture		// palette list here.  We do it in EndTextureIO, so that temp texture items		// are not added to the texture palette list during file i/o.	}	return(ti);}/*------------------------------------------------------------------------------*//*	Given a texture item, we need to determine its local id.  		If this texture item has already been written out during this file i/o, then we	will be given the id this texture item was assigned before.  Otherwise we will	create a new id for the texture item and return that.  */long TextureServer::TexturetoID(struct TextureItem *ti){	if (ti == NULL)		return NO_TEXTURE_IO_ID;		if (ti->id == NON_IO_ID) 	{		ti->id = next_id++;	}	return(ti->id);}/*------------------------------------------------------------------------------*//**/int TextureServer::SameName(struct TextureItem *ti1, struct TextureItem *ti2){char *nm1, *nm2;int val;		val = (strcmp(ti1->settings.name, ti2->settings.name) == 0);	return val;}/*------------------------------------------------------------------------------*//**/int TextureServer::SameFile(struct TextureItem *ti1, struct TextureItem *ti2){//MODIFIED							//GJR 10/06/93 [[[int err = 0;VfsLocation *location1, *location2;int returnval;//long dir1, dir2;//short vol1, vol2;//char fn1[256], fn2[256];	location1 = new(VfsLocation);	location1->cVfsLocation();	location2 = new(VfsLocation);	location2->cVfsLocation();	ti1->GetFileLoc(location1);	ti2->GetFileLoc(location2);//	PtoCstr((StringPtr)fn1);//	PtoCstr((StringPtr)fn2);	returnval = VfsIsSameLocation(location1, location2);	location2->dVfsLocation();    location1->dVfsLocation();    return returnval;//MODIFIED							//GJR 10/06/93 	]]]}/*------------------------------------------------------------------------------*//**/int TextureServer::SameSettings(struct TextureItem *ti1, struct TextureItem *ti2){int val = FALSE;struct TextureSettings *s1, *s2;	ObjLock(ti1);	ObjLock(ti2);	s1 = &(ti1->settings);	s2 = &(ti2->settings);	val =  (((s1->decal) == (s2->decal)) &&			((s1->shade) == (s2->shade)) &&			((s1->colorize) == (s2->colorize)) &&			((s1->hFlip) == (s2->hFlip)) &&			((s1->vFlip) == (s2->vFlip)) &&			((s1->hMirror) == (s2->hMirror)) &&			((s1->vMirror) == (s2->vMirror)) &&			((s1->hUnit) == (s2->hUnit)) &&			((s1->vUnit) == (s2->vUnit)) &&			((s1->use_real_world_size_h) == (s2->use_real_world_size_h)) &&			((s1->use_real_world_size_v) == (s2->use_real_world_size_v)) &&			((s1->mapping) == (s2->mapping)) &&			(FFEqual(s1->hSlide, s2->hSlide)) &&			(FFEqual(s1->vSlide, s2->vSlide)) &&			(FFEqual(s1->rotate, s2->rotate)) &&			(FFEqual(s1->hTiles, s2->hTiles)) &&			(FFEqual(s1->vTiles, s2->vTiles)) &&			(FFEqual(s1->hPixels_per_unit, s2->hPixels_per_unit)) &&			(FFEqual(s1->vPixels_per_unit, s2->vPixels_per_unit))	);	ObjUnlock(ti1);	ObjUnlock(ti2);	return val;}/*------------------------------------------------------------------------------*//*	Texture style sheets means that if two texture items have the same name,	*/int TextureServer::MergeIfSame(struct TextureItem *old_ti, struct TextureItem *new_ti){// MERGE-VPRO-2 [[[#if VPROint val;char str[256];char name[256];		// return true if user wants old//MERGE-PRO-JAM-3 [[[	if (SameName(old_ti, new_ti))	{		// if these textures are absolutely the same, then merge them without asking the user		if (SameFile(old_ti, new_ti) && SameSettings(old_ti, new_ti))		{			new_ti->MergeInto(old_ti);	// deletes new				return TRUE;		// delete new guy 		}				if (gUseAllOld)		// if the user previously said to use all old		{					// do nothing			new_ti->MergeInto(old_ti);	// deletes new			return TRUE;	// delete new guy		}		else if (gUseAllNew) 	// if the user previously said to use all new		{			// reset the texture file loc			old_ti->Merge(new_ti);			new_ti->MergeInto(old_ti);	// deletes new			return TRUE;		// delete new guy 		}		else if (gRenameAllNew) 	// if the user previously said to use all new		{			new_ti->UniqueName();			return FALSE;		// don't delete new guy, he has a unique name now								// note that we return early so that new_ti is not merged into old_ti		}				old_ti->GetName(name);	//		sprintf(str,"Texture \"%s\" already exists in this model. Use the old or new texture?",name);		// MERGE-GOURAUD-PRO-5		sprintf(str,TXT_ALREADYEXITS,name);		val = SixButtonMessage(str,TXT_CUSENEW,TXT_CUSEOLD,TXT_CRENAMENEW,TXT_CUSEALLNEW,TXT_CUSEALLOLD,TXT_CRENAMEALL,POSITIVE_BUTTON_ONE|DEFAULT_BUTTON_ONE);		if (val == 1)		{			// user wants new						// reset the texture file loc			old_ti->Merge(new_ti);		}		else if (val == 2)		{			// user wants old			// do nothing		}		else if (val == 3)		{			new_ti->UniqueName();			return FALSE;		// don't delete new guy, he has a unique name now								// note that we return early so that new_ti is not merged into old_ti		}		else if (val == 4)		{			// user all new			// user wants all new			gUseAllNew = TRUE;						// reset the texture file loc			old_ti->Merge(new_ti);		}		else if (val == 5)		{			// user all old			gUseAllOld = TRUE;			// do nothing		}		else if (val == 6)		{				// user wants to rename all new			gRenameAllNew = TRUE;			new_ti->UniqueName();			return FALSE;		// don't delete new guy, he has a unique name now								// note that we return early so that new_ti is not merged into old_ti		}		// we are always deleting the new guy if there is already one with the same name		// The only question		new_ti->MergeInto(old_ti);	// deletes new		return TRUE;		// delete new guy 	}	else 		return FALSE;		// don't merge, make new guy real //MERGE-PRO-JAM-3 ]]]#elseint val;char str[256];char name[256];		// return true if user wants old	if (SameName(old_ti, new_ti))	{		// if these textures are absolutely the same, then merge them without asking the user		if (SameFile(old_ti, new_ti) && SameSettings(old_ti, new_ti))		{			new_ti->MergeInto(old_ti);	// deletes new				return TRUE;		// delete new guy 		}					// VR NOTE: we always rename new if there is a name conflict			new_ti->UniqueName();		return FALSE;		// don't delete new guy, he has a unique name now							// note that we return early so that new_ti is not merged into old_ti	}	else 		return FALSE;		// don't merge, make new guy real#endif // VPRO-2}/*------------------------------------------------------------------------------*//*	Texture style sheets means that if two texture items have the same name,	*/int TextureServer::MergeIfSameVR(struct TextureItem *old_ti, struct TextureItem *new_ti){int val;char str[256];char name[256];		// return true if user wants old	if (SameName(old_ti, new_ti))	{		new_ti->MergeInto(old_ti);	// deletes new			return TRUE;		// delete new guy 	}	else 		return FALSE;		// don't merge, make new guy real }/*------------------------------------------------------------------------------*//*	This routine sets f to point to a file in custom picts with the same file name.*/intTextureServer::FindInCustomPicts(V_File *f){//REPLACE //GJR 10/06/93VfsLocation	*customLocation;//char fn[256];//char fn0[256];int err = fileNotFoundErr;struct TextureItem **ti;int i;extern TextureArray *gCustomPicts;//REPLACE VARIOUS  //GJR 10/06/93			[[[//	f->GetFName(fn);	customLocation = new(VfsLocation);	customLocation->cVfsLocation();	ti = (TextureItem **)gCustomPicts->Use();	for ( i = 0 ; i < gCustomPicts->ALength() ; i++ )	{		if (ti[i]->texture)			if (ti[i]->texture->tt)				if (ti[i]->texture->tt->class_type == TEXTURE_FILE)				{					ti[i]->texture->GetFileLoc(customLocation);					if (f->VIsSameLocation(customLocation))					{						f->VSetLocation(customLocation);//REPLACE VARIOUS															//GJR 10/06/93 ]]]						err = f->Find();						break;					}				}	}	gCustomPicts->Unuse();    customLocation->dVfsLocation();	return err;}/*------------------------------------------------------------------------------*//*	On DATA IN:	We read in the mapping from id to texture info (name, file ref, or picture, etc).	So we read in the id.  We want to find the texture item with the corresponding	id so we can fill in the info.  Since we write out the texture	table after the model has been written, IDtoTexture will always give us a texture	item that existed before the call to IDtoTexture.  		On DATA OUT:	We write mapping from id to texture info (name, file ref, or picture, etc).*/intTextureServer::IOTextureTable(V_Buffer *buf, int purge_textures){int err = 0;long id, id2;struct TextureItem **tx = NULL;				// MERGE27struct TextureItem *ti = NULL;				// MERGE27struct TextureItem *matching_ti = NULL;		// MERGE27int delete_ti;int forget_texture = FALSE;int i;char c;#if VR // jca 17JAN94extern int gLoadingTextureFolderTextures;       // jca 1 Oct 93int reading_vwt_pro_file = FALSE;#endif // VRVfsLocation *checkLoc = NULL;			// MERGE-GOURAUD-PRO-5int check = FALSE;		// MERGE-GOURAUD-PRO-5int found;		// MERGE-GOURAUD-PRO-5//JAM 11OCT94 for hack to get meters operating nice when loading textures [[[extern gLoadingTexture;	//global from textarray.cpp//JAM 11OCT94 for hack to get meters operating nice when loading textures ]]]int actually_got_picture_data = FALSE;	checkLoc = new(VfsLocation);		// MERGE-GOURAUD-PRO-5	checkLoc->cVfsLocation();		// MERGE-GOURAUD-PRO-5	if (buf->IODirection() == DATA_IN)	{		while (!err)		{			id = buf->OpenChunkR();			if (id == 0) break;						switch (id)			{				case IFF_TXTE:	// texture table entry				{				int read_picture_data = TRUE;		// MERGE30				int found_file_ref = FALSE;			// MERGE30				int got_custom_pict = FALSE;		// MERGE30				int add_to_doc_textures = FALSE;	// MERGE30									while (!err)					{					long txID;					short vdSlot, vdInput;					V_Array *name;					char *nm;					V_File *f;					V_Offscreen *off;                    short	tmp_short;											id2 = buf->OpenChunkR();						if (id2 == 0) break;												switch (id2)						{						char fileName[256], str[256];													case IFF_TXID:	// texture id								buf->IOType(&txID, IO_LONG);								ti = IDtoTexture(txID);								break;															case IFF_TXVD:	// texture video digitizer								// MERGE30 [[[								// always forget vdigs in vr								#if 0								buf->IOType(&vdSlot, IO_SHORT);															buf->IOType(&vdInput, IO_SHORT);															err = ti->SetVideoDigitizer(vdSlot, vdInput);								// we got an error, so just forget about this texture								if (err) forget_texture = TRUE;								#endif								// MERGE30 ]]]								forget_texture = TRUE;								// !!! the best thing we could do is ask the user								// to set the texture to another video digitizer he								// may have available								break;																case IFF_TXPD:                            	actually_got_picture_data = TRUE;								//JAM 30AUG94 we need to set the ti's texture if it's a chunk, even if we don't need to load picture								if (buf->GetBufferType() == V_FILETYPE)                                {									ti->TextureChunk((V_File*)buf, buf->IOGetPosition() - 8);	// MERGE15								}								if (read_picture_data)								{								Boolean save_picture_data = FALSE;	// MERGE-BUG 17MAR94 copying textures in VWT										// for picture data, just tell the texture item where the file									// with the picture data is									// MERGE-BUG -- if this is just a buffer, we had better remember									// the entire offscreen, because it is not in a permanent file.									if (buf->GetBufferType() == V_FILETYPE)									{                                    	//this has been moved to before the if(read_picture_data) //JAM 30AUG94	  									//ti->TextureChunk((V_File*)buf, buf->IOGetPosition() - 8);	// MERGE15									}									else                           			{                           				ti->TextureOffscreen();		// MERGE-BUG                           				save_picture_data = TRUE;	// MERGE-BUG                           			}                          									off = NULL;									off = new(V_Offscreen);		// MERGE16									if (off == NULL)                           				{ err = memFullErr; break; }									err = off->IO_BMAP(buf, NULL, NoCompression);									if (err == noErr)                                    {										if (save_picture_data)	// MERGE-BUG											ti->SetOffscreen(off);	// must do this before setthumbnail								   #if (!VPLAYER)										ti->SetThumbnail(off);								   #endif // (!VPLAYER)										}									else										forget_texture = TRUE;									off->dOffscreen();                           			if (err == noErr)										add_to_doc_textures = TRUE;	// MERGE20								}								break;															case IFF_TXFR:	// texture file ref								f = new(V_File);								f->cFile(REFERENCE, 0, 0, "", "");																// if we are saving to a file, we will set relative 								// to this file, otherwise we will set relative to NULL 								// (as in cut/paste).								if (buf->GetBufferType() == V_FILETYPE)									f->SetRelative((V_File*)buf);								else									f->SetRelative(NULL);								err = f->IO(buf);								if (err)		// MERGE16								{								char fn[256];								#if VR    // jca 19MAY94 do this only for VR     													// MERGE24									// We can't find the file, so look in the custom picts									// array for the file.  If we find it there, then we set									// matching_ti to NULL, because we want to make this a real									// texture item									if (gReadingLibrary)									{										forget_texture = TRUE;										err = noErr;									}									else									{										f->GetFName(fn);										err = FindInCustomPicts(f);										if (err)										{																					forget_texture = TRUE;											err = noErr;										}										else										{											// force a make real											matching_ti = NULL;											got_custom_pict = TRUE;											add_to_doc_textures = TRUE;		// MERGE25											err = noErr;										}																	}#endif // VR#if VPRO			// MERGE-GOURAUD-PRO-5										// check to see if we can find the file in the same place as										// the last file we forced the user to find.  Maybe it's there.										f->GetFName(fn);										found = FALSE;										if (check)										{										V_File *checkf;                                        	#if MACINTOSH											// get rid of that goddammned alias											if (checkLoc->alias)											{												DisposHandle((Handle)(checkLoc->alias));												checkLoc->alias = NULL;											}											#endif																					// check to see if the file we are looking for is in											// checkdir and checkvol.  If it is, then go ahead and											// use it.  											checkf = new(V_File);											checkf->cFile(REFERENCE, 0, 0, "", ""); 											strcpy(checkLoc->name, fn);											checkf->VSetLocation(checkLoc);											err = checkf->Find();											if (!err)											{											OSErr tmperr;												// we found the file, so set f to be this file we found												f->VSetLocation(checkLoc);												tmperr = f->Find();												found = TRUE;											}											checkf->dFile();										}										if (!found)										{											// we can't even find it in the custom picts, so ask user what to do											//sprintf(str,"Texture \"%s\" is missing. Do you want to locate it?",fn);											sprintf(str,TXT_TXTRMISSING,fn);											if (WarningMessage(str,TXTC_FORGET,TXTC_LOCATE,POSITIVE_BUTTON_TWO|DEFAULT_BUTTON_TWO))											{												//sprintf(str,"Locate texture \"%s\":",fn);												sprintf(str,TXT_LOCATETXTR,fn);												// ¥¥¥¥ SHOULD CALL SEPARATE ROUTINE FOR THIS!!!!!!												f->SetQuery(LOADAS,str);                                                #if MACINTOSH												f->AddFType(appFileTypePICT, "");												f->AddFType(appFileTypeQuickTime, "");												#elif WINDOWS												f->AddFType(appFileTypeBMP, "");												#endif												err = f->Find();																								f->SetQuery(REFERENCE,"");												if (err)												{													forget_texture = TRUE;													err = noErr;												}												else												{													// the user found a file, so remember this													// location and next time we have to look for													// a file, if we can use this same location													// and the file is there, just go ahead and													// use the files in that dir.													f->VGetLocation(checkLoc);													check = TRUE;												}											}											else											{																						forget_texture = TRUE;												err = noErr;											}										}#endif#if ((!VR) && (!VPRO))									// do something appropriate									forget_texture = TRUE;									err = noErr;#endif // ((!VR) && (!VPRO))								}								else	// no error, so we found the file ref okay									found_file_ref = TRUE;	// MERGE24								if ((!err) && (!forget_texture))		// MERGE14									ti->TextureVFile(f);			//GJR 09/24/93 [[[									//err = ti->TextureVFile(f);			//GJR 09/24/93 [[[									if (err)					// Oops, memory/file problems										{										forget_texture = TRUE; //Leave err set to abort load.										}								//GJR 09/24/93 ]]]								f->dFile();								break;							case IFF_TXNM:	// texture logical name								name = new(V_Array);								name->cArray(buf->ChunkSize(), 1, 16);								name->IO(buf);								nm = (char*)name->Use();																#if (!VPLAYER)								// MERGE20 [[[								// MERGE16 search for a texture item that matches this name;								// if we find one, then don't bother reading in the picture data								// later								// MERGE27:  don't bother looking if we already found the file								// reference.								// MERGE-BUG-034: don't check VR Texture Galleries if we are loading								// a VWT Pro file -- just use the info in the pro file itself.  								#if VR								if (buf->GetBufferType() == V_FILETYPE)		// MERGE-BUG-034									reading_vwt_pro_file = (((V_File*)buf)->create == MakeID('V','p','r','o'));	// MERGE-BUG-034																if (!got_custom_pict && !found_file_ref && !reading_vwt_pro_file)		// MERGE27	// MERGE-BUG-034								#else								if (!got_custom_pict && !found_file_ref)		// MERGE27	// MERGE-BUG-034								#endif // VR								{									matching_ti = VRFindTextureByName(nm);																		// MERGE31 if we previously decided to forget this									// texture, then we can now remember it, because									// we found a texture that we can merge with.  So									// don't forget it after all!!									if (matching_ti) forget_texture = FALSE;								}								else									matching_ti = NULL;																// PRO-14 this is the  problem for the pasting from another								// embedded-texture file... we get a "matching_ti" above and								// so we don't read the picture data. What we want to happen								// is even though we get a matching ti we want to read the								// picture data if we are reading from a buffer.								 								//if (matching_ti != NULL)			// PRO-14 this maybe should be removed!!								//	read_picture_data = FALSE;		// PRO-14 this maybe should be removed!!								// MERGE20 ]]]								#endif //!VPLAYER								strcpy(ti->settings.name, nm);																//if (matching_ti != NULL)			// PRO-14 this maybe should be removed!!								//	read_picture_data = FALSE;		// PRO-14 this maybe should be removed!!																name->Unuse();								name->dArray();			// jca 19 Oct 93								name = NULL;			// jca 19 Oct 93								break;							case IFF_TXST:								buf->IOType(&c, IO_CHAR);								ti->settings.decal = c;								buf->IOType(&c, IO_CHAR);								ti->settings.shade = c;								buf->IOType(&c, IO_CHAR);								ti->settings.colorize = c;								IOType(buf, &ti->settings.hSlide, IO_FFIXED);								IOType(buf, &ti->settings.vSlide, IO_FFIXED);								IOType(buf, &ti->settings.rotate, IO_FFIXED);								buf->IOType(&c, IO_CHAR);								ti->settings.hFlip = c;								buf->IOType(&c, IO_CHAR);								ti->settings.vFlip = c;								buf->IOType(&c, IO_CHAR);								ti->settings.hMirror = c;								buf->IOType(&c, IO_CHAR);								ti->settings.vMirror = c;								IOType(buf, &ti->settings.hTiles, IO_FFIXED);								IOType(buf, &ti->settings.vTiles, IO_FFIXED);								IOType(buf, &ti->settings.hPixels_per_unit, IO_FFIXED);								IOType(buf, &ti->settings.vPixels_per_unit, IO_FFIXED);								buf->IOType(&tmp_short, IO_SHORT);								ti->settings.hUnit = tmp_short;								buf->IOType(&tmp_short, IO_SHORT);								ti->settings.vUnit = tmp_short;								buf->IOType(&c, IO_CHAR);								ti->settings.use_real_world_size_h = c;								buf->IOType(&c, IO_CHAR);								ti->settings.use_real_world_size_v = c;								buf->IOType(&tmp_short, IO_SHORT);								ti->settings.mapping = tmp_short;								break;						}												buf->CloseChunk();						// MERGE22 [[[						//JAM 11OCT94 gLoadingTexture for hack to get meters operating nice when loading textures						if ((!gHigherPriorityMeterInUse) && (!gLoadingTexture))						{						MeterSetCount(buf->IOGetPosition());						if (MeterUpdate(0)) err = -2;						}						// MERGE22 ]]]						if (lowMemory) err = -3;					}					// now we have read in all the info for this texture item.					// if the user told us to forget the texture file, then we should					// set all the objects using this texture item to no texture.					// Otherwise we check it against the other texture items and					// merge them if they are the same.  										if (err || forget_texture)		//any reason for having quit early?  GJR 09/24/93					{						ti->NoTexture();						ti->dTextureItem();						forget_texture = FALSE;					}					else					{					int theBool;	// PRO-14											// we should make this a real guy (i.e. not merge him) if						// this is a custom pict and the settings don't match the 						// matching ti's settings.  It is possible that the matching                       						//MERGE-PRO-JAM-2 [[[                        #if !VPRO						if (matching_ti != NULL)						{							MergeIfSameVR(matching_ti, ti);							ti->dTextureItem();						}						#else						// PRO-14 [[[						if (matching_ti != NULL)						{							if ((matching_ti->texture->type == TEXTURE_CHUNK) || 	// PRO-14								(actually_got_picture_data))		// PRO-14							{								theBool = (MergeIfSameVR(matching_ti, ti));							}							else							{								theBool = (MergeIfSame(matching_ti, ti));							}						}						else							theBool = FALSE;												if (theBool)	// PRO-14						// PRO-14 ]]]						{							ti->dTextureItem();	//got merged                        }                        #endif //!VPRO						//MERGE-PRO-JAM-2 ]]]						else						{							err = ti->MakeReal();							// MERGE20 [[[							// remember this texture item as a document-specific texture							// so we can remove it when we close the document.  Don't 							// do it if we are scanning the texture folder at startup though							// (when gLoadingTextureFolderTextures is set to true)#if VR // jca 17JAN94							if (add_to_doc_textures && (!gLoadingTextureFolderTextures))							{							extern TextureArray *gAllDocTextures;								gAllDocTextures->Append(&ti);							}#else							if (add_to_doc_textures)							{   // jca 21JAN94 add texture to the doc's textures//MERGE-PRO-JAM-3 removed--done in cTextureItem.  io_textures->Append(&ti);	                            }#endif // VR							// MERGE20 ]]]						}					}					break;				}			}						buf->CloseChunk();			// MERGE22 [[[			//JAM 11OCT94 gLoadingTexture for hack to get meters operating nice when loading textures [[[			if ((!gHigherPriorityMeterInUse) && (!gLoadingTexture))			{			MeterSetCount(buf->IOGetPosition());			if (MeterUpdate(0)) err = -2;			}			//JAM 11OCT94 for hack to get meters operating nice when loading textures [[[			if(gLoadingTexture)			{				long buflength, bufposition,newmetercount;				buf->IOLength(&buflength);				bufposition = buf->IOGetPosition();				if(bufposition != 0)                {				   newmetercount = (long)((float)(TEXTUREMETERLOADLENGTH-1) * (float)bufposition / (float)buflength);				}				else				{				   newmetercount = MeterGetCount();                }				MeterSetCount(newmetercount);				if (MeterUpdate(0)) err = -2;			}			//JAM 11OCT94 for hack to get meters operating nice when loading textures ]]]			// MERGE22 ]]]			if (lowMemory) err = -3;		}	}	else // DATA OUT	{			#if (!VPLAYER)	// No DataOut for Player. Also avoids GetEmbedTextures	struct TextureItem **ti;	long local_id;	int i;	short tmp_short;			ti = (TextureItem **)io_textures->Use();		for ( i = 0 ; i < io_textures->ALength() ; i++ )			{			int purge_this_texture = FALSE;		// default is not to purge  // PRO-21						#if VR // PRO-21 ABD this will need to be retought for VR and stuff			//#error // PRO-21			// mar95 ABD since VR always embeds textures, we set			// purge_textures to TRUE.  We could do a GetEmbedTextures()			// here when VR give users a choice...			purge_textures = TRUE;			#if VPRO	// pro ignores passed purge param?? //GJR10/19/94			// write this texture out iff:			//    1) we are not purging textures			// or 3) it is a texture link (not embedded)			purge_textures = FALSE;  		// PRO-15 never purge unused textures // always purge texture for VR MERGE15						if (GetEmbedTextures())  		// PRO-15 ......except if they are all embedded,				purge_textures = TRUE;  	// PRO-15 purge unused textures			#endif //VPRO			//JAM/DREW 20OCT94			//don't output unused textures if this is a buffer (i.e. a copy command)			if (buf->GetBufferType() == V_BUFFERTYPE)				purge_textures = TRUE;  	// PRO-15 purge unused textures			#endif // PRO-21						// NEW CODE 10/24/94 ABD			// always write it out unless 						// 		1) it is an embedded texture (or use has chosen all textures to be 			//         embedded) and it is not in use,			// or	2) we are doing a cut and it is not in use			purge_this_texture = FALSE;			#if VR			if(ti[i]->id == NON_IO_ID)				purge_this_texture = TRUE;			#else			if(ti[i]->id == NON_IO_ID)			{				if((buf->GetBufferType() == V_BUFFERTYPE) || (GetEmbedTextures()) || (ti[i]->texture->type == TEXTURE_CHUNK) || (ti[i]->texture->type == TEXTURE_PICT))					purge_this_texture = TRUE;			}    		#endif			#if VPRO // PRO-21			if (!purge_this_texture) // PRO-21#else // PRO-21			if ((!purge_textures) || (ti[i]->id != NON_IO_ID))#endif // PRO-21			{			struct V_Array *name;			char *nm;			char c;							buf->OpenChunkW(IFF_TXTE);			// texture table entry									buf->OpenChunkW(IFF_TXID);		// texture id											// if ti[i]->id is NON_IO_ID, then this texture is not involved in						// i/o, but we need to give it a unique id anyway so that it won't						// be confused with other unused textures when read back in						if (ti[i]->id == NON_IO_ID)							local_id = next_id++;						else							local_id = ti[i]->id;						buf->IOType(&local_id, IO_LONG);					buf->CloseChunk();										// MERGE19 write out the name *BEFORE* the offscreen goddammit.  Maybe this					// time this code will actually get merged.  Hopefully Bill will see this					// snide comment and will retaliate by challenging me to a game of					// Bolo.  If he does this, we will know that this code has finally been merged.										buf->OpenChunkW(IFF_TXNM);		// texture name 						name = new(V_Array);						name->cArray(64, sizeof(char), 8);						nm = (char *)name->Use();						ti[i]->GetName(nm);						name->Unuse();						name->IO(buf);						name->dArray();			// jca 19 Oct 93						name = NULL;			// jca 19 Oct 93					buf->CloseChunk();					//JAM first try to save embedded textures or file refs [[[#if VPRO					// MERGE19 [[[					// if buf is a buffertype, then we are doing cut/copy/paste, so dont write					// out the entire offscreen.  We wrote out the name and so we will find the					// texture again when we do a paste.					//ùùùùif (buf->GetBufferType() != V_BUFFERTYPE)// MERGE-BUG  ABD 17MAR94					if(GetEmbedTextures())						{						err = ti[i]->IOOff(buf);	//JAM if you change this line, change it after the #else matching #if VPRO						}					else						{						if ((ti[i]->texture->type != TEXTURE_CHUNK) && (ti[i]->texture->type != TEXTURE_PICT))		// PRO-20							err = ti[i]->IORef(buf);						else                        	err = ti[i]->IOOff(buf);						}										// MERGE19 ]]]#else //!VPRO						err = ti[i]->IOOff(buf);#endif //VPRO//JAM first try to save embedded textures or file refs ]]]					ObjLock((Handle)ti[i]);         // PRO-17					buf->OpenChunkW(IFF_TXST);		// texture settings 						c = ti[i]->settings.decal;						buf->IOType(&c, IO_CHAR);						c = ti[i]->settings.shade;						buf->IOType(&c, IO_CHAR);						c = ti[i]->settings.colorize;						buf->IOType(&c, IO_CHAR);						IOType(buf, &ti[i]->settings.hSlide, IO_FFIXED);						IOType(buf, &ti[i]->settings.vSlide, IO_FFIXED);						IOType(buf, &ti[i]->settings.rotate, IO_FFIXED);						c = ti[i]->settings.hFlip;						buf->IOType(&c, IO_CHAR);						c = ti[i]->settings.vFlip;						buf->IOType(&c, IO_CHAR);						c = ti[i]->settings.hMirror;						buf->IOType(&c, IO_CHAR);						c = ti[i]->settings.vMirror;						buf->IOType(&c, IO_CHAR);						IOType(buf, &ti[i]->settings.hTiles, IO_FFIXED);						IOType(buf, &ti[i]->settings.vTiles, IO_FFIXED);						IOType(buf, &ti[i]->settings.hPixels_per_unit, IO_FFIXED);						IOType(buf, &ti[i]->settings.vPixels_per_unit, IO_FFIXED);						tmp_short = ti[i]->settings.hUnit;						buf->IOType(&tmp_short, IO_SHORT);						tmp_short = ti[i]->settings.vUnit;						buf->IOType(&tmp_short, IO_SHORT);						c = ti[i]->settings.use_real_world_size_h;						buf->IOType(&c, IO_CHAR);						c = ti[i]->settings.use_real_world_size_v;						buf->IOType(&c, IO_CHAR);						tmp_short = ti[i]->settings.mapping;						buf->IOType(&tmp_short, IO_SHORT);					buf->CloseChunk();					ObjUnlock((Handle)ti[i]);      // PRO-17									buf->CloseChunk();				}			}		io_textures->Unuse();	#endif //(!VPLAYER)	 No DataOut for Player. Also avoids GetEmbedTextures	}	//JAM added the following line 24Sept93 	if (checkLoc) checkLoc->dVfsLocation();		// MERGE-GOURAUD-PRO-5 	return (err);					// need lint GJR091593}/*------------------------------------------------------------------------------*//*	This routine ends texture io by making the texture palette list and the	internal docTextures list be the same.  We keep two internal lists because	docTextures may have temporary texture items created when doing file i/o,	and we don't want to bother with these in the palette list.  So we go	through each texture item in the docTextures list now, and add it to the	palette.  The routine that adds texture items to the palette checks the	palette to make sure the given texture item is not already there.*/void TextureServer::EndTextureIO(V_Buffer *buf){struct TextureItem **ti;int i;		gUseAllOld = FALSE;	gUseAllNew = FALSE;	gRenameAllNew = FALSE;	gAskAboutAll = FALSE;	gReadingLibrary = FALSE;	// MERGE24		// add all the textures to the palette list	ti = (TextureItem **)io_textures->Use();	for ( i = 0 ; i < io_textures->ALength() ; i++ )	{#if VPRO		// add texture item to palette -- no need in VR		if (io_textures->controller)			if (io_textures->controller->GetType() == toolCRTLWalk)				io_textures->controller->AddTextureItem(ti[i]);#endif //VPRO				// reapply the texture to all objects/surfaces/features that use it		ti[i]->ApplyTexture();	}	io_textures->Unuse();		/*JAM*/	/*At the end of the write or read, indicate that all the textures are	  not in the midst of i/o*/	io_textures->ResetIDs();		// null out io_textures	io_textures = NULL;}/*------------------------------------------------------------------------------*//*	This routine ends texture io by making the texture palette list and the	internal docTextures list be the same.  We keep two internal lists because	docTextures may have temporary texture items created when doing file i/o,	and we don't want to bother with these in the palette list.  So we go	through each texture item in the docTextures list now, and add it to the	palette.  The routine that adds texture items to the palette checks the	palette to make sure the given texture item is not already there.*/void TextureServer::EndTextureIOLib(V_Buffer *buf){struct TextureItem **ti;int i;		gUseAllOld = FALSE;	gUseAllNew = FALSE;	gRenameAllNew = FALSE;	gAskAboutAll = FALSE;	gReadingLibrary = FALSE;	// MERGE24	// add all the textures to the palette list	ti = (TextureItem **)io_textures->Use();	for ( i = 0 ; i < io_textures->ALength() ; i++ )	{		// reapply the texture to all objects/surfaces/features that use it		ti[i]->ApplyTexture();	}	io_textures->Unuse();		/*JAM*/	/*At the end of the write or read, indicate that all the textures are	  not in the midst of i/o*/	io_textures->ResetIDs();			// null out io_textures	io_textures = NULL;}/*------------------------------------------------------------------------------*//*	This routine */intTextureServer::IOTextureLibrary(V_Buffer *buf){int err = 0;long id = 0;			if (buf->IODirection() == DATA_IN)	{		while (!err)		{			id = buf->OpenChunkR();			if (id == 0) break;						switch (id)			{				case IFF_TXTB:					err = IOTextureTable(buf, FALSE);					break;				case IFF_FORM:	// recursively descend if textures in there					err = buf->IOType(&id, IO_LONG);					if (!err && id == IFF_VMDL)						err = IOTextureLibrary(buf);					break;				default:	// do nothing					break;			}			buf->CloseChunk();		}	}	else	{		buf->OpenChunkW(IFF_TXTB);		err = IOTextureTable(buf, FALSE);		buf->CloseChunk();	}	return(err);}	/*------------------------------------------------------------------------------*//**/void TextureServer::LoadTexturesOldStyle (V_File *modelFile){	// don't load old style in VR}// MERGE20 [[[/*------------------------------------------------------------------------------*//**/void TextureServer::RemoveDocTextures(){#if VRstruct TextureItem **ti;int i;extern TextureArray *gAllDocTextures;extern TextureArray * gAllTextures;   	// jca 1 Oct 93	ti = (TextureItem **)gAllDocTextures->Use();	for ( i = 0 ; i < gAllDocTextures->ALength() ; i++ )	{	long loc = gAllTextures->Find(&(ti[i]));	long tloc;	// MERGE-DEL			//#if 0		// MERGE-DEL [[[		// remove the texture that is referenced by this texture item		tloc = textures->Find(&(ti[i]->texture));		if (tloc != VARY_NOTFOUND) 		{			//ti[i]->texture->dTexture();		}		else		{			// the texture has already been removed, so do nothing		}		// MERGE-DEL ]]]		//#endif				if (loc != VARY_NOTFOUND)			gAllTextures->Remove(loc);		else			DEBUGGER();	}	gAllDocTextures->Unuse();#endif // VR}// MERGE20 ]]]/*------------------------------------------------------------------------------*//**/struct TextureItem *TextureServer::FindOldStyle(int index){	if (io_textures)		return io_textures->FindOldStyle(index);}// JAM 7-18-94 to help handle embedding/file refs for textures[[[#if VPROshortTextureServer::GetEmbedTextures(void){	return(EmbedTexturesFlag);}voidTextureServer::SetEmbedTextures(short newvalue){	EmbedTexturesFlag = newvalue;}#endif// JAM 7-18-94 to help handle embedding/file refs for textures]]]