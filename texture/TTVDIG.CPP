#include "VTypes.h"#include "WTypes.h"#include "ShowTest.h"#include "VDisplay.h"#include "VGraphic.h"#include "VMemUtil.h"#include "VButton.h"	// jca 2 Oct 93#include "VMDL.h"#include <stdio.h>#include <string.h>#include "VFile.h"			//added for texture				//GJR 10/06/93#include "TextType.h"		//keep after vfile.h			//GJR 10/06/93#include "AppText.h"		// jam 31Oct94#if MACINTOSH/*------------------------------------------------------------------------------*//*	This routine */void TTVDIG::cTextureType(){	char str[256];	sprintf(str,"%s",TXT_VDIG);	//jam 31oct94	TextureType::cTextureType();	strcpy(type_str, str);}/*------------------------------------------------------------------------------*//*	This routine */void TTVDIG::SetVDIG(VideoDigitizerComponent vThingSoul, short input){	VideoDigitizerError verr;DigitizerInfo info;	vdig = vThingSoul;	input_num = input;	verr = VDGetDigitizerInfo(vdig, &info);	slot_num = info.slot;}/*------------------------------------------------------------------------------*//*	This routine sets up the frame for the video digitizer by grabbing the next	frame.  */int TTVDIG::SetupFrame(){	VideoDigitizerError verr = noErr;	if (mip[0])		verr = VDGrabOneFrame(vdig);			return (verr);}/*------------------------------------------------------------------------------*//*	This routine loads the picture for the video digitizer.  It does this by 	initializing the video 		!!! Bug note -- for some reason, with the SuperMac VideoSpigot, the video 	sometimes has to be coming in while the following calls (or other init calls)	are made.  If the VDIG is inited and then the video input signal started, the	result can be a picture that has a vertical black line in the center, and an	image that wraps around the sides.  Workaround is to leave the video signal on,	choose No Texture, and then choose the video digitizer again.*/int TTVDIG::LoadPicture(){	VideoDigitizerError verr;PixMapHandle pix;Rect pixRect, digRect;int err=0; 	// create an offscreen buffer 	mip[0] = new(V_Offscreen);		// vdigs do not use padding for now	padded = FALSE;	// VideoSpigot 320x240 mode looks bad; lots of vertical bands	// now create it for real 	SetRect(&pixRect, 0, 0, 240, 180);	SetRect(&unpadded_rect[0], 0, 0, 240, 180);		// 240x180	err = mip[0]->cOffscreen(&pixRect, 8, &vWhite, NULL);		if (err)	// error, so try smaller rect	{		SetRect(&pixRect, 0, 0, 160, 120);		SetRect(&unpadded_rect[0], 0, 0, 160, 120);		// 160x120		err = mip[0]->cOffscreen(&pixRect, 8, &vWhite, NULL);	}	if (err) return(err);		// get a PixMap handle and pixmap rect 	pix = mip[0]->metaPort->portPixMap;	pixRect = unpadded_rect[0];		// which input do we want to digitize	verr = VDSetInput(vdig, input_num);	if (verr) return(verr);		// get the rect we are digitizing	verr = VDGetDigitizerRect(vdig, &digRect);	if (verr) return(verr);		// see if our destination is okay with this digitizer	verr = VDPreflightDestination(vdig, &digRect, pix, &pixRect, NULL);		// if verr is qtParamErr, then digRect and pixRect were invalid values, but	// we just ignore the error because Preflight sets them to be valid.	if ((verr) && (verr != qtParamErr)) return(verr);		// set the destination for the video	verr = VDSetPlayThruDestination(vdig, pix, &pixRect, NULL, NULL);	if (verr) return(verr);	// grab a frame	verr = VDGrabOneFrame(vdig);	if (verr) return(verr);	return (verr);}/*------------------------------------------------------------------------------*//*	This routine deletes the offscreen used for video digitizing.  It is called when	we no longer are using this digitizer in the model. */void TTVDIG::UnloadPicture(){		if (mip[0]) mip[0]->dOffscreen();		// get rid of picture	mip[0] = NULL;							// make sure picture set to NULL}/*------------------------------------------------------------------------------*//*	This routine makes a thumbnail for the digitizer and draws it in thumbnail,	which has already been created.  */int TTVDIG::MakeThumbnail(V_Offscreen *thumbnail, Rect *r_to){	V_Offscreen *icon_off, *mask;Rect r_from;RGBColor c;//extern unsigned int offColor[];       <-- remove jca 2 Oct 93Point local_size;VCGrafPort p;VGrafDevice d;	icon_off = new(V_Offscreen);	icon_off->LoadPNum(500,8);	mask=new(V_Offscreen);	mask->LoadPNum(501,0);		r_from = icon_off->rect;	*r_to = thumbnail->rect;	VGetPort(&p,&d);	thumbnail->SetMetaPort();	c = offColor[BaseColor];       // jca 2 Oct 93	VForeColor(&c);	PaintRect(r_to);	thumbnail->UnsetMetaPort();	VSetPort(p,d);	   	// copy from the picture only if there is a picture	icon_off->MaskMetaTo(thumbnail, mask, &r_from, r_to);			icon_off->dOffscreen();	mask->dOffscreen();	ObjLock(this);	sprintf(info_str, "slot %X input %d", slot_num, input_num+1);	ObjUnlock(this);}/*------------------------------------------------------------------------------*//*	This routine */int TTVDIG::IORef(V_Buffer *buf){	short vdSlot, vdInput;	vdSlot = slot_num;	vdInput = input_num;	buf->OpenChunkW(IFF_TXVD);		// texture video board		buf->IOType(&vdSlot, IO_SHORT);									buf->IOType(&vdInput, IO_SHORT);								buf->CloseChunk();}#elif WINDOWS#if !ELVIS#error TTVDIG#endif#endif //MACINTOSH