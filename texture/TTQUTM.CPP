#include "VTypes.h"#include "WTypes.h"#include <stdio.h>#include <string.h>#include "QUICKTIM.h"#include "VMDL.h"#include "ShowTest.h"			// !!! DEBUG#include "AppText.h"			// needed for IO()#include "AppFiles.h"			// needed for IO()#include "VDisplay.h"#include "VFile.h"#include "VGraphic.h"#include "VGUtil.h"#include "VMemUtil.h"#include "VError.h"#include "TextType.h"			//after vfile				//GJR 10/06/93#if MACINTOSH#include <QuickTimeComponents.h>#endifextern int gQuickTime;#if USE_HMD#include "HMD.h"long gQTCurrentFrame = 0;		// MERGE-HMDlong gQTOldFrame = 0;			// MERGE-HMD#endif // USE_HMD/*------------------------------------------------------------------------------*//*	This routine */void TTQuickTime::cTextureType(){	char str[256];	sprintf(str,"%s",TXT_MOVIE);	//jam 31oct94	// create the quicktime movie	if (gQuickTime)	{		file = (V_File*)new(QuickTime);		((QuickTime*)file)->cQuickTime(REFERENCE,0,0,"",TXTPF_QUICTIME);	}	else		file = NULL;	vfsLocation = new(VfsLocation);	vfsLocation->cVfsLocation();	strcpy(type_str, str);	started = FALSE;	running = FALSE;}/*------------------------------------------------------------------------------*//*	This routine deletes the texture object and associated objects.*/void TTQuickTime::dTextureType(void){		if (gQuickTime)		if (file) ((QuickTime*)file)->dQuickTime();	// note no need to delete picture separately; dQuickTime does it		file = NULL;	FileTextureType::dTextureType();}/*------------------------------------------------------------------------------*//*	No MIP maps for quicktime movies. */int TTQuickTime::MakeMIP(){	int i;	for ( i = 1 ; i < MAX_NUM_MIPS ; i++ )		// NOTE we don't NULL out mip[0]		mip[i] = NULL;			return(noErr);								// JAM needed return value}/*------------------------------------------------------------------------------*//*	This routine */int TTQuickTime::MakeThumbnail(V_Offscreen *thumbnail, Rect *r_to){	int result;#if MACINTOSHRect box;Movie theMovie;PicHandle pic_h;double scale_factor;int width, height, top, bottom, left, right;double new_height, new_width, margin;extern unsigned int offColor[];VCGrafPort p;VGrafDevice d;	if (!gQuickTime) return(noErr);	theMovie = ((QuickTime*)file)->qtMovie;	pic_h = GetMoviePosterPict(theMovie);	thumbnail->GetRect(r_to);	width = (*pic_h)->picFrame.right - (*pic_h)->picFrame.left;	height = (*pic_h)->picFrame.bottom - (*pic_h)->picFrame.top;	if (width > height)	{		scale_factor = (double)(32.0 / width);		new_height = height * scale_factor;		margin = 32 - new_height;		top = (margin / 2);		bottom = 32 - (margin / 2);		SetRect(&box, 0, top, 32, bottom);	}	else // height > width	{		scale_factor = (double)(32.0 / height);		new_width = width * scale_factor;		margin = 32 - new_width;		left = (margin / 2);		right = 32 - (margin / 2);		SetRect(&box, left, 0, right, 32);	}#if VR			// jca 18 Oct 93 {	*r_to = box;		// this is what we're after, right?  we should blit to the right size#endif	// VR	// jca 18 Oct 93 }	VGetPort(&p,&d);	thumbnail->SetMetaPort();	DrawPicture(pic_h, r_to);	thumbnail->UnsetMetaPort();	VSetPort(p,d);	KillPicture(pic_h);#elif WINDOWS#if !ELVIS	//	No quicktime movies in windows			//GJR 10/01/93//#error quicktime texture#endif#endif //MACINTOSH	return(noErr);}#if MACINTOSH/*------------------------------------------------------------------------------*//*	This routine sets the texture to be based on the file info passed to it.  It 	does processing necessary to create the texture thumbnail, movie, etc.		The texture fields with the file reference info passed in	as parameters.  fn must be a *Pascal* string, as is returned by most toolbox	calls.  fn,dir,vol will be passed to SetLocation(), so see the documentation	for that routine about what is acceptable to pass to it.*/int TTQuickTime::SetFileLoc(VfsLocation *vfsLocation)		//GJR 10/06/93{	int err = noErr;Rect r;Rect r_from = {0,0,0,0};		// init for errors		//GJR 092493	err = FileTextureType::SetFileLoc(vfsLocation);		//GJR 10/06/93		if (gQuickTime) 	{	short power;	short width;		if (!err) err = ((QuickTime*)file)->OpenMovie(FALSE);		if (!err)			{	 // then rect is probably good			//GJR 09/24/93			((QuickTime*)file)->IORect(&r_from);			}		r = r_from;				if (!err)										//GJR 09/24/93			{			// QuickTime movies are textured with a mod version of texture8 and so don't need to			// be powers of two#if 0		// make the horiz size a power of two		power = 2;		width = r_from.right - r_from.left;		while (power < width)			power <<= 1;						r.right = r.left + power;		// make the vertical size a power of two		power = 2;		width = r_from.bottom - r_from.top;		while (power < width)			power <<= 1;						r.bottom = r.top + power;#endif			// limit max size to 1024 (see TTPICTFile and flashtexture to guess why			// *2 for mirroring, *2 for signed values, *2 to catch proper signed overflows, *4 for rowaddress indexing ==>2^5			r.right = r.left + min(r_from.right - r_from.left, 1024);			r.bottom = r.top + min(r_from.bottom - r_from.top, 1024);			}													//GJR 09/24/93		rect = r;	}	ObjLock(this);#if JAPANESE	sprintf(info_str, "%s%d x %s%d", TXTD_HRZSIZE, r_from.right-r_from.left, TXTD_VRTSIZE, r_from.bottom-r_from.top);#else	sprintf(info_str, "%d%s x %d%s", r_from.right-r_from.left, TXTD_HRZSIZE, r_from.bottom-r_from.top, TXTD_VRTSIZE);#endif	ObjUnlock(this);		return(err);}#elif WINDOWSintTTQuickTime::SetFileLoc(VfsLocation *vfsLocation)		//GJR 10/06/93{	return -1;}#if !ELVIS	//	No QuickTime movies for Windows		//GJR 10/01/93//#error quicktime texture		#endif#endif //MACINTOSH/*------------------------------------------------------------------------------*//*	This routine */int TTQuickTime::LoadPicture(){int err = noErr;	if (!gQuickTime) return(noErr);	if (!started)	{	Rect r = rect;			unpadded_rect[0] = rect;			err = ((QuickTime*)file)->BeginMovie(&r, 8, 0);		started = TRUE;		running = TRUE;	}	return err;}/*------------------------------------------------------------------------------*//*	This routine */void TTQuickTime::UnloadPicture(){	if (!gQuickTime) return;	started = FALSE;}/*------------------------------------------------------------------------------*//*	This routine loads the next QuickTime movie frame; texture->picture points to	this offscreen buffer containing the next frame.  */int TTQuickTime::SetupFrame(){		// MERGE-HMD [[[	// MERGE-MAY94 [[[	// read in only one QT frame per rendered frame	#if USE_HMD	if ((gUseHMDs) && (gHMD))	// ABD HMD MAR95    {		if (gQTCurrentFrame == gQTOldFrame)			return(noErr);		else			gQTOldFrame = gQTCurrentFrame;    }	#endif // USE_HMD	// MERGE-MAY94 ]]]	// MERGE-HMD ]]]	if (!gQuickTime) return(noErr);	if (!file) return(-1);	if (!running) return(noErr);	return ((QuickTime*)file)->IOFrame();}/*------------------------------------------------------------------------------*//*	This routine */V_Offscreen *TTQuickTime::GetPicture(int index){		if (!gQuickTime) return(NULL);		if (file) 		return(((QuickTime*)file)->GetOffscreen());	else		return(NULL);}/*------------------------------------------------------------------------------*//*	This routine */voidTTQuickTime::SetMovieRunning(Boolean new_setting){		if (!gQuickTime) return;	if (running == new_setting) return;#if MACINTOSH	running = new_setting;	if (new_setting)	{		StartMovie(((QuickTime*)file)->qtMovie);	}	else	{		StopMovie(((QuickTime*)file)->qtMovie);	}#elif WINDOWS#if !ELVIS	//	No QuickTime movies for Windows		//GJR 10/01/93//#error quicktime texture#endif#endif //MACINTOSH}// MERGE-DEC94intTTQuickTime::IOOff(struct V_Buffer *buf){    return IORef(buf);}