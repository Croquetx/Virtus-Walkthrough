/***********************************************************************************//*********	PERFECT FAST TEXTURES!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ****************//***********************************************************************************/#include "VTypes.h"  #include "WTypes.h"#include "Clip.h"#include "Flash.h"#include "VGUtil.h"#include <stdlib.h>#include "InitText.h"#if WINDOWS#include "DOS.h"		// DOS segment handlers		GJR 10/29/93						// Note: huge can't store across seg boundaries with single op#define SPANNEDHUGE(farptr, hifarptr) ((unsigned) FP_OFF(farptr) > (unsigned) FP_OFF(hifarptr))#endif //WINDOWS//#define DEBUG 1//#define PROFILE 1#include "VDebug.h"#if DEBUG#include "VTimer.h"#endif#include "TextSrvr.h"	// ABD TEXTURE#if PROFILE#include <profile.h>#endif#include "sfgen.h"#define ACCEPT 0#define TRIVIALREJECT -1#define LEFT 0#define RIGHT 1#define UP 2#define DOWN 3/*temporary arrays for clipping and tables*/V_Array *globalvarray1 = NULL;V_Array *globalvarray2 = NULL;V_Array *globalvarray3 = NULL;V_Array *globalvarray7 = NULL;V_Array *clipvarray1 = NULL;V_Array *clipvarray2 = NULL;V_Array *clipvarray3 = NULL;V_Array *clipvarray4 = NULL;int screenpointerchange;FFixed *texturetable;int *auxarray;typedef struct Point3DFFNoPersp	{		FFixed x;		FFixed y;		FFixed z;		long perspecD;	} Point3DFFNoPersp;typedef struct PointFFixedpersp	{	FFixed x;	FFixed y;	short z;	long perspecD;	} PointFFixedpersp;	typedef struct FFixedrect	{	FFixed top;	FFixed bottom;	FFixed left;	FFixed right;	} FFixedrect;/*linear texture routine for fixed point coordinates*//*this routine exists so we can draw linearly from the cliped-to-screen textured  polygon*/  intFFixedLinearTexture8(struct  TextureRendSettings *textureinfo, V_Offscreen *to,					 PointFFixed *pf, PointFFixed *pt, int plength,					 Clip *clipper);intFFixedLinearTexture8(struct  TextureRendSettings *textureinfo, V_Offscreen *to,					 PointFFixed *pf, PointFFixed *pt, int plength,					 Clip *clipper){int index_left=0,index_right;int mode = textureinfo->decal;int xOffsetTail;//#if MACINTOSH         // DELETE COMMENTS 	//GJR 11/02/93int xOffset=-to->GetXOffset();int yOffset=-to->GetYOffset();long toRowBytes=to->GetRowWidth();//#elif WINDOWS//#if !ELVIS//#error hi Greg!//#error int xOffset=-to->GetXOffset();//#error int yOffset=-to->GetYOffset();//#error long toRowBytes=to->GetRowWidth();//#endif//int xOffset=-to->GetXOffset();    // these are all zero!  jca 23 sept 93//int yOffset=-to->GetYOffset();//long toRowBytes=to->GetRowWidth();//#endif // MACINTOSH#if WINDOWSunsigned char *yBase; //windows original start of output line			#endifunsigned char *y;	// pointer to start of output line, with xoffsetunsigned char *yy;  // pointer to start of span, with x coord figured in.unsigned char *drawmin, *drawmax;unsigned char **fromRaster;unsigned char *dith1, *dith2;int fodxl, fodyl, fodxr, fodyr;int dyl, odyl, odxl, dyr, odyr, odxr, deltay, reset;int dx;int cxl;int cxr;int i,j;Rect rclip, texturerect;//int cleft,cright;int ytop;struct ClipStruct *clip;int cliptop,clipbottom,clipindex;int notDone=TRUE;int rval=FALSE;FFixed xl, dxl, xr, dxr, yl, yr, fxl, fdxl, fxr, fdxr, fyl, fdyl, fyr, fdyr;FFixed tempfixed;int horizontaltexturemask, verticaltexturemask, horizontalmirrormask, verticalmirrormask;ShadeEntry *tshade;int fliph, flipv;int IsAPowerOfTwo;int currenthorizontaltile = 0;int currentverticaltile = 0;struct ScanLineInfo LineInfo;void (*ShadedLinearScanFillRoutine)(struct ScanLineInfo *);int BitDepthIndex;VGrafPort savePort;	// ABD MERGE23VGrafDevice saveDevice;	// ABD MERGE23/*if(clipper->rgnClip)return rval;*/to->GetClip(&rclip);textureinfo->mip[0]->GetRect(&texturerect);fromRaster = textureinfo->mip[0]->UseRaster(&savePort, &saveDevice);	// ABD MERGE23LineInfo.fromRaster = fromRaster;//pt=(PointFFixed *)tpoints->Use();//pf=(PointFFixed *)fpoints->Use();//plength=tpoints->ALength();if(plength<=2)goto endit;horizontaltexturemask = (texturerect.right) - 1;verticaltexturemask = (texturerect.bottom) - 1;horizontalmirrormask = (texturerect.right);verticalmirrormask = (texturerect.bottom);LineInfo.horizontaltexturemask = horizontaltexturemask;LineInfo.verticaltexturemask = verticaltexturemask;LineInfo.horizontalmirrormask = horizontalmirrormask;LineInfo.verticalmirrormask = verticalmirrormask;/*select correct bit depth based on to raster*/switch (to->bitDepth)	{#if MACINTOSHcase	1:		BitDepthId = BITDEPTHID1;		BitDepthIndex = BITDEPTHINDEX1;		break;case	2:		BitDepthId = BITDEPTHID2;		BitDepthIndex = BITDEPTHINDEX2;		break;#endifcase	4:		BitDepthId = BITDEPTHID4;		BitDepthIndex = BITDEPTHINDEX4;#if WINDOWS		if(to->wBmPlanes == 4)			{			BitDepthId = BITDEPTHID4X1;			BitDepthIndex = BITDEPTHINDEX4X1;			}#endif //WINDOWS		break;case	8:		BitDepthId = BITDEPTHID8;		BitDepthIndex = BITDEPTHINDEX8;		break;case	16:		BitDepthId = BITDEPTHID16;		BitDepthIndex = BITDEPTHINDEX16;		break;#if WINDOWScase	24:		BitDepthId = BITDEPTHID24;		BitDepthIndex = BITDEPTHINDEX24;		break;#endif //WINDOWScase	32:		BitDepthId = BITDEPTHID32;		BitDepthIndex = BITDEPTHINDEX32;		break;default: DEBUGGER();return (rval);	}tshade = textureinfo->textureShade;//cleft=cright=pt[0].h;for(i=1;i<plength;i++)	{	if(pt[index_left].v.l>pt[i].v.l)index_left=i;//	if(pt[i].h<cleft)cleft=pt[i].h;//	if(pt[i].h>cright)cright=pt[i].h;	}//if(cleft>rclip.right)goto endit;//if(cright<rclip.left)goto endit;if(clipper)	{	if(clipper->type)		{		cliptop=clipper->ytop;		clipbottom=cliptop+clipper->ALength()-1;			if(rclip.top<cliptop)			{			rclip.top=cliptop;			clipindex=0;			}		else clipindex=rclip.top-cliptop;		if(rclip.bottom>clipbottom)rclip.bottom=clipbottom;		clip=(ClipStruct *)clipper->Use();//		if(cleft>clipper->right)goto endit;//		if(cright<clipper->left)goto endit;		}	else clipper=0;	}	if(textureinfo->hFlip) {	fliph = 1;}else {	fliph = 0;}if(textureinfo->vFlip) {	flipv = 1;}else {	flipv = 0;}if(((horizontalmirrormask & (horizontalmirrormask - 1)) == 0) &&  ((verticalmirrormask & (verticalmirrormask - 1)) == 0))  {  	IsAPowerOfTwo = 1;  }else {	IsAPowerOfTwo = 0;}if(textureinfo->vMirror) i = 1;else i = 0;if(textureinfo->hMirror) i |= 2;if(textureinfo->decal)  i |= 4;if(IsAPowerOfTwo) i |= 8;ShadedLinearScanFillRoutine = ShadedLinearScanFill[i][BitDepthIndex];index_right=index_left;j=0;while(FFRound(pt[index_left].v)==FFRound(pt[i=previousNum(index_left,plength)].v) && ++j<plength)index_left=i;if(j==plength)goto endit;j=0;while(FFRound(pt[index_right].v)==FFRound(pt[i=nextNum(index_right,plength)].v) && ++j<plength)index_right=i;if(j==plength)goto endit;/*the TO points *//*xl.intg=pt[index_left].h;yl.intg=pt[index_left].v;xr.intg=pt[index_right].h;yr.intg=pt[index_right].v;xl.frac = yl.frac = xr.frac = yr.frac = 0;*/xl = pt[index_left].h;yl = pt[index_left].v;xr = pt[index_right].h;yr = pt[index_right].v;/*the FROM points */fxl = pf[index_left].h;fyl = pf[index_left].v;fxr = pf[index_right].h;fyr = pf[index_right].v;index_left=previousNum(index_left,plength);index_right=nextNum(index_right,plength);//ytop=yl.intg;ytop = FFRound(yl);rval=TRUE;//if(ytop>=rclip.bottom)goto endit;//clipindex+=(ytop-rclip.top);//if(clipper)if(clipindex>clipper->ALength())goto endit;switch(BitDepthId) {	case BITDEPTHID4X1:	case BITDEPTHID1:		xOffsetTail = xOffset & 7;		xOffset >>= 3;		break;	case BITDEPTHID2:		xOffsetTail = xOffset & 3;		xOffset >>= 2;		break;	case BITDEPTHID4:		xOffsetTail = xOffset & 1;		xOffset >>= 1;		break;	case BITDEPTHID8:		xOffsetTail = 0;		break;	case BITDEPTHID16:		xOffsetTail = 0;		xOffset <<= 1;		break;	case BITDEPTHID24:		xOffsetTail = 0;		xOffset += xOffset+xOffset;		break;	case BITDEPTHID32:		xOffsetTail = 0;		xOffset <<= 2;		break;}#if MACINTOSH                    	//GJR 10/13/93y=(unsigned char *)to->GetBaseAddr() + ((yOffset+ytop)*toRowBytes) + xOffset;#elif WINDOWS// Modify to convert linear lpl to segment adjusted lpl //GJR 10/29/93yBase = to->lpbBmRowAddresses[yOffset+ytop];y     = yBase + xOffset;#endifdyl = FFRound(pt[index_left].v) - FFRound(yl);dyr = FFRound(pt[index_right].v) - FFRound(yr);tempfixed.l = pt[index_left].v.l - yl.l;/*tempfixed.intg = pt[index_left].v - yl.intg;tempfixed.frac = 0;*/dxl.l = pt[index_left].h.l - xl.l;dxl = FFDiv(dxl, tempfixed);fdxl.l = pf[index_left].h.l - fxl.l;fdxl = FFDiv(fdxl, tempfixed);fdyl.l = pf[index_left].v.l - fyl.l;fdyl = FFDiv(fdyl, tempfixed);tempfixed.l = pt[index_right].v.l - yr.l;dxr.l = pt[index_right].h.l - xr.l;dxr = FFDiv(dxr, tempfixed);fdxr.l = pf[index_right].h.l - fxr.l;fdxr = FFDiv(fdxr, tempfixed);fdyr.l = pf[index_right].v.l - fyr.l;fdyr = FFDiv(fdyr, tempfixed);/*handle vertical rounding*//*jump down to sample row*/tempfixed.frac = 0;tempfixed.intg = FFRound(yl);tempfixed.l += FixedPointFive.l;tempfixed.l = tempfixed.l - yl.l;xl.l += FFMult(dxl, tempfixed).l;fxl.l += FFMult(fdxl, tempfixed).l;fyl.l += FFMult(fdyl, tempfixed).l;tempfixed.frac = 0;tempfixed.intg = FFRound(yr);tempfixed.l += FixedPointFive.l;tempfixed.l = tempfixed.l - yr.l;xr.l += FFMult(dxr, tempfixed).l;fxr.l += FFMult(fdxr, tempfixed).l;fyr.l += FFMult(fdyr, tempfixed).l;	/*handle rounding*/xr.l += FixedPointFive.l;xl.l += FixedPointFive.l;fxl.l += FixedPointFive.l;fxr.l += FixedPointFive.l;fyl.l += FixedPointFive.l;fyr.l += FixedPointFive.l;if(clipper) {#if DEBUG	if(FFRound(yl) < clipper->ytop) DEBUGGER();#endif	if(FFRound(yl) > clipper->ytop) {		clipindex = FFRound(yl) - clipper->ytop;	}	else {		clipindex = 0;	}}do	{		if(index_left==index_right)notDone=FALSE;	if(dyl < dyr)		{		deltay=dyl;		reset=1;		dyr-=dyl;		dyl =0;		}	else if(dyr < dyl)		{		deltay=dyr;		reset=2;		dyl-=dyr;		dyr=0;		}	else		{		deltay=dyr;		reset=3;		dyl=dyr=0;		}	while(deltay--)		{		clipindex++;		if(ytop>=rclip.top)			{			FFixed fx, dfx, fy, dfy;			int remainder;			int fxint, fyint;			cxl = xl.intg;			cxr = xr.intg;			if(clipper)				{				cxr=cxr<clip[clipindex].right?cxr:clip[clipindex].right;				cxl=cxl>clip[clipindex].left?cxl:clip[clipindex].left;				}			remainder = xOffsetTail + cxl;			switch(BitDepthId) {				case BITDEPTHID1:					yy = y + (remainder >> 3);					InitialMaskIndex = remainder & 7;					break;				case BITDEPTHID2:					yy = y + (remainder >> 2);					InitialMaskIndex = remainder & 3;					break;				case BITDEPTHID4:					yy = y + (remainder >> 1);					InitialMaskIndex = remainder & 1;					break;				case BITDEPTHID8: 					yy = y + remainder;					break;				case BITDEPTHID16:					yy = y + (remainder << 1);					break;				case BITDEPTHID24:					yy = y + (remainder + remainder + remainder);					break;				case BITDEPTHID32:					yy = y + (remainder << 2);					break;#if WINDOWS				case BITDEPTHID4X1://					LineInfo.yy0 = y + (tempfixed.intg >> 3);					LineInfo.offset4x1 = gwBmWidthBytes;					LineInfo.yy0 = to->lpbBmRowAddresses[ytop+to->yOffset];                    LineInfo.yy0 += (remainder + to->xOffset)>>3;					InitialMaskIndex = remainder & 7;					yy = y;					break;#endif //WINDOWS			}			#if WINDOWS// Modify to convert linear yy to segment adjusted yy //GJR 10/29/93if (SPANNEDHUGE(yBase, yy))  // Segment Adjust	//GJR 10/29/93	{ char huge* hugepc  = yBase;				 hugepc += FP_OFF(yy) - FP_OFF(yBase);				 yy      = (UCharPtr)hugepc;    }#endif			cxr-=cxl;	/*this is the length of the drawn pixels */			//if((xr.intg < rclip.right) && (xr.frac != 0)) cxr++;			cxl-=xl.intg;	/*this is the left hand size of the clip (<=0 if no clip)*/			fx=fxl;			fy=fyl;						/*if(cxl<0)DEBUGGER(); this should be impossible */			/*Draw the scan-line*/			if(cxr>0)		// Only do draws and divides if pixels on line GJR082893				{				/*0 fraction implies center of pixel, center of texel*/								/*need to fiddle here to get exact match, i.e. need to				  divide by xr.l - xl.l and advance to sample point*/				tempfixed.frac = 0;				tempfixed.intg = xr.intg - xl.intg;				dfx.l = fxr.l - fxl.l;				dfx = FFDiv(dfx, tempfixed);				dfy.l = fyr.l - fyl.l;				dfy = FFDiv(dfy, tempfixed);								/* for textures, we need to calculate all of the left hand pixels,				 * including those that are not drawn, because we need to calculate				 * the next pixel location based upon the last pixel location.				 */				/*--------------first do the left-most then middle clipped areas*/					if(cxl > 0) {						fx.l += dfx.l * cxl;						fy.l += dfy.l * cxl;						cxl = 0;					}					if(fliph) {						tempfixed.frac = 0;						tempfixed.intg = horizontaltexturemask;						fx.l = tempfixed.l - fx.l;						dfx.l = -dfx.l;					}					if(flipv) {						tempfixed.frac = 0;						tempfixed.intg = verticaltexturemask;						fy.l = tempfixed.l - fy.l;						dfy.l = -dfy.l;					}					if(BitDepthId <= BITDEPTHID8) {						if(ytop & 1) {							LineInfo.dith1 = tshade->dith[BitDepthId][2];							LineInfo.dith2 = tshade->dith[BitDepthId][3];						}						else {							LineInfo.dith1 = tshade->dith[BitDepthId][0];							LineInfo.dith2 = tshade->dith[BitDepthId][1];						}					}					if(BitDepthId == BITDEPTHID16) {						LineInfo.dith1 = (unsigned char *)(tshade->color16bit);					}					if(BitDepthId == BITDEPTHID24) {						LineInfo.dith1 = (unsigned char *)(tshade->color24bit);					}					if(BitDepthId == BITDEPTHID32) {						LineInfo.dith1 = (unsigned char *)(tshade->truecolor);					}					if(BitDepthId == BITDEPTHID4X1) {                    	if(ytop & 1)						LineInfo.longptr = (unsigned long *) (tshade->color4x1[0]);                        else						LineInfo.longptr =(unsigned long *) (tshade->color4x1[1]);					}					LineInfo.NumOfPixels = cxr;					LineInfo.yy = yy;					LineInfo.x = fx;					LineInfo.dx = dfx;					LineInfo.y = fy;					LineInfo.dy = dfy;					(*ShadedLinearScanFillRoutine)(& LineInfo);				}			}//		y+=toRowBytes;		ytop++;		if(ytop>=rclip.bottom)goto endit;  	// limit before usage      	//GJR 10/29/93#if MACINTOSH                    	//GJR 10/13/93				y+=toRowBytes;#elif WINDOWS// Prepare to convert linear yy to segment adjusted yy //GJR 10/20/93		yBase = to->lpbBmRowAddresses[yOffset+ytop];		y     = yBase + xOffset;#endif//		if(ytop>=rclip.bottom)goto endit;			fxl.l += fdxl.l;			fxr.l += fdxr.l;			fyl.l += fdyl.l;			fyr.l += fdyr.l;			xl.l += dxl.l;			xr.l += dxr.l;		}	if(reset&1)		{		yl = pt[index_left].v;		xl = pt[index_left].h;		fxl = pf[index_left].h;		fyl = pf[index_left].v;		do	{			index_left=previousNum(index_left,plength);			dyl = FFRound(pt[index_left].v) - FFRound(yl);			tempfixed.l = pt[index_left].v.l - yl.l;			dxl.l = pt[index_left].h.l - xl.l;			dxl = FFDiv(dxl, tempfixed);						fdxl.l = pf[index_left].h.l - fxl.l;			fdxl = FFDiv(fdxl, tempfixed);			fdyl.l = pf[index_left].v.l - fyl.l;			fdyl = FFDiv(fdyl, tempfixed);			}while(FFRound(yl)>FFRound(pt[index_left].v) && notDone && index_left!=index_right);			/*jump down to sample row*/			tempfixed.frac = 0;			tempfixed.intg = FFRound(yl);			tempfixed.l += FixedPointFive.l;			tempfixed.l = tempfixed.l - yl.l;			xl.l += FFMult(dxl, tempfixed).l;			fxl.l += FFMult(fdxl, tempfixed).l;			fyl.l += FFMult(fdyl, tempfixed).l;			/*handle rounding*/			xl.l += FixedPointFive.l;			fxl.l += FixedPointFive.l;			fyl.l += FixedPointFive.l;		}	if((reset&2) && index_left != index_right)		{		yr = pt[index_right].v;		xr = pt[index_right].h;		fxr = pf[index_right].h;		fyr = pf[index_right].v;		do	{			index_right=nextNum(index_right,plength);			dyr = FFRound(pt[index_right].v) - FFRound(yr);			tempfixed.l = pt[index_right].v.l - yr.l;						dxr.l = pt[index_right].h.l - xr.l;			dxr = FFDiv(dxr, tempfixed);			fdxr.l = pf[index_right].h.l - fxr.l;			fdxr = FFDiv(fdxr, tempfixed);			fdyr.l = pf[index_right].v.l - fyr.l;			fdyr = FFDiv(fdyr, tempfixed);			}while(FFRound(yr)>FFRound(pt[index_right].v) && notDone && index_left!=index_right);				/*jump down to sample row*/			tempfixed.frac = 0;			tempfixed.intg = FFRound(yr);			tempfixed.l += FixedPointFive.l;			tempfixed.l = tempfixed.l - yr.l;			xr.l += FFMult(dxr, tempfixed).l;			fxr.l += FFMult(fdxr, tempfixed).l;			fyr.l += FFMult(fdyr, tempfixed).l;			/*handle rounding*/			xr.l += FixedPointFive.l;			fxr.l += FixedPointFive.l;			fyr.l += FixedPointFive.l;		}	}while(notDone);endit://tpoints->Unuse();//fpoints->Unuse();if(clipper)clipper->Unuse();textureinfo->mip[0]->UnuseRaster(&savePort, &saveDevice);	// ABD MERGE23return rval;}/*---------------------------------------------------------------------------------*//*test to see if the bounding box of a polygon is trivally outside another box*/intTrivialTest(PointFFixed *screen, FFixedrect rclip, int plength);intTrivialTest(PointFFixed *screen, FFixedrect rclip, int plength){	int i;	FFixed leftmost, rightmost, topmost, bottommost;	FFixed tempfixed;		leftmost = rightmost = screen[0].h;	topmost = bottommost = screen[0].v;	for(i = 1; i < plength; i++) {		if(screen[i].h.l < leftmost.l) leftmost.l = screen[i].h.l;		else if(screen[i].h.l > rightmost.l) rightmost.l = screen[i].h.l;		if(screen[i].v.l < topmost.l) topmost.l = screen[i].v.l;		else if(screen[i].v.l > bottommost.l) bottommost.l = screen[i].v.l;	}	if(		(topmost.l >= rclip.bottom.l) ||		(bottommost.l <= rclip.top.l) ||		(leftmost.l >= rclip.right.l) ||		(rightmost.l <= rclip.left.l)	)	{		return(TRIVIALREJECT);	}	else	{		return(ACCEPT);	}}voidcliplinevertical(PointFFixed *screen, Point3DFFNoPersp *nontrans, PointFFixed *texture,			int a, int b, FFixed clipline, 		 PointFFixed *newscreen, Point3DFFNoPersp *newnontrans, PointFFixed *newtexture,		 	int outpoint);voidcliplinevertical(PointFFixed *screen, Point3DFFNoPersp *nontrans, PointFFixed *texture,			int a, int b, FFixed clipline, 		 PointFFixed *newscreen, Point3DFFNoPersp *newnontrans, PointFFixed *newtexture,		 	int outpoint){	FFixed tempfixed, tempfixed2, tempfixed3, ratio;		newscreen[outpoint].v.l = clipline.l;		tempfixed.l = clipline.l - screen[a].v.l;	ratio.l = screen[b].v.l - screen[a].v.l;	ratio = FFDiv(tempfixed, ratio);		tempfixed.l = screen[b].h.l - screen[a].h.l;	newscreen[outpoint].h.l = FFMult(tempfixed, ratio).l + screen[a].h.l;		tempfixed.l = nontrans[b].x.l - nontrans[a].x.l;	newnontrans[outpoint].x.l = FFMult(tempfixed, ratio).l + nontrans[a].x.l;	tempfixed.l = nontrans[b].y.l - nontrans[a].y.l;	newnontrans[outpoint].y.l = FFMult(tempfixed, ratio).l + nontrans[a].y.l;	tempfixed.l = nontrans[b].z.l - nontrans[a].z.l;	newnontrans[outpoint].z.l = FFMult(tempfixed, ratio).l + nontrans[a].z.l;	tempfixed.l = nontrans[b].perspecD - nontrans[a].perspecD;	newnontrans[outpoint].perspecD = FFMult(tempfixed, ratio).l + nontrans[a].perspecD;		/*want (1/w - 1/w1)/(1/w2 - 1/w1), but need to watch for overflow and	  cases where w1 is very close to w2.	  handled as (w2 - (w1w2/w))/(w2-w1)*/	if(nontrans[a].perspecD != nontrans[b].perspecD) {		tempfixed.l = 0x7fffffff;		tempfixed2.l = tempfixed.l/nontrans[a].perspecD;		tempfixed3.l = (tempfixed.l/nontrans[b].perspecD) - tempfixed2.l;		if(labs(tempfixed3.l) > 0x80) {			tempfixed2.l = (tempfixed.l/newnontrans[outpoint].perspecD) - tempfixed2.l;			ratio = FFDiv(tempfixed2, tempfixed3);		}	}		tempfixed.l = texture[b].h.l - texture[a].h.l;	newtexture[outpoint].h.l = FFMult(tempfixed, ratio).l + texture[a].h.l;	tempfixed.l = texture[b].v.l - texture[a].v.l;	newtexture[outpoint].v.l = FFMult(tempfixed, ratio).l + texture[a].v.l;	}voidcliplinehorizontal(PointFFixed *screen, Point3DFFNoPersp *nontrans, PointFFixed *texture,			int a, int b, FFixed clipline, 		 PointFFixed *newscreen, Point3DFFNoPersp *newnontrans, PointFFixed *newtexture,		 	int outpoint);voidcliplinehorizontal(PointFFixed *screen, Point3DFFNoPersp *nontrans, PointFFixed *texture,			int a, int b, FFixed clipline, 		 PointFFixed *newscreen, Point3DFFNoPersp *newnontrans, PointFFixed *newtexture,		 	int outpoint){	FFixed tempfixed, tempfixed2, tempfixed3, ratio;		newscreen[outpoint].h.l = clipline.l;		tempfixed.l = clipline.l - screen[a].h.l;	ratio.l = screen[b].h.l - screen[a].h.l;	ratio = FFDiv(tempfixed, ratio);		tempfixed.l = screen[b].v.l - screen[a].v.l;	newscreen[outpoint].v.l = FFMult(tempfixed, ratio).l + screen[a].v.l;		tempfixed.l = nontrans[b].x.l - nontrans[a].x.l;	newnontrans[outpoint].x.l = FFMult(tempfixed, ratio).l + nontrans[a].x.l;	tempfixed.l = nontrans[b].y.l - nontrans[a].y.l;	newnontrans[outpoint].y.l = FFMult(tempfixed, ratio).l + nontrans[a].y.l;	tempfixed.l = nontrans[b].z.l - nontrans[a].z.l;	newnontrans[outpoint].z.l = FFMult(tempfixed, ratio).l + nontrans[a].z.l;	tempfixed.l = nontrans[b].perspecD - nontrans[a].perspecD;	newnontrans[outpoint].perspecD = FFMult(tempfixed, ratio).l + nontrans[a].perspecD;		/*want (1/w - 1/w1)/(1/w2 - 1/w1), but need to watch for overflow and	  cases where w1 is very close to w2.	  handled as (w2 - (w1w2/w))/(w2-w1)*/	if(nontrans[a].perspecD != nontrans[b].perspecD) {		tempfixed.l = 0x7fffffff;		tempfixed2.l = tempfixed.l/nontrans[a].perspecD;		tempfixed3.l = (tempfixed.l/nontrans[b].perspecD) - tempfixed2.l;		if(labs(tempfixed3.l) > 0x80) {			tempfixed2.l = (tempfixed.l/newnontrans[outpoint].perspecD) - tempfixed2.l;			ratio = FFDiv(tempfixed2, tempfixed3);		}	}		tempfixed.l = texture[b].h.l - texture[a].h.l;	newtexture[outpoint].h.l = FFMult(tempfixed, ratio).l + texture[a].h.l;	tempfixed.l = texture[b].v.l - texture[a].v.l;	newtexture[outpoint].v.l = FFMult(tempfixed, ratio).l + texture[a].v.l;	}/*-------------------------------------------------------------------------*//*temporary array routines for use by clipping code.  Saves lots of copying*//*-------------------------------------------------------------------------*/#define NUMOFTEMPARRAYS 10int indexPFFArray;V_Array *tempPFFArray[NUMOFTEMPARRAYS] = {NULL};int indexPFFNPArray;V_Array *tempPFFNPArray[NUMOFTEMPARRAYS] = {NULL};void inittemparrays(int plength);void inittemparrays(int plength){	int i;		if(plength > tempPFFArray[0]->ALength()) {		for(i=0;i<NUMOFTEMPARRAYS;i++) {			tempPFFArray[i]->Unuse();			tempPFFArray[i]->SetLength((long)plength+8);			tempPFFArray[i]->Use();			tempPFFNPArray[i]->Unuse();			tempPFFNPArray[i]->SetLength((long)plength+8);			tempPFFNPArray[i]->Use();		}			}}PointFFixed *gettemparray2(void);PointFFixed *gettemparray2(){	indexPFFArray += 1;	if(indexPFFArray == NUMOFTEMPARRAYS) indexPFFArray = 0;	return((PointFFixed *)(tempPFFArray[indexPFFArray]->Abuse()));}Point3DFFNoPersp *gettemparray1(void);Point3DFFNoPersp *gettemparray1(){	indexPFFNPArray += 1;	if(indexPFFNPArray == NUMOFTEMPARRAYS) indexPFFNPArray = 0;	return((Point3DFFNoPersp *)(tempPFFNPArray[indexPFFNPArray]->Abuse()));}/*-------------------------------------------------------------------------*/voidTexture2DClip(Point3DFFNoPersp **nontransptr, PointFFixed **screenptr, PointFFixed **textureptr,			 int *plength, FFixed clipline, int direction);voidTexture2DClip(Point3DFFNoPersp **nontransptr, PointFFixed **screenptr, PointFFixed **textureptr,			 int *plength, FFixed clipline, int direction){	/*	Point3DFFNoPersp newnontrans[50];	PointFFixed newscreen[50];	PointFFixed newtexture[50];	*/	Point3DFFNoPersp *newnontrans = gettemparray1();	PointFFixed *newscreen = gettemparray2();	PointFFixed *newtexture = gettemparray2();	Point3DFFNoPersp *nontrans = *nontransptr;	PointFFixed *screen = *screenptr;	PointFFixed *texture = *textureptr;		int i, currentinpoint, currentoutpoint, startpoint;		if(direction == LEFT) 	{		currentinpoint = 0;		currentoutpoint = 0;		/*move around poly till we are on outside of clip*/		while((screen[currentinpoint].h.l <= clipline.l) && (currentinpoint < *plength)) {			currentinpoint++;		}		if(currentinpoint == *plength) return;		/*move around till we cross clip into inside*/		startpoint = currentinpoint;		do		{			currentinpoint = nextNum(currentinpoint, *plength);		}		while((screen[currentinpoint].h.l > clipline.l) && (currentinpoint != startpoint));		if(currentinpoint == startpoint) return;		/*get clip crossing if necessary*/		if((screen[currentinpoint].h.l != clipline.l)) {			cliplinehorizontal(screen, nontrans, texture, previousNum(currentinpoint, *plength),					 currentinpoint, clipline,					newscreen, newnontrans, newtexture, currentoutpoint);			currentoutpoint++;		}		/*copy points until we are outside clip again*/		while(screen[currentinpoint].h.l <= clipline.l) {			newscreen[currentoutpoint] = screen[currentinpoint];			newnontrans[currentoutpoint] = nontrans[currentinpoint];			newtexture[currentoutpoint] = texture[currentinpoint];				currentoutpoint++;				currentinpoint = nextNum(currentinpoint, *plength);		}			/*get last clip crossing if necessary*/		if(screen[previousNum(currentinpoint, *plength)].h.l != clipline.l) {			cliplinehorizontal(screen, nontrans, texture, currentinpoint,					 previousNum(currentinpoint, *plength), clipline,					newscreen, newnontrans, newtexture, currentoutpoint);			currentoutpoint++;		}	}	if(direction == RIGHT) 	{		currentinpoint = 0;		currentoutpoint = 0;		/*move around poly till we are on outside of clip*/		while((screen[currentinpoint].h.l >= clipline.l) && (currentinpoint < *plength)) {			currentinpoint++;		}		if(currentinpoint == *plength) return;		/*move around till we cross clip into inside*/		startpoint = currentinpoint;		do		{			currentinpoint = nextNum(currentinpoint, *plength);		}		while((screen[currentinpoint].h.l < clipline.l) && (currentinpoint != startpoint));		if(currentinpoint == startpoint) return;		/*get clip crossing if necessary*/		if((screen[currentinpoint].h.l != clipline.l)) {			cliplinehorizontal(screen, nontrans, texture, previousNum(currentinpoint, *plength),					 currentinpoint, clipline,					newscreen, newnontrans, newtexture, currentoutpoint);			currentoutpoint++;		}		/*copy points until we are outside clip again*/		while(screen[currentinpoint].h.l >= clipline.l) {			newscreen[currentoutpoint] = screen[currentinpoint];			newnontrans[currentoutpoint] = nontrans[currentinpoint];			newtexture[currentoutpoint] = texture[currentinpoint];				currentoutpoint++;				currentinpoint = nextNum(currentinpoint, *plength);		}			/*get last clip crossing if necessary*/		if(screen[previousNum(currentinpoint, *plength)].h.l != clipline.l) {			cliplinehorizontal(screen, nontrans, texture, currentinpoint,					 previousNum(currentinpoint, *plength), clipline,					newscreen, newnontrans, newtexture, currentoutpoint);			currentoutpoint++;		}	}	if(direction == UP) 	{		currentinpoint = 0;		currentoutpoint = 0;		/*move around poly till we are on outside of clip*/		while((screen[currentinpoint].v.l <= clipline.l) && (currentinpoint < *plength)) {			currentinpoint++;		}		if(currentinpoint == *plength) return;		/*move around till we cross clip into inside*/		startpoint = currentinpoint;		do		{			currentinpoint = nextNum(currentinpoint, *plength);		}		while((screen[currentinpoint].v.l > clipline.l) && (currentinpoint != startpoint));		if(currentinpoint == startpoint) return;		/*get clip crossing if necessary*/		if((screen[currentinpoint].v.l != clipline.l)) {			cliplinevertical(screen, nontrans, texture, previousNum(currentinpoint, *plength),					 currentinpoint, clipline,					newscreen, newnontrans, newtexture, currentoutpoint);			currentoutpoint++;		}		/*copy points until we are outside clip again*/		while(screen[currentinpoint].v.l <= clipline.l) {			newscreen[currentoutpoint] = screen[currentinpoint];			newnontrans[currentoutpoint] = nontrans[currentinpoint];			newtexture[currentoutpoint] = texture[currentinpoint];				currentoutpoint++;				currentinpoint = nextNum(currentinpoint, *plength);		}			/*get last clip crossing if necessary*/		if(screen[previousNum(currentinpoint, *plength)].v.l != clipline.l) {			cliplinevertical(screen, nontrans, texture, currentinpoint,					 previousNum(currentinpoint, *plength), clipline,					newscreen, newnontrans, newtexture, currentoutpoint);			currentoutpoint++;		}	}	if(direction == DOWN) 	{		currentinpoint = 0;		currentoutpoint = 0;		/*move around poly till we are on outside of clip*/		while((screen[currentinpoint].v.l >= clipline.l) && (currentinpoint < *plength)) {			currentinpoint++;		}		if(currentinpoint == *plength) return;		/*move around till we cross clip into inside*/		startpoint = currentinpoint;		do		{			currentinpoint = nextNum(currentinpoint, *plength);		}		while((screen[currentinpoint].v.l < clipline.l) && (currentinpoint != startpoint));		if(currentinpoint == startpoint) return;		/*get clip crossing if necessary*/		if((screen[currentinpoint].v.l != clipline.l)) {			cliplinevertical(screen, nontrans, texture, previousNum(currentinpoint, *plength),					 currentinpoint, clipline,					newscreen, newnontrans, newtexture, currentoutpoint);			currentoutpoint++;		}		/*copy points until we are outside clip again*/		while(screen[currentinpoint].v.l >= clipline.l) {			newscreen[currentoutpoint] = screen[currentinpoint];			newnontrans[currentoutpoint] = nontrans[currentinpoint];			newtexture[currentoutpoint] = texture[currentinpoint];				currentoutpoint++;				currentinpoint = nextNum(currentinpoint, *plength);		}			/*get last clip crossing if necessary*/		if(screen[previousNum(currentinpoint, *plength)].v.l != clipline.l) {			cliplinevertical(screen, nontrans, texture, currentinpoint,					 previousNum(currentinpoint, *plength), clipline,					newscreen, newnontrans, newtexture, currentoutpoint);			currentoutpoint++;		}	}	/*	for(i=0;i<currentoutpoint;i++) {		screen[i] = newscreen[i];		nontrans[i] = newnontrans[i];		texture[i] = newtexture[i];	}	*/	*screenptr = newscreen;	*nontransptr = newnontrans;	*textureptr = newtexture;	*plength = currentoutpoint;}/*clip the texture polygon to the visible screen, later the bounding rect of  the cliping object*/intClipToScreen(Point3DFFNoPersp **nontrans, PointFFixed **screen, PointFFixed **texture,			 int *plength, FFixedrect rclip);intClipToScreen(Point3DFFNoPersp **nontrans, PointFFixed **screen, PointFFixed **texture,			 int *plength, FFixedrect rclip){	int trivialcase;		/*test for trivial reject*/	trivialcase = TrivialTest(*screen, rclip, *plength);	if(trivialcase == TRIVIALREJECT) {			return(TRIVIALREJECT);	}	inittemparrays(*plength);		Texture2DClip(nontrans, screen, texture, plength, rclip.top, DOWN);	Texture2DClip(nontrans, screen, texture, plength, rclip.right, LEFT);	Texture2DClip(nontrans, screen, texture, plength, rclip.bottom, UP);	Texture2DClip(nontrans, screen, texture, plength, rclip.left, RIGHT);	/*clipping may have caused trival reject to be able to work*/	trivialcase = TrivialTest(*screen, rclip, *plength);	if(trivialcase == TRIVIALREJECT) {			return(TRIVIALREJECT);	}	else	{		return(ACCEPT);	}}/*given a polygon and the reciprocal of a depth value, find the intersection  of the line with that depth value and the polygon and the corresponding  texture points*/voidIntersectPolyAndDepthLine(Point3DFFNoPersp *p, PointFFixed *texture, int plength,						  long oneoverdepth,						  FFixed *screenx1, FFixed *screeny1,						  FFixed *texturex1, FFixed *texturey1,						  FFixed *screenx2, FFixed *screeny2,						  FFixed *texturex2, FFixed *texturey2);voidIntersectPolyAndDepthLine(Point3DFFNoPersp *p, PointFFixed *texture, int plength,						  long oneoverdepth,						  FFixed *screenx1, FFixed *screeny1,						  FFixed *texturex1, FFixed *texturey1,						  FFixed *screenx2, FFixed *screeny2,						  FFixed *texturex2, FFixed *texturey2){	int p1a, p1b, p2a, p2b;	FFixed tempfixed, tempfixed2, ratio, delta;		for(p1a = 0, p1b = 1;		!(((p[p1a].perspecD <= oneoverdepth) && (p[p1b].perspecD >= oneoverdepth)) ||		((p[p1a].perspecD >= oneoverdepth) && (p[p1b].perspecD <= oneoverdepth)));		p1a++, p1b++);	/*these two are slightly different in case p[0].perspecD == oneoverdepth*/	for(p2a = 0, p2b = plength-1;		!(((p[p2a].perspecD < oneoverdepth) && (p[p2b].perspecD >= oneoverdepth)) ||		((p[p2a].perspecD > oneoverdepth) && (p[p2b].perspecD <= oneoverdepth)));		p2a = p2b, p2b--);		delta.l = p[p1a].perspecD - p[p1b].perspecD;	if(delta.l != 0) {		ratio.l = oneoverdepth - p[p1b].perspecD;		ratio = FFDiv(ratio, delta);	}	else { ratio.l = 0; }		/*	screenx1->frac = 0;	screenx1->intg = p[p1b].x;	screenx1->l += (p[p1a].x - p[p1b].x)*ratio.l;	screeny1->frac = 0;	screeny1->intg = p[p1b].y;	screeny1->l += (p[p1a].y - p[p1b].y)*ratio.l;	*/	screenx1->l = p[p1a].x.l - p[p1b].x.l;	*screenx1 = FFMult(*screenx1, ratio);	screenx1->l += p[p1b].x.l;	screeny1->l = p[p1a].y.l - p[p1b].y.l;	*screeny1 = FFMult(*screeny1, ratio);	screeny1->l += p[p1b].y.l;			/*for textures, ratio along edge in non-perspected space is		(1/w - 1/w1)/(1/w2 - 1/w1)		which is the same as		w2(1 - (w1/w))/(w2 - w1)	*/	if(delta.l != 0) {		tempfixed.l = p[p1b].perspecD;		tempfixed2.l = oneoverdepth;		tempfixed = FFDiv(tempfixed, tempfixed2);		tempfixed2.intg = 1;		tempfixed2.frac = 0;		tempfixed2.l -= tempfixed.l;		tempfixed.l = p[p1a].perspecD;				ratio = FFDiv(FFMult(tempfixed, tempfixed2),delta);	}	else { ratio.l = 0; }		texturex1->l = texture[p1a].h.l - texture[p1b].h.l;	*texturex1 = FFMult(*texturex1, ratio);	texturex1->l += texture[p1b].h.l;		texturey1->l = texture[p1a].v.l - texture[p1b].v.l;	*texturey1 = FFMult(*texturey1, ratio);	texturey1->l += texture[p1b].v.l;		delta.l = p[p2a].perspecD - p[p2b].perspecD;	if(delta.l != 0) {		ratio.l = oneoverdepth - p[p2b].perspecD;		ratio = FFDiv(ratio, delta);	}	else { ratio.l = 0; }		/*	screenx2->frac = 0;	screenx2->intg = p[p2b].x;	screenx2->l += (p[p2a].x - p[p2b].x)*ratio.l;	screeny2->frac = 0;	screeny2->intg = p[p2b].y;	screeny2->l += (p[p2a].y - p[p2b].y)*ratio.l;	*/	screenx2->l = p[p2a].x.l - p[p2b].x.l;	*screenx2 = FFMult(*screenx2, ratio);	screenx2->l += p[p2b].x.l;	screeny2->l = p[p2a].y.l - p[p2b].y.l;	*screeny2 = FFMult(*screeny2, ratio);	screeny2->l += p[p2b].y.l;		/*for textures, ratio along edge in non-perspected space is		(1/w - 1/w1)/(1/w2 - 1/w1)		which is the same as		w2(1 - (w1/w))/(w2 - w1)	*/	if(delta.l != 0) {		tempfixed.l = p[p2b].perspecD;		tempfixed2.l = oneoverdepth;		tempfixed = FFDiv(tempfixed, tempfixed2);		tempfixed2.intg = 1;		tempfixed2.frac = 0;		tempfixed2.l -= tempfixed.l;		tempfixed.l = p[p2a].perspecD;				ratio = FFDiv(FFMult(tempfixed, tempfixed2),delta);	}	else { ratio.l = 0; }			texturex2->l = texture[p2a].h.l - texture[p2b].h.l;	*texturex2 = FFMult(*texturex2, ratio);	texturex2->l += texture[p2b].h.l;		texturey2->l = texture[p2a].v.l - texture[p2b].v.l;	*texturey2 = FFMult(*texturey2, ratio);	texturey2->l += texture[p2b].v.l;	}/*------------------------------------------------------------------------------------*/voidFFSwap(FFixed *a, FFixed *b);voidFFSwap(FFixed *a, FFixed *b){	long temp;		temp = a->l;	a->l = b->l;	b->l = temp;}/*------------------------------------------------------------------------------------*//*finds the bounding parallelogram to the polygon and finds the u and v texture  widths for the top (right) sides and the deltas for sweeping the table down (left)  for the greater (less than) 45 degree constant z line slopes*/voidfindtexturewidths(Point3DFFNoPersp *p, PointFFixed *texture, int plength, FFixed constdepthslope,				  short slopegreaterthan45,				  FFixed *totaldeltay, int closestindex, int furthestindex,				  FFixed *ymintexturexwidth, FFixed *ymintextureywidth,				  FFixed *ymaxtexturexwidth, FFixed *ymaxtextureywidth,				  FFixed *ymintexturexinit, FFixed *ymintextureyinit, 				  FFixed *ymaxtexturexinit, FFixed *ymaxtextureyinit);voidfindtexturewidths(Point3DFFNoPersp *p, PointFFixed *texture, int plength, FFixed constdepthslope,				  short slopegreaterthan45,				  FFixed *totaldeltay, int closestindex, int furthestindex,				  FFixed *ymintexturexwidth, FFixed *ymintextureywidth,				  FFixed *ymaxtexturexwidth, FFixed *ymaxtextureywidth,				  FFixed *ymintexturexinit, FFixed *ymintextureyinit, 				  FFixed *ymaxtexturexinit, FFixed *ymaxtextureyinit){struct PointFFixedpersp yminfurthest, yminclosest, ymaxfurthest, ymaxclosest,					    yminfurthesttexture, yminclosesttexture,					    ymaxfurthesttexture, ymaxclosesttexture;FFixed yminfurthestxnopersp, yminclosestxnopersp;FFixed ymaxfurthestxnopersp, ymaxclosestxnopersp;FFixed yminfurthesttexturex, yminfurthesttexturey;FFixed yminclosesttexturex, yminclosesttexturey;FFixed ymaxfurthesttexturex, ymaxfurthesttexturey;FFixed ymaxclosesttexturex, ymaxclosesttexturey;FFixed screenxa, screenxb, screenxc, screenxd;FFixed texturexa, texturexb, texturexc, texturexd;FFixed textureya, textureyb, textureyc, textureyd;FFixed a,b,c,d;FFixed perspec1, perspec2;FFixed screenx1, screenx2, screeny1, screeny2;FFixed texturex1, texturey1, texturex2, texturey2;FFixed ratio, tempfixed, tempfixed2, tempfixed3;int i, yminindex, ymaxindex;short p0x, p0y, t0h, t0v;if(slopegreaterthan45) {	/*find points which are largest and smallest in the vertical screen direction*/	yminindex = ymaxindex = 0;	for(i=1;i<plength;i++) {		if(p[i].y.l > p[ymaxindex].y.l) { ymaxindex = i; }		else { if(p[i].y.l < p[yminindex].y.l) { yminindex = i; } }	}	totaldeltay->l = p[ymaxindex].y.l - p[yminindex].y.l; 	/*	totaldeltay->intg = p[ymaxindex].y - p[yminindex].y; 	totaldeltay->frac = 0;	*/	/*find the screen points of the bounding parallelogram*/		/*find the screen locations of the points we will need to find widths*/	yminfurthest.perspecD = p[furthestindex].perspecD;	yminfurthest.y = p[yminindex].y;	yminfurthest.x.l = p[yminindex].y.l - p[furthestindex].y.l;	yminfurthest.x = FFMult(constdepthslope, yminfurthest.x);	yminfurthest.x.l += p[furthestindex].x.l;	yminclosest.perspecD = p[closestindex].perspecD;	yminclosest.y = p[yminindex].y;	yminclosest.x.l = p[yminindex].y.l - p[closestindex].y.l;	yminclosest.x = FFMult(constdepthslope, yminclosest.x);	yminclosest.x.l += p[closestindex].x.l;	ymaxfurthest.perspecD = p[furthestindex].perspecD;	ymaxfurthest.y = p[ymaxindex].y;	ymaxfurthest.x.l = p[ymaxindex].y.l - p[furthestindex].y.l;	ymaxfurthest.x = FFMult(constdepthslope, ymaxfurthest.x);	ymaxfurthest.x.l += p[furthestindex].x.l;	ymaxclosest.perspecD = p[closestindex].perspecD;	ymaxclosest.y = p[ymaxindex].y;	ymaxclosest.x.l = p[ymaxindex].y.l - p[closestindex].y.l;	ymaxclosest.x = FFMult(constdepthslope, ymaxclosest.x);	ymaxclosest.x.l += p[closestindex].x.l;	perspec2.l = ((p[closestindex].perspecD - p[furthestindex].perspecD)/3);	perspec1.l = p[furthestindex].perspecD + perspec2.l;	perspec2.l = p[furthestindex].perspecD + (perspec2.l *2);	IntersectPolyAndDepthLine(p, texture, plength, perspec1.l,								&screenx1, &screeny1, &texturex1, &texturey1,								&screenx2, &screeny2, &texturex2, &texturey2);	if(screeny1.l < screeny2.l) {		FFSwap(&screeny1, &screeny2);		FFSwap(&screenx1, &screenx2);		FFSwap(&texturex1, &texturex2);		FFSwap(&texturey1, &texturey2);	}	ratio.l = p[ymaxindex].y.l - screeny2.l;	tempfixed.l = screeny1.l - screeny2.l;	ratio = FFDiv(ratio, tempfixed);	texturexa.l = texturex1.l - texturex2.l;	texturexa = FFMult(texturexa, ratio);	texturexa.l += texturex2.l;	textureya.l = texturey1.l - texturey2.l;	textureya = FFMult(textureya, ratio);	textureya.l += texturey2.l;		ratio.l = p[yminindex].y.l - screeny1.l;	tempfixed.l = screeny2.l - screeny1.l;	ratio = FFDiv(ratio, tempfixed);	texturexc.l = texturex2.l - texturex1.l;	texturexc = FFMult(texturexc, ratio);	texturexc.l += texturex1.l;	textureyc.l = texturey2.l - texturey1.l;	textureyc = FFMult(textureyc, ratio);	textureyc.l += texturey1.l;		IntersectPolyAndDepthLine(p, texture, plength, perspec2.l,								&screenx1, &screeny1, &texturex1, &texturey1,								&screenx2, &screeny2, &texturex2, &texturey2);	if(screeny1.l < screeny2.l) {		FFSwap(&screeny1, &screeny2);		FFSwap(&screenx1, &screenx2);		FFSwap(&texturex1, &texturex2);		FFSwap(&texturey1, &texturey2);	}		ratio.l = p[ymaxindex].y.l - screeny2.l;	tempfixed.l = screeny1.l - screeny2.l;	ratio = FFDiv(ratio, tempfixed);	texturexb.l = texturex1.l - texturex2.l;	texturexb = FFMult(texturexb, ratio);	texturexb.l += texturex2.l;	textureyb.l = texturey1.l - texturey2.l;	textureyb = FFMult(textureyb, ratio);	textureyb.l += texturey2.l;		ratio.l = p[yminindex].y.l - screeny1.l;	tempfixed.l = screeny2.l - screeny1.l;	ratio = FFDiv(ratio, tempfixed);	texturexd.l = texturex2.l - texturex1.l;	texturexd = FFMult(texturexd, ratio);	texturexd.l += texturex1.l;	textureyd.l = texturey2.l - texturey1.l;	textureyd = FFMult(textureyd, ratio);	textureyd.l += texturey1.l;	#if 1	tempfixed.l = 0x7fffffff;	tempfixed2.l = tempfixed.l/p[closestindex].perspecD;	tempfixed3.l = (tempfixed.l/p[furthestindex].perspecD) - tempfixed2.l;	if(labs(tempfixed3.l) > 0x80) {		a.l = (tempfixed.l/perspec1.l) - tempfixed2.l;		a = FFDiv(a, tempfixed3);		b.l = (tempfixed.l/perspec2.l) - tempfixed2.l;		b = FFDiv(b, tempfixed3);	}	else {		tempfixed2.l = p[closestindex].perspecD;		tempfixed3.l = p[furthestindex].perspecD - tempfixed2.l;		a.l = perspec1.l - tempfixed2.l;		a = FFDiv(a, tempfixed3);		b.l = perspec2.l - tempfixed2.l;		b = FFDiv(b, tempfixed3);	}	tempfixed.intg = 1; 	tempfixed.frac = 0;	c.l = tempfixed.l - a.l;	d.l = tempfixed.l - b.l;	tempfixed.l = b.l - a.l;	tempfixed2.l = -tempfixed.l;	ymaxclosesttexturex = FFDiv(								FFSub(									FFMult(b, texturexa),									FFMult(a, texturexb)									),								tempfixed								);	ymaxclosesttexturey = FFDiv(								FFSub(									FFMult(b, textureya),									FFMult(a, textureyb)									),								tempfixed								);	ymaxfurthesttexturex = FFDiv(								FFSub(									FFMult(d, texturexa),									FFMult(c, texturexb)									),								tempfixed2								);	ymaxfurthesttexturey = FFDiv(								FFSub(									FFMult(d, textureya),									FFMult(c, textureyb)									),								tempfixed2								);									yminclosesttexturex = FFDiv(								FFSub(									FFMult(b, texturexc),									FFMult(a, texturexd)									),								tempfixed								);	yminclosesttexturey = FFDiv(								FFSub(									FFMult(b, textureyc),									FFMult(a, textureyd)									),								tempfixed								);	yminfurthesttexturex = FFDiv(								FFSub(									FFMult(d, texturexc),									FFMult(c, texturexd)									),								tempfixed2								);	yminfurthesttexturey = FFDiv(								FFSub(									FFMult(d, textureyc),									FFMult(c, textureyd)									),								tempfixed2								);									#endif					 		#if 0	tempfixed.l = p[furthestindex].perspecD;	a = FFDiv(tempfixed,perspec1);	a.intg -= 1;	tempfixed.l = p[closestindex].perspecD;		a = FFMult(a,tempfixed);	tempfixed.l = p[furthestindex].perspecD - p[closestindex].perspecD;	a = FFDiv(a,tempfixed);	c.l = a.l;	tempfixed.l = p[furthestindex].perspecD;	b = FFDiv(tempfixed,perspec2);	b.intg -= 1;	tempfixed.l = p[closestindex].perspecD;		b = FFMult(b,tempfixed);	tempfixed.l = p[furthestindex].perspecD - p[closestindex].perspecD;	b = FFDiv(b,tempfixed);	d.l = b.l;				ymaxfurthesttexturex = FFDiv(							FFSub(FFMult(b,texturexa),FFMult(a,texturexb)),							FFSub(b,a)						   );	ymaxclosesttexturex = FFAdd(							ymaxfurthesttexturex,							FFDiv(FFSub(texturexb, texturexa),FFSub(b,a))						  );	ymaxfurthesttexturey = FFDiv(							FFSub(FFMult(b,textureya),FFMult(a,textureyb)),							FFSub(b,a)						   );	ymaxclosesttexturey = FFAdd(							ymaxfurthesttexturey,							FFDiv(FFSub(textureyb, textureya),FFSub(b,a))						  );						  	yminfurthesttexturex = FFDiv(							FFSub(FFMult(d,texturexc),FFMult(c,texturexd)),							FFSub(d,c)						   );	yminclosesttexturex = FFAdd(							yminfurthesttexturex,							FFDiv(FFSub(texturexd, texturexc),FFSub(d,c))						  );	yminfurthesttexturey = FFDiv(							FFSub(FFMult(d,textureyc),FFMult(c,textureyd)),							FFSub(d,c)						   );	yminclosesttexturey = FFAdd(							yminfurthesttexturey,							FFDiv(FFSub(textureyd, textureyc),FFSub(d,c))						  );#endifymintexturexwidth->l = yminfurthesttexturex.l - yminclosesttexturex.l;ymintextureywidth->l = yminfurthesttexturey.l - yminclosesttexturey.l;ymaxtexturexwidth->l = ymaxfurthesttexturex.l - ymaxclosesttexturex.l;ymaxtextureywidth->l = ymaxfurthesttexturey.l - ymaxclosesttexturey.l;ymintexturexinit->l = yminclosesttexturex.l;ymintextureyinit->l = yminclosesttexturey.l;ymaxtexturexinit->l = ymaxclosesttexturex.l;ymaxtextureyinit->l = ymaxclosesttexturey.l;return;	}else {	/*find points which are largest and smallest in the horizontal screen direction*/	yminindex = ymaxindex = 0;	for(i=1;i<plength;i++) {		if(p[i].x.l < p[ymaxindex].x.l) { ymaxindex = i; }		else { if(p[i].x.l > p[yminindex].x.l) { yminindex = i; } }	}	totaldeltay->l = p[yminindex].x.l - p[ymaxindex].x.l;	/*find the screen points of the bounding parallelogram*/		/*find the screen locations of the points we will need to find widths*/	/*	yminfurthest.perspecD = p[furthestindex].perspecD;	yminfurthest.x.intg = p[yminindex].x;	yminfurthest.x.frac = 0;	yminfurthest.y.l = (p[yminindex].x - p[furthestindex].x) * constdepthslope.l;	yminfurthest.y.intg += p[furthestindex].y;	yminfurthest.z = p[furthestindex].z;	yminclosest.perspecD = p[closestindex].perspecD;	yminclosest.x.intg = p[yminindex].x;	yminclosest.x.frac = 0;	yminclosest.y.l = (p[yminindex].x - p[closestindex].x) * constdepthslope.l;	yminclosest.y.intg += p[closestindex].y;	yminclosest.z = p[closestindex].z;	ymaxfurthest.perspecD = p[furthestindex].perspecD;	ymaxfurthest.x.intg = p[ymaxindex].x;	ymaxfurthest.x.frac = 0;	ymaxfurthest.y.l = (p[ymaxindex].x - p[furthestindex].x) * constdepthslope.l;	ymaxfurthest.y.intg += p[furthestindex].y;	ymaxfurthest.z = p[furthestindex].z;	ymaxclosest.perspecD = p[closestindex].perspecD;	ymaxclosest.x.intg = p[ymaxindex].x;	ymaxclosest.x.frac = 0;	ymaxclosest.y.l = (p[ymaxindex].x - p[closestindex].x) * constdepthslope.l;	ymaxclosest.y.intg += p[closestindex].y;	ymaxclosest.z = p[closestindex].z;	*/	yminfurthest.perspecD = p[furthestindex].perspecD;	yminfurthest.x = p[yminindex].x;	yminfurthest.y.l = p[yminindex].x.l - p[furthestindex].x.l;	yminfurthest.y = FFMult(constdepthslope, yminfurthest.y);	yminfurthest.y.l += p[furthestindex].y.l;	yminclosest.perspecD = p[closestindex].perspecD;	yminclosest.x = p[yminindex].x;	yminclosest.y.l = p[yminindex].x.l - p[closestindex].x.l;	yminclosest.y = FFMult(constdepthslope, yminclosest.y);	yminclosest.y.l += p[closestindex].y.l;	ymaxfurthest.perspecD = p[furthestindex].perspecD;	ymaxfurthest.x = p[ymaxindex].x;	ymaxfurthest.y.l = p[ymaxindex].x.l - p[furthestindex].x.l;	ymaxfurthest.y = FFMult(constdepthslope, ymaxfurthest.y);	ymaxfurthest.y.l += p[furthestindex].y.l;	ymaxclosest.perspecD = p[closestindex].perspecD;	ymaxclosest.x = p[ymaxindex].x;	ymaxclosest.y.l = p[ymaxindex].x.l - p[closestindex].x.l;	ymaxclosest.y = FFMult(constdepthslope, ymaxclosest.y);	ymaxclosest.y.l += p[closestindex].y.l;	/*can probably use shifts not divide*/	perspec2.l = ((p[closestindex].perspecD - p[furthestindex].perspecD)/4);	perspec1.l = p[furthestindex].perspecD + perspec2.l;	perspec2.l = p[furthestindex].perspecD + (perspec2.l *3);	IntersectPolyAndDepthLine(p, texture, plength, perspec1.l,								&screenx1, &screeny1, &texturex1, &texturey1,								&screenx2, &screeny2, &texturex2, &texturey2);	if(screenx1.l < screenx2.l) {		FFSwap(&screeny1, &screeny2);		FFSwap(&screenx1, &screenx2);		FFSwap(&texturex1, &texturex2);		FFSwap(&texturey1, &texturey2);	}	ratio.l = p[ymaxindex].x.l - screenx2.l;	tempfixed.l = screenx1.l - screenx2.l;	ratio = FFDiv(ratio, tempfixed);	texturexa.l = texturex1.l - texturex2.l;	texturexa = FFMult(texturexa, ratio);	texturexa.l += texturex2.l;	textureya.l = texturey1.l - texturey2.l;	textureya = FFMult(textureya, ratio);	textureya.l += texturey2.l;		ratio.l = p[yminindex].x.l - screenx1.l;	tempfixed.l = screenx2.l - screenx1.l;	ratio = FFDiv(ratio, tempfixed);	texturexc.l = texturex2.l - texturex1.l;	texturexc = FFMult(texturexc, ratio);	texturexc.l += texturex1.l;	textureyc.l = texturey2.l - texturey1.l;	textureyc = FFMult(textureyc, ratio);	textureyc.l += texturey1.l;		IntersectPolyAndDepthLine(p, texture, plength, perspec2.l,								&screenx1, &screeny1, &texturex1, &texturey1,								&screenx2, &screeny2, &texturex2, &texturey2);	if(screeny1.l < screeny2.l) {		FFSwap(&screeny1, &screeny2);		FFSwap(&screenx1, &screenx2);		FFSwap(&texturex1, &texturex2);		FFSwap(&texturey1, &texturey2);	}	ratio.l = p[ymaxindex].x.l - screenx2.l;	tempfixed.l = screenx1.l - screenx2.l;	ratio = FFDiv(ratio, tempfixed);	texturexb.l = texturex1.l - texturex2.l;	texturexb = FFMult(texturexb, ratio);	texturexb.l += texturex2.l;	textureyb.l = texturey1.l - texturey2.l;	textureyb = FFMult(textureyb, ratio);	textureyb.l += texturey2.l;		ratio.l = p[yminindex].x.l - screenx1.l;	tempfixed.l = screenx2.l - screenx1.l;	ratio = FFDiv(ratio, tempfixed);	texturexd.l = texturex2.l - texturex1.l;	texturexd = FFMult(texturexd, ratio);	texturexd.l += texturex1.l;	textureyd.l = texturey2.l - texturey1.l;	textureyd = FFMult(textureyd, ratio);	textureyd.l += texturey1.l;#if 1	tempfixed.l = 0x7fffffff;	tempfixed2.l = tempfixed.l/p[closestindex].perspecD;	tempfixed3.l = (tempfixed.l/p[furthestindex].perspecD) - tempfixed2.l;	if(labs(tempfixed3.l) > 0x80) {		a.l = (tempfixed.l/perspec1.l) - tempfixed2.l;		a = FFDiv(a, tempfixed3);		b.l = (tempfixed.l/perspec2.l) - tempfixed2.l;		b = FFDiv(b, tempfixed3);	}	else {		tempfixed2.l = p[closestindex].perspecD;		tempfixed3.l = p[furthestindex].perspecD - tempfixed2.l;		a.l = perspec1.l - tempfixed2.l;		a = FFDiv(a, tempfixed3);		b.l = perspec2.l - tempfixed2.l;		b = FFDiv(b, tempfixed3);	}	tempfixed.intg = 1; 	tempfixed.frac = 0;	c.l = tempfixed.l - a.l;	d.l = tempfixed.l - b.l;	tempfixed.l = b.l - a.l;	tempfixed2.l = -tempfixed.l;	ymaxclosesttexturex = FFDiv(								FFSub(									FFMult(b, texturexa),									FFMult(a, texturexb)									),								tempfixed								);	ymaxclosesttexturey = FFDiv(								FFSub(									FFMult(b, textureya),									FFMult(a, textureyb)									),								tempfixed								);	ymaxfurthesttexturex = FFDiv(								FFSub(									FFMult(d, texturexa),									FFMult(c, texturexb)									),								tempfixed2								);	ymaxfurthesttexturey = FFDiv(								FFSub(									FFMult(d, textureya),									FFMult(c, textureyb)									),								tempfixed2								);									yminclosesttexturex = FFDiv(								FFSub(									FFMult(b, texturexc),									FFMult(a, texturexd)									),								tempfixed								);	yminclosesttexturey = FFDiv(								FFSub(									FFMult(b, textureyc),									FFMult(a, textureyd)									),								tempfixed								);	yminfurthesttexturex = FFDiv(								FFSub(									FFMult(d, texturexc),									FFMult(c, texturexd)									),								tempfixed2								);	yminfurthesttexturey = FFDiv(								FFSub(									FFMult(d, textureyc),									FFMult(c, textureyd)									),								tempfixed2								);									#endif					 		#if 0	tempfixed.l = p[furthestindex].perspecD;	a = FFDiv(tempfixed,perspec1);	a.intg -= 1;	tempfixed.l = p[closestindex].perspecD;		a = FFMult(a,tempfixed);	tempfixed.l = p[furthestindex].perspecD - p[closestindex].perspecD;	a = FFDiv(a,tempfixed);	c.l = a.l;	tempfixed.l = p[furthestindex].perspecD;	b = FFDiv(tempfixed,perspec2);	b.intg -= 1;	tempfixed.l = p[closestindex].perspecD;		b = FFMult(b,tempfixed);	tempfixed.l = p[furthestindex].perspecD - p[closestindex].perspecD;	b = FFDiv(b,tempfixed);	d.l = b.l;				ymaxfurthesttexturex = FFDiv(							FFSub(FFMult(b,texturexa),FFMult(a,texturexb)),							FFSub(b,a)						   );	ymaxclosesttexturex = FFAdd(							ymaxfurthesttexturex,							FFDiv(FFSub(texturexb, texturexa),FFSub(b,a))						  );	ymaxfurthesttexturey = FFDiv(							FFSub(FFMult(b,textureya),FFMult(a,textureyb)),							FFSub(b,a)						   );	ymaxclosesttexturey = FFAdd(							ymaxfurthesttexturey,							FFDiv(FFSub(textureyb, textureya),FFSub(b,a))						  );						  	yminfurthesttexturex = FFDiv(							FFSub(FFMult(d,texturexc),FFMult(c,texturexd)),							FFSub(d,c)						   );	yminclosesttexturex = FFAdd(							yminfurthesttexturex,							FFDiv(FFSub(texturexd, texturexc),FFSub(d,c))						  );	yminfurthesttexturey = FFDiv(							FFSub(FFMult(d,textureyc),FFMult(c,textureyd)),							FFSub(d,c)						   );	yminclosesttexturey = FFAdd(							yminfurthesttexturey,							FFDiv(FFSub(textureyd, textureyc),FFSub(d,c))						  );#endifymintexturexwidth->l = yminfurthesttexturex.l - yminclosesttexturex.l;ymintextureywidth->l = yminfurthesttexturey.l - yminclosesttexturey.l;ymaxtexturexwidth->l = ymaxfurthesttexturex.l - ymaxclosesttexturex.l;ymaxtextureywidth->l = ymaxfurthesttexturey.l - ymaxclosesttexturey.l;ymintexturexinit->l = yminclosesttexturex.l;ymintextureyinit->l = yminclosesttexturey.l;ymaxtexturexinit->l = ymaxclosesttexturex.l;ymaxtextureyinit->l = ymaxclosesttexturey.l;return;}}/*------------------------------------------------------------------------------------*/#if 1/*finds the slope of a constant depth line.  finds smallest magnitude  version of dy/dx and dx/dy, returns 1 if it's dy/dx (indicating > 45 degree slope),  and 0 otherwise*/int findslope(Point3DFFNoPersp *p, int plength, int closestindex, int furthestindex, FFixed *slope);int findslope(Point3DFFNoPersp *p, int plength, int closestindex, int furthestindex, FFixed *slope) {int p1a, p1b, p2a, p2b;FFixed f1, f2, delta, ratio;FFixed screenx1, screeny1, screenx2, screeny2;long middledepth;int shiftval;	middledepth = (p[closestindex].perspecD + p[furthestindex].perspecD)/2;	for(p1a = 0, p1b = 1;		!(((p[p1a].perspecD <= middledepth) && (p[p1b].perspecD >= middledepth)) ||		((p[p1a].perspecD >= middledepth) && (p[p1b].perspecD <= middledepth)));		p1a++, p1b++);	/*have to have slightly different loop in case middledepth = p[0].perspecD*/	for(p2a = 0, p2b = plength-1;		!(((p[p2a].perspecD < middledepth) && (p[p2b].perspecD >= middledepth)) ||		((p[p2a].perspecD > middledepth) && (p[p2b].perspecD <= middledepth)));		p2a = p2b, p2b--);		delta.l = p[p1a].perspecD - p[p1b].perspecD;	if(delta.l != 0) {//		BIT_WIDTH(labs(delta.l), shiftval);//		shiftval = 31 - shiftval;//		FFFShift(delta, shiftval);		ratio.l = middledepth - p[p1b].perspecD;//		FFFShift(ratio, shiftval);		ratio = FFDiv(ratio, delta);	}	else { ratio.l = 0; }		/*	screenx1.frac = 0;	screenx1.intg = p[p1b].x;	screenx1.l += (p[p1a].x - p[p1b].x)*ratio.l;	screeny1.frac = 0;	screeny1.intg = p[p1b].y;	screeny1.l += (p[p1a].y - p[p1b].y)*ratio.l;	*/	screenx1.l = p[p1a].x.l - p[p1b].x.l;	screenx1 = FFMult(ratio, screenx1);	screenx1.l += p[p1b].x.l;	screeny1.l = p[p1a].y.l - p[p1b].y.l;	screeny1 = FFMult(ratio, screeny1);	screeny1.l += p[p1b].y.l;		delta.l = p[p2a].perspecD - p[p2b].perspecD;	if(delta.l != 0) {//		BIT_WIDTH(labs(delta.l), shiftval);//		shiftval = 31 - shiftval;//		FFFShift(delta, shiftval);		ratio.l = middledepth - p[p2b].perspecD;//		FFFShift(ratio, shiftval);		ratio = FFDiv(ratio, delta);	}	else { ratio.l = 0; }		/*	screenx2.frac = 0;	screenx2.intg = p[p2b].x;	screenx2.l += (p[p2a].x - p[p2b].x)*ratio.l;	screeny2.frac = 0;	screeny2.intg = p[p2b].y;	screeny2.l += (p[p2a].y - p[p2b].y)*ratio.l;	*/	screenx2.l = p[p2a].x.l - p[p2b].x.l;	screenx2 = FFMult(ratio, screenx2);	screenx2.l += p[p2b].x.l;	screeny2.l = p[p2a].y.l - p[p2b].y.l;	screeny2 = FFMult(ratio, screeny2);	screeny2.l += p[p2b].y.l;		f1.l = screeny2.l - screeny1.l;	f2.l = screenx2.l - screenx1.l;	if(f1.l == 0) { slope->l = 0; return(0); }	if(f2.l == 0) { slope->l = 0; return(1); }	if(labs(f1.l) >= labs(f2.l)) {//		BIT_WIDTH(labs(f1.l), shiftval);//		shiftval = 31-shiftval;//		FFFShift(f1, shiftval);//		FFFShift(f2, shiftval);		*slope = FFDiv(f2, f1);		return(1);	}	else {//		BIT_WIDTH(labs(f2.l), shiftval);//		shiftval = 31-shiftval;//		FFFShift(f1, shiftval);//		FFFShift(f2, shiftval);		*slope = FFDiv(f1, f2);		return(0);	}}#endif/*------------------------------------------------------------------------------------*//*structure for info about bounding parallelogram*/typedef struct constdepthstruct	{	struct V_Array *texturetable;	FFixed spanend1;	FFixed spanend2;	FFixed constdepthslope;	int closestindex;	int furthestindex;	short slopegreaterthan45;	} constdepthstruct;/*------------------------------------------------------------------------------------*//*routine to create table of constant depth entries*//*might eventually alter to just find necessary data and only calculate  entries as needed*/intcreatezconsttable(struct constdepthstruct *constdepthinfo, PointFFixed *pt, PointFFixed *texture, 				  Point3DFFNoPersp *inPnt2, int);intcreatezconsttable(struct constdepthstruct *constdepthinfo, PointFFixed *pt, PointFFixed *texture,				  Point3DFFNoPersp *inPnt2, int plength){	FFixed closest, furthest;	int closestindex, furthestindex;	FFixed spanend1, spanend2, constdepthslope;	FFixed depth, deltadepth, initdepth;	FFixed oneoverdepthstep;	FFixed C1, C2, yminC2x, yminC2y, ymaxC2x, ymaxC2y, tempfixed, tempfixed2, tempfixed3;	FFixed *texturetable;	FFixed texturexwidth, textureywidth;	int i;	int oneovertotaldeltaypreshift, constshift, stepshift;	FFixed oneovertotaldeltay;	FFixed totaldeltay,		   ymintexturexwidth, ymintextureywidth,		   ymaxtexturexwidth, ymaxtextureywidth,		   ymintexturexinit, ymintextureyinit,		   ymaxtexturexinit, ymaxtextureyinit;	int index;	int tablelength;	FFixed tablelengthfixed;	unsigned long templong;	FFixed *tableptr;	#if DEBUG && MACINTOSH	long looptime, nonlooptime;	#endif	int negatedeltas;			/*first, find min and max depth and corresponding points*/	closestindex = constdepthinfo->closestindex;	furthestindex = constdepthinfo->furthestindex;	closest.l = inPnt2[closestindex].perspecD;	furthest.l = inPnt2[furthestindex].perspecD;	#if 0	/*if closest and furthest are small, shift to allow for more units between*/	/*ASSERT closest and furthest are positive and closest > furthest*/		if(closest.l < FixedPointFive.l) {		BIT_WIDTH(closest.l,i);	/*JAM change to labs in VR*/		i = 16 - i;		FFFShift(closest,i);		FFFShift(furthest,i);	}#endif	/*make closest and furthest around 1.0 for best bit accuracy*/	/*ASSERT closest and furthest are positive and closest > furthest*/		BIT_WIDTH(closest.l,i);	/*JAM change to labs in VR*/	i = 16 - i;	FFFShift(closest,i);	FFFShift(furthest,i);	if(closest.l == furthest.l) return(1);	/*find slope of lines of constant depth*/	/* dy/dx = [(bz-az)(cy-ay) - (cz-az)(by-ay)]/[(bz-az)(cx-ax) - (cz-az)(bx-ax)] */			/*find length of span from closest line to furthest line of constant depth*/	if(1 == findslope(inPnt2, plength, closestindex, furthestindex, &constdepthslope)) {		/*slope > 45 degrees, constdepthslope = dx/dy */		constdepthinfo->slopegreaterthan45 = 1;		negatedeltas = 0;		closestindex = constdepthinfo->closestindex;		furthestindex = constdepthinfo->furthestindex;		/*		spanend1.frac = 0;		spanend1.intg = inPnt2[closestindex].x;		spanend2.frac = 0;		spanend2.intg = (int)inPnt2[closestindex].y - (int)inPnt2[furthestindex].y;		spanend2 = FFMult(spanend2, constdepthslope);		spanend2.intg += (int)inPnt2[furthestindex].x;		*/		spanend1 = inPnt2[closestindex].x;		spanend2.l = inPnt2[closestindex].y.l - inPnt2[furthestindex].y.l;		spanend2 = FFMult(spanend2, constdepthslope);		spanend2.l += inPnt2[furthestindex].x.l;	}	else {		/*slope < 45 degrees, so constdepthslope = dy/dx */		constdepthinfo->slopegreaterthan45 = 0;		if(constdepthslope.l > 0) negatedeltas = 1;		else negatedeltas = 0;		closestindex = constdepthinfo->closestindex;		furthestindex = constdepthinfo->furthestindex;		/*screen y is flipped from initial post-perspected value, so flip		  spanends*/		/*		spanend1.frac = 0;		spanend1.intg = inPnt2[closestindex].y;		spanend2.frac = 0;		spanend2.intg = (int)inPnt2[closestindex].x - (int)inPnt2[furthestindex].x;		spanend2 = FFMult(spanend2, constdepthslope);		spanend2.intg += (int)inPnt2[furthestindex].y;		*/		spanend1 = inPnt2[closestindex].y;		spanend2.l = inPnt2[closestindex].x.l - inPnt2[furthestindex].x.l;		spanend2 = FFMult(spanend2, constdepthslope);		spanend2.l += inPnt2[furthestindex].y.l;	}		/*finds the u and v texture spans at the top (right) and bottom (left) of	  the bounding parallelogram for the greater (less) than 45 slope case*/	findtexturewidths(inPnt2, texture, plength, constdepthslope, 					  constdepthinfo->slopegreaterthan45,					  &totaldeltay, 					  closestindex, furthestindex,					  &ymintexturexwidth, &ymintextureywidth,					  &ymaxtexturexwidth, &ymaxtextureywidth,					  &ymintexturexinit, &ymintextureyinit, 					  &ymaxtexturexinit, &ymaxtextureyinit);		tempfixed.frac = 0;	tempfixed.intg = 2;	oneovertotaldeltaypreshift = 0;	while(tempfixed.l < totaldeltay.l)	{		oneovertotaldeltaypreshift++;		tempfixed.l <<= 1;	}	tempfixed.frac = 0;	tempfixed.intg = 1 << oneovertotaldeltaypreshift;	oneovertotaldeltay = FFDiv(tempfixed, totaldeltay);			/*fill in array*/	/*		the equation for finding the table texture point, where x is		the screen location and w is the corresponding 1/depth value,		t1 and t2 are the texture points on each side of the line, x1, w1, x2,		and w2 are the values for the screen points on each side of the line				correcttexture(x) = t1 + (t2 - t1) * (1/w - 1/w1)/(1/w2 - 1/w1)				in other words, we transform the screen point back into pre-perspective		space, and linearly interpolate there.  We must do this calculation for		both the u and v texture points for each table entry.				To calculate the texture deltas, we calculate the correct textures at		the far row, subtract, and divide by the vertical distance.				To do the calculations faster, we change the calculation to				[t1 + (-1/w1)/(1/w2 - 1/w1)] + (1/w)*(1/(1/w2 - 1/w1))				and precalculate everything except (1/w) which is what changes.	*/		if(spanend2.l > spanend1.l) {		/*special stuff to handle fractional length of table*/		tempfixed = FFSub(spanend2, spanend1);		tablelengthfixed.l = tempfixed.l;		if(tempfixed.frac != 0)			tablelength = tempfixed.intg + 2;		else			tablelength = tempfixed.intg + 1;		tempfixed.l = furthest.l - closest.l;		BIT_WIDTH(labs(tempfixed.l),stepshift);		/*31 - stepshift occasionally causes overflow because the integer		  range is greater than the fractional range (furthest pixel - closest		  pixel > fractional furthest - fractional closest).  Could get bit		  back by multiplying tempfixed by integer span/fractional span first*/		stepshift = 30 - stepshift;		FFFShift(tempfixed, stepshift);		//oneoverdepthstep.l = tempfixed.l/(tablelength-1);		if(tablelengthfixed.l != 0) {			oneoverdepthstep = FFDiv(tempfixed, tablelengthfixed);		}	}	else {		tempfixed = FFSub(spanend1, spanend2);		tablelengthfixed.l = tempfixed.l;		if(tempfixed.frac != 0)			tablelength = tempfixed.intg + 2;		else			tablelength = tempfixed.intg + 1;		tempfixed.l = closest.l - furthest.l;		BIT_WIDTH(labs(tempfixed.l),stepshift);		stepshift = 30 - stepshift;		FFFShift(tempfixed, stepshift);		//oneoverdepthstep.l = tempfixed.l/(tablelength-1);		if(tablelengthfixed.l != 0) {			oneoverdepthstep = FFDiv(tempfixed, tablelengthfixed);		}	}	tempfixed.l = 0x7fffffff;	C1.l = tempfixed.l/closest.l;	C2.l = (tempfixed.l/furthest.l) - C1.l;	/*want 1 <= C2 < 2 so FFDivs result in decent values despite large texture widths*/	BIT_WIDTH(labs(C2.l),constshift);	/*JAM change to labs in VR*/	constshift = 17 - constshift;	FFFShift(C2,constshift);	yminC2x = FFDiv(ymintexturexwidth, C2);	yminC2y = FFDiv(ymintextureywidth, C2);	ymaxC2x = FFDiv(ymaxtexturexwidth, C2);	ymaxC2y = FFDiv(ymaxtextureywidth, C2);#if DEBUG	if(((long)tablelength)*4 > constdepthinfo->texturetable->ALength()) {		DEBUGGER();		constdepthinfo->texturetable->Unuse();		constdepthinfo->texturetable->SetLength(((long)tablelength+1) * 4);		constdepthinfo->texturetable->Use();		globalvarray2->Unuse();		globalvarray2->SetLength((long)tablelength+1);		globalvarray2->Use();		globalvarray3->Unuse();		globalvarray3->SetLength((long)tablelength+1);		globalvarray3->Use();		globalvarray7->Unuse();		globalvarray7->SetLength((long)tablelength+1);		globalvarray7->Use();	}#endif	texturetable = (FFixed *)VA_Abuse(constdepthinfo->texturetable);			tableptr = &(texturetable[1]);			/*round stuff so polys look nicer*/	ymintexturexinit.l += FixedPointFive.l;	ymaxtexturexinit.l += FixedPointFive.l;	ymintextureyinit.l += FixedPointFive.l;	ymaxtextureyinit.l += FixedPointFive.l;		/*initdepth, deltadepth, and oneoverdepthstep have been manipulated to	  provide large dynamic range while preventing overflow*/	if(spanend2.l > spanend1.l) {		initdepth.l = closest.l;	}	else {		//initdepth.l = furthest.l;		initdepth.l = closest.l - ((oneoverdepthstep.l * (long)(tablelength-1)) >> stepshift);	}	deltadepth.l = 0;		for(index = 0; index < tablelength; index++) {						if((index == 0) && (spanend1.l > spanend2.l)) {				depth.l = furthest.l;			}			else if((index == tablelength-1) && (spanend2.l > spanend1.l)) {				depth.l = furthest.l;			}			else {				depth.l = initdepth.l + (deltadepth.l >> stepshift);			}			deltadepth.l += oneoverdepthstep.l;										tempfixed2.l = 0x7fffffff;			tempfixed.l = tempfixed2.l/depth.l;						tempfixed.l -= C1.l;			FFFShift(tempfixed,constshift);						tableptr->l =				FFMult(tempfixed, ymaxC2x).l + ymaxtexturexinit.l;			/*			(tableptr-1)->l =				(FFMult(tempfixed, yminC2x).l + ymintexturexinit.l) - (tableptr->l);			if(negatedeltas) {				(tableptr-1)->l = -FFMult(*(tableptr-1), oneovertotaldeltay).l;			}			else {				*(tableptr-1) = FFMult(*(tableptr-1), oneovertotaldeltay);			}			*/			tempfixed2.l = FFMult(tempfixed, yminC2x).l + ymintexturexinit.l;			if(negatedeltas) {				tempfixed2.l = -FFMult(tempfixed2, oneovertotaldeltay).l;				tempfixed3.l = -FFMult(*tableptr, oneovertotaldeltay).l;			}			else {				tempfixed2 = FFMult(tempfixed2, oneovertotaldeltay);				tempfixed3 = FFMult(*tableptr, oneovertotaldeltay);			}			(tableptr-1)->l = tempfixed2.l - tempfixed3.l;									(tableptr-1)->l >>= oneovertotaldeltaypreshift;			//tableptr->l += (tableptr-1)->l >> 1;	//because we start in middle of pixels									tableptr += 2;			tableptr->l =				FFMult(tempfixed, ymaxC2y).l + ymaxtextureyinit.l;			/*			(tableptr-1)->l =				((FFMult(tempfixed, yminC2y).l + ymintextureyinit.l) - (tableptr->l));			if(negatedeltas) {				(tableptr-1)->l = -FFMult(*(tableptr-1), oneovertotaldeltay).l;			}			else {				*(tableptr-1) = FFMult(*(tableptr-1), oneovertotaldeltay);			}			*/						tempfixed2.l = FFMult(tempfixed, yminC2y).l + ymintextureyinit.l;			if(negatedeltas) {				tempfixed2.l = -FFMult(tempfixed2, oneovertotaldeltay).l;				tempfixed3.l = -FFMult(*tableptr, oneovertotaldeltay).l;			}			else {				tempfixed2 = FFMult(tempfixed2, oneovertotaldeltay);				tempfixed3 = FFMult(*tableptr, oneovertotaldeltay);			}			(tableptr-1)->l = tempfixed2.l - tempfixed3.l;						(tableptr-1)->l >>= oneovertotaldeltaypreshift;			//tableptr->l += (tableptr-1)->l >> 1;	//because we start in middle of pixels						tableptr += 2;	}	/*pad for extra table element*/	tableptr[0].l = (tableptr-4)->l;	tableptr[1].l = (tableptr-3)->l;	tableptr[2].l = (tableptr-2)->l;	tableptr[3].l = (tableptr-1)->l;		/*	VA_Unuse(constdepthinfo->texturetable);		*/		constdepthinfo->spanend1 = spanend1;	constdepthinfo->spanend2 = spanend2;	constdepthinfo->closestindex = closestindex;	constdepthinfo->furthestindex = furthestindex;	constdepthinfo->constdepthslope = constdepthslope;					return(0);					    }/*------------------------------------------------------------------------------------*//*routine which checks to see if linear is sufficiently accurate*/intlinearisokay(Point3DFFNoPersp *p, int plength,			int closestindex, int furthestindex);intlinearisokay(Point3DFFNoPersp *p, int plength,			int closestindex, int furthestindex) {FFixed z1, z2, ratio;int screenwidth;int i;FFixed xmax, xmin, ymax, ymin;//return(1);/*need to find z1/z2, but occasionally perspecD (an unsigned long) will  cause the fixed z1 or z2 to be negative.  The preshift handles this, while  costing little, since z1.l and z2.l tend to be over 1000 at least--HACK*/z1.l = p[closestindex].perspecD >> 1;z2.l = p[furthestindex].perspecD >> 1;ratio = FFDiv(z1, z2);//if(ratio.l < LINEARTHRESHHOLD) return(0);if(ratio.intg >= 7) return(0);/*uses manhattan distance.  actual would allow linear more often*/xmax = xmin = p[0].x;ymax = ymin = p[0].x;for(i=1;i<plength;i++){	if(p[i].x.l > xmax.l) xmax.l = p[i].x.l;	else if(p[i].x.l < xmin.l) xmin.l = p[i].x.l;	if(p[i].y.l > ymax.l) ymax.l = p[i].y.l;	else if(p[i].y.l < ymin.l) ymin.l = p[i].y.l;}//screenwidth = abs(p[closestindex].x.intg - p[furthestindex].x.intg) +//			   abs(p[closestindex].y.intg - p[furthestindex].y.intg);screenwidth = (xmax.intg - xmin.intg + ymax.intg - ymin.intg) >> 1;ratio.intg--;ratio.l >>= 2;ratio.l *= screenwidth;if(ratio.intg != 0) return(0);else return(1);}unsigned char divisionlinecolor = 128;extern struct TextureServer *gTextureServer;	// ABD TEXTUREextern TextureShader gTextureShader;	// ABD TEXTURE/*------------------------------------------------------------------------------*//*		MAIN TEXTURING ROUTINE													*//*------------------------------------------------------------------------------*//*  */int Texture8(V_Offscreen *to,V_Array *fpoints,V_Array *tpoints,V_Array *nppoints,	Clip *clipper, struct TextureRendSettings *textureinfo){int plength,index_left=0,index_right, oldindexleft;Point *pt;PointFFixed *pf;Point3DNoPersp *pnp;int xOffsetTail;//#if MACINTOSHint xOffset=-to->GetXOffset();int yOffset=-to->GetYOffset();long toRowBytes=to->GetRowWidth();//#elif WINDOWS//#if !ELVIS//#error hi Greg!//#error int xOffset=-to->GetXOffset();//#error int yOffset=-to->GetYOffset();//#error long toRowBytes=to->GetRowWidth();//#endif//int xOffset=-to->GetXOffset();    // these are all zero!  jca 23 sept 93//int yOffset=-to->GetYOffset();//long toRowBytes=to->GetRowWidth();//#endif // MACINTOSH#if WINDOWSunsigned char *yBase; //windows original start of output line#endifunsigned char *y;	// pointer to start of output line, with xoffsetunsigned char *yy;  // pointer to start of span, with x coord figured in.int dylint, dxlint, odyl, odxl, dyrint, dxrint, odyr, odxr, deltay, reset;int dx;FFixed cxl, cxr, cyl, cyr;int i,j;Rect rclip, texturerect;int ytop, mostright;struct ClipStruct *clip;int clipindex;int notDone=TRUE;int rval=FALSE;FFixed xl, dxl, xr, dxr, yl, dyl, yr, dyr, fxl, fdxl, fxr, fdxr, fyl, fdyl, fyr, fdyr;FFixed tblxl;FFixed tempfixed, tempfixed2;FFixed *basexarray, *baseyarray;long *fixedpointer1, *fixedpointer2, *fixedpointer3, *fixedpointer4;short index, index2, indexold, index2old, indexN, index2N;long timetocreatetable, timetodrawshape, timetodrawline, timetodrawshapelinear;long timespentupdatingtable = 0, timespentdrawinglines = 0;int	overalldeltay = 0;int	skipdown;V_Array *V_auxarray;FFixed xdistance, tablepos, adjustment, dadjustment;int oldtableposint;int tablelength;FFixed tablelengthfixed;int mirrorh, mirrorv;V_Array *currenttablex, *currenttabley;long longmask;void (*scanfillsteep)(struct ScanLineInfo *);void (*scanfillshallow)(struct ScanLineInfo *);struct constdepthstruct constdepthinfo;int	closestindex, furthestindex, leftmostindex;int IsAPowerOfTwo;int mode;long usetimes, makebasetimes;long jumpdownandstartup = 0;long otherstartup = 0;int NumOfPixels;int BitDepthIndex;struct ScanLineInfo LineInfo;ShadeEntry *tshade;unsigned char **fromRaster;int tempint;long templong;FFixedrect ffrclip;PointFFixed *ptC, *pfC;Point3DFFNoPersp *pnpC;int FirstTimeTableEntries;VGrafPort savePort;	// ABD MERGE23VGrafDevice saveDevice;	// ABD MERGE23#if PROFILE_profile = FALSE;#endif#if DEBUG && MACINTOSHStartTimingMilli();#endifto->GetClip(&rclip);pt=(Point *)tpoints->Use();plength=tpoints->ALength();if(plength<=2) {	#if DEBUG && MACINTOSH	timetodrawshape = EndTimingMilli();	#endif	tpoints->Unuse();	if(clipper)clipper->Unuse();	return rval;}pnp=(Point3DNoPersp *)nppoints->Use();pf=(PointFFixed *)fpoints->Use();textureinfo->mip[0]->GetRect(&texturerect);fromRaster = textureinfo->mip[0]->UseRaster(&savePort, &saveDevice);	// ABD MERGE23mode=textureinfo->decal;/*make sure table arrays are big enough*//*max number of table entries used is height + width + safety fudge */templong = (long)rclip.right - (long)rclip.left + (long)rclip.bottom - (long)rclip.top + 10;if(globalvarray2->ALength() < templong) {	globalvarray1->Unuse();	globalvarray2->Unuse();	globalvarray3->Unuse();	globalvarray7->Unuse();	globalvarray1->SetLength(templong*4);	globalvarray2->SetLength(templong);	globalvarray3->SetLength(templong);	globalvarray7->SetLength(templong);	globalvarray1->Use();	globalvarray2->Use();	globalvarray3->Use();	globalvarray7->Use();}if(clipvarray1->ALength() < plength + 4) {	clipvarray1->Unuse();	clipvarray2->Unuse();	clipvarray3->Unuse();	clipvarray4->Unuse();	clipvarray1->SetLength((long)plength + 4);	clipvarray2->SetLength((long)plength + 4);	clipvarray3->SetLength((long)plength + 4);	clipvarray4->SetLength((long)plength + 4);	clipvarray1->Use();	clipvarray2->Use();	clipvarray3->Use();	clipvarray4->Use();}constdepthinfo.texturetable = globalvarray1;pnpC = (Point3DFFNoPersp *)(clipvarray1->Abuse());pfC = (PointFFixed *)(clipvarray2->Abuse());ptC = (PointFFixed *)(clipvarray3->Abuse());for(i=0;i<plength;i++) {	pnpC[i].x.intg = pnp[i].x;	pnpC[i].x.frac = 0;	pnpC[i].y.intg = pnp[i].y;	pnpC[i].y.frac = 0;	pnpC[i].z.intg = pnp[i].z;	pnpC[i].z.frac = 0;	pnpC[i].perspecD = pnp[i].perspecD;	ptC[i].h.intg = pt[i].h;	ptC[i].h.frac = 0;	ptC[i].v.intg = pt[i].v;	ptC[i].v.frac = 0;	pfC[i] = pf[i];}ffrclip.top.intg = rclip.top;ffrclip.bottom.intg = rclip.bottom;ffrclip.left.intg = rclip.left;ffrclip.right.intg = rclip.right;ffrclip.top.frac = ffrclip.bottom.frac = ffrclip.left.frac = ffrclip.right.frac = 0;if(clipper)	{	if(clipper->type)		{		clip=(ClipStruct *)clipper->Use();		}	else clipper=0;	}if(clipper) {	tempfixed.frac = 0;	tempfixed.intg = clipper->ytop;	if(tempfixed.l > ffrclip.top.l) ffrclip.top = tempfixed;	tempfixed.intg = clipper->ytop + clipper->ALength() - 1;	if(tempfixed.l < ffrclip.bottom.l) ffrclip.bottom = tempfixed;	tempfixed.intg = clipper->left;	if(tempfixed.l > ffrclip.left.l) ffrclip.left = tempfixed;	tempfixed.intg = clipper->right;	if(tempfixed.l < ffrclip.right.l) ffrclip.right = tempfixed;}if(	ClipToScreen(&pnpC, &ptC, &pfC, &plength, ffrclip) == TRIVIALREJECT  )  { goto endit; }			 /*find closest and furthest points*/	closestindex = furthestindex = 0;	for(i=1;i<plength;i++) {		if(pnpC[closestindex].perspecD < pnpC[i].perspecD) {			closestindex = i;		}		else {			if(pnpC[furthestindex].perspecD > pnpC[i].perspecD) {				furthestindex = i;			}		}	}	if(closestindex == furthestindex) {		furthestindex++;	}	constdepthinfo.closestindex = closestindex;	constdepthinfo.furthestindex = furthestindex;		/*handle cases where linear interpolation is pixel-accurate.  might make  linearisokay routine more accurate so we can do more linear cases*/if(linearisokay(pnpC, plength, closestindex, furthestindex)) {	#if DEBUG && MACINTOSH	StartTimingMicro();	#endif	rval = FFixedLinearTexture8(textureinfo, to, pfC, ptC, plength, clipper);	#if DEBUG && MACINTOSH	timetodrawshapelinear = EndTimingMicro();	#endif	goto endit;}/*uses these masks for doing tiling and mirroring*/LineInfo.horizontaltexturemask = (texturerect.right) - 1;LineInfo.verticaltexturemask = (texturerect.bottom) - 1;LineInfo.horizontalmirrormask = (texturerect.right);LineInfo.verticalmirrormask = (texturerect.bottom);LineInfo.fromRaster = fromRaster;/*check if the masks are powers of two*/if(((LineInfo.horizontalmirrormask & (LineInfo.horizontalmirrormask - 1)) == 0) &&  ((LineInfo.verticalmirrormask & (LineInfo.verticalmirrormask - 1)) == 0))  {  	IsAPowerOfTwo = 1;  }else {	IsAPowerOfTwo = 0;}if(textureinfo->hMirror) mirrorh = 1;else mirrorh = 0;if(textureinfo->vMirror) mirrorv = 1;else mirrorv = 0;/*makes the table.  see the routine.  Might be better to just find the  necessary data here (bounding parallelogram size, texture deltas, etc.),  and only do divisions to fill in the table if their actually needed--  this would be better for clipped cases*/#if DEBUG && MACINTOSHStartTimingMicro();#endifif(createzconsttable(&constdepthinfo, ptC, pfC, pnpC, plength)){	/*if this returns 1 we need to do linear*/	#if DEBUG && MACINTOSH	timetocreatetable = EndTimingMicro();	#endif	goto endit;}#if DEBUG && MACINTOSHtimetocreatetable = EndTimingMicro();#endifclosestindex = constdepthinfo.closestindex;furthestindex = constdepthinfo.furthestindex;if(constdepthinfo.spanend2.l > constdepthinfo.spanend1.l) {	tempfixed = FFSub(constdepthinfo.spanend2, constdepthinfo.spanend1);	if(tempfixed.frac != 0) tablelength = tempfixed.intg + 2;	else tablelength = tempfixed.intg + 1;}else {	tempfixed = FFSub(constdepthinfo.spanend1, constdepthinfo.spanend2);	if(tempfixed.frac != 0) tablelength = tempfixed.intg + 2;	else tablelength = tempfixed.intg + 1;}#if DEBUGif((long)tablelength*4 > globalvarray1->ALength()) DEBUGGER();#endifif((long)tablelength*4 > globalvarray1->ALength()) tablelength = globalvarray1->ALength()/4;	//FIXIT GJR083193/*flip constant z slope since we flipped y's*/constdepthinfo.constdepthslope.l = -constdepthinfo.constdepthslope.l;/*gain pointers to the table.*//*basearrays contain the table values on the bounding parallelogram on the  edge which is closest.  current table is used to track the table through  the parallelogram.  deltaarrays contain the texture steps for each table  element*/if(!(constdepthinfo.slopegreaterthan45)) {	V_auxarray = globalvarray7;	auxarray = (int *)VA_Abuse(V_auxarray);}basexarray = (FFixed *)VA_Abuse(globalvarray2);baseyarray = (FFixed *)VA_Abuse(globalvarray3);texturetable = (FFixed *)VA_Abuse(constdepthinfo.texturetable);/*handle flipping*/if(textureinfo->hFlip) {	longmask = (long)(LineInfo.horizontaltexturemask) << 16;	for(i=0;i<=(tablelength<<2);i+=4) {		texturetable[i+1].l = longmask - texturetable[i+1].l;		texturetable[i].l = -texturetable[i].l;	}}if(textureinfo->vFlip) {	longmask = (long)(LineInfo.verticaltexturemask) << 16;	for(i=2;i<=(tablelength<<2)+2;i+=4) {		texturetable[i+1].l = longmask - texturetable[i+1].l;		texturetable[i].l = -texturetable[i].l;	}}/*select correct bit depth based on to raster*/switch (to->bitDepth)	{#if MACINTOSHcase	1:		BitDepthId = BITDEPTHID1;		BitDepthIndex = BITDEPTHINDEX1;		break;case	2:		BitDepthId = BITDEPTHID2;		BitDepthIndex = BITDEPTHINDEX2;		break;#endifcase	4:		BitDepthId = BITDEPTHID4;		BitDepthIndex = BITDEPTHINDEX4;#if WINDOWS		if(to->wBmPlanes == 4)			{			BitDepthId = BITDEPTHID4X1;			BitDepthIndex = BITDEPTHINDEX4X1;			}#endif //WINDOWS		break;case	8:		BitDepthId = BITDEPTHID8;		BitDepthIndex = BITDEPTHINDEX8;		break;case	16:		BitDepthId = BITDEPTHID16;		BitDepthIndex = BITDEPTHINDEX16;		break;#if WINDOWScase	24:		BitDepthId = BITDEPTHID24;		BitDepthIndex = BITDEPTHINDEX24;		break;#endif //WINDOWScase	32:		BitDepthId = BITDEPTHID32;		BitDepthIndex = BITDEPTHINDEX32;		break;default: DEBUGGER();return (rval);	}/*used to keep track of where we are in the parallelogram for > 45 degree cases*/overalldeltay = 0;tshade = textureinfo->textureShade;/*two cases:  slope >= 45 and slope <= 45.  Experiment suggests it might be better  to split at a different point, e.g. 30 degrees, since the > 45 degree case seems  somewhat faster.  Might not be true after optimization*/  /*SLOPE GREATER THAN 45 DEGREES*//*ALGORITHMWe have a bounding parallelogram of the polygon where two of the parallelogram sidesare lines of constant z and two are horizontal linesWe have two table which contains one entry per horizontal pixel of the boundingparallelogram.  Those tables contain the correct texture points (u and v) for eachhorizontal pixel at the horizontal line which is closest to the viewer.We have two other tables, which contains the stepwise change of each of the abovetables as we move down the parallelogram in screen space.We draw as if we were sweeping the table down from the top of screen space to thebottom, doing actual drawing (and hopefully actual work) only where the polygonactually exists inside the bounding parallelogram.*/if(constdepthinfo.slopegreaterthan45) {for(i=1;i<plength;i++)	{	if(ptC[index_left].v.l>ptC[i].v.l)index_left=i;	}	/*make the base array*/{	long *longptr1, *longptr2, *longptr3;	longptr1 = (long *)basexarray;	longptr2 = (long *)baseyarray;	longptr3 = (long *)texturetable;	longptr3++;	for(i=0;i<=tablelength;i++) {		*(longptr1++) = *longptr3;		longptr3+= 2;		*(longptr2++) = *longptr3;		longptr3+= 2;	//		basexarray[i].l = texturetable[(i<<2)+1].l;//		baseyarray[i].l = texturetable[(i<<2)+3].l;	}}/*set the proper scanfill routine*/if(textureinfo->vMirror) i = 1;else i = 0;if(textureinfo->hMirror) i |= 2;if(textureinfo->decal)  i |= 4;if(IsAPowerOfTwo) i |= 8;scanfillsteep = ScanFillSteepSlope[i][BitDepthIndex];index_right=index_left;j=0;while(FFRound(ptC[index_left].v)==FFRound(ptC[i=previousNum(index_left,plength)].v) && ++j<plength)index_left=i;if(j==plength)goto endit;j=0;while(FFRound(ptC[index_right].v)==FFRound(ptC[i=nextNum(index_right,plength)].v) && ++j<plength)index_right=i;if(j==plength)goto endit;/*the TO points */xl = ptC[index_left].h;yl = ptC[index_left].v;xr = ptC[index_right].h;yr = ptC[index_right].v;/*the table left side points*//*follows the left side of the bounding parallelogram down the near*/tblxl = ptC[constdepthinfo.closestindex].h;tempfixed.l = ptC[index_left].v.l - ptC[constdepthinfo.closestindex].v.l;tblxl.l += FFMult(tempfixed, constdepthinfo.constdepthslope).l;/*the FROM points */index_left=previousNum(index_left,plength);index_right=nextNum(index_right,plength);//ytop=yl.intg;ytop = FFRound(yl);rval=TRUE;switch(BitDepthId) {	case BITDEPTHID4X1:	case BITDEPTHID1:		xOffsetTail = xOffset & 7;		xOffset >>= 3;		break;	case BITDEPTHID2:		xOffsetTail = xOffset & 3;		xOffset >>= 2;		break;	case BITDEPTHID4:		xOffsetTail = xOffset & 1;		xOffset >>= 1;		break;	case BITDEPTHID8:		xOffsetTail = 0;		break;	case BITDEPTHID16:		xOffsetTail = 0;		xOffset <<= 1;		break;	case BITDEPTHID24:		xOffsetTail = 0;		xOffset += xOffset+xOffset;		break;	case BITDEPTHID32:		xOffsetTail = 0;		xOffset <<= 2;		break;		}#if MACINTOSH                    	//GJR 10/13/93y=(unsigned char *)to->GetBaseAddr() + ((yOffset+ytop)*toRowBytes) + xOffset;#elif WINDOWS// Modify to convert linear lpl to segment adjusted lpl //GJR 10/29/93yBase = to->lpbBmRowAddresses[yOffset+ytop];y     = yBase + xOffset;#endiftempfixed.l = ptC[index_left].v.l - yl.l;dxl.l = ptC[index_left].h.l - xl.l;dxl = FFDiv(dxl, tempfixed);tempfixed.l = ptC[index_right].v.l - yr.l;dxr.l = ptC[index_right].h.l - xr.l;dxr = FFDiv(dxr, tempfixed);/*handle vertical rounding*//*jump down to sample row*/tempfixed.frac = 0;tempfixed.intg = FFRound(yl);tempfixed.l += FixedPointFive.l;tempfixed.l = tempfixed.l - yl.l;xl.l += FFMult(dxl, tempfixed).l;tblxl.l += FFMult(constdepthinfo.constdepthslope, tempfixed).l;tempfixed.frac = 0;tempfixed.intg = FFRound(yr);tempfixed.l += FixedPointFive.l;tempfixed.l = tempfixed.l - yr.l;xr.l += FFMult(dxr, tempfixed).l;dylint = FFRound(ptC[index_left].v) - FFRound(yl);dyrint = FFRound(ptC[index_right].v) - FFRound(yr);/*find table entries we already need*//*we are trying to ignore table entries till we need them, then 'jump' them down  from the edge of the parallelogram to where they first appear on the polygon.  It may be the case that we start out using some right away, and we need to  copy these from the base (parallelogram-edge) array into the tracking array*/if(clipper) {#if DEBUG	if(FFRound(yl) < clipper->ytop) DEBUGGER();#endif	if(FFRound(yl) > clipper->ytop) {		clipindex = FFRound(yl) - clipper->ytop;	}	else {		clipindex = 0;	}}FirstTimeTableEntries = TRUE;do	{	if(index_left==index_right)notDone=FALSE;	if(dylint < dyrint)		{		deltay=dylint;		reset=1;		dyrint-=dylint;		dylint =0;		}	else if(dyrint < dylint)		{		deltay=dyrint;		reset=2;		dylint-=dyrint;		dyrint=0;		}	else		{		deltay=dyrint;		reset=3;		dylint=dyrint=0;		} 	while(deltay--)		{			short fx, fy;			FFixed xpos;			unsigned char *dith1, *dith2;		/*for the new table elements we are about to use, jump them down from the base		  table.  We need to retain a base table because weird window-clipping		  creates situations in which at least one table entry is used, then not		  used, then used, and then not used.*/			/*find the new range of table elements that will be used*/			cxl = xl;			cxr = xr;			if(clipper)				{				tempfixed.frac = 0;				tempfixed.intg = clip[clipindex].right;				if(tempfixed.l > ffrclip.right.l) tempfixed = ffrclip.right;				if (cxr.l > tempfixed.l) cxr.l = tempfixed.l;				tempfixed.frac = 0;				tempfixed.intg = clip[clipindex].left;				if(tempfixed.l < ffrclip.left.l) tempfixed = ffrclip.left;				if (cxl.l < tempfixed.l) cxl.l = tempfixed.l;			}				if(constdepthinfo.spanend1.l < constdepthinfo.spanend2.l) {				tempfixed.l = cxl.l - tblxl.l + FixedPointFive.l;				index = tempfixed.intg;			}			else {				tempfixed.l = tblxl.l - cxl.l + FixedPointFive.l;				index = tablelength - tempfixed.intg;			}			tempfixed.l = cxl.l + FixedPointFive.l;			tempfixed2.l = cxr.l + FixedPointFive.l;			index2 = index + tempfixed2.intg - tempfixed.intg - 1;			if(index < 0) index = 0;			if(index > tablelength) index = tablelength;			if(index2 <0) index2 = 0;			if(index2 >tablelength) index2 = tablelength;				if(index2 >= index) {				/*calculate necessary table elements.  Either add to ends or do			  all if it is first time*/			if(FirstTimeTableEntries == TRUE) {			/*calculate new elements*/				for(i=index; i <= index2; i++) {					texturetable[(i<<2)+1].l = overalldeltay * texturetable[i<<2].l +												basexarray[i].l;					texturetable[(i<<2)+3].l = overalldeltay * texturetable[(i<<2)+2].l +												baseyarray[i].l;								}				FirstTimeTableEntries = FALSE;			}						else {			/*calculate new elements on right end*/				for(i=index2; i > index2old; i--) {					texturetable[(i<<2)+1].l = overalldeltay * texturetable[i<<2].l +												basexarray[i].l;					texturetable[(i<<2)+3].l = overalldeltay * texturetable[(i<<2)+2].l +												baseyarray[i].l;								}				/*calculate new elements on left end*/				for(i=index; i < indexold; i++) {					texturetable[(i<<2)+1].l = overalldeltay * texturetable[i<<2].l +												basexarray[i].l;					texturetable[(i<<2)+3].l = overalldeltay * texturetable[(i<<2)+2].l +												baseyarray[i].l;								}			}					/*where we actually start drawing on the screen*/			tempfixed.l = cxl.l + FixedPointFive.l;			tempfixed.intg += xOffsetTail;			switch(BitDepthId) {				case BITDEPTHID1:					yy = y + (tempfixed.intg >> 3);					InitialMaskIndex = tempfixed.intg & 7;					break;				case BITDEPTHID2:					yy = y + (tempfixed.intg >> 2);					InitialMaskIndex = tempfixed.intg & 3;					break;				case BITDEPTHID4:					yy = y + (tempfixed.intg >> 1);					InitialMaskIndex = tempfixed.intg & 1;					break;				case BITDEPTHID8: 					yy = y + tempfixed.intg;					InitialMaskIndex = 0;					break;				case BITDEPTHID16:					yy = y + (tempfixed.intg << 1);					InitialMaskIndex = 0;					break;				case BITDEPTHID24:					yy = y + (tempfixed.intg + tempfixed.intg + tempfixed.intg);					break;				case BITDEPTHID32:					yy = y + (tempfixed.intg << 2);					InitialMaskIndex = 0;					break;#if WINDOWS				case BITDEPTHID4X1://					LineInfo.yy0 = y + (tempfixed.intg >> 3);					LineInfo.yy0 = to->lpbBmRowAddresses[ytop+to->yOffset];                    LineInfo.yy0 += (tempfixed.intg + to->xOffset)>>3;					LineInfo.offset4x1 = gwBmWidthBytes;					InitialMaskIndex = tempfixed.intg & 7;					yy = y;					break;#endif //WINDOWS			}					if(BitDepthId <= BITDEPTHID8) {			if(ytop & 1) {				LineInfo.dith1 = tshade->dith[BitDepthId][2];				LineInfo.dith2 = tshade->dith[BitDepthId][3];			}			else {				LineInfo.dith1 = tshade->dith[BitDepthId][0];				LineInfo.dith2 = tshade->dith[BitDepthId][1];			}		}        else {			if(BitDepthId == BITDEPTHID32) {				LineInfo.dith1 = (unsigned char *)(tshade->truecolor);			}			if(BitDepthId == BITDEPTHID24) {				LineInfo.dith1 = (unsigned char *)(tshade->color24bit);			}			if(BitDepthId == BITDEPTHID16) {				LineInfo.dith1 = (unsigned char *)(tshade->color16bit);			}			if(BitDepthId == BITDEPTHID4X1) {				if(ytop & 1)				LineInfo.longptr = (unsigned long *) (tshade->color4x1[0]);                else				LineInfo.longptr =(unsigned long *) (tshade->color4x1[1]);			}		}			/*scanline drawing loop.  this is innermost loop*/				#if DEBUG && MACINTOSH			if(yy < y) DEBUGGER();			i = index2 - index + 1 + InitialMaskIndex;			switch(BitDepthId) {				case BITDEPTHID1:					if((i & 7) != 0) i = (i>>3) + 1;					else i >>= 3;					if(yy + i > y + toRowBytes) DEBUGGER();					break;				case BITDEPTHID2:					if((i & 3) != 0) i = (i>>2) + 1;					else i >>= 2;					if(yy + i > y + toRowBytes) DEBUGGER();					break;				case BITDEPTHID4:					if((i & 1) != 0) i = (i>>1) + 1;					else i >>= 1;					if(yy + i > y + toRowBytes) DEBUGGER();					break;				case BITDEPTHID8: 					if(yy + i > y + toRowBytes) DEBUGGER();					break;				case BITDEPTHID16:					if(yy + (i<<1) > y + toRowBytes) DEBUGGER();					break;				case BITDEPTHID24:					if(yy + (i+i+i) > y + toRowBytes) DEBUGGER();					break;				case BITDEPTHID32:					if(yy + (i<<2) > y + toRowBytes) DEBUGGER();					break;			}		#endif		#if WINDOWS// Modify to convert linear yy to segment adjusted yy //GJR 10/29/93if (SPANNEDHUGE(yBase, yy))  // Segment Adjust	//GJR 10/29/93	{ char huge* hugepc  = yBase;				 hugepc += FP_OFF(yy) - FP_OFF(yBase);				 yy      = (UCharPtr)hugepc;    }#endif		LineInfo.yy = yy;		LineInfo.index = index;		LineInfo.index2 = index2;				(*scanfillsteep)(&LineInfo);	}		clipindex++;		overalldeltay++;			index2old = index2;		indexold = index;			  						/*advance to next scanline.  go down sides of poly*/				xl.l += dxl.l;				xr.l += dxr.l;							/*go down side of bounding parallelogram*/			tblxl.l += constdepthinfo.constdepthslope.l;											/*advance to next screen line*///				y+=toRowBytes;				ytop++;		if(ytop>=rclip.bottom)goto endit;  	// limit before usage      	//GJR 10/29/93#if MACINTOSH                    	//GJR 10/13/93				y+=toRowBytes;#elif WINDOWS// Prepare to convert linear yy to segment adjusted yy //GJR 10/20/93		yBase = to->lpbBmRowAddresses[yOffset+ytop];		y     = yBase + xOffset;#endif		}	if(reset&1)		{		yl = ptC[index_left].v;		xl = ptC[index_left].h;		do	{			index_left=previousNum(index_left,plength);			dylint = FFRound(ptC[index_left].v) - FFRound(yl);						tempfixed.l = ptC[index_left].v.l - yl.l;			dxl.l = ptC[index_left].h.l - xl.l;			dxl = FFDiv(dxl, tempfixed);			}while(FFRound(yl)>FFRound(ptC[index_left].v) && notDone && index_left!=index_right);		tempfixed.frac = 0;		tempfixed.intg = FFRound(yl);		tempfixed.l += FixedPointFive.l;		tempfixed.l = tempfixed.l - yl.l;		xl.l += FFMult(dxl, tempfixed).l;		}	if((reset&2) && index_left != index_right)		{		yr = ptC[index_right].v;		xr = ptC[index_right].h;		do	{			index_right=nextNum(index_right,plength);			dyrint = FFRound(ptC[index_right].v) - FFRound(yr);						tempfixed.l = ptC[index_right].v.l - yr.l;			dxr.l = ptC[index_right].h.l - xr.l;			dxr = FFDiv(dxr, tempfixed);			}while(FFRound(yr)>FFRound(ptC[index_right].v) && notDone && index_left!=index_right);			tempfixed.frac = 0;		tempfixed.intg = FFRound(yr);		tempfixed.l += FixedPointFive.l;		tempfixed.l = tempfixed.l - yr.l;		xr.l += FFMult(dxr, tempfixed).l;		}	}while(notDone);}/*SLOPE LESS THAN 45 DEGREES*//*ALGORITHMThe bounding parallelogram has two side which are lines of constant z and two whichare VERTICAL linesone table entry per VERTICAL pixel width of bounding parallelogram.We can say the drawing is done as if the bounding parallelogram is filled bydrawing each table entry along its line ofconstant z from the close side of the parallelogram to the far side of the parallelogram,with actual work done only when we are inside the polygon.To convert to a scanline algorithm, we actually draw across a scanline, drawingthe portions of the lines of constant z which are in that scanline.As we go across a scanline, we change from one table entry to the next (keepingtrack of a fractional table position), butusually we pick that table entry up right where it left off from drawing theprevious scanline.We have an auxilliary table which keeps track of where each table entry isalong its line of constant z, so when we switch from one table entry to thenext, we know if we can just pick up or if some adjustment is required.Since we are essentially doing line-tracking, we know that the number of timeseach table entry is used will differ by at most one (e.g. 4-4-5-4-4-5-4-4-5),so we could avoid a check-per-pixel to see if a new table entry is crossed, onlydoing a check per x (4 in the example) pixels.we could generalize this form of the algorithm to handle all cases, and use tableswhich have fewer than one entry per pixel (e.g. use pixel distance between linesof constant z)*/else {/*don't need a base table for this method, since we keep track of each line*//*find leftmost point and top point*/leftmostindex = 0;for(i=1;i<plength;i++)	{	if(ptC[index_left].v.l>ptC[i].v.l)index_left=i;	if(ptC[i].h.l < ptC[leftmostindex].h.l) leftmostindex = i;	}/*set the proper scanfill routine*/if(textureinfo->vMirror) i = 1;else i = 0;if(textureinfo->hMirror) i |= 2;if(textureinfo->decal)  i |= 4;if(IsAPowerOfTwo) i |= 8;scanfillshallow = ScanFillShallowSlope[i][BitDepthIndex];index_right=index_left;j=0;while(FFRound(ptC[index_left].v)==FFRound(ptC[i=previousNum(index_left,plength)].v) && ++j<plength)index_left=i;if(j==plength)goto endit;j=0;while(FFRound(ptC[index_right].v)==FFRound(ptC[i=nextNum(index_right,plength)].v) && ++j<plength)index_right=i;if(j==plength)goto endit;/*"adjustment" allows us to find the table element on which we start the scanline.  if the poly edge were vertical, dajustment would be one, since one scanline down  would be one table entry.  Since the poly edge ususally isn't vertical, this change  is not so regular.  If a poly edge tracks a constant z line, then the same table  entry starts each scanline*/if(constdepthinfo.spanend1.l < constdepthinfo.spanend2.l) {	tablelengthfixed = FFSub(constdepthinfo.spanend2, constdepthinfo.spanend1);	if(pnpC[index_left].perspecD == pnpC[closestindex].perspecD) {		adjustment.l = 0;	}	else {		adjustment.l = ptC[index_left].h.l - ptC[closestindex].h.l;		adjustment = FFMult(constdepthinfo.constdepthslope, adjustment);		adjustment.l += ptC[closestindex].v.l - ptC[index_left].v.l;		}	}else {	tablelengthfixed = FFSub(constdepthinfo.spanend1, constdepthinfo.spanend2);	if(pnpC[index_left].perspecD == pnpC[closestindex].perspecD) {		adjustment.frac = 0; adjustment.intg = tablelength-1;	}	else {		adjustment.l = ptC[index_left].h.l - ptC[closestindex].h.l;		adjustment = FFMult(constdepthinfo.constdepthslope, adjustment);		adjustment.l += ptC[closestindex].v.l - ptC[index_left].v.l;		tempfixed.intg = tablelength-1;		tempfixed.frac = 0;		adjustment.l = tempfixed.l + adjustment.l;		}	}/*the TO points */xl = ptC[index_left].h;yl = ptC[index_left].v;xr = ptC[index_right].h;yr = ptC[index_right].v;index_left=previousNum(index_left,plength);index_right=nextNum(index_right,plength);//ytop=yl.intg;ytop = FFRound(yl);rval=TRUE;switch(BitDepthId) {	case BITDEPTHID4X1:	case BITDEPTHID1:		xOffsetTail = xOffset & 7;		xOffset >>= 3;		break;	case BITDEPTHID2:		xOffsetTail = xOffset & 3;		xOffset >>= 2;		break;	case BITDEPTHID4:		xOffsetTail = xOffset & 1;		xOffset >>= 1;		break;	case BITDEPTHID8:		xOffsetTail = 0;		break;	case BITDEPTHID16:		xOffsetTail = 0;		xOffset <<= 1;		break;	case BITDEPTHID24:		xOffsetTail = 0;		xOffset += xOffset + xOffset;		break;	case BITDEPTHID32:		xOffsetTail = 0;		xOffset <<= 2;		break;}#if MACINTOSH                    	//GJR 10/13/93y=(unsigned char *)to->GetBaseAddr() + ((yOffset+ytop)*toRowBytes) + xOffset;#elif WINDOWS// Modify to convert linear lpl to segment adjusted lpl //GJR 10/29/93yBase = to->lpbBmRowAddresses[yOffset+ytop];y     = yBase + xOffset;#endifdylint = FFRound(ptC[index_left].v) - FFRound(yl);dyrint = FFRound(ptC[index_right].v) - FFRound(yr);tempfixed.l = ptC[index_left].v.l - yl.l;dxl.l = ptC[index_left].h.l - xl.l;dxl = FFDiv(dxl, tempfixed);tempfixed.l = ptC[index_right].v.l - yr.l;dxr.l = ptC[index_right].h.l - xr.l;dxr = FFDiv(dxr, tempfixed);if(clipper) {#if DEBUG	if(FFRound(yl) < clipper->ytop) DEBUGGER();#endif	if(FFRound(yl) > clipper->ytop) {		clipindex = FFRound(yl) - clipper->ytop;	}	else {		clipindex = 0;	}}/*adjustment above was for finding the starting table entry at the starting point  dadjustment is found by finding what the adjustment will be when we get to the  next polygon corner and then dividing by the vertical distance*/if(constdepthinfo.spanend1.l < constdepthinfo.spanend2.l) {	if(pnpC[index_left].perspecD == pnpC[closestindex].perspecD) {		dadjustment.l = 0;	}	else {		dadjustment.l = ptC[index_left].h.l - ptC[closestindex].h.l;		dadjustment = FFMult(constdepthinfo.constdepthslope, dadjustment);		dadjustment.l += ptC[closestindex].v.l - ptC[index_left].v.l;		}	dadjustment.l -= adjustment.l;	tempfixed.l = ptC[index_left].v.l - ptC[nextNum(index_left, plength)].v.l;	if(tempfixed.intg != 0) {		dadjustment = FFDiv(dadjustment, tempfixed);	}}else {	if(pnpC[index_left].perspecD == pnpC[closestindex].perspecD) {		dadjustment.frac = 0; dadjustment.intg = tablelength-1;	}	else {		dadjustment.l = ptC[index_left].h.l - ptC[closestindex].h.l;		dadjustment = FFMult(constdepthinfo.constdepthslope, dadjustment);		dadjustment.l += ptC[closestindex].v.l - ptC[index_left].v.l;		tempfixed.intg = tablelength-1;		tempfixed.frac = 0;		dadjustment.l = tempfixed.l + dadjustment.l;		}	dadjustment.l -= adjustment.l;	tempfixed.l = ptC[index_left].v.l - ptC[nextNum(index_left, plength)].v.l;	if(tempfixed.intg != 0) {		dadjustment = FFDiv(dadjustment, tempfixed);	}}/*handle vertical rounding*//*jump down to sample row*/tempfixed.frac = 0;tempfixed.intg = FFRound(yl);tempfixed.l += FixedPointFive.l;tempfixed.l = tempfixed.l - yl.l;xl.l += FFMult(dxl, tempfixed).l;adjustment.l += FFMult(dadjustment, tempfixed).l;tempfixed.frac = 0;tempfixed.intg = FFRound(yr);tempfixed.l += FixedPointFive.l;tempfixed.l = tempfixed.l - yr.l;xr.l += FFMult(dxr, tempfixed).l;/*fill in the auxilliary array for keeping track of where we are in drawing each  table entry's line of constant z with 0's to indicate we are at the beginning of  each line*//*if(constdepthinfo.spanend1.l > constdepthinfo.spanend2.l){	FFixed ff_temp = FFSub(constdepthinfo.spanend1, constdepthinfo.spanend2);	i =ff_temp.intg;}else{	FFixed ff_temp = FFSub(constdepthinfo.spanend2, constdepthinfo.spanend1);	i = ff_temp.intg;}	for(;i>=0;i--) {auxarray[i] = 0;} */for(i=0;i<=tablelength;i++) { auxarray[i] = 0; }overalldeltay = 0;do	{	if(index_left==index_right)notDone=FALSE;	if(dylint < dyrint)		{		deltay=dylint;		reset=1;		dyrint-=dylint;		dylint =0;		}	else if(dyrint < dylint)		{		deltay=dyrint;		reset=2;		dylint-=dyrint;		dyrint=0;		}	else		{		deltay=dyrint;		reset=3;		dylint=dyrint=0;		}/****this is the slope less than 45 degrees half****/	while(deltay--)		{			short fx, fy;			FFixed xpos;			unsigned char *dith1, *dith2;			cxl = xl;			cxr = xr;			if(clipper)				{				tempfixed.frac = 0;				tempfixed.intg = clip[clipindex].right;				if(tempfixed.l > ffrclip.right.l) tempfixed = ffrclip.right;				if (cxr.l > tempfixed.l) cxr.l = tempfixed.l;				tempfixed.frac = 0;				tempfixed.intg = clip[clipindex].left;				if(tempfixed.l < ffrclip.left.l) tempfixed = ffrclip.left;				if (cxl.l < tempfixed.l) cxl.l = tempfixed.l;			}			if(cxr.l >= cxl.l)			{				/*find the table entry on the right side of the polygon*/				xdistance.l = cxl.l;				xdistance.l -= ptC[leftmostindex].h.l;				xdistance.l += FixedPointFive.l;				tablepos.l = adjustment.l;				if(xl.l < cxl.l) {					tempfixed.l = cxl.l - xl.l;					tablepos.l += FFMult(tempfixed, constdepthinfo.constdepthslope).l;				}				tempfixed.frac = 0;				tempfixed.intg = FFRound(cxl);				tempfixed.l = cxl.l - tempfixed.l;				tablepos.l -= FFMult(tempfixed, constdepthinfo.constdepthslope).l;								tablepos.l += FixedPointFive.l;				/*boundary check*/				if(tablepos.intg <0) {					tablepos.l = 0;				}				if(tablepos.intg > tablelength) {					tablepos.intg = tablelength;					tablepos.frac = 0;				}								/*check to make sure tablepos will stay inside legal range*/				tempfixed.l = cxl.l + FixedPointFive.l;				tempfixed2.l = cxr.l + FixedPointFive.l;				NumOfPixels = tempfixed2.intg - tempfixed.intg;						if(NumOfPixels > 0) {							tempfixed.l = tablepos.l +					((NumOfPixels-1) * constdepthinfo.constdepthslope.l);				if(tempfixed.intg > tablelength) {					do {						cxr.intg--;						tempfixed.l -= constdepthinfo.constdepthslope.l;					} while (tempfixed.intg > tablelength);				}				if(tempfixed.intg < 0) {					do {						cxr.intg--;						tempfixed.l -= constdepthinfo.constdepthslope.l;					} while (tempfixed.intg < 0);				}				if(cxl.l <= cxr.l) {				/*if our starting table entry hasn't been draw to this point, alter				  it so it may start as if it has been drawn to this point*/				tempfixed.l = cxl.l + FixedPointFive.l;				tempfixed2.l = cxr.l + FixedPointFive.l;				NumOfPixels = tempfixed2.intg - tempfixed.intg;				if(constdepthinfo.constdepthslope.l >= 0) {					tempfixed.l = cxl.l + FixedPointFive.l;					tempfixed.intg += xOffsetTail;					switch(BitDepthId) {						case BITDEPTHID1:							yy = y + (tempfixed.intg >> 3);							InitialMaskIndex = tempfixed.intg & 7;							break;						case BITDEPTHID2:							yy = y + (tempfixed.intg >> 2);							InitialMaskIndex = tempfixed.intg & 3;							break;						case BITDEPTHID4:							yy = y + (tempfixed.intg >> 1);							InitialMaskIndex = tempfixed.intg & 1;							break;						case BITDEPTHID8: 							yy = y + tempfixed.intg;							InitialMaskIndex = 0;							break;						case BITDEPTHID16:							yy = y + (tempfixed.intg << 1);							InitialMaskIndex = 0;							break;						case BITDEPTHID24:							yy = y + (tempfixed.intg + tempfixed.intg + tempfixed.intg);                            InitialMaskIndex = 0;							break;						case BITDEPTHID32:							yy = y + (tempfixed.intg << 2);							InitialMaskIndex = 0;							break;#if WINDOWS						case BITDEPTHID4X1:		//					LineInfo.yy0 = y + (tempfixed.intg >> 3);							LineInfo.yy0 = to->lpbBmRowAddresses[ytop+to->yOffset];                		    LineInfo.yy0 += (tempfixed.intg + to->xOffset)>>3;							LineInfo.offset4x1 = gwBmWidthBytes;							InitialMaskIndex = tempfixed.intg & 7;							yy = y;							break;#endif //WINDOWS					}					if(auxarray[tablepos.intg] != xdistance.intg) {						i = (xdistance.intg - auxarray[tablepos.intg]);							texturetable[((tablepos.intg)<<2)+1].l +=											texturetable[(tablepos.intg)<<2].l * i;						texturetable[((tablepos.intg)<<2)+3].l +=											texturetable[((tablepos.intg)<<2)+2].l * i;						auxarray[tablepos.intg] = xdistance.intg;					}					screenpointerchange = 1;					tempfixed.l = constdepthinfo.constdepthslope.l;					#if DEBUG && MACINTOSH						if(yy < y) DEBUGGER();							i = NumOfPixels + InitialMaskIndex;						switch(BitDepthId) {							case BITDEPTHID1:								if((i & 7) != 0) i = (i>>3) + 1;								else i >>= 3;								if(yy + i > y + toRowBytes) DEBUGGER();								break;							case BITDEPTHID2:								if((i & 3) != 0) i = (i>>2) + 1;								else i >>= 2;								if(yy + i > y + toRowBytes) DEBUGGER();								break;							case BITDEPTHID4:								if((i & 1) != 0) i = (i>>1) + 1;								else i >>= 1;								if(yy + i > y + toRowBytes) DEBUGGER();								break;							case BITDEPTHID8: 								if(yy + i > y + toRowBytes) DEBUGGER();								break;							case BITDEPTHID16:																if(yy + (i<<1) > y + toRowBytes) DEBUGGER();								break;							case BITDEPTHID24:								if(yy + (i+i+i) > y + toRowBytes) DEBUGGER();								break;							case BITDEPTHID32:								if(yy + (i<<2) > y + toRowBytes) DEBUGGER();								break;						}					#endif				}				else {					/*must go right to left due to constant depth line slope*/					tempfixed.l = cxl.l + FixedPointFive.l;					tempfixed.intg += NumOfPixels - 1 + xOffsetTail;					switch(BitDepthId) {						case BITDEPTHID1:							yy = y + (tempfixed.intg >> 3);							InitialMaskIndex = 7 - (tempfixed.intg & 7);							break;						case BITDEPTHID2:							yy = y + (tempfixed.intg >> 2);							InitialMaskIndex = 3 - (tempfixed.intg & 3);							break;						case BITDEPTHID4:							yy = y + (tempfixed.intg >> 1);							InitialMaskIndex = 1 - (tempfixed.intg & 1);							break;						case BITDEPTHID8: 							yy = y + tempfixed.intg;							InitialMaskIndex = 0;							break;						case BITDEPTHID16:							yy = y + (tempfixed.intg << 1);							InitialMaskIndex = 0;							break;						case BITDEPTHID24:							yy = y + (tempfixed.intg+tempfixed.intg+tempfixed.intg);							InitialMaskIndex = 0;							break;						case BITDEPTHID32:							yy = y + (tempfixed.intg << 2);							InitialMaskIndex = 0;							break;#if WINDOWS						case BITDEPTHID4X1:		//					LineInfo.yy0 = y + (tempfixed.intg >> 3);							LineInfo.yy0 = to->lpbBmRowAddresses[ytop+to->yOffset];                		    LineInfo.yy0 += (tempfixed.intg + to->xOffset)>>3;							LineInfo.offset4x1 = gwBmWidthBytes;							InitialMaskIndex = 7 - tempfixed.intg & 7;							yy = y;							break;#endif //WINDOWS					}					tablepos.l += (NumOfPixels - 1) * constdepthinfo.constdepthslope.l;					xdistance.intg += NumOfPixels - 1;					if(auxarray[tablepos.intg] != -xdistance.intg) {						i = (-xdistance.intg - auxarray[tablepos.intg]);							texturetable[((tablepos.intg)<<2)+1].l +=											texturetable[(tablepos.intg)<<2].l * i;						texturetable[((tablepos.intg)<<2)+3].l +=											texturetable[((tablepos.intg)<<2)+2].l * i;						auxarray[tablepos.intg] = -xdistance.intg;					}					screenpointerchange = -1;					tempfixed.l = -constdepthinfo.constdepthslope.l;					#if DEBUG && MACINTOSH						if(yy >= y+toRowBytes) DEBUGGER();												i = NumOfPixels + InitialMaskIndex;						switch(BitDepthId) {							case BITDEPTHID1:								if((i & 7) != 0) i = (i>>3) + 1;								else i >>= 3;								if(yy - i < y - 1) DEBUGGER();								break;							case BITDEPTHID2:								if((i & 3) != 0) i = (i>>2) + 1;								else i >>= 2;								if(yy - i < y - 1) DEBUGGER();								break;							case BITDEPTHID4:								if((i & 1) != 0) i = (i>>1) + 1;								else i >>= 1;								if(yy - i < y - 1) DEBUGGER();								break;							case BITDEPTHID8: 								if(yy - i < y - 1) DEBUGGER();								break;							case BITDEPTHID16:								if(yy - ((i-1)<<1) < y) DEBUGGER();								break;							case BITDEPTHID24:								if(yy - ((i-1)*3) < y) DEBUGGER();								break;							case BITDEPTHID32:								if(yy - ((i-1)<<2) < y) DEBUGGER();								break;						}					#endif				}				if(BitDepthId <= BITDEPTHID8) {						if(ytop & 1) {							LineInfo.dith1 = tshade->dith[BitDepthId][2];							LineInfo.dith2 = tshade->dith[BitDepthId][3];						}						else {							LineInfo.dith1 = tshade->dith[BitDepthId][0];							LineInfo.dith2 = tshade->dith[BitDepthId][1];						}				}                else {					if(BitDepthId == BITDEPTHID32) {						LineInfo.dith1 = (unsigned char *)(tshade->truecolor);					}					if(BitDepthId == BITDEPTHID24) {						LineInfo.dith1 = (unsigned char *)(tshade->color24bit);					}					if(BitDepthId == BITDEPTHID16) {						LineInfo.dith1 = (unsigned char *)(tshade->color16bit);					}					if(BitDepthId == BITDEPTHID4X1) {						if(ytop & 1)						LineInfo.longptr = (unsigned long *) (tshade->color4x1[0]);                        else						LineInfo.longptr =(unsigned long *) (tshade->color4x1[1]);					}				}#if WINDOWS// Modify to convert linear yy to segment adjusted yy //GJR 10/29/93if (SPANNEDHUGE(yBase, yy))  // Segment Adjust	//GJR 10/29/93	{ char huge* hugepc  = yBase;				 hugepc += FP_OFF(yy) - FP_OFF(yBase);				 yy      = (UCharPtr)hugepc;    }#endif				LineInfo.NumOfPixels = NumOfPixels;				LineInfo.tablepos = tablepos;				LineInfo.dtablepos = tempfixed;				LineInfo.yy = yy;								(*scanfillshallow)(&LineInfo);			}						}	//if(NumOfPixels > 0)					}		/*advance to next scanline*/		clipindex++;		adjustment.l += dadjustment.l;							xl.l += dxl.l;			xr.l += dxr.l;//		y+=toRowBytes;		overalldeltay++;		ytop++;		if(ytop>=rclip.bottom)goto endit;  	// limit before usage      	//GJR 10/29/93#if MACINTOSH                    	//GJR 10/13/93		y+=toRowBytes;#elif WINDOWS// Prepare to convert linear yy to segment adjusted yy //GJR 10/20/93		yBase = to->lpbBmRowAddresses[yOffset+ytop];		y     = yBase + xOffset;#endif				/*if we have creeped off left or right edge, increment till we are		  back on or reach next polygon corner*/		  	}			if(reset&1)		{		yl = ptC[index_left].v;		xl = ptC[index_left].h;		do	{			index_left=previousNum(index_left,plength);			dylint = FFRound(ptC[index_left].v) - FFRound(yl);						tempfixed.l = ptC[index_left].v.l - yl.l;			dxl.l = ptC[index_left].h.l - xl.l;			dxl = FFDiv(dxl, tempfixed);			}while(FFRound(yl)>FFRound(ptC[index_left].v) && notDone && index_left!=index_right);			oldindexleft = nextNum(index_left,plength);			if(constdepthinfo.spanend1.l < constdepthinfo.spanend2.l) {					if(pnpC[oldindexleft].perspecD == pnpC[closestindex].perspecD) {					adjustment.l = 0;				}				else {					adjustment.l = ptC[oldindexleft].h.l - ptC[closestindex].h.l;					adjustment = FFMult(constdepthinfo.constdepthslope, adjustment);					adjustment.l += ptC[closestindex].v.l - ptC[oldindexleft].v.l;					}				if(pnpC[index_left].perspecD == pnpC[closestindex].perspecD) {					dadjustment.l = 0;				}				else {					dadjustment.l = ptC[index_left].h.l - ptC[closestindex].h.l;					dadjustment = FFMult(constdepthinfo.constdepthslope, dadjustment);					dadjustment.l += ptC[closestindex].v.l - ptC[index_left].v.l;					}				dadjustment.l -= adjustment.l;				tempfixed.l = ptC[index_left].v.l - ptC[nextNum(index_left, plength)].v.l;				if(tempfixed.intg != 0) {					dadjustment = FFDiv(dadjustment, tempfixed);				}			}			else {				if(pnpC[oldindexleft].perspecD == pnpC[closestindex].perspecD) {					//adjustment.l = tablelengthfixed.l;					adjustment.frac = 0; adjustment.intg = tablelength-1;				}				else {								adjustment.l = ptC[oldindexleft].h.l - ptC[closestindex].h.l;					adjustment = FFMult(constdepthinfo.constdepthslope, adjustment);					adjustment.l += ptC[closestindex].v.l - ptC[oldindexleft].v.l;					tempfixed.intg = tablelength-1;					tempfixed.frac = 0;					adjustment.l = tempfixed.l + adjustment.l;					}				if(pnpC[index_left].perspecD == pnpC[closestindex].perspecD) {					//dadjustment.l = tablelengthfixed.l;					dadjustment.frac = 0; dadjustment.intg = tablelength-1;				}				else {					dadjustment.l = ptC[index_left].h.l - ptC[closestindex].h.l;					dadjustment = FFMult(constdepthinfo.constdepthslope, dadjustment);					dadjustment.l += ptC[closestindex].v.l - ptC[index_left].v.l;					tempfixed.intg = tablelength-1;					tempfixed.frac = 0;					dadjustment.l = tempfixed.l + dadjustment.l;					}				dadjustment.l -= adjustment.l;				//i = ptC[index_left].v - ptC[nextNum(index_left, plength)].v;				tempfixed.l = ptC[index_left].v.l - ptC[nextNum(index_left, plength)].v.l;				if(tempfixed.intg != 0) {					dadjustment = FFDiv(dadjustment, tempfixed);				}			}		tempfixed.frac = 0;		tempfixed.intg = FFRound(yl);		tempfixed.l += FixedPointFive.l;		tempfixed.l = tempfixed.l - yl.l;		xl.l += FFMult(dxl, tempfixed).l;		adjustment.l += FFMult(dadjustment, tempfixed).l;		}	if((reset&2) && index_left != index_right)		{		yr = ptC[index_right].v;		xr = ptC[index_right].h;		do	{			index_right=nextNum(index_right,plength);			dyrint = FFRound(ptC[index_right].v) - FFRound(yr);						tempfixed.l = ptC[index_right].v.l - yr.l;			dxr.l = ptC[index_right].h.l - xr.l;			dxr = FFDiv(dxr, tempfixed);			}while(FFRound(yr)>FFRound(ptC[index_right].v) && notDone && index_left!=index_right);		tempfixed.frac = 0;		tempfixed.intg = FFRound(yr);		tempfixed.l += FixedPointFive.l;		tempfixed.l = tempfixed.l - yr.l;		xr.l += FFMult(dxr, tempfixed).l;		}	}while(notDone);}endit:tpoints->Unuse();fpoints->Unuse();nppoints->Unuse();if(clipper)clipper->Unuse();textureinfo->mip[0]->UnuseRaster(&savePort, &saveDevice);	// ABD MERGE23#if DEBUG && MACINTOSHtimetodrawshape = EndTimingMilli();timetocreatetable += 1;#endif#if PROFILE_profile = FALSE;DumpProfile();#endifreturn rval;}/*called in startup() in walkthru.cp to initialize some arrays for use by the  texture mapping routines.  Avoids creating and destroying several VArrays per  poly*/voidInitTextureMapping(){	int i;		/*defensive programming in case this gets called more than once*/	if(globalvarray1 != NULL) return;		/*initialize temporary arrays used for clipping*/	for(i=0;i<NUMOFTEMPARRAYS;i++) {		tempPFFArray[i] = new(V_Array);		tempPFFArray[i]->cArray(64, sizeof(PointFFixed), 8);		tempPFFArray[i]->Use();		tempPFFNPArray[i] = new(V_Array);		tempPFFNPArray[i]->cArray(64, sizeof(Point3DFFNoPersp), 8);		tempPFFNPArray[i]->Use();	}	indexPFFArray = -1;			/*initialize temporary arrays used for tables for texturing poly*/	globalvarray1 = new(V_Array);	globalvarray1->cArray(0, sizeof(FFixed), 8);	globalvarray2 = new(V_Array);	globalvarray2->cArray(0, sizeof(FFixed), 8);	globalvarray3 = new(V_Array);	globalvarray3->cArray(0, sizeof(FFixed), 8);	/*this one is for the auxilliary array in the < 45 degree case*/	globalvarray7 = new(V_Array);	globalvarray7->cArray(0, sizeof(int), 8);	clipvarray1 = new(V_Array);	clipvarray1->cArray(0, sizeof(Point3DFFNoPersp), 8);	clipvarray2 = new(V_Array);	clipvarray2->cArray(0, sizeof(PointFFixed), 8);	clipvarray3 = new(V_Array);	clipvarray3->cArray(0, sizeof(PointFFixed), 8);	clipvarray4 = new(V_Array);	clipvarray4->cArray(0, sizeof(Point), 8);		globalvarray1->Use();	globalvarray2->Use();	globalvarray3->Use();	globalvarray7->Use();	clipvarray1->Use();	clipvarray2->Use();	clipvarray3->Use();	clipvarray4->Use();}/*called in endit() in walkthru.cp to delete arrays created by InitTextureMapping()*/voidEndTextureMapping(){	int i;		/*defensive programming in case this gets called more than once*/	if(globalvarray1 == NULL) return;		for(i=0;i<NUMOFTEMPARRAYS;i++) {		tempPFFArray[i]->Unuse();		tempPFFArray[i]->dArray();		tempPFFNPArray[i]->Unuse();		tempPFFNPArray[i]->dArray();	}	globalvarray1->Unuse();	globalvarray2->Unuse();	globalvarray3->Unuse();	globalvarray7->Unuse();	clipvarray1->Unuse();	clipvarray2->Unuse();	clipvarray3->Unuse();	clipvarray4->Unuse();	globalvarray1->dArray();	globalvarray2->dArray();	globalvarray3->dArray();	globalvarray7->dArray();	clipvarray1->dArray();	clipvarray2->dArray();	clipvarray3->dArray();	clipvarray4->dArray();}