#include "VTypes.h"#include "WTypes.h"#include "VGUtil.h"#include <stdio.h>#include <string.h>#include <QuickTimeComponents.h>#include "VMDL.h"#include "ShowTest.h"			// !!! DEBUG#include "AppText.h"			// needed for IO()#include "AppFiles.h"			// needed for IO() & file types#include "CVWCNTRL.h"#include "VFile.h"#include "TextArry.h"#include "TextItem.h"#include "TextSrvr.h"#include "Texture.h"#include "TextType.h"#include "VDialog.h"#include "VError.h"		// jca 8 Oct 93#include "VGestalt.h"	// jca 13 Oct 93#if MACINTOSHstatic HFileInfo gHFI;			// used in LoadTexturesInDir; must lock object if not local !!!static DirInfo gCPB;			// used in LoadTexturesInDir; must lock object if not local !!!#elif WINDOWS#if !ELVIS // AddTexturesInFolder, write whole thing		//GJR 10/01/93#error This needs your attention, Greg...#endif#endifstatic char gName[63]; 		// used in LoadTexturesInDir; must lock object if not local !!!extern struct TextureServer *gTextureServer;// test ioFlAttrib; returns TRUE if bit 4 is set (== directory)#define IS_FOLDER(x) ((x) & (1<<4))/*------------------------------------------------------------------------------*//* TEXTUREARRAY *//*------------------------------------------------------------------------------*//*------------------------------------------------------------------------------*//* 	This routine creates the texture array.  */void TextureArray::cTextureArray(){	controller = NULL;	// create this array of TextureItem ptrs	V_Array::cArray(0, sizeof(struct TextureItem *), 4);}/*------------------------------------------------------------------------------*//* 	This routine deletes the texture array. */void TextureArray::dTextureArray(){	V_Array::dArray();}	//JAM MEMLEAK 2JAN95 [[[/*------------------------------------------------------------------------------*//* 	This routine deletes the texture items that are in the texture	array */void TextureArray::dTextureItemsInTextureArray(){	int i, NumOfTextureItems;	TextureItem *texture_item;	V_Array *ListOfTextureItemsToDelete;	/*	We wish to go through the texture array and delete every texture	item therein.  However, TextureArray, as of 12/14/94, is also the	parent array of all the TextureItems it points to, so when we do	a dTextureItem() on an individual TextureItem, it is removed	from the parent varray, i.e. this TextureArray.  We could,	therefore, repeatedly get the first (or last) element in the	array and do a dTextureItem() on that one, after which the	first (last) element will be what used to be the second (next	to last), and that one will be deleted next.  It would not be	obvious that this is what was happening, however, since	dTextureItem() is a member of another class.  Therefore, for	robustness, we first make a list of TextureItems to be	Deleted, and then go through that list.  Thus it is not necessary	for TextureArray to be the parent array of the TextureItems it	contains, but neither is that situation bad.  In fact, with this	robust deletion method, TextureArray can be the parent of some,	none, or all of the TextureItems it contains.	*/	//create place to put list of texture items to be deleted	ListOfTextureItemsToDelete = (V_Array *)new(V_Array);	NumOfTextureItems = ALength();	if(ListOfTextureItemsToDelete == NULL) return; //blech! no memory!	if((ListOfTextureItemsToDelete->cArray(NumOfTextureItems, sizeof(TextureItem *), NumOfTextureItems)) == VARY_LOWMEM)	{    	return;	//blech! no memory!    }	//fill in list of texture items to be deleted    CopyArray(ListOfTextureItemsToDelete);    //delete all the texture items in list 	for(i=0; i<NumOfTextureItems; i++)	{		ListOfTextureItemsToDelete->Get(i,&texture_item);        texture_item->dTextureItem();	}    //destroy list	ListOfTextureItemsToDelete->dArray();}//JAM MEMLEAK 2JAN95 ]]]/*------------------------------------------------------------------------------*//* 	This routine adds vdigs to the texture array. */void TextureArray::AddVDIGs(){	// get the texture server to add video digitizers to us	gTextureServer->AddVDIGs(this);}	/*------------------------------------------------------------------------------*//* 	This routine */void TextureArray::NameChanged(){}	/*------------------------------------------------------------------------------*//* 	This routine */voidTextureArray::SetController(struct CAVWalkController *c){	controller = c; }/*------------------------------------------------------------------------------*//* 	This routine *///MODIFIED		//GJR 10/06/93		[[[struct TextureItem * TextureArray::FindTextureItem(char *name_to_find, VfsLocation *findLocation){	VfsLocation *textureLocation;	char nm[256];	//char fn0[256] = "", fn1[256] = "";	//long dir1 = 0, dir0 = dir;	//short vol1 = 0, vol0 = vol;	struct TextureItem **ti;	struct TextureItem *return_result = NULL;	int i;//MERGE-PRO-JAM-1	textureLocation = new(VfsLocation);	textureLocation->cVfsLocation();	ti = (TextureItem **)this->Use();	for ( i = 0 ; i < this->ALength() ; i++ )	{		ti[i]->GetName(nm);		if (strcmp(nm, name_to_find) == 0)		{ 			ti[i]->GetFileLoc(textureLocation);			if (VfsIsSameLocation(textureLocation, findLocation))				{ return_result = ti[i]; break; }		}	}	this->Unuse();    textureLocation->dVfsLocation();	return (return_result);}//MODIFIED		//GJR 10/06/93		]]]int gAskAboutAll = FALSE;int gUseAllOld = FALSE;int gUseAllNew = FALSE;int gRenameAllNew = FALSE;/*------------------------------------------------------------------------------*//* 	This routine 	if already loaded, return ptr to it	if not already loaded, create new one		This routine is called when adding textures, not when doing i/o or cut/copy/paste.*///MODIFIED	//GJR 10/06/93 [[[//JAM MODIFIED 10/12/94 to return error upon failure [[[intTextureArray::GetTextureItem(char *name, VfsLocation *vfsLocation, struct TextureItem **NewTi){// MERGE-VPRO-2 [[[#if VPROstruct TextureItem *ti0;char str[256];struct TextureItem *ti;int err = noErr;	ti0 = FindByName(name);	if (ti0 != NULL)		// whoops!  not a unique name	{		if (gUseAllOld)		// if the user previously said to use all old		{			if(NewTi) { *NewTi = ti0; } 			return err;		}		else if (gUseAllNew) 	// if the user previously said to use all new		{			// reset the texture file loc			err = ti0->TextureFileLoc(vfsLocation);			if(!err)            {				// load the picture if it is in use				if (ti0->IsUsedInDocument())                	{ err = ti0->LoadPicture(); }				// reapply the texture				// follows LoadPicture GJR091093				if (!err) ti0->ApplyTexture();			}			if(err) {ti0 = NULL;}			if(NewTi) { *NewTi = ti0; }		// give the texture item back			return err;		}		else if (gRenameAllNew) 	// if the user previously said to rename all new		{			// make a new texture item			ti = new(TextureItem);			if(ti == NULL) {if(NewTi) { *NewTi = NULL; } return -1;}			ti->cTextureItem(this);			// does not create the texture itself						strcpy(ti->settings.name, name);				err = ti->TextureFileLoc(vfsLocation);			if(!err)            {				controller->AddTextureItem(ti);							// user wants to rename new, so give it a unique name				ti->UniqueName();			}			else			{				if(ti) ti->dTextureItem();                ti = NULL;			}			if(NewTi) { *NewTi = ti; }			return err;		}		if (gAskAboutAll)		// ask the user what to do		{		int val;		//			sprintf(str,"Texture \"%s\" already exists in this model. Use the old or new texture?",name);		// MERGE-GOURAUD-PRO-5			sprintf(str,TXT_ALREADYEXITS,name);		// MERGE-GOURAUD-PRO-5			val = SixButtonMessage(str,TXT_CUSENEW,TXT_CUSEOLD,TXT_CRENAMENEW,TXT_CUSEALLNEW,TXT_CUSEALLOLD,TXT_CRENAMEALL,POSITIVE_BUTTON_ONE|DEFAULT_BUTTON_ONE);			if (val == 1)			{				// user wants new				// reset the texture file loc				err = ti0->TextureFileLoc(vfsLocation);				if(!err)            	{					// load the picture if it is in use					if (ti0->IsUsedInDocument())        	        	{ err = ti0->LoadPicture(); }            						// reapply the texture				// follows LoadPicture GJR091093					if (!err) ti0->ApplyTexture();				}				if(err) {ti0 = NULL;}				if(NewTi) { *NewTi = ti0; }		// give the texture item back				return err;			}			else if (val == 2)			{				// user wants old				if(NewTi) { *NewTi = ti0; }	   //do nothing				return err;			}			else if (val == 3)			{				// user wants to rename new, so we need to make a new guy and then give him a 				// unique name				//make a new texture item				ti = new(TextureItem);				if(ti == NULL) {if(NewTi) { *NewTi = NULL; } return -1;}				ti->cTextureItem(this);			// does not create the texture itself							strcpy(ti->settings.name, name);					err = ti->TextureFileLoc(vfsLocation);				if(!err)    	        {					controller->AddTextureItem(ti);								// user wants to rename new, so give it a unique name					ti->UniqueName();				}				else				{					if(ti) ti->dTextureItem();                	ti = NULL;				}				if(NewTi) { *NewTi = ti; }				return err;			}			else if (val == 4)			{				// user all new				gUseAllNew = TRUE;								// user wants new				// reset the texture file loc				err = ti0->TextureFileLoc(vfsLocation);				if(!err)            	{					// load the picture if it is in use					if (ti0->IsUsedInDocument())        	        	{ err = ti0->LoadPicture(); }            						// reapply the texture				// follows LoadPicture GJR091093					if (!err) ti0->ApplyTexture();				}				if(err) {ti0 = NULL;}				if(NewTi) { *NewTi = ti0; }		// give the texture item back				return err;			}			else if (val == 5)			{				// user all old				gUseAllOld = TRUE;				// user wants old				if(NewTi) { *NewTi = ti0; }	   //do nothing				return err;			}			else if (val == 6)			{					// user wants to rename all new				gRenameAllNew = TRUE;				// user wants to rename new, so we need to make a new guy and then give him a				// unique name				//make a new texture item				ti = new(TextureItem);				if(ti == NULL) {if(NewTi) { *NewTi = NULL; } return -1;}				ti->cTextureItem(this);			// does not create the texture itself							strcpy(ti->settings.name, name);					err = ti->TextureFileLoc(vfsLocation);				if(!err)    	        {					controller->AddTextureItem(ti);								// user wants to rename new, so give it a unique name					ti->UniqueName();				}				else				{					if(ti) ti->dTextureItem();                	ti = NULL;				}				if(NewTi) { *NewTi = ti; }				return err;			}		}		else		{		int val;		//			sprintf(str,"Texture \"%s\" already exists in this model. Use the old or new texture?",name);		// MERGE-GOURAUD-PRO-5				sprintf(str,TXT_ALREADYEXITS,name);		// MERGE-GOURAUD-PRO-5			val = ThreeButtonMessage(str,TXT_CUSENEW,TXT_CUSEOLD,TXT_CRENAMENEW,POSITIVE_BUTTON_ONE|DEFAULT_BUTTON_ONE);			if (val == 1)			{				// user wants new				// reset the texture file loc				ti0->TextureFileLoc(vfsLocation);								// load the picture if it is in use				if (ti0->IsUsedInDocument())					ti0->LoadPicture();				// reapply the texture				ti0->ApplyTexture();		//follows LoadPicture GJR091093				if(NewTi) { *NewTi = ti0; }		// give the texture item back				return err;			}			else if (val == 2)			{				// user wants old								if(NewTi) { *NewTi = ti0; }		// do nothing				return err;			}			else if (val == 3)			{				// make a new texture item				ti = new(TextureItem);				ti->cTextureItem(this);			// does not create the texture itself								strcpy(ti->settings.name, name);					ti->TextureFileLoc(vfsLocation);				controller->AddTextureItem(ti);								// user wants to rename new, so give it a unique name				ti->UniqueName();				if(NewTi) { *NewTi = ti; }	// do nothing				return err;			}		}	}	else 	// a unique name, so create a new texture item	{		// make a new texture item		ti = new(TextureItem); 		if(ti == NULL) {if(NewTi) { *NewTi = NULL; } return -1;}		ti->cTextureItem(this);			// does not create the texture itself				strcpy(ti->settings.name, name);			err = ti->TextureFileLoc(vfsLocation);		if(!err) {controller->AddTextureItem(ti);}		else {if(ti) {ti->dTextureItem(); ti = NULL; } }		if(NewTi) { *NewTi = ti; }		return(err);	}#else // above is VPRO, below is not VPROstruct TextureItem *ti0 = NULL;char str[256];struct TextureItem *ti = NULL;int err = noErr;	ti0 = FindByName(name);	if (ti0 != NULL)		// whoops!  not a unique name	{		// VR NOTE:  in VR, we always rename all new textures if there is a name conflict			// make a new texture item		ti = new(TextureItem);		ti->cTextureItem(this);			// does not create the texture itself				strcpy(ti->settings.name, name);			ti->TextureFileLoc(vfsLocation);				//GJR 10/06/93#if (!VPLAYER)		if (controller) controller->AddTextureItem(ti);		// MERGE16#endif //!VPLAYER				// user wants to rename new, so give it a unique name		ti->UniqueName();		*NewTi = ti;		return err; 	// do nothing	}	else 	// a unique name, so create a new texture item	{				// make a new texture item		ti = new(TextureItem);		ti->cTextureItem(this);			// does not create the texture itself				strcpy(ti->settings.name, name);      // ABD added err return val 12/9/93		err = ti->TextureFileLoc(vfsLocation);					//GJR 10/06/93		if (err == noErr)			{			/* Note that it is possible to have read the file			correctly even without a controller.  Under Windows,			the controller isn't installed until long after the texture			is read in (I suspect the mac is similar).  Do not combine			the check for a valid texture file with the check for a			controller; they are not equivalent.  jca 12 Dec 93            */#if (!VPLAYER)			if (controller)	controller->AddTextureItem(ti);		// MERGE16#endif //!VPLAYER            }		else		{      	// an error occurred			// remove this texture item from ourselves; delete everything			ti->dTextureItem();			ti = NULL;		// return NULL when an error occurs      	}			*NewTi = ti;		return err;	}#endif // VPRO-2// MERGE-VPRO-2}//JAM MODIFIED 10/12/94 to return error upon failure [[[//MODIFIED	//GJR 10/06/93 ]]]/*-------------------------------------------------------------------------------*//*	This routine finds a texture PICT file that is used in the document, so we	can show it to the user in the standard compression dialog box when he saves	this document.  If we can't find any PICT file textures used in this document, 	then we return FALSE.*/V_Offscreen *TextureArray::GetSample()	{int i;TextureItem *ti;	for (i = 0 ; i < ALength() ; i++)	{		Get(i, &ti);		if ((ti->texture)			&& ((ti->texture->type == TEXTURE_PICTFILE) || 				(ti->texture->type == TEXTURE_PICT)) &&				(ti->IsUsedInDocument()))			{				return ti->GetPicture(0);			}	}	return NULL;}//JAM PORTTOWINQQQ#if MACINTOSH/*-------------------------------------------------------------------------------*//*	This routine loads all the textures inside the directory specified by the fSpec	passed in.  This fSpec contains info about the folder itself, so parID is 	actually the parent ID of the folder, name is the name of the folder, etc.*/void TextureArray::LoadTexturesInDir (VfsLocation *fSpec)				//CHanges	//GJR 10/06/93{int index, i;int err = noErr;char str[256], str2[256];struct TextureItem *ti;	// first we need to figure out the actual directory ID of fSpec'd folder passed in.	for (i=0;i<64;i++) gName[i]=fSpec->name[i];	C2Pstr(gName);	gCPB.ioNamePtr = (StringPtr)gName;	gCPB.ioVRefNum = fSpec->volume;	gCPB.ioDrDirID = fSpec->directory;								//Changes	//GJR 10/06/93	gCPB.ioFDirIndex = 0;	err = PBGetCatInfo((CInfoPBPtr)&gCPB, FALSE);		// now gCPB.ioDrDirID contains the directory ID of the folder passed in		MeterStopCreate();	MeterTitle(TXT_APPNAME);	MeterSetText("");	MeterSetTotal(gCPB.ioDrNmFls);	MeterSetCount(0);	MeterStart();	gUseAllOld = FALSE;	gUseAllNew = FALSE;	gRenameAllNew = FALSE;	gAskAboutAll = TRUE;	gHFI.ioNamePtr = (StringPtr)gName;	gHFI.ioVRefNum = fSpec->volume;										//GJR 10/06/93	index = 1;	while (err == noErr)	{		gHFI.ioFDirIndex = index;		gHFI.ioDirID = gCPB.ioDrDirID;		// reset dirID		err = PBGetCatInfo((CInfoPBPtr)&gHFI, FALSE);		if (err == noErr)		{			if (!IS_FOLDER(gHFI.ioFlAttrib))			{			extern int gQuickTime;							for (i=0;i<64;i++) str[i]=gHFI.ioNamePtr[i];				P2Cstr(str);				for (i=0;i<64;i++) fSpec->name[i]=gHFI.ioNamePtr[i];				P2Cstr(fSpec->name);				fSpec->directory = gCPB.ioDrDirID;				// volume left alone				fSpec->alias = 0;								if (gHFI.ioFlFndrInfo.fdType == appFileTypePICT)				{	sprintf(str2, TXTM_ADDPICT, str);					MeterSetText(str2);					GetTextureItem(str, fSpec, NULL);							//GJR 10/06/93				}else if ((gQuickTime) && (gHFI.ioFlFndrInfo.fdType == appFileTypeQuickTime))				{	sprintf(str2, TXTM_ADDQT, str);					MeterSetText(str2);					GetTextureItem(str, fSpec, NULL);							//GJR 10/06/93				}#if 0				else if (gHFI.ioFlFndrInfo.fdType == appFileTypeModel)				{					V_File *f;					sprintf(str2, TXTM_ADDTEXTMDL, str);					MeterSetText(str2);					f = new(V_File);					f->cFile(LOAD, '????', '????', "", "");					f->SetLocation(fSpec);								//GJR 10/06/93					f->Find();					f->Open(FALSE);					gTextureServer->BeginTextureIO(f, this);					gTextureServer->IOTextureLibrary(f);					gTextureServer->EndTextureIO(f);					f->Close();					f->dFile();				}				else if (gHFI.ioFlFndrInfo.fdType == appFileTypeLibrary)				{					V_File *f;					sprintf(str2, TXTM_ADDTEXTLIB, str);					MeterSetText(str2);					f = new(V_File);					f->cFile(LOAD, '????', '????', "", "");					f->SetLocation(fSpec);								//GJR 10/06/93					f->Find();					f->Open(FALSE);					gTextureServer->BeginTextureIO(f, this);					gTextureServer->IOTextureLibrary(f);					gTextureServer->EndTextureIO(f);					f->Close();					f->dFile();				}					else if (gHFI.ioFlFndrInfo.fdType == appFileTypeTextureLibModel)				{					V_File *f;									sprintf(str2, TXTM_ADDTEXTTLIB, str);					MeterSetText(str2);					f = new(V_File);					f->cFile(LOAD, '????', '????', "", "");					f->SetLocation(fSpec);								//GJR 10/06/93					f->Find();					f->Open(FALSE);					gTextureServer->BeginTextureIO(f, this);					gTextureServer->IOTextureLibrary(f);					gTextureServer->EndTextureIO(f);					f->Close();					f->dFile();				}	#endif			}		}		index++;		MeterSetCount(index-1);							if (MeterUpdate(0)) 		{			// user cancelled 			break; 		}	}	MeterStop();		gUseAllOld = FALSE;		// reset globals so next load we can ask the user again	gUseAllNew = FALSE;	gRenameAllNew = FALSE;	gAskAboutAll = FALSE;}#endif												//!elvis. one left to go GJR 10/06/93#if WINDOWS//JAM PORTTOWINQQQ/*-------------------------------------------------------------------------------*//*	This routine loads all the textures inside the directory specified by the fSpec	passed in.  This fSpec contains info about the folder itself, so parID is 	actually the parent ID of the folder, name is the name of the folder, etc.*/void TextureArray::LoadTexturesInDir (VfsLocation *fSpec)				//CHanges	//GJR 10/06/93{}#endif												//!elvis. one left to go GJR 10/06/93#if MACINTOSH/*-------------------------------------------------------------------------------*//*	This routine loads all the textures inside the directory specified by the fSpec	passed in.  This fSpec contains info about the folder itself, so parID is 	actually the parent ID of the folder, name is the name of the folder, etc.*/void TextureArray::AddListOfTextures (V_Array *filelist)				//CHanges	//GJR 10/06/93{}#endif												//!elvis. one left to go GJR 10/06/93#if WINDOWSvoidTextureArray::AddListOfTextures (V_Array *filelist)				//CHanges	//GJR 10/06/93{	VfsLocation **vfslist;	long i, NumOfFiles;	int err = 0;	NumOfFiles = filelist->ALength();	vfslist = (VfsLocation **)filelist->Use();	for(i=0;(i<NumOfFiles) && (!err);i++)	{		err = LoadTexture(vfslist[i]);	}	if(err) { AlertMessage(TXT_LOADFAILURE); }	filelist->Unuse();}#endif//CHANGES						//GJR 10/06/93 [[[/*-------------------------------------------------------------------------------*//*	This routine loads the textures specified by the fSpec passed in.  	It calls AddTextureFileLoc() to actually add the texture to the array (and make	sure it was not already loaded).*///JAM 11OCT94 for hack to get meters operating nice when loading textures [[[//JAM 11OCT94 global flag to indicate texture is loadingint gLoadingTexture = 0;//JAM 11OCT94 for hack to get meters operating nice when loading textures ]]]intTextureArray::LoadTexture (VfsLocation *fSpec){int index, i;int err = noErr;char str[256], str2[256];struct TextureItem *ti;Long fileType;	gLoadingTexture++;	//JAM 11OCT94 increment flag to indicate loading texture	MeterStopCreate();	MeterTitle(TXT_APPNAME);	MeterSetText("");	MeterSetTotal(TEXTUREMETERLOADLENGTH);	MeterSetCount(0);	MeterStart();	gUseAllOld = FALSE;	gUseAllNew = FALSE;	gRenameAllNew = FALSE;	gAskAboutAll = FALSE;	VfsGetLocationFType(fSpec, &fileType);								//GJR 10/06/93		VfsGetLocationFName(fSpec, str);									//GJR 10/06/93//	for (i=0;i<64;i++) str[i] = fSpec->name[i];//	P2Cstr(str);	if (fileType == appFileTypePICT)	{			sprintf(str2, TXTM_ADDPICT, str); // jca 8 Oct 93		MeterSetText(str2);		err = GetTextureItem(str, fSpec, NULL);										//GJR 10/06/93	}	else if (fileType == appFileTypeBMP)	{			sprintf(str2, TXTM_ADDBMP, str); // jca 8 Oct 93		MeterSetText(str2);		err = GetTextureItem(str, fSpec, NULL);										//GJR 10/06/93	}	else if ((gQuickTime) && (fileType == appFileTypeQuickTime))	{			sprintf(str2, TXTM_ADDQT, str);    // jca 8 Oct 93		MeterSetText(str2);		err = GetTextureItem(str, fSpec, NULL);										//GJR 10/06/93	}//	else if (fileType == appFileTypeModel)	else if (VfsIsVirtusModel(fSpec)) 	// jam 23July94	{	V_File *f;		sprintf(str2, TXTM_ADDTEXTMDL, str);		// MERGE-GOURAUD-PRO-5 //GJR 09/24/93   // jca 8 Oct 93		MeterSetText(str2);		f = new(V_File);		f->cFile(LOAD, MakeID('?','?','?','?'), MakeID('?','?','?','?'), "", "");         // jca 8 Oct 93		f->VSetLocation(fSpec);											//GJR 10/06/93		f->Find();		f->Open(FALSE);		gTextureServer->BeginTextureIO(f, this);		err = gTextureServer->IOTextureLibrary(f);		gTextureServer->EndTextureIO(f);		f->Close();		f->dFile();	}	else if (fileType == appFileTypeLibrary)	{		V_File *f;		sprintf(str2, TXTM_ADDTEXTLIB, str);		// MERGE-GOURAUD-PRO-5 		//GJR 09/24/93    // jca 8 Oct 93		MeterSetText(str2);		f = new(V_File);		f->cFile(LOAD, MakeID('?','?','?','?'), MakeID('?','?','?','?'), "", "");        // jca 8 Oct 93		f->VSetLocation(fSpec);											//GJR 10/06/93		f->Find();		f->Open(FALSE);		gTextureServer->BeginTextureIO(f, this);		err = gTextureServer->IOTextureLibrary(f);		gTextureServer->EndTextureIO(f);		f->Close();		f->dFile();	}	else if (fileType == appFileTypeTextureLibModel)	{		V_File *f;			sprintf(str2, TXTM_ADDTEXTTLIB, str);		// MERGE-GOURAUD-PRO-5 		//GJR 09/24/93   // jca 8 Oct 93		MeterSetText(str2);		f = new(V_File);		f->cFile(LOAD, MakeID('?','?','?','?'), MakeID('?','?','?','?'), "", "");		f->VSetLocation(fSpec);											//GJR 10/06/93		f->Find();		f->Open(FALSE);		gTextureServer->BeginTextureIO(f, this);		err = gTextureServer->IOTextureLibrary(f);		gTextureServer->EndTextureIO(f);		f->Close();		f->dFile();	}//MERGE-PRO-JAM-3 [[[	else if (fileType == appFileTypeVRTextureLib)	{		V_File *f;			sprintf(str2, TXTM_ADDTEXTTLIB, str);		MeterSetText(str2);		f = new(V_File);		f->cFile(LOAD, MakeID('?','?','?','?'), MakeID('?','?','?','?'), "", "");		f->VSetLocation(fSpec);											//GJR 10/06/93		f->Find();		f->Open(FALSE);		gTextureServer->BeginTextureIO(f, this);		err = gTextureServer->IOTextureLibrary(f);		gTextureServer->EndTextureIO(f);		f->Close();		f->dFile();	}//MERGE-PRO-JAM-3 ]]]	MeterSetCount(TEXTUREMETERLOADLENGTH);	if (MeterUpdate(0)) {}	MeterStop();	gUseAllOld = FALSE;	gUseAllNew = FALSE;	gRenameAllNew = FALSE;	gAskAboutAll = FALSE;	gLoadingTexture--;	//JAM 11OCT94 decrement flag to indicate texture isn't loading anymore	return(err);}//CHANGES						//GJR 10/06/93 ]]]/*------------------------------------------------------------------------------*//*	This routine compares two textures for sorting alpha by texture item logical name.*/int TextureArray::Compare(void *data1, void *data2){struct TextureItem *ti1, *ti2;char *nm1, *nm2;char name1[256], name2[256];int result;	ti1 = *(TextureItem**)(data1);	ti2 = *(TextureItem**)(data2);	strncpy(name1, ti1->settings.name, strlen(ti1->settings.name));	strncpy(name2, ti2->settings.name, strlen(ti2->settings.name));	result = strcmp(name1, name2);	return(result);}/*------------------------------------------------------------------------------*//*	This routine returns a pointer to the texture item in this array with the	logical name name_to_find.  If it doesn't find one it returns NULL.*/struct TextureItem* TextureArray::FindByName(char *name_to_find){char nm[256];struct TextureItem **ti;struct TextureItem *return_result = NULL;int i;	ti = (TextureItem **)this->Use();	for ( i = 0 ; i < this->ALength() ; i++ )	{		ti[i]->GetName(nm);		if (strcmp(nm, name_to_find) == 0)		{ 			return_result = ti[i]; 			break; 		}	}	this->Unuse();	return (return_result);}/*------------------------------------------------------------------------------*//*	This routine */void TextureArray::PurgeUnused(){}/*------------------------------------------------------------------------------*//*	This routine returns a pointer to the texture item in this array with the	logical name name_to_find.  If it doesn't find one it returns NULL.*/struct TextureItem* TextureArray::FindByNameX(char *name_to_find, struct TextureItem *exclude){char nm[256];struct TextureItem **ti;struct TextureItem *return_result = NULL;int i;	ti = (TextureItem **)this->Use();	for ( i = 0 ; i < this->ALength() ; i++ )	{		if (exclude != ti[i])		{			ti[i]->GetName(nm);			if (strcmp(nm, name_to_find) == 0)			{ 				return_result = ti[i]; 				break; 			}		}	}	this->Unuse();	return (return_result);}/*------------------------------------------------------------------------------*//*	This routine */struct TextureItem *TextureArray::FindOldStyle(int index){struct TextureItem **ti;struct TextureItem *return_result = NULL;int i;	ti = (TextureItem **)this->Use();	for ( i = 0 ; i < this->ALength() ; i++ )	{		if (ti[i]->old_style_index == index) { return_result = ti[i]; break; }	}	this->Unuse();	return (return_result);}/*------------------------------------------------------------------------------*//*	This routine returns the TextureItem in this array whose id is find_id, if	there is no TextureItem in this array whose id is find_id, then NULL is returned.*/struct TextureItem *TextureArray::FindByID(long find_id){struct TextureItem **ti;struct TextureItem *return_result = NULL;int i;	ti = (TextureItem **)this->Use();	for ( i = 0 ; i < this->ALength() ; i++ )	{		if (ti[i]->id == find_id) { return_result = ti[i]; break; }	}	this->Unuse();	return (return_result);}/*------------------------------------------------------------------------------*//*	This routine returns the TextureItem in this array whose id is find_id, if	there is no TextureItem in this array whose id is find_id, then NULL is returned.*/voidTextureArray::ResetIDs(){struct TextureItem **ti;int i;	ti = (TextureItem **)this->Use();	for ( i = 0 ; i < this->ALength() ; i++ )	{		ti[i]->id = NON_IO_ID;	}	this->Unuse();}