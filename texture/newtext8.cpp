/***********************************************************************************//*********	PERFECT FAST TEXTURES!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ****************//***********************************************************************************/#include "VTypes.h"  #include "WTypes.h"#include "Clip.h"#include "Flash.h"#include "VGUtil.h"#include <stdlib.h>#include "sfgen.h"#include "TextType.h"#include "objprclp.h"#include "TxtrUtil.h"#include <stdio.h>#include "VDialog.h"#if USE_HMD				// MERGE-HMD#include "HMD.h"		// MERGE-HMD#endif					// MERGE-HMD#define ACCEPT 0#define REJECT -1#define INSIDE 1#define EXACTLY_ON 0#define OUTSIDE -1#define DONT_INTERSECT 0#define DO_INTERSECT 1#define COLINEAR 2unsigned long MinimumDepthStep;int MinimumPixelWidth = 4;int GlobalSlopeIsSteep;FFixed GlobalConstantDepthSlope;typedef struct Parallelogram {	FFixed Slope;	FFixed xmin, xmax, ymin, ymax;	long Texture, perspec2;	int SlopeIsSteep;	int MaxDepthIndex;	int MinDepthIndex;	int MaxScreenXIndex;	FFixed OneOverMaxDepth, OneOverMinDepth;	FFixed x1, x2;	FFixed y1, y2;} Parallelogram;typedef struct RenderingParameters{	struct TextureRendSettings *textureinfo;	V_Offscreen *to;	unsigned char **fromRaster;	int xOffset;	int yOffset;	long toRowBytes;	int BitDepthId;	int BitDepthIndex;	int horizontaltexturemask, verticaltexturemask;	int horizontalmirrormask, verticalmirrormask;	ShadeEntry *tshade;	void (*ShadedLinearScanFillRoutine)(struct ScanLineInfo *);} RenderingParameters;/*store the info used for each sub-polygon into a structure that can  be generated once per polygon*/voidMakeRendSettings(struct TextureRendSettings *textureinfo, V_Offscreen *to,				 PointFFixed *pf, int plength, RenderingParameters *RendSettings);voidMakeRendSettings(struct TextureRendSettings *textureinfo, V_Offscreen *to,				 PointFFixed *pf, int plength, RenderingParameters *RendSettings){	int i;	Rect texturerect;	FFixed tempfixed;			RendSettings->textureinfo = textureinfo;	RendSettings->to = to;		RendSettings->xOffset = -to->GetXOffset();	RendSettings->yOffset = -to->GetYOffset();	RendSettings->toRowBytes = to->GetRowWidth();	textureinfo->mip[0]->GetRect(&texturerect);	RendSettings->horizontaltexturemask = (texturerect.right) - 1;	RendSettings->verticaltexturemask = (texturerect.bottom) - 1;	RendSettings->horizontalmirrormask = (texturerect.right);	RendSettings->verticalmirrormask = (texturerect.bottom);	if(textureinfo->hFlip) {		tempfixed.frac = 0;		tempfixed.intg = RendSettings->horizontaltexturemask;		for(i=0;i<plength;i++)		{			pf[i].h.l = tempfixed.l - pf[i].h.l;		}	}	if(textureinfo->vFlip) {		tempfixed.frac = 0;		tempfixed.intg = RendSettings->verticaltexturemask;		for(i=0;i<plength;i++)		{			pf[i].v.l = tempfixed.l - pf[i].v.l;		}	}	RendSettings->tshade = textureinfo->textureShade;	/*select correct bit depth based on to raster*//*	i = to->bitDepth;	if(i == 1) { RendSettings->BitDepthId = BITDEPTHID1; RendSettings->BitDepthIndex = 0; }	else if(i == 2) { RendSettings->BitDepthId = BITDEPTHID2; RendSettings->BitDepthIndex = 0; }	else if(i == 4) { RendSettings->BitDepthId = BITDEPTHID4; RendSettings->BitDepthIndex = 0; }	else if(i == 8) { RendSettings->BitDepthId = BITDEPTHID8; RendSettings->BitDepthIndex = 1; }	else if(i == 16) { RendSettings->BitDepthId = BITDEPTHID16; RendSettings->BitDepthIndex = 2; }//JAM 3-31-94 24/32 bit fix [[[	else if(i == 24) { RendSettings->BitDepthId = BITDEPTHID24; RendSettings->BitDepthIndex = 3; }	else if(i == 32) { RendSettings->BitDepthId = BITDEPTHID32; RendSettings->BitDepthIndex = 4; }//JAM 3-31-94 24/32 bit fix ]]]*//*select correct bit depth based on to raster*/switch (to->bitDepth)	{// BUGBUG - hack so we print if the bitdepth is zero!//	if(to->bitDepth == 0) { RendSettings->BitDepthId = BITDEPTHID8; RendSettings->BitDepthIndex = 1; }case	0:		RendSettings->BitDepthId = BITDEPTHID8;		RendSettings->BitDepthIndex = BITDEPTHINDEX8;		break;#if MACINTOSHcase	1:		RendSettings->BitDepthId = BITDEPTHID1;		RendSettings->BitDepthIndex = BITDEPTHINDEX1;		break;case	2:		RendSettings->BitDepthId = BITDEPTHID2;		RendSettings->BitDepthIndex = BITDEPTHINDEX2;		break;#endifcase	4:		RendSettings->BitDepthId = BITDEPTHID4;		RendSettings->BitDepthIndex = BITDEPTHINDEX4;#if WINDOWS		if(to->wBmPlanes == 4)			{			RendSettings->BitDepthId = BITDEPTHID4X1;			RendSettings->BitDepthIndex = BITDEPTHINDEX4X1;			}#endif //WINDOWS		break;case	8:		RendSettings->BitDepthId = BITDEPTHID8;		RendSettings->BitDepthIndex = BITDEPTHINDEX8;		break;case	16:		RendSettings->BitDepthId = BITDEPTHID16;		RendSettings->BitDepthIndex = BITDEPTHINDEX16;		break;#if WINDOWScase	24:		RendSettings->BitDepthId = BITDEPTHID24;		RendSettings->BitDepthIndex = BITDEPTHINDEX24;		break;#endif //WINDOWScase	32:		RendSettings->BitDepthId = BITDEPTHID32;		RendSettings->BitDepthIndex = BITDEPTHINDEX32;		break;default: DEBUGGER();	}//JAM 27Sept94 this code now in case statement above// BUGBUG - hack so we print if the bitdepth is zero!//	if(to->bitDepth == 0) { RendSettings->BitDepthId = BITDEPTHID8; RendSettings->BitDepthIndex = 1; }/*	if(((horizontalmirrormask & (horizontalmirrormask - 1)) == 0) &&		  ((verticalmirrormask & (verticalmirrormask - 1)) == 0))	  {  		IsAPowerOfTwo = 1;	  }		else {		IsAPowerOfTwo = 0;	}*/	if(RendSettings->textureinfo->vMirror) i = 1;	else i = 0;	if(RendSettings->textureinfo->hMirror) i |= 2;	if(RendSettings->textureinfo->decal)  i |= 4;//	if(IsAPowerOfTwo) i |= 8;	if(((RendSettings->horizontalmirrormask & (RendSettings->horizontalmirrormask - 1)) == 0) &&		  ((RendSettings->verticalmirrormask & (RendSettings->verticalmirrormask - 1)) == 0))	  {  		/*texture array is a power of two*/  		i |= 8;	  }		RendSettings->ShadedLinearScanFillRoutine =			ShadedLinearScanFill[i][RendSettings->BitDepthIndex];}/*finds the slope of a constant depth line.  finds smallest magnitude  version of dy/dx and dx/dy, returns 1 if it's dy/dx (indicating > 45 degree slope),  and 0 otherwise*/intFindSlope(Point3DAllInfo *p, int plength, FFixed *Slope);intFindSlope(Point3DAllInfo *p, int plength, FFixed *Slope){int p1a, p1b, p2a, p2b;int i;FFixed f1, f2, delta, ratio;FFixed screenx1, screeny1, screenx2, screeny2;unsigned long middledepth, tempulong;unsigned long closest, furthest;	closest = furthest = p[0].perspecD;	for(i=1;i<plength;i++)	{		tempulong = p[i].perspecD;		if(tempulong > closest) { closest = tempulong; }		else if(tempulong < furthest) { furthest = tempulong; }	}	middledepth = (closest + furthest)>>1;	for(p1a = 0, p1b = 1;		!(((p[p1a].perspecD <= middledepth) && (p[p1b].perspecD >= middledepth)) ||		((p[p1a].perspecD >= middledepth) && (p[p1b].perspecD <= middledepth)));		p1a++, p1b++);	/*have to have slightly different loop in case middledepth = p[0].perspecD*/	for(p2a = 0, p2b = plength-1;		!(((p[p2a].perspecD < middledepth) && (p[p2b].perspecD >= middledepth)) ||		((p[p2a].perspecD > middledepth) && (p[p2b].perspecD <= middledepth)));		p2a = p2b, p2b--);		delta.l = p[p1a].perspecD - p[p1b].perspecD;	if(delta.l != 0) {		ratio.l = middledepth - p[p1b].perspecD;		ratio = FFDiv(ratio, delta);	}	else { ratio.l = 0; }		screenx1.l = p[p1a].ScreenX.l - p[p1b].ScreenX.l;	screenx1 = FFMult(ratio, screenx1);	screenx1.l += p[p1b].ScreenX.l;	screeny1.l = p[p1a].ScreenY.l - p[p1b].ScreenY.l;	screeny1 = FFMult(ratio, screeny1);	screeny1.l += p[p1b].ScreenY.l;		delta.l = p[p2a].perspecD - p[p2b].perspecD;	if(delta.l != 0) {		ratio.l = middledepth - p[p2b].perspecD;		ratio = FFDiv(ratio, delta);	}	else { ratio.l = 0; }		screenx2.l = p[p2a].ScreenX.l - p[p2b].ScreenX.l;	screenx2 = FFMult(ratio, screenx2);	screenx2.l += p[p2b].ScreenX.l;	screeny2.l = p[p2a].ScreenY.l - p[p2b].ScreenY.l;	screeny2 = FFMult(ratio, screeny2);	screeny2.l += p[p2b].ScreenY.l;		f1.l = screeny2.l - screeny1.l;	f2.l = screenx2.l - screenx1.l;	if(f1.l == 0) { Slope->l = 0; return(0); }	if(f2.l == 0) { Slope->l = 0; return(1); }	if(labs(f1.l) >= labs(f2.l)) {		*Slope = FFDiv(f2, f1);		return(1);	}	else {		*Slope = FFDiv(f1, f2);		return(0);	}}/*returns the absolute value of the fixed point number with the  greates magnitue of two fixed point numbers*/FFixed      maxmagnitude(FFixed d1, FFixed d2);FFixedmaxmagnitude(FFixed d1, FFixed d2){	if(d1.l < 0) d1.l=-d1.l;	if(d2.l < 0) d2.l=-d2.l;	if(d1.l < d2.l) return d2;	else return d1;}/*finds the screen and texture deltas and changes in deltas for tracing down the left  and right edges of the polygon.*/voidFindDeltaDelta(int deltay, 			   FFixed xl, FFixed dxl, FFixed xr, FFixed dxr,			   FFixed fxl, FFixed dfxl, FFixed fxr, FFixed dfxr,	   			   FFixed fyl, FFixed dfyl, FFixed fyr, FFixed dfyr,				   FFixed *deltafxinit, FFixed *ddfx, int *ddfxshift,   			   FFixed *deltafyinit, FFixed *ddfy, int *ddfyshift,			   int IsTriangular);voidFindDeltaDelta(int deltay, 			   FFixed xl, FFixed dxl, FFixed xr, FFixed dxr,			   FFixed fxl, FFixed dfxl, FFixed fxr, FFixed dfxr,	   			   FFixed fyl, FFixed dfyl, FFixed fyr, FFixed dfyr,				   FFixed *deltafxinit, FFixed *ddfx, int *ddfxshift,   			   FFixed *deltafyinit, FFixed *ddfy, int *ddfyshift,			   int IsTriangular){	FFixed dxinit, dxnext;	FFixed dfxnext, dfxinit;	FFixed dfynext, dfyinit;	int shiftval;	int neg;	FFixed tempfixed, tempfixed2;		dxinit.l = xr.l - xl.l;	dxnext.l = dxinit.l + (dxr.l - dxl.l)*deltay;		if(IsTriangular)	{		if(labs(dxinit.l) >= labs(dxnext.l))		{			dfxinit.l = fxr.l - fxl.l;			dfyinit.l = fyr.l - fyl.l;			*deltafxinit = FFDiv(dfxinit, dxinit);			*deltafyinit = FFDiv(dfyinit, dxinit);			*ddfxshift = *ddfyshift = 0;			ddfx->l = ddfy->l = 0;			return;		}		else		{			dfxnext.l = fxr.l - fxl.l;			dfxnext.l += (dfxr.l - dfxl.l)*deltay;			dfynext.l = fyr.l - fyl.l;			dfynext.l += (dfyr.l - dfyl.l)*deltay;			*deltafxinit = FFDiv(dfxnext, dxnext);			*deltafyinit = FFDiv(dfynext, dxnext);			*ddfxshift = *ddfyshift = 0;			ddfx->l = ddfy->l = 0;			return;		}	}		dfxinit.l = fxr.l - fxl.l;	dfyinit.l = fyr.l - fyl.l;	if(dxinit.l < dxnext.l)	{		tempfixed = dxnext;		tempfixed2.l = dxinit.l << 1;	}	else	{		tempfixed = dxinit;		tempfixed2.l = dxnext.l << 1;	}		if((deltay < 4) || (tempfixed.l < tempfixed2.l))	{		dfxnext.l = dfxinit.l + (dfxr.l - dfxl.l)*deltay;		dfynext.l = dfyinit.l + (dfyr.l - dfyl.l)*deltay;	}	else if(dxinit.l > dxnext.l)	{		dfxnext.l = dfxinit.l + (dfxr.l - dfxl.l)*(deltay>>1);		dfynext.l = dfyinit.l + (dfyr.l - dfyl.l)*(deltay>>1);			dxnext.l = dxinit.l + (dxr.l - dxl.l)*(deltay>>1);	}	else	{		dfxnext.l = dfxinit.l + (dfxr.l - dfxl.l)*deltay;		dfynext.l = dfyinit.l + (dfyr.l - dfyl.l)*deltay;		dfxinit.l += (dfxr.l - dfxl.l)*(deltay>>1);		dfyinit.l += (dfyr.l - dfyl.l)*(deltay>>1);		dxinit.l += (dxr.l - dxl.l)*(deltay>>1);	}		tempfixed = maxmagnitude(dfxnext, dfxinit);	if(tempfixed.l != 0)	{		BIT_WIDTH(tempfixed.l, shiftval);		shiftval = 31 - shiftval;		FFFShift(dfxnext, shiftval);		FFFShift(dfxinit, shiftval);		*ddfxshift = shiftval;	}	else	{		*ddfxshift = 0;	}		tempfixed = maxmagnitude(dfynext, dfyinit);	if(tempfixed.l != 0)	{		BIT_WIDTH(tempfixed.l, shiftval);		shiftval = 31 - shiftval;		FFFShift(dfynext, shiftval);		FFFShift(dfyinit, shiftval);		*ddfyshift = shiftval;	}	else	{		*ddfyshift = 0;	}	if(dxinit.l == 0)	{		dfxinit.l = dfyinit.l = 0;	//wrong--fix	}	else	{		dfxinit = FFDiv(dfxinit, dxinit);		dfyinit = FFDiv(dfyinit, dxinit);	}	if(dxnext.l == 0)	{		dfxnext.l = dfynext.l = 0;	//wrong--fix	}	else	{		dfxnext = FFDiv(dfxnext, dxnext);		dfynext = FFDiv(dfynext, dxnext);	}		if(deltay != 0)	{		ddfx->l = (dfxnext.l - dfxinit.l)/deltay;		ddfy->l = (dfynext.l - dfyinit.l)/deltay;	}	*deltafxinit = dfxinit;	*deltafyinit = dfyinit;}#define DIVPERSCANLINECODE 0#if DIVPERSCANLINECODE/*variable to cause division per scanline, rather than repeated addition*/int DivPerScanLine = FALSE;#endif //DIVPERSCANLINECODE/*draw a texture-mapped polygon with a bileanear approximation of exact  perspective correct texture mapping*/intFFixedLinearTexture8(RenderingParameters *RendSettings,					 PointFFixed *pf, PointFFixed *pt, int plength);intFFixedLinearTexture8(RenderingParameters *RendSettings,					 PointFFixed *pf, PointFFixed *pt, int plength){int index_left=0,index_right;int xOffsetTail;int xOffset= RendSettings->xOffset;int yOffset= RendSettings->yOffset;long toRowBytes= RendSettings->toRowBytes;#if WINDOWSunsigned char huge *y;	   //JAM 30Jun94 fixes blank lines in texturesunsigned char huge *yy;    //JAM 30Jun94 fixes blank lines in textures#elseunsigned char *y;unsigned char *yy;#endifint dyl, dyr, deltay, reset;int dx;int cxr;int i,j;int ytop;int notDone=TRUE;int rval=FALSE;FFixed xl, dxl, xr, dxr, yl, yr, fxl, fdxl, fxr, fdxr, fyl, fdyl, fyr, fdyr;FFixed tempfixed;ShadeEntry *tshade;struct ScanLineInfo LineInfo;void (*ShadedLinearScanFillRoutine)(struct ScanLineInfo *);int BitDepthIndex;FFixed deltafxinit, deltadfx, ddfx;int ddfxshift;FFixed deltafyinit, deltadfy, ddfy;int ddfyshift;unsigned char *currentdith1, *currentdith2, *nextdith1, *nextdith2;#if USE_HMDextern long gHMDOffsetLeft;		// MERGE-HMDextern long gHMDOffsetRight;	// MERGE-HMD#endif USE_HMDif(plength <= 2) return rval;LineInfo.fromRaster = RendSettings->fromRaster;LineInfo.horizontaltexturemask = RendSettings->horizontaltexturemask;LineInfo.verticaltexturemask = RendSettings->verticaltexturemask;LineInfo.horizontalmirrormask = RendSettings->horizontalmirrormask;LineInfo.verticalmirrormask = RendSettings->verticalmirrormask;BitDepthId = RendSettings->BitDepthId;BitDepthIndex = RendSettings->BitDepthIndex;tshade = RendSettings->tshade;for(i=1;i<plength;i++)	{	if(pt[index_left].v.l>pt[i].v.l)index_left=i;	}	ShadedLinearScanFillRoutine = RendSettings->ShadedLinearScanFillRoutine;index_right=index_left;j=0;while(FFRound(pt[index_left].v)==FFRound(pt[i=previousNum(index_left,plength)].v) && ++j<plength)index_left=i;if(j==plength)goto endit;j=0;while(FFRound(pt[index_right].v)==FFRound(pt[i=nextNum(index_right,plength)].v) && ++j<plength)index_right=i;if(j==plength)goto endit;/*the TO points */xl = pt[index_left].h;yl = pt[index_left].v;xr = pt[index_right].h;yr = pt[index_right].v;/*the FROM points */fxl = pf[index_left].h;fyl = pf[index_left].v;fxr = pf[index_right].h;fyr = pf[index_right].v;index_left=previousNum(index_left,plength);index_right=nextNum(index_right,plength);ytop = FFRound(yl);rval=TRUE;switch(BitDepthId) {	case BITDEPTHID4X1:	case BITDEPTHID1:		xOffsetTail = xOffset & 7;		xOffset >>= 3;		break;	case BITDEPTHID2:		xOffsetTail = xOffset & 3;		xOffset >>= 2;		break;	case BITDEPTHID4:		xOffsetTail = xOffset & 1;		xOffset >>= 1;		break;	case BITDEPTHID8:		xOffsetTail = 0;		break;	case BITDEPTHID16:		xOffsetTail = 0;		xOffset <<= 1;		break;//JAM 3-31-94 24/32 bit fix [[[	case BITDEPTHID24:		xOffsetTail = 0;		xOffset += xOffset + xOffset;		break;	case BITDEPTHID32:		xOffsetTail = 0;		xOffset <<= 2;		break;//JAM 3-31-94 24/32 bit fix ]]]		}#if MACINTOSH                    	//GJR 10/13/93// MERGE-HMD [[[#if USE_HMDif ((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX)){y=(unsigned char *)RendSettings->to->GetBaseAddr() + ((yOffset+(ytop << 1))*toRowBytes) + xOffset;if (gHMDOffsetLeft && (gHMD->eye == EYE_LEFT)) y += ((long)(toRowBytes));else if (gHMDOffsetRight && (gHMD->eye == EYE_RIGHT)) y += ((long)(toRowBytes));}else// MERGE-HMD ]]]	y=(unsigned char *)RendSettings->to->GetBaseAddr() + ((yOffset+ytop)*toRowBytes) + xOffset;#elsey=(unsigned char *)RendSettings->to->GetBaseAddr() + ((yOffset+ytop)*toRowBytes) + xOffset;#endif // USE_HMD#elif WINDOWS#if USE_HMD// HMD NOTE: must do similar HMD stuff for windows hereif((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX)){	long ynumber;	ynumber = yOffset+(ytop << 1);	if (gHMDOffsetLeft && (gHMD->eye == EYE_LEFT)) ynumber++;	else if (gHMDOffsetRight && (gHMD->eye == EYE_RIGHT)) ynumber++;	y= RendSettings->to->lpbBmRowAddresses[ynumber] + xOffset;}else	y= RendSettings->to->lpbBmRowAddresses[yOffset+ytop] + xOffset;#else //USE_HMDy= RendSettings->to->lpbBmRowAddresses[yOffset+ytop] + xOffset;#endif //USE_HMD#endif //if MAC elif WINDOWSdyl = FFRound(pt[index_left].v) - FFRound(yl);dyr = FFRound(pt[index_right].v) - FFRound(yr);tempfixed.l = pt[index_left].v.l - yl.l;dxl.l = pt[index_left].h.l - xl.l;dxl = FFDiv(dxl, tempfixed);fdxl.l = pf[index_left].h.l - fxl.l;fdxl = FFDiv(fdxl, tempfixed);fdyl.l = pf[index_left].v.l - fyl.l;fdyl = FFDiv(fdyl, tempfixed);tempfixed.l = pt[index_right].v.l - yr.l;dxr.l = pt[index_right].h.l - xr.l;dxr = FFDiv(dxr, tempfixed);fdxr.l = pf[index_right].h.l - fxr.l;fdxr = FFDiv(fdxr, tempfixed);fdyr.l = pf[index_right].v.l - fyr.l;fdyr = FFDiv(fdyr, tempfixed);/*handle vertical rounding*//*jump down to sample row*/tempfixed.frac = 0;tempfixed.intg = FFRound(yl);tempfixed.l += FixedPointFive.l;tempfixed.l = tempfixed.l - yl.l;xl.l += FFMult(dxl, tempfixed).l;fxl.l += FFMult(fdxl, tempfixed).l;fyl.l += FFMult(fdyl, tempfixed).l;tempfixed.frac = 0;tempfixed.intg = FFRound(yr);tempfixed.l += FixedPointFive.l;tempfixed.l = tempfixed.l - yr.l;xr.l += FFMult(dxr, tempfixed).l;fxr.l += FFMult(fdxr, tempfixed).l;fyr.l += FFMult(fdyr, tempfixed).l;	/*handle rounding*/xr.l += FixedPointFive.l;xl.l += FixedPointFive.l;fxl.l += FixedPointFive.l;fxr.l += FixedPointFive.l;fyl.l += FixedPointFive.l;fyr.l += FixedPointFive.l;/*set up dithering*/if(BitDepthId <= BITDEPTHID8) {	if(ytop & 1) {		currentdith1 = tshade->dith[BitDepthId][2];		currentdith2 = tshade->dith[BitDepthId][3];		nextdith1 = tshade->dith[BitDepthId][0];		nextdith2 = tshade->dith[BitDepthId][1];	}	else {		currentdith1 = tshade->dith[BitDepthId][0];		currentdith2 = tshade->dith[BitDepthId][1];		nextdith1 = tshade->dith[BitDepthId][2];		nextdith2 = tshade->dith[BitDepthId][3];	}}else if(BitDepthId == BITDEPTHID16) {	currentdith1 = currentdith2 = nextdith1 = nextdith2 	= (unsigned char *)(tshade->color16bit);}//JAM 3-31-94 24/32 bit fix [[[else if(BitDepthId == BITDEPTHID24) {	currentdith1 = currentdith2 = nextdith1 = nextdith2 	= (unsigned char *)(tshade->color24bit);}else if(BitDepthId == BITDEPTHID32) {	currentdith1 = currentdith2 = nextdith1 = nextdith2 	= (unsigned char *)(tshade->truecolor);}//JAM 3-31-94 24/32 bit fix ]]]else if(BitDepthId == BITDEPTHID4X1) {	if(ytop & 1)        {		currentdith1 = currentdith2 = (unsigned char *)((unsigned long *) (tshade->color4x1[0]));		nextdith1 = nextdith2 = (unsigned char *)((unsigned long *) (tshade->color4x1[1]));	}	else        {		nextdith1 = nextdith2 = (unsigned char *)((unsigned long *) (tshade->color4x1[0]));		currentdith1 = currentdith2 = (unsigned char *)((unsigned long *) (tshade->color4x1[1]));	}}do	{		if(index_left==index_right)notDone=FALSE;	if(dyl < dyr)		{		deltay=dyl;		reset=1;		dyr-=dyl;		dyl =0;		}	else if(dyr < dyl)		{		deltay=dyr;		reset=2;		dyl-=dyr;		dyr=0;		}	else		{		deltay=dyr;		reset=3;		dyl=dyr=0;		}#if DIVPERSCANLINECODE	if(DivPerScanLine)	{#if MACINTOSH 		ytop += deltay;#endif		while(deltay--)		{			FFixed dfx, dfy;			int remainder;			unsigned char *tempptr;#if WINDOWS			//JAM JCA 23OCT94 this line was moved to the top of the loop--			//it was crashing when the loop was about to exit--yOffset+ytop			//was beyond the end of the array, and although y won't be changed			//since the loop is exiting, the yoffset+ytop address is illegal;			//putting this line at the beginning of the loop solves the            //problem.			#if USE_HMD			if((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX))			{				long ynumber;				ynumber = yOffset+(ytop << 1);				if (gHMDOffsetLeft && (gHMD->eye == EYE_LEFT)) ynumber++;				else if (gHMDOffsetRight && (gHMD->eye == EYE_RIGHT)) ynumber++;				y= RendSettings->to->lpbBmRowAddresses[ynumber] + xOffset;			}			else				y= RendSettings->to->lpbBmRowAddresses[yOffset+ytop] + xOffset;			#else //USE_HMD			y= RendSettings->to->lpbBmRowAddresses[yOffset+ytop] + xOffset;			#endif#endif //WINDOWS			cxr = xr.intg;						/*handle different bit depth requirements*/			remainder = xOffsetTail +xl.intg;			switch(BitDepthId) {				case BITDEPTHID1:					yy = y + (remainder >> 3);					InitialMaskIndex = remainder & 7;					break;				case BITDEPTHID2:					yy = y + (remainder >> 2);					InitialMaskIndex = remainder & 3;					break;				case BITDEPTHID4:					yy = y + (remainder >> 1);					InitialMaskIndex = remainder & 1;					break;				case BITDEPTHID8: 					yy = y + remainder;					break;				case BITDEPTHID16:					yy = y + (remainder << 1);					break;//JAM 3-31-94 24/32 bit fix [[[				case BITDEPTHID24:					yy = y + remainder + remainder + remainder;					break;				case BITDEPTHID32:					yy = y + (remainder << 2);					break;//JAM 3-31-94 24/32 bit fix ]]]#if WINDOWS				case BITDEPTHID4X1:			#if USE_HMD			// HMD NOTE: must do similar HMD stuff for windows here				if((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX))				{					long ynumber;					ynumber = RendSettings->to->yOffset+(ytop << 1);					if (gHMDOffsetLeft && (gHMD->eye == EYE_LEFT)) ynumber +=1;					else if (gHMDOffsetRight && (gHMD->eye == EYE_RIGHT)) ynumber +=1;					LineInfo.offset4x1 = gwBmWidthBytes;					LineInfo.yy0 = RendSettings->to->lpbBmRowAddresses[ynumber];               		LineInfo.yy0 += (remainder + RendSettings->to->xOffset)>>3;					InitialMaskIndex = remainder & 7;					yy = y;				}				else				{					LineInfo.offset4x1 = gwBmWidthBytes;					LineInfo.yy0 = RendSettings->to->lpbBmRowAddresses[ytop+RendSettings->to->yOffset];					LineInfo.yy0 += (remainder + RendSettings->to->xOffset)>>3;					InitialMaskIndex = remainder & 7;					yy = y;				}			#else //USE_HMD					LineInfo.offset4x1 = gwBmWidthBytes;					LineInfo.yy0 = RendSettings->to->lpbBmRowAddresses[ytop+RendSettings->to->yOffset];					LineInfo.yy0 += (remainder + RendSettings->to->xOffset)>>3;					InitialMaskIndex = remainder & 7;					yy = y;			#endif //USE_HMD			break;#endif //WINDOWS			}			cxr-=xl.intg;	/*this is the length of the drawn pixels */						/*Draw the scan-line*/			if(cxr>0)		// Only do draws and divides if pixels on line GJR082893			{				/*0 fraction implies center of pixel, center of texel*/				tempfixed.frac = 0;				tempfixed.intg = xr.intg - xl.intg;				tempfixed.l = xr.l - xl.l;				dfx.l = fxr.l - fxl.l;				dfx = FFDiv(dfx, tempfixed);				dfy.l = fyr.l - fyl.l;				dfy = FFDiv(dfy, tempfixed);				/*advance to pixel center.  Currently not done--why bother?*/				/*						tempfixed.frac = 0;				tempfixed.intg = FFRound(xl);				tempfixed.l += FixedPointFive.l;				tempfixed.l -= xl.l;								fx.l += FFMult(tempfixed, dfx).l;				fy.l += FFMult(tempfixed, dfy).l;				*/															/*set up dither and get ready for next line's dither*/						LineInfo.dith1 = currentdith1;				LineInfo.dith2 = currentdith2;				tempptr = currentdith1;				currentdith1 = nextdith1;				nextdith1 = tempptr;				tempptr = currentdith2;				currentdith2 = nextdith2;				nextdith2 = tempptr;								/*fill in info required to draw scanline*/				LineInfo.NumOfPixels = cxr;				LineInfo.yy = (unsigned char *) yy;	   //JAM 30Jun94 fixes blank lines in textures				LineInfo.x = fxl;				LineInfo.dx = dfx;				LineInfo.y = fyl;				LineInfo.dy = dfy;									/*do it!*/				(*ShadedLinearScanFillRoutine)(& LineInfo);			}			/*update info for next line*/#if MACINTOSH                    	//GJR 10/13/93			y+=toRowBytes;			// MERGE-HMD [[[			#if USE_HMD			if ((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX))				y+=toRowBytes;			#endif // USE_HMD			// MERGE-HMD ]]]#elif WINDOWS			ytop++;			//JAM JCA 23OCT94 this line was moved to the top of the loop--			//it was crashing when the loop was about to exit--yOffset+ytop			//was beyond the end of the array, and although y won't be changed			//since the loop is exiting, the yoffset+ytop address is illegal;			//putting this line at the beginning of the loop solves the            //problem.//			y= RendSettings->to->lpbBmRowAddresses[yOffset+ytop] + xOffset;#endif			fxl.l += fdxl.l;			fxr.l += fdxr.l;			fyl.l += fdyl.l;			fyr.l += fdyr.l;			xl.l += dxl.l;			xr.l += dxr.l;		}	}	else#endif //DIVPERSCANLINECODE	{		/*the texture deltas should be almost constant since this is a linear		  rendering.  However, we allow for a linear change in the texture deltas,		  to account for non-linearities introduced by the fact that this is a		  linear approximation of a perspective correct section of a polygon*/		  		if((index_left == index_right) ||			(nextNum(index_left, plength) == previousNum(index_right, plength)))		{			i = TRUE;		}		else		{			i = FALSE;		}		FindDeltaDelta(deltay, xl, dxl, xr, dxr, fxl, fdxl, fxr, fdxr, fyl, fdyl, fyr, fdyr,				   &deltafxinit, &ddfx, &ddfxshift, &deltafyinit, &ddfy, &ddfyshift, i);		deltadfx.l = deltadfy.l = 0;	#if MACINTOSH 		ytop += deltay;#endif		fxr.l += fdxr.l * deltay;		fyr.l += fdyr.l * deltay;		while(deltay--)		{			FFixed dfx, dfy;			int remainder;			unsigned char *tempptr;#if WINDOWS			//JAM JCA 23OCT94 this line was moved to the top of the loop--			//it was crashing when the loop was about to exit--yOffset+ytop			//was beyond the end of the array, and although y won't be changed			//since the loop is exiting, the yoffset+ytop address is illegal;			//putting this line at the beginning of the loop solves the            //problem.			#if USE_HMD			// HMD NOTE: must do similar HMD stuff for windows here			if((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX))			{				long ynumber;				ynumber = yOffset+(ytop << 1);				if (gHMDOffsetLeft && (gHMD->eye == EYE_LEFT)) ynumber++;				else if (gHMDOffsetRight && (gHMD->eye == EYE_RIGHT)) ynumber++;				y= RendSettings->to->lpbBmRowAddresses[ynumber] + xOffset;			}			else				y= RendSettings->to->lpbBmRowAddresses[yOffset+ytop] + xOffset;			#else //USE_HMD			y= RendSettings->to->lpbBmRowAddresses[yOffset+ytop] + xOffset;			#endif //USE_HMD#endif //WINDOWS			cxr = xr.intg;						/*handle different bit depth requirements*/			remainder = xOffsetTail +xl.intg;			switch(BitDepthId) {				case BITDEPTHID1:					yy = y + (remainder >> 3);					InitialMaskIndex = remainder & 7;					break;				case BITDEPTHID2:					yy = y + (remainder >> 2);					InitialMaskIndex = remainder & 3;					break;				case BITDEPTHID4:					yy = y + (remainder >> 1);					InitialMaskIndex = remainder & 1;					break;				case BITDEPTHID8: 					yy = y + remainder;					break;				case BITDEPTHID16:					yy = y + (remainder << 1);					break;//JAM 3-31-94 24/32 bit fix [[[				case BITDEPTHID24:					yy = y + remainder + remainder + remainder;					break;				case BITDEPTHID32:					yy = y + (remainder << 2);					break;//JAM 3-31-94 24/32 bit fix ]]]#if WINDOWS				case BITDEPTHID4X1:			#if USE_HMD			// HMD NOTE: must do similar HMD stuff for windows here				if((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX))				{					long ynumber;					ynumber = RendSettings->to->yOffset+(ytop << 1);					if (gHMDOffsetLeft && (gHMD->eye == EYE_LEFT)) ynumber +=1;					else if (gHMDOffsetRight && (gHMD->eye == EYE_RIGHT)) ynumber +=1;					LineInfo.offset4x1 = gwBmWidthBytes;					LineInfo.yy0 = RendSettings->to->lpbBmRowAddresses[ynumber];               		LineInfo.yy0 += (remainder + RendSettings->to->xOffset)>>3;					InitialMaskIndex = remainder & 7;					yy = y;				}				else				{					LineInfo.offset4x1 = gwBmWidthBytes;					LineInfo.yy0 = RendSettings->to->lpbBmRowAddresses[ytop+RendSettings->to->yOffset];					LineInfo.yy0 += (remainder + RendSettings->to->xOffset)>>3;					InitialMaskIndex = remainder & 7;					yy = y;				}			#else //USE_HMD					LineInfo.offset4x1 = gwBmWidthBytes;					LineInfo.yy0 = RendSettings->to->lpbBmRowAddresses[ytop+RendSettings->to->yOffset];					LineInfo.yy0 += (remainder + RendSettings->to->xOffset)>>3;					InitialMaskIndex = remainder & 7;					yy = y;			#endif //USE_HMD			break;#endif //WINDOWS			}						cxr-=xl.intg;	/*this is the length of the drawn pixels */						/*Draw the scan-line*/			if(cxr>0)		// Only do draws and divides if pixels on line GJR082893			{				/*0 fraction implies center of pixel, center of texel*/								dfx.l = (deltafxinit.l + deltadfx.l) >> ddfxshift;				dfy.l = (deltafyinit.l + deltadfy.l) >> ddfyshift;				/*advance to pixel center.  Currently not done--why bother?*/				/*						tempfixed.frac = 0;				tempfixed.intg = FFRound(xl);				tempfixed.l += FixedPointFive.l;				tempfixed.l -= xl.l;								fx.l += FFMult(tempfixed, dfx).l;				fy.l += FFMult(tempfixed, dfy).l;				*/															/*set up dither and get ready for next line's dither*/						LineInfo.dith1 = currentdith1;				LineInfo.dith2 = currentdith2;				tempptr = currentdith1;				currentdith1 = nextdith1;				nextdith1 = tempptr;				tempptr = currentdith2;				currentdith2 = nextdith2;				nextdith2 = tempptr;								/*fill in info required to draw scanline*/				LineInfo.NumOfPixels = cxr;				LineInfo.yy = (unsigned char *)yy;	   //JAM 30Jun94 fixes blank lines in textures				LineInfo.x = fxl;				LineInfo.dx = dfx;				LineInfo.y = fyl;				LineInfo.dy = dfy;									/*do it!*/				(*ShadedLinearScanFillRoutine)(& LineInfo);			}			/*update info for next line*/#if MACINTOSH                    	//GJR 10/13/93			y+=toRowBytes;			// MERGE-HMD [[[			#if USE_HMD			if ((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX))				y+=toRowBytes;			#endif // USE_HMD			// MERGE-HMD ]]]#elif WINDOWS			ytop++;			//JAM JCA 23OCT94 this line was moved to the top of the loop--			//it was crashing when the loop was about to exit--yOffset+ytop			//was beyond the end of the array, and although y won't be changed			//since the loop is exiting, the yoffset+ytop address is illegal;			//putting this line at the beginning of the loop solves the            //problem.//			y= RendSettings->to->lpbBmRowAddresses[yOffset+ytop] + xOffset;#endif			fxl.l += fdxl.l;			deltadfx.l += ddfx.l;			fyl.l += fdyl.l;			deltadfy.l += ddfy.l;			xl.l += dxl.l;			xr.l += dxr.l;		}	}	if(notDone)	{	if(reset&1)		{		yl = pt[index_left].v;		xl = pt[index_left].h;		fxl = pf[index_left].h;		fyl = pf[index_left].v;		do	{			index_left=previousNum(index_left,plength);			dyl = FFRound(pt[index_left].v) - FFRound(yl);			tempfixed.l = pt[index_left].v.l - yl.l;			dxl.l = pt[index_left].h.l - xl.l;			dxl = FFDiv(dxl, tempfixed);						fdxl.l = pf[index_left].h.l - fxl.l;			fdxl = FFDiv(fdxl, tempfixed);			fdyl.l = pf[index_left].v.l - fyl.l;			fdyl = FFDiv(fdyl, tempfixed);			}while(FFRound(yl)>FFRound(pt[index_left].v) && notDone && index_left!=index_right);			/*jump down to sample row*/			tempfixed.frac = 0;			tempfixed.intg = FFRound(yl);			tempfixed.l += FixedPointFive.l;			tempfixed.l = tempfixed.l - yl.l;			xl.l += FFMult(dxl, tempfixed).l;			fxl.l += FFMult(fdxl, tempfixed).l;			fyl.l += FFMult(fdyl, tempfixed).l;			/*handle rounding*/			xl.l += FixedPointFive.l;			fxl.l += FixedPointFive.l;			fyl.l += FixedPointFive.l;		}	if((reset&2) && index_left != index_right)		{		yr = pt[index_right].v;		xr = pt[index_right].h;		fxr = pf[index_right].h;		fyr = pf[index_right].v;		do	{			index_right=nextNum(index_right,plength);			dyr = FFRound(pt[index_right].v) - FFRound(yr);			tempfixed.l = pt[index_right].v.l - yr.l;						dxr.l = pt[index_right].h.l - xr.l;			dxr = FFDiv(dxr, tempfixed);			fdxr.l = pf[index_right].h.l - fxr.l;			fdxr = FFDiv(fdxr, tempfixed);			fdyr.l = pf[index_right].v.l - fyr.l;			fdyr = FFDiv(fdyr, tempfixed);			}while(FFRound(yr)>FFRound(pt[index_right].v) && notDone && index_left!=index_right);				/*jump down to sample row*/			tempfixed.frac = 0;			tempfixed.intg = FFRound(yr);			tempfixed.l += FixedPointFive.l;			tempfixed.l = tempfixed.l - yr.l;			xr.l += FFMult(dxr, tempfixed).l;			fxr.l += FFMult(fdxr, tempfixed).l;			fyr.l += FFMult(fdyr, tempfixed).l;			/*handle rounding*/			xr.l += FixedPointFive.l;			fxr.l += FixedPointFive.l;			fyr.l += FixedPointFive.l;		}		}	}while(notDone);endit:return rval;}/*routine which checks to see if linear interpolation is sufficiently accurate*/int AlwaysDoLinear = 0;intlinearisokay(Point3DAllInfo *p, int plength);intlinearisokay(Point3DAllInfo *p, int plength){unsigned long wmin, wmax, tempulong;int i;if(AlwaysDoLinear) return 1;wmax = wmin = p[0].perspecD;for(i=0;i<plength;i++){	tempulong = p[i].perspecD;	if(tempulong < wmin) wmin = tempulong;	else if(tempulong > wmax) wmax = tempulong;}//if(wmin + (wmin >> 6) >= wmax) return 1;if(wmin == wmax) return 1;else return 0;#if 0FFixed wmax, wmin, ratio;int screenwidth;int i;FFixed xmax, xmin, ymax, ymin;if(AlwaysDoLinear) return 1;/*need to find z1/z2, but occasionally perspecD (an unsigned long) will  cause the fixed z1 or z2 to be negative.  The preshift handles this, while  costing little, since z1.l and z2.l tend to be over 1000 at least--HACK*//*uses manhattan distance.  actual would allow linear more often*/xmax = xmin = p[0].ScreenX;ymax = ymin = p[0].ScreenY;wmax.l = wmin.l = p[0].perspecD;for(i=1;i<plength;i++){	if(p[i].ScreenX.l > xmax.l) xmax.l = p[i].ScreenX.l;	else if(p[i].ScreenX.l < xmin.l) xmin.l = p[i].ScreenX.l;	if(p[i].ScreenY.l > ymax.l) ymax.l = p[i].ScreenY.l;	else if(p[i].ScreenY.l < ymin.l) ymin.l = p[i].ScreenY.l;	if(p[i].perspecD > wmax.l) wmax.l = p[i].perspecD;	else if(p[i].perspecD < wmin.l) wmin.l = p[i].perspecD;}ratio = FFDiv(wmax, wmin);if(ratio.intg >= 7) return(0);screenwidth = (xmax.intg - xmin.intg + ymax.intg - ymin.intg) >> 1;ratio.intg--;ratio.l >>= 2;ratio.l *= screenwidth;if(ratio.intg != 0) return(0);else return(1);#endif}						long maxpixelerror = 0x00010000;int ShowSubPolys = 0;/*finds the screen intersection of a segment defined by two screen points  with associated depths and a line of constant depth*/voidIntersectSide(unsigned long wdivide, Point3DAllInfo *p1, Point3DAllInfo *p2,			  Point3DAllInfo *intersect, FFixed *ratioptr);voidIntersectSide(unsigned long wdivide, Point3DAllInfo *p1, Point3DAllInfo *p2,			  Point3DAllInfo *intersect, FFixed *ratioptr){	FFixed Ratio, tempfixed1, tempfixed2;	int shiftval, reverseratioflag;		tempfixed1.l = p2->perspecD - p1->perspecD;	tempfixed2.l = wdivide - p1->perspecD;	Ratio = FFDiv(tempfixed2, tempfixed1);	tempfixed1.l = p2->ScreenX.l - p1->ScreenX.l;	intersect->ScreenX.l = p1->ScreenX.l + FFMult(Ratio, tempfixed1).l;	tempfixed1.l = p2->ScreenY.l - p1->ScreenY.l;	intersect->ScreenY.l = p1->ScreenY.l + FFMult(Ratio, tempfixed1).l;	intersect->perspecD = wdivide;	if(ratioptr != NULL)	{		*ratioptr = Ratio;	}}/*finds the screen intersection of a segment defined by two screen points  with associated depths and a vertical screen line*/voidIntersectSideX(FFixed xdivide, Point3DAllInfo *p1, Point3DAllInfo *p2,			   Point3DAllInfo *intersect, FFixed *ratioptr);voidIntersectSideX(FFixed xdivide, Point3DAllInfo *p1, Point3DAllInfo *p2,			   Point3DAllInfo *intersect, FFixed *ratioptr){	FFixed Ratio, tempfixed1, tempfixed2;	int shiftval, reverseratioflag;		tempfixed1.l = p2->ScreenX.l - p1->ScreenX.l;	tempfixed2.l = xdivide.l - p1->ScreenX.l;	Ratio = FFDiv(tempfixed2, tempfixed1);	intersect->ScreenX = xdivide;	tempfixed1.l = p2->ScreenY.l - p1->ScreenY.l;	intersect->ScreenY.l = p1->ScreenY.l + FFMult(Ratio, tempfixed1).l;	tempfixed1.l = p2->perspecD - p1->perspecD;	intersect->perspecD = p1->perspecD + FFMult(Ratio, tempfixed1).l;	if(ratioptr != NULL)	{		*ratioptr = Ratio;	}}/*finds the intersection of a segment defined by two points  with associated depths and a line of constant depth, including the  perspective corrected texture points*/voidFindIntersection(unsigned long wdivide,				 Point3DAllInfo *p1, Point3DAllInfo *p2, Point3DAllInfo *pntrsct,				 PointFFixed *texture1, PointFFixed *texture2, PointFFixed *txtrntrsct);voidFindIntersection(unsigned long wdivide,				 Point3DAllInfo *p1, Point3DAllInfo *p2, Point3DAllInfo *pntrsct,				 PointFFixed *texture1, PointFFixed *texture2, PointFFixed *txtrntrsct){	FFixed ratio;		IntersectSide(wdivide, p2, p1, pntrsct, &ratio);		PerspectiveCorrectBetween(p2, texture2, p1, texture1, ratio, pntrsct, txtrntrsct);		}/*finds the intersection of a segment defined by two points  with associated depths and a vertical screen line, including the  perspective corrected texture points*/voidFindIntersectionX(FFixed xdivide,				  Point3DAllInfo *p1, Point3DAllInfo *p2, Point3DAllInfo *pntrsct,				  PointFFixed *texture1, PointFFixed *texture2, PointFFixed *txtrntrsct);voidFindIntersectionX(FFixed xdivide,			 	  Point3DAllInfo *p1, Point3DAllInfo *p2, Point3DAllInfo *pntrsct,				  PointFFixed *texture1, PointFFixed *texture2, PointFFixed *txtrntrsct){	FFixed ratio;		IntersectSideX(xdivide, p2, p1, pntrsct, &ratio);		PerspectiveCorrectBetween(p2, texture2, p1, texture1, ratio, pntrsct, txtrntrsct);	}/*slices a polygon into two polygons with a line defined by a constant depth value*/voidDivideOnConstantDepthLine(PointFFixed **textureptr, Point3DAllInfo **pptr, int *plengthptr,				 		  PointFFixed *texture2, PointFFixed *p2, int *plength2ptr,				 		  unsigned long wdivide, int closestdepthindex);voidDivideOnConstantDepthLine(PointFFixed **textureptr, Point3DAllInfo **pptr, int *plengthptr,				 		  PointFFixed *texture2, PointFFixed *p2, int *plengthptr2,				 		  unsigned long wdivide, int closestdepthindex){	int index, oldindex, index1, index2;	PointFFixed *texture, *texture1;	Point3DAllInfo *p, *p1;	int plength = *plengthptr;	Point3DAllInfo IntersectPt;	PointFFixed textureIntersect;		p = *pptr;	texture = *textureptr;	p1 = gettemparray1B();	texture1 = gettemparray2B();		index1 = index2 = 0;	index = closestdepthindex;	while(p[index].perspecD > wdivide)	{		p2[index2].h = p[index].ScreenX;		p2[index2].v = p[index].ScreenY;		texture2[index2] = texture[index];		oldindex = index;		index = nextNum(index, plength);		index2++;	}	FindIntersection(wdivide, &(p[oldindex]), &(p[index]), &IntersectPt,					 &(texture[oldindex]), &(texture[index]), &textureIntersect);	p2[index2].h = IntersectPt.ScreenX;	p2[index2].v = IntersectPt.ScreenY;	p1[index1] = IntersectPt;	texture2[index2] = texture1[index1] = textureIntersect;	index1++;	index2++;		if(p[index].perspecD != wdivide)	{		p1[index1] = p[index];		texture1[index1] = texture[index];		index1++;	}	oldindex = index;	index = nextNum(index, plength);		while(p[index].perspecD < wdivide)	{		p1[index1] = p[index];		texture1[index1] = texture[index];		oldindex = index;		index = nextNum(index, plength);		index1++;	}	FindIntersection(wdivide, &(p[index]), &(p[oldindex]), &IntersectPt,					 &(texture[index]), &(texture[oldindex]), &textureIntersect);	p2[index2].h = IntersectPt.ScreenX;	p2[index2].v = IntersectPt.ScreenY;	texture2[index2] = texture1[index1] = textureIntersect;	p1[index1] = IntersectPt;	index1++;	index2++;		if(index != closestdepthindex)	{		if(p[index].perspecD != wdivide)		{			p2[index2].h = p[index].ScreenX;			p2[index2].v = p[index].ScreenY;			texture2[index2] = texture[index];			index2++;		}				oldindex = index;		index = nextNum(index, plength);				while(index != closestdepthindex)		{			p2[index2].h = p[index].ScreenX;			p2[index2].v = p[index].ScreenY;			texture2[index2] = texture[index];			oldindex = index;			index = nextNum(index, plength);			index2++;		}	}		*plengthptr = index1;	*textureptr = texture1;	*pptr = p1;	*plengthptr2 = index2;	}/*finds the change in one-over-depth with respect to x or y between two points,  and multiplies this slope by the maximum pixel error*/FFixedFind2PointWSlope(Point3DAllInfo *p1, Point3DAllInfo *p2);FFixedFind2PointWSlope(Point3DAllInfo *p1, Point3DAllInfo *p2){	FFixed dx, dy, dw, dist, tempfixed, slope;	int width1, width2, widthB;		dx.l = p2->ScreenX.l - p1->ScreenX.l;	dy.l = p2->ScreenY.l - p1->ScreenY.l;	dist.l = max(labs(dx.l), labs(dy.l));		dw.l = p1->perspecD - p2->perspecD;	if(dw.l < 0) dw.l = -dw.l;	slope = FFDiv(dw, dist);	tempfixed.l = maxpixelerror;	return(FFMult(slope, tempfixed));}/*finds the depth to divide a segment between two points in such a way that  a linear-approximation texture mapping will give an error of no more than  maxpixels error*/unsigned longFindDepthDivide(Point3DAllInfo *p1, Point3DAllInfo *p2);unsigned longFindDepthDivide(Point3DAllInfo *p1, Point3DAllInfo *p2){	unsigned long DivisionW;	FFixed WSlope;	FFixed tempfixed1, tempfixed2;	int shiftval;		if(p2->perspecD > p1->perspecD)	{//		DEBUGGER();		DivisionW = p2->perspecD - 1;		return(DivisionW);	}		BIT_WIDTH(p1->perspecD, shiftval);	shiftval = 22 - shiftval;	if(shiftval < 0) shiftval = 0;			p1->perspecD <<= shiftval;	p2->perspecD <<= shiftval;		WSlope = Find2PointWSlope(p1, p2);	if(WSlope.l == 0)	{		p1->perspecD >>= shiftval;		p2->perspecD >>= shiftval;		DivisionW = p2->perspecD - 1;		return(DivisionW);	}	tempfixed1.l = p1->perspecD;	tempfixed1 = FFMult(tempfixed1, WSlope);	tempfixed2.l = FastFixedSquareRoot(tempfixed1).l << 1;	DivisionW = p1->perspecD + WSlope.l - tempfixed2.l;	if(DivisionW >= p1->perspecD)	{		p1->perspecD >>= shiftval;		p2->perspecD >>= shiftval;		DivisionW = p2->perspecD - 1;		return(DivisionW);	}	p1->perspecD >>= shiftval;	p2->perspecD >>= shiftval;	DivisionW >>= shiftval;	return(DivisionW);}#define NOSUBDIVISION 0#define DIVIDEALONGDEPTHLINE 1#define DIVIDEATVERTICALLINE 2/*traces along a polygon until a point at whicha polygon edge needs to be divided  in order for a linear texture mapping approximation to be sufficiently accurate.  returns NOSUBDIVISION if no such division is necessary*/intTracePolygonToMaxerror(PointFFixed *texture, Point3DAllInfo *p, int plength,					   unsigned long *wdivide, FFixed *xdivide, int *closestindexptr);intTracePolygonToMaxerror(PointFFixed *texture, Point3DAllInfo *p, int plength,					   unsigned long *wdivide, FFixed *xdivide, int *closestindexptr){	int closestindex, side1index, side1oldindex, side2index, side2oldindex;	unsigned long closestperspecD, furthestperspecD, tempulong;	unsigned long worstcasedivisionval;	long side1w, side2w, scanlineerror;	int i;	Point3DAllInfo IntersectPt;	Point3DAllInfo *pt1ptr;		if(plength <= 2) return(NOSUBDIVISION);		/*find closest point*/	closestindex = 0;	closestperspecD = p[0].perspecD;	furthestperspecD = closestperspecD;	for(i=1;i<plength;i++)	{		tempulong = p[i].perspecD;		if(tempulong > closestperspecD)		{			closestperspecD = p[i].perspecD;			closestindex = i;		}		else		{			if(tempulong < furthestperspecD)			{				furthestperspecD = tempulong;			}		}	}	*closestindexptr = closestindex;	if(closestperspecD > MinimumDepthStep)	{		worstcasedivisionval = closestperspecD - MinimumDepthStep;	}	else	{		worstcasedivisionval = furthestperspecD - 1;	}		/*move to next closest point in both directions*/	side1oldindex = side2oldindex = closestindex;	side1index = nextNum(closestindex, plength);	while(p[side1index].perspecD == closestperspecD)	{		side1oldindex = side1index;		side1index = nextNum(side1index, plength);	}	side2index = previousNum(closestindex, plength);	while(p[side2index].perspecD == closestperspecD)	{		side2oldindex = side2index;		side2index = previousNum(side2index, plength);	}		/*determine worst case--side1, side2, or scanline, assuming division along	  constant depth line*/	/*find individual errors.  NOTE  we could reduce math a lot by	  1: saving sqrt values and 2: only computing sqrt ratios once when we can.	     PLUS, it might be wasteful to first determine error, and later determine	     how far we can go without error--might just determine how far and use	     that.  Finally, we can gain by throwing out obvious cases, e.g. if one 	     side or scanline goes through the same or more depth (with the same	     starting depth) over the same or more pixels, it's obviously worse.  might	     get heuristics for other obvious cases.	*/	for(;;){	/*could special-case when they're equal depth*/	if(p[side1index].perspecD >= p[side2index].perspecD)	{		tempulong = p[side1index].perspecD;		pt1ptr = &(p[side1index]);		side1w = FindDepthDivide(&(p[side1oldindex]), pt1ptr);		IntersectSide(tempulong, &(p[side2oldindex]), &(p[side2index]),					  &IntersectPt, NULL);		side2w = FindDepthDivide(&(p[side2oldindex]), &IntersectPt);	}	else	{		tempulong = p[side2index].perspecD;		pt1ptr = &(p[side2index]);		side2w = FindDepthDivide(&(p[side2oldindex]), pt1ptr);		IntersectSide(tempulong, &(p[side1oldindex]), &(p[side1index]),					  &IntersectPt, NULL);		side1w = FindDepthDivide(&(p[side1oldindex]), &IntersectPt);	}	if(side2w > side1w) side1w = side2w;	if(side1w > worstcasedivisionval) side1w = worstcasedivisionval;	if(side1w > tempulong)	{		if((tempulong > p[side2oldindex].perspecD) ||		  (tempulong > p[side1oldindex].perspecD))		{	//			AlertMessage("Debugger Stop 2");			DEBUGGER(); }		*wdivide = side1w;		return (DIVIDEALONGDEPTHLINE);	}		if((p[side1index].perspecD == furthestperspecD) &&	  (p[side2index].perspecD == furthestperspecD))	{		return(NOSUBDIVISION);	}		if(p[side1index].perspecD >= p[side2index].perspecD)	{		tempulong = p[side1index].perspecD;		do		{			side1oldindex = side1index;			side1index = nextNum(side1index, plength);		} while(p[side1index].perspecD == tempulong);	}	else	{		tempulong = p[side2index].perspecD;		do		{			side2oldindex = side2index;			side2index = previousNum(side2index, plength);		} while(p[side2index].perspecD == tempulong);	}}		  	/*if worst case results in error*/		/*if worst case is side1 or side2, we want to divide on constant z line.		  figure where to divide and return proper info*/				/*worst case is scanline.  first idea is to divide at z, recheck scanlines		  for not-shallow cases, and divide vertically or perpendicular for shallow*/		/*worst case doesn't result in error.  go to next closest point*/		  }  /*find a bounding parallelogram for the polygon.  The bounding parallelogram  has two sides which are parallel to axes (h or v) and two which are  along constant depth lines*/voidMakeParallelogram(Point3DAllInfo *p, int plength, Parallelogram *prllelgrm);voidMakeParallelogram(Point3DAllInfo *p, int plength, Parallelogram *prllelgrm){FFixed wmax, wmin, ratio;int wmaxindex, wminindex;int xmaxindex;int screenwidth;int i;FFixed xmax, xmin, ymax, ymin;FFixed FF1, FF2;/*find extremes*/xmax = xmin = p[0].ScreenX;xmaxindex = 0;ymax = ymin = p[0].ScreenY;wmax.l = wmin.l = p[0].perspecD;wmaxindex = wminindex = 0;for(i=1;i<plength;i++){	if(p[i].ScreenX.l > xmax.l) { xmax.l = p[i].ScreenX.l; xmaxindex = i; }	else if(p[i].ScreenX.l < xmin.l) xmin.l = p[i].ScreenX.l;	if(p[i].ScreenY.l > ymax.l) ymax.l = p[i].ScreenY.l;	else if(p[i].ScreenY.l < ymin.l) ymin.l = p[i].ScreenY.l;	if(p[i].perspecD > wmax.l) { wmax.l = p[i].perspecD; wmaxindex = i; }	else if(p[i].perspecD < wmin.l) { wmin.l = p[i].perspecD; wminindex = i; }}	prllelgrm->SlopeIsSteep = GlobalSlopeIsSteep;	prllelgrm->Slope = GlobalConstantDepthSlope;	if(prllelgrm->SlopeIsSteep)	{		FF1.l = ymin.l - p[wminindex].ScreenY.l;		FF1.l = FFMult(FF1, prllelgrm->Slope).l + p[wminindex].ScreenX.l;		FF2.l = ymin.l - p[wmaxindex].ScreenY.l;		FF2.l = FFMult(FF2, prllelgrm->Slope).l + p[wmaxindex].ScreenX.l;		prllelgrm->ymin = ymin;		prllelgrm->x1 = FF2;		prllelgrm->x2 = FF1;	}	else	{		FF1.l = xmin.l - p[wminindex].ScreenX.l;		FF1.l = FFMult(FF1, prllelgrm->Slope).l + p[wminindex].ScreenY.l;		FF2.l = xmin.l - p[wmaxindex].ScreenX.l;		FF2.l = FFMult(FF2, prllelgrm->Slope).l + p[wmaxindex].ScreenY.l;//		prllelgrm->xmin = xmin;		prllelgrm->y1 = FF2;		prllelgrm->y2 = FF1;		prllelgrm->x1 = xmin;		prllelgrm->x2 = xmax;	}	prllelgrm->MaxDepthIndex = wminindex;	prllelgrm->MinDepthIndex = wmaxindex;	prllelgrm->OneOverMaxDepth = wmin;	prllelgrm->OneOverMinDepth = wmax;	prllelgrm->MaxScreenXIndex = xmaxindex;}/*find the depth at which we must divide a parallelogram in order to guarantee  linear texture mapping is sufficiently accurate*/intFindDivisionDepth(Parallelogram *prllelgrm, unsigned long *wdivide);intFindDivisionDepth(Parallelogram *prllelgrm, unsigned long *wdivide){	Point3DAllInfo p1, p2;		p1.ScreenY.l = p2.ScreenY.l = 0;	p1.ScreenX = prllelgrm->x1;	p2.ScreenX = prllelgrm->x2;	p1.perspecD = prllelgrm->OneOverMaxDepth.l;	p2.perspecD = prllelgrm->OneOverMinDepth.l;	*wdivide = FindDepthDivide(&p2, &p1);	if(*wdivide > p2.perspecD - MinimumDepthStep)	{		*wdivide = p2.perspecD - MinimumDepthStep;	}	if(*wdivide <= p1.perspecD) return(0);	else return(1);}voidDivideOnConstantDepthLine2(PointFFixed **textureptr, Point3DAllInfo **pptr, int *plengthptr,				 		  PointFFixed *texture2, Point3DAllInfo *p2, int *plength2ptr,				 		  unsigned long wdivide, int closestdepthindex);voidDivideOnConstantDepthLine2(PointFFixed **textureptr, Point3DAllInfo **pptr, int *plengthptr,				 		  PointFFixed *texture2, Point3DAllInfo *p2, int *plengthptr2,				 		  unsigned long wdivide, int closestdepthindex){	int index, oldindex, index1, index2;	PointFFixed *texture, *texture1;	Point3DAllInfo *p, *p1;	int plength = *plengthptr;	Point3DAllInfo IntersectPt;	PointFFixed textureIntersect;		p = *pptr;	texture = *textureptr;	p1 = gettemparray1();	texture1 = gettemparray2();		index1 = index2 = 0;	index = closestdepthindex;		if(p[index].perspecD <= wdivide) 	{//		AlertMessage("Debugger Stop 3");		DEBUGGER(); }		while(p[index].perspecD > wdivide)	{		p2[index2] = p[index];		texture2[index2] = texture[index];		oldindex = index;		index = nextNum(index, plength);		index2++;	}	FindIntersection(wdivide, &(p[oldindex]), &(p[index]), &IntersectPt,					 &(texture[oldindex]), &(texture[index]), &textureIntersect);	p2[index2] = IntersectPt;	p1[index1] = IntersectPt;	texture2[index2] = texture1[index1] = textureIntersect;	index1++;	index2++;		if(p[index].perspecD != wdivide)	{		p1[index1] = p[index];		texture1[index1] = texture[index];		index1++;	}	oldindex = index;	index = nextNum(index, plength);		while(p[index].perspecD < wdivide)	{		p1[index1] = p[index];		texture1[index1] = texture[index];		oldindex = index;		index = nextNum(index, plength);		index1++;	}	FindIntersection(wdivide, &(p[index]), &(p[oldindex]), &IntersectPt,					 &(texture[index]), &(texture[oldindex]), &textureIntersect);	p2[index2] = IntersectPt;	texture2[index2] = texture1[index1] = textureIntersect;	p1[index1] = IntersectPt;	index1++;	index2++;		if(index != closestdepthindex)	{		if(p[index].perspecD != wdivide)		{			p2[index2] = p[index];			texture2[index2] = texture[index];			index2++;		}				oldindex = index;		index = nextNum(index, plength);				while(index != closestdepthindex)		{			p2[index2] = p[index];			texture2[index2] = texture[index];			oldindex = index;			index = nextNum(index, plength);			index2++;		}	}		*plengthptr = index1;	*textureptr = texture1;	*pptr = p1;	*plengthptr2 = index2;	}voidDivideOnVerticalLine(PointFFixed **textureptr, Point3DAllInfo **pptr, int *plengthptr,				 	 PointFFixed *texture2, PointFFixed *p2, int *plengthptr2,				 	 FFixed xdivide, int xmaxindex);voidDivideOnVerticalLine(PointFFixed **textureptr, Point3DAllInfo **pptr, int *plengthptr,				 	 PointFFixed *texture2, PointFFixed *p2, int *plengthptr2,				 	 FFixed xdivide, int xmaxindex){	int index, oldindex, index1, index2;	PointFFixed *texture, *texture1;	Point3DAllInfo *p, *p1;	int plength = *plengthptr;	Point3DAllInfo IntersectPt;	PointFFixed textureIntersect;		p = *pptr;	texture = *textureptr;	p1 = gettemparray1B();	texture1 = gettemparray2B();		index1 = index2 = 0;	index = xmaxindex;	while(p[index].ScreenX.l > xdivide.l)	{		p2[index2].h = p[index].ScreenX;		p2[index2].v = p[index].ScreenY;		texture2[index2] = texture[index];		oldindex = index;		index = nextNum(index, plength);		index2++;	}	FindIntersectionX(xdivide, &(p[oldindex]), &(p[index]), &IntersectPt,					 &(texture[oldindex]), &(texture[index]), &textureIntersect);	p2[index2].h = IntersectPt.ScreenX;	p2[index2].v = IntersectPt.ScreenY;	p1[index1] = IntersectPt;	texture2[index2] = texture1[index1] = textureIntersect;	index1++;	index2++;		if(p[index].ScreenX.l != xdivide.l)	{		p1[index1] = p[index];		texture1[index1] = texture[index];		index1++;	}	oldindex = index;	index = nextNum(index, plength);		while(p[index].ScreenX.l < xdivide.l)	{		p1[index1] = p[index];		texture1[index1] = texture[index];		oldindex = index;		index = nextNum(index, plength);		index1++;	}	FindIntersectionX(xdivide, &(p[index]), &(p[oldindex]), &IntersectPt,					 &(texture[index]), &(texture[oldindex]), &textureIntersect);	p2[index2].h = IntersectPt.ScreenX;	p2[index2].v = IntersectPt.ScreenY;	texture2[index2] = texture1[index1] = textureIntersect;	p1[index1] = IntersectPt;	index1++;	index2++;		if(index != xmaxindex)	{		if(p[index].ScreenX.l != xdivide.l)		{			p2[index2].h = p[index].ScreenX;			p2[index2].v = p[index].ScreenY;			texture2[index2] = texture[index];			index2++;		}				oldindex = index;		index = nextNum(index, plength);				while(index != xmaxindex)		{			p2[index2].h = p[index].ScreenX;			p2[index2].v = p[index].ScreenY;			texture2[index2] = texture[index];			oldindex = index;			index = nextNum(index, plength);			index2++;		}	}		*plengthptr = index1;	*textureptr = texture1;	*pptr = p1;	*plengthptr2 = index2;	}intFindDivisionVerticalLine(Parallelogram *prllelgrm, FFixed *xdivide);intFindDivisionVerticalLine(Parallelogram *prllelgrm, FFixed *xdivide){	Point3DAllInfo p1, p2;	FFixed tempfixed, ydist;	FFixed Ratio, depthdelta;	unsigned long wdivide;		/*handle cases where lines of constant depth are along scan line or	  almost along scanline*/	if(labs(prllelgrm->Slope.l) < 0x00000080) return(0);		p1.ScreenY.l = p2.ScreenY.l = 0;	p1.ScreenX.l = 0;	p2.ScreenX.l = prllelgrm->x2.l - prllelgrm->x1.l;		tempfixed = FFMult(p2.ScreenX, prllelgrm->Slope);		ydist.l = prllelgrm->y1.l - prllelgrm->y2.l;	Ratio = FFDiv(tempfixed, ydist);	if(Ratio.l < 0) Ratio.l = -Ratio.l;		tempfixed.intg = 1; tempfixed.frac = 0;	if(Ratio.l > tempfixed.l)	{		/*worst case scanline is less than width of parallelogram*/		p2.perspecD = prllelgrm->OneOverMinDepth.l;		p1.perspecD = prllelgrm->OneOverMaxDepth.l;		p2.ScreenX = FFDiv(ydist, prllelgrm->Slope);		if(p2.ScreenX.l < 0) p2.ScreenX.l = -p2.ScreenX.l;		wdivide = FindDepthDivide(&p2, &p1);		if(wdivide <= p1.perspecD) return(0);		depthdelta.l = p2.perspecD - p1.perspecD;		tempfixed.l = p2.perspecD - wdivide;		Ratio = FFDiv(tempfixed, depthdelta);		tempfixed = FFMult(Ratio, p2.ScreenX);		if(abs(tempfixed.intg) < MinimumPixelWidth)		{			tempfixed.frac = 0;			if(tempfixed.l < 0) { tempfixed.intg = -MinimumPixelWidth; }			else { tempfixed.intg = MinimumPixelWidth;}			xdivide->l = prllelgrm->x2.l - tempfixed.l;			if(((tempfixed.l <= prllelgrm->x2.l) && (tempfixed.l <= prllelgrm->x1.l)) ||			  ((tempfixed.l >= prllelgrm->x2.l) && (tempfixed.l >= prllelgrm->x1.l)))			{				return(0);			}			else			{				return(1);			}		}			xdivide->l = prllelgrm->x2.l - tempfixed.l;		return(1);	}	else	{		/*worst case scanline is width of parallelogram, but doesn't cover full depth*/		p1.perspecD = prllelgrm->OneOverMaxDepth.l;		tempfixed.l = prllelgrm->OneOverMinDepth.l - prllelgrm->OneOverMaxDepth.l;		depthdelta = FFMult(tempfixed, Ratio);		p2.perspecD = p1.perspecD + depthdelta.l;		wdivide = FindDepthDivide(&p2, &p1);		if(wdivide <= p1.perspecD) return(0);		tempfixed.l = p2.perspecD - wdivide;		Ratio = FFDiv(tempfixed, depthdelta);		tempfixed = FFMult(Ratio, p2.ScreenX);		if(abs(tempfixed.intg) < MinimumPixelWidth)		{			tempfixed.frac = 0;			if(tempfixed.l < 0) { tempfixed.intg = -MinimumPixelWidth; }			else { tempfixed.intg = MinimumPixelWidth;}			xdivide->l = prllelgrm->x2.l - tempfixed.l;			if(((tempfixed.l <= prllelgrm->x2.l) && (tempfixed.l <= prllelgrm->x1.l)) ||			  ((tempfixed.l >= prllelgrm->x2.l) && (tempfixed.l >= prllelgrm->x1.l)))			{				return(0);			}			else			{				return(1);			}		}			xdivide->l = prllelgrm->x2.l - tempfixed.l;		return(1);	}}/*See if and where worst-case scanline needs to be divided so that  linear texture mapping is sufficiently accurate*/intDivideDueToScanline(PointFFixed **texture, Point3DAllInfo **p, int *plength,					PointFFixed *texture2, PointFFixed *p2, int *plength2);intDivideDueToScanline(PointFFixed **texture, Point3DAllInfo **p, int *plength,					PointFFixed *texture2, PointFFixed *p2, int *plength2){	Parallelogram prllelgrm;	FFixed xdivide;	unsigned long wdivide;		if(*plength <= 2) return(0);		MakeParallelogram(*p, *plength, &prllelgrm);	if(prllelgrm.SlopeIsSteep)	{		if(FindDivisionDepth(&prllelgrm, &wdivide))		{						DivideOnConstantDepthLine(texture, p, plength, texture2, p2, plength2, wdivide,									   prllelgrm.MinDepthIndex);			return(1);		}		else		{			return(0);		}	}	else	{		if(FindDivisionVerticalLine(&prllelgrm, &xdivide))		{			DivideOnVerticalLine(texture, p, plength, texture2, p2, plength2, xdivide,									   prllelgrm.MaxScreenXIndex);			return(1);		}		else		{			return(0);		}	}		return(0);}intDivideIfNecessary(PointFFixed **texture, Point3DAllInfo **p, int *plength,				  PointFFixed *texture2, Point3DAllInfo *p2, int *plength2);intDivideIfNecessary(PointFFixed **texture, Point3DAllInfo **p, int *plength,				  PointFFixed *texture2, Point3DAllInfo *p2, int *plength2){	unsigned long wdivide;	FFixed xdivide;	int typeofsubdivision;	int closestdepthindex;		typeofsubdivision = TracePolygonToMaxerror(*texture, *p, *plength, &wdivide, &xdivide,											   &closestdepthindex);	if(typeofsubdivision == NOSUBDIVISION) return(0);		if(typeofsubdivision == DIVIDEALONGDEPTHLINE)	{		DivideOnConstantDepthLine2(texture, p, plength, texture2, p2, plength2, wdivide,								  closestdepthindex);		return(1);	}//	AlertMessage("Debugger Stop 4");	DEBUGGER();}voiddrawsubdivision(V_Offscreen *to, PointFFixed *p, int plength);voiddrawsubdivision(V_Offscreen *to, PointFFixed *p, int plength){	int i,j;		j = plength-1;	i = 0;	while(i < plength)	{		FLine8(to, p[i].h.intg, p[i].v.intg, p[j].h.intg, p[j].v.intg, 0);		j = i;		i++;	}}/*slice poly into subpolys where each subpoly's scanlines can be linearly  texture mapped with sufficient accuracy. Draw each slice.*/intDrawWithSlices2(RenderingParameters *RendSettings,				PointFFixed *texture, Point3DAllInfo *p, int plength);intDrawWithSlices2(RenderingParameters *RendSettings,				PointFFixed *texture, Point3DAllInfo *p, int plength){	int newplength;	int i;		while(DivideDueToScanline(&texture, &p, &plength, slicetexture2, slicep2, &newplength))	{		FFixedLinearTexture8(RendSettings, slicetexture2, slicep2, newplength);		if(ShowSubPolys) { drawsubdivision(RendSettings->to, slicep2, newplength); }	}		for(i=0;i<plength;i++)	{		slicep2[i].h = p[i].ScreenX;		slicep2[i].v = p[i].ScreenY;	}	FFixedLinearTexture8(RendSettings, texture, slicep2, plength);	if(ShowSubPolys) { drawsubdivision(RendSettings->to, slicep2, plength); }			return(0);}/*slice poly into subpolys where each subpoly's edges can be linearly  texture mapped with sufficient accuracy. Draw each slice.*/intDrawWithSlices(RenderingParameters *RendSettings, 				PointFFixed *texture, Point3DAllInfo *p, int plength);intDrawWithSlices(RenderingParameters *RendSettings, 				PointFFixed *texture, Point3DAllInfo *p, int plength){	int i;	int newplength;		while(DivideIfNecessary(&texture, &p, &plength, slicetexture, slicep, &newplength))	{		DrawWithSlices2(RendSettings, slicetexture, slicep, newplength);//JAM 3-31-04 removed unnecessary recursion//		DrawWithSlices(RendSettings, texture, p, plength);//		return (0);	}	return (DrawWithSlices2(RendSettings, texture, p, plength));}voidFindMinimumDepthStep(Point3DAllInfo *p, int plength);voidFindMinimumDepthStep(Point3DAllInfo *p, int plength){	Parallelogram prllelgrm;	FFixed pixeldelta, oneoverdepthdelta, wslope;		MakeParallelogram(p, plength, &prllelgrm);		if(prllelgrm.SlopeIsSteep)	{		pixeldelta.l = labs(prllelgrm.x1.l - prllelgrm.x2.l);		oneoverdepthdelta.l = prllelgrm.OneOverMinDepth.l - prllelgrm.OneOverMaxDepth.l;		wslope = FFDiv(oneoverdepthdelta, pixeldelta);	}	else	{		pixeldelta.l = labs(prllelgrm.y1.l - prllelgrm.y2.l);		oneoverdepthdelta.l = prllelgrm.OneOverMinDepth.l - prllelgrm.OneOverMaxDepth.l;		wslope = FFDiv(oneoverdepthdelta, pixeldelta);	}	MinimumDepthStep = wslope.l * MinimumPixelWidth;}int NewTexture8(V_Offscreen *to,V_Array *fpoints,Point3DAllInfo *pt, int plength,	Clip *clipper, struct TextureRendSettings *textureinfo);int NewTexture8(V_Offscreen *to,V_Array *fpoints,Point3DAllInfo *pt, int plength,	Clip *clipper, struct TextureRendSettings *textureinfo){int mode;Point3DAllInfo *ptClipped;PointFFixed *pf;			/*the texture points.*/PointFFixed *pfClipped;int rval = FALSE;int i;PointFFixed InterceptPoint;PointFFixed ScreenPtA, ScreenPtB, TexturePtA, TexturePtB;unsigned char **fromRaster;int NumOfSubPolys;PointFFixed *PointFFixedPtr;LineData *LineDataPtr;		//Added by JAM 3-7-94 to use saved cliping poly line equationsRenderingParameters RendSettings;VGrafPort savePort;	// ABD MERGE23VGrafDevice saveDevice;	// ABD MERGE23long plength2, templong;/*check for trivial non-drawn poly*/if(plength<=2) {	return rval;}pf = (PointFFixed *)fpoints->Use();mode = textureinfo->decal;/*initialize clippling arrays*/i = plength + clipper->ClipShape->ALength() + 2;initcliparrays(i);initslicearrays(i);inittemparrays(i);/*clip poly to screen/surffeat.  NOTE this assumes clipper always  exists and is at least the screen*/#if DEBUG && MACINTOSHif(!clipper){//	AlertMessage("Debugger Stop 5");	DEBUGGER();}#elseif(!clipper) {	fpoints->Unuse();	return rval;}#endif//Changed by JAM 3-7-94 to save cliping poly line equations [[[templong = plength;if(	clipper->ClipToPoly(pt, pf, templong, &ptClipped, &pfClipped, &plength2, 0) == REJECT  ){	fpoints->Unuse();	rval = TRUE;	return rval;}plength = plength2;//Changed by JAM 3-7-94 to save cliping poly line equations ]]]MakeRendSettings(textureinfo, to, pfClipped, plength, &RendSettings);RendSettings.fromRaster = textureinfo->mip[0]->UseRaster(&savePort, &saveDevice);	// ABD MERGE23/*handle cases where linear interpolation is pixel-accurate.  might make  linearisokay routine more accurate so we can do more linear cases*/if(linearisokay(ptClipped, plength)) {	PointFFixed *screenpt;		screenpt = gettemparray2();	for(i=0;i<plength;i++)	{		screenpt[i].h = ptClipped[i].ScreenX;		screenpt[i].v = ptClipped[i].ScreenY;	}	rval = FFixedLinearTexture8(&RendSettings, pfClipped, screenpt, plength);}else{	GlobalSlopeIsSteep = FindSlope(ptClipped, plength, &GlobalConstantDepthSlope);	FindMinimumDepthStep(ptClipped, plength);	rval = DrawWithSlices(&RendSettings, pfClipped, ptClipped, plength);}textureinfo->mip[0]->UnuseRaster(&savePort, &saveDevice);	// ABD MERGE23fpoints->Unuse();rval = 0;return rval;}//int profileinited = FALSE;int Texture8(V_Offscreen *to,V_Array *fpoints,V_Array *tpoints,V_Array *nppoints,	Clip *clipper, struct TextureRendSettings *textureinfo){	Point3DAllInfo *p;	PointFFixed *t;	int i;	Rect rclip;	PointFFixed *clippts;	int rval = FALSE;	V_Array *va1;	V_Array *va2;	int plength = tpoints->ALength();//JAM 3-31-94 changed to inline abuses [[[//	Point *pt = (Point *)tpoints->Abuse();//	Point3DNoPersp *pnp = (Point3DNoPersp *)nppoints->Abuse();//	PointFFixed *pf = (PointFFixed *)fpoints->Abuse();	Point *pt = (Point *)VA_Abuse(tpoints);	Point3DNoPersp *pnp = (Point3DNoPersp *)VA_Abuse(nppoints);	PointFFixed *pf = (PointFFixed *)VA_Abuse(fpoints);//JAM 3-31-94 changed to inline abuses ]]]		if(clipper->reject) return(0);	/*//	if(!profileinited)//	{//		profileinited = TRUE;//		InitProfile(200, 200);//		freopen("Profile", "w", stdout);//		_profile = FALSE;//	}	*/	//	_profile = TRUE;	//	va1 = (V_Array *)new(V_Array);//	va1->cArray(plength, sizeof(Point3DAllInfo), 8);//	p = (Point3DAllInfo*)va1->Use();		p = gettemparray1C(plength);		for(i=0;i<plength;i++)	{		p[i].ScreenX.intg = pt[i].h;		p[i].ScreenX.frac = 0;		p[i].ScreenY.intg = pt[i].v;		p[i].ScreenY.frac = 0;		p[i].perspecD = pnp[i].perspecD;	}	/*	if(clipper && clipper->type)	{		return(TRUE);	}	*/	rval = NewTexture8(to, fpoints, p, plength, clipper, textureinfo);	to->SetCurrent();		// ABD - QuickTime fix - 4/11/94	// MERGE-HMD [[[	#if USE_HMD	if ((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX))	{		// since SetCurrent resets our flash routines, we want to set the back to the		// proper VRex routines if we are using the VRex HMD		gHMD->ResetFlashRoutines(to);	}	#endif // USE_HMD	// MERGE-HMD ]]]//	va1->Unuse();//	va1->dArray();//	_profile = FALSE;//	DumpProfile();	return(rval);	}