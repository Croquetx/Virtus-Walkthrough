#include "VTypes.h"#include "WTypes.h"#include "Drawing.h"#include "POLYHDRN.h"#include "POLYCONV.h"#include "SurfDef.h"#include "Surface.h"#include "Slice.h"#include "Position.h"#include "Light.h"#include "Geometry.h"#include "VMDL.h"#include "WalkBuff.h"#include "Unit.h"#include "TextItem.h"		// ABD TEXTURE#include "TextSrvr.h"		// ABD TEXTURE#include "View.h"			// ABD TEXTURE#include "AppDeflt.h"		// ABD TEXTURE#include "VError.h"			// jca merge#include <stddef.h>#include <math.h>#include <string.h>extern TextureServer *gTextureServer;		// ABD TEXTURE/*----- TEXTURE CODE -----*//*	we go through each surface and set up the raw texture points for each surface*/#define TILING_NOT_IMPLEMENTED 1void	Polyhedron::CalcTextureMapping()		// ABD TEXTURE{TextureItem *t;Surface **s;int i,j;Rect r,r2;double meters_per_unit;	//MERGE-PRO-JAM-2	if (!piece) return;	if (!(piece->surfaces)) return;	s = (Surface **)piece->surfaces->Use();	for (i = 0 ; i < piece->surfaces->ALength() ; i++ )	{		// set up the inside points		t = s[i]->GetTexture(SURF_INSIDE);		// (the textures are read in last, I think, and so t->texture		// can be NULL on the first pass.  Wait until the end -- when		// textures are read in -- to fix the mapping params.  jca)		if ((t != NULL) && (t->texture != NULL))	// 12 Nov 93 JAM		{			// ABD MERGE-MEM REMOVED V_Array *outl;			V_Array *rawIn = NULL;		// ABD MERGE-MEM			t->GetPaddedRect(&r, 0);			t->GetUnpaddedRect(&r2, 0);						// MERGE-PRO-JAM-2 [[[//			if (GetUnit() == NULL) //				goto exit_routine;			if (GetUnit() == NULL)			{				meters_per_unit = 0.0254;	// use inches as a default			}			else			{				meters_per_unit = GetUnit()->GetSize();			}			// MERGE-PRO-JAM-2 ]]]							// ABD MERGE-MEM REMOVED outl = s[i]->GetOutline();			// ABD MERGE-MEM REMOVED if (!outl) goto exit_routine;		// „„„„„ debug// ABD MERGE-MEM REMOVED if (!s[i]->rawInsideTexturePoints) goto exit_routine;		// „„„„„ debug// JAM MERGE-PRO-JAM-2 REMOVED	if (!GetUnit()) goto exit_routine;		// „„„„„ debug			// ABD MERGE-MEM rawIn will be created if it is NULL, which it is 			MakeTextureArray(s[i]->GetOutline(), &rawIn, &r,&r2,        // ABD MERGE-MEM				t->settings.use_real_world_size_h,				t->settings.use_real_world_size_v,				t->settings.hUnit,				t->settings.vUnit,				t->settings.hPixels_per_unit,				t->settings.vPixels_per_unit,				t->settings.hTiles,				t->settings.vTiles,				meters_per_unit);	//MERGE-PRO-JAM-2			rawIn->CopyArray(s[i]->GetRawTexturePoints(SURF_INSIDE));	// ABD MERGE-MEM			rawIn->dArray();		// ABD MERGE-MEM		}				// set up the outside points		t = s[i]->GetTexture(SURF_OUTSIDE);		// (the textures are read in last, I think, and so t->texture		// can be NULL on the first pass.  Wait until the end -- when		// textures are read in -- to fix the mapping params.  jca)		if ((t != NULL) && (t->texture != NULL))	// 12 Nov 93 JAM		{			// ABD MERGE-MEM REMOVED V_Array *outl;			V_Array *rawOut = NULL;	// ABD MERGE-MEM					t->GetPaddedRect(&r, 0);			t->GetUnpaddedRect(&r2, 0);			// MERGE-PRO-JAM-2 [[[//			if (GetUnit() == NULL) //				goto exit_routine;			if (GetUnit() == NULL)			{				meters_per_unit = 0.0254;	// use inches as a default			}			else			{				meters_per_unit = GetUnit()->GetSize();			}			// MERGE-PRO-JAM-2 ]]]			// ABD MERGE-MEM REMOVED if (!outl) goto exit_routine;		// „„„„„ debug// ABD MERGE-MEM REMOVED if (!s[i]->rawInsideTexturePoints) goto exit_routine;		// „„„„„ debug// ABD MERGE-MEM REMOVED if (!s[i]->rawOutsideTexturePoints) goto exit_routine;		// „„„„„ JAM debug// JAM MERGE-PRO-JAM-2 REMOVED	if (!GetUnit()) goto exit_routine;		// „„„„„ debug			// ABD MERGE-MEM rawOut will be created if it is NULL, which it is 			MakeTextureArray(s[i]->GetOutline(), &rawOut, &r,&r2,		// ABD MERGE-MEM				t->settings.use_real_world_size_h,				t->settings.use_real_world_size_v,				t->settings.hUnit,				t->settings.vUnit,				t->settings.hPixels_per_unit,				t->settings.vPixels_per_unit,				t->settings.hTiles,				t->settings.vTiles,				meters_per_unit);	//MERGE-PRO-JAM-2			rawOut->CopyArray(s[i]->GetRawTexturePoints(SURF_OUTSIDE));	// ABD MERGE-MEM			rawOut->dArray();		// ABD MERGE-MEM		}	}exit_routine:	piece->surfaces->Unuse();	#ifdef USE_SHADOWS	SetRect(&r, 0, 0, 64, 64);	s = piece->surfaces->Use();	for (i = 0 ; i < piece->surfaces->ALength() ; i++ )	{		// set up the inside points		MakeTextureArray(s[i]->GetOutline(), s[i]->rawInsideShadowPoints, &r);				// set up the outside points		MakeTextureArray(s[i]->GetOutline(), s[i]->rawOutsideShadowPoints, &r);	}	piece->surfaces->Unuse();#endif}voidPolyhedron::SetTexture(struct TextureItem *t, int where)		// ABD TEXTURE{	if (type == POLY_INVALID)		return;	SetTextureIO(t, where);		// set all of the raw texture mapping points	CalcTextureMapping();}voidPolyhedron::SetTextureIO(struct TextureItem *t, int where)		// ABD TEXTURE{Polyhedron *local_poly = this;int err = noErr;	if (type == POLY_INVALID)		return;	if (where == SURF_SHARED)	{		if (t != insideTexture)	 	{			if (insideTexture != NULL) 				insideTexture->DocUnusePoly(local_poly);			if (t != NULL) 				err = t->DocUsePoly(local_poly);			insideTexture = t;		}		if (t != outsideTexture)	 	{			if (outsideTexture != NULL) 				outsideTexture->DocUnusePoly(local_poly);			if (t != NULL) 				err = t->DocUsePoly(local_poly);			outsideTexture = t;		}	}	else if (where == SURF_INSIDE)	{		if (t != insideTexture)	 	{			if (insideTexture != NULL) 				insideTexture->DocUnusePoly(local_poly);			if (t != NULL) 				err = t->DocUsePoly(local_poly);			insideTexture = t;		}	}	else if (where == SURF_OUTSIDE)	{		if (t != outsideTexture)	 	{			if (outsideTexture != NULL) 				outsideTexture->DocUnusePoly(local_poly);			if (t != NULL) 				err = t->DocUsePoly(local_poly);			outsideTexture = t;		}	}	}		struct TextureItem *Polyhedron::GetTexture(int where)		// ABD TEXTURE	{	if ((type & POLY_CLASS) == P_INTERNAL)		return(NULL);	if (where == SURF_INSIDE)		return (insideTexture);	else		return (outsideTexture);	}/*	// ABD TEXTURE */intPolyhedron::IO_PLTX(V_Buffer *buf){int err = 0;long id;long txID;struct TextureItem *t;			if (buf->IODirection() == DATA_IN)	{		while (!err)		{			id = buf->OpenChunkR();			if (id == 0) break;						switch (id)			{				case IFF_TXID:	/* inside texture ID */				{					// DATA IN					// We read in the id number and ask the texture server for a					// texture item with that id number.  If there is already a texture					// item with that id number, then we get a pointer to it.  Otherwise					// the texture server creates a new texture item with that id number.					// in any case we will receive a ptr to a texture item, and we should					// set our texture to that texture item.  Note that we MUST call					// SetTexture() instead of setting the texture directly, because					// we have to add ourselves to the list of objects using this texture.					buf->IOType(&txID, IO_LONG);	// Write out the id.					t = gTextureServer->IDtoTexture(txID);					// use SetTextureIO which defers recalcing the texture coords					SetTextureIO(t, SURF_INSIDE);										// later, when the texture server reads in the id table, it will set					// the name and file ref of each of these new, blank texture items					// that it created.  If the name, when set, conflicts with a name					// that already exists in the file, then the user will be prompted					// to either rename the texture or go ahead and replace the texture					// that was there already with the new texture name/file ref.										break;				}				case IFF_TXOD:	/* outside texture ID */				{					buf->IOType(&txID, IO_LONG);	// Write out the id.					t = gTextureServer->IDtoTexture(txID);										// use SetTextureIO which defers recalcing the texture coords					SetTextureIO(t, SURF_OUTSIDE);					break;				}				case IFF_TATR:	/* texture attributes */				{					break;				}			}						buf->CloseChunk();		}	}	else // DATA OUT	{				// ABD 22 Mar 93 		// DATA OUT		// ask the texture server for a new local id based on this texture		// if this texture has already been written out during this file i/o, then we		// will be given the id this texture was assigned before.  Otherwise we will		// be assigned a new id.  In any case we will be given an id.			if (insideTexture != NULL)		{			buf->OpenChunkW(IFF_TXID);	/* inside texture index */			txID = gTextureServer->TexturetoID(insideTexture);			buf->IOType(&txID, IO_LONG);	// Write out the id.			buf->CloseChunk();		}			if (outsideTexture != NULL)		{			buf->OpenChunkW(IFF_TXOD);	/* outside texture index */			txID = gTextureServer->TexturetoID(outsideTexture);			buf->IOType(&txID, IO_LONG);	// Write out the id.			buf->CloseChunk();		}		buf->OpenChunkW(IFF_TATR);	/* texture attributes */		buf->CloseChunk();	}	return(err);}/*JAM 27Aug93*//*when a surface feature is added or changed, SurfFeature::Update() calls this  routine to update the polyhedron's bounds*/voidPolyhedron::UpdateBound()	{	int nPieces, i;	PolyConvex **piec;	Point3D bMin, bMax;	bMin.x = 32767; bMin.y = 32767; bMin.z = 32767;	bMax.x = -32768; bMax.y = -32768; bMax.z = -32768;	if (pieces != NULL)		{		nPieces = pieces->ALength();		piec = (PolyConvex **)pieces->Use();		for (i = 0; i < nPieces; i++, piec++)			{			//(*piec)->PositionX();			(*piec)->CalcBound(BOUND_DEF);			(*piec)->ExpandBound(&bMin, &bMax, BOUND_DEF);			}		pieces->Unuse();		}	else if (piece != NULL)		{		//piece->PositionX();		piece->CalcBound(BOUND_DEF);		piece->ExpandBound(&bMin, &bMax, BOUND_DEF);		}	boundMin = bMin;	boundMax = bMax;		bMin.x = 32767; bMin.y = 32767; bMin.z = 32767;	bMax.x = -32768; bMax.y = -32768; bMax.z = -32768;	if (pieces != NULL)		{		nPieces = pieces->ALength();		piec = (PolyConvex **)pieces->Use();		for (i = 0; i < nPieces; i++, piec++)			{			(*piec)->PositionX();			(*piec)->CalcBound(BOUND_POSN);			(*piec)->ExpandBound(&bMin, &bMax, BOUND_POSN);			}		pieces->Unuse();		}	else if (piece != NULL)		{		piece->PositionX();		piece->CalcBound(BOUND_POSN);		piece->ExpandBound(&bMin, &bMax, BOUND_POSN);		}	posnBoundMin = bMin;	posnBoundMax = bMax;	}// PRO25 [[[voidPolyhedron::GetTextureName(int where, char *name)	{	struct TextureItem *ti = NULL;	if ((type & POLY_CLASS) == P_INTERNAL)		return;	if (where == SURF_INSIDE)		ti = insideTexture;	else		ti = outsideTexture;			if (ti != NULL)		strcpy(name, ti->settings.name); 	else		strcpy(name, "");	}// PRO25 ]]]