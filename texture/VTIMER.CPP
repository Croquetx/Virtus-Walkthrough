/*-------------------------------------------------------------------------------*//*CALL WITH:~~~~~~~~~~// note: the maximum time that will be reported is approximately 33 minutes. long milliseconds_elapsed;		// elapsed milliseconds	StartTiming();	// code to time goes here	milliseconds_elapsed = EndTiming();*/#include "VTypes.h"	// MERGE-GOURAUD-PRO-8#include "VDebug.h"	// MERGE-GOURAUD-PRO-8#include "VTimer.h"	// MERGE-GOURAUD-PRO-8#include <Timer.h>	// MERGE-GOURAUD-PRO-8#define MICRO_LONG ((long)(-5000000))	// maximum time of 5 seconds#define MILLI_LONG ((long)(2000000))	// maximum time of 2000 seconds (~= 33 minutes)#define MAX_TIMERS 512int gCurrentTimer = 0;TMTask gTMTask[MAX_TIMERS];            /*an extended task record*/long gOverhead = 0;		// microsecond overhead (negated)						// i.e. -5 == 5 microsecond overhead/*-------------------------------------------------------------------------------*//*	This routine determines the amount of time required to call the timer, and	subtracts this correction from subsequent calls.  If this routine is never called,	there is no correction.*/void InitTiming(){int i;	StartTimingMicro();	gOverhead = EndTimingMicro();}/*-------------------------------------------------------------------------------*//*	This routine installs an extended time manager task with a large delay value.	When we remove this task, the tmCount field will contain the unelapsed delay,	which we use to compute the elapsed time.*/void StartTimingMicro(){	if (gCurrentTimer == MAX_TIMERS) 	{		DEBUGSTR(((unsigned char*)"\pNo more timers available!"));	// MERGE-GOURAUD-PRO-8		return;	}	gTMTask[gCurrentTimer].tmAddr = NULL;		/* get address of task */	gTMTask[gCurrentTimer].tmWakeUp = 0;			/* initialize tmWakeUp */	gTMTask[gCurrentTimer].tmReserved = 0;			/* initialize tmReserved */	InsXTime((QElemPtr)&gTMTask[gCurrentTimer]);			/* install the task record */	PrimeTime((QElemPtr)&gTMTask[gCurrentTimer], MICRO_LONG);	/* activate the task record */	gCurrentTimer++;}/*-------------------------------------------------------------------------------*//*	This routine installs an extended time manager task with a large delay value.	When we remove this task, the tmCount field will contain the unelapsed delay,	which we use to compute the elapsed time.*/void StartTimingMilli(){	if (gCurrentTimer == MAX_TIMERS) 	{		DEBUGSTR((unsigned char*)"\pNo more timers available!");	// MERGE-GOURAUD-PRO-8		return;	}			gTMTask[gCurrentTimer].tmAddr = NULL;		/* get address of task */	gTMTask[gCurrentTimer].tmWakeUp = 0;			/* initialize tmWakeUp */	gTMTask[gCurrentTimer].tmReserved = 0;			/* initialize tmReserved */	InsXTime((QElemPtr)&gTMTask[gCurrentTimer]);			/* install the task record */	PrimeTime((QElemPtr)&gTMTask[gCurrentTimer], MILLI_LONG);	/* activate the task record */	gCurrentTimer++;}/*-------------------------------------------------------------------------------*//**/long EndTimingMicro(){	RmvTime((QElemPtr)&gTMTask[--gCurrentTimer]);	if (gCurrentTimer < 0) 	{		DEBUGSTR((unsigned char*)"\pEndTiming() called without StartTiming()!");	// MERGE-GOURAUD-PRO-8		return 0L;	}	if (gTMTask[gCurrentTimer].tmCount < 0)		// negative tmCount means unelapsed (negated) microseconds, so we add (subtract)		// the value from the initial delay value (which was in milliseconds).		// -5000000 - (-2000000) == -3000000		return (MICRO_LONG - gTMTask[gCurrentTimer].tmCount);		else		// positive tmCount values means unelapsed milliseconds, so we subract it from		// the initial delay to compute the elapsed time.		return (MICRO_LONG - gTMTask[gCurrentTimer].tmCount);	}/*-------------------------------------------------------------------------------*//**/long EndTimingMilli(){	RmvTime((QElemPtr)&gTMTask[--gCurrentTimer]);	if (gCurrentTimer < 0) 	{		DEBUGSTR((unsigned char*)"\pEndTiming() called without StartTiming()!");	// MERGE-GOURAUD-PRO-8		return 0L;	}	if (gTMTask[gCurrentTimer].tmCount < 0)		// negative tmCount means unelapsed (negated) microseconds, so we add (subtract)		// the value/1000 it from the initial delay value (which was in milliseconds).		return (MILLI_LONG + ((long)((double)(gTMTask[gCurrentTimer].tmCount) / 1000.0)));		else		// positive tmCount values means unelapsed milliseconds, so we subract it from		// the initial delay to compute the elapsed time.		return (MILLI_LONG - (gTMTask[gCurrentTimer].tmCount));	}