#include "VTypes.h"#include "WTypes.h"#include <stdio.h>#include "APPDEFLT.h"#include <string.h>#include <QuickTimeComponents.h>#include "VMDL.h"#include "ShowTest.h"			// !!! DEBUG#include "AppText.h"			// needed for IO()#include "AppFiles.h"			// needed for IO()#include "Drawing.h"#include "SURFFEAT.h"#include "SurfDef.h"#include "POLYHDRN.h"#include "VFile.h"#include "TextItem.h"#include "TextArry.h"#include "TextSrvr.h"#include "TextType.h"#include "Texture.h"#include "VMemUtil.h"#include "VDisplay.h"#include "VGraphic.h"#include "VDebug.h"#include "VError.h"				// jca 22 Sept 93#include "VGestalt.h"extern struct TextureServer *gTextureServer;int gMakingReal = FALSE;/*------------------------------------------------------------------------------*//*	This routine creates a texture item.  */void TextureItem::cTextureItem(struct TextureArray *parent_array){	struct TextureItem *local_ti = this;char *vnm;	parent = parent_array;	parent->Append(&local_ti);		texture = NULL;	id = NON_IO_ID;	old_style_index = -1;	// bogus index 	use_count = 0;	doc_use_count = 0;	polys = new(V_Array);	polys->cArray(0, sizeof(struct Polyhedron *), 4);	surfs = new(V_Array);	surfs->cArray(0, sizeof(struct SurfDef *), 4);	feats = new(V_Array);	feats->cArray(0, sizeof(struct SurfFeature *), 4);		SetDefaults();}/*------------------------------------------------------------------------------*//*	This routine creates a texture item.  */void TextureItem::dTextureItem(){	struct TextureItem *local_ti = this;	if (parent) parent->Remove(parent->Find(&local_ti));	polys->dArray();	polys = NULL;	surfs->dArray();	surfs = NULL;	feats->dArray();	feats = NULL;			delete this;}/*------------------------------------------------------------------------------*//*	This routine returns a string filled in with the name of the texture (NOT	the name of the texture file).  str MUST point to a buffer of at least 64	bytes.  If it doesn't, then this routine will overwrite memory and we'll	all die a horrible death.  */void TextureItem::SetDefaults(){	char *vnm;FFixed ff;	strcpy(settings.name, "<UNINITIALIZED>");			//GJR083093	settings.decal = FALSE;	settings.shade = TRUE;	settings.colorize = FALSE;	settings.hSlide = FFZero;	settings.vSlide = FFZero;	settings.rotate = FFZero;	settings.hFlip = settings.vFlip = settings.hMirror = settings.vMirror = FALSE;	settings.hTiles = settings.vTiles = FFOne;#if JAPANESE	// metric countries prefer metric units.	ff.intg = 1;	ff.frac = 0;	settings.hUnit = unitCentimeter;	settings.vUnit = unitCentimeter;#else	ff.intg = 32;	ff.frac = 0;	settings.hUnit = unitFoot;	settings.vUnit = unitFoot;#endif // JAPANESE	settings.hPixels_per_unit = ff;	settings.vPixels_per_unit = ff;	settings.use_real_world_size_h = FALSE;	settings.use_real_world_size_v = FALSE;	settings.mapping = mapNormal;}/*------------------------------------------------------------------------------*//*	This routine returns a string filled in with the name of the texture (NOT	the name of the texture file).  str MUST point to a buffer of at least 64	bytes.  If it doesn't, then this routine will overwrite memory and we'll	all die a horrible death.  */void TextureItem::GetName(char *str){		memmove(str, settings.name, 64);}/*------------------------------------------------------------------------------*//*	This routine sets the texture field based on the file info passed in.	If the file has already been loaded, it sets the texture instance variable to	point to it.  Otherwise it creates a new Texture object and sets the var to point 	to it.	ABD changed to return err; 12/9/93*/intTextureItem::TextureFileLoc(VfsLocation *fSpec){struct Texture *t = NULL;int type = -1;int err = noErr;char str[256], str2[256];int i;Long fileType;//extern int gQuickTime;	VfsGetLocationFType(fSpec, &fileType);	if (fileType == appFileTypePICT)				// PICT file		type = TEXTURE_PICTFILE;	else if ((fileType == appFileTypeBMP) || (fileType == appFileTypeDIB))	// BMP file - BILBIL - 12/01/93  DIB file jca 10 Dec 93		type = TEXTURE_BMPFILE;	else if ((gQuickTime) && (fileType == appFileTypeQuickTime))		// QuickTime Movie		type = TEXTURE_QUICKTIME;	else		type = -1;			if (type == -1) return -1;			t = NULL;	t = gTextureServer->GlobalFindByFileLoc(fSpec);				//GJR 10/06/93	if (t == NULL)	{		// texture file has not been loaded, so create a new texture object		t = gTextureServer->NewTexture(type);		// ABD added error check 12/9/93		// if t == NULL then it has already been deleted and removed from TextureServer array		if (t == NULL)      	err = -1;			// ABD added error check 12/9/93      if (err == noErr)			err = t->SetTextureFileLoc(fSpec);							//GJR 10/06/93	}	// set texture ptr to texture if we got no error; otherwise delete texture	if (err == noErr)		texture = t;	else if (t)		t->dTexture();   return err;}/*------------------------------------------------------------------------------*//*	This routine sets the file info for this texture item.  If the file has already	been loaded, it sets the texture instance variable to point to it.  Otherwise	it creates a new Texture object and sets the var to point to it.  		The V_File object f can be deleted safely after calling this routine -- only	the file location is used.*/intTextureItem::TextureVFile(V_File *f){struct Texture *t = NULL;int type;int err = noErr;long fileType;VfsLocation *vfsLocation;						//GJR 10/06/93 	// we need to Find() the file again here to make sure all of the 	// fields are valid -- if this file was just a relative file, then	// file->IO() will have done a SetLocation(), but we need to do a 	// Find() before the file type info will be valid.  If the file was	// already found, then no harm done.  f must be a valid file anyway. 	err = f->Find();	if (err) return err;	fileType = f->GetFType();		if (fileType == appFileTypePICT)				// PICT file		type = TEXTURE_PICTFILE;	else if ((fileType == appFileTypeBMP) || (fileType == appFileTypeDIB))	// BMP file - BILBIL - 12/01/93  DIB file jca 10 Dec 93		type = TEXTURE_BMPFILE;	else if ((gQuickTime) && (fileType == appFileTypeQuickTime))		// QuickTime Movie		type = TEXTURE_QUICKTIME;	else		type = -1;	if (type == -1) return -1;	vfsLocation = new(VfsLocation);    vfsLocation->cVfsLocation();	err = f->VGetLocation(vfsLocation);	if (err) { vfsLocation->dVfsLocation(); return err; }	t = NULL;	t = gTextureServer->GlobalFindByFileLoc(vfsLocation);	if (t == NULL)	{		// texture file has not been loaded, so create a new texture object		t = gTextureServer->NewTexture(type);		if (t == NULL) { vfsLocation->dVfsLocation(); return -1; }		err = t->SetTextureFileLoc(vfsLocation);	}	// set texture ptr to texture   if (err == noErr)		texture = t;	else if (t)		t->dTexture();	vfsLocation->dVfsLocation();	return err;}/*------------------------------------------------------------------------------*//*	This routine */intTextureItem::TextureChunk(V_File *f, long io_position){struct Texture *t = NULL;int err = noErr;VfsLocation *vfsLocation;						//JAM 8/9/94	// we don't need to Find() the file here because if this routine is being	// called, then f is currently open.  You can't very well open a file without	// finding it first, so it is clearly a valid file.	// no need to do: err = f->Find();#if 0	// create a new chunk texture object.  Note that we don't check to see if there	// is already a texture with this file loc, because there can be many textures	// with the same file when textures are chunky.	t = gTextureServer->NewTexture(TEXTURE_CHUNK);   if (t == NULL) return -1;#endif	//above is wrong.  If we go into the texture dialog, do a set	//source, and then do a cancel, we need to go back to the old	//texture, which is necessarily the same as one we have already	//instead, we need to search list, also taking into account	//io_positon	vfsLocation = new(VfsLocation);    vfsLocation->cVfsLocation();	err = f->VGetLocation(vfsLocation);	if (err) { vfsLocation->dVfsLocation(); return err; }	t = NULL;	t = gTextureServer->GlobalFindChunkByLocAndPos(vfsLocation, io_position);	if (t == NULL)	{		// texture file has not been loaded, so create a new texture object		t = gTextureServer->NewTexture(TEXTURE_CHUNK);		if (t == NULL) { vfsLocation->dVfsLocation(); return -1; }		err = t->SetTextureChunkPosition(io_position);        if(err == noErr) err = t->SetTextureVFile(f);	}		// set texture ptr to texture   if (err == noErr)		texture = t;	else if (t)		t->dTexture();	vfsLocation->dVfsLocation();	return err;}// ABD 17MAR94 MERGE-BUG/*------------------------------------------------------------------------------*//*	This routine */intTextureItem::TextureOffscreen(){struct Texture *t = NULL;int err = noErr;	// we don't need to Find() the file here because if this routine is being	// called, then f is currently open.  You can't very well open a file without	// finding it first, so it is clearly a valid file.	// no need to do: err = f->Find();	// create a new chunk texture object.  Note that we don't check to see if there	// is already a texture with this file loc, because there can be many textures	// with the same file when textures are chunky.	t = gTextureServer->NewTexture(TEXTURE_PICT);   if (t == NULL) return -1;		// set texture ptr to texture   if (err == noErr)		texture = t;	else if (t)		t->dTexture();	return err;}/*------------------------------------------------------------------------------*//*	This routine */voidTextureItem::Merge(TextureItem* ti){	VfsLocation *vfsLocation;	vfsLocation = new(VfsLocation);    vfsLocation->cVfsLocation();//MERGE-PRO-JAM-3 [[[	if (ti->texture)		if (ti->texture->tt)			if (ti->texture->tt->class_type == TEXTURE_FILE)				{		//Shouldn't all this be done with same protection? //GJR 10/06/93				//MERGE-PRO-JAM-3				if(ti->texture->type == TEXTURE_CHUNK)				{					vfsLocation->CopyVfsLocation(((FileTextureType*)(ti->texture->tt))->vfsLocation);				}				else				{								((FileTextureType*)(ti->texture->tt))->file->VGetLocation(vfsLocation);				}			//else				//DEBUGGER();				// reset the texture file loc				if(ti->texture->type == TEXTURE_CHUNK)				{					texture = ti->texture;	//if we are merging chunk, just copy data as it must already exist MERGE-PRO-JAM-3				}				else				{								TextureFileLoc(vfsLocation);				}					// reset the texture settings				settings = ti->settings;					// load the picture if it is in use				if (IsUsedInDocument())					LoadPicture();				// reapply the texture				ApplyTexture();		//follows LoadPicture GJR091093				} //end of pointer validity checks					//GJR 10/06/93//MERGE-PRO-JAM-3 ]]]	vfsLocation->dVfsLocation();}/*------------------------------------------------------------------------------*//*	This routine */intTextureItem::SetVideoDigitizer(short slot, short input){struct TextureItem **ti;int found = FALSE;char str[256];int i;int err = fileNotFoundErr;		// presume we can't find it	// note that every texture array is guaranteed to have a video digitizer item	// already in it, if indeed there are video digitizers available, 	// because the vdig items are added there when the texture array	// is created.  Thus, all we have to do is find it.  When we find it, we have to	// set our name to be the same as it, so that we will be merged with it after the	// texture table has been read in.	  	ti = (TextureItem **)parent->Use();	for ( i = 0 ; i < parent->ALength() ; i++ )	{#if MACINTOSH		if (ti[i]->texture)			if (ti[i]->texture->type == TEXTURE_VDIG)				if ((((TTVDIG*)(ti[i]->texture->tt))->slot_num == slot) &&					(((TTVDIG*)(ti[i]->texture->tt))->input_num == input))				{					ti[i]->GetName(str); 					strcpy(settings.name, str);					found = TRUE;					break; 				}#elif WINDOWS#if !ELVIS	//		No Vdig Errors in Windows			//GJR 10/01/93//#error This needs your attention, Greg...#endif#endif	}	parent->Unuse();	if (found) 		{		err = noErr;		}			return (err);}/*------------------------------------------------------------------------------*//*	This routine loads the picture into memory so that it can be used as a texture.  It	increments use_count so we know how many times this texture is used, so we can unload	it when it is no longer used.  We check to make sure the Pict is not in memory	before loading it because the texture could be Use()'d but not really used in	the document.*/int TextureItem::DocUsePoly(struct Polyhedron *v)	{		int err = 0;	struct Polyhedron *local_v;	struct V_Offscreen *Savecurrentscreen;	//JAM--this routine should leave currentscreen unchanged HACK--I hope this doesn't break		// add the surface feature pointer to the list of objects using this texture				local_v = v;				// add it to the array.  Note that we do not check to make sure the object is		// not already in the array.  This is because surfaces and polys can have 		// inside and outside textures, and they will be added twice to this array.		// But they will be removed twice also so everything will be okay.  But when		// we are making this a real texture item, we don't want to add it again,		// so we check our global. 				if (!gMakingReal)					// if we are making it a real texture item,			polys->Append(&local_v);		// then the item is already in the array					// if this texture item is a placeholder, then return immediately, because		// we have done what we need to do (and messing around with the use counts		// may screw things up if the texture file reference has not been set yet).				if (id != NON_IO_ID) 			return(noErr);		#if DEBUG		if (texture == NULL)			{			DEBUGGER();			return(-1);			}#else		if (texture == NULL) return(-1);	// error if no texture defined GJR091593#endif		Savecurrentscreen = currentscreen;	//JAM--this routine should leave currentscreen unchanged HACK--I hope this doesn't break		if (texture->global_use_count == 0) 		// no one was using the texture before now, so load it		{			// note that LoadPicture does not really load QuickTime movies			err = LoadPicture();		// load the picture		}		if (!err)		{				doc_use_count++;						// update doc use count if no error			texture->global_use_count++;		// update texture global use count		}		currentscreen = Savecurrentscreen;	//JAM--this routine should leave currentscreen unchanged HACK--I hope this doesn't break		return(err);	}/*------------------------------------------------------------------------------*//*	This routine unloads the picture if this texture is no longer used.  */void TextureItem::DocUnusePoly(struct Polyhedron *v)	{		int err;	struct Polyhedron *local_v;	int pos;				local_v = v;		if ((pos = (polys->Find(&local_v))) < 0)		{			DEBUGGER();            return;			// WHAT ARE YOU DOING???  err = err / 0; //еее programmer error; object not in array !!!		}				polys->Remove(pos);//JAM 28Sept93 changed comments so noone will destroy this fix again! [[[		// if this texture item is a placeholder, then return immediately, because		// we don't need to do anything here.  We CANNOT, however move this return		// to the beginning of the routine, because the item must be deleted		// from the list, so an infinite loop doesn't occur.  Really need to		// rewrite logic so the calling routine does the Remove(pos)		//JAM 28Sept93 changed comments so noone will destroy this fix again! ]]]				if (id != NON_IO_ID) 			return;		if (texture == NULL) return;	//  no texture defined GJR091593				if (texture->global_use_count == 1)	// the last object using texture doesn't want it any more		{			UnloadPicture();	// purge the picture (but keep the thumbnail around)		}		// fix up doc use count, even if this is a placeholder texture item		doc_use_count--;							// update doc use count		texture->global_use_count--;	// update texture global use count	}/*------------------------------------------------------------------------------*//*	This routine loads the picture into memory so that it can be used as a texture.  It	increments use_count so we know how many times this texture is used, so we can unload	it when it is no longer used.  We check to make sure the Pict is not in memory	before loading it because the texture could be Use()'d but not really used in	the document.*/int TextureItem::DocUseSurf(struct SurfDef *v)	{		int err = 0;	struct SurfDef *local_v;		// add the surface feature pointer to the list of objects using this texture				local_v = v;				// add it to the array.  Note that we do not check to make sure the object is		// not already in the array.  This is because surfaces and polys can have 		// inside and outside textures, and they will be added twice to this array.		// But they will be removed twice also so everything will be okay.  But when		// we are making this a real texture item, we don't want to add it again,		// so we check our global. 				if (!gMakingReal)					// if we are making it a real texture item,			surfs->Append(&local_v);		// then the item is already in the array					// if this texture item is a placeholder, then return immediately, because		// we have done what we need to do (and messing around with the use counts		// may screw things up if the texture file reference has not been set yet).		// Note that this is not an error.				if (id != NON_IO_ID) 			return(noErr);		#if DEBUG		if (texture == NULL) DEBUGGER();#else		if (texture == NULL) return(-1);	// error if no texture defined GJR091593#endif		if (texture->global_use_count == 0) 		// no one was using the texture before now, so load it		{			// note that LoadPicture does not really load QuickTime movies			err = LoadPicture();		// load the picture		}		if (!err) 		{				doc_use_count++;						// update doc use count if no error			texture->global_use_count++;		// update texture global use count		}		return(err);	}/*------------------------------------------------------------------------------*//*	This routine unloads the picture if this texture is no longer used.  */void TextureItem::DocUnuseSurf(struct SurfDef *v)	{		int err;	struct SurfDef *local_v;	int pos;				local_v = v;		if ((pos = (surfs->Find(&local_v))) < 0)		{ 			DEBUGGER();            return;			// WHAT THE #*$)U# ARE YOU DOING???? err = err / 0; //еее programmer error; object not in array !!!		}				surfs->Remove(pos);//JAM 28Sept93 changed comments so noone will destroy this fix again! [[[		// if this texture item is a placeholder, then return immediately, because		// we don't need to do anything here.  We CANNOT, however move this return		// to the beginning of the routine, because the item must be deleted		// from the list, so an infinite loop doesn't occur.  Really need to		// rewrite logic so the calling routine does the Remove(pos)		//JAM 28Sept93 changed comments so noone will destroy this fix again! ]]]				if (id != NON_IO_ID) 			return;				if (texture == NULL) return;	// no texture defined GJR091593		if (texture->global_use_count == 1)	// the last object using texture doesn't want it any more		{			UnloadPicture();	// purge the picture (but keep the thumbnail around)		}				// fix up doc use count, even if this is a placeholder texture item		doc_use_count--;							// update doc use count		texture->global_use_count--;	// update texture global use count	}/*------------------------------------------------------------------------------*//*	This routine loads the picture into memory so that it can be used as a texture.  It	increments use_count so we know how many times this texture is used, so we can unload	it when it is no longer used.  We check to make sure the Pict is not in memory	before loading it because the texture could be Use()'d but not really used in	the document.*/int TextureItem::DocUseFeat(struct SurfFeature *v)	{		int err = 0;	struct SurfFeature *local_v;		// add the surface feature pointer to the list of objects using this texture				local_v = v;				// add it to the array.  Note that we do not check to make sure the object is		// not already in the array.  This is because surfaces and polys can have 		// inside and outside textures, and they will be added twice to this array.		// But they will be removed twice also so everything will be okay.  But when		// we are making this a real texture item, we don't want to add it again,		// so we check our global. 				if (!gMakingReal)					// if we are making it a real texture item,			feats->Append(&local_v);		// then the item is already in the array					// if this texture item is a placeholder, then return immediately, because		// we have done what we need to do (and messing around with the use counts		// may screw things up if the texture file reference has not been set yet).				if (id != NON_IO_ID) 			return(noErr);		#if DEBUG		if (texture == NULL) DEBUGGER();#else		if (texture == NULL) return(-1);	// error if no texture defined GJR091593#endif				if (texture->global_use_count == 0) 		// no one was using the texture before now, so load it		{			// note that LoadPicture does not really load QuickTime movies			err = LoadPicture();		// load the picture		}		if (!err) 		{				doc_use_count++;						// update doc use count if no error			texture->global_use_count++;		// update texture global use count		}		return(err);	}/*------------------------------------------------------------------------------*//*	This routine unloads the picture if this texture is no longer used.  */void TextureItem::DocUnuseFeat(struct SurfFeature *v)	{		int err;	struct SurfFeature *local_v;	int pos;				local_v = v;		if ((pos = (feats->Find(&local_v))) < 0)		{ 			DEBUGGER();            return;			// WHY????? err = err / 0; //еее programmer error; object not in array !!!		}				feats->Remove(pos);//JAM 28Sept93 changed comments so noone will destroy this fix again! [[[		// if this texture item is a placeholder, then return immediately, because		// we don't need to do anything here.  We CANNOT, however move this return		// to the beginning of the routine, because the item must be deleted		// from the list, so an infinite loop doesn't occur.  Really need to		// rewrite logic so the calling routine does the Remove(pos)		//JAM 28Sept93 changed comments so noone will destroy this fix again! ]]]				if (id != NON_IO_ID) 			return;				if (texture == NULL) return;	//  no texture defined GJR091593		if (texture->global_use_count == 1)	// the last object using texture doesn't want it any more		{			UnloadPicture();	// purge the picture (but keep the thumbnail around)		}				// fix up doc use count, even if this is a placeholder texture item		doc_use_count--;							// update doc use count		texture->global_use_count--;	// update texture global use count	}/*------------------------------------------------------------------------------*//*	This routine loads the picture into memory so that it can be used as a texture.  It	increments use_count so we know how many times this texture is used, so we can unload	it when it is no longer used.  We check to make sure the Pict is not in memory	before loading it because the texture could be DocUse()'d and so might already	be in memory.*/int TextureItem::TIUse()//DAS-LK 10/2/93	{		int error = 0;		if (!texture) return -1;			if (texture->global_use_count == 0) 		// no one was using the texture before now, so load it		{			// note that LoadPicture does not really load QuickTime movies			error = LoadPicture();		// load the picture		}		if (!error) 		{			use_count++;							// update use count if no error			texture->global_use_count++;			// update texture global use count		}		return(error);	}/*------------------------------------------------------------------------------*//*	This routine unloads the picture if this texture is no longer used.  */void TextureItem::TIUnuse()//DAS-LK 10/2/93	{			if (!texture) return;				if (texture->global_use_count == 1)	// the last object using texture doesn't want it any more		{			UnloadPicture();	// purge the picture (but keep the thumbnail around)		}		use_count--;						// update use count		texture->global_use_count--;		// update texture global use count	}/*------------------------------------------------------------------------------*//*	This routine applies the texture to all of the objects/surfaces/features	that use it.  It is called after file i/o to calc the texture mapping for all	things that were loaded.  During file i/o certain lists may not be set up	properly (and of course the texture mapping routine checks for this), so we	defer the mapping until now.*/void TextureItem::ApplyTexture(){	int i;Polyhedron **pls;SurfDef **sds;SurfFeature **sfs;int did_resequence = FALSE;	pls = (Polyhedron **)polys->Use();	for ( i = 0 ; i < polys->ALength() ; i++ )	{		// recalc the texture mapping for this object		pls[i]->CalcTextureMapping();				if ((!did_resequence) && (pls[i]->drawing))		{			pls[i]->drawing->Sequence();			did_resequence = TRUE;		}	}	polys->Unuse();	sds = (SurfDef **)surfs->Use();	for ( i = 0 ; i < surfs->ALength() ; i++ )	{		// recalc the texture mapping for this object		sds[i]->CalcTextureMapping();		if ((!did_resequence) && 			(sds[i]->polyhedron) &&			(sds[i]->polyhedron->drawing))			{				sds[i]->polyhedron->drawing->Sequence();				did_resequence = TRUE;			}	}	surfs->Unuse();	sfs = (SurfFeature**)feats->Use();	for ( i = 0 ; i < feats->ALength() ; i++ )	{		// recalc the texture mapping for this object		sfs[i]->CalcTextureMapping();		if ((!did_resequence) && 			(sfs[i]->surfDef) &&			(sfs[i]->surfDef->polyhedron) &&			(sfs[i]->surfDef->polyhedron->drawing))			{				sfs[i]->surfDef->polyhedron->drawing->Sequence();				did_resequence = TRUE;			}	}	feats->Unuse();}/*------------------------------------------------------------------------------*//*	This routine sets all of the objects using this texture item to use no texture	instead.  It is used during file i/o if the user can't (or won't) find a texture	file that was missing.  Ideally, we should retain the texture info so that the	file is not modified.  !!!*/voidTextureItem::NoTexture(){int i;Polyhedron **pls;SurfDef **sds;SurfFeature **sfs;	/*JAM--this doesn't work, because each deletion removes one and shrinks surfs->ALength()	pls = polys->Use();	for ( i = 0 ; i < polys->ALength() ; i++ )	{		// get each object in objects and set its texture to texture item ti.		pls[i]->SetTexture(NULL, SURF_SHARED);	}	polys->Unuse();	sfs = (SurfFeature **)feats->Use();	for ( i = 0 ; i < surfs->ALength() ; i++ )	{		// get each object in objects and set its texture to texture item ti.		sds[i]->SetTexture(NULL, SURF_SHARED);	}	surfs->Unuse();	sfs = feats->Use();	for ( i = 0 ; i < feats->ALength() ; i++ )	{		// get each object in objects and set its texture to texture item ti.		sfs[i]->SetTexture(NULL);	}	feats->Unuse();	*/		/*JAM--this should do the job.  delete the last until there are no more*/		pls = (Polyhedron **)polys->Use();	for( i = polys->ALength(); i > 0; i = polys->ALength())	{		// get each object in objects and set its texture to texture item ti.		pls[i-1]->SetTexture(NULL, SURF_SHARED);	}	polys->Unuse();	sds = (SurfDef **)surfs->Use();	for( i = surfs->ALength(); i > 0; i = surfs->ALength())	{		// get each object in objects and set its texture to texture item ti.		sds[i-1]->SetTexture(NULL, SURF_SHARED);	}	surfs->Unuse();		sfs = (SurfFeature **)feats->Use();	for( i = feats->ALength(); i > 0; i = feats->ALength())	{		// get each object in objects and set its texture to texture item ti.		sfs[i-1]->SetTexture(NULL);	}	feats->Unuse();		// now no objects are using this texture item, and all the objects that	// were using it have no texture.  		// we don't delete this item yet; the calling routine should do that so it	// can do any cleanup it might wanna do.}/*------------------------------------------------------------------------------*//*	This routine changes the texture source file used by this	TextureItem*/voidTextureItem::ChangeSource(V_File *NewSourceFile){	int err;	Texture *oldtexture;	oldtexture = texture;	TextureVFile(NewSourceFile);	//texturevfilechuck--e.g. changesourcechunk(V_file *f, IO_Pos p);	if(texture == oldtexture) return;	//changing to same one	if (texture->global_use_count == 0)		// no one was using the texture before now, so load it	{		// note that LoadPicture does not really load QuickTime movies		err = LoadPicture();		// load the picture		if(err)		{			//JAM--put error dialog here--"couldn't load source...using old"			texture = oldtexture;			return;		}	}	texture->global_use_count += doc_use_count;	oldtexture->global_use_count -= doc_use_count;	if ((oldtexture->global_use_count == 0) && (doc_use_count != 0))	// the last object using texture doesn't want it any more	{		oldtexture->UnloadPicture();	// purge the picture (but keep the thumbnail around)	}}/*------------------------------------------------------------------------------*//*	This routine changes the texture source file used by this	TextureItem, if the source we're changing to is a chunk*/voidTextureItem::ChangeSourceChunk(V_File *NewSourceFile, long io_position){	int err;	Texture *oldtexture;	oldtexture = texture;	TextureChunk(NewSourceFile, io_position);	if(texture == oldtexture) return;	//changing to same one	if (texture->global_use_count == 0)		// no one was using the texture before now, so load it	{		// note that LoadPicture does not really load QuickTime movies		err = LoadPicture();		// load the picture		if(err)		{			//JAM--put error dialog here--"couldn't load source...using old"			texture = oldtexture;			return;		}	}	texture->global_use_count += doc_use_count;	oldtexture->global_use_count -= doc_use_count;	if (oldtexture->global_use_count == 0)	// the last object using texture doesn't want it any more	{		oldtexture->UnloadPicture();	// purge the picture (but keep the thumbnail around)	}}/*------------------------------------------------------------------------------*//*	This routine makes all the objects using this texture item use the texture item	passed in.  After this is done, this texture item can be safely deleted, since	no objects are now using it.		This routine is called for i/o, and this texture item will be a placeholder	texture item temporarily used to give surface features something to attach	themselves to.  After we read in the texture table, we merge the placeholder	texture items with real texture items, and then delete the placeholders.		Note that we can Use() the objects array because it will not be modified by	any of the calls within the loop.*/voidTextureItem::MergeInto(struct TextureItem *ti){int i;Polyhedron **pls;SurfDef **sds;SurfFeature **sfs;#if (MACINTOSH)	if (ti == this)	{		DEBUGSTR((UChar*)"\pprogrammer error, merging with self!!!");	// MERGE-GOURAUD-PRO-8	}#endif //MACINTOSH && DEBUG	/*JAM 22Sept93 SetTexture changes ALength().  instead want to	  do first or last until there are no more*/	// MERGE35 [[[	pls = (Polyhedron **)polys->Use();	for ( i = polys->ALength() ; i > 0 ; i = polys->ALength())	{		if (pls[i-1]->insideTexture == this)			pls[i-1]->SetTexture(ti, SURF_INSIDE);		if (pls[i-1]->outsideTexture == this)			pls[i-1]->SetTexture(ti, SURF_OUTSIDE);	}	polys->Unuse();	sds = (SurfDef **)surfs->Use();	for ( i = surfs->ALength() ; i > 0 ; i = surfs->ALength())	{		if (sds[i-1]->insideTexture == this)			sds[i-1]->SetTexture(ti, SURF_INSIDE);		if (sds[i-1]->outsideTexture == this)			sds[i-1]->SetTexture(ti, SURF_OUTSIDE);	}	surfs->Unuse();	// MERGE35 ]]]	sfs = (SurfFeature **)feats->Use();	for ( i = feats->ALength() ; i > 0 ; i = feats->ALength())		sfs[i-1]->SetTexture(ti);	feats->Unuse();	// now no objects are using this texture item, and all the objects that	// were using it are using the texture item ti.  		// we don't delete this item yet; the calling routine should do that so it	// can do any cleanup it might wanna do.}/*------------------------------------------------------------------------------*//*	This routine turns a temporary placeholder texture item into a real texture	item.   We need to do this to update the doc_count, global_use_count, and	therefore load the picture.  These counts are not updated for placeholder 	items, so we need to update them now.  First we have to rest the id to NON_IO_ID.	This will let DocUse() know that it is supposed to update the counts.	Then we call DocUse as many times as there are objects using this texture item, 	and pass it each object using this texture item -- DocUse is smart enough to check 	the objects array, and so it won't add the object to it, because it will already be	there (the objects using this texture item were added to the objects array during	file i/o).  Note that this works out perfectly because DocUse probably would have	trouble adding an object to the objects array anyway because we lock it here.*/int TextureItem::MakeReal(){OSErr err = noErr;int i;struct SurfFeature *sf;Polyhedron **pls;SurfDef **sds;SurfFeature **sfs;extern int lowMemory;	// reset id so DocUse will update counts, etc.	id = NON_IO_ID;		gMakingReal = TRUE;	// use this texture item as many times as necessary	pls = (Polyhedron **)polys->Use();	for ( i = 0 ; (!err) && (i < polys->ALength()) ; i++ )	{		err = DocUsePoly(pls[i]);		if (lowMemory) err = memFullErr;	// if we are low on memory, then we got an err	}	polys->Unuse();	if (!err)	{		sds = (SurfDef **)surfs->Use();		for ( i = 0 ; (!err) && (i < surfs->ALength()) ; i++ )		{			err = DocUseSurf(sds[i]);		if (lowMemory) err = memFullErr;	// if we are low on memory, then we got an err		}		surfs->Unuse();	}	if (!err)	{		sfs = (SurfFeature **)feats->Use();		for ( i = 0 ; (!err) && (i < feats->ALength()) ; i++ )		{			err = DocUseFeat(sfs[i]);		if (lowMemory) err = memFullErr;	// if we are low on memory, then we got an err		}		feats->Unuse();	}		gMakingReal = FALSE;	return err;}/*------------------------------------------------------------------------------*//*	This routine */voidTextureItem::UniqueName(){	TextureItem *ti;char str[256],digstr[10];int i = 2;	strcpy(str, settings.name);	strcat(str, "+");	while (parent->FindByName(str) != NULL)	{		strcat(str, "+");	}	ObjLock(this);	strcpy(settings.name, str);	ObjUnlock(this);}/*------------------------------------------------------------------------------*//*	This routine */TextureItem *TextureItem::Duplicate(){	TextureItem *ti;char str[256],digstr[10];int i = 2;	ti = new(TextureItem);	ti->cTextureItem(parent);	ti->settings = settings;	ti->texture = texture;	ti->UniqueName();	return ti;}/*------------------------------------------------------------------------------*//*	This routine returns TRUE if the texture is really used in the model.  Note	that the texture may be in memory but not really be used under certain 	circumstances (for example if it were chosen in the palette when no objects	were selected).*/intTextureItem::IsUsedInDocument()	{			return (doc_use_count > 0);	}/*------------------------------------------------------------------------------*//*	This routine returns TRUE if the texture is used by objects (like the palette)	but not counting uses in the model.*/int TextureItem::IsUsed()	{			return (use_count > 0);	}/*------------------------------------------------------------------------------*//*	This routine */void TextureItem::GetFileLoc(VfsLocation *vfsLocation_ptr)					//GJR 10/06/93{		if ((texture) && (texture->tt)) 		texture->GetFileLoc(vfsLocation_ptr);							//GJR 10/06/93	else	{		// these are the bogus values that TTstub returns		// they will be used for comparison purposes		VfsGetBogusLocation(vfsLocation_ptr);							//GJR 10/06/93	}}#if (!VPLAYER)/*------------------------------------------------------------------------------*//*	This routine */intTextureItem::SetThumbnail(V_Offscreen *picture){		if (texture)		return texture->SetThumbnail(picture);	else		return -1;}#endif // (!VPLAYER)/*------------------------------------------------------------------------------*//*	This routine returns a pointer to the V_Offscreen object that is the texture	picture.*/struct V_Offscreen * TextureItem::GetPicture(int index){		if (texture)		return texture->GetPicture(index);	else		return NULL;}/*------------------------------------------------------------------------------*//*	This routine */RGBColor TextureItem::GetFilteredRGB(){		if (texture)		return texture->GetFilteredRGB();	else		return vBlack;}/*------------------------------------------------------------------------------*//*	This routine */void TextureItem::GetTypeStr(char *str)	{			if (texture)			texture->GetTypeStr(str);		else			str[0] = 0;		// set the first char to null. GJR082893	}/*------------------------------------------------------------------------------*//*	This routine */void TextureItem::GetInfoStr(char *str)	{			if (texture)			texture->GetInfoStr(str);		else			str[0] = 0;		// set the first char to null. GJR082893	}/*------------------------------------------------------------------------------*//*	This routine */void TextureItem::GetFullPathStr(char *str){		if (texture)		texture->GetFullPathStr(str);	else		str[0] = 0;		// set the first char to null. GJR082893}/*------------------------------------------------------------------------------*//*	This routine */int TextureItem::SetupFrame(void){	if (texture) return (texture->SetupFrame());	else		return noErr;}/*------------------------------------------------------------------------------*//*	This routine */void TextureItem::GetPaddedRect(Rect *r, int index){	if (texture) texture->GetPaddedRect(r,index);	else 		SetRect(r, 0,0,0,0);}/*------------------------------------------------------------------------------*//*	This routine */void TextureItem::GetUnpaddedRect(Rect *r, int index){	if (texture) texture->GetUnpaddedRect(r,index);	else 		SetRect(r, 0,0,0,0);}/*------------------------------------------------------------------------------*//*	This routine */int TextureItem::IORef(V_Buffer *buf){	if (texture) return(texture->IORef(buf));	else //		return -1;		return noErr;		// let it be ok to have no texture file going out GJR091593}/*------------------------------------------------------------------------------*//*	This routine */int TextureItem::IOOff(V_Buffer *buf){	if (texture) return(texture->IOOff(buf));	else 		return -1;}#if (!VPLAYER)/*------------------------------------------------------------------------------*//*	This routine returns a pointer to the V_Offscreen object that is the texture	thumbnail.*/V_Offscreen * TextureItem::GetThumbnail()	{			if (texture)			return texture->thumbnail;		else			return NULL;	}// jca 18 oct 93 {/*------------------------------------------------------------------------------*//*	This routine returns the thumbnail's rect (which, if we're doing icon caching,	can be much larger than you'd expect!)*/Rect TextureItem::GetThumbnailRect()	{	Rect	nullRect = {0,0,0,0};			if (texture)			return texture->thumbnail_rect;		else			return nullRect;	}#endif // (!VPLAYER)/*------------------------------------------------------------------------------*//*	This routine */intTextureItem::LoadPicture(){	#if 0	{	char str[256]; char *nm;		nm = name->Use();		if (texture)			sprintf(str, "LOADING %s %s\n", texture->tt->type_str, 				nm);		DBF(DB_TEXLOAD, str);				name->Unuse();	}#endif	if (texture)		return texture->LoadPicture();	else		return -1;}/*------------------------------------------------------------------------------*//*	This routine */voidTextureItem::UnloadPicture(){	#if 0	{	char str[256]; char *nm;		nm = name->Use();		if (texture)			sprintf(str, "UNLOADING %s %s\n", texture->tt->type_str, 				nm);		DBF(DB_TEXLOAD, str);				name->Unuse();	}#endif	if (texture)		texture->UnloadPicture();}/*------------------------------------------------------------------------------*//*	This routine */int TextureItem::IO(V_Buffer *buf){	return(noErr);}// ABD 17MAR94 MERGE-BUG/*------------------------------------------------------------------------------*//*	This routine */int TextureItem::SetOffscreen(V_Offscreen *off){		if (texture)		return texture->SetOffscreen(off);	else		return -1;}