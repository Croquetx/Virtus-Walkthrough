/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*//*DoGetDirectory with a Dialog Hook and File Filter*//*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*//*This demonstrates how to modify SFGetFile to allow you to select adirectory.  This mimics the "GetFileName -d" function of MPW.  As a matterof fact, the DLOG and DITL used in this sample were taken directly out ofMPW.  There are 2 major additions in the dialog used in this sample:1. a Simple button that lets one select the directory that is currently   highlighted in the list of directories,2. Simple button at the top of the dialog that lets the user select the   directory that we are currently *IN*.DoGetDirectory--------------Sets up the pointers to the Dialog Hook and File Filter.  Once the userhas selected a folder, we look at the global gMyCurDir which was setwithin the Dialog Hook.  We take this DirID and call PBGetCatInfo to findthe name of this folder.  This is so we can display the name to the user.MyGetDirDlgHook----------------No new techniques are really used in this sample.  Hits on the two simplebuttons are handled by a dialog hook called GetDirDlgHook.  Depending onwhich button is hit, we set the global variable gMyCurDir to eithergReply.fType (for the currently highlighted directory) or what StandardFile has set as the current directory.  We then simulate a hit on the Openbutton so that Standard File will return to our application and theFSReply.good will be TRUE.While an item is selected, the gReply.fType will be set to a value.gReply.fType is set to 0 when nothing is selected.  We test for thisduring idle time (item = 100) and activate the Directory buttonappropriately.  We also use the "Item = -1" feature to set up a promptString.FolderFFilter-------------Normally, folders are ALWAYS shown, and aren't even passed to this filefilter for judgement.  Under such circumstances, it is only necessary toblindly return TRUE (allow no files whatsoever).  However, Standard Fileis not documented in such a manner, and this feature may not be true inthe future.  Therefore, we DO check to see if the entry passed to usdescribes a file or a directory.  This can be done by checking a bitin the ioFlAttrib, which is set for folders.*/#include "VTypes.h"#include <Files.h>#include "GETFOLD.h"#include "AppFiles.h"#include "QuickTim.h"#include "AppText.h"struct SFReply gReply;long gMyCurDir;int gGetDirNowButton;int gLast_btn_set = -1;int gReturnVal;// In case we don't have the universal headers...#ifndef NewDlgHookProc	#define NewDlgHookProc(x) (ProcPtr)x#endif#ifndef NewFileFilterProc	#define NewFileFilterProc(x) (ProcPtr)x#endif/*-----------------------------------------------------------------------------------*//*	PROTOTYPES*/pascal Boolean FolderFFilter(ParmBlkPtr p);long GetSFCurDir(void);int GetSFVRefNum(void);pascal short GetDirDlgHook(short item, DialogPtr dlgPtr);int AddTexturesDialog6(FSSpec *fSpec);/*-----------------------------------------------------------------------------------*//**/pascal Boolean FolderFFilter(ParmBlkPtr p){extern int gQuickTime;	if (p->fileParam.ioFlAttrib & (1<<4)) // a directory 		return false;	else // a file	{		if (p->fileParam.ioFlFndrInfo.fdType == appFileTypePICT) return false;		else if ((gQuickTime) && (p->fileParam.ioFlFndrInfo.fdType == appFileTypeQuickTime)) return false;		else if (p->fileParam.ioFlFndrInfo.fdType == appFileTypeModel) return false;		//else if (p->fileParam.ioFlFndrInfo.fdType == appFileTypeLibrary) return false;		else if (p->fileParam.ioFlFndrInfo.fdType == appFileTypeTextureLibModel) return false;		else if (p->fileParam.ioFlFndrInfo.fdType == appFileTypeVRTextureLib) return false;		// MERGE-GOURAUD-PRO-7		else return true;	}}/*-----------------------------------------------------------------------------------*//**/long GetSFCurDir(){	#ifdef __powerc	return LMGetCurDirStore();	#else	// MERGE-GOURAUD-PRO-7	// for some reason they changed CurDirStore so it's no longer a memory location, but rather	// it actually returns the value of that memory location.  How sweet of them to *!?##* up	// every program in existance.	return CurDirStore;// MERGE-GOURAUD-PRO-7	// MERGE-GOURAUD-PRO-7 return (*((long*)(CurDirStore)));	#endif //__powerc}/*-----------------------------------------------------------------------------------*//**/int GetSFVRefNum(){	#ifdef __powerc	return -LMGetSFSaveDisk();    // PRO-17	#else	// MERGE-GOURAUD-PRO-7	// for some reason they changed SFSaveDisk so it's no longer a memory location, but rather	// it actually returns the value of that memory location.  How sweet of them to fuck up	// every program in existance.	return -SFSaveDisk;// MERGE-GOURAUD-PRO-7 	// MERGE-GOURAUD-PRO-7 return -(*((int*)(SFSaveDisk)));	#endif //__powerc}#define kGetDirNowButtonPreview	16#define kGetDirNowButton	11#define kCntlActivate		0#define kCntlDeactivate 	0xFF#define rGetDirectoryDLOG 	131#define rGetDirectoryPreviewDLOG 	129#define kNoSelection		0				/*reply.fType is NULL for no selection*/#define kNullModalEvt		100				/*Item number for null event from ModalDialog*/#define kNoItem				0				/*no item, ignore it*/#define kFirstTime			-1				/*the first time our hook it's passed a -1*/#define kShowAllFiles		-1				/*show all files in the StdFile list*//*-----------------------------------------------------------------------------------*//**/pascal short GetDirDlgHook(short item, DialogPtr dlgPtr){Rect iRect;Handle iHandle;short iKind;int return_val;		return_val = item;						/*default, return same item*/		if (item == gGetDirNowButton)	{		gMyCurDir = GetSFCurDir();		return_val = getOpen;				/*simulate Open button*/		gReturnVal = ADD_TEXTURES_FOLDER;	}	else switch (item)	{		case getOpen:			// if the selection is a folder, open it			if ((((long)(gReply.fType)) != kNoSelection) && (gReply.fName[0] == 0)) 			{ 				gMyCurDir = ((long)(gReply.fType));				gReturnVal = ADD_TEXTURES_FOLDER;			}			else			{				gReturnVal = ADD_TEXTURES_FILE;			}			break;		case kNullModalEvt:						// if no selection, dim the open button and set name to open			if ((((long)(gReply.fType)) == kNoSelection) && (gReply.fName[0] == 0)) 			{				if (gLast_btn_set == 0) break;				gLast_btn_set = 0;				GetDItem(dlgPtr, getOpen, &iKind, (Handle*)&iHandle, &iRect);				HiliteControl((ControlHandle)iHandle, kCntlDeactivate);				SetCTitle((ControlHandle)iHandle, (unsigned char*)TXTI_OPEN);	// PRO-JAP			}			// if the selection is a folder, change add button name to Open and activate btn			else if ((((long)(gReply.fType)) != kNoSelection) && (gReply.fName[0] == 0)) 			{ 				if (gLast_btn_set == 1) break;				gLast_btn_set = 1;				GetDItem(dlgPtr, getOpen, &iKind, (Handle*)&iHandle, &iRect);				HiliteControl((ControlHandle)iHandle, kCntlActivate);				SetCTitle((ControlHandle)iHandle, (unsigned char*)TXTI_OPEN);	// PRO-JAP			}			// if the selection is a file, set add button to Add and activate btn			else if ((((long)(gReply.fType)) != kNoSelection) && (gReply.fName[0] != 0)) 			{ 				if (gLast_btn_set == 2) break;				gLast_btn_set = 2;				GetDItem(dlgPtr, getOpen, &iKind, (Handle*)&iHandle, &iRect);				HiliteControl((ControlHandle)iHandle, kCntlActivate);				SetCTitle((ControlHandle)iHandle, (unsigned char*)TXTI_ADD);	// PRO-JAP			}			break;	}	return return_val;}/*-----------------------------------------------------------------------------------*//**/int AddTexturesDialog6(FSSpec *fSpec){Str31 folderName = "";					/*directories can be 31 chars*/SFTypeList typeList;DirInfo myCInfo;OSErr err;Point where = {100, 80};	// default guess for centering	GJR083093int i;extern int gQuickTime;	gLast_btn_set = -1;		if (gQuickTime)	{		where.h = -2;		where.v = -2;		// auto center for quicktime		GJR083093		gGetDirNowButton = kGetDirNowButton;		SFPGetFile(where,							/*location*/				   (ConstStr255Param)"",			/*vestigial String*/				   NewFileFilterProc(FolderFFilter),/*file filter*/				   kShowAllFiles,					/*numtypes*/				   typeList,						/*array to types to show*/				   NewDlgHookProc(GetDirDlgHook),	/*Dialog hook*/				   &gReply,							/*record for returned values*/				   rGetDirectoryDLOG,				/*Resource ID dialog*/				   NULL);							/*ModalDialog filter proc*/#if 0		gGetDirNowButton = kGetDirNowButtonPreview;		SFPGetFile(where,							/*location*/				   (ConstStr255Param)"",			/*vestigial String*/				   NewFileFilterProc(FolderFFilter),/*file filter*/				   kShowAllFiles,					/*numtypes*/				   typeList,						/*array to types to show*/				   NewDlgHookProc(GetDirDlgHook),	/*Dialog hook*/				   &gReply,							/*record for returned values*/				   rGetDirectoryPreviewDLOG,		/*Resource ID dialog*/				   NULL);							/*ModalDialog filter proc*/#endif	}	else	{		gGetDirNowButton = kGetDirNowButton;		SFPGetFile(where,							/*location*/				   (ConstStr255Param)"",			/*vestigial String*/				   NewFileFilterProc(FolderFFilter),/*file filter*/				   kShowAllFiles,					/*numtypes*/				   typeList,						/*array to types to show*/				   NewDlgHookProc(GetDirDlgHook),	/*Dialog hook*/				   &gReply,							/*record for returned values*/				   rGetDirectoryDLOG,				/*Resource ID dialog*/				   NULL);							/*ModalDialog filter proc*/	}			   	if (gReply.good)  	{				// if there is no error, we need to fake a fsspec record that contains		// the name, parID, and vRefNum of this folder.  We know the name and 		// vRefNum, but we need the parID -- gMyCurDir is the actual dirID of the		// folder, so we fill in parID with the parent directory id.  We need to do		// this because LoadTexturesInDir expects a properly set up FSSpec.						if (gReturnVal == ADD_TEXTURES_FOLDER)		{			myCInfo.ioCompletion = NULL;					/*no completion*/			myCInfo.ioNamePtr = folderName;			/*VAR to string*/			myCInfo.ioFDirIndex = -1;					/*-1 means use ioDrDirID*/			myCInfo.ioVRefNum = GetSFVRefNum(); 			/*this is the volume*/			myCInfo.ioDrDirID = gMyCurDir;				/*this is the directory*/			err = PBGetCatInfo((CInfoPBPtr)&myCInfo, FALSE);			if (err) return ADD_TEXTURES_CANCEL;			for (i = 0;i<64;i++) fSpec->name[i] = myCInfo.ioNamePtr[i];			fSpec->parID = myCInfo.ioDrParID;				fSpec->vRefNum = GetSFVRefNum();		}		else if (gReturnVal == ADD_TEXTURES_FILE)		{			for (i = 0;i<64;i++) fSpec->name[i] = gReply.fName[i];			fSpec->parID = GetSFCurDir();			fSpec->vRefNum = GetSFVRefNum();		}		return gReturnVal;	}	else	{		return ADD_TEXTURES_CANCEL;	}}