#include "VTypes.h"#include "WTypes.h"#include <stdio.h>#include <string.h>#include <QuickTimeComponents.h>#include "VMDL.h"#include "ShowTest.h"			// !!! DEBUG#include "AppText.h"			// needed for IO()#include "AppFiles.h"			// needed for IO()#include "VDisplay.h"#include "VGraphic.h"#include "VMemUtil.h"#include "VError.h"#include "VFile.h"#include "Texture.h"			//moved down after vfile		//GJR 10/06/93#include "TextType.h"#include "VRIcon.h"			// jca 18 Oct 93#include "TEXTSRVR.h"		// ABD 12/10/93/*------------------------------------------------------------------------------*//*	This routine creates a new texture object and fills in the texture fields to 	point to no file.  Do not call this routine directly; use the TextureServer 	routine NewTexture() instead.*/void Texture::cTexture(int texture_type){	int err;Rect thumb_rect;	tt = NULL;		// ABD added init here 12/9/93	type = texture_type;		global_use_count = 0;		SetRect(&thumb_rect, 0, 0, 32, 32);#if (!VPLAYER)	thumbnail = new(V_Offscreen);	//	JAM--use 8 bit when creating textures 	//  thumbnail->cOffscreen(&thumb_rect, MainDepth(), &vWhite, NULL);	thumbnail->cOffscreen(&thumb_rect, 8, &vWhite, NULL);#endif // (!VPLAYER)	switch (type)	{#if WINDOWS		case TEXTURE_BMPFILE:			tt = new(TTBMPFile); 			tt->class_type = TEXTURE_FILE;			break;	#elif MACINTOSH		case TEXTURE_PICTFILE:			tt = new(TTPICTFile); 			tt->class_type = TEXTURE_FILE;			break;			case TEXTURE_QUICKTIME:			tt = new(TTQuickTime); 			tt->class_type = TEXTURE_FILE;			break;	#if 0	// MERGE-PRO no vdigs for now#if VPRO		case TEXTURE_VDIG: 			tt = new(TTVDIG);			tt->class_type = TEXTURE_NONE;			break;	#endif //VPRO#endif#endif //WINDOWS		case TEXTURE_CHUNK: 			tt = new(TTChunk); 			tt->class_type = TEXTURE_FILE;			break;			case TEXTURE_PICT: 	// MERGE-BUG			tt = new(TTPICT); 	// MERGE-BUG			tt->class_type = TEXTURE_NONE;	// MERGE-BUG			break;			default:			tt = new(TextureType);			tt->class_type = TEXTURE_NONE;			break;	}	tt->cTextureType();	#if (!VPLAYER)	// For file-based textures, we have to wait until we have our file set before	// we make the thumbnail.  Others can do it now.	if ((tt->class_type != TEXTURE_FILE) && (type != TEXTURE_PICT))		// MERGE-BUG	{		ObjLock(this);		err = tt->MakeThumbnail(thumbnail, &thumbnail_rect);		ObjUnlock(this);	}#endif // (!VPLAYER)}/*------------------------------------------------------------------------------*//*	This routine deletes the texture object and associated objects.*/void Texture::dTexture(void){extern struct TextureServer *gTextureServer;	// ABD added check for tt here	if (tt) tt->dTextureType();	if (gTextureServer)		gTextureServer->RemoveTexture(this);	//if (thumbnail) thumbnail->dOffscreen();		// MERGE-CLEANUP	#if VPRO	//JAM 24OCT94	//this does need to be deleted at the end.  In VR, it	//probably gets deleted in the icon cache stuff, so it	//had to be commented out here 	if (thumbnail) thumbnail->dOffscreen();		// MERGE-CLEANUP	#endif	delete this;}/*------------------------------------------------------------------------------*//*	This routine sets the texture to be based on the file info passed to it.  It 	does processing necessary to create the texture thumbnail, movie, etc.  This	texture must have a corresponding TextureType that is a FileTextureType		The texture fields with the file reference info passed in	as parameters.  fn must be a *Pascal* string, as is returned by most toolbox	calls.  fn,dir,vol will be passed to SetLocation(), so see the documentation	for that routine about what is acceptable to pass to it.	This method assumes that the texture->file has been set up appropriately (i.e.	it is a reference to a file).  This method will Use() the texture (thus loading	the picture file), save a smaller version of the picture in the thumbnail (which	was created in cTexture(), and then Unuse() the texture (thus deleting the picture).	The picture will be loaded for real when the texture is actually used in a model.		!!! see comments in routine for what it actually does.*/int Texture::SetTextureChunkPosition(long io_position){	int err = noErr;		if (type != TEXTURE_CHUNK) 		return(-1);		((TTChunk*)tt)->io_position = io_position;	return (err);}/*------------------------------------------------------------------------------*//*	gets chunk position of the texture if it is of type TEXTURE_CHUNK*/long Texture::GetTextureChunkPosition(){	int err = noErr;		if (type != TEXTURE_CHUNK) 		return(-1);		return(((TTChunk*)tt)->io_position);}/*------------------------------------------------------------------------------*//**/int Texture::SetTextureVFile(V_File *file){	int err = noErr;VfsLocation *vfsLocation;						//GJR 10/06/93V_Offscreen *picture;		if (tt->class_type != TEXTURE_FILE) 		return(-1);	vfsLocation = new(VfsLocation);	vfsLocation->cVfsLocation();	if (((FileTextureType*)tt)->file)	// BILBIL - use the real file if we can		{		err = file->VGetLocation(vfsLocation);		if (err) {vfsLocation->dVfsLocation(); return err; }		err = ((FileTextureType*)tt)->SetFileLoc(vfsLocation);		if (err) {vfsLocation->dVfsLocation(); return err; }        ((FileTextureType *)tt)->SetVfsLocation(vfsLocation);		}	else								// BILBIL - use the real file if we can [[[		{		((FileTextureType*)tt)->file = file;		err = file->VGetLocation(vfsLocation);		if (err) {vfsLocation->dVfsLocation(); return err; }		((FileTextureType *)tt)->SetVfsLocation(vfsLocation);		}								// BILBIL - use the real file if we can ]]]    vfsLocation->dVfsLocation();	return (err);}#if (!VPLAYER)/*------------------------------------------------------------------------------*//**/int Texture::SetThumbnail(V_Offscreen *off){	int err = noErr;Rect r;	if (!thumbnail) return(-1);	if (!off) return(-1);	thumbnail->GetRect(&r);	ObjLock(this);	err = tt->SetThumbnail(off, thumbnail, &thumbnail_rect);	ObjUnlock(this);#if VR_CACHE_TEXTURE_ICONS			// jca 18 Oct 93 {	if ((globalTextureIcons) && !err)  // jca 2 Dec 93		{		thumbnail_rect = r;		globalTextureIcons->Add(thumbnail, &thumbnail_rect, vSrcCopy);		thumbnail->dOffscreen();		thumbnail = globalTextureIcons->GetOffscreen();	//	ShowOffscreenMore(thumbnail);		}#endif // VR_CACHE_TEXTURE_ICONS	// jca 18 Oct 93 }	return err;}#endif //(!VPLAYER)/*------------------------------------------------------------------------------*//*	This routine sets the texture to be based on the file info passed to it.  It 	does processing necessary to create the texture thumbnail, movie, etc.  This	texture must have a corresponding TextureType that is a FileTextureType		The texture fields with the file reference info passed in	as parameters.  fn must be a *Pascal* string, as is returned by most toolbox	calls.  fn,dir,vol will be passed to SetLocation(), so see the documentation	for that routine about what is acceptable to pass to it.	This method assumes that the texture->file has been set up appropriately (i.e.	it is a reference to a file).  This method will Use() the texture (thus loading	the picture file), save a smaller version of the picture in the thumbnail (which	was created in cTexture(), and then Unuse() the texture (thus deleting the picture).	The picture will be loaded for real when the texture is actually used in a model.		!!! see comments in routine for what it actually does.*/int Texture::SetTextureFileLoc(VfsLocation *vfsLocation)				//GJR 10/06/93{	int err = noErr;char str[256];int position;AliasHandle als = NULL;V_Offscreen *picture;		if (tt->class_type != TEXTURE_FILE) 		return(-1);//REPLACE			//GJR 10/06/93	err = ((FileTextureType*)tt)->SetFileLoc(vfsLocation);	if (err) return err;	#if (!VPLAYER)	// now make the thumbnail and MIP maps and get the actual thumbnail rect	ObjLock(this);	err = tt->MakeThumbnail(thumbnail, &thumbnail_rect);	ObjUnlock(this);#if VR_CACHE_TEXTURE_ICONS			// jca 18 Oct 93 {	if ((globalTextureIcons) && (!err))		{		thumbnail->GetRect(&thumbnail_rect);		globalTextureIcons->Add(thumbnail, &thumbnail_rect, vSrcCopy);		thumbnail->dOffscreen();		thumbnail = globalTextureIcons->GetOffscreen();	//	ShowOffscreenMore(thumbnail);		}#endif // VR_CACHE_TEXTURE_ICONS	// jca 18 Oct 93 }	if (err) return err;#endif // (!VPLAYER)	return (err);}/*------------------------------------------------------------------------------*//*	This routine */void Texture::GetFileLoc(VfsLocation *vfsLocation_ptr){	if (tt->class_type == TEXTURE_FILE)	{		if(type == TEXTURE_CHUNK)			{            ((TTChunk*)tt)->GetFileLoc(vfsLocation_ptr);            }//MODIFIED	//GJR 10/06/93		else        	{			((FileTextureType*)tt)->GetFileLoc(vfsLocation_ptr);			}	}	else	{		// these are the bogus values that TTstub returns		// they will be used for comparison purposes		VfsGetBogusLocation(vfsLocation_ptr);	}}/*------------------------------------------------------------------------------*//*	This routine */int Texture::LoadPicture(void){OSErr err = noErr;	err = tt->LoadPicture();	if (err == noErr) 		err = tt->MakeMIP();}/*------------------------------------------------------------------------------*//*	This routine */void Texture::UnloadPicture(void){	tt->UnloadPicture();}/*------------------------------------------------------------------------------*//*	This routine */void Texture::Lock(){		tt->Lock();}/*------------------------------------------------------------------------------*//*	This routine */void Texture::Unlock(){		tt->Unlock();}// MERGE-CLEANUP [[[/*------------------------------------------------------------------------------*//*	This routine */void Texture::UnlockCompletely(){		tt->UnlockCompletely();}// MERGE-CLEANUP ]]]/*------------------------------------------------------------------------------*//*	This routine */int Texture::SetupFrame(void){	return tt->SetupFrame();}/*------------------------------------------------------------------------------*//*	This routine */V_Offscreen *Texture::GetPicture(int index){	return tt->GetPicture(index);}/*------------------------------------------------------------------------------*//*	This routine */RGBColor Texture::GetFilteredRGB(){		return tt->GetFilteredRGB();}/*------------------------------------------------------------------------------*//*	This routine */void Texture::GetPaddedRect(Rect *r,int index){	tt->GetPaddedRect(r,index);}/*------------------------------------------------------------------------------*//*	This routine */void Texture::GetUnpaddedRect(Rect *r,int index){	tt->GetUnpaddedRect(r,index);}/*------------------------------------------------------------------------------*//*	This routine */void Texture::GetTypeStr(char *str){		tt->GetTypeStr(str);}/*------------------------------------------------------------------------------*//*	This routine */void Texture::GetInfoStr(char *str){		tt->GetInfoStr(str);}/*------------------------------------------------------------------------------*//*	This routine */void Texture::GetFullPathStr(char *str){		tt->GetFullPathStr(str);}/*------------------------------------------------------------------------------*//*	This routine */int Texture::IORef(V_Buffer *buf){	return tt->IORef(buf);}/*------------------------------------------------------------------------------*//*	This routine */int Texture::IOOff(V_Buffer *buf){	return tt->IOOff(buf);} // ABD MERGE-BUG 17MAR94/*------------------------------------------------------------------------------*//*	This routine */int Texture::SetOffscreen(V_Offscreen *off){		return tt->SetOffscreen(off);}