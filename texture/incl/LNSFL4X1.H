void XCAT(LinearScanFill4x1pln_,ROUTINENUMBER)	(struct ScanLineInfo *LineInfo)/*						 (int NumOfPixels, 						  #if SHADED(ROUTINENUMBER)						  unsigned char *dith1,						  unsigned char *dith2,						  #endif						  unsigned char *yy,						  FFixed x, FFixed dx, FFixed y, FFixed dy,						  int horizontaltexturemask, int verticaltexturemask,						  unsigned char **fromRaster)*/{int NumOfPixels = LineInfo->NumOfPixels;unsigned long *colorlookup = (unsigned long *)LineInfo->dith1;unsigned char *yy0 = LineInfo->yy0;unsigned char *yy1 = yy0 + LineInfo->offset4x1;unsigned char *yy2 = yy1 + LineInfo->offset4x1;unsigned char *yy3 = yy2 + LineInfo->offset4x1;FFixed x = LineInfo->x;FFixed dx = LineInfo->dx;FFixed y = LineInfo->y;FFixed dy = LineInfo->dy;int horizontaltexturemask = LineInfo->horizontaltexturemask;int horizontalmirrormask = LineInfo->horizontalmirrormask;int verticaltexturemask = LineInfo->verticaltexturemask;int verticalmirrormask = LineInfo->verticalmirrormask;unsigned char **localfromRaster = LineInfo->fromRaster;int xint, yint;long horizontalmirrortest;long verticalmirrortest;#if (!ISAPOWEROFTWO(ROUTINENUMBER))int currentverticaltile = 0;int currenthorizontaltile = 0;#endif/*C version for now*/#if 1unsigned char byte, subbyte;byteword word;unsigned long subword;int maskindex, endmaskindex, PixelsPerByte;unsigned long *mask;int LastByteDone = 0;/*	if(BitDepthId == BITDEPTHID4) {		PixelsPerByte = 2;		endmaskindex = 1;		mask = mask4bitforward;	}	else if(BitDepthId == BITDEPTHID2) {		PixelsPerByte = 4;		endmaskindex = 3;		mask = mask2bitforward;	}	else if(BitDepthId == BITDEPTHID1) {		PixelsPerByte = 8;		endmaskindex = 7;		mask = mask1bitforward;	}*/	PixelsPerByte = 8;	endmaskindex = 7;    mask = mask4x1bitforward;//	byte = *yy;	//construct word from current set of planes	word.b.b0 = *yy0;	word.b.b1 = *yy1;	word.b.b2 = *yy2;	word.b.b3 = *yy3;	maskindex = InitialMaskIndex;	NumOfPixels += InitialMaskIndex;while(LastByteDone != 2) {	while(NumOfPixels >= PixelsPerByte) {			for(;			maskindex <= endmaskindex;			maskindex++) {				x.l += dx.l;	y.l += dy.l;	#if ISAPOWEROFTWO(ROUTINENUMBER)		xint = x.intg & horizontaltexturemask;		#if HMIRROR(ROUTINENUMBER)		if(x.intg & horizontalmirrormask) xint = horizontaltexturemask - xint;		#endif			yint = y.intg & verticaltexturemask;		#if VMIRROR(ROUTINENUMBER)		if(y.intg & verticalmirrormask) yint = verticaltexturemask - yint;		#endif	#else		while(x.intg < 0) {			currenthorizontaltile++;			x.intg += horizontalmirrormask;		}		while(x.intg >= horizontalmirrormask) {			currenthorizontaltile++;			x.intg -= horizontalmirrormask;		}		while(y.intg < 0) {			currentverticaltile++;			y.intg += verticalmirrormask;		}		while(y.intg >= verticalmirrormask) {			currentverticaltile++;			y.intg -= verticalmirrormask;		}		xint = x.intg;		#if HMIRROR(ROUTINENUMBER)		if(currenthorizontaltile & 1) xint = horizontaltexturemask - xint;		#endif				yint = y.intg;		#if VMIRROR(ROUTINENUMBER)		if(currentverticaltile & 1) yint = verticaltexturemask - yint;		#endif		#endif		#if DECAL(ROUTINENUMBER)	if(localfromRaster[yint][xint] != 0) {	#endif		/*			if(maskindex & 1) {				subbyte = dith2[localfromRaster[yint][xint]];			}			else {				subbyte = dith1[localfromRaster[yint][xint]];			}		*/			subword = colorlookup[localfromRaster[yint][xint]];		//	byte = ((byte^subbyte)&(mask[maskindex]))^subbyte;        	word.w = ((word.w^subword)&(mask[maskindex]))^subword;	#if DECAL(ROUTINENUMBER)	}	#endif		}		*yy0 = word.b.b0;	*yy1 = word.b.b1;	*yy2 = word.b.b2;	*yy3 = word.b.b3;	maskindex = 0;	yy0++; yy1++; yy2++; yy3++;#if 0#if WINDOWS	// Modify to convert linear pointer to segment adjusted pointer //GJR 10/29/93	if (FP_OFF(yy) == 0)  // if we just crossed (all accesses segment aligned)		{	// then let compiler see the segment crossing		char huge* hugepc  = (char huge*)((UCharPtr)yy - 1); // prepare to re-cross the segment		hugepc += 1;		//Note: can't we do this ourselves? (since even the compiler hardcodes in <<3)		yy      = (UCharPtr)hugepc;		}#endif#endif	#if DECAL(ROUTINENUMBER)//	byte = *yy;	word.b.b0 = *yy0;	word.b.b1 = *yy1;	word.b.b2 = *yy2;	word.b.b3 = *yy3;	#else	word.w = 0;	#endif	NumOfPixels -= PixelsPerByte;}if(LastByteDone++ == 0) {	if(NumOfPixels != 0) {		word.b.b0 = *yy0;		word.b.b1 = *yy1;		word.b.b2 = *yy2;		word.b.b3 = *yy3;		endmaskindex = NumOfPixels - 1;		NumOfPixels = PixelsPerByte;	}	else { LastByteDone++; }}}#endif}