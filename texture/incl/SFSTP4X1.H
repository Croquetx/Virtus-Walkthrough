/*this file is the body of the scanfill routines for textures where the  slope of the line of constant depth are greater than 45 degrees.  It is  used in scanfillgenerator.h to generate 16 cases of routines for texture8*/#if 0d0	---d1	IndexLoopd2	fxd3	fyd4  horizontaltexturewrapd5	verticaltexturewrapd6	horizontalmirrortestd7	verticalmirrortesta0	---a1	dither1a2	dither2a3	yya4	texturetablea5	fromRaster#endif	void XCAT(scanfillsteepslope4x1pln_,ROUTINENUMBER)(struct ScanLineInfo *LineInfo) {int index = LineInfo->index;int index2 = LineInfo->index2;unsigned long *colorlookup = (unsigned long *)LineInfo->longptr;unsigned char *yy0 = LineInfo->yy0;unsigned char *yy1 = yy0 + LineInfo->offset4x1;unsigned char *yy2 = yy1 + LineInfo->offset4x1;unsigned char *yy3 = yy2 + LineInfo->offset4x1;int horizontaltexturemask = LineInfo->horizontaltexturemask;int horizontalmirrormask = LineInfo->horizontalmirrormask;int verticaltexturemask = LineInfo->verticaltexturemask;int verticalmirrormask = LineInfo->verticalmirrormask;unsigned char **localfromRaster = LineInfo->fromRaster;/*C version for now*/#if 1int fx, fy;FFixed *tableptr;unsigned char byte, subbyte;byteword word;unsigned long subword;int maskindex, endmaskindex, PixelsPerByte;unsigned long *mask;int NumOfPixels = index2 - index + 1;int LastByteDone = 0;FFixed tempfixed;#if HMIRROR(ROUTINENUMBER)int doublehorizontalmirrormask = horizontalmirrormask << 1;#endif#if VMIRROR(ROUTINENUMBER)int doubleverticalmirrormask = verticalmirrormask << 1;#endif	tableptr = &(texturetable[(index<<2) + 1]);/*		if(BitDepthId == BITDEPTHID4) {		PixelsPerByte = 2;		endmaskindex = 1;		mask = mask4bitforward;	}	else if(BitDepthId == BITDEPTHID2) {		PixelsPerByte = 4;		endmaskindex = 3;		mask = mask2bitforward;	}	else if(BitDepthId == BITDEPTHID1) {		PixelsPerByte = 8;		endmaskindex = 7;		mask = mask1bitforward;	}*/	PixelsPerByte = 8;	endmaskindex = 7;    mask = mask4x1bitforward;	//	byte = *yy;	//construct word from current set of planes	word.b.b0 = *yy0;	word.b.b1 = *yy1;	word.b.b2 = *yy2;	word.b.b3 = *yy3;	maskindex = InitialMaskIndex;	NumOfPixels += InitialMaskIndex;while(LastByteDone != 2) {	while(NumOfPixels >= PixelsPerByte) {			for(;			maskindex <= endmaskindex;			maskindex++) {					#if ISAPOWEROFTWO(ROUTINENUMBER) 			#if HMIRROR(ROUTINENUMBER)			if(tableptr->intg & horizontalmirrormask)				fx = horizontaltexturemask - (tableptr->intg & horizontaltexturemask);			else				fx = tableptr->intg & horizontaltexturemask;			#else			fx = tableptr->intg & horizontaltexturemask;			#endif			/*apply the delta texture x*/			tableptr->l += (tableptr-1)->l;			tableptr += 2;						#if VMIRROR(ROUTINENUMBER)			if(tableptr->intg & verticalmirrormask)				fy = verticaltexturemask - (tableptr->intg & verticaltexturemask);			else				fy = tableptr->intg & verticaltexturemask;			#else			fy = tableptr->intg & verticaltexturemask;			#endif			tableptr->l += (tableptr-1)->l;			tableptr += 2;		#else			#if HMIRROR(ROUTINENUMBER)			tempfixed.l = tableptr->l;			while(tempfixed.intg < 0)				tempfixed.intg += doublehorizontalmirrormask;			while(tempfixed.intg >= doublehorizontalmirrormask)				tempfixed.intg -= doublehorizontalmirrormask;			fx = tempfixed.intg;			if(fx >= horizontalmirrormask)				fx = doublehorizontalmirrormask - fx - 1;			tableptr->l = tempfixed.l + (tableptr-1)->l;			#else			tempfixed.l = tableptr->l;			while(tempfixed.intg < 0)				tempfixed.intg += horizontalmirrormask;			while(tempfixed.intg >= horizontalmirrormask)				tempfixed.intg -= horizontalmirrormask;			fx = tempfixed.intg;			tableptr->l = tempfixed.l + (tableptr-1)->l;			#endif			tableptr += 2;						#if VMIRROR(ROUTINENUMBER)			tempfixed.l = tableptr->l;			while(tempfixed.intg < 0)				tempfixed.intg += doubleverticalmirrormask;			while(tempfixed.intg >= doubleverticalmirrormask)				tempfixed.intg -= doubleverticalmirrormask;			fy = tempfixed.intg;			if(fy >= verticalmirrormask)				fy = doubleverticalmirrormask - fy - 1;			tableptr->l = tempfixed.l + (tableptr-1)->l;			#else			tempfixed.l = tableptr->l;			while(tempfixed.intg < 0)				tempfixed.intg += verticalmirrormask;			while(tempfixed.intg >= verticalmirrormask)				tempfixed.intg -= verticalmirrormask;			fy = tempfixed.intg;			tableptr->l = tempfixed.l + (tableptr-1)->l;			#endif			tableptr += 2;		#endif								/*draw the pixel.  If there's mirroring involved, use the		  next higher adress bit to specify which direction tile		  we are on.  If there is flip, reverse this direction.		  if decal is on, check for white pixel*/		/*draw the pixel, handling dithering.  if decal is on, also check for a		  white pixel*/		#if DECAL(ROUTINENUMBER)		if(localfromRaster[fy][fx] != 0) {		#endif        /*			if(maskindex & 1) {				subbyte = dith2[localfromRaster[fy][fx]];			}			else {				subbyte = dith1[localfromRaster[fy][fx]];			}		*/			subword = colorlookup[localfromRaster[fy][fx]];		//	byte = ((byte^subbyte)&(mask[maskindex]))^subbyte;        	word.w = ((word.w^subword)&(mask[maskindex]))^subword;		#if DECAL(ROUTINENUMBER)		}		#endif				/*		yy--;		*/				/*move to next pixel--next table entry too, if necessary*/	}	*yy0 = word.b.b0;	*yy1 = word.b.b1;	*yy2 = word.b.b2;	*yy3 = word.b.b3;	maskindex = 0;	yy0++; yy1++; yy2++; yy3++;#if 0#if WINDOWS	// Modify to convert linear pointer to segment adjusted pointer //GJR 10/29/93	if (FP_OFF(yy) == 0)  // if we just crossed (all accesses segment aligned)		{	// then let compiler see the segment crossing		char huge* hugepc  = (char huge*)((UCharPtr)yy - 1); // prepare to re-cross the segment		hugepc += 1;		//Note: can't we do this ourselves? (since even the compiler hardcodes in <<3)		yy      = (UCharPtr)hugepc;		}#endif#endif	#if DECAL(ROUTINENUMBER)//	byte = *yy;	word.b.b0 = *yy0;	word.b.b1 = *yy1;	word.b.b2 = *yy2;	word.b.b3 = *yy3;	#else	word.w = 0;	#endif	NumOfPixels -= PixelsPerByte;	}if(LastByteDone++ == 0) {	if(NumOfPixels != 0) {//		byte = *yy;		word.b.b0 = *yy0;		word.b.b1 = *yy1;		word.b.b2 = *yy2;		word.b.b3 = *yy3;		endmaskindex = NumOfPixels - 1;		NumOfPixels = PixelsPerByte;	}	else { LastByteDone++; }}}#endif}