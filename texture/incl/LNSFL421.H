void XCAT(LinearScanFill4_2_1bit_,ROUTINENUMBER)	(struct ScanLineInfo *LineInfo)/*						 (int NumOfPixels, 						  #if SHADED(ROUTINENUMBER)						  unsigned char *dith1,						  unsigned char *dith2,						  #endif						  unsigned char *yy,						  FFixed x, FFixed dx, FFixed y, FFixed dy,						  int horizontaltexturemask, int verticaltexturemask,						  unsigned char **fromRaster)*/{int NumOfPixels = LineInfo->NumOfPixels;unsigned char *dith1 = LineInfo->dith1;unsigned char *dith2 = LineInfo->dith2;unsigned char *yy = LineInfo->yy;FFixed x = LineInfo->x;FFixed dx = LineInfo->dx;FFixed y = LineInfo->y;FFixed dy = LineInfo->dy;int horizontaltexturemask = LineInfo->horizontaltexturemask;int horizontalmirrormask = LineInfo->horizontalmirrormask;int verticaltexturemask = LineInfo->verticaltexturemask;int verticalmirrormask = LineInfo->verticalmirrormask;unsigned char **fromRaster = LineInfo->fromRaster;int xint, yint;long horizontalmirrortest;long verticalmirrortest;#if (!ISAPOWEROFTWO(ROUTINENUMBER))int currentverticaltile = 0;int currenthorizontaltile = 0;#endif#if 0	asm{		MOVEM.L   D3-D7/A2-A5,-(A7);		;D0-D2,A0-A1 are temps for ThinkC  //	oldtableposint = tablepos.intg;	//	tableptr = &(texturetable[((tablepos.intg)<<2)+1]);	#if SHADED(ROUTINENUMBER)	MOVE.L	dith1,A1;#endif	MOVE.L	fromRaster,A5;	MOVE.L	yy,A3;	@DoneDith:// Get the clamping values for the fx and fy// If mirroring, the clamp is really twice normal,// and the mirror folds it into regular size.// Powerof2 uses masks for fast clamping.// Non-power of 2 has to do compares.#if ISAPOWEROFTWO(ROUTINENUMBER)	CLR.L	D4		MOVE.W	horizontalmirrormask,D4;	;This is the size (== max count + 1)	CLR.L	D5	MOVE.W	verticalmirrormask,D5;		;Size, valid indices are index less than size.#if HMIRROR(ROUTINENUMBER)	LSL.W	#1,D4;					;Mirror uses 2x mask. Compensate for following sub.#endif#if VMIRROR(ROUTINENUMBER)	LSL.W	#1,D5;					;4x bit minus 1 gives 2x mask#endif	SUB.W	#1,D4;					;H Make into a mask, this turns off top bit	SUB.W	#1,D5;					;V Make into a mask, this turns off top bit#else	// is not a power of 2; Use actual limit values, not masks.	CLR.L	D4		MOVE.W	horizontalmirrormask,D4;	;This is the size (==max count + 1)	CLR.L	D5	MOVE.W	verticalmirrormask,D5;		;Size -- .LT. is valid#if HMIRROR(ROUTINENUMBER)	LSL.W	#1,D4;					;Mirror uses double size for limit#endif#if VMIRROR(ROUTINENUMBER)	LSL.W	#1,D5;					;Mirror uses double size for limit#endif#endif	SWAP	D4;	SWAP	D5;						;get into high words// Now get the testing values for mirroring.#if HMIRROR(ROUTINENUMBER)	CLR.L	D6	MOVE.W	horizontalmirrormask,D6	;Use the actual size, index >= size means mirror	SWAP	D6						;plop into high word for compares	MOVE.L	D6,horizontalmirrortest#endif //HMIRROR(ROUTINENUMBER)#if VMIRROR(ROUTINENUMBER)	CLR.L	D7	MOVE.W	verticalmirrormask,D7	;Get the actual size, .GE. means mirror	SWAP	D7						;Plop into hi word for compares	MOVE.L	D7,verticalmirrortest#endif //VMIRROR(ROUTINENUMBER)// Get current texturemap offsets into registers	MOVE.L	x,D6				;horizontal offset	MOVE.L	y,D7				;vertical offset	//	while(NumOfPixels--) {	//		/*find the fromRaster coordinates.  Mask to guarantee legal//		  values and handle tiling.  Mirror if that is the case.  update the//		  table elements.*/	MOVE.W	NumOfPixels,D1	SUB.W	#1,D1			;Loops for 0..n-1 (DBRA setup)	BMI		@EndPixels;		;Insurance@NextPixel://			delta = (tableptr++)->l;		//get delta, move to oldfxfy//			longfxfy = tableptr->l;			//get long fxfy, but don't move yet//			fx = longfxfy>>16;//			longfxfy += delta;				// update for next time//			tableptr->l = longfxfy;			MOVE.L	D6,D2				;get current horz; update it later			// Clamping, especially for Non^2, to avoid Divs and Mods// Can't trust input values to be in range, so be prepared for out-of-range vals.// I REALLY want to update and use that result, not the prior result.// Or have input clamped.#if ISAPOWEROFTWO(ROUTINENUMBER)			AND.L	D4,D2;				;This masking blitzes the low fraction.#else// Can't mask easily. To avoid mods, clamp and SAVE the clamped values.			CMP.L	D4,D2;				;Keep within modulus size			BLO		@HNowSmall			;Unsigned compare checks negative and too large			BGE		@HMakeSmaller			ADD.L	D4,D2;				;We were negative, so bump us up. Fract is ok.			BPL		@HNowSmall			; If we succeeded in being positive, then skip on			MOVE.W	D2,D4				;Else need to modulus.Weird, save fract in low part of D4			SWAP	D2					;PreDiv by 16 bits. Prevents overflow.			EXT.L	D2								SWAP	D4					; Get divisor ready in WORD			DIVS.W	D4,D2				;Remainder in top half of D2: signed negative			SWAP	D4					;Get size back			CLR.W	D2					;prepare to get back FFixed fraction of the remainder			ADD.L	D4,D2				;Small negative within reach (0..-max). Bump it positive.			SUB.L	#0x10000,D2			;Was 1..size. Make it 0..max.			CLR.W	D4					;Get rid of temp fract that doesn't belong.			BRA		@HNowSmall			;--- @HMakeSmaller:			SUB.L	D4,D2;				;Too Large, so diminish it.			CMP.L	D4,D2				;Check if we got it in range yet			BLT		@HNowSmall			;Skip if one sub got it in range			MOVE.W	D2,D4				;Save the fract for after divide			SWAP	D2					;PreDiv by 16 bits. Prevents overflow.			EXT.L	D2								SWAP	D4					;Else need modulus. Get divider ready into S16			DIVS.W	D4,D2				;d2/d4, remainder in top of D2			SWAP	D4					;get size back			MOVE.W	D4,D2				;Restore FFixed fraction of remainder			CLR.W	D4					;Get rid of temp fract that doesn't belong@HNowSmall:			MOVE.L	D2,D6;#endif			ADD.L	dx,D6;			;add increment here			//Now check for Mirroring on current value.// Mirroring uses a double size. 0..size is normal. size..2*size is mirrored.#if HMIRROR(ROUTINENUMBER)#if ISAPOWEROFTWO(ROUTINENUMBER)			CMP.L	horizontalmirrortest,D2			BLT		@SkipHMirror			EOR.L	D4,D2				;Flip the direction #else			CMP.L	horizontalmirrortest,D2			BLT		@SkipHMirror			NOT.L	D2					;Reverse Subtract - 1, DoubleSize+(-1-Value) flips it			ADD.L	D4,D2#endif	//ISAPOWEROFTWO(ROUTINENUMBER)@SkipHMirror:#endif	//HMIRROR(ROUTINENUMBER)						SWAP	D2					;fx in lower 16 bits, trash in upper 						//			delta = (tableptr++)->l;		//get delta, move to oldfxfy//			longfxfy = tableptr->l;			//get long fxfy, but don't move yet//			fy = longfxfy>>16;//			longfxfy += delta;				// update for next time//			tableptr->l = longfxfy;			MOVE.L	D7,D3				;get current vert; update it later						// Clamping, especially for Non^2, to avoid Divs and Mods#if ISAPOWEROFTWO(ROUTINENUMBER)			AND.L	D5,D3;				;Clamping via masks handle any input fine.#else			CMP.L	D5,D3;				;Keep within modulus size			BLO		@VNowSmall			;Unsigned compare checks negative and too large			BGE		@VMakeSmaller			ADD.L	D5,D3;				;We were negative, so bump us up 			BPL		@VNowSmall			; If we succeeded in being positive, then skip on			MOVE.W	D3,D5				;Weird, save fract in low part of D5			SWAP	D3					;PreDiv by 16 bits. Prevents overflow.			EXT.L	D3								SWAP	D5					;Else need to modulus. Get divisor ready in WORD			DIVS.W	D5,D3				;Remainder in top half of D3: signed negative			SWAP	D5					;Get size back			CLR.W	D3					;prepare to get back FFixed fraction of the remainder			ADD.L	D5,D3				;Small negative within reach (0..-max). Bump it positive.			SUB.L	#0x10000,D3			;Was 1..size. Make it 0..max.			CLR.W	D5					;Get rid of temp fract that doesn't belong.			BRA		@VNowSmall			;--- @VMakeSmaller:			SUB.L	D5,D3;				;Too Large, so diminish it.			CMP.L	D5,D3				;Check if we got it in range yet			BLT		@VNowSmall			;Skip if one sub got it in range			MOVE.W	D3,D5				;Save the fract for after divide			SWAP	D3					;PreDiv by 16 bits. Prevents overflow.			EXT.L	D3								SWAP	D5					;Else need modulus. Get divider ready into S16			DIVS.W	D5,D3				;d3/d5, remainder in top of D3			SWAP	D5					;get size back into upper word			MOVE.W	D5,D3				;Restore FFixed fraction of remainder			CLR.W	D5					;Get rid of temp fract that doesn't belong@VNowSmall:			MOVE.L	D3,D7;#endif			ADD.L	dy,D7;						//Now check for Mirroring on current value.// Mirroring uses a double size. 0..size is normal. size..2*size is mirrored.#if VMIRROR(ROUTINENUMBER)#if ISAPOWEROFTWO(ROUTINENUMBER)			CMP.L	verticalmirrormask,D3			BLT		@SkipVMirror			EOR.L	D5,D3				;Flip the direction #else			CMP.L	verticalmirrormask,D3			BLT		@SkipVMirror			NOT.L	D3					;Reverse Subtract - 1, DoubleSize-1-Value flips it			ADD.L	D5,D3#endif	//ISAPOWEROFTWO(ROUTINENUMBER)@SkipVMirror:#endif	//VMIRROR(ROUTINENUMBER)			SWAP	D3					;f in lower 16 bits, trash in upper 							/*draw the pixel, handling dithering.  if decal is on, also check for a		  white pixel*///		texel = fromRaster[fy][fx];GETASMREGS		LSL.L	#2,D3;					;fy * 4GETASMREGS		MOVE.L	0(A5,D3.W),A0;			;get the raster addressGETASMREGS		CLR.W	D0;						;prepare for word index addressingGETASMREGS		MOVE.B	0(A0,D2.W),D0;			;get the texel byteGETASMREGS		LSL		#2,D0;					;in 24 bit, shading table is longs					#if DECAL(ROUTINENUMBER)//		if(texel != 0) {		BEQ		@SkipPixel;		#endif				#if SHADED(ROUTINENUMBER)//			if((int)yy & 1) {//				*yy = dith2[texel];//			}//			else {//				*yy = dith1[texel];//			}			MOVE.L 0(A1,D0.W),(A3)		#else			MOVE.L D0,(A3)				;FIX THIS!!!!!!!!!!!!!!!		#endifGETASMREGS		#if DECAL(ROUTINENUMBER)//		}@SkipPixel:		#endif						ADD.W 	#4, A3//		}			GETASMREGS		DBRA	D1,@NextPixel;		;loops even at zero, matching indices				@EndPixels:		MOVEM.L   (A7)+,D3-D7/A2-A5	}//end asm#endif#if 1unsigned char byte, subbyte;int maskindex, endmaskindex, PixelsPerByte;unsigned char *mask;int LastByteDone = 0;	if(BitDepthId == BITDEPTHID4) {		PixelsPerByte = 2;		endmaskindex = 1;		mask = mask4bitforward;	}	else if(BitDepthId == BITDEPTHID2) {		PixelsPerByte = 4;		endmaskindex = 3;		mask = mask2bitforward;	}	else if(BitDepthId == BITDEPTHID1) {		PixelsPerByte = 8;		endmaskindex = 7;		mask = mask1bitforward;	}		byte = *yy;	maskindex = InitialMaskIndex;	NumOfPixels += InitialMaskIndex;	while(LastByteDone != 2) {	while(NumOfPixels >= PixelsPerByte) {			for(;			maskindex <= endmaskindex;			maskindex++) {				x.l += dx.l;	y.l += dy.l;	#if ISAPOWEROFTWO(ROUTINENUMBER)		xint = x.intg & horizontaltexturemask;		#if HMIRROR(ROUTINENUMBER)		if(x.intg & horizontalmirrormask) xint = horizontaltexturemask - xint;		#endif			yint = y.intg & verticaltexturemask;		#if VMIRROR(ROUTINENUMBER)		if(y.intg & verticalmirrormask) yint = verticaltexturemask - yint;		#endif	#else		while(x.intg < 0) {			currenthorizontaltile++;			x.intg += horizontalmirrormask;		}		while(x.intg >= horizontalmirrormask) {			currenthorizontaltile++;			x.intg -= horizontalmirrormask;		}		while(y.intg < 0) {			currentverticaltile++;			y.intg += verticalmirrormask;		}		while(y.intg >= verticalmirrormask) {			currentverticaltile++;			y.intg -= verticalmirrormask;		}		xint = x.intg;		#if HMIRROR(ROUTINENUMBER)		if(currenthorizontaltile & 1) xint = horizontaltexturemask - xint;		#endif				yint = y.intg;		#if VMIRROR(ROUTINENUMBER)		if(currentverticaltile & 1) yint = verticaltexturemask - yint;		#endif		#endif		#if DECAL(ROUTINENUMBER)	if(fromRaster[yint][xint] != 0) {	#endif		if(maskindex & 1) {			subbyte = dith2[fromRaster[yint][xint]];		}		else {			subbyte = dith1[fromRaster[yint][xint]];		}		byte = ((byte^subbyte)&(mask[maskindex]))^subbyte;	#if DECAL(ROUTINENUMBER)	}	#endif		}		*yy = byte;	maskindex = 0;	yy++;#if WINDOWS	// Modify to convert linear pointer to segment adjusted pointer //GJR 10/29/93	if (FP_OFF(yy) == 0)  // if we just crossed (all accesses segment aligned)		{	// then let compiler see the segment crossing		char huge* hugepc  = (char huge*)((UCharPtr)yy - 1); // prepare to re-cross the segment		hugepc += 1;		//Note: can't we do this ourselves? (since even the compiler hardcodes in <<3)		yy      = (UCharPtr)hugepc;		}#endif	#if DECAL(ROUTINENUMBER)	byte = *yy;	#else	byte = 0;	#endif	NumOfPixels -= PixelsPerByte;}if(LastByteDone++ == 0) {	if(NumOfPixels != 0) {		byte = *yy;		endmaskindex = NumOfPixels - 1;		NumOfPixels = PixelsPerByte;	}	else { LastByteDone++; }}}#endif}