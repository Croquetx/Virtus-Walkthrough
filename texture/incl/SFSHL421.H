/*this file is the body of the scanfill routines for textures where the  slope of the line of constant depth are greater than 45 degrees.  It is  used in scanfillgenerator.h to generate 16 cases of routines for texture8*/#ifdef GETASMREGS//#undef GETASMREGS		// request this routine for debugging, please  DEBUG 				// Turn off this debugging routine, please#else#define GETASMREGS		// else predefine it as empty. Forces it off.#endif #include "VAsm.h"#if 0d0	---d1	IndexLoopd2	fxd3	fyd4  horizontaltexturewrapd5	verticaltexturewrapd6	texturehorizontaloffset	htexture coordd7	textureverticaloffset	vtexture coorda0	---a1	dither1a2	dither2a3	yya4	texturetablea5	fromRaster#endifvoid XCAT(scanfillshallowslope4_2_1bit_,ROUTINENUMBER)(struct ScanLineInfo *LineInfo) { //int oldtableposint;//FFixed *tableptr;int NumOfPixels = LineInfo->NumOfPixels;FFixed tablepos = LineInfo->tablepos;FFixed dtablepos = LineInfo->dtablepos;unsigned char *dith1 = LineInfo->dith1;unsigned char *dith2 = LineInfo->dith2;unsigned char *yy = LineInfo->yy;int horizontaltexturemask = LineInfo->horizontaltexturemask;int horizontalmirrormask = LineInfo->horizontalmirrormask;int verticaltexturemask = LineInfo->verticaltexturemask;int verticalmirrormask = LineInfo->verticalmirrormask;unsigned char **localfromRaster = LineInfo->fromRaster;long horizontalmirrortest;long verticalmirrortest;	//	int fx, fy;		// just the upper integer portion//	long delta;		//amount to inc fx or fy by.//	long longfxfy;	//old and new full fxfy values//  FFixed *tableptr;//  unsigned char texel;//  long *texptr;	/*first run at 1,4,8 bits is in C*/#if 0	asm{		MOVEM.L   D3-D7/A2-A5,-(A7);		;D0-D2,A0-A1 are temps for ThinkC  //	oldtableposint = tablepos.intg;	//	tableptr = &(texturetable[((tablepos.intg)<<2)+1]);	MOVE.L	texturetable,A4			;get base	MOVE.W	tablepos,D0;	LSL.W	#2*2,D0					;*16=4 items of 4bytes each	LEA		0(A4,D0.W),A4			;add offset to base		MOVE.L	dith1,A1;	MOVE.L	fromRaster,A5;	MOVE.L	yy,A3;@DoneDith:// Get the clamping values for the fx and fy// If mirroring, the clamp is really twice normal,// and the mirror folds it into regular size.// Powerof2 uses masks for fast clamping.// Non-power of 2 has to do compares.#if ISAPOWEROFTWO(ROUTINENUMBER)	CLR.L	D4		MOVE.W	horizontalmirrormask,D4;	;This is the size (== max count + 1)	CLR.L	D5	MOVE.W	verticalmirrormask,D5;		;Size, valid indices are index less than size.#if HMIRROR(ROUTINENUMBER)	LSL.W	#1,D4;					;Mirror uses 2x mask. Compensate for following sub.#endif#if VMIRROR(ROUTINENUMBER)	LSL.W	#1,D5;					;4x bit minus 1 gives 2x mask#endif	SUB.W	#1,D4;					;H Make into a mask, this turns off top bit	SUB.W	#1,D5;					;V Make into a mask, this turns off top bit#else	// is not a power of 2; Use actual limit values, not masks.	CLR.L	D4		MOVE.W	horizontalmirrormask,D4;	;This is the size (==max count + 1)	CLR.L	D5	MOVE.W	verticalmirrormask,D5;		;Size -- .LT. is valid#if HMIRROR(ROUTINENUMBER)	LSL.W	#1,D4;					;Mirror uses double size for limit#endif#if VMIRROR(ROUTINENUMBER)	LSL.W	#1,D5;					;Mirror uses double size for limit#endif#endif	SWAP	D4;	SWAP	D5;						;get into high words// Now get the testing values for mirroring.#if HMIRROR(ROUTINENUMBER)	CLR.L	D6	MOVE.W	horizontalmirrormask,D6	;Use the actual size, index >= size means mirror	SWAP	D6						;plop into high word for compares	MOVE.L	D6,horizontalmirrortest#endif //HMIRROR(ROUTINENUMBER)#if VMIRROR(ROUTINENUMBER)	CLR.L	D7	MOVE.W	verticalmirrormask,D7	;Get the actual size, .GE. means mirror	SWAP	D7						;Plop into hi word for compares	MOVE.L	D7,verticalmirrortest#endif //VMIRROR(ROUTINENUMBER)// Get current texturemap offsets into registers	MOVE.L	1*4(A4),D6				;horizontal offset	MOVE.L	3*4(A4),D7				;vertical offset	//	while(NumOfPixels--) {	//		/*find the fromRaster coordinates.  Mask to guarantee legal//		  values and handle tiling.  Mirror if that is the case.  update the//		  table elements.*/	MOVE.W	NumOfPixels,D1	SUB.W	#1,D1			;Loops for 0..n-1 (DBRA setup)	BMI		@EndPixels;		;Insurance@NextPixel://			delta = (tableptr++)->l;		//get delta, move to oldfxfy//			longfxfy = tableptr->l;			//get long fxfy, but don't move yet//			fx = longfxfy>>16;//			longfxfy += delta;				// update for next time//			tableptr->l = longfxfy;			MOVE.L	D6,D2				;get current horz; update it later			// Clamping, especially for Non^2, to avoid Divs and Mods// Can't trust input values to be in range, so be prepared for out-of-range vals.// I REALLY want to update and use that result, not the prior result.// Or have input clamped.#if ISAPOWEROFTWO(ROUTINENUMBER)			AND.L	D4,D2;				;This masking blitzes the low fraction.#else// Can't mask easily. To avoid mods, clamp and SAVE the clamped values.			CMP.L	D4,D2;				;Keep within modulus size			BLO		@HNowSmall			;Unsigned compare checks negative and too large			BGE		@HMakeSmaller			ADD.L	D4,D2;				;We were negative, so bump us up. Fract is ok.			BPL		@HNowSmall			; If we succeeded in being positive, then skip on			MOVE.W	D2,D4				;Else need to modulus.Weird, save fract in low part of D4			SWAP	D2					;PreDiv by 16 bits. Prevents overflow.			EXT.L	D2								SWAP	D4					; Get divisor ready in WORD			DIVS.W	D4,D2				;Remainder in top half of D2: signed negative			SWAP	D4					;Get size back			CLR.W	D2					;prepare to get back FFixed fraction of the remainder			ADD.L	D4,D2				;Small negative within reach (0..-max). Bump it positive.			SUB.L	#0x10000,D2			;Was 1..size. Make it 0..max.			CLR.W	D4					;Get rid of temp fract that doesn't belong.			BRA		@HNowSmall			;--- @HMakeSmaller:			SUB.L	D4,D2;				;Too Large, so diminish it.			CMP.L	D4,D2				;Check if we got it in range yet			BLT		@HNowSmall			;Skip if one sub got it in range			MOVE.W	D2,D4				;Save the fract for after divide			SWAP	D2					;PreDiv by 16 bits. Prevents overflow.			EXT.L	D2								SWAP	D4					;Else need modulus. Get divider ready into S16			DIVS.W	D4,D2				;d2/d4, remainder in top of D2			SWAP	D4					;get size back			MOVE.W	D4,D2				;Restore FFixed fraction of remainder			CLR.W	D4					;Get rid of temp fract that doesn't belong@HNowSmall:			MOVE.L	D2,D6;#endif			ADD.L	0*4(A4),D6;			;add increment here			//Now check for Mirroring on current value.// Mirroring uses a double size. 0..size is normal. size..2*size is mirrored.#if HMIRROR(ROUTINENUMBER)#if ISAPOWEROFTWO(ROUTINENUMBER)			CMP.L	horizontalmirrortest,D2			BLT		@SkipHMirror			EOR.L	D4,D2				;Flip the direction #else			CMP.L	horizontalmirrortest,D2			BLT		@SkipHMirror			NOT.L	D2					;Reverse Subtract - 1, DoubleSize+(-1-Value) flips it			ADD.L	D4,D2#endif	//ISAPOWEROFTWO(ROUTINENUMBER)@SkipHMirror:#endif	//HMIRROR(ROUTINENUMBER)						SWAP	D2					;fx in lower 16 bits, trash in upper 						//			delta = (tableptr++)->l;		//get delta, move to oldfxfy//			longfxfy = tableptr->l;			//get long fxfy, but don't move yet//			fy = longfxfy>>16;//			longfxfy += delta;				// update for next time//			tableptr->l = longfxfy;			MOVE.L	D7,D3				;get current vert; update it later						// Clamping, especially for Non^2, to avoid Divs and Mods#if ISAPOWEROFTWO(ROUTINENUMBER)			AND.L	D5,D3;				;Clamping via masks handle any input fine.#else			CMP.L	D5,D3;				;Keep within modulus size			BLO		@VNowSmall			;Unsigned compare checks negative and too large			BGE		@VMakeSmaller			ADD.L	D5,D3;				;We were negative, so bump us up 			BPL		@VNowSmall			; If we succeeded in being positive, then skip on			MOVE.W	D3,D5				;Weird, save fract in low part of D5			SWAP	D3					;PreDiv by 16 bits. Prevents overflow.			EXT.L	D3								SWAP	D5					;Else need to modulus. Get divisor ready in WORD			DIVS.W	D5,D3				;Remainder in top half of D3: signed negative			SWAP	D5					;Get size back			CLR.W	D3					;prepare to get back FFixed fraction of the remainder			ADD.L	D5,D3				;Small negative within reach (0..-max). Bump it positive.			SUB.L	#0x10000,D3			;Was 1..size. Make it 0..max.			CLR.W	D5					;Get rid of temp fract that doesn't belong.			BRA		@VNowSmall			;--- @VMakeSmaller:			SUB.L	D5,D3;				;Too Large, so diminish it.			CMP.L	D5,D3				;Check if we got it in range yet			BLT		@VNowSmall			;Skip if one sub got it in range			MOVE.W	D3,D5				;Save the fract for after divide			SWAP	D3					;PreDiv by 16 bits. Prevents overflow.			EXT.L	D3								SWAP	D5					;Else need modulus. Get divider ready into S16			DIVS.W	D5,D3				;d3/d5, remainder in top of D3			SWAP	D5					;get size back into upper word			MOVE.W	D5,D3				;Restore FFixed fraction of remainder			CLR.W	D5					;Get rid of temp fract that doesn't belong@VNowSmall:			MOVE.L	D3,D7;#endif			ADD.L	2*4(A4),D7;						//Now check for Mirroring on current value.// Mirroring uses a double size. 0..size is normal. size..2*size is mirrored.#if VMIRROR(ROUTINENUMBER)#if ISAPOWEROFTWO(ROUTINENUMBER)			CMP.L	verticalmirrormask,D3			BLT		@SkipVMirror			EOR.L	D5,D3				;Flip the direction #else			CMP.L	verticalmirrormask,D3			BLT		@SkipVMirror			NOT.L	D3					;Reverse Subtract - 1, DoubleSize-1-Value flips it			ADD.L	D5,D3#endif	//ISAPOWEROFTWO(ROUTINENUMBER)@SkipVMirror:#endif	//VMIRROR(ROUTINENUMBER)			SWAP	D3					;f in lower 16 bits, trash in upper 							/*draw the pixel, handling dithering.  if decal is on, also check for a		  white pixel*///		texel = fromRaster[fy][fx];GETASMREGS		LSL.L	#2,D3;					;fy * 4GETASMREGS		MOVE.L	0(A5,D3.W),A0;			;get the raster addressGETASMREGS		CLR.W	D0;						;prepare for word index addressingGETASMREGS		MOVE.B	0(A0,D2.W),D0;			;get the texel byteGETASMREGS		LSL		#2,D0					;shading table is longs for 24 bit (not bytes)					#if DECAL(ROUTINENUMBER)//		if(texel != 0) {		BEQ		@SkipPixel;		#endif		//			if((int)yy & 1) {//				*yy = dith2[texel];//			}//			else {//				*yy = dith1[texel];//			}			MOVE.L 0(A1,D0.W),(A3)			GETASMREGS		#if DECAL(ROUTINENUMBER)//		}@SkipPixel:		#endif		/*move to next pixel--next table entry too, if necessary*/;D0			;was ---;	newpos				;updated new tablepos;D2			;was fx;	auxtable[oldpos];	h,v texture increment;D3			;was fy;	dtablepos, for when to change zlines;	auxtable[newpos];	delta_auxtablepos	;difference in table positions, # of columns to jump;	;;A0 ---;	auxarray	//		auxarray[tablepos.intg]++;		MOVE.L	auxarray,A0		MOVE.W	tablepos.intg,D0		LSL.W	#1,D0				;record = 2 bytes		MOVE.W	0(A0,D0.W),D2		ADD.W	#1,D2				;update old "column" number		MOVE.W	D2,0(A0,D0.W)GETASMREGS			//		tablepos.l += dtablepos.l;					//update to new tablepos//		if(tablepos.intg != oldtableposint) {// We want to update the zline we are using.// For shallow slope, only the fraction gets changed usually.// If the fract changing carries into the intg, then we need to change the whole zline.// So either sub tablepos.l and check for change in upper, or sub fracs and detect carry// Fastest code is for no zline change		MOVE.L	dtablepos.l,D3			;Use high for sign test, low for subbing fracts		ADD.W	D3,tablepos.frac		;Just do fraction.REQUIRES <1 slope!!		BCC		@DoneLineChange			;If int not changed, then done@LineChange:		GETASMREGS			MOVE.W	tablepos.intg,D0					;else update integer portion			SWAP	D3									;addx requires vals in registers (gag)			ADDX.W	D3,D0								;This adds with 'carry' from fracts			MOVE.W	D0,tablepos.intg					;D0:=new zline to useGETASMREGS		// Save now old accumulated texel offsets			MOVE.L	D6,1*4(A4)				;Save horizontal offset			MOVE.L	D7,3*4(A4)				;Save vertical offset//			tableptr += tablechange;//			ADD.W	tablechange,A4					;Move to corresponding zline parms			ADD		#16,A4GETASMREGS			// Get new texturemap offsets into registers			MOVE.L	1*4(A4),D6				;horizontal offset			MOVE.L	3*4(A4),D7				;vertical offsetGETASMREGS				//			if(auxarray[tablepos.intg] != auxarray[oldtableposint]) {//				fx = auxarray[oldtableposint] - auxarray[tablepos.intg];			LSL.W	#1,D0							;record = 2 bytes			MOVE.W	0(A0,D0.W),D3					;get column of new lineGETASMREGS			SUB.W	D2,D3							;if it matches current column, great			BEQ		@DoneColumnFind			MOVE.W	D2,0(A0,D0.W)					;else save desired column, and get to it//				if((fx > 3) || (fx < -3)) {	//					tableptr->l +=//						fx *//						(tableptr-1)->l;//					tableptr++;//					tableptr++;//					tableptr->l +=//						fx *//						(tableptr-1)->l;//					tableptr--;//					tableptr--;//				}//				else {//					while(fx > 0) {//						(tableptr)->l += (tableptr-1)->l;//						(tableptr+2)->l += (tableptr+1)->l;//						fx--;//					}//					while(fx < 0) {//						(tableptr)->l -= (tableptr-1)->l;//						(tableptr+2)->l -= (tableptr+1)->l;//						fx++;//					}//				}											;Force the new to match the old column				NEG.W	D3					;OOPS, did old from new (new-old).Change direction.				EXT.L	D3					;MUST get sign for next test. Save upper signGETASMREGS				BMI		@ColNegDir			;if positive direction				CMP.W	#5,D3				;see if close enough				BGT		@ColPosMult1				SUB.W	#1,D3				;0..cnt-1@ColPosRept:				ADD.L	0*4(A4),D6			;add to base value				ADD.L	2*4(A4),D7			;add to base value				DBRA	D3,@ColPosRept								BRA		@DoneCol@ColNegDir:				CMP.W	#-5,D3				BLT		@ColNegMult1				NOT.W	D3					;abs - 1 ==> 0..cnt-1@ColNegRept:				SUB.L	0*4(A4),D6			;add to base value				SUB.L	2*4(A4),D7			;add to base value				DBRA	D3,@ColNegRept								BRA		@DoneCol											;---				// Messy Multiplier; Could just extend and MULS.L S32xS32=>S32 for '020+@ColPosMult1:	// We know the # of columns is positive. How about the increment itself?								MOVE.L	0*4(A4),D2			;Get the S32 incrementGETASMREGS				BPL		@ColResultPos1		;If positive, result is (pos*pos)positive.				NEG.L	D2					;else negative. Abs(), then get negative result@ColResultNeg1:GETASMREGS				MOVE.W	D2,D0				;get lo word increment				MULU.W	D3,D0				;low portion done via unsigned				SUB.L	D0,D6				;Remember, negative result				SWAP	D2					;Get hi word in position				MOVE.W	D2,D0				;get hi word of increment				MULU.W	D3,D0				;				SWAP	D0					;Move up 16 bits				CLR.W	D0					;clear out low part				SUB.L	D0,D6				;Sub hi part in alsoGETASMREGS				BRA		@DoneColMult1		;											;---@ColNegMult1:								;Columns is negative. Check increment.				NEG.W	D3					;Force columns positive. LEAVE SIGN HI ALONE.				MOVE.L	0*4(A4),D2			;Get the S32 incrementGETASMREGS				BPL		@ColResultNeg1		;If positive, result is (neg*pos)negative.				NEG.L	D2					;else (neg*neg)pos. Abs(), then get positive result				@ColResultPos1:GETASMREGS				MOVE.W	D2,D0				;get lo word increment				MULU.W	D3,D0				;low portion done via unsigned				ADD.L	D0,D6				;Remember, Positive result				SWAP	D2					;Get hi word in position				MOVE.W	D2,D0				;get hi word of increment				MULU.W	D3,D0				;				SWAP	D0					;Move up 16 bits				CLR.W	D0					;clear out low part				ADD.L	D0,D6				;Add hi part in alsoGETASMREGS				BRA		@DoneColMult1		;											;---				@DoneColMult1:				TST.L	D3					;Get the saved sign of the column delta				BMI		@ColNegMult2@ColPosMult2:	// We know the # of columns is positive. How about the increment itself?								MOVE.L	2*4(A4),D2			;Get the S32 incrementGETASMREGS				BPL		@ColResultPos2		;If positive, result is (pos*pos)positive.				NEG.L	D2					;else negative. Abs(), then get negative result@ColResultNeg2:GETASMREGS				MOVE.W	D2,D0				;get lo word increment				MULU.W	D3,D0				;low portion done via unsigned				SUB.L	D0,D7				;Remember, negative result				SWAP	D2					;Get hi word in position				MOVE.W	D2,D0				;get hi word of increment				MULU.W	D3,D0				;				SWAP	D0					;Move up 16 bits				CLR.W	D0					;clear out low part				SUB.L	D0,D7				;Sub hi part in alsoGETASMREGS				BRA		@DoneColMult2		;											;---@ColNegMult2:								;Columns is negative. Check increment.// already did this				NEG.W	D3					;Force columns positive. LEAVE SIGN HI ALONE.				MOVE.L	2*4(A4),D2			;Get the S32 increment				BPL		@ColResultNeg2		;If positive, result is (neg*pos)negative.				NEG.L	D2					;else (neg*neg)pos. Abs(), then get positive result				@ColResultPos2:GETASMREGS				MOVE.W	D2,D0				;get lo word increment				MULU.W	D3,D0				;low portion done via unsigned				ADD.L	D0,D7				;Remember, Positive result				SWAP	D2					;Get hi word in position				MOVE.W	D2,D0				;get hi word of increment				MULU.W	D3,D0				;				SWAP	D0					;Move up 16 bits				CLR.W	D0					;clear out low part				ADD.L	D0,D7				;Add hi part in alsoGETASMREGS				BRA		@DoneColMult2		;											;---				@DoneColMult2:				BRA		@DoneCol@DoneCol://				auxarray[tablepos.intg] = auxarray[oldtableposint];//			}//			oldtableposint = tablepos.intg;@DoneColumnFind:@DoneLineChange:					//		yy += screenpointerchange;		ADD.W 	screenpointerchange, A3//		}			GETASMREGS		DBRA	D1,@NextPixel;		;loops even at zero, matching indices				@EndPixels:// Save the latest accumulated texel offsetsGETASMREGS		MOVE.L	D6,1*4(A4)				;Save horizontal offset		MOVE.L	D7,3*4(A4)				;Save vertical offset					MOVEM.L   (A7)+,D3-D7/A2-A5	}//end asm#endif#if 1int fx, fy, oldtableposint;FFixed *tableptr;unsigned char byte, subbyte;int maskindex, endmaskindex, PixelsPerByte;unsigned char *mask;int LastByteDone = 0;FFixed tempfixed;#if HMIRROR(ROUTINENUMBER)int doublehorizontalmirrormask = horizontalmirrormask << 1;#endif#if VMIRROR(ROUTINENUMBER)int doubleverticalmirrormask = verticalmirrormask << 1;#endif	oldtableposint = tablepos.intg;	tableptr = &(texturetable[((tablepos.intg)<<2)+1]);		if(BitDepthId == BITDEPTHID4) {		PixelsPerByte = 2;		endmaskindex = 1;		if(screenpointerchange > 0) {			mask = mask4bitforward;		}		else {			mask = mask4bitbackward;		}	}	else if(BitDepthId == BITDEPTHID2) {		PixelsPerByte = 4;		endmaskindex = 3;		if(screenpointerchange > 0) {			mask = mask2bitforward;		}		else {			mask = mask2bitbackward;		}	}	else if(BitDepthId == BITDEPTHID1) {		PixelsPerByte = 8;		endmaskindex = 7;		if(screenpointerchange > 0) {			mask = mask1bitforward;		}		else {			mask = mask1bitbackward;		}	}		byte = *yy;	maskindex = InitialMaskIndex;	NumOfPixels += InitialMaskIndex;	while(LastByteDone !=2) {	while(NumOfPixels >= PixelsPerByte) {			for(;			maskindex <= endmaskindex;			maskindex++) {					#if ISAPOWEROFTWO(ROUTINENUMBER) 			#if HMIRROR(ROUTINENUMBER)			if(tableptr->intg & horizontalmirrormask)				fx = horizontaltexturemask - (tableptr->intg & horizontaltexturemask);			else				fx = tableptr->intg & horizontaltexturemask;			#else			fx = tableptr->intg & horizontaltexturemask;			#endif			/*apply the delta texture x*/			tableptr->l += (tableptr-1)->l;			tableptr += 2;						#if VMIRROR(ROUTINENUMBER)			if(tableptr->intg & verticalmirrormask)				fy = verticaltexturemask - (tableptr->intg & verticaltexturemask);			else				fy = tableptr->intg & verticaltexturemask;			#else			fy = tableptr->intg & verticaltexturemask;			#endif			tableptr->l += (tableptr-1)->l;			tableptr -= 2;		#else			#if HMIRROR(ROUTINENUMBER)			tempfixed.l = tableptr->l;			while(tempfixed.intg < 0)				tempfixed.intg += doublehorizontalmirrormask;			while(tempfixed.intg >= doublehorizontalmirrormask)				tempfixed.intg -= doublehorizontalmirrormask;			fx = tempfixed.intg;			if(fx >= horizontalmirrormask)				fx = doublehorizontalmirrormask - fx - 1;			tableptr->l = tempfixed.l + (tableptr-1)->l;			#else			tempfixed.l = tableptr->l;			while(tempfixed.intg < 0)				tempfixed.intg += horizontalmirrormask;			while(tempfixed.intg >= horizontalmirrormask)				tempfixed.intg -= horizontalmirrormask;			fx = tempfixed.intg;			tableptr->l = tempfixed.l + (tableptr-1)->l;			#endif			tableptr += 2;						#if VMIRROR(ROUTINENUMBER)			tempfixed.l = tableptr->l;			while(tempfixed.intg < 0)				tempfixed.intg += doubleverticalmirrormask;			while(tempfixed.intg >= doubleverticalmirrormask)				tempfixed.intg -= doubleverticalmirrormask;			fy = tempfixed.intg;			if(fy >= verticalmirrormask)				fy = doubleverticalmirrormask - fy - 1;			tableptr->l = tempfixed.l + (tableptr-1)->l;			#else			tempfixed.l = tableptr->l;			while(tempfixed.intg < 0)				tempfixed.intg += verticalmirrormask;			while(tempfixed.intg >= verticalmirrormask)				tempfixed.intg -= verticalmirrormask;			fy = tempfixed.intg;			tableptr->l = tempfixed.l + (tableptr-1)->l;			#endif			tableptr -= 2;		#endif								/*draw the pixel.  If there's mirroring involved, use the		  next higher adress bit to specify which direction tile		  we are on.  If there is flip, reverse this direction.		  if decal is on, check for white pixel*/		/*draw the pixel, handling dithering.  if decal is on, also check for a		  white pixel*/		#if DECAL(ROUTINENUMBER)		if(localfromRaster[fy][fx] != 0) {		#endif			if(maskindex & 1) {				subbyte = dith2[localfromRaster[fy][fx]];			}			else {				subbyte = dith1[localfromRaster[fy][fx]];			}			byte = ((byte^subbyte)&(mask[maskindex]))^subbyte;		#if DECAL(ROUTINENUMBER)		}		#endif				/*		yy--;		*/				/*move to next pixel--next table entry too, if necessary*/		auxarray[tablepos.intg]++;			tablepos.l += dtablepos.l;		if(tablepos.intg != oldtableposint) {			tableptr += 4;			if(auxarray[tablepos.intg] != auxarray[oldtableposint]) {				fx = auxarray[oldtableposint] - auxarray[tablepos.intg];				if((fx > 3) || (fx < -3)) {						tableptr->l +=						fx *						(tableptr-1)->l;					tableptr++;					tableptr++;					tableptr->l +=						fx *						(tableptr-1)->l;					tableptr--;					tableptr--;				}				else {					while(fx > 0) {						(tableptr)->l += (tableptr-1)->l;						(tableptr+2)->l += (tableptr+1)->l;						fx--;					}					while(fx < 0) {						(tableptr)->l -= (tableptr-1)->l;						(tableptr+2)->l -= (tableptr+1)->l;						fx++;					}				}				auxarray[tablepos.intg] = auxarray[oldtableposint];			}			oldtableposint = tablepos.intg;			}		}	*yy = byte;	maskindex = 0;#if !WINDOWS		yy+=screenpointerchange;#else // IS WINDOWS		if (screenpointerchange > 0)			{	// then check for increasing into new segment			yy+=screenpointerchange;			// Modify to convert linear pointer to segment adjusted pointer //GJR 10/29/93			if (FP_OFF(yy) == 0)  // if we just crossed (all accesses segment aligned)				{	// then let compiler see the segment crossing				char huge* hugepc  = (char huge*)((UCharPtr)yy - 1); // prepare to re-cross the segment				hugepc += 1;		//Note: can't we do this ourselves? (since even the compiler hardcodes in <<3)				yy      = (UCharPtr)hugepc;				}		   }		else			{	// else is negative going, check if coming from 0:0			if (FP_OFF(yy) == 0)  // if we are about to cross				{	// then let compiler see the segment crossing				char huge* hugepc = yy;				hugepc +=screenpointerchange;            // cross using huge pointer				yy      = (UCharPtr)hugepc;				}			else				{ // not crossing downwards, so do normal far pointer update				yy+=screenpointerchange;				}			}#endif //WINDOWS	#if DECAL(ROUTINENUMBER)	byte = *yy;	#else	byte = 0;	#endif	NumOfPixels -= PixelsPerByte;	}if(LastByteDone++ == 0) {	if(NumOfPixels != 0) {		byte = *yy;		endmaskindex = NumOfPixels - 1;		NumOfPixels = PixelsPerByte;	}	else { LastByteDone++; }}}#endif}