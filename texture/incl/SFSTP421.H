/*this file is the body of the scanfill routines for textures where the  slope of the line of constant depth are greater than 45 degrees.  It is  used in scanfillgenerator.h to generate 16 cases of routines for texture8*/#if 0d0	---d1	IndexLoopd2	fxd3	fyd4  horizontaltexturewrapd5	verticaltexturewrapd6	horizontalmirrortestd7	verticalmirrortesta0	---a1	dither1a2	dither2a3	yya4	texturetablea5	fromRaster#endif	void XCAT(scanfillsteepslope4_2_1bit_,ROUTINENUMBER)(struct ScanLineInfo *LineInfo) {int index = LineInfo->index;int index2 = LineInfo->index2;unsigned char *dith1 = LineInfo->dith1;unsigned char *dith2 = LineInfo->dith2;unsigned char *yy = LineInfo->yy;int horizontaltexturemask = LineInfo->horizontaltexturemask;int horizontalmirrormask = LineInfo->horizontalmirrormask;int verticaltexturemask = LineInfo->verticaltexturemask;int verticalmirrormask = LineInfo->verticalmirrormask;unsigned char **localfromRaster = LineInfo->fromRaster;/*C version for now*/#if 0	asm{		MOVEM.L   D3-D7/A2-A5,-(A7);		;D0-D2,A0-A1 are temps for ThinkC  //	int fx, fy;		// just the upper integer portion//	long delta;		//amount to inc fx or fy by.//	long longfxfy;	//old and new full fxfy values//  FFixed *tableptr;//  unsigned char texel;//  long *texptr;	//	tableptr = &(texturetable[(index<<2)]);	MOVE.L	texturetable,A4			;get base	MOVE.W	index,D0;	LSL		#2*2,D0					;*16=4 items of 4bytes each	LEA		0(A4,D0.W),A4			;add offset to base	MOVE.L	dith1,A1				;A1 points to 24 bit shading table	MOVE.L	fromRaster,A5;	MOVE.L	yy,A3;@DoneDith:// Get the clamping values for the fx and fy// If mirroring, the clamp is really twice normal,// and the mirror folds it into regular size.// Powerof2 uses masks for fast clamping.// Non-power of 2 has to do compares.#if ISAPOWEROFTWO(ROUTINENUMBER)	CLR.L	D4		MOVE.W	horizontalmirrormask,D4;	;This is the size (== max count + 1)	CLR.L	D5	MOVE.W	verticalmirrormask,D5;		;Size, valid indices are index less than size.#if HMIRROR(ROUTINENUMBER)	LSL.W	#1,D4;					;Mirror uses 2x mask. Compensate for following sub.#endif#if VMIRROR(ROUTINENUMBER)	LSL.W	#1,D5;					;4x bit minus 1 gives 2x mask#endif	SUB.W	#1,D4;					;H Make into a mask, this turns off top bit	SUB.W	#1,D5;					;V Make into a mask, this turns off top bit#else	// is not a power of 2; Use actual limit values, not masks.	CLR.L	D4		MOVE.W	horizontalmirrormask,D4;	;This is the size (==max count + 1)	CLR.L	D5	MOVE.W	verticalmirrormask,D5;		;Size -- .LT. is valid#if HMIRROR(ROUTINENUMBER)	LSL.W	#1,D4;					;Mirror uses double size for limit#endif#if VMIRROR(ROUTINENUMBER)	LSL.W	#1,D5;					;Mirror uses double size for limit#endif#endif	SWAP	D4;	SWAP	D5;						;get into high words// Now get the testing values for mirroring.#if HMIRROR(ROUTINENUMBER)	CLR.L	D6	MOVE.W	horizontalmirrormask,D6	;Use the actual size, index >= size means mirror	SWAP	D6						;plop into high word for compares#endif //HMIRROR(ROUTINENUMBER)#if VMIRROR(ROUTINENUMBER)	CLR.L	D7	MOVE.W	verticalmirrormask,D7	;Get the actual size, .GE. means mirror	SWAP	D7						;Plop into hi word for compares#endif //VMIRROR(ROUTINENUMBER)	//	for(;index <= index2;index++) {//		/*find the fromRaster coordinates.  Mask to guarantee legal//		  values and handle tiling.  Mirror if that is the case.  update the//		  table elements.*/	MOVE.W	index2,D1	SUB.W  	index,D1	;Still loop even if equal, and zero	BMI		@EndPixels;	;Insurance@NextPixel://			delta = (tableptr++)->l;		//get delta, move to oldfxfy//			longfxfy = tableptr->l;			//get long fxfy, but don't move yet//			fx = longfxfy>>16;//			longfxfy += delta;				// update for next time//			tableptr->l = longfxfy;			MOVE.L	(A4)+,D0;			;get delta			MOVE.L	(A4),D2;			;get long fxfy			// Clamping, especially for Non^2, to avoid Divs and Mods// Can't trust input values to be in range, so be prepared for out-of-range vals.// I REALLY want to update and use that result, not the prior result.// Or have input clamped.#if ISAPOWEROFTWO(ROUTINENUMBER)			ADD.L	D2,D0;				;update, and get rid of it before fraction disappears			AND.L	D4,D2;				;This masking blitzes the low fraction.#else// Can't mask easily. To avoid mods, clamp and SAVE the clamped values.			CMP.L	D4,D2;				;Keep within modulus size			BLO		@HNowSmall			;Unsigned compare checks negative and too large			BGE		@HMakeSmaller			ADD.L	D4,D2;				;We were negative, so bump us up. Fract is ok.			BPL		@HNowSmall			; If we succeeded in being positive, then skip on			MOVE.W	D2,D4				;Else need to modulus.Weird, save fract in low part of D4			SWAP	D2					;PreDiv by 16 bits. Prevents overflow.			EXT.L	D2								SWAP	D4					; Get divisor ready in WORD			DIVS.W	D4,D2				;Remainder in top half of D2: signed negative			SWAP	D4					;Get size back			CLR.W	D2					;prepare to get back FFixed fraction of the remainder			ADD.L	D4,D2				;Small negative within reach. Bump it positive.			CLR.W	D4					;Get rid of temp fract that doesn't belong.			BRA		@HNowSmall			;--- @HMakeSmaller:			SUB.L	D4,D2;				;Too Large, so diminish it.			CMP.L	D4,D2				;Check if we got it in range yet			BLT		@HNowSmall			;Skip if one sub got it in range			MOVE.W	D2,D4				;Save the fract for after divide			SWAP	D2					;PreDiv by 16 bits. Prevents overflow.			EXT.L	D2								SWAP	D4					;Else need modulus. Get divider ready into S16			DIVS.W	D4,D2				;d2/d4, remainder in top of D2			SWAP	D4					;get size back			MOVE.W	D4,D2				;Restore FFixed fraction of remainder			CLR.W	D4					;Get rid of temp fract that doesn't belong@HNowSmall:			ADD.L	D2,D0;#endif			MOVE.L	D0,(A4)+			;Store next update fxfy			//Now check for Mirroring on current value.// Mirroring uses a double size. 0..size is normal. size..2*size is mirrored.#if HMIRROR(ROUTINENUMBER)#if ISAPOWEROFTWO(ROUTINENUMBER)			CMP.L	D6,D2			BLT		@SkipHMirror			EOR.L	D4,D2				;Flip the direction #else			CMP.L	D6,D2			BLT		@SkipHMirror			NOT.L	D2					;Reverse Subtract - 1, DoubleSize+(-1-Value) flips it			ADD.L	D4,D2#endif	//ISAPOWEROFTWO(ROUTINENUMBER)@SkipHMirror:#endif	//HMIRROR(ROUTINENUMBER)						SWAP	D2					;fx in lower 16 bits, trash in upper 						//			delta = (tableptr++)->l;		//get delta, move to oldfxfy//			longfxfy = tableptr->l;			//get long fxfy, but don't move yet//			fy = longfxfy>>16;//			longfxfy += delta;				// update for next time//			tableptr->l = longfxfy;			MOVE.L	(A4)+,D0;			;get delta			MOVE.L	(A4),D3;			;get long fxfy			// Clamping, especially for Non^2, to avoid Divs and Mods#if ISAPOWEROFTWO(ROUTINENUMBER)			ADD.L	D3,D0;				;Add vals before masking destroys the fracts			AND.L	D5,D3;				;Clamping via masks handle any input fine.#else			CMP.L	D5,D3;				;Keep within modulus size			BLO		@VNowSmall			;Unsigned compare checks negative and too large			BGE		@VMakeSmaller			ADD.L	D5,D3;				;We were negative, so bump us up 			BPL		@VNowSmall			; If we succeeded in being positive, then skip on			MOVE.W	D3,D5				;Weird, save fract in low part of D5			SWAP	D3					;PreDiv by 16 bits. Prevents overflow.			EXT.L	D3								SWAP	D5					;Else need to modulus. Get divisor ready in WORD			DIVS.W	D5,D3				;Remainder in top half of D3: signed negative			SWAP	D5					;Get size back			CLR.W	D3					;prepare to get back FFixed fraction of the remainder			ADD.L	D5,D3				;Small negative within reach. Bump it positive.			CLR.W	D5					;Get rid of temp fract that doesn't belong.			BRA		@VNowSmall			;--- @VMakeSmaller:			SUB.L	D5,D3;				;Too Large, so diminish it.			CMP.L	D5,D3				;Check if we got it in range yet			BLT		@VNowSmall			;Skip if one sub got it in range			MOVE.W	D3,D5				;Save the fract for after divide			SWAP	D3					;PreDiv by 16 bits. Prevents overflow.			EXT.L	D3								SWAP	D5					;Else need modulus. Get divider ready into S16			DIVS.W	D5,D3				;d3/d5, remainder in top of D3			SWAP	D5					;get size back into upper word			MOVE.W	D5,D3				;Restore FFixed fraction of remainder			CLR.W	D5					;Get rid of temp fract that doesn't belong@VNowSmall:			ADD.L	D3,D0;#endif			MOVE.L	D0,(A4)+			;Store next update fxfy			//Now check for Mirroring on current value.// Mirroring uses a double size. 0..size is normal. size..2*size is mirrored.#if VMIRROR(ROUTINENUMBER)#if ISAPOWEROFTWO(ROUTINENUMBER)			CMP.L	D7,D3			BLT		@SkipVMirror			EOR.L	D5,D3				;Flip the direction #else			CMP.L	D7,D3			BLT		@SkipVMirror			NOT.L	D3					;Reverse Subtract - 1, DoubleSize-1-Value flips it			ADD.L	D5,D3#endif	//ISAPOWEROFTWO(ROUTINENUMBER)@SkipVMirror:#endif	//VMIRROR(ROUTINENUMBER)			SWAP	D3					;f in lower 16 bits, trash in upper 							/*draw the pixel, handling dithering.  if decal is on, also check for a		  white pixel*///		texel = fromRaster[fy][fx];		LSL.L	#2,D3;					;fy * 4		MOVE.L	0(A5,D3.W),A0;			;get the raster address		CLR.W	D0;						;prepare for word index addressing		MOVE.B	0(A0,D2.W),D0;			;get the texel byte				LSL		#2,D0;					;24 bits => longs in shading table					#if DECAL(ROUTINENUMBER)//		if(texel != 0) {		BEQ		@SkipPixel;		#endif		//			if((int)yy & 1) {//				*yy = dith2[texel];//			}//			else {//				*yy = dith1[texel];//			}			MOVE.L 0(A1,D0.W),(A3)		#if DECAL(ROUTINENUMBER)//		}@SkipPixel:		#endif//		yy++;		ADD #4,A3				DBRA	D1,@NextPixel;		;loops even at zero, matching indices@EndPixels:		MOVEM.L   (A7)+,D3-D7/A2-A5	}//end asm#endif#if 1int fx, fy;FFixed *tableptr;unsigned char byte, subbyte;int maskindex, endmaskindex, PixelsPerByte;unsigned char *mask;int NumOfPixels = index2 - index + 1;int LastByteDone = 0;FFixed tempfixed;#if HMIRROR(ROUTINENUMBER)int doublehorizontalmirrormask = horizontalmirrormask << 1;#endif#if VMIRROR(ROUTINENUMBER)int doubleverticalmirrormask = verticalmirrormask << 1;#endif	tableptr = &(texturetable[(index<<2) + 1]);		if(BitDepthId == BITDEPTHID4) {		PixelsPerByte = 2;		endmaskindex = 1;		mask = mask4bitforward;	}	else if(BitDepthId == BITDEPTHID2) {		PixelsPerByte = 4;		endmaskindex = 3;		mask = mask2bitforward;	}	else if(BitDepthId == BITDEPTHID1) {		PixelsPerByte = 8;		endmaskindex = 7;		mask = mask1bitforward;	}		byte = *yy;	maskindex = InitialMaskIndex;	NumOfPixels += InitialMaskIndex;while(LastByteDone != 2) {	while(NumOfPixels >= PixelsPerByte) {			for(;			maskindex <= endmaskindex;			maskindex++) {					#if ISAPOWEROFTWO(ROUTINENUMBER) 			#if HMIRROR(ROUTINENUMBER)			if(tableptr->intg & horizontalmirrormask)				fx = horizontaltexturemask - (tableptr->intg & horizontaltexturemask);			else				fx = tableptr->intg & horizontaltexturemask;			#else			fx = tableptr->intg & horizontaltexturemask;			#endif			/*apply the delta texture x*/			tableptr->l += (tableptr-1)->l;			tableptr += 2;						#if VMIRROR(ROUTINENUMBER)			if(tableptr->intg & verticalmirrormask)				fy = verticaltexturemask - (tableptr->intg & verticaltexturemask);			else				fy = tableptr->intg & verticaltexturemask;			#else			fy = tableptr->intg & verticaltexturemask;			#endif			tableptr->l += (tableptr-1)->l;			tableptr += 2;		#else			#if HMIRROR(ROUTINENUMBER)			tempfixed.l = tableptr->l;			while(tempfixed.intg < 0)				tempfixed.intg += doublehorizontalmirrormask;			while(tempfixed.intg >= doublehorizontalmirrormask)				tempfixed.intg -= doublehorizontalmirrormask;			fx = tempfixed.intg;			if(fx >= horizontalmirrormask)				fx = doublehorizontalmirrormask - fx - 1;			tableptr->l = tempfixed.l + (tableptr-1)->l;			#else			tempfixed.l = tableptr->l;			while(tempfixed.intg < 0)				tempfixed.intg += horizontalmirrormask;			while(tempfixed.intg >= horizontalmirrormask)				tempfixed.intg -= horizontalmirrormask;			fx = tempfixed.intg;			tableptr->l = tempfixed.l + (tableptr-1)->l;			#endif			tableptr += 2;						#if VMIRROR(ROUTINENUMBER)			tempfixed.l = tableptr->l;			while(tempfixed.intg < 0)				tempfixed.intg += doubleverticalmirrormask;			while(tempfixed.intg >= doubleverticalmirrormask)				tempfixed.intg -= doubleverticalmirrormask;			fy = tempfixed.intg;			if(fy >= verticalmirrormask)				fy = doubleverticalmirrormask - fy - 1;			tableptr->l = tempfixed.l + (tableptr-1)->l;			#else			tempfixed.l = tableptr->l;			while(tempfixed.intg < 0)				tempfixed.intg += verticalmirrormask;			while(tempfixed.intg >= verticalmirrormask)				tempfixed.intg -= verticalmirrormask;			fy = tempfixed.intg;			tableptr->l = tempfixed.l + (tableptr-1)->l;			#endif			tableptr += 2;		#endif								/*draw the pixel.  If there's mirroring involved, use the		  next higher adress bit to specify which direction tile		  we are on.  If there is flip, reverse this direction.		  if decal is on, check for white pixel*/		/*draw the pixel, handling dithering.  if decal is on, also check for a		  white pixel*/		#if DECAL(ROUTINENUMBER)		if(localfromRaster[fy][fx] != 0) {		#endif			if(maskindex & 1) {				subbyte = dith2[localfromRaster[fy][fx]];			}			else {				subbyte = dith1[localfromRaster[fy][fx]];			}			byte = ((byte^subbyte)&(mask[maskindex]))^subbyte;		#if DECAL(ROUTINENUMBER)		}		#endif				/*		yy--;		*/				/*move to next pixel--next table entry too, if necessary*/	}	*yy = byte;	maskindex = 0;	yy++;#if WINDOWS	// Modify to convert linear pointer to segment adjusted pointer //GJR 10/29/93	if (FP_OFF(yy) == 0)  // if we just crossed (all accesses segment aligned)		{	// then let compiler see the segment crossing		char huge* hugepc  = (char huge*)((UCharPtr)yy - 1); // prepare to re-cross the segment		hugepc += 1;		//Note: can't we do this ourselves? (since even the compiler hardcodes in <<3)		yy      = (UCharPtr)hugepc;		}#endif	#if DECAL(ROUTINENUMBER)	byte = *yy;	#else	byte = 0;	#endif	NumOfPixels -= PixelsPerByte;	}if(LastByteDone++ == 0) {	if(NumOfPixels != 0) {		byte = *yy;		endmaskindex = NumOfPixels - 1;		NumOfPixels = PixelsPerByte;	}	else { LastByteDone++; }}}#endif}