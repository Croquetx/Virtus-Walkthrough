/*this file is the body of the scanfill routines for textures where the  slope of the line of constant depth are greater than 45 degrees.  It is  used in scanfillgenerator.h to generate 16 cases of routines for texture8*/#ifdef GETASMREGS//#undef GETASMREGS		// request this routine for debugging, please  DEBUG 				// Turn off this debugging routine, please#else#define GETASMREGS		// else predefine it as empty. Forces it off.#endif #include "VAsm.h"#if 0d0	---d1	IndexLoopd2	fxd3	fyd4  horizontaltexturewrapd5	verticaltexturewrapd6	texturehorizontaloffset	htexture coordd7	textureverticaloffset	vtexture coorda0	---a1	dither1a2	dither2a3	yya4	texturetablea5	fromRaster#endifvoid XCAT(scanfillshallowslope4x1pln_,ROUTINENUMBER)(struct ScanLineInfo *LineInfo) { //int oldtableposint;//FFixed *tableptr;int NumOfPixels = LineInfo->NumOfPixels;FFixed tablepos = LineInfo->tablepos;FFixed dtablepos = LineInfo->dtablepos;unsigned long *colorlookup = (unsigned long *)LineInfo->longptr;unsigned char *yy0 = LineInfo->yy0;unsigned char *yy1 = yy0 + LineInfo->offset4x1;unsigned char *yy2 = yy1 + LineInfo->offset4x1;unsigned char *yy3 = yy2 + LineInfo->offset4x1;int horizontaltexturemask = LineInfo->horizontaltexturemask;int horizontalmirrormask = LineInfo->horizontalmirrormask;int verticaltexturemask = LineInfo->verticaltexturemask;int verticalmirrormask = LineInfo->verticalmirrormask;unsigned char **localfromRaster = LineInfo->fromRaster;long horizontalmirrortest;long verticalmirrortest;	//	int fx, fy;		// just the upper integer portion//	long delta;		//amount to inc fx or fy by.//	long longfxfy;	//old and new full fxfy values//  FFixed *tableptr;//  unsigned char texel;//  long *texptr;	/*first run at 1,4,8 bits is in C*/#if 1int fx, fy, oldtableposint;FFixed *tableptr;unsigned char byte, subbyte;byteword word;unsigned long subword;int maskindex, endmaskindex, PixelsPerByte;unsigned long *mask;int LastByteDone = 0;FFixed tempfixed;#if HMIRROR(ROUTINENUMBER)int doublehorizontalmirrormask = horizontalmirrormask << 1;#endif#if VMIRROR(ROUTINENUMBER)int doubleverticalmirrormask = verticalmirrormask << 1;#endif	oldtableposint = tablepos.intg;	tableptr = &(texturetable[((tablepos.intg)<<2)+1]);	/*	if(BitDepthId == BITDEPTHID4) {		PixelsPerByte = 2;		endmaskindex = 1;		if(screenpointerchange > 0) {			mask = mask4bitforward;		}		else {			mask = mask4bitbackward;		}	}	else if(BitDepthId == BITDEPTHID2) {		PixelsPerByte = 4;		endmaskindex = 3;		if(screenpointerchange > 0) {			mask = mask2bitforward;		}		else {			mask = mask2bitbackward;		}	}	else if(BitDepthId == BITDEPTHID1) {		PixelsPerByte = 8;		endmaskindex = 7;		if(screenpointerchange > 0) {			mask = mask1bitforward;		}		else {			mask = mask1bitbackward;		}	}*/		PixelsPerByte = 8;	endmaskindex = 7;	if(screenpointerchange > 0) {		mask = mask4x1bitforward;	}	else {		mask = mask4x1bitbackward;	}//	byte = *yy;	//construct word from current set of planes	word.b.b0 = *yy0;	word.b.b1 = *yy1;	word.b.b2 = *yy2;	word.b.b3 = *yy3;	maskindex = InitialMaskIndex;	NumOfPixels += InitialMaskIndex;while(LastByteDone !=2) {	while(NumOfPixels >= PixelsPerByte) {			for(;			maskindex <= endmaskindex;			maskindex++) {					#if ISAPOWEROFTWO(ROUTINENUMBER) 			#if HMIRROR(ROUTINENUMBER)			if(tableptr->intg & horizontalmirrormask)				fx = horizontaltexturemask - (tableptr->intg & horizontaltexturemask);			else				fx = tableptr->intg & horizontaltexturemask;			#else			fx = tableptr->intg & horizontaltexturemask;			#endif			/*apply the delta texture x*/			tableptr->l += (tableptr-1)->l;			tableptr += 2;						#if VMIRROR(ROUTINENUMBER)			if(tableptr->intg & verticalmirrormask)				fy = verticaltexturemask - (tableptr->intg & verticaltexturemask);			else				fy = tableptr->intg & verticaltexturemask;			#else			fy = tableptr->intg & verticaltexturemask;			#endif			tableptr->l += (tableptr-1)->l;			tableptr -= 2;		#else			#if HMIRROR(ROUTINENUMBER)			tempfixed.l = tableptr->l;			while(tempfixed.intg < 0)				tempfixed.intg += doublehorizontalmirrormask;			while(tempfixed.intg >= doublehorizontalmirrormask)				tempfixed.intg -= doublehorizontalmirrormask;			fx = tempfixed.intg;			if(fx >= horizontalmirrormask)				fx = doublehorizontalmirrormask - fx - 1;			tableptr->l = tempfixed.l + (tableptr-1)->l;			#else			tempfixed.l = tableptr->l;			while(tempfixed.intg < 0)				tempfixed.intg += horizontalmirrormask;			while(tempfixed.intg >= horizontalmirrormask)				tempfixed.intg -= horizontalmirrormask;			fx = tempfixed.intg;			tableptr->l = tempfixed.l + (tableptr-1)->l;			#endif			tableptr += 2;						#if VMIRROR(ROUTINENUMBER)			tempfixed.l = tableptr->l;			while(tempfixed.intg < 0)				tempfixed.intg += doubleverticalmirrormask;			while(tempfixed.intg >= doubleverticalmirrormask)				tempfixed.intg -= doubleverticalmirrormask;			fy = tempfixed.intg;			if(fy >= verticalmirrormask)				fy = doubleverticalmirrormask - fy - 1;			tableptr->l = tempfixed.l + (tableptr-1)->l;			#else			tempfixed.l = tableptr->l;			while(tempfixed.intg < 0)				tempfixed.intg += verticalmirrormask;			while(tempfixed.intg >= verticalmirrormask)				tempfixed.intg -= verticalmirrormask;			fy = tempfixed.intg;			tableptr->l = tempfixed.l + (tableptr-1)->l;			#endif			tableptr -= 2;		#endif								/*draw the pixel.  If there's mirroring involved, use the		  next higher adress bit to specify which direction tile		  we are on.  If there is flip, reverse this direction.		  if decal is on, check for white pixel*/		/*draw the pixel, handling dithering.  if decal is on, also check for a		  white pixel*/		#if DECAL(ROUTINENUMBER)		if(localfromRaster[fy][fx] != 0) {		#endif		/*			if(maskindex & 1) {				subbyte = dith2[localfromRaster[fy][fx]];			}			else {				subbyte = dith1[localfromRaster[fy][fx]];			}		*/			subword = colorlookup[localfromRaster[fy][fx]];		//	byte = ((byte^subbyte)&(mask[maskindex]))^subbyte;        	word.w = ((word.w^subword)&(mask[maskindex]))^subword;		#if DECAL(ROUTINENUMBER)		}		#endif				/*		yy--;		*/				/*move to next pixel--next table entry too, if necessary*/		auxarray[tablepos.intg]++;			tablepos.l += dtablepos.l;		if(tablepos.intg != oldtableposint) {			tableptr += 4;			if(auxarray[tablepos.intg] != auxarray[oldtableposint]) {				fx = auxarray[oldtableposint] - auxarray[tablepos.intg];				if((fx > 3) || (fx < -3)) {						tableptr->l +=						fx *						(tableptr-1)->l;					tableptr++;					tableptr++;					tableptr->l +=						fx *						(tableptr-1)->l;					tableptr--;					tableptr--;				}				else {					while(fx > 0) {						(tableptr)->l += (tableptr-1)->l;						(tableptr+2)->l += (tableptr+1)->l;						fx--;					}					while(fx < 0) {						(tableptr)->l -= (tableptr-1)->l;						(tableptr+2)->l -= (tableptr+1)->l;						fx++;					}				}				auxarray[tablepos.intg] = auxarray[oldtableposint];			}			oldtableposint = tablepos.intg;			}		}	*yy0 = word.b.b0;	*yy1 = word.b.b1;	*yy2 = word.b.b2;	*yy3 = word.b.b3;	maskindex = 0;	yy0 += screenpointerchange;	yy1 += screenpointerchange;	yy2 += screenpointerchange;    yy3 += screenpointerchange;#if 0#if !WINDOWS		yy+=screenpointerchange;#else // IS WINDOWS		if (screenpointerchange > 0)			{	// then check for increasing into new segment			yy+=screenpointerchange;			// Modify to convert linear pointer to segment adjusted pointer //GJR 10/29/93			if (FP_OFF(yy) == 0)  // if we just crossed (all accesses segment aligned)				{	// then let compiler see the segment crossing				char huge* hugepc  = (char huge*)((UCharPtr)yy - 1); // prepare to re-cross the segment				hugepc += 1;		//Note: can't we do this ourselves? (since even the compiler hardcodes in <<3)				yy      = (UCharPtr)hugepc;				}		   }		else			{	// else is negative going, check if coming from 0:0			if (FP_OFF(yy) == 0)  // if we are about to cross				{	// then let compiler see the segment crossing				char huge* hugepc = yy;				hugepc +=screenpointerchange;            // cross using huge pointer				yy      = (UCharPtr)hugepc;				}			else				{ // not crossing downwards, so do normal far pointer update				yy+=screenpointerchange;				}			}#endif //WINDOWS#endif	#if DECAL(ROUTINENUMBER)//	byte = *yy;	word.b.b0 = *yy0;	word.b.b1 = *yy1;	word.b.b2 = *yy2;	word.b.b3 = *yy3;	#else	word.w = 0;	#endif	NumOfPixels -= PixelsPerByte;	}if(LastByteDone++ == 0) {	if(NumOfPixels != 0) {//		byte = *yy;		word.b.b0 = *yy0;		word.b.b1 = *yy1;		word.b.b2 = *yy2;		word.b.b3 = *yy3;		endmaskindex = NumOfPixels - 1;		NumOfPixels = PixelsPerByte;	}	else { LastByteDone++; }}}#endif}