#include "VTypes.h"#include "WTypes.h"#include "Clip.h"#include "Flash.h"#include "VTimer.h"#include "VDisplay.h"#include "VGUtil.h"#include "VMath.h"#include "VDebug.h"#include "TextSrvr.h"	// ABD TEXTURE#include "sfgen.h"#include "VDisplay.h"#if WINDOWS#include "DOS.h"		// DOS segment handlers		GJR 10/29/93						// Note: huge can't store across seg boundaries with single op#define SPANNEDHUGE(farptr, hifarptr) ((unsigned) FP_OFF(farptr) > (unsigned) FP_OFF(hifarptr))#endif //WINDOWS/*draws textures with linear interpolation for cases where error is sufficiently small*/intShadedLinearTexture8(struct  TextureRendSettings *textureinfo, V_Offscreen *to,					 V_Array *fpoints,V_Array *tpoints,					 Clip *clipper){int plength,index_left=0,index_right;int mode = textureinfo->decal;Point *pt;PointFFixed *pf;int xOffsetTail;// Join mac and windows		DELETE COMMENTS 		//GJR 10/01/93//#if MACINTOSH//int xOffset=-to->GetXOffset();//int yOffset=-to->GetYOffset();//long toRowBytes=to->GetRowWidth();//#elif WINDOWS//#if !ELVIS//#error hi Greg!//#error int xOffset=-to->GetXOffset();//#error int yOffset=-to->GetYOffset();//#error long toRowBytes=to->GetRowWidth();//#endifint xOffset=-to->GetXOffset();    // these are all zero!  jca 23 sept 93int yOffset=-to->GetYOffset();long toRowBytes=to->GetRowWidth();//#endif // MACINTOSH// Join mac and windows		DELETE COMMENTS 		//GJR 10/01/93#if WINDOWSunsigned char *yBase; //windows original start of output line#endifunsigned char *y;	// pointer to start of output line, with xoffsetunsigned char *yy;  // pointer to start of span, with x coord figured in.unsigned char **fromRaster;unsigned char *dith1, *dith2;int fodxl, fodyl, fodxr, fodyr;int dyl, odyl, odxl, dyr, odyr, odxr, deltay, reset;int dx;int cxl;int cxr;int i,j;Rect rclip, texturerect;int cleft,cright;int ytop;struct ClipStruct *clip;int cliptop,clipbottom,clipindex;int notDone=TRUE;int rval=FALSE;FFixed xl, dxl, xr, dxr, yl, yr, fxl, fdxl, fxr, fdxr, fyl, fdyl, fyr, fdyr;FFixed tempfixed;int horizontaltexturemask, verticaltexturemask, horizontalmirrormask, verticalmirrormask;ShadeEntry *tshade;int fliph, flipv;int IsAPowerOfTwo;int currenthorizontaltile = 0;int currentverticaltile = 0;struct ScanLineInfo LineInfo;void (*ShadedLinearScanFillRoutine)(struct ScanLineInfo *);int BitDepthIndex;VGrafPort savePort;	// ABD MERGE23VGrafDevice saveDevice;	// ABD MERGE23/*if(clipper->rgnClip)return rval;*/to->GetClip(&rclip);textureinfo->mip[0]->GetRect(&texturerect);fromRaster = textureinfo->mip[0]->UseRaster(&savePort, &saveDevice);	// ABD MERGE23LineInfo.fromRaster = fromRaster;pt=(Point *)tpoints->Use();pf=(PointFFixed *)fpoints->Use();plength=tpoints->ALength();if(plength<=2)goto endit;horizontaltexturemask = (texturerect.right) - 1;verticaltexturemask = (texturerect.bottom) - 1;horizontalmirrormask = (texturerect.right);verticalmirrormask = (texturerect.bottom);LineInfo.horizontaltexturemask = horizontaltexturemask;LineInfo.verticaltexturemask = verticaltexturemask;LineInfo.horizontalmirrormask = horizontalmirrormask;LineInfo.verticalmirrormask = verticalmirrormask;/*select correct bit depth based on to raster*/switch (to->bitDepth)	{#if MACINTOSHcase	1:		BitDepthId = BITDEPTHID1;		BitDepthIndex = BITDEPTHINDEX1;		break;case	2:		BitDepthId = BITDEPTHID2;		BitDepthIndex = BITDEPTHINDEX2;		break;#endifcase	4:		BitDepthId = BITDEPTHID4;		BitDepthIndex = BITDEPTHINDEX4;#if WINDOWS		if(to->wBmPlanes == 4)			{			BitDepthId = BITDEPTHID4X1;			BitDepthIndex = BITDEPTHINDEX4X1;			}#endif //WINDOWS		break;case	8:		BitDepthId = BITDEPTHID8;		BitDepthIndex = BITDEPTHINDEX8;		break;case	16:		BitDepthId = BITDEPTHID16;		BitDepthIndex = BITDEPTHINDEX16;		break;#if WINDOWScase	24:		BitDepthId = BITDEPTHID24;		BitDepthIndex = BITDEPTHINDEX24;		break;#endif //WINDOWScase	32:		BitDepthId = BITDEPTHID32;		BitDepthIndex = BITDEPTHINDEX32;		break;default: DEBUGGER();return (rval);	}tshade = textureinfo->textureShade;cleft=cright=pt[0].h;for(i=1;i<plength;i++)	{	if(pt[index_left].v>pt[i].v)index_left=i;	if(pt[i].h<cleft)cleft=pt[i].h;	if(pt[i].h>cright)cright=pt[i].h;	}if(cleft>rclip.right)goto endit;if(cright<rclip.left)goto endit;if(clipper)	{	if(clipper->type)		{		cliptop=clipper->ytop;		clipbottom=cliptop+clipper->ALength()-1;			if(rclip.top<cliptop)			{			rclip.top=cliptop;			clipindex=0;			}		else clipindex=rclip.top-cliptop;		if(rclip.bottom>clipbottom)rclip.bottom=clipbottom;		clip=(ClipStruct *)clipper->Use();		if(cleft>clipper->right)goto endit;		if(cright<clipper->left)goto endit;		}	else clipper=0;	}	if(textureinfo->hFlip) {	fliph = 1;}else {	fliph = 0;}if(textureinfo->vFlip) {	flipv = 1;}else {	flipv = 0;}if(((horizontalmirrormask & (horizontalmirrormask - 1)) == 0) &&  ((verticalmirrormask & (verticalmirrormask - 1)) == 0))  {  	IsAPowerOfTwo = 1;  }else {	IsAPowerOfTwo = 0;}if(textureinfo->vMirror) i = 1;else i = 0;if(textureinfo->hMirror) i |= 2;if(textureinfo->decal)  i |= 4;if(IsAPowerOfTwo) i |= 8;ShadedLinearScanFillRoutine = ShadedLinearScanFill[i][BitDepthIndex];/*switch(i) {	case 0: ShadedLinearScanFillRoutine = LinearScanFill_16; break;	case 1: ShadedLinearScanFillRoutine = LinearScanFill_17; break;	case 2: ShadedLinearScanFillRoutine = LinearScanFill_18; break;	case 3: ShadedLinearScanFillRoutine = LinearScanFill_19; break;	case 4: ShadedLinearScanFillRoutine = LinearScanFill_20; break;	case 5: ShadedLinearScanFillRoutine = LinearScanFill_21; break;	case 6: ShadedLinearScanFillRoutine = LinearScanFill_22; break;	case 7: ShadedLinearScanFillRoutine = LinearScanFill_23; break;	case 8: ShadedLinearScanFillRoutine = LinearScanFill_24; break;	case 9: ShadedLinearScanFillRoutine = LinearScanFill_25; break;	case 10: ShadedLinearScanFillRoutine = LinearScanFill_26; break;	case 11: ShadedLinearScanFillRoutine = LinearScanFill_27; break;	case 12: ShadedLinearScanFillRoutine = LinearScanFill_28; break;	case 13: ShadedLinearScanFillRoutine = LinearScanFill_29; break;	case 14: ShadedLinearScanFillRoutine = LinearScanFill_30; break;	case 15: ShadedLinearScanFillRoutine = LinearScanFill_31; break;#if DEBUG	default: DEBUGGER();#endif}*/index_right=index_left;j=0;while(pt[index_left].v==pt[i=previousNum(index_left,plength)].v && ++j<plength)index_left=i;if(j==plength)goto endit;j=0;while(pt[index_right].v==pt[i=nextNum(index_right,plength)].v && ++j<plength)index_right=i;if(j==plength)goto endit;/*the TO points */xl.intg=pt[index_left].h;yl.intg=pt[index_left].v;xr.intg=pt[index_right].h;yr.intg=pt[index_right].v;xl.frac = yl.frac = xr.frac = yr.frac = 0;/*the FROM points *//*fxl.intg=pf[index_left].h;fyl.intg=pf[index_left].v;fxr.intg=pf[index_right].h;fyr.intg=pf[index_right].v;xl.frac = yl.frac = xr.frac = yr.frac = fxl.frac = fxr.frac = fyl.frac = fyr.frac = 0;*/fxl = pf[index_left].h;fyl = pf[index_left].v;fxr = pf[index_right].h;fyr = pf[index_right].v;index_left=previousNum(index_left,plength);index_right=nextNum(index_right,plength);ytop=yl.intg;rval=TRUE;if(ytop>=rclip.bottom)goto endit;clipindex+=(ytop-rclip.top);if(clipper)if(clipindex>clipper->ALength())goto endit;switch(BitDepthId) {	case BITDEPTHID4X1:	case BITDEPTHID1:		xOffsetTail = xOffset & 7;		xOffset >>= 3;		break;	case BITDEPTHID2:		xOffsetTail = xOffset & 3;		xOffset >>= 2;		break;	case BITDEPTHID4:		xOffsetTail = xOffset & 1;		xOffset >>= 1;		break;	case BITDEPTHID8:		xOffsetTail = 0;		break;	case BITDEPTHID16:		xOffsetTail = 0;		xOffset <<= 1;		break;	case BITDEPTHID24:		xOffsetTail = 0;		xOffset += xOffset+xOffset;		break;	case BITDEPTHID32:		xOffsetTail = 0;		xOffset <<= 2;		break;}#if MACINTOSH                    	//GJR 10/13/93y=(unsigned char *)to->GetBaseAddr() + ((yOffset+ytop)*toRowBytes) + xOffset;#elif WINDOWS// Modify to convert linear lpl to segment adjusted lpl //GJR 10/29/93if(ytop >= rclip.top){	yBase = to->lpbBmRowAddresses[yOffset+ytop];	y     = yBase + xOffset;}#endifdyl = pt[index_left].v - yl.intg;dyr = pt[index_right].v - yr.intg;tempfixed.intg = pt[index_left].v - yl.intg;tempfixed.frac = 0;dxl.intg = pt[index_left].h - xl.intg;dxl.frac = 0;dxl = FFDiv(dxl, tempfixed);/*fdxl.intg = pf[index_left].h - fxl.intg;fdxl.frac = 0;*/fdxl.l = pf[index_left].h.l - fxl.l;fdxl = FFDiv(fdxl, tempfixed);/*fdyl.intg = pf[index_left].v - fyl.intg;fdyl.frac = 0;*/fdyl.l = pf[index_left].v.l - fyl.l;fdyl = FFDiv(fdyl, tempfixed);tempfixed.intg = pt[index_right].v - yr.intg;tempfixed.frac = 0;dxr.intg = pt[index_right].h - xr.intg;dxr.frac = 0;dxr = FFDiv(dxr, tempfixed);/*fdxr.intg = pf[index_right].h - fxr.intg;fdxr.frac = 0;*/fdxr.l = pf[index_right].h.l - fxr.l;fdxr = FFDiv(fdxr, tempfixed);/*fdyr.intg = pf[index_right].v - fyr.intg;fdyr.frac = 0;*/fdyr.l = pf[index_right].v.l - fyr.l;fdyr = FFDiv(fdyr, tempfixed);xr.l += FixedPointFive.l + (dxr.l >> 1);xl.l += FixedPointFive.l + (dxl.l >> 1);fxl.l += FixedPointFive.l + (fdxl.l >> 1);fxr.l += FixedPointFive.l + (fdxr.l >> 1);fyl.l += FixedPointFive.l + (fdyl.l >> 1);fyr.l += FixedPointFive.l + (fdyr.l >> 1);do	{	/*handle rounding*/		if(index_left==index_right)notDone=FALSE;	if(dyl < dyr)		{		deltay=dyl;		reset=1;		dyr-=dyl;		dyl =0;		}	else if(dyr < dyl)		{		deltay=dyr;		reset=2;		dyl-=dyr;		dyr=0;		}	else		{		deltay=dyr;		reset=3;		dyl=dyr=0;		}	while(deltay--)		{		clipindex++;		if(ytop>=rclip.top)			{			FFixed fx, dfx, fy, dfy;			int remainder;			int fxint, fyint;			cxl=xl.intg>rclip.left?xl.intg:rclip.left;			cxr=xr.intg<rclip.right?xr.intg:rclip.right;			if(clipper)				{				cxr=cxr<clip[clipindex].right?cxr:clip[clipindex].right;				cxl=cxl>clip[clipindex].left?cxl:clip[clipindex].left;				}			remainder = xOffsetTail + cxl;			switch(BitDepthId) {				case BITDEPTHID1:					yy = y + (remainder >> 3);					InitialMaskIndex = remainder & 7;					break;				case BITDEPTHID2:					yy = y + (remainder >> 2);					InitialMaskIndex = remainder & 3;					break;				case BITDEPTHID4:					yy = y + (remainder >> 1);					InitialMaskIndex = remainder & 1;					break;				case BITDEPTHID8: 					yy = y + remainder;					break;				case BITDEPTHID16:					yy = y + (remainder << 1);					break;				case BITDEPTHID24:					yy = y + (remainder+remainder+remainder);					break;				case BITDEPTHID32:					yy = y + (remainder << 2);					break;#if WINDOWS				case BITDEPTHID4X1://					LineInfo.yy0 = y + (tempfixed.intg >> 3);					LineInfo.offset4x1 = gwBmWidthBytes;					LineInfo.yy0 = to->lpbBmRowAddresses[ytop+to->yOffset];                    LineInfo.yy0 += (remainder + to->xOffset)>>3;					InitialMaskIndex = remainder & 7;					yy = y;					break;#endif //WINDOWS			}#if WINDOWS// Modify to convert linear yy to segment adjusted yy //GJR 10/29/93if (SPANNEDHUGE(yBase, yy))  // Segment Adjust	//GJR 10/29/93	{ char huge* hugepc  = yBase;				 hugepc += FP_OFF(yy) - FP_OFF(yBase);				 yy      = (UCharPtr)hugepc;    }#endif			cxr-=cxl;	/*this is the length of the drawn pixels */			//if((xr.intg < rclip.right) && (xr.frac != 0)) cxr++;			cxl-=xl.intg;	/*this is the left hand size of the clip (<=0 if no clip)*/			fx=fxl;			fy=fyl;						/*if(cxl<0)DEBUGGER(); this should be impossible */			/*Draw the scan-line*/			/*			if(xr.frac < xl.frac) {				cxr--;			}			*/			if(cxr>0)		// Only do draws and divides if pixels on line GJR082893				{				/*0 fraction implies center of pixel, center of texel*/								#if 0				//tempfixed.l = xr.l - xl.l;				dfx.l = fxr.l - fxl.l;				dfx.l /= xr.intg - xl.intg;		//??SLOW??				//dfx = FFDiv(dfx,tempfixed);				dfy.l = fyr.l - fyl.l;				dfy.l /= xr.intg - xl.intg;				//dfy = FFDiv(dfy,tempfixed);				#endif				tempfixed.frac = 0;				tempfixed.intg = xr.intg - xl.intg;				dfx.l = fxr.l - fxl.l;				dfx = FFDiv(dfx, tempfixed);				dfy.l = fyr.l - fyl.l;				dfy = FFDiv(dfy, tempfixed);								/* for textures, we need to calculate all of the left hand pixels,				 * including those that are not drawn, because we need to calculate				 * the next pixel location based upon the last pixel location.				 */				/*--------------first do the left-most then middle clipped areas*/					/*						while(cxl--)							{							fx.l += dfx.l;							fy.l += dfy.l;							}					*/					if(cxl > 0) {						fx.l += dfx.l * cxl;						fy.l += dfy.l * cxl;						cxl = 0;					}					if(fliph) {						tempfixed.frac = 0;						tempfixed.intg = horizontaltexturemask;						fx.l = tempfixed.l - fx.l;						dfx.l = -dfx.l;					}					if(flipv) {						tempfixed.frac = 0;						tempfixed.intg = verticaltexturemask;						fy.l = tempfixed.l - fy.l;						dfy.l = -dfy.l;					}					if(BitDepthId <= BITDEPTHID8) {						if(ytop & 1) {							LineInfo.dith1 = tshade->dith[BitDepthId][2];							LineInfo.dith2 = tshade->dith[BitDepthId][3];						}						else {							LineInfo.dith1 = tshade->dith[BitDepthId][0];							LineInfo.dith2 = tshade->dith[BitDepthId][1];						}					}					if(BitDepthId == BITDEPTHID16) {						LineInfo.dith1 = (unsigned char *)(tshade->color16bit);					}					if(BitDepthId == BITDEPTHID24) {						LineInfo.dith1 = (unsigned char *)(tshade->color24bit);					}					if(BitDepthId == BITDEPTHID32) {						LineInfo.dith1 = (unsigned char *)(tshade->truecolor);					}					if(BitDepthId == BITDEPTHID4X1) {						if(ytop & 1)							LineInfo.dith1 = (unsigned char *)((unsigned long *) (tshade->color4x1[0]));                     				else							LineInfo.dith1 =(unsigned char *)((unsigned long *) (tshade->color4x1[1]));					}					LineInfo.NumOfPixels = cxr;					LineInfo.yy = yy;					LineInfo.x = fx;					LineInfo.dx = dfx;					LineInfo.y = fy;					LineInfo.dy = dfy;					(*ShadedLinearScanFillRoutine)(& LineInfo);				}			}//		y+=toRowBytes;		ytop++;		if(ytop>=rclip.bottom)goto endit;  	// limit before usage      	//GJR 10/29/93#if MACINTOSH                    	//GJR 10/13/93		y+=toRowBytes;#elif WINDOWS// Prepare to convert linear yy to segment adjusted yy //GJR 10/20/93		if(ytop >= rclip.top)			{			yBase = to->lpbBmRowAddresses[yOffset+ytop];			y     = yBase + xOffset;        	}#endif//		if(ytop>=rclip.bottom)goto endit;            //REMOVE //GJR 10/29/93			fxl.l += fdxl.l;			fxr.l += fdxr.l;			fyl.l += fdyl.l;			fyr.l += fdyr.l;			xl.l += dxl.l;			xr.l += dxr.l;		}	if(reset&1)		{		yl.intg=pt[index_left].v;		xl.intg=pt[index_left].h;		xl.frac = 0;		fxl = pf[index_left].h;		fyl = pf[index_left].v;		/*		fyl.intg=pf[index_left].v;		fyl.frac = 0;		fxl.intg=pf[index_left].h;		fxl.frac = 0;		*/		do	{			index_left=previousNum(index_left,plength);			dyl = pt[index_left].v - yl.intg;			tempfixed.intg = pt[index_left].v - yl.intg;			tempfixed.frac = 0;			dxl.intg = pt[index_left].h - xl.intg;			dxl.frac = 0;			dxl = FFDiv(dxl, tempfixed);						/*			fdxl.intg = pf[index_left].h - fxl.intg;			fdxl.frac = 0;			*/			fdxl.l = pf[index_left].h.l - fxl.l;			fdxl = FFDiv(fdxl, tempfixed);			/*			fdyl.intg = pf[index_left].v - fyl.intg;			fdyl.frac = 0;			*/			fdyl.l = pf[index_left].v.l - fyl.l;			fdyl = FFDiv(fdyl, tempfixed);			}while(yl.intg>pt[index_left].v && notDone && index_left!=index_right);			xl.l += FixedPointFive.l + (dxl.l >> 1);			fxl.l += FixedPointFive.l + (fdxl.l >> 1);			fyl.l += FixedPointFive.l + (fdyl.l >> 1);		}	if((reset&2) && index_left != index_right)		{		yr.intg=pt[index_right].v;		yr.frac = 0;		xr.intg=pt[index_right].h;		xr.frac = 0;		fxr = pf[index_right].h;		fyr = pf[index_right].v;		/*		fyr.intg=pf[index_right].v;		fyr.frac = 0;		fxr.intg=pf[index_right].h;		fxr.frac = 0;		*/		do	{			index_right=nextNum(index_right,plength);			dyr = pt[index_right].v - yr.intg;			tempfixed.intg = pt[index_right].v - yr.intg;			tempfixed.frac = 0;			dxr.intg = pt[index_right].h - xr.intg;			dxr.frac = 0;			dxr = FFDiv(dxr, tempfixed);			/*			fdxr.intg = pf[index_right].h - fxr.intg;			fdxr.frac = 0;			*/			fdxr.l = pf[index_right].h.l - fxr.l;			fdxr = FFDiv(fdxr, tempfixed);			/*			fdyr.intg = pf[index_right].v - fyr.intg;			fdyr.frac = 0;			*/			fdyr.l = pf[index_right].v.l - fyr.l;			fdyr = FFDiv(fdyr, tempfixed);			}while(yr.intg>pt[index_right].v && notDone && index_left!=index_right);				xr.l += FixedPointFive.l + (dxr.l >> 1);			fxr.l += FixedPointFive.l + (fdxr.l >> 1);			fyr.l += FixedPointFive.l + (fdyr.l >> 1);		}	}while(notDone);endit:tpoints->Unuse();fpoints->Unuse();if(clipper)clipper->Unuse();textureinfo->mip[0]->UnuseRaster(&savePort, &saveDevice);return rval;}