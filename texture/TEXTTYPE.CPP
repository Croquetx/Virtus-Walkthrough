#include "VTypes.h"#include "WTypes.h"#include "ShowTest.h"#include "VMemUtil.h"#include "VDisplay.h"#include "VGraphic.h"#include "VMDL.h"#include "VError.h"#include "VDebug.h"#include <stdio.h>#include <string.h>#include "VFile.h"			//move down, add vfile		//GJR 10/06/93#include "VRIcon.h"#include "TextType.h"#include "AppText.h"#if 0#include "VButton.h"       // defines offColor[] for use below jca 2 Oct 93#endif/*------------------------------------------------------------------------------*//*	This routine */void TextureType::cTextureType(){	int i;	padded = TRUE;	ObjLock(this);	for ( i = 0 ; i < MAX_NUM_MIPS ; i++ )	{		mip[i] = NULL;		SetRect(&unpadded_rect[i], 0,0,0,0);	}	ObjUnlock(this);}/*------------------------------------------------------------------------------*//*	This routine */void TextureType::dTextureType(){		UnloadPicture();	//jam 6OCT94 // jca 12AUG94 VR1.0.1 delete any leftover textures/pixel8s	delete this;}/*------------------------------------------------------------------------------*//*	MERGE-HMD [[[	What we want is for each different type of device SetupFrame be called only	once per frame.  That is, call SetupFrame once per rendered frame for VDIGs, 	once per rendered frame for QuickTime movies, etc.  We increment gQTCurrentFrame	and gVDIGCurrentFrame each time through the rendering routine.  We test it	against gQTOldFrame and gVDIGOldFrame in this routine (or its subclass	routines) and if they are different, we store it and go ahead and render.  If	they are the same we just exit.	MERGE-HMD ]]]*/int TextureType::SetupFrame(){		return (noErr);}/*------------------------------------------------------------------------------*//*	This routine */int TextureType::LoadPicture(){		return (noErr);}/*------------------------------------------------------------------------------*//*	This routine */void TextureType::UnloadPicture(){	}/*------------------------------------------------------------------------------*//*	This routine */void TextureType::Lock(){	int i;	for ( i = 0 ; i < MAX_NUM_MIPS ; i++ )		if (mip[i] != NULL)			mip[i]->Lock();}/*------------------------------------------------------------------------------*//*	This routine */void TextureType::Unlock(){	int i;	for ( i = 0 ; i < MAX_NUM_MIPS ; i++ )		if (mip[i] != NULL)			mip[i]->Unlock();}// MERGE-CLEANUP [[[/*------------------------------------------------------------------------------*//*	This routine */void TextureType::UnlockCompletely(){	int i;	for ( i = 0 ; i < MAX_NUM_MIPS ; i++ )		if (mip[i] != NULL)		{		int num_locks = mip[i]->lock;		int j;					for ( j = 0 ; j < num_locks ; j++ )				mip[i]->Unlock();		}			}// MERGE-CLEANUP ]]]/*------------------------------------------------------------------------------*//*	This routine */int TextureType::MakeMIP(){	int err = noErr;int i;V_Offscreen *picture;double scale_factor;double new_height, new_width, margin;RGBColor c;int width, height, top, bottom, left, right;//extern unsigned int offColor[];         // jca 2 Oct 93   <-- removeV_Offscreen *temp_mip;VCGrafPort tp;VGrafDevice gd;extern int lowMemory;V_Offscreen *temp_off;		// MERGE-PIXEL8		ObjLock(this);	// note that we NULL out 1..(MAX_NUM_MIPS-1) and leave mip 0 (the main picture) alone	for ( i = 1 ; i < MAX_NUM_MIPS ; i++ )	{		mip[i] = NULL;		SetRect(&unpadded_rect[i], 0,0,0,0);	}	// get the main picture	picture = GetPicture(0);		// make sure there is a picture	if ((!err) && (picture))	{	Rect r_from, r_to;		GetPaddedRect(&r_from, 0);			// get real (padded) rect		GetUnpaddedRect(&unpadded_rect[0], 0);			// get real (padded) rect				int num = MAX_NUM_MIPS;		for ( i = 1 ; i < num ; i++ )		{			r_to = r_from;			unpadded_rect[i] = unpadded_rect[0];						// compute a resized rect 			r_to.right = ((r_from.right + r_from.left) >> i);			r_to.bottom = ((r_from.bottom + r_from.top) >> i);			unpadded_rect[i].right = ((unpadded_rect[0].right + unpadded_rect[0].left) >> i);			unpadded_rect[i].bottom = ((unpadded_rect[0].bottom + unpadded_rect[0].top) >> i);						// if the to rect is less than 4 pixels in both directions, then break			if (((r_to.right - r_to.left) < 4) && ((r_to.bottom - r_to.top) < 4))				break;						// if the to rect is zero in any direction, then break			if (((r_to.right - r_to.left) == 0) || ((r_to.bottom - r_to.top) == 0))				break;			// jca 22MAR94 reordered the code and added cCreateCopy to handle making			// the pixel8  [[			/*			   note that we use the ditherCopy mode to transfer the picture 			   from the full-sized picture into the smaller thumbnail offscreen			   image.  This will doubtlessly make the thumbnail look better than			   simply doing a MetaTo because of automatic Macintosh error diffusion. 			*/						temp_off = new(V_Offscreen);			err = temp_off->cOffscreen(&r_to, 8, &vWhite, NULL);			if(err) return memFullErr;				//catch  mem problems	//GJR 10/19/83			// MERGE-PIXEL8 create a copy in a temp offscreen			picture->MetaToMode(temp_off, &r_from, &r_to, vSrcDither);				// MERGE-PIXEL8					   			// MERGE-PIXEL8 copy the temp off to Pixel8			// otherwise create a new offscreen for this mip			mip[i] = new(V_Pixel8);			if (mip[i])            	{				err = mip[i]->cCreateCopy(temp_off);			// MERGE-PIXEL8				if (lowMemory && err)					{  // we failed to get the pixel8, clean up and return an error                    delete(mip[i]);					mip[i] = NULL;					}				else if (lowMemory && !err)					{  // we got the pixel8, but it left us short on memory; bye!                    mip[i]->dPixel8();					mip[i] = NULL;					err = memFullErr;					}				}			else				err = memFullErr;			// jca 22MAR94 end reordering ]]			// MERGE-PIXEL8 delete our temp offscreen			temp_off->dOffscreen();  // MERGE-PIXEL8			//ShowOffscreen(mip[i]);		// ¥¥ TO DEBUG		}		   // MERGE-PIXEL8 -- we don't need the average color, so don't compute it #if 0		// now do one more mip map to compute the average color of the whole shebang		temp_mip = new(V_Offscreen); 		if (temp_mip == NULL) return memFullErr;				SetRect(&r_to, 0, 0, 1, 1);		err = temp_mip->cOffscreen(&r_to, 8, &vWhite, NULL);		if(err) return memFullErr;				//catch  mem problems	//GJR 10/19/83						if (lowMemory) 		{ 			temp_mip->dOffscreen();			temp_mip = NULL; 			return memFullErr;		}		// copy from the picture only if there is a picture		picture->MetaToMode(temp_mip, &r_from, &r_to, vSrcDither);			//		VGetPort(&tp, &gd);//		temp_mip->SetMetaPort();         mip_color = temp_mip->GetPixelColor(0,0);         //GJR 12/11/93// REMOVE #if MACINTOSH//		GetCPixel(0, 0, &mip_color);//#elif WINDOWS//#if !ELVIS // single pixel mip, getCPixel					//GJR 10/01/93//#error This needs your attention, Greg...//#endif//#endif    // MACINTOSH//		temp_mip->UnsetMetaPort();//		VSetPort(tp, gd);				temp_mip->dOffscreen();#endif	}	ObjUnlock(this);	return(err);}#if (!VPLAYER)/*------------------------------------------------------------------------------*//*	This routine */int TextureType::MakeThumbnail(V_Offscreen *thumbnail, Rect *r_to){	int err;V_Offscreen *picture;double scale_factor;double new_height, new_width, margin;RGBColor c;Rect unpad_rect;int width, height, top, bottom, left, right;//extern unsigned int offColor[];         // jca 2 Oct 93   <-- remove	err = LoadPicture();					// loads the PICT into memory	picture = GetPicture(0);		if ((!err) && (picture))	{	Rect r_from;		GetPaddedRect(&unpad_rect, 0);		GetPaddedRect(&r_from, 0);		*r_to = thumbnail->rect;#if 0		thumbnail->SetMetaPort(NULL);		c = offColor[BaseColor]; 		// jca 2 Oct 93		VForeColor(&c);		PaintRect(r_to);		VForeColor(&vBlack);		thumbnail->UnsetMetaPort(NULL);#endif		width = r_from.right - r_from.left;		height = r_from.bottom - r_from.top;		if (width > height)		{			scale_factor = (double)(32.0 / width);			new_height = height * scale_factor;			margin = 32 - new_height;			top = (margin / 2);			bottom = 32 - (margin / 2);			SetRect(r_to, 0, top, 32, bottom);		}		else // height > width		{			scale_factor = (double)(32.0 / height);			new_width = width * scale_factor;			margin = 32 - new_width;			left = (margin / 2);			right = 32 - (margin / 2);			SetRect(r_to, left, 0, right, 32);		}					// set up size instance variable		ObjLock(this);#if JAPANESE		sprintf(info_str, "%s%d x %s%d", TXTD_HRZSIZE, unpad_rect.right-unpad_rect.left, TXTD_VRTSIZE, unpad_rect.bottom-unpad_rect.top);#else		sprintf(info_str, "%d%s x %d%s", unpad_rect.right-unpad_rect.left, TXTD_HRZSIZE, unpad_rect.bottom-unpad_rect.top, TXTD_VRTSIZE);#endif		ObjUnlock(this);				/* 		   note that we use the ditherCopy mode to transfer the picture 		   from the full-sized picture into the smaller thumbnail offscreen		   image.  This will doubtlessly make the thumbnail look better than		   simply doing a MetaTo because of automatic Macintosh error diffusion. 		*/		   		// copy from the picture only if there is a picture		picture->MetaToMode(thumbnail, &r_from, r_to, vSrcDither);			// we can unload the picture here, because if we are making a thumbnail,		// then no object has actually used the texture yet and so there is no		// danger of unloading a picture that needs to be kept around.				// ¥¥¥ÊNOTE there are cases in which we would not want to unload the picture		// here, for example the texture dialog set source/apply buttons		// We just re-load the picture in those cases for now, but ideally this 		// texturetype should not unload the picture if texture items are using this		// texturetype.				UnloadPicture();	}	return(err);}/*------------------------------------------------------------------------------*//*	This routine */int TextureType::SetThumbnail(V_Offscreen *picture, V_Offscreen *thumbnail, Rect *r_to){	int err = noErr;double scale_factor;double new_height, new_width, margin;RGBColor c;int width, height, top, bottom, left, right;// extern unsigned int offColor[];		<-- remove jca 2 Oct 93Rect r_from;VCGrafPort savePort;		// MERGE-BUGVGrafDevice saveDevice;		// MERGE-BUG	VGetPort(&savePort,&saveDevice);		// MERGE-BUG	if (!picture) return -1;	if (!thumbnail) return -1;	picture->GetRect(&r_from);	*r_to = thumbnail->rect;#if 0	thumbnail->SetMetaPort(NULL);	c = offColor[BaseColor]; 		// jca 2 Oct 93	VForeColor(&c);	PaintRect(r_to);	VForeColor(&vBlack);	thumbnail->UnsetMetaPort(NULL);#endif	width = r_from.right - r_from.left;	height = r_from.bottom - r_from.top;	if (width > height)	{		scale_factor = (double)(32.0 / width);		new_height = height * scale_factor;		margin = 32 - new_height;		top = (margin / 2);		bottom = 32 - (margin / 2);		SetRect(r_to, 0, top, 32, bottom);	}	else // height > width	{		scale_factor = (double)(32.0 / height);		new_width = width * scale_factor;		margin = 32 - new_width;		left = (margin / 2);		right = 32 - (margin / 2);		SetRect(r_to, left, 0, right, 32);	}		// set up size instance variable	ObjLock(this);#if JAPANESE	sprintf(info_str, "%s%d x %s%d", TXTD_HRZSIZE, r_from.right-r_from.left, TXTD_VRTSIZE, r_from.bottom-r_from.top);#else	sprintf(info_str, "%d%s x %d%s", r_from.right-r_from.left, TXTD_HRZSIZE, r_from.bottom-r_from.top, TXTD_VRTSIZE);#endif	ObjUnlock(this);		/*	   note that we use the ditherCopy mode to transfer the picture 	   from the full-sized picture into the smaller thumbnail offscreen	   image.  This will doubtlessly make the thumbnail look better than	   simply doing a MetaTo because of automatic Macintosh error diffusion. 	*/	   	// copy from the picture only if there is a picture	picture->SetMetaPort();	thumbnail->SetMetaPort();	picture->MetaToMode(thumbnail, &r_from, r_to, vSrcDither);	thumbnail->UnsetMetaPort();	picture->UnsetMetaPort();	VSetPort(savePort,saveDevice);		// MERGE-BUG	return(err);}#endif // (!VPLAYER)/*------------------------------------------------------------------------------*//*	This routine */V_Offscreen *TextureType::GetPicture(int index){		return(mip[index]);}/*------------------------------------------------------------------------------*//*	This routine */void TextureType::GetUnpaddedRect(Rect *r, int index){		*r = unpadded_rect[index];}/*------------------------------------------------------------------------------*//*	This routine */RGBColor TextureType::GetFilteredRGB(){		return mip_color;}/*------------------------------------------------------------------------------*//*	This routine */void TextureType::GetPaddedRect(Rect *r, int index){		if (GetPicture(index))	{ 		GetPicture(index)->GetRect(r);		// return the actual offscreen rect (padded)	}	else		SetRect(r,0,0,0,0);}/*------------------------------------------------------------------------------*//*	This routine */void TextureType::GetTypeStr(char *str){	int i;	for(i=0;i<32;i++) str[i] = type_str[i];}/*------------------------------------------------------------------------------*//*	This routine */void TextureType::GetInfoStr(char *str){	int i;	for(i=0;i<64;i++) str[i] = info_str[i];}/*------------------------------------------------------------------------------*//*	This routine */void TextureType::GetFullPathStr(char *str){	int i;	strcpy(str, "blah");  	// what does this do?  jca 24 Sept 93}/*------------------------------------------------------------------------------*//*	This routine */int TextureType::IORef(V_Buffer *buf){		return (noErr);}/*------------------------------------------------------------------------------*//*	This routine MERGE15*/int TextureType::IOOff(V_Buffer *buf){	int err = noErr;V_Offscreen *off;	off = GetPicture(0);		if (off == NULL) DEBUGGER();		// ¥¥¥¥										buf->OpenChunkW(IFF_TXPD);		// texture picture data		err = off->IO_BMAP(buf, NULL, NoCompression);	buf->CloseChunk();			return (err);}// MERGE-BUG ABD 17MAR94/*------------------------------------------------------------------------------*//*	This routine */int TextureType::SetOffscreen(V_Offscreen *off){		DEBUGGER();	return 0;}