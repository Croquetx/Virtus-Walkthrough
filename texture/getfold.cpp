/*	StandardGetFolder example files.h	Steve Falkenburg -- MacDTS*/#include "VTypes.h"#include "QuickTim.h"#include "GETFOLD.h"#include "AppFiles.h"#include "VGUtil.h"#include "AppText.h"/* typedefs */typedef struct {	StandardFileReply *replyPtr;	FSSpec oldSelection, folder_selection;	int select_folder;} SFData, *SFDataPtr;// incase we don't have universal headers#ifndef NewFileFilterYDProc	#define NewFileFilterYDProc(x)		((FileFilterYDProcPtr)x)#endif //not def NewFileFilterYDProc#ifndef NewDlgHookYDProc	#define NewDlgHookYDProc(x)			((DlgHookYDProcPtr)x)#endif //not def NewDlgHookYDProc#ifndef NewModalFilterYDProc	#define NewModalFilterYDProc(x)		((ModalFilterYDProcPtr)x)#endif //not def NewModalFilterYDProc/* prototypes */pascal short MyDlgHook(short item,DialogPtr theDlg,void *userData);pascal Boolean MyModalFilter(DialogPtr theDlg,EventRecord *ev,short *itemHit,void *myData);void HitButton(DialogPtr theDlg,short item);pascal Boolean FilterFiles(ParmBlkPtr PB, void *yourDataPtr);void SetSelectButtonName(SFDataPtr sfUserData, StringPtr selName,DialogPtr theDlg);Boolean SameFile(FSSpec *file1,FSSpec *file2);Boolean GetFSSpecPartialName(FSSpec *file,StringPtr fName);OSErr GetDeskFolderSpec(FSSpec *fSpec,short vRefNum);OSErr MakeCanonFSSpec(SFDataPtr sfUserData, FSSpec *fSpec);Boolean ShouldHiliteSelect(FSSpec *fSpec);/* constants */#define kOpenItem#define	kSelectItem			11#define	kSFDlg				131#define	kSelectItemPreview			16#define	kSFDlgPreview				129#define	kCanSelectDesktop	true#define kDefaultSelectString	TXTI_ADD			// PRO-JAP#define	kDefaultDeskString		TXTI_DESKTOP		// PRO-JAP#define	kSelectKey			'a'		// Add Textures/*-------------------------------------------------------------------------------*//* globals */int gSFDlgID, gSelectItemNo;FSSpec gDeskFolderSpec;Str255 gSelectString = kDefaultSelectString;Str255 gDesktopFName = kDefaultDeskString;SFData gSFUserData;extern int gQuickTime;int AddTexturesDialog7(FSSpec *fSpec);	// system 7 versionint AddTexturesDialog6(FSSpec *fSpec);	// system 6 version/*-------------------------------------------------------------------------------*/int AddTexturesDialog(FSSpec *fSpec){int result;extern int gFSSpecCalls;	if (gFSSpecCalls && gQuickTime)		result = AddTexturesDialog7(fSpec);	else		result = AddTexturesDialog6(fSpec);	return result;}/*-------------------------------------------------------------------------------*//*-------------------------------------------------------------------------------*//* 	do getfile -- fSpec if filled in if the user doesn't cancel		fSpec is filled in with the information about the selected folder, so parID	is *NOT* the directory ID of the folder itself, but rather the parent ID of	the folder.  If this value is used as a directory ID, files on the same level	as the folder will be found, instead of files *in* the folder, which is what	is usually required.  */int AddTexturesDialog7(FSSpec *fSpec){	Point where = {-2,-2};	SFReply reply;	DialogPtr theDialog;	short item;	StandardFileReply sfReply;	OSErr err;	Boolean targetIsFolder,wasAliased;		/* initialize user data area */		gSFUserData.replyPtr = &sfReply;	gSFUserData.oldSelection.vRefNum = -9999;	/* init to ridiculous value */		if (gQuickTime)	{		gSFDlgID = kSFDlgPreview;		gSelectItemNo = kSelectItemPreview;	}	else	{		gSFDlgID = kSFDlg;		gSelectItemNo = kSelectItem;	}	// if QuickTime is installed we get the nifty automatic preview dialog box	if (gQuickTime)		CustomGetFilePreview(NewFileFilterYDProc(FilterFiles),-1,NULL,&sfReply,					gSFDlgID,where,NewDlgHookYDProc(MyDlgHook),					NewModalFilterYDProc(MyModalFilter),NULL,NULL,&gSFUserData);	else		CustomGetFile(NewFileFilterYDProc(FilterFiles),-1,NULL,&sfReply,gSFDlgID,where,					NewDlgHookYDProc(MyDlgHook),NewModalFilterYDProc(MyModalFilter),					NULL,NULL,&gSFUserData);						// if we are selecting a folder, then retrieve the data from userdata	// because we might have had a file selected when we hit the select folder 	// button	if (gSFUserData.select_folder) 	{		BlockMove(&gSFUserData.folder_selection,&sfReply.sfFile,sizeof(FSSpec));	}		if (sfReply.sfGood) 	{		err = ResolveAliasFile(&sfReply.sfFile,true,&targetIsFolder,&wasAliased);		if (err!=noErr)			return false;	}		err = FSMakeFSSpec(sfReply.sfFile.vRefNum,sfReply.sfFile.parID,sfReply.sfFile.name,fSpec);	if (err!=noErr)		return false;			if (sfReply.sfGood)	{		if (!gSFUserData.select_folder) 		{			return(ADD_TEXTURES_FILE);		}		else 		{			return(ADD_TEXTURES_FOLDER);		}	}	else return ADD_TEXTURES_CANCEL;}/*-------------------------------------------------------------------------------*//*	This routine */pascal short MyDlgHook(short item,DialogPtr theDlg,void *userData){	SFDataPtr sfUserData;	Boolean hiliteButton;	FSSpec curSpec;	OSType refCon;		refCon = GetWRefCon(theDlg);	if (refCon!=sfMainDialogRefCon)		// only do stuff for main dialog box		return item;			sfUserData = (SFDataPtr) userData;		if (item==sfHookFirstCall || item==sfHookLastCall)		return item;			if (!SameFile(&sfUserData->replyPtr->sfFile,&sfUserData->oldSelection)) 	{		// save the sfFile info in curSpec		BlockMove(&sfUserData->replyPtr->sfFile, &curSpec, sizeof(FSSpec));				// fill in curSpec with good stuff		MakeCanonFSSpec(sfUserData, &curSpec);				// 		BlockMove(&curSpec,&sfUserData->folder_selection,sizeof(FSSpec));					// set the button to it's new name		SetSelectButtonName(sfUserData, curSpec.name,theDlg);				// save the current selection in old selection so the button won't blink		// every time through the loop		BlockMove(&sfUserData->replyPtr->sfFile,&sfUserData->oldSelection,sizeof(FSSpec));	}		if (item == getOpen)		sfUserData->select_folder = FALSE;		if (item == gSelectItemNo)	{		item = sfItemOpenButton;		sfUserData->select_folder = TRUE;	}			return item;}/*-------------------------------------------------------------------------------*//*	This routine filters the events and returns in CMD-A (for "Add Textures")	was pressed.*/pascal Boolean MyModalFilter(DialogPtr theDlg,EventRecord *ev,short *itemHit,void *myData){	Boolean evHandled;	char keyPressed;	OSType refCon;		refCon = GetWRefCon(theDlg);	if (refCon!=sfMainDialogRefCon)		return false;			evHandled = false;		switch (ev->what) 	{		case keyDown:		case autoKey:			keyPressed = ev->message & charCodeMask;			if ((ev->modifiers & cmdKey) != 0) 			{				switch (keyPressed) 				{					case kSelectKey:						HitButton(theDlg,gSelectItemNo);						*itemHit = gSelectItemNo;						evHandled = true;						break;				}			}			break;	}		return evHandled;}/*-------------------------------------------------------------------------------*//*	This routine fakes the hitting of the Add Textures button if CMD-A was pressed.*/void HitButton(DialogPtr theDlg,short item){	short iType;	ControlHandle iHndl;	Rect iRect;	long fTicks;		GetDItem(theDlg,item,&iType,(Handle*)&iHndl,&iRect);	HiliteControl(iHndl,inButton);	Delay(5,&fTicks);	HiliteControl(iHndl,0);}/*-------------------------------------------------------------------------------*//*	Filter all files except PICT files, MooV (QuickTime movie) files, WalkThrough Pro	models, and WalkThrough Pro libraries. !!!*/pascal Boolean FilterFiles(ParmBlkPtr PB, void *yourDataPtr){extern int gQuickTime;	if (PB->fileParam.ioFlFndrInfo.fdFlags & fInvisible)	// filter invisible things		return true;	else if (PB->fileParam.ioFlAttrib & (1<<4)) // a directory 		return false;	else // a file	{		if (PB->fileParam.ioFlFndrInfo.fdType == appFileTypePICT) return false;		else if ((gQuickTime) && (PB->fileParam.ioFlFndrInfo.fdType == appFileTypeQuickTime)) return false;		else if (PB->fileParam.ioFlFndrInfo.fdType == appFileTypeModel) return false;		//else if (PB->fileParam.ioFlFndrInfo.fdType == appFileTypeLibrary) return false;		else if (PB->fileParam.ioFlFndrInfo.fdType == appFileTypeTextureLibModel) return false;		else if (PB->fileParam.ioFlFndrInfo.fdType == appFileTypeVRTextureLib) return false;		// MERGE-GOURAUD-PRO-7		else return true;	}}/*-------------------------------------------------------------------------------*//*	This routine sets the name of the Select ("Add Textures") button to be the	passed-in string; it automatically displays an elipsis if the name is too	long to fit in the button.		This routine also sets the name of the Open button to "Open" if a folder is	selected, or "Add" if a file is selected.  */void SetSelectButtonName(SFDataPtr sfUserData, StringPtr selName,DialogPtr theDlg){	ControlHandle selectButton;	short iType;	Handle iHndl;	Rect iRect;	Str255 storeName,tempLenStr,tempSelName;	short btnWidth;		BlockMove(selName,tempSelName,selName[0]+1);	GetDItem(theDlg,gSelectItemNo,&iType,&iHndl,&iRect);		/* truncate select name to fit in button */		btnWidth = iRect.right - iRect.left;	BlockMove(gSelectString,tempLenStr,gSelectString[0]+1);	P2Cstr((char *)tempLenStr);	strcat((char *)tempLenStr,TXT_EMPTY_QUOTE);		// PRO-JAP	C2Pstr((char *)tempLenStr);	btnWidth -= StringWidth(tempLenStr);	//본본본본본TruncString(btnWidth,tempSelName,smTruncMiddle);		BlockMove(gSelectString,storeName,gSelectString[0]+1);	P2Cstr((char *)storeName);	P2Cstr((char *)tempSelName);	strcat((char *)storeName,TXT_OPEN_QUOTE);		// PRO-JAP	strcat((char *)storeName,(char *)tempSelName);	strcat((char *)storeName,TXT_CLOSE_QUOTE);		// PRO-JAP		C2Pstr((char *)storeName);	C2Pstr((char *)tempSelName);	SetCTitle((ControlHandle)iHndl,storeName);		SetDItem(theDlg,gSelectItemNo,iType,iHndl,&iRect);		if ((sfUserData->replyPtr->sfIsFolder) || (sfUserData->replyPtr->sfIsVolume))	{		GetDItem(theDlg,getOpen,&iType,&iHndl,&iRect);		SetCTitle((ControlHandle)iHndl,(unsigned char*)TXTI_OPEN);		// PRO-JAP		SetDItem(theDlg,getOpen,iType,iHndl,&iRect);	}	else	{		GetDItem(theDlg,getOpen,&iType,&iHndl,&iRect);		SetCTitle((ControlHandle)iHndl,(unsigned char*)TXTI_ADD);		// PRO-JAP		SetDItem(theDlg,getOpen,iType,iHndl,&iRect);	}}/*-------------------------------------------------------------------------------*//*	This routine returns TRUE if file1 and file2 are the same file.  It does this	in sort of a brain-dead way by comparing the fields one at a time -- in theory	the fields could be different and they still could point to the same file.*/Boolean SameFile(FSSpec *file1,FSSpec *file2){	if (file1->vRefNum != file2->vRefNum)		return false;	if (file1->parID != file2->parID)		return false;	if (!EqualString(file1->name,file2->name,false,true))		return false;		return true;}/*-------------------------------------------------------------------------------*//*	This routine sets the fSpec to be the appropriate stuff to return if the	Select Folder button is hit.  fSpec is already filled in with the FSSpec of	the currently selected file or folder in the GetFile dialog.  We have to modify	this FSSpec to be the enclosing folder if nothing is selected, the enclosing	folder if a file is selected, or the selected item if a folder is selected.*/OSErr MakeCanonFSSpec(SFDataPtr sfUserData, FSSpec *fSpec){	DirInfo infoPB;	OSErr err = 0;		if ((sfUserData->replyPtr->sfIsFolder) || (sfUserData->replyPtr->sfIsVolume))	{		// we are selecting a folder or volume, so don't change the fSpec at all		return err;	}	else if (fSpec->name[0] == '\0') 	{		// we are selecting nothing, so change the fSpec to the parent folder				infoPB.ioNamePtr = fSpec->name;			// PBGetCatInfo will fill in fSpec name		infoPB.ioVRefNum = fSpec->vRefNum;		infoPB.ioDrDirID = fSpec->parID;		infoPB.ioFDirIndex = -1;		err = PBGetCatInfo((CInfoPBPtr)&infoPB,false);	    fSpec->parID = infoPB.ioDrParID;		return err;	}	else 	{		// we are selecting a file, so change the fSpec to the enclosing folder				fSpec->name[0] = '\0';					// fake a zero-length name for PBGetCatInfo		infoPB.ioNamePtr = fSpec->name;			// fill in fSpec name		infoPB.ioVRefNum = fSpec->vRefNum;		infoPB.ioDrDirID = fSpec->parID;		infoPB.ioFDirIndex = -1;		err = PBGetCatInfo((CInfoPBPtr)&infoPB,false);	    fSpec->parID = infoPB.ioDrParID;		return err;	}}/*-----------------------------------------------------------------------------------*//**/pascal Boolean WLKfilter(ParmBlkPtr p){	if (p->fileParam.ioFlAttrib & (1<<4)) // a directory 		return false;	else // a file	{		if (p->fileParam.ioFlFndrInfo.fdType == appFileTypeModel) 			return false;		else 		{		char str[256];					memcpy(str, p->fileParam.ioNamePtr, p->fileParam.ioNamePtr[0]+1);			str[p->fileParam.ioNamePtr[0]+1] = '\0';			P2Cstr(str);					if (strstr(str, ".WLK") != NULL)				return false;			else				return true;		}	}}/*-----------------------------------------------------------------------------------*//**/pascal Boolean WLBfilter(ParmBlkPtr p){	if (p->fileParam.ioFlAttrib & (1<<4)) // a directory 		return false;	else // a file	{		if (p->fileParam.ioFlFndrInfo.fdType == appFileTypeLibrary) 			return false;		else 		{		char str[256];					memcpy(str, p->fileParam.ioNamePtr, p->fileParam.ioNamePtr[0]+1);			str[p->fileParam.ioNamePtr[0]+1] = '\0';			P2Cstr(str);					if (strstr(str, ".WLB") != NULL)				return false;			else				return true;		}	}}