#include "VTypes.h"#include "WTypes.h"#include "CVWCNTRL.h"#include "CNTRL.h"#include "CADCNTRL.h"#include <string.h>#include <stdio.h>#include "AppMssgs.h"#include "AppDeflt.h"#include "ToolDef.h"#include "Misc.h"#include "VGUtil.h"#include "VGraphic.h"#include <stdlib.h>#include <math.h>#include "VMenu.h"#include "TEXSEL.h"#include "Texture.h"#include "VRTex.h"#include "VFile.h"#include "TEXTARRY.h"						//keep after vfile		//GJR 10/06/93#include "TEXTITEM.h"#include "VMain.h"#include "Walkthru.h"		 // jca 11/23/93#include "VButton.h"#include "BALLHELP.H"#include "AppText.h"		// jca 14 Oct 93#if WINDOWS#include <ctype.h>#endif //WINDOWS#if VR // jca 17JAN94void TextureSelect::cPane(int flag)	{	V_Pane::cPane(flag);	}void TextureSelect::SetController(Controller *ctrl)	{ 	controller = ctrl; 	}void TextureSelect::SetWalkController(WalkController *ctrl)	{ 	walk_controller = ctrl; 	}voidTextureSelect::SetPopTexture(VRTexture *pop)	{	popTexture = pop;	}void TextureSelect::CalcSize(Rect *r, Point *p, int type, int warning)	{	controller->GetPlace(r, warning, toolTextureVR);	}void TextureSelect::DrawContent(int type,int x,int y)	{	Rect	r, r2;	RGBColor c;		r = dataRect;		VEraseRect(&r);			VForeColor(&vBlack);			VFrameRect(&r);	VInsetRect(&r,2,2);		VForeColor(&vBlack);	VMoveTo(r.right-7,r.top+2);	VLineTo(r.right-7,r.top+8);	VMoveTo(r.right-6,r.top+3);	VLineTo(r.right-6,r.top+7);	VMoveTo(r.right-5,r.top+4);	VLineTo(r.right-5,r.top+6);	VMoveTo(r.right-4,r.top+5);	VLineTo(r.right-4,r.top+5);	VFrameRect(&r);		VForeColor(&vBlack);	VBackColor(&vWhite);	if (current_texture == NULL)		{		VMoveTo(r.left + 10, r.top + (TEXTURE_HEIGHT / 2));		VSetPenNormal();		VSetFont(vAppFont, vAppFontSize, vNormal);    // jca 5 Oct 93 {		CenterTextInRect(TXTI_NOTEXTURE, &r, &r2);#if WINDOWS		VTextMode(vSrcXor);#endif		VDrawText(TXTI_NOTEXTURE, 0, strlen(TXTI_NOTEXTURE), &r2);    // try this char, Elvis.#if WINDOWS        VTextMode(vSrcOr);#endif		VSetFont(vSystemFont, vSystemFontSize, vNormal);    // jca 5 Oct 93 }		}	else		{			Rect r_from, r_to, tx_rect;			char str[256];#if 0			PenNormal();			TextFace(bold);							/* !!! */			TextFont(applFont);						/* !!! */			TextSize(9);							/* !!! */				current_texture->GetName(str);			C2Pstr(str);						MoveTo(r.left + 6, r.bottom - 18);			DrawString((StringPtr)str);					/* !!! */				TextFace(0);							/* !!! */				TextFont(systemFont);					/* !!! */			TextSize(12);							/* !!! */			TextFace(0);							/* !!! */#endif						if (active)			{			V_Display *thePlaceToBlitTo;   		// 22 OCt 93 jca {#if MACINTOSH			thePlaceToBlitTo = (V_Display *)theWindow;#elif WINDOWS			thePlaceToBlitTo = this;#endif // MACINTOSH				// !!! due to a bug in V_Windows, drawing with MetaTo must be done LAST !!!				r_from = current_texture->GetThumbnailRect();				SetRect(&r_to, r.left + 6, r.top + 5, r.left + 38, r.top + 37);				(current_texture->GetThumbnail())->MetaTo(thePlaceToBlitTo, &r_from, &r_to);			}                                  // jca 22 Oct 93 }			else			{				VSetPattern(vPatGray);#if MACINTOSH				VPenMode(notSrcXor);#elif WINDOWS#if !ELVIS // GreyOut nonactive TextureItem, notSrcXor		// GJR 10/01/93#error This needs your attention, Greg...				VPenMode(notSrcXor);#endif#endif				VPaintRect(&paneRect);				VSetPenNormal();			}		}	}void TextureSelect::Display(int type,int x,int y)	{	Rect	r;	RGBColor c;			switch(type)		{				default:					DrawContent(type, x, y);					break;		}	}		void TextureSelect::MouseDown(Point p,long modifiers)// DAS-VWINDOWS 9/30/93	{	Rect r;int length;int old;long result;#if 0	if (!active) return;	if(modifiers&doubleClick)	{	}	else	{		V_Pane::MouseDown(p,modifiers);	}#endif	if(modifiers&doubleClick)		controller->Request(NULL, msgEdit, objTexture, 0);	delayTime = VGetTime();	}// { DAS-VR-HELP 9/30/93voidTextureSelect::TrackHelp(Point pt, long modifier)	{	Rect rect;	rect=dataRect;	BalloonHotRect(&rect, pt);	Bubble(pt, &rect, TXTB_TEXTUREBAR);	}// } DAS-VR-HELP 9/30/93void TextureSelect::Track(Point p,long modifiers,int lastCall){			if( (buttonDown&modifiers) && appDelayTime < abs(VGetTime()-delayTime) && lastCall)		{		Point		l;		Rect		avoid=paneRect;    // jca -- avoid this pane		struct TextureItem *t;		// uninitialized texture ptr		l.h = avoid.left;             // jca -- put the rect in real space		l.v = avoid.top;		LocalToGlobal(&l);		VOffsetRect(&avoid, l.h, l.v);#if MACINTOSH		l.h = dataRect.right;		l.v = 0;		avoid.left = avoid.top = avoid.right = avoid.bottom = 0;#elif WINDOWS		l.h = dataRect.right+2;		l.v = 0;#endif		if (popTexture->Pop(l,&t, &avoid))			{			// no point in unloading and reloading the picture if we just selected the 			// current texture again...			if (t != current_texture)			{							// if the current_texture is not being used, then we should unload it				if (current_texture) 					current_texture->TIUnuse();//DAS-LK 10/2/93								current_texture = t;		// set the current texture				if (current_texture)					current_texture->TIUse();//DAS-LK 10/2/93			}						// ...however we should do this even if we selected the current texture again			// because new objects may have been selected and we should set their 			// textures			VDisplay(DRAW);				controller->Request(NULL, msgEdit, objTexture, 0);			}		}	VSetCursor(vCursorArrow);}	void TextureSelect::MouseUp(Point p,long modifiers)	{	#if 0		V_Pane::MouseUp(p,modifiers);#endif	if(modifiers&doubleClick)		controller->Request(NULL,msgEdit,objTexture,0);	}	void TextureSelect::SetTexture(struct TextureItem *t)	{		current_texture = t;	}	struct TextureItem * TextureSelect::GetTexture()	{		return(current_texture);	}	int TextureSelect::GetAction(long action,long modifiers)	{		if (!active) return(FALSE);	if(MSG_TEXTURE == action) 		{ controller->Request(NULL,msgEdit,objTexture,0); return(TRUE); }	return(FALSE);	}/*-----------------------------------------------------------------------------------------*/voidTextureFilesPopUp::AddItems(){struct V_File **fls;extern V_Array *gTextures;extern int gNextTextureLib;int i;int j;VStyleRec	style;	if (!gTextures) return;	style.font = vAppFont;	style.size = vAppFontSize;	style.face = vNormal;	style.just = vJustLeft;    style.textFlags = 0;	SetStyle(&style);	fls = (V_File**)gTextures->Use();	for ( i = 0 ; i < gTextures->ALength() ; i++ )	{	char str[256];	#if MACINTOSH		fls[i]->GetFName(str);#elif WINDOWS		fls[i]->GetName(str);				// reformats the filenames#if !JAPANESE		for (j = 1; j < strlen(str);j++)	// from NAME.TLB to Name			str[j] = (char)tolower(str[j]);	// BILBIL - 11/24/93#endif // !JAPANESE#endif //MACINTOSH		Append(str);	}	gTextures->Unuse();	Append(TXTI_TEXTCUSTOM);#if WINDOWS	SetValue(gNextTextureLib + 1);#endif //WINDOWS}voidTextureFilesPopUp::SetController(struct Controller *c){	controller = c;}void TextureFilesPopUp::Display(void){// do nothing}intTextureFilesPopUp::MouseDown(Point p,long modifiers){int result;Rect r;	result = V_PopMenu::MouseDown(p,modifiers);	r = thePane->dataRect;	SetRect(&r);	return result;}voidTextureFilesPopUp::SetRect(Rect *r){	Rect nR;	char *textPtr;	nR = *r;#if MACINTOSH	V_Text::SetRect(&nR);	popRect = bounds;	popRect.bottom -= popRect.top;	popRect.top = 0;	popRect.top--;	popRect.bottom++;	//popRect.left-=MENUPOP_PAD;	//popRect.right+=MENUPOP_PAD;#elif WINDOWS	nR.bottom += 100;	V_Control::SetRect(&nR);#endif}voidTextureFilesPopUp::Action()		// MERGE15{	extern V_Array *gTextureArrays;	extern int gNextTextureLib;	#if WINDOWS	GetValue();#endif //WINDOWS	if (value != 0)	{		if (value < 1) return;		if (value > gTextureArrays->ALength()) return;				gNextTextureLib = value - 1;		VSendMessage(OPEN_TEXTURE_LIB);		thePane->Reset();	// MERGE17	}}voidVRTextureTitle::cPane(int flag)	{	Rect r;	extern int gNextTextureLib;	controller = NULL;	V_Pane::cPane(flag);	moveSide = FALSE;		button = new(V_BItem);	button->cBItem(0x20);	r = dataRect;	texturePopUp = new(TextureFilesPopUp);	texturePopUp->cItem();	texturePopUp->SetRect(&r);	texturePopUp->Install(this);	AddItem(texturePopUp);	texturePopUp->SetValue(gNextTextureLib + 1);	}void VRTextureTitle::dPane()	{	button->dBItem();	V_Pane::dPane();		// will destroy vrLibPopUp (a V_Item)	}void VRTextureTitle::SetController(struct Controller *c)	{	controller = c;	if (texturePopUp) texturePopUp->SetController(c);	}void  VRTextureTitle::CalcSize(Rect *r,Point *p,int type,int warning){ 	controller->GetPlace(r,warning,toolVRPTextureTitle); 	texturePopUp->SetRect(r);}void VRTextureTitle::Display(int type,int h,int v)	{#if MACINTOSH	Rect	r,r2;	RGBColor	color;    VGrafPort   tp;    VGrafDevice gd;    char str[256] = "Texture";    int desired_width;		// MERGE17			VGetPort(&tp, &gd);	SetMetaPort();		r=dataRect;	r.right -= r.left;	r.bottom -= r.top;	r.left = 0;	r.top = 0;	desired_width = (r.right - r.left) - 20;		// MERGE17	button->SetState(OFFSTATE);	button->MoveButton(&r);	color = vBlack;	if(depth>=4)		button->CDraw();	else 		button->MDraw();		VForeColor(&vBlack);	TextSetUp(vAppFont,vAppFontSize,vBold);		// ŠŠŠ		VMoveTo(r.left+5,r.top+10);	texturePopUp->GetText(str);		// MERGE17	// ELVIS	Ellipsis(str, desired_width);		// MERGE17   jca 14 Oct 93 #if MACINTOSH	DrawText(str,0,strlen(str));#elif WINDOWS	r.left += 12;	r.top += 13;	VTextMode(vSrcXor);	VDrawText(str,0,strlen(str), &r);	// ELVIS#endif //WINDOWS	TextSetUp(vSystemFont,vSystemFontSize,vNormal);	r2 = dataRect;#if MACINTOSH	PenNormal();#elif WINDOWS	// ELVIS    VSetPenNormal();#endif // WINDOWS	VMoveTo(r2.right - 9, r2.bottom - 6);	VLineTo(r2.right - 9, r2.bottom - 6);	VMoveTo(r2.right - 10, r2.bottom - 7);	VLineTo(r2.right - 8, r2.bottom - 7);	VMoveTo(r2.right - 11, r2.bottom - 8);	VLineTo(r2.right - 7, r2.bottom - 8);	VMoveTo(r2.right - 12, r2.bottom - 9);	VLineTo(r2.right - 6, r2.bottom - 9);	VMoveTo(r2.right - 13, r2.bottom - 10);	VLineTo(r2.right - 5, r2.bottom - 10);	r = dataRect;	MetaCopy(&r);	UnsetMetaPort();	VSetPort(tp, gd);#elif WINDOWS    texturePopUp->SetRect(&dataRect);#endif //MACINTOSH	}void VRTextureTitle::MouseDown(Point p,long modifiers){Rect r;int length;int old;long result;	if (!active) return;	if(modifiers&doubleClick)	{	}	else	{		V_Pane::MouseDown(p,modifiers);	}}void VRTextureTitle::Track(Point p,long modifiers,int lastCall)	{		V_Pane::Track(p,modifiers,lastCall);	}void VRTextureTitle::MouseUp(Point p,long modifiers) 	{ 		V_Pane::MouseUp(p,modifiers);	}// { DAS-VR-HELP 9/30/93voidVRTextureTitle::TrackHelp(Point pt, long modifier)	{	Rect rect;	rect=dataRect;	BalloonHotRect(&rect, pt);	Bubble(pt, &rect, TXTB_TEXTUREGROUP);	}// } DAS-VR-HELP 9/30/93#endif // VR			