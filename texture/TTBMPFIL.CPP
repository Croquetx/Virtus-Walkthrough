#include "VTypes.h"#include "WTypes.h"#include "ShowTest.h"			// !!! DEBUG#include "VDisplay.h"#include "VFile.h"#include "VMemUtil.h"#include "VGUtil.h"#include "VGraphic.h"#include <string.h>#include <stdio.h>#include "VError.h"		// jca 4 Oct 93#include "TextType.h"			//after vfile		//GJR 10/06/93#include "BMPHandl.h"#include "AppText.h"#if MACINTOSH#include <Components.h>#endif/*------------------------------------------------------------------------------*//*	This routine */void TTBMPFile::cTextureType(){	char str[256] = "BMP";	FileTextureType::cTextureType();	strcpy(type_str, str);}/*------------------------------------------------------------------------------*//*	This method assumes that the texture->file has been set up appropriately (i.e.	it is a reference to a file).  This method will load the picture file, save	a smaller version of the picture in the thumbnail, and then delete the picture.	The picture will be loaded for real when the texture is actually used in a model	or selected in the texture selector.  (If no objects are selected and we choose	a texture from the palette, then we load the texture immediately.  Otherwise	there will be a delay if we try to create a new object -- the texture will be	loaded after we release the mouse button, while the marquee is still visible,	kinda ugly, and also may cause bugs because many routines do not expect the	port to be reset from underneath them (even though IOPictFile should not in	theory do that).  There is definitely a bug in there somewhere, probably the	fact that Set/UnsetMetaPort are not nestable.		!!! see comments in routine for what it actually does.*/int TTBMPFile::LoadPicture(){	int error = 0;extern int lowMemory;	if (!file) return(-1);	if (!mip[0])	{	V_Offscreen *temp_pict = NULL;	Rect r_from, r;	short power;	short width;    BMPReader*	bReader;			error = file->Open(FALSE);		if (error) return error;				bReader = new(BMPReader);		if (!error) error = bReader->cBMPReader(file);		if (!error) error = bReader->ReadImage(8);        if (!error) temp_pict = bReader->GetScreen();		if (temp_pict == NULL) error = memFullErr;        bReader->dBMPReader();		if (!error)		{			temp_pict->GetRect(&r_from);						// make the horizontal size a power of two			r = r_from;			power = 2;			width = r_from.right - r_from.left;			while (power < width)				power <<= 1;			power = min(power, 1024);		// max out at 1024, protects flash texture							r.right = r.left + power;			// make the vertical size a power of two			power = 2;			width = r_from.bottom - r_from.top;			while (power < width)				power <<= 1;							power = min(power, 1024);		// max out at 1024, protects flash texture							r.bottom = r.top + power;						mip[0] = NULL; 	// initialize			// check for degenerate cases			if (((r.bottom - r.top) == 0) || ((r.right - r.left) == 0))			{            	// ELVIS!!!! need a better error code				error = -1;	// jca 22MAR94 this is an error (there's probably a better error code)			}			if (lowMemory)	error = memFullErr;		}				if (!error)		{		// MERGE-PIXEL8 [[[		V_Pixel8 *temp_off = NULL;			temp_off = new(V_Pixel8);	// create temp offscreen			if (temp_off == NULL)				goto handle_error;						error = temp_off->cPixel8(&r, 8, &vWhite, NULL);			if (error) goto handle_error;							// copy pict to temp offscreen		   	temp_pict->SetMetaPort();		// MERGE-1/26		   	temp_off->SetMetaPort();		// MERGE-1/26		  	temp_pict->MetaTo(temp_off, &r_from, &r);		  	temp_off->UnsetMetaPort();		// MERGE-1/26		    temp_pict->UnsetMetaPort();		// MERGE-1/26//JAM 28JUN94 [[[ since temp_off and mip[0] are both pixel8's, we can just make mip[0] = temp_off#if 0/*			// jca 22MAR94 [[ moved this code down here			mip[0] = new(V_Pixel8);			if (mip[0] == NULL)				{							error = memFullErr;                goto handle_error;				}							error = mip[0]->cCreateCopy(temp_off);			if (error || lowMemory)				{				if (!error)	error = memFullErr;				mip[0] = NULL;                goto handle_error;                }			// jca 22MAR94 ]] end moved code			unpadded_rect[0] = r_from;		  	temp_off->dPixel8();		// get rid of temp offscreen			temp_off = NULL;*/#endif//JAM 28JUN94 ]]] since temp_off and mip[0] are both pixel8's, we can just make mip[0] = temp_off			unpadded_rect[0] = r_from;			mip[0] = temp_off;			temp_off = NULL;			goto no_error;handle_error:			//JAM 28JUN94 mip[0] should now always be NULL here, but I'm leaving it in.			if (mip[0] != NULL) mip[0]->dPixel8();			mip[0] = NULL;			if (temp_off)  // jca 22MAR94 also clean up the temp_off            	{				temp_off->dOffscreen();		// get rid of temp offscreen				temp_off = NULL;                }no_error:			;		// MERGE-PIXEL8 ]]]		}		if (temp_pict != NULL) temp_pict->dOffscreen();				if (error)			file->Close();		else			error = file->Close();					// close the picture file 	}	//ShowMem(FALSE);	return (error);}/*------------------------------------------------------------------------------*//*	This routine */void TTBMPFile::UnloadPicture(){	int i;		for ( i = 0 ; i < MAX_NUM_MIPS ; i++ )	{		if (mip[i]) mip[i]->dPixel8();		// get rid of picture		mip[i] = NULL;							// make sure picture set to NULL	}	//ShowMem(FALSE);}#if (!VPLAYER)/*------------------------------------------------------------------------------*//*	This routine */int TTBMPFile::MakeThumbnail(V_Offscreen *thumbnail, Rect *r_to){	int err;V_Offscreen *picture;double scale_factor;double new_height, new_width, margin;RGBColor c;int width, height, top, bottom, left, right;extern unsigned int offColor[];Rect r_from;Rect r_unpad;			// used to keep original unpadded rect for info display		//GJR082593	err = LoadPicture();					// loads the PICT into memory	picture = GetPicture(0);	if ((!err) && (picture))		{			GetPaddedRect(&r_from, 0);		GetUnpaddedRect(&r_unpad, 0);		// for info display of original size  //GJR082593		*r_to = thumbnail->rect;			width = r_from.right - r_from.left;		height = r_from.bottom - r_from.top;		if (width > height)		{			scale_factor = (double)(32.0 / width);			new_height = height * scale_factor;			margin = 32 - new_height;			top = (margin / 2);			bottom = 32 - (margin / 2);			SetRect(r_to, 0, top, 32, bottom);		}		else // height > width		{			scale_factor = (double)(32.0 / height);			new_width = width * scale_factor;			margin = 32 - new_width;			left = (margin / 2);			right = 32 - (margin / 2);			SetRect(r_to, left, 0, right, 32);		}				/* 		   note that we use the ditherCopy mode to transfer the picture 		   from the full-sized picture into the smaller thumbnail offscreen		   image.  This will doubtlessly make the thumbnail look better than		   simply doing a MetaTo because of automatic Macintosh error diffusion. 		*/			   		// copy from the picture only if there is a picture		picture->SetMetaPort();		thumbnail->SetMetaPort();		picture->MetaToMode(thumbnail, &r_from, r_to, vSrcDither);			thumbnail->UnsetMetaPort();		picture->UnsetMetaPort();					// we can unload the picture here, because if we are making a thumbnail,		// then no object has actually used the texture yet and so there is no		// danger of unloading a picture that needs to be kept around.		// (note that we unload it only if it was loaded earlier, and it was loaded		// earlier in this routine only if we didn't use the quicktime method)		UnloadPicture();	}	// set up size instance variable	ObjLock(this);#if JAPANESE	sprintf(info_str, "%s%d x %s%d", TXTD_HRZSIZE, r_unpad.right-r_unpad.left, TXTD_VRTSIZE, r_unpad.bottom-r_unpad.top);#else	sprintf(info_str, "%d%s x %d%s", r_unpad.right-r_unpad.left, TXTD_HRZSIZE, r_unpad.bottom-r_unpad.top, TXTD_VRTSIZE);#endif	ObjUnlock(this);	return(err);}#endif // (!VPLAYER)