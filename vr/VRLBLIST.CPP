#include "VTypes.h"#if VR#include "VRLBLIST.H"#include "VRLBITEM.H"#include "LIBITEM.H"#include "LIBINDEX.H"#include "LIBDEFS.H"#include "LBVCNTRL.H"#include "POLYHDRN.H"#include "VMDL.H"#include "APPMSSGS.H"#include "APPTEXT.H"#include "TOOLDEF.H"#include "MISC.H"#include "VIEW.H"#include "Observer.h"#include "SHOWTEST.H"#include "VGraphic.h"#include "Drawing.h"#include "Position.h"#include "VMath.h"#include "VSound.h"#include "VGUtil.h"#include "APPDEFLT.H"#include "VDialog.h"#include "CVEnvirn.h"#include "VFILE.H"#include "VRLBENTR.H"#include "LBWCNTRL.H"#include "VRIcon.h"		// jca 26 Sept 93#include "vdebug.h"#include "BALLHELP.H" // DAS-VR-HELP 9/30/93#include <stdio.h>#include <string.h>#include <math.h>void VRLibraryList::cPane(int flag)	{		controller = NULL;	beginSelection = -1;	items_per_row = 2;	List::cPane(flag);	SetVScroll();	}void VRLibraryList::LoadIndex(LibraryIndex *index){	VRLibraryEntry **entry;VRLibraryItem	*item,**ditems,**it;int		i,length;		length = theList->ALength();	ditems = (VRLibraryItem**)theList->Use();	for(i = 0; i < length; i++) 		ditems[i]->dListItem();	theList->Unuse();		theList->SetLength(0);			length = index->ALength();	entry = (VRLibraryEntry**)index->Use();	for(i = 0; i < length; i++,entry++) 	{		item = new(VRLibraryItem);		item->cListItem();		item->SetController(controller);		item->SetListPane(this);		if(*entry)		{			item->SetEntry(*entry,i);			theList->Append(&item);		}	}	index->Unuse();}#if MACINTOSH// on the mac, we can dither the icon#define VR_THUMBNAIL_RENDER_SIZE (VR_ICON_SIZE << 1)#elif WINDOWS// under windows, we can't.  Don't try.#define VR_THUMBNAIL_RENDER_SIZE	VR_ICON_SIZE#endifextern int gHigherPriorityMeterInUse; // jca 3MAR94 now defined in txtrsrvr.cpp; replaces gBuildingThumbnails.void VRLibraryList::BuildThumbnails(){	VRLibraryItem	**it;int		i,length, escape = FALSE;V_Offscreen *tmp_off,*new_off;V_Offscreen *new_off1;V_Pane *tmp_pane;Rect r;VGrafPort   savePort, meterPort;VGrafDevice saveDevice, meterDevice;int oldW, oldH;V_Pane *fakePane,*fakePane1;int opt, real_opt;RGBColor rgb = { 10000, 20000, 30000 };int already_started_meter = FALSE;	gHigherPriorityMeterInUse = TRUE;	// MERGE22	// This is where we should check to see if there are already icons in this	// file, and if so, we need to read them in.	// Create a fake pane so that the drawing code centers the items correctly.  This is really	// stupid but only in response to the stupidity of the Ident() routines, which rely on there	// being a current pane.  The only parts of the current pane they need, however, are the 	// centerX and centerY.  So we set those.  We don't do a cPane() because there is no point.	// Later we just "delete" this pane instead of doing a dPane().		// create an offscreen to draw into	tmp_off = offscreen;	new_off = new(V_Offscreen);	SetRect(&r, 0, 0, VR_THUMBNAIL_RENDER_SIZE, VR_THUMBNAIL_RENDER_SIZE);	new_off->cOffscreen(&r, 8, &vWhite, NULL);	// make a 1-bit offscreen of exactly icon size to render into for 1-bit icons	new_off1 = new(V_Offscreen);	SetRect(&r, 0, 0, VR_ICON_SIZE, VR_ICON_SIZE);	new_off1->cOffscreen(&r, 1, &vWhite, NULL);	// need to do this so that our view knows about how big our offscreen is.  Otherwise	// it thinks that is is the same size as the walkpane.  We save the old values so we	// can restore them later.	oldW = plc(controller)->view->width;	oldH = plc(controller)->view->height;	fakePane = new(V_Pane);	fakePane1 = new(V_Pane);	if (controller)	{	int err;	V_File	*originalCopy;				originalCopy = pLc(controller->controller)->GetFile();		// loop through the library items and draw each one to an offscreen.				// also to do:		// Also, we need to compute the world center of the item so we can orbit		// and we need to save the icon and item cetner to the library file.		length = theList->ALength();				VGetPort(&savePort, &saveDevice);	// get the port stuff, to save		it = (VRLibraryItem**)theList->Use();		for(i = 0; i < length && !escape; i++ ) 		{		Rect r_from, r_to, r;		char str[256], nm[256];					// build thumbnails only for those items that do not already have them			if (it[i]->has_thumb)				goto next_item;			else				{				it[i]->write_thumb = TRUE;// MERGE22 [[[				if (!already_started_meter)					{					MeterNoButtonCreate();					MeterTitle(TXT_APPNAME);					MeterSetText(TXTM_ICONS);					MeterSetTotal(length * 2);					MeterSetCount(0);					MeterStart();					VGetPort(&meterPort, &meterDevice);	// get the port stuff, to save					already_started_meter = TRUE;					}       // MERGE22 ]]]				}// MERGE22 [[[			it[i]->GetName(nm);			sprintf(str, TXTM_BITEM, i, nm);			VSetPort(meterPort, meterDevice);	// Set the port			MeterSetText(str);			MeterSetCount(i+1);			MeterUpdate(0);			VSetPort(savePort, saveDevice);   // MERGE22 ]]]						VSetCursor(vCursorEarth);			// VGet/SetPort required because LoadLibraryItem stupidly changes the current port.			// How conveeeenient.			VSetPort(savePort, saveDevice);			plc(controller)->LoadLibraryItem(i);			VSetPort(savePort, saveDevice);			offscreen = new_off;			offscreen->SetMetaPort();						// reset the height and width yet again because of utter rendering stupidity			tmp_pane = currentPane;			currentPane = fakePane;			currentPane->centerX = (VR_THUMBNAIL_RENDER_SIZE >> 1);			currentPane->centerY = (VR_THUMBNAIL_RENDER_SIZE >> 1); 			currentPane->dataRect.left = 0;			currentPane->dataRect.top = 0; 			currentPane->dataRect.right = VR_THUMBNAIL_RENDER_SIZE;			currentPane->dataRect.bottom = VR_THUMBNAIL_RENDER_SIZE;			 			plc(controller)->view->UpdatePane(VR_THUMBNAIL_RENDER_SIZE >> 1, 				VR_THUMBNAIL_RENDER_SIZE >> 1);					// set the flag so that we calc the bounding box			real_opt = plc(controller)->view->GetOptions(0xFFFF);  // jca 1 Oct 93            opt = real_opt;		// jca 1 Oct 93			opt |= DRAW_BBOX;			plc(controller)->view->SetOptions(opt);									// draw the library item into the offscreen (this one is just for calcing the bounding box)			plc(controller)->view->drawing->Sequence();			plc(controller)->view->Draw(TRUE, FALSE);					// unset the bounding box flag and dither flag			opt = plc(controller)->view->GetOptions(0xFFFF);		// yes, we just want to muck with the local options.. .jca 5 Oct 93			opt &= ~DRAW_BBOX;			opt &= ~DRAW_DITHER;			plc(controller)->view->SetOptions(opt);						// set the item center for this item			it[i]->itemCenter.x = ((plc(controller)->view->boundMin.x + plc(controller)->view->boundMax.x) >> 1);			it[i]->itemCenter.y = ((plc(controller)->view->boundMin.y + plc(controller)->view->boundMax.y) >> 1);			it[i]->itemCenter.z = ((plc(controller)->view->boundMin.z + plc(controller)->view->boundMax.z) >> 1);			// reset the observer location to something good			plc(controller)->view->SetGoodObserverPosition(VR_THUMBNAIL_RENDER_SIZE, VR_THUMBNAIL_RENDER_SIZE);						// redraw into the icon -- this time for real!!!			plc(controller)->view->drawing->Sequence();			plc(controller)->view->Draw(TRUE, FALSE);			// reset the observer location to something good for the walk pane			plc(controller)->view->SetGoodObserverPosition(204, LIBPREVIEW_HEIGHT);		// ABD MERGE9 change to VRLIB_DEFWIDTH						// remember the observer point and angle			it[i]->obsPoint = plc(controller)->view->point;			it[i]->obsAngle = plc(controller)->view->angle;			// reset the dither flag			//opt = plc(controller)->view->GetOptions(0xFFFF);		REMOVE		  //	opt |= DRAW_DITHER;     jca 1 Oct 93				REMOVE			plc(controller)->view->SetOptions(real_opt);      // jca 1 Oct 93			offscreen->UnsetMetaPort();			// reset the observer location to something good for the b/w icon			plc(controller)->view->SetGoodObserverPosition(VR_ICON_SIZE, VR_ICON_SIZE);			offscreen = new_off1;			offscreen->SetMetaPort();						// reset the height and width yet again because of utter rendering stupidity			currentPane = fakePane1;			currentPane->centerX = (VR_ICON_SIZE >> 1);			currentPane->centerY = (VR_ICON_SIZE >> 1); 			currentPane->dataRect.left = 0;			currentPane->dataRect.top = 0; 			currentPane->dataRect.right = VR_ICON_SIZE;			currentPane->dataRect.bottom = VR_ICON_SIZE;			plc(controller)->view->UpdatePane(VR_ICON_SIZE >> 1, VR_ICON_SIZE >> 1);					// unset the dither flag and set whatever other flags we want here			real_opt = plc(controller)->view->GetOptions(0xFFFF);  		// jca 1 Oct 93            opt = real_opt;		// jca 1 Oct 93			opt &= ~DRAW_DITHER;			opt |= DRAW_WHITE_SHADE;			opt |= DRAW_BLACK_FRAME;			plc(controller)->view->SetOptions(opt);						// redraw into the icon -- this time for real!!!			plc(controller)->view->drawing->Sequence();			plc(controller)->view->Draw(TRUE, FALSE);			// reset the dither flag and unset other flags here			/*opt = plc(controller)->view->GetOptions(0xFFFF);		REMOVE			opt |= DRAW_DITHER;										REMOVE			opt &= ~DRAW_WHITE_SHADE;								REMOVE			opt &= ~DRAW_BLACK_FRAME;			jca 5 Oct 93		REMOVE */			plc(controller)->view->SetOptions(real_opt);  	// jca 1 Oct 93			offscreen->UnsetMetaPort();			VSetPort(savePort, saveDevice);			// reset the current pane			currentPane = tmp_pane;			new_off->GetRect(&r_from);			if (currentGallery8)		// we're using an icon cache				{				r_to = currentGallery8->GetNextRect();				it[i]->thumbnail8 = currentGallery8->GetOffscreen();				it[i]->thumb8Rect = r_to;				it[i]->thumb8Owner = currentGallery8;				currentGallery8->Add(new_off, &r_from, vSrcDither);				}			else		// no icon cache; make sure we have an icon available				{				if (!it[i]->thumbnail8)					{					Rect	lr = it[i]->thumb8Rect;					it[i]->thumbnail8 = new(V_Offscreen);					it[i]->thumbnail8->cOffscreen(&lr, 8, NULL, NULL);					// check that we can get this offscreen?  ELVIS!!!					}				it[i]->thumbnail8->GetRect(&r_to);						new_off->MetaToMode(it[i]->thumbnail8, &r_from, &r_to, vSrcDither);				}							// copy the library item into our thumbnail offscreen, without dithering			// (it's 1-bit... why dither?)	jca 			new_off1->GetRect(&r_from);			if (currentGallery1)		// we're using an icon cache				{				r_to = currentGallery1->GetNextRect();				it[i]->thumbnail1 = currentGallery1->GetOffscreen();				it[i]->thumb1Rect = r_to;				it[i]->thumb1Owner = currentGallery1;				currentGallery1->Add(new_off1, &r_from, vSrcCopy);				}			else		// no icon cache; make sure we have an icon available				{				if (!it[i]->thumbnail1)					{					Rect	lr = it[i]->thumb1Rect;					it[i]->thumbnail1 = new(V_Offscreen);					it[i]->thumbnail1->cOffscreen(&lr, 1, NULL, NULL);					// check that we can get this offscreen?  ELVIS!!!					}				it[i]->thumbnail1->GetRect(&r_to);						new_off1->MetaToMode(it[i]->thumbnail1, &r_from, &r_to, vSrcCopy);				}			//			ShowOffscreen(it[i]->thumbnail8);//			ShowOffscreen(new_off);//			ShowOffscreenMore(currentGallery8->GetOffscreen());///			ShowOffscreen(it[i]->thumbnail1);//			ShowOffscreen(new_off1);next_item:			;		}		offscreen = tmp_off;		// write the thumbnail and info out		for(i = 0; i < length && !escape; i++ ) 		{		char nm[256];	// MERGE22		char str[256];	// MERGE22// BILBIL - ShowOffscreen(it[i]->thumbnail);			if (it[i]->write_thumb && !originalCopy->ReadOnly())			{				//  write one colormap jca 15 Sept 93			   /*	if (defClrmap8)					{                    }     */				originalCopy->SetQuery(LOAD,"Load Library:");				originalCopy->IOSetDirection(DATA_IN);				originalCopy->Open(FALSE);				originalCopy->IOSetDirection(DATA_OUT);				plc(controller)->libraryIndex->VREntry(originalCopy,i,it[i]);				originalCopy->Close();// MERGE22 [[[				it[i]->GetName(nm);				sprintf(str, TXTM_SITEM, i, nm);				VSetPort(meterPort, meterDevice);	// Set the port				MeterSetText(str);				MeterSetCount(length+i+1);				MeterUpdate(0);				VSetPort(savePort, saveDevice);      // MERGE22 ]]]			}		}		theList->Unuse();		if (length > 0)			MeterStop();	// MERGE22           	}	delete fakePane;		// use delete because we never did a cPane()    delete fakePane1;	new_off->dOffscreen();    new_off1->dOffscreen();		// Update the pane width and height to their old values.	plc(controller)->view->UpdatePane(oldW, oldH);	gHigherPriorityMeterInUse = FALSE;	// MERGE22}	voidVRLibraryList::MouseDown(Point p,long modifier)	{	ListItem	**aListItem;	int			oldselection;	delayTime = VGetTime();	doPopUp = FALSE;		if(!theList->ALength())return;		oldselection = selection;			Select(p);		if(oldselection != selection && oldselection!=-1)		{		aListItem = (ListItem **)theList->Use();				aListItem[ oldselection ]->Hilite(FALSE);					aListItem[ selection ]->Hilite(TRUE);				theList->Unuse();		}	UnsetPane();	Drag();	SetPane();		if(modifier & doubleClick)		{		aListItem = (ListItem **)theList->Use();				aListItem[ selection ]->Action(p,modifier);				theList->Unuse();		}	beginSelection = selection;	}			void VRLibraryList::Track(Point p,long modifiers,int lastCall)	{	VSetCursor(vCursorArrow);		if((buttonDown & modifiers))		{			if(beginSelection != selection) beginSelection = -1;		}	List::Track(p,modifiers,lastCall);	}voidVRLibraryList::Display(int type,int x,int y)	// ABD MERGE16	{	ListItem	**aListItem;	Rect r;	int	 top;	VPenMode(vPatCopy);	VSetPattern(vPatBlack);		r = dataRect;		switch(type)		{		case DEACT_DRAW:				case DEACT_REDRAW:		case DEACT_REBUILD_DRAW:		case	ACT_REBUILD_DRAW:			case	ACT_DRAW:			case	DRAW:					case 	ACT_REDRAW:						VEraseRect(&r);			DrawContent(y,type);			break;		case	SCROLL_DRAW:			if(y>lastVisible)				type = DRAW;			r.bottom = r.bottom - leftOver;			top = (firstVisible-y) * GetHeight();							#if MACINTOSH			{			RgnHandle	updateRgn;			updateRgn = NewRgn();			ScrollRect(&r,0,top,updateRgn);			SetClip(updateRgn);			DisposeRgn(updateRgn);            }			r = dataRect;#elif WINDOWS			ScrollWindow(paneWindow,0,top,&r,NULL);			if(top>=0)r.top=r.bottom+top;			else r.bottom=r.top+top;#endif //WINDOWS			VEraseRect(&r);			DrawContent(y,type);			break;		}	}		/*========================================================================= * void List::DrawContent( int dy, int type ) * This method draws the list items in the list *-------------------------------------------------------------------------*/void VRLibraryList::DrawContent(int y,int type)	{	ListItem	**aListItem;	Rect		r,r2;	int			i,length,height,bottom,dy,offset;	int			hl=-1;	int			fv,lv;	int item;		if(!(length = theList->ALength())) return;	height = GetHeight();	bottom = dataRect.bottom - 1;	aListItem = (ListItem**)theList->Use();	dy = firstVisible - y;	r2 = dataRect;#if 0	if( depth >= 4)		{		VForeColor(&vColorSlateM);		PaintRect(&r2);		VForeColor(&vBlack);		}	else#endif//	VEraseRect(&r2);	switch(type)		{		case SCROLL_DRAW:			if (dy == 0)	return;    // ELVIS 15 Spet 93		default:			VEraseRect(&r2);#if WINDOWS   // jca 8 Dec 93 {			// draw a line beside the icons if there's no scroll.  If there is a scroll, it covers this up.			VMoveTo(r2.right-1, r2.top);            VLineTo(r2.right-1, r2.bottom);#endif       // jca 8 Dec 93 }			r = dataRect;					firstVisible = y;			lastVisible = firstVisible + .5 + (r.bottom - r.top) / (double)GetHeight();			if(lastVisible>=(length / items_per_row))lastVisible=length-1;			if(firstVisible<0)fv=0;						/* guarantees the list will try to fit 			as much as the list as it can into the pane */									if(1 > (offset = length - lastVisible))				{				if(0>(firstVisible + offset))					offset = firstVisible;									firstVisible += offset;				lastVisible += offset;								if(lastVisible > length - 1)					lastVisible = length - 1;				}							offset = 0;						// VR -- firstVis and lastvis are now rows that are visible, not actual			// items, 			for(i = firstVisible; i <= lastVisible; i++)			{				offset+=height;									for(item = 0; item < items_per_row; item++)				{					if (((i*items_per_row)+item) < theList->ALength())					{						aListItem[(i*items_per_row)+item]->location = offset;						aListItem[(i*items_per_row)+item]->horiz_location = item * item_width;											aListItem[(i*items_per_row)+item]->Display();											if(aListItem[(i*items_per_row)+item]->GetState())hl=(i*items_per_row)+item;			/* dude - not necessary */					}				}			}			if(hl!=-1)aListItem[hl]->Hilite(TRUE);		/* dude - I think		*/						break;		}					theList->Unuse();	}	/*========================================================================= * void List::Select( Point p	 ) * This method finds the selection in the list from the point * VR changes: VR can have n items across, which are always evenly spaced, * so we find out the horizontal position as well. *-------------------------------------------------------------------------*/void VRLibraryList::Select(Point p)	{		int	height,length,width;	int row,col;	int old_sel = selection;		height = GetHeight();	width = dataRect.right - dataRect.left;			if (0 > (row = firstVisible + p.v/ height)) 		row = 0;	else if (row >= (length = GetNumRows())) 		// MERGE24		row = length-1;			col = p.h / item_width;		selection = (row * items_per_row) + col;	// MERGE24 -- moved this check up here	// extra sanity check (probably not necessary)	if (selection < 0)		selection = 0;	else if (selection >= theList->ALength()) 	// MERGE24		selection = theList->ALength()-1;		// MERGE24	if (selection != old_sel)		{		current_angle_yaw = 0;		if (controller)			{			if (plc(controller)->libraryItemTitle)				{				UnsetPane();				plc(controller)->libraryItemTitle->VDisplay(DRAW);				SetPane();				}			if (plc(controller)->view)							//MERGE21				plc(controller)->view->SetPoint(GetObsPoint());	//MERGE21			}		}	}Point3D VRLibraryList::GetItemCenter(){VRLibraryItem *listItem;	listItem = (VRLibraryItem *)GetCurrentItem();	if (listItem)		return (((VRLibraryItem*)listItem)->itemCenter);	else	{	Point3D tmp = { 0, 0, 0 };		return tmp;	}}Point3D VRLibraryList::GetBoundMin()		// MERGE20{VRLibraryItem *listItem;	listItem = (VRLibraryItem *)GetCurrentItem();	if (listItem)		return (((VRLibraryItem*)listItem)->boundMin);	else	{	Point3D tmp = { 0, 0, 0 };		return tmp;	}}Point3D VRLibraryList::GetBoundMax()		// MERGE20{VRLibraryItem *listItem;	listItem = (VRLibraryItem *)GetCurrentItem();	if (listItem)		return (((VRLibraryItem*)listItem)->boundMax);	else	{	Point3D tmp = { 0, 0, 0 };		return tmp;	}}Point3D VRLibraryList::GetObsPoint(){VRLibraryItem *listItem;	listItem = (VRLibraryItem *)GetCurrentItem();	if (listItem)		return (((VRLibraryItem*)listItem)->obsPoint);	else	{	Point3D tmp = { 0, 0, 0 };		return tmp;	}}Angle3D VRLibraryList::GetObsAngle(){VRLibraryItem *listItem;	listItem = (VRLibraryItem *)GetCurrentItem();	if (listItem)		return (((VRLibraryItem*)listItem)->obsAngle);	else	{	Angle3D tmp = { 0, 0, 0 };		return tmp;	}}int VRLibraryList::GetNumRows(){	if (theList)	{		return (theList->ALength() + (items_per_row - 1)) / items_per_row;	}	else		return 0;}		void VRLibraryList::CalcSize(Rect *r,Point *p,int type,int warning)	{	controller->GetPlace(r,warning,toolVRLLibrary);				// compute how many items we can have nicely per row	items_per_row = ((r->right - r->left) - 16) / VR_COLUMN_SIZE;		if (items_per_row == 0) 		items_per_row = 1;				// compute how many actual pixels wide is each item	item_width = ((r->right - r->left) - 16) / items_per_row;	}void VRLibraryList::SetVScroll()		// MERGE20	{	SetVPage((int)(0.5 + (dataRect.bottom - dataRect.top) / (double)GetHeight()) - 1);	// MERGE20	SetVMove(1);	SetVSpeed(10); //MERGE23		}intVRLibraryList::GetHeight()	{	return(VR_ICON_HEIGHT_FUDGE + VR_ICON_SIZE);  // jca 3 Oct 93	}	intVRLibraryList::AddItem()	{ 	LibraryItem		*item;		if(item = (LibraryItem*)GetCurrentItem())		item->SetHilite(FALSE);		if(selection<0)selection = 0;	item = (LibraryItem*)new(VRLibraryItem);	item->cListItem();	item->SetController(controller);	item->SetListPane(this);	theList->Insert(selection,&item);	item->SetHilite(TRUE);		return(TRUE); 	}// { DAS-VR-HELP 9/30/93voidVRLibraryList::TrackHelp(Point pt, long modifier)// DAS-VWINDOWS 9/30/93	{	Rect r;		r=dataRect;	Bubble(pt,&r,TXTB_ICONGALLERY);	}// } DAS-VR-HELP 9/30/93#endif //VR