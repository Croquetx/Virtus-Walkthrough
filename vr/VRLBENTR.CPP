#include "VTypes.h"#if VR // jca 14JAN94#include "VRLBENTR.H"#include "LibIndex.h"#include "WalkBuff.h"#include "VMDL.h"#include "VRLBITEM.H"		 // ABD MERGE6 WILLIAMS 8/26/93#include "VMemUtil.h"#include "ShowTest.h"#include "VGraphic.h"#include "VGUtil.h"#include "VDebug.h"#include "VRIcon.h"intVRLibraryIndex::IO_FORM(V_Buffer *buf, int loc)	{	int err = 0;	long id;	VRLibraryEntry *entry;	Handle name;	char *namePtr;	V_Array	*clrmap8 = NULL, *clrmap1 = NULL;		if (buf->IODirection() == DATA_IN)		{		err = err?err:buf->IOType(&id, IO_LONG);		if (!err && id == IFF_VCLP)			{			entry = new(VRLibraryEntry);			entry->cEntry();			entry->SetPosition(buf->IOGetPosition());			entry->SetLength(buf->ChunkSize());				buf->SetRefCon(0);			err = err?err:buf->IOType(&id, IO_LONG);			entry->SetType(id);				while (!err && id)							{				id = buf->OpenChunkR();				if (id == 0) break;								switch(id)					{					case IFF_VERS:						err = err?err:IO_VERS(buf);						break;						case IFF_NAME:						name = NewHandle(256);						HLock((Handle)name);						namePtr = (char *)HDeref(name);						err = err?err:IOType(buf, namePtr, IO_CSTR);						entry->SetName(namePtr);						HUnlock((Handle)name);						DisposHandle((Handle)name);						break;					case IFF_CGRP:						{   // for now, 2 color maps.						long	count, cmapCount;						ULong	ucolor;						RGBColor	rgb;						ULong ctype;						int i;						// read the item count						err = err?err:buf->IOType((void *) &count, IO_LONG);						if (count == 2)							{							if (clrmap8)	clrmap8->dArray();  //destroy any previous ones							if (clrmap1)	clrmap1->dArray();							clrmap8 = new(V_Array);							clrmap8->cArray(0, sizeof(RGBColor), 16);							clrmap1 = new(V_Array);							clrmap1->cArray(0, sizeof(RGBColor), 2);                            // open the 8-bit chunk							ctype = buf->OpenChunkR();							if (ctype == IFF_CMAP)								{								cmapCount = buf->ChunkSize()/sizeof(ULong);								// 8-bit first								for (i = 0; i < cmapCount && !err; i++)									{                    				err = err?err:IOType(buf, (void *)&ucolor, IO_LONG);									rgb.red = (Short)((ucolor >> 8) & 0xFF00);									rgb.green = (Short)((ucolor) & 0xFF00);									rgb.blue = (Short)((ucolor << 8) & 0xFF00);                                    clrmap8->Append(&rgb);									}								}							else								err = err?err: -1;                            buf->CloseChunk(); 							ctype = buf->OpenChunkR();							if (ctype == IFF_CMAP)								{								cmapCount = buf->ChunkSize()/sizeof(ULong);								// 1-bit		  						for (i = 0; i < cmapCount && !err; i++)									{									err = err?err:buf->IOType((void *)&ucolor, IO_LONG);									rgb.red = (Short)((ucolor >> 8) & 0xFF00);									rgb.green = (Short)((ucolor) & 0xFF00);									rgb.blue = (Short)((ucolor << 8) & 0xFF00);                                    clrmap1->Append(&rgb);									}								}							else								err = err?err: -1;													buf->CloseChunk();							}						}						break;					case IFF_VRIF:					{					V_Offscreen *off8 = NULL, *off1 = NULL;					ULong	ctype;					long 	count;					Point3D itemCenter = { 0, 0, 0 };					Point3D obsPoint = { 0, 0, 0 };					Point3D boundMin = { 0, 0, 0 };		// MERGE20					Point3D boundMax = { 0, 0, 0 };		// MERGE20					Angle3D obsAngle = { 0, 0, 0 };						err = err?err:IOType(buf, (void*)&itemCenter, IO_POINT3D);						err = (err?err:IOType(buf, (void*)&obsPoint, IO_POINT3D));						err = (err?err:IOType(buf, (void*)&obsAngle, IO_ANGLE3D));						err = (err?err:IOType(buf, (void*)&boundMin, IO_POINT3D));		// MERGE20						err = (err?err:IOType(buf, (void*)&boundMax, IO_POINT3D));		// MERGE20										ctype = buf->OpenChunkR();						if (ctype == IFF_CGRP)							{							// read the item count							err = err?err:buf->IOType((void *) &count, IO_LONG);							if (count == 2)                            	{								// read in the info (thumbnail and info)								if (!err)									{									if (!currentGallery8)	// we've got no cache managers 										{ 										off8 = new(V_Offscreen);										off1 = new(V_Offscreen);										ctype = buf->OpenChunkR();										if (ctype == IFF_BMAP)											err = (err?err:off8->IO_BMAP(buf, clrmap8, NoCompression));										buf->CloseChunk();																				// do the 1-bit										ctype = buf->OpenChunkR();										if (ctype == IFF_BMAP)											err = (err?err:off1->IO_BMAP(buf, clrmap1, NoCompression));										buf->CloseChunk();										entry->SetThumbnail8(off8);										entry->SetThumbnail1(off1);														}									else		// we have cache managers; write to them										{										Rect	localR;										ctype = buf->OpenChunkR();										if (ctype == IFF_BMAP)											{											err = (err?err:currentGallery8->IO_Icon(buf, &localR, clrmap8, NoCompression));											if (!err)												{									 //			ShowOffscreenMore(currentGallery8->icons);												entry->SetThumbnail8(currentGallery8->GetOffscreen());												entry->SetThumbnail8Rect(localR);												entry->thumb8Owner = currentGallery8;												}											}										buf->CloseChunk();										ctype = buf->OpenChunkR();										if (ctype == IFF_BMAP)											{											err = (err?err:currentGallery1->IO_Icon(buf, &localR, clrmap1, NoCompression));											if (!err)												{		//										ShowOffscreen(currentGallery1->icons);												entry->SetThumbnail1(currentGallery1->GetOffscreen());												entry->SetThumbnail1Rect(localR);												entry->thumb8Owner = currentGallery1;												}											}										buf->CloseChunk();										}									}								}							else								err = err?err:-1;							}                        buf->CloseChunk();						entry->SetItemCenter(itemCenter);						entry->SetObsPoint(obsPoint);						entry->SetObsAngle(obsAngle);						entry->SetBound(boundMin,boundMax);		// MERGE20					}						break;					}					buf->CloseChunk();				}			}			if (!err)			Insert(loc, &entry);		else			entry->dEntry();		}	return(err);	}voidVRLibraryIndex::VREntry(V_Buffer *buf, int loc, struct VRLibraryItem *vr_item)	{	long id;	long vrSize = 0, posn = 0, headerPosn, size;	int insert;	long itemCount, newSize;	VRLibraryEntry **ent;	int nEntries, i;	V_Buffer *vbuf;	int err = 0;	int	iconCaches;	Rect	rect8, rect1;		// jca 28 Sept 93 {	// if we're using a cache, use the cache write out.  otherwise, do the IO_BMAP	if (vr_item->thumb8Owner)  // we have an owner		iconCaches = TRUE;	else		iconCaches = FALSE;		// set up the rects	rect8 = vr_item->thumb8Rect;	rect1 = vr_item->thumb1Rect;	// jca 28 Sept 93 }	buf->IOSetDirection(DATA_IN);	OpenEntry(buf, loc);	buf->SetRefCon(0);	headerPosn = buf->IOGetPosition() - 12;	buf->IOType(&id, IO_LONG);	posn = buf->IOGetPosition();	while (vrSize == 0)		{		id = buf->OpenChunkR();		if (id == 0) break;		switch(id)			{			case IFF_VERS:				posn = buf->IOGetPosition()+buf->ChunkSize();				posn = (posn+0x1) & ~0x1;				break;				case IFF_NAME:				posn = buf->IOGetPosition()+buf->ChunkSize();				posn = (posn+0x1) & ~0x1;				break;			case IFF_VRIF:				posn = buf->IOGetPosition() - 8;				vrSize = (buf->ChunkSize() + 1) & ~1;				break;			}		buf->CloseChunk();		}	CloseEntry(buf);	// init the virtual buffer	vbuf = new(V_Buffer);	vbuf->cBuffer(DATA_OUT);	//ShowOffscreen(vr_item->thumbnail);    // write out the new VRIF chunk	ObjLock((ObjectHandle)vr_item);	err = err?err:vbuf->OpenChunkW(IFF_VRIF);			// write out the viewing info 		IOType(vbuf, (void*)&(vr_item->itemCenter), IO_POINT3D);		IOType(vbuf, (void*)&(vr_item->obsPoint), IO_POINT3D);		IOType(vbuf, (void*)&(vr_item->obsAngle), IO_ANGLE3D);		// write the bounding box		IOType(vbuf, (void*)&(vr_item->boundMin), IO_POINT3D);		// MERGE20		IOType(vbuf, (void*)&(vr_item->boundMax), IO_POINT3D);		// MERGE20        // write a grouping chunk		err = err?err:vbuf->OpenChunkW(IFF_CGRP);        	itemCount = 2;               // two images			err = err?err:vbuf->IOType((void *)&itemCount, IO_LONG);			// write the 8-bit image chunk			vbuf->OpenChunkW(IFF_BMAP);				if (iconCaches) vr_item->thumb8Owner->IO_Icon(vbuf, &rect8, NULL, NoCompression);				else 			vr_item->thumbnail8->IO_BMAP(vbuf, NULL, NoCompression);		// jca 28 Sept 93			vbuf->CloseChunk();			// write the 1-bit image chunk			vbuf->OpenChunkW(IFF_BMAP);				if (iconCaches) vr_item->thumb1Owner->IO_Icon(vbuf, &rect1, NULL, NoCompression);				else 			vr_item->thumbnail1->IO_BMAP(vbuf, NULL, NoCompression);		// jca 28 Sept 93			vbuf->CloseChunk();		// close the grouping chunk        vbuf->CloseChunk();	vbuf->CloseChunk();	ObjUnlock((ObjectHandle)vr_item);    if (!err)	// if an error, do not pass go, do not collect $200    	{	    // set the ouput stream, set the size, and add or remove space.		buf->IOSetDirection(DATA_OUT);		vbuf->IOLength(&newSize);		if (vrSize != 0)			insert = newSize - vrSize;		else			insert = newSize;			insert = (insert + 0x1) & ~0x1;				if (insert > 0)			buf->IOInsert(posn, insert);		else if (insert < 0)			buf->IODelete(posn, -insert);			// now write the vbuf to the file		buf->IOSetPosition(posn);		vbuf->IO(buf);			// updating the chunk header		buf->IOSetPosition(headerPosn+4);		buf->IOSetDirection(DATA_IN);		buf->IOType(&size, IO_LONG);		size += insert;		buf->IOSetDirection(DATA_OUT);		buf->IOSetPosition(headerPosn+4);		buf->IOType(&size, IO_LONG);			// update the file's header		buf->IOSetPosition(4);		buf->IOSetDirection(DATA_IN);		buf->IOType(&size, IO_LONG);		size += insert;		buf->IOSetDirection(DATA_OUT);		buf->IOSetPosition(4);		buf->IOType(&size, IO_LONG);		}			nEntries = ALength();	ent = (VRLibraryEntry **)Use();	ent += loc;			(*ent)->SetThumbnail8(vr_item->thumbnail8);	(*ent)->SetThumbnail1(vr_item->thumbnail1);	(*ent)->SetThumbnail8Rect(vr_item->thumb8Rect);	(*ent)->SetThumbnail1Rect(vr_item->thumb1Rect);	(*ent)->SetThumbnail8Owner(vr_item->thumb8Owner);	(*ent)->SetThumbnail1Owner(vr_item->thumb1Owner);	(*ent)->SetItemCenter(vr_item->itemCenter);	(*ent)->SetObsPoint(vr_item->obsPoint);	(*ent)->SetObsAngle(vr_item->obsAngle);	(*ent)->SetBound(vr_item->boundMin, vr_item->boundMax);		// MERGE20	if (!err)		(*ent)->SetLength((*ent)->GetLength() + insert);	ent++;		if (!err)		{		// now, update the entries for any further chunks.  Any chunk in the file 		// beyond this one must have its location field in the entry list updated		// to the new file location		for (i = loc+1; i < nEntries; i++, ent++)			(*ent)->SetPosition((*ent)->GetPosition() + insert);		Unuse();	}			// deallocate the vbuf	vbuf->dBuffer();	}voidVRLibraryEntry::cEntry()	{	LibraryEntry::cEntry();		thumbnail8 = NULL;	thumbnail1 = NULL;	VSetRect(&thumb8Rect, 0,0,0,0); 	// jca 25 Sept 93	thumb1Rect = thumb8Rect;			// jca 25 Sept 93	obsPoint.x = obsPoint.y = obsPoint.z = 0;	itemCenter.x = itemCenter.y = itemCenter.z = 0;	obsAngle.roll = obsAngle.pitch = obsAngle.yaw = 0;	}V_Offscreen *VRLibraryEntry::GetThumbnail8()				// ABD WILLIAMS MERGE6 8/26/93	{ return(thumbnail8); }voidVRLibraryEntry::SetThumbnail8(struct V_Offscreen *t)		// ABD WILLIAMS MERGE6 8/26/93	{ thumbnail8 = t; }V_Offscreen *VRLibraryEntry::GetThumbnail1()				// ABD WILLIAMS MERGE6 8/26/93	{ return(thumbnail1); }voidVRLibraryEntry::SetThumbnail1(struct V_Offscreen *t)		// ABD WILLIAMS MERGE6 8/26/93	{ thumbnail1 = t; }// jca 25 Sept 93 {voidVRLibraryEntry::SetThumbnail1Rect(Rect r)			{ thumb1Rect = r; }voidVRLibraryEntry::SetThumbnail8Rect(Rect r)			{ thumb8Rect = r; }voidVRLibraryEntry::SetThumbnail1Owner(VRIconCache *ic)			{ thumb1Owner = ic; }voidVRLibraryEntry::SetThumbnail8Owner(VRIconCache *ic)			{ thumb8Owner = ic; }	// jca 25 Sept 93 }Point3DVRLibraryEntry::GetItemCenter()				// ABD WILLIAMS MERGE6 8/26/93	{ return(itemCenter); }voidVRLibraryEntry::SetItemCenter(Point3D ic)		// ABD WILLIAMS MERGE6 8/26/93	{ itemCenter = ic; }Point3DVRLibraryEntry::GetBoundMin()				// ABD WILLIAMS MERGE20	{ return(boundMin); }Point3DVRLibraryEntry::GetBoundMax()				// ABD WILLIAMS MERGE20	{ return(boundMax); }voidVRLibraryEntry::SetBound(Point3D bmin, Point3D bmax)		// ABD WILLIAMS MERGE20	{ boundMin = bmin; boundMax = bmax; }Point3DVRLibraryEntry::GetObsPoint()					// ABD WILLIAMS MERGE6 8/26/93	{ return(obsPoint); }voidVRLibraryEntry::SetObsPoint(Point3D ic)		// ABD WILLIAMS MERGE6 8/26/93	{ obsPoint = ic; }Angle3DVRLibraryEntry::GetObsAngle()					// ABD WILLIAMS MERGE6 8/26/93	{ return(obsAngle); }voidVRLibraryEntry::SetObsAngle(Angle3D ic)		// ABD WILLIAMS MERGE6 8/26/93	{ obsAngle = ic; }#endif // VR