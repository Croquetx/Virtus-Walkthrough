#include "VTypes.h"#if VR#include "VRLBITEM.h"#include "VRLBLIST.h"#include "LIBINDEX.h"#include "LBVCNTRL.H"#include <stdio.h>#include <string.h>#include "APPTEXT.H"#include "MISC.H"#include "APPDEFLT.H"#include "VPane.h"#include "VWindow.h"#include "VGraphic.h"#include "VDisplay.h"#include "VRLBENTR.H"#include "VRIcon.h"void VRLibraryItem::cListItem()	{	Rect r;	entry = NULL;	controller = NULL;	VSetRect(&r, 0, 0, VR_ICON_SIZE, VR_ICON_SIZE);   // jca 2 Oct 93/*	jca 25 Sept 93 {	thumbnail1 = new(V_Offscreen);	thumbnail1->cOffscreen(&r,1, &vWhite, NULL);	thumbnail8 = new(V_Offscreen);	thumbnail8->cOffscreen(&r, 8, &vWhite, NULL); */	thumbnail1 = thumbnail8 = NULL;	thumb8Rect = thumb1Rect = r;		thumb8Owner = thumb1Owner = NULL;	// jca 25 Sept 93 }	has_thumb = FALSE;	write_thumb = FALSE;	itemCenter.x = itemCenter.y = itemCenter.z = 0;	boundMin.x = boundMin.y = boundMin.z = 0;		// MERGE20	boundMax.x = boundMax.y = boundMax.z = 0;		// MERGE20	obsPoint.x = obsPoint.y = obsPoint.z = 0;	obsAngle.roll = obsAngle.pitch = obsAngle.yaw = 0;	}	void VRLibraryItem::dListItem()	{	if (!thumb8Owner && thumbnail8)		// jca 25 Sept 93 {		thumbnail8->dOffscreen();	if (!thumb8Owner && thumbnail8)		thumbnail1->dOffscreen();		if (thumb8Owner)		thumb8Owner->Remove(thumb8Rect);	if (thumb1Owner)		thumb1Owner->Remove(thumb1Rect);	// jca 25 Sept 93 }			delete(this);		// jca 15 Sept 93	}void VRLibraryItem::SetController(Controller *ctrl)	{	controller = ctrl;	}void VRLibraryItem::SetEntry(LibraryEntry *newEntry,int num)	{//	jca 31 aug 93	Handle 	strH;	char *str;	entry = newEntry;	strH = (Handle) newEntry->GetName();	if (strH)		{		HLock(strH);        str = (char *)HDeref(strH);		strcpy(name, str);		HUnlock(strH);		}	else    	sprintf(name, "Object %i", num+1);		// get the thumbnail and the info from the entry and set them here	if ((((VRLibraryEntry *)newEntry)->thumbnail8 != NULL) &&		(((VRLibraryEntry *)newEntry)->thumbnail1 != NULL))	{		if (thumbnail1) thumbnail1->dOffscreen();		thumbnail1 = ((VRLibraryEntry *)newEntry)->thumbnail1;		if (thumbnail8) thumbnail8->dOffscreen();		thumbnail8 = ((VRLibraryEntry *)newEntry)->thumbnail8;		thumb8Rect = ((VRLibraryEntry *)newEntry)->thumb8Rect;	// jca 25 Sept 93 {		thumb1Rect = ((VRLibraryEntry *)newEntry)->thumb1Rect;			thumb8Owner = ((VRLibraryEntry *)newEntry)->thumb8Owner;		thumb1Owner = ((VRLibraryEntry *)newEntry)->thumb1Owner;		// jca 25 Sept 93 }		has_thumb = TRUE;	}	else	{		has_thumb = FALSE;	}	itemCenter = ((VRLibraryEntry *)newEntry)->itemCenter;	boundMin = ((VRLibraryEntry *)newEntry)->boundMin;		// MERGE20	boundMax = ((VRLibraryEntry *)newEntry)->boundMax;		// MERGE20	obsPoint = ((VRLibraryEntry *)newEntry)->obsPoint;	obsAngle = ((VRLibraryEntry *)newEntry)->obsAngle;	}void VRLibraryItem::Display()	{			VPenState p;	Rect r, r2, r_from, r_to;    	// jca 2 Oct 93	int item_width = ((VRLibraryList *)(list_pane))->item_width;	int w;    VGrafPort   tp;    VGrafDevice gd;    VRLibraryItem *local_this = this;    int desired_width; 		// MERGE17    char str[256]; 	GetRect(&r2);           	// jca 2 Oct 93	VGetPen(&p);		VSetPenNormal();	GetLocationRect(&r_to);	VForeColor(&vBlack);	VBackColor(&vWhite);	VGetPort(&tp, &gd);// ELVIS	if (list_pane->depth < 4)    	{		r_from = thumb1Rect;		thumbnail1->MetaTo(list_pane, &r_from, &r_to);		}	else		{		r_from = thumb8Rect;		thumbnail8->MetaTo(list_pane, &r_from, &r_to);		}	VSetPort(tp, gd);	VInsetRect(&r_to, -1, -1);	VForeColor(&vBlack);	VFrameRect(&r_to);	VForeColor(&vColorSlateLine);	VMoveTo(r_to.right, r_to.top+1);	VLineTo(r_to.right, r_to.bottom);	VLineTo(r_to.left+1, r_to.bottom);	VForeColor(&vBlack);	VSetRect(&r, r2.left + 2, r2.bottom  - 13,		r2.left + item_width - 2, r2.bottom);     // jca 2 Oct 93#if MACINTOSH        	// jca 2 Oct 93 {	desired_width = (r.right - r.left) - 5;		// MERGE17#elif WINDOWS	desired_width = (r.right - r.left); 		// jca 2 Oct 93 ...Looks great, less space wasted...#endif // MACINTOSH		// jca 2 Oct 93 }	TextSetUp(vAppFont,vAppFontSize,vNormal);	VForeColor(&vBlack);	VBackColor(&vWhite);	strcpy(str, name);		// MERGE21#if MACINTOSH	Ellipsis(str, desired_width);		// MERGE17		// MERGE21	TextBox(str, strlen(str), &r, teJustCenter);		// MERGE21#elif WINDOWS	{          // center the text    // jca 2 Oct 93 {	ULong textLen;    int realLen, fudge;	Ellipsis(str, desired_width);		// this truncates the text and adds ellipses.	textLen = GetTextExtent(GetGraphicContext(), str, strlen(str));   // get the text length now	realLen = LOWORD(textLen);   // get the text length now	fudge = (desired_width - realLen)/2;     // figure out the fudge on each side	VInsetRect(&r, fudge, 0);            // inset the rect to center the name    }               // jca 2 Oct 93 }	VDrawText(str,0,strlen(str), &r);		// MERGE21#endif //MACINTOSH	TextSetUp(vSystemFont,vSystemFontSize,vNormal);		VSetPen(&p);	}/* jca 19 Sept 93This is where the icon is in the lib window*/voidVRLibraryItem::GetLocationRect(Rect *r)	{	int item_width = ((VRLibraryList *)(list_pane))->item_width;	int pad = (item_width - VR_ICON_SIZE) >> 1;	Rect r_region;    // get the rect that contains the icon and the item name    GetRect(&r_region);	// set the location of image within that rect	VSetRect(r, r_region.left + pad, (r_region.bottom - VR_ICON_PLACEMENT) - VR_ICON_SIZE,		r_region.left + VR_ICON_SIZE + pad, r_region.bottom - VR_ICON_PLACEMENT);   // jca 2 Oct 93    }void VRLibraryItem::GetRect(Rect *r)	{	int result;	int row;	VRLibraryItem *local_this = this;	VRLibraryList *list = ((VRLibraryList *)(list_pane));	int items_per_row = list->items_per_row;	int item_width = list->item_width;		r->left = 0;	r->right = item_width;		result = list->theList->Find(&local_this);	row = result / items_per_row;	if (row < list->firstVisible) 	{		r->top = -32000;		r->bottom = -32000;	}	else 	{		r->top = GetHeight() * (row - list->firstVisible);		r->bottom = GetHeight() * ((row - list->firstVisible)+1);	}	r->left += (result % items_per_row) * item_width;	r->right += (result % items_per_row) * item_width;		if ((result % items_per_row) == items_per_row-1)		r->right = list->dataRect.right;	}int VRLibraryItem::GetHeight(void){	return(VR_ICON_HEIGHT_FUDGE + VR_ICON_SIZE);      // jca 2 Oct 93}/*========================================================================= * void ListItem::Hilite(int hiliteState) * This method displays the list item in the list *------------------------------------------------------------------------------*/void VRLibraryItem::Hilite(int hiliteState)	{	Rect	r, ricon, r2;		// MERGE19		hilited = hiliteState;		GetRect(&r);#if 0	if( list_pane->depth >= 4)		{		VForeColor(&vColorSlateM);		PaintRect(&r);		VForeColor(&vBlack);		}	else#endif	VEraseRect(&r);		Display();		if(hilited)		{#if MACINTOSH			// 0x938 is the low-memory global that we set to do a real hilite		// operation -- this is the "HiliteMode" global, but HiliteMode is		// used for something else so we just hard-code the number.  Cute.		GetLocationRect(&ricon);    				// get the icon's rect		// MERGE19		VSetRect(&r2, r.left, ricon.bottom, r.right, r.bottom);			// MERGE19		BitClr ((Ptr)0x938, pHiliteBit);		// ABD do a real hilite		InvertRect(&r2);								// ABD		VSetRect(&r2, r.left, r.top, r.right, ricon.top);		// MERGE19		BitClr ((Ptr)0x938, pHiliteBit);		// ABD do a real hilite		InvertRect(&r2);								// ABD		VSetRect(&r2, r.left, ricon.top, ricon.left, ricon.bottom);		// MERGE19		BitClr ((Ptr)0x938, pHiliteBit);		// ABD do a real hilite		InvertRect(&r2);								// ABD		VSetRect(&r2, ricon.right, ricon.top, r.right, ricon.bottom);		// MERGE19		BitClr ((Ptr)0x938, pHiliteBit);		// ABD do a real hilite		InvertRect(&r2);								// ABD#elif  WINDOWS		VPenMode(vPatXor);			VPaintRect(&r);     	// XOR the whole item rect		GetLocationRect(&r);    	// get the icon's rect		VPaintRect(&r);         // XOR the item back		VPenMode(vPatCopy);#endif // MACINTOSH		}	}#endif // VR