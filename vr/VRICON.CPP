#include "VTypes.h"#if VR#include <stdio.h>#include "VGraphic.h"#include "VDisplay.h"#include "VMemUtil.h"#include "VRLbItem.h"#include "VRIcon.h"#include "VError.h"#include "TextType.h"		// jca#include "ShowTest.h"	// for testing/* the VRIconCache is used to manage the VR icons as references into a single offscreen.Each icon has an id number and a rect in the VRIconCache's offscreen.  We can assume thatall the icons will use the same color map and be the same bitdepth, and that there will not be more than 20 icons per library.  I'm going to check that the icon count is< 20 and enlarge the offscreen if not.Usage:There will be two VRIconCaches per library (one for color, one for B&W).  With VR, we knowthat there will only be two libs open at a time:  one 2D, and one 3D*//* globals, for easy access */VRIconCache 	*currentGallery8=NULL;VRIconCache 	*currentGallery1=NULL;VRIconCache *gallery2DColorIcons=NULL;VRIconCache *gallery2DMonoIcons=NULL;VRIconCache *gallery3DColorIcons=NULL;VRIconCache *gallery3DMonoIcons=NULL;#if VR_CACHE_TEXTURE_ICONS			// jca 18 Oct 93 {VRIconCache *globalTextureIcons=NULL;#endif // VR_CACHE_TEXTURE_ICONS	// jca 18 Oct 93 }/* some routines to manage the globals:  set them, up, destroy them. */int	InitVRIconCaches(){	int err = noErr;	Rect	defVRRect;		VSetRect(&defVRRect, 0, 0, VR_ICON_SIZE, VR_ICON_SIZE);	// we know this.		if (!gallery2DColorIcons)		{		gallery2DColorIcons = new(VRIconCache);		err = err?err:gallery2DColorIcons->cVRIconCache(MAX_VR_ITEM_COUNT, 8, defVRRect);		if (!err)	MoveObjHi(gallery2DColorIcons);		}	if (!gallery2DMonoIcons)		{		gallery2DMonoIcons = new(VRIconCache);		err = err?err:gallery2DMonoIcons->cVRIconCache(MAX_VR_ITEM_COUNT, 1, defVRRect);		if (!err)	MoveObjHi(gallery2DMonoIcons);		}	if (!gallery3DColorIcons)		{		gallery3DColorIcons = new(VRIconCache);		err = err?err:gallery3DColorIcons->cVRIconCache(MAX_VR_ITEM_COUNT, 8, defVRRect);		if (!err)	MoveObjHi(gallery3DColorIcons);		}	if (!gallery3DMonoIcons)		{		gallery3DMonoIcons = new(VRIconCache);		err = err?err:gallery3DMonoIcons->cVRIconCache(MAX_VR_ITEM_COUNT, 1, defVRRect);		if (!err)	MoveObjHi(gallery3DMonoIcons);		}#if VR_CACHE_TEXTURE_ICONS			// jca 18 Oct 93 {	if (!globalTextureIcons)		{		Rect textureRect;				VSetRect(&textureRect, 0, 0, TEXTURE_ICON_SIZE, TEXTURE_ICON_SIZE);		globalTextureIcons = new(VRIconCache);		err = err?err:globalTextureIcons->cVRIconCache(MAX_VR_ITEM_COUNT, 8, textureRect);		}#endif // VR_CACHE_TEXTURE_ICONS	// jca 18 Oct 93 }		return(err);}void EndVRIconCaches(){	if (gallery2DColorIcons) gallery2DColorIcons->dVRIconCache();	if (gallery2DMonoIcons) gallery2DMonoIcons->dVRIconCache();	if (gallery3DColorIcons) gallery3DColorIcons->dVRIconCache();	if (gallery3DMonoIcons) gallery3DMonoIcons->dVRIconCache();#if VR_CACHE_TEXTURE_ICONS			// jca 18 Oct 93 {	if (globalTextureIcons) globalTextureIcons->dVRIconCache();#endif // VR_CACHE_TEXTURE_ICONS	// jca 18 Oct 93 }}/* count is the number of things to allocate space for, depth is the bitdepth ofthe offscreen, and rect is the size of the icon */	int	VRIconCache::cVRIconCache(int count, int depth, Rect rect){	Rect	offSize;	int		err = noErr;		iconCount = 0;	VSetRect(&baseRect, 0, 0, (rect.right - rect.left), (rect.bottom - rect.top)); 	VSetRect(&offSize, 0, 0, baseRect.right, (baseRect.bottom * count));		icons = new(V_Offscreen);	err = icons->cOffscreen(&offSize, depth, &vWhite, NULL);	if (err)		{		icons->dOffscreen();		icons = NULL;		allocSize = 0;		}	else		{		allocSize = count;		nextRect = baseRect;		}	return(err);	}	void VRIconCache::dVRIconCache(){	if (icons)	icons->dOffscreen();	delete(this);}/*	Call Resize if you need to get a larger bitmap*/intVRIconCache::Resize(int count, int depth , Rect rect){	int		allocated, err = noErr;	Rect	maxR, oldR, newR;	V_Offscreen	*old;	if (!icons)		err = cVRIconCache(count, depth, rect);	else		{		// nextRect.top is the end of the used space, and is a multiple of baseRect.bottom.		// Thus, the number of used spaces is (nextRect.top/baseRect.bottom)		allocated = nextRect.top/baseRect.bottom;			if (count < allocated)					count = allocated;	// thou shalt not allocate less than thou needst.				VSetRect(&oldR, 0, 0, nextRect.right, nextRect.top);	// this is the real size of the offscreen		VSetRect(&newR, 0, 0, baseRect.right, baseRect.bottom*count);	// this is the size we want		VSetRect(&maxR, 0, 0, baseRect.left, baseRect.bottom*allocSize);	// this is the allocated size				if (newR.bottom == maxR.bottom)	// the bottom is the real size			return(err);		// you tried to reallocate the same size space.					if (iconCount)	// don't preserve the icons if there are none to preserve			{			old = new(V_Offscreen);			err = err? err:old->cOffscreen(&oldR, depth, &vWhite, NULL);		//		ShowOffscreen(icons);			if (!err)	icons->MetaTo(old, &oldR, &oldR);	// save the old icons			}		err = err?err:icons->Resize(&newR, RESIZE_PRESERVE_DEPTH);				if (!err)			{			if (iconCount)				{				// I get confused on this sometimes, so I'll write it down.				// oldR is the real, current size of the icon space.  				// newR is the size of the space we want (which cannot be <= than				// oldR, because we checked for it.  It can be smaller than the allocated				// space, though (we may have allocated a huge space earlier, and are compacting it)//		ShowOffscreen(old);				old->MetaTo(icons, &oldR, &oldR);//		ShowOffscreen(icons);				old->dOffscreen();				}			allocSize = count;			VSetRect(&nextRect, oldR.left, oldR.bottom, oldR.right, (oldR.bottom+baseRect.bottom));			}		else			icons = old;		}			return(err);		}int	VRIconCache::Add(struct V_Offscreen *voff, Rect *r, ULong mode){	int err = noErr;	Rect lR = baseRect;	Rect nR = nextRect;		if (!icons)		return(NO_ICON_CACHE);		if (iconCount >= allocSize)		err = Resize(2*allocSize, icons->GetDepth(), lR);		if (!err)		{		ObjLock((ObjectHandle)this);		icons->SetMetaPort();		// MERGE-Z1		icons->ToMetaMode(voff, r, &nR, mode);  // store the icon		icons->UnsetMetaPort();		// MERGE-Z1		ObjUnlock((ObjectHandle)this);		*r = nextRect;		// return the icon's location in the rect		VSetRect(&nextRect, 0, nextRect.bottom, nextRect.right, (nextRect.bottom+baseRect.bottom));		iconCount++;		}			return(err);}int VRIconCache::Remove(Rect which){#if 0	// for now, do nothing.  Decrement the count.	// In the future, we should maintain a status vector for each icon	int whichId = which.bottom/baseRect.bottom;	//which.bottom is be a multiple of baseRect.#endif	if (icons)		iconCount--;}int	VRIconCache::RemoveAll(void){	iconCount = 0;	nextRect = baseRect;}intVRIconCache::Compact(int mod){	int		newSize, depth, maxIcon, err = noErr;	Rect	ourRect;	if (mod <= 0)	mod = 1;	// must be a positive divisor		// nextRect.top is the end of the used space, and is a multiple of baseRect	maxIcon = nextRect.top/baseRect.bottom;		newSize = (maxIcon+mod-1) / mod;	// allocate space to the nearest mod.  So if mod == 20, we allocate in blocks of 20	newSize *= mod;		// never allocate an empty offscreen.	if (newSize <= 0)	newSize = 1;		if (newSize < iconCount)			newSize += mod;			// can't compact an empty dataspace && only compact larger spaces	if ((icons)	&& (allocSize > newSize))		{		depth = icons->GetDepth();		ourRect = baseRect;			err=err?err:Resize(newSize, depth, ourRect);		}			return(err);	}// return the basic icon sizeRect VRIconCache::GetBaseRect(void){	Rect retRect = baseRect;	return(retRect);}// return the basic icon sizeRect VRIconCache::GetNextRect(void){	Rect retRect = nextRect;	return(retRect);}int	VRIconCache::GetDepth(void){	return((icons?icons->GetDepth():0));}V_Offscreen *VRIconCache::GetOffscreen(void){	return(icons);}/* 27 Sept 93   jca		{   This potentially dangerous routine reads icons from a file into the cache or    write icons from the cache to a file.  The potential danger is, of course, in    the lack of safeguards in this routine and the routines it calls.      Parameters:  	   		buf				the V_Buffer we are going to or coming from.  It is usually a file,    						though it needn't be.   				   		rect			If we're writing, this is the rect we want to write from the cache.   						It will not be modified inside the routine.  If we are reading,    						this is the rect where the icon was stuck.  It _is_ modified inside   						the routine   		   		cMap			colormap for the icon, stuffed into a V_Array.  This is an optional   						colormap, and if it exists, is the colormap for all of the icons   						in the file.  Currently not used.   				   		compression		flag for the compression option.  Currently NoCompression, since   						we're not compressing.	*/int	VRIconCache::IO_Icon(struct V_Buffer *buf, Rect *rect, V_Array *cMap, int compression){	int err = noErr;		if (buf->IODirection() == DATA_OUT)		{			/* if the rect we're outputting is not the same width and height as the base rect		   and is not within the allocated offscreen, then there's an error.  Bye! */		if ((((rect->bottom - rect->top) != (baseRect.bottom - baseRect.top)) ||			((rect->right != baseRect.right) || (rect->left != baseRect.left))) ||			((rect->top < baseRect.top) || (rect->bottom > nextRect.top)))		// remember, nextRect.top is the _bottom_ end of the used space.			err = WRONG_RECT_SIZE;				if (!err)			{	// if no error, do the dirty deed.			Rect rR;#if MACINTOSH			rR = *rect;#elif WINDOWS			icons->GetRect(&rR);			rR.top = rR.bottom - rect->bottom;			rR.bottom -= rect->top;#endif			err = icons->IO_BMAP_STRIPE(buf, cMap, rR.top, (rR.bottom-rR.top), FALSE, compression);			}		}	else		{		if (!icons)			return(NO_ICON_CACHE);		// get the extremely unlikely case out of the way					if (iconCount >= allocSize)			{		// resize the offscreen			Rect lR = baseRect;			err = Resize(allocSize * 2, icons->GetDepth(), lR);			}				if (!err)			{			Rect rR;			*rect = nextRect;#if MACINTOSH			rR = nextRect;#elif WINDOWS			icons->GetRect(&rR);			rR.top = rR.bottom - rect->bottom;			rR.bottom -= rect->top;#endif			err = icons->IO_BMAP_STRIPE(buf, cMap, rR.top, (rR.bottom-rR.top), FALSE, compression);						if (!err)				{				nextRect.top = nextRect.bottom;				nextRect.bottom += baseRect.bottom;				iconCount++;				}			}		}			return(err);	}// jca 27 Sept 93 }#endif // VR