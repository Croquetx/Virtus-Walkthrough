#include "VTypes.h"#include "VIEWCOLL.H"#include "VIEW.H"#include "POLYHDRN.H"#include "POLYCONV.H"#include "SURFACE.H"#include "SURFFEAT.H"#include "vdebug.h"	// ABD DEBUG#include "MATRIX.H"	// ABD#include <math.h>#include <stddef.h>#include "misc.h"#include "surfdef.h"#include "VArray.h"#include "Position.h"#include "VGUtil.h"#include "Geometry.h"#include <stdlib.h>#if COLLISION_DETECTION#ifndef	HUGE_VAL#define	HUGE_VAL	1.7976931348623157e+308#endiftypedef struct Point4Struct 	/* 4d point */{	double x, y, z, w;} Point4D;/* fast macro version of V3Dot, usable with Point4 */#define DOT3( a, b )	( (a)->x*(b).x + (a)->y*(b).y + (a)->z*(b).z )#define RAY_HIT_FEAT 2#define RAY_MISSED_FEAT 3struct V_Array *g2DPoints;voidSurface::RayIntersectFeats(Point3D *int_point, int *return_val){int nFeatures, i;SurfFeature **feat;	if ((!return_val) || (!int_point)) return;		*return_val = RAY_MISSED_FEAT;	if ((surfDef != NULL) && (surfDef->features[SURF_SHARED] != NULL))	{		nFeatures = surfDef->features[SURF_SHARED]->ALength();		feat = (SurfFeature **)(surfDef->features[SURF_SHARED])->Use();		for ( i = 0; i < nFeatures; i++ )		{			// if this surface feature could change our return val to missed, then			// check it.			if (IS_TRANSPARENT(feat[i]->opacity))			{			int length = feat[i]->posnPoints->ALength();			Point3D normal = posnNormal;	//  surface positioned normal;			int max_component;			Point3DFFixed *pts;			Point *ptss;			Point p, testPoint;			Point a,b;				int next, j;			int hit_it = TRUE;			int dropped_component;			int direction;							if (!g2DPoints)				{					g2DPoints = new(V_Array);					g2DPoints->cArray(0, sizeof(Point), 8);				}				g2DPoints->SetLength(0);							max_component = max(max(abs(normal.x), abs(normal.y)), abs(normal.z));							pts = (Point3DFFixed *)feat[i]->posnPoints->Use();				if (max_component == abs(normal.x))				{					dropped_component = normal.x;					for( j = 0; j < length; j++ )					{ p.h = pts[j].z.intg; p.v = pts[j].y.intg; g2DPoints->Append(&p);}					testPoint.h = int_point->z;					testPoint.v = int_point->y;				}				else if (max_component == abs(normal.y))				{					dropped_component = normal.y;					for( j = 0; j < length; j++ )					{ p.h = pts[j].x.intg; p.v = pts[j].z.intg; g2DPoints->Append(&p);}					testPoint.h = int_point->x;					testPoint.v = int_point->z;				}				else if (max_component == abs(normal.z))				{					dropped_component = normal.z;					for( j = 0; j < length; j++ )					{ p.h = pts[j].y.intg; p.v = pts[j].x.intg; g2DPoints->Append(&p);}					testPoint.h = int_point->y;					testPoint.v = int_point->x;				}				feat[i]->posnPoints->Unuse();								// if the component we dropped was negative, then test for counter-				// clockwise ness otherwise, test for clockwiseness.				if (dropped_component < 0)					direction = COUNTERCLOCKWISE;				else					direction = CLOCKWISE;									// copy the points into the 2d points array, dropping the largest				// magnitude component								ptss = (Point *)g2DPoints->Use();				for( j = 0; j < length; j++ )				{					next = nextNum(j,length);					a.h = ptss[j].h; 						a.v = ptss[j].v;					b.h = ptss[next].h; 					b.v = ptss[next].v;					if (direction == Clockwise(testPoint,a,b)) 					{ 						// we are not in this surface feature 						hit_it = FALSE;						break; 					}				}				g2DPoints->Unuse();				if (hit_it)					{					*return_val = RAY_HIT_FEAT;		// went through transparent surf feature					break;				// BILBIL - Someone needs to check this, DREW.					}				else					*return_val = RAY_MISSED_FEAT;			}		}		surfDef->features[SURF_SHARED]->Unuse();	}}/*--------------------------------------------------------------------------------*//*	This routine tests the ray with the surface and all of the surface features	in the surface.*/int	Surface::RayIntersectLowLevel				(   Point3Ddouble	*org, 		// origin of velocity vector					Point3Ddouble	*dir, 		// normalized velocity vector					double tmax,				// length of velocity vector					double *tresult) 			// intersection pt along ray {Point4D pln;						/* plane equation */double tnear, tfar, t, vn, vd;short p0,p1,p2,count;short *index;Point3DFFixed *surfPt;int return_val;int length;	length = points->ALength();	if (length == 0)		return RAY_MISSED;	surfPt = (Point3DFFixed*)polyConvex->polyhedron->posnPoints->Use();	index = (short*)points->Use();	    tnear = -HUGE_VAL;    tfar = tmax;	*tresult = HUGE_VAL;		// compute the plane equation 	count = 0;	p0 = count;	p1 = length+2 >> 2;	p2 = length+1 >> 1;	while((count < length) && FFEqual(surfPt[index[p0]].x,surfPt[index[p1]].x)		&& FFEqual(surfPt[index[p0]].y,surfPt[index[p1]].y)		&& FFEqual(surfPt[index[p0]].z,surfPt[index[p1]].z))		{ count++; p1 = count; };	while((count < length) && FFEqual(surfPt[index[p0]].x,surfPt[index[p2]].x)		&& FFEqual(surfPt[index[p0]].y,surfPt[index[p2]].y)		&& FFEqual(surfPt[index[p0]].z,surfPt[index[p2]].z))		{ count++; p2 = count; };	while((count < length) && FFEqual(surfPt[index[p1]].x,surfPt[index[p2]].x)		&& FFEqual(surfPt[index[p1]].y,surfPt[index[p2]].y)		&& FFEqual(surfPt[index[p1]].z,surfPt[index[p2]].z))		{ count++; p2 = count; };	PlaneEquationDbl(surfPt[index[p0]],surfPt[index[p1]],		surfPt[index[p2]],&(pln.x),&(pln.y),&(pln.z),&(pln.w));   	/* Compute intersection point T and sidedness */	vd = DOT3(dir, pln);	vn = DOT3(org, pln) + pln.w;		if (vd == 0.0) 	{	    // ray is parallel to plane - check if ray origin is inside plane's	    // half-space 	    	    if (vn > 0.0)				// ray origin is outside half-space 		{			return_val = RAY_MISSED;			goto exit_routine;		}	} 	else 	{	    	    t = -vn / vd ;				// ray not parallel - get distance to plane	    if (vd < 0.0) 	    {			if (t > tfar) 			// front face - T is a near point 			{				return_val = RAY_MISSED;				goto exit_routine;			}							if (t > tnear) 			// hit near face, update normal			    tnear = t;	    } 	    else 	    {			if (t < 0.0) 			// back face - T is a far point			{				return_val = RAY_MISSED;				goto exit_routine;			}							if (t < tfar) 			// hit near face, update normal			    tfar = t;	    }	}    // survived all tests    // Note: if ray originates on polyhedron, may want to change 0.0 to some    // epsilon to avoid intersecting the originating face.    if (tnear >= 0.0) 			// outside, hitting front face    {		*tresult = tnear;		return_val = RAY_HIT;		goto exit_routine;	} 	else 	{		if (tfar < tmax) 		// inside, hitting back face		{			*tresult = tfar;		    return_val = RAY_HIT;			goto exit_routine;		} 		else 					// inside, but back face beyond tmax		{		    return_val = RAY_MISSED;			goto exit_routine;		}    }    exit_routine:	// unuse the arrays	polyConvex->polyhedron->posnPoints->Unuse();	points->Unuse();		return return_val;}/*--------------------------------------------------------------------------------*//*	This routine tests the ray with the surface and all of the surface features	in the surface.*/int	Surface::RayIntersect				(   Point3Ddouble	*org, 		// origin of velocity vector					Point3Ddouble	*dir, 		// normalized velocity vector					double tmax,				// length of velocity vector					double *tresult) 			// intersection pt along ray {Point4D pln;						/* plane equation */double tnear, tfar, t, vn, vd;short p0,p1,p2,count;short *index;Point3DFFixed *surfPt;int return_val;int length;	return_val = RayIntersectLowLevel(org, dir, tmax, tresult);		// if we hit the surface, then test against surface features and transparency	if (return_val == RAY_HIT)	{		if (surfDef == NULL) 		{			// no surface features, so check against surface transparency and texture			if (IS_TRANSPARENT(opacity))				return_val = RAY_MISSED;		}		else		{		int i;		int nConnections;		Connection *conn;		Point3D int_point;			// in order to change a ray_hit to ray_missed, we need to know that this			// surface and all connected surfaces are transparent.  Otherwise we still			// hit the surface					// no surface features, so check against surface transparency and texture			if (IS_TRANSPARENT(opacity))				return_val = RAY_MISSED;			else			{				// loop through all the connections too				if (surfDef->flatConnections[SIDE_INSIDE] != NULL)				{					conn = (Connection*)surfDef->flatConnections[SIDE_INSIDE]->Use();					nConnections = surfDef->flatConnections[SIDE_INSIDE]->ALength();					for ( i = 0 ; i < nConnections ; i++ )					{						if (IS_TRANSPARENT(conn[i].surf->surface->opacity))						{							if (conn[i].surf->surface->RayIntersectLowLevel(org, dir, tmax, tresult))							{ 								// we intersected a connected transparent surface, so we missed								return_val = RAY_MISSED;								break;							}						}					}					surfDef->flatConnections[SIDE_INSIDE]->Unuse();				}								// loop through all the connections too				if ((return_val == RAY_HIT) && (surfDef->flatConnections[SIDE_OUTSIDE] != NULL))				{					conn = (Connection*)surfDef->flatConnections[SIDE_OUTSIDE]->Use();					nConnections = surfDef->flatConnections[SIDE_OUTSIDE]->ALength();					for ( i = 0 ; i < nConnections ; i++ )					{						if (IS_TRANSPARENT(conn[i].surf->surface->opacity))						{							if (conn[i].surf->surface->RayIntersectLowLevel(org, dir, tmax, tresult))							{ 								// we intersected a connected transparent surface, so we missed								return_val = RAY_MISSED;								break;							}						}					}					surfDef->flatConnections[SIDE_OUTSIDE]->Unuse();				}								// we still think we hit the surface, so check surface features				if (return_val == RAY_HIT)				{				int rval;									// compute the intersection point itself (note that not necessary except for					// surface features					int_point.x = (int)org->x + (dir->x * (*tresult));					int_point.y = (int)org->y + (dir->y * (*tresult));					int_point.z = (int)org->z + (dir->z * (*tresult));						// check this surface first					RayIntersectFeats(&int_point, &rval);										// remember the return val sense is reversed, because if we hit the features					// we missed the actual surface						// check connected surfaces too					if (rval == RAY_HIT_FEAT)						return_val = RAY_MISSED;		// rval == RAY_HIT, so we missed the surface					else					{						// loop through all the connections too						if (surfDef->flatConnections[SIDE_INSIDE] != NULL)						{							conn = (Connection*)surfDef->flatConnections[SIDE_INSIDE]->Use();							nConnections = surfDef->flatConnections[SIDE_INSIDE]->ALength();							for ( i = 0 ; i < nConnections ; i++ )							{							int rval;															conn[i].surf->surface->RayIntersectFeats(&int_point, &rval);																// if we went through a transparent feature in a connected surface,								// then we missed								if (rval == RAY_HIT_FEAT) return_val = RAY_MISSED; break;							}							surfDef->flatConnections[SIDE_INSIDE]->Unuse();						}												// loop through all the connections too						if ((return_val == RAY_HIT) && (surfDef->flatConnections[SIDE_OUTSIDE] != NULL))						{							conn = (Connection*)surfDef->flatConnections[SIDE_OUTSIDE]->Use();							nConnections = surfDef->flatConnections[SIDE_OUTSIDE]->ALength();							for ( i = 0 ; i < nConnections ; i++ )							{							int rval;								conn[i].surf->surface->RayIntersectFeats(&int_point, &rval);									// if we went through a transparent feature in a connected surface,								// then we missed								if (rval == RAY_HIT_FEAT) return_val = RAY_MISSED; break;							}							surfDef->flatConnections[SIDE_OUTSIDE]->Unuse();						}					}				}					}		}	}		return return_val;}/*--------------------------------------------------------------------------------*//*	This routine intersects the ray with the PolyConvex's contents (the interior).*/int	PolyConvex::RayIntersectSurfaces				(   Point3Ddouble	*org, 		// origin of velocity vector					Point3Ddouble	*dir, 		// normalized velocity vector					double tmax,				// length of velocity vector					double *tresult)			// where along vel vect did we hit?{Surface **surf;int i;	surf = (Surface **)surfaces->Use();	for ( i = 0 ; i < surfaces->ALength() ; i++ )	{	int val;	double T;			val = surf[i]->RayIntersect(org, dir, tmax, tresult);				if (val == RAY_HIT)		{			return val;		}	}	surfaces->Unuse();	return RAY_MISSED;}/*------------------------------------------------------------------------------*//*	This routine calculates the origin, normalized vector, and length of the velocity	vector based on the old point and new point.  */voidCalcRay(Point3D oldPoint, Point3D newPoint, Point3Ddouble *org, Point3Ddouble *dir,	double *tmax){	// compute the origin of the ray (the old point)	org->x = (double)oldPoint.x;	org->y = (double)oldPoint.y;	org->z = (double)oldPoint.z;		// compute the vector of the ray (the new point minus the old point)	dir->x = (double)(newPoint.x - oldPoint.x);	dir->y = (double)(newPoint.y - oldPoint.y);	dir->z = (double)(newPoint.z - oldPoint.z);		// compute the ray length	(*tmax) = VectLengthPointDouble(dir);		// normalize the ray so our dot products will work	dir->x /= (*tmax);	dir->y /= (*tmax);	dir->z /= (*tmax);}#endif // COLLISION_DETECTION