/*------------------------------------------------------------------------------ * VWINDOWSð - the window object toolbox * Version 1.0 * * Copyright ð 1989 by Virtus Corporation * All Rights Reserved * Written by David A. Smith * 111 Gold Meadow Drive * Cary, North Carolina    27513 * (919) 469-8485 *------------------------------------------------------------------------------*///XYZZY this entire file is new.#include "VTypes.h"#include "VWindow.h"#include "VPane.h"#include "VGUtil.h"#include "VGraphic.h"#include "VWI.h"#include "VButton.h"#include "VDocumnt.h"#include "BallHelp.h"#include "VMEMUTIL.H" // DAS 10/9/93 add low memory check here for file loading.#include <stdio.h>#include <string.h>// DAS 10/9/93 % of freeMem where we change to warning color#define FREEMEM_WARN 10	#if VRextern RGBColor appBackColor;#if MACINTOSHVInfoWindow *VWI;int VWICount = 0;#endif#if VRint VWIflag = 1;#elif VWTint VWIflag = 0;#endifVInfoWindow*VWIInit(Rect *screenRect){if (!VWIflag)	return(NULL);   // do nothing if we're not doing the info win#if MACINTOSHif (!VWICount)	{	VWI=new(VInfoWindow);	VWI->cVInfoWindow(screenRect);	}VWICount++;#elif WINDOWSVInfoWindow	*VWI = new(VInfoWindow);VWI->cVInfoWindow(screenRect);#endif //MACINTOSHreturn(VWI);}void VWIEnd(VInfoWindow *vi){if ((!VWIflag) || !vi)	return;   // do nothing if we're not doing the info win#if MACINTOSHVWICount--;if (!VWICount)	{	VWI->dVInfoWindow();	VWI=NULL;	}#elif WINDOWSvi->dVInfoWindow();#endif //MACINTOSHvi = NULL;}// { DAS-VWI 8/25/93 these are left up to the reader.void VWIHide(void){if (!VWIflag)	return;   // do nothing if we're not doing the info win#if MACINTOSHif(VWICount)VWI->theWin->Hide();#elif WINDOWS	V_Document *doc;    VInfoWindow *info;	doc = GetCurrentDocument();	if (doc)		{		info = doc->GetInfoWin();        if (info)  info->theWin->Hide();        }#endif}void VWIShow(void){if (!VWIflag)	return;   // do nothing if we're not doing the info win#if MACINTOSH	if(VWICount)		{		VWI->theWin->Show();		VWI->theWin->Behind(NULL);		}#elif WINDOWS	V_Document *doc;    VInfoWindow *info;	doc = GetCurrentDocument();	if (doc)		{		info = doc->GetInfoWin();        if (info)  info->theWin->Show();        }#endif}int IsVWIOn(void){	int state= FALSE;#if MACINTOSH	if(VWIflag)	state = TRUE;#elif WINDOWS#if VWT	V_Document *doc;    VInfoWindow *info;	doc = GetCurrentDocument();	if (doc)		{		info = doc->GetInfoWin();      if (info)  state = info->vwiOn;		}#elif VR	if (VWIflag)	state = TRUE;	// jca 6 Nov 93.  For VR, we only have one doc at a time.#endif // VWT#endif //MACINTOSH    return(state);}// } DAS-VWI 8/25/93void VWIMessage(char *str){#if MACINTOSHif(VWI)	VWI->ShowMessage(str);#elif WINDOWS	V_Document *doc;    VInfoWindow *info;	doc = GetCurrentDocument();	if (doc)		{		info = doc->GetInfoWin();		if ((info && str))  info->ShowMessage(str);      }#endif}void VWIMemory(void){#if MACINTOSHif(VWI)	VWI->ShowMemory();#elif WINDOWS	V_Document *doc;    VInfoWindow *info;	doc = GetCurrentDocument();	if (doc)		{		info = doc->GetInfoWin();		if (info)  info->ShowMemory();      }#endif}#define NEWMESSAGE -12345/*------------------------------------------------------------------------------* *------------------------------------------------------------------------------*/void VInfoWindow::cVInfoWindow(Rect	*screenSize)	{	Point p;	Rect r;   vwiOn = TRUE;		// jca 6 Nov 93.  We should rethink this for MDI things	//GetScreen(&r);	r = *screenSize;	r.top=r.bottom-VWI_DEF_HEIGHT;		p.h=p.v=0;	theWin=new(V_Window);	theWin->cWindow(&r,"",p,p,p,BORDERLESS|ONTOP,WINDOW_DESTROY);#if WINDOWS	theWin->SetDocument(GetCurrentDocument());#endif	theWin->Show();	theWin->Deactivate();		thePane=new(VInfoPane);	thePane->cVInfoPane();	theWin->Install(thePane);	thePane->VDisplay(0);	ShowMessage("");	ShowMemory();	}	void VInfoWindow::dVInfoWindow(void)	{	theWin->dWindow();	delete(this);	}V_Window *VInfoWindow::GetWindow()	{	return(theWin);	}void VInfoWindow::ShowMessage(char *s)	{	thePane->SetMessage(s);	thePane->VDisplay(NEWMESSAGE);	}	void VInfoWindow::ShowMemory(void)	{	thePane->SetMemory();	thePane->VDisplay(NEWMESSAGE);	}/*------------------------------------------------------------------------------* *------------------------------------------------------------------------------*/void VInfoPane::cVInfoPane(void){cPane(0);str[0]=0; //set the length of the string to 0freeMem=100; // DAS 10/9/93 make sure this is NOT zero}void VInfoPane::SetMessage(char *s){int i=0;while(s[i]==str[i] && s[i] && str[i])i++;if(s[i]!=0 || str[i]!=0)	{	i=0;	changed=TRUE;	while(str[i]=s[i])i++;	}else changed=FALSE;}extern long availableMem; // DAS-VWI 10/2/93void VInfoPane::SetMemory(void){long fMem;fMem=FreeMem();// fMem=(fMem*100)/availableMem;      // oops, overflow if fMem>20MegfMem = fMem/((availableMem/100)+1);		// get percentage, avoid large (>20M) fMem overflows	//GJR 11/10/93    // jca 10 Nov 93 don't allow to be zeroif(fMem!=freeMem)	{	freeMem=fMem;	memChanged=TRUE;	}//if(fMem<3)lowMemory=memoryShort; // DAS-MEMORY 10/9/93 this allows the load to exit sooner.CheckMemory();						// Let memory manager decide warning level	// GJR 10/22/93}// jca.  yick.  Perhaps we will have time to tidy this....void VInfoPane::Display(int w,int x, int y){Rect r,r2,r3;int d,i;r=dataRect;#if WINDOWS         // jca 2 Oct 93 {r.left += 1;     // windows needs to be inset a little more.#endif	// WINDOWS	// jca 2 Oct 93 }r2=r;d=MainDepth();if(w!=NEWMESSAGE)	{	VInsetRect(&r2,3,3); // DAS-VWI-FIX 9/26/93 smaller size	r3=r2;	r2.right-=107;	r3.left=r2.right+3;	if(d<4)// DAS-BUGFIX 10/16/93 this should be gray at 4 bits		{		MonoButton(&r,FALSE);		VFrameRect(&r2);		VFrameRect(&r3);		}	else		{		TallColorButton(&r,offColor);		TallColorButton(&r2,onColor); // DAS-BILBIL - (too dark) onColor);		TallColorButton(&r3,onColor);		}	VClipRect(&r2); // DAS 10/9/93	DrawText(&r2);	r3.top+=2;	r3.bottom-=2;	r3.left+=2;	r3.right-=2;// { DAS 10/9/93	VClipRect(&r3);	VSetPenNormal();	VForeColor(&vBlack);	VFrameRect(&r3);	for(i=1;i<10;i++)		{		VMoveTo(r3.left+i*10,r3.top+2);		VLineTo(r3.left+i*10,r3.top);		}	VLineTo(r3.left+50,r3.top);	VLineTo(r3.left+50,r3.top+4);	r3.top=r3.bottom-4;// } DAS 10/9/93	DrawMem(&r3);	}else if(changed)	{#if MACINTOSH   	// jca 2Oct 93 {	VInsetRect(&r2,8,5);// DAS-VWI-FIX 9/26/93#elif WINDOWS	VInsetRect(&r2,3,4);// DAS-VWI-FIX 9/26/93	r2.right -= 1;#endif 	// MACINTOSH	// jca 2 Oct 93 }	r2.right-=VWI_MEM_WIDTH;	if(d<4)// DAS-BUGFIX 10/16/93 this should be gray at 4 bits		{		VBackColor(&vWhite);		VEraseRect(&r2);      	// jca 2 Oct 93		}	else		{		RGBColor color;		// DAS-VBUTTON 8/13/93 it wont be too dark color = appBackColor;#if MACINTOSH                 // jca 2 Oct 93  {		color=onColor[BaseColor];		VBackColor(&color);        VEraseRect(&r2);#elif WINDOWS		color=offColor[BaseColor];		VForeColor(&color);		VFillRect(&r2);#endif // MACINTOSH		// jca 2 Oct 93  }		}	DrawText(&r2);	}else if(memChanged)	{	VInsetRect(&r2,5,5);	r2.left=r2.right-100;	r2.top=r2.bottom-4; // DAS 10/9/93	DrawMem(&r2);	}else return;}void VInfoPane::DrawText(Rect *r)	{	Rect r2;		// VClipRect(&r2); // DAS 10/9/93 turn this off here	r2=*r;	changed=FALSE;	VForeColor(&vBlack);    // jca this should be offColor[ButtonTextColor]#if MACINTOSH	VMoveTo(8,12); 			// DAS-VWI-FIX 9/26/93       // jca 2 Oct 93	C2Pstr(str);	TextFont(1);TextSize(9); //10);	DrawString((unsigned char *)str);	P2Cstr(str);#elif WINDOWS    // DWE 30 Mar 94. Resize again.	r2.bottom += 4 - r2.top; // JAM 17 Nov 93.  Resize the rect properly.	r2.left = 8;	// jca 2 Oct 93	r2.top = 4;		// jca 2 Oct 93#if JAPANESE	r2.top+=2; r2.bottom+=2;#endif //JAPANESE	TextSetUp(vAppFont,vAppFontSize,vNormal);	VTextMode(vSrcXor);	VClipDrawText(str,0,strlen(str),&r2);	TextSetUp(vSystemFont,vSystemFontSize,vNormal);#endif	VSetPenNormal();	}// { DAS 10/9/93 adding meter tick spacevoid VInfoPane::DrawMem(Rect *r)	{	Rect r2;		if(depth<4)		{		VSetPattern(vPatWhite); // DAS-BUGFIX 10/16/93 this was reversed		r2=*r;		r2.left=r2.right-freeMem;		if(freeMem==100)r2.left++;//DAS-BUGFIX 10/16/93 don't overwrite the left bar		r2.right--; // DAS-BUGFIX 10/16/93 make room for the right edge		VPaintRect(&r2);		if(freeMem>FREEMEM_WARN)// DAS-BUGFIX 10/16/93 this was reversed			VSetPattern(vPatGray);		else VSetPattern(vPatBlack);		r2=*r;		r2.right-=freeMem;		r2.left++; // DAS-BUGFIX 10/16/93 don't overwrite the left bar		VPaintRect(&r2);		}	else		{		RGBColor vc;				VSetPattern(vPatBlack);		r2=*r;		r2.left=r2.right-freeMem;		if(freeMem==100)r2.left++;//DAS-BUGFIX 10/16/93 don't overwrite the left bar		r2.right--; // DAS 10/9/93 make room for the right edge#if MACINTOSH                 // { DAS 10/9/93		vc=onColor[BaseColor];		VBackColor(&vc);        VEraseRect(&r2);#elif WINDOWS		vc=offColor[BaseColor];		VForeColor(&vc);		VFillRect(&r2);#endif // MACINTOSH		// } DAS 10/9/93		if(freeMem>FREEMEM_WARN)			{			vc.blue=0xFFFF;			vc.green=vc.red=0;			}		else			{			vc.red=0xFFFF;			vc.green=vc.blue=0;			}		r2=*r;		r2.right-=freeMem;		r2.left++; // DAS-BUGFIX 10/16/93 don't overwrite the left bar		VForeColor(&vc);		VFillRect(&r2);		}	}// } DAS 10/9/93 adding meter tick spacevoidVInfoPane::TrackHelp(Point pt,long modifier) 	{	char str[255];	if(pt.h>dataRect.right-(VWI_MEM_WIDTH-1))		{		sprintf(str,TXTB_MEMBAR,FreeMem()>>10);		VWIMessage(str);		}	else VWIMessage(TXTB_HELPHELP);	}#endif // VR