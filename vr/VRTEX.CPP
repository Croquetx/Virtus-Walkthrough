#include "VTypes.h"#include "VRTex.h"#include "WalkBuff.h"#include "CVWCNTRL.h"#include "WLKCNTRL.h"#include "ToolDef.h"#include "CNTRL.h"#include "TEXTITEM.h"#include "TEXTARRY.h"#include <stdio.h>#include <string.h>#include "VGraphic.h"#include "VDebug.h"#include "VGUtil.h"#include "VError.h"#include "Misc.h"#include "VButton.h"		// jca 2 Oct 93#include "VFile.h"#include "TEXTITEM.h"#include "TEXTARRY.h"#include "AppText.h"		// jca 15 Oct 93#define ARROW_MARGIN 6		// pixel margin for scrolling menu arrow#define CHECK_MARGIN 15		// pixel margin for check mark of current texture#define DRAG_MARGIN 3#define CELL_HEIGHT 36#define VISIBLE_ROWS 12#define NO_ROW -1#define NO_TEXTURE_ROW 0#if MACINTOSH   // jca 5 Oct 93 {#define WINDOWS_RMARGIN 	0#define ENTRY_INSET			1#define TEXTUREMENU_CHECK	18	// jca 15 Oct 93#elif WINDOWS#define WINDOWS_RMARGIN 	10 	  // extra border for the windows(tm) window.#define ENTRY_INSET			2#define TEXTUREMENU_CHECK	18   	// jca 15 Oct 93#endif          // jca 5 Oct 93 }TextureArray *gInUseTextures = NULL;	//jam 6OCT94 initialize to NULL/*** struct VRTexture ***********************************************//*----------------------------------------------------------------------------------*//* 	VRTexture is a derived pane that allows the user to select textures from a	palette, or bring up a texture picker dialog box.  Call cVRTexture() when	the pane is first created, and then Pop() to bring up the pane.  Call dPane()	when destroying the parent object, after you are completely through with	the VRTexture.  These four routines are the only ones that the programmer	should need to call, in general. *//*----------------------------------------------------------------------------------*//* cPane() * This basically just initializes all of the internal variables.  Call this * just after allocating space for the object. */voidVRTexture::cPane(int flag)	{	int i;	Rect rr;				V_Pane::cPane(flag);				top_row = 0;		old_top_row = 0;				/* note: lRect inited in CalcSize */		/* note: visible_rows inited in CalcSize */				czone = TZoneNowhere;		crow = 0;		current_texture = NULL;		SetRect(&cr, -32767, -32767, -32767, -32767);		// MERGE-Z1	}/*----------------------------------------------------------------------------------*//* dPane() * This deletes the V_Array of recently used colors, and then deletes the * pane itself.  Call this when you're completely through with the pane. */voidVRTexture::dPane()	{		V_Pane::dPane();	}/*----------------------------------------------------------------------------------*//**/void VRTexture::SetController(struct Controller *ctrl)	{ 	controller = ctrl; 	}/*----------------------------------------------------------------------------------*//*	This routine returns a ptr to the texture array that this pop texture pane	is to display -- it is a field in the WalkController.  We walk up the list	of parent controllers until we find the walk controller.   */struct TextureArray *VRTexture::GetDocTextures()	{	struct TextureItem **ti;	extern TextureArray *gAllTextures;		// MERGE16	int i;			if (!gInUseTextures)		{			gInUseTextures = new(TextureArray);			gInUseTextures->cTextureArray();		}		gInUseTextures->SetLength(0);			ti = (TextureItem **)gAllTextures->Use();		// MERGE16		for ( i = 0 ; i < gAllTextures->ALength() ; i++ )		{			if (ti[i]->IsUsedInDocument())				gInUseTextures->Append(&ti[i]);		}		gAllTextures->Unuse();		return gInUseTextures;	}/*----------------------------------------------------------------------------------*//* 	This routine calculates the width of the texture picker.  It creates it's own	port so it can set the font etc. in whatever way it wants without screwing up	the window manager port.*/intVRTexture::CalcWidth()	{		return (47 + CHECK_MARGIN + 120 + WINDOWS_RMARGIN);		// ŠŠŠŠŠŠ  // jca 5 Oct 93	}/*----------------------------------------------------------------------------------*//* CalcSize() * This is called from V_Windows, to resize the pane.  The internal rectangles are * also initialized. */voidVRTexture::CalcSize(Rect *r, Point *p, int type, int warning)	{	extern TextureArray *gCurrentTextures;	Rect sr;	V_Offscreen *popScrn;	Point pt;					// MERGE34			if (p) pt = *p;			// MERGE34			// recalc cx in case textures added		cx = CalcWidth();			cy = CELL_HEIGHT;					popScrn = FindScreen(pt);		// MERGE34		popScrn->GetRect(&sr);			// MERGE34		visible_rows = (((sr.bottom - sr.top) - (2 * ARROW_MARGIN)) / CELL_HEIGHT) - 1;				/* no point in having more rows than textures */		if (visible_rows > GetDocTextures()->ALength()+2+gCurrentTextures->ALength()) 			visible_rows = GetDocTextures()->ALength()+2+gCurrentTextures->ALength();				// MERGE33 [[[		// reset top row so we won't be scrolled off into never-never land		if ((top_row + visible_rows) > GetDocTextures()->ALength()+2+gCurrentTextures->ALength())		{			top_row = 0;			old_top_row = 0;		}		// MERGE33 ]]]//jam 11/9/93 added vertical length on windows version#if MACINTOSH		SetRect(&lRect, 0, 0, cx, cy*visible_rows);#elif WINDOWS		SetRect(&lRect, 0, 0, cx, cy*visible_rows+4);#endif		OffsetRect(&lRect, 0, ARROW_MARGIN);				SetRect(r, lRect.left,				   lRect.top-ARROW_MARGIN,				   lRect.right,				   lRect.bottom+ARROW_MARGIN);				   		// theses rects affect how the arrows are drawn, so don't just change them		// randomly		// JAM 11/9/93 moved arrows 2 pixels toward the		// center vertically and 1 pixel left for Windows tm#if MACINTOSH		SetRect(&uparrowRect, r->right-11, r->top,							  r->right-1, r->top+ARROW_MARGIN);	// rect of up arrow		SetRect(&dnarrowRect, r->right-11, r->bottom-ARROW_MARGIN,							  r->right-1, r->bottom);		// rect of up arrow#elif WINDOWS		SetRect(&uparrowRect, r->right-12, r->top+2, 							  r->right-2, r->top+ARROW_MARGIN+2);	// rect of up arrow		SetRect(&dnarrowRect, r->right-12, r->bottom-ARROW_MARGIN-2, 							  r->right-2, r->bottom-2);		// rect of up arrow#endif		r->bottom++;	}/*----------------------------------------------------------------------------------*//* 	This routine draws the up arrow indicating there are more textures to scroll	to, or erases the arrow if there aren't.*/voidVRTexture::UpdateArrows(void)	{	int i;	RGBColor c;	extern TextureArray *gCurrentTextures;           // jca 27 Sept 93		// up arrow		if (top_row > 0)			// we can scroll, so draw arrow			VForeColor(&vBlack);		else		{			// we can't scroll, so erase arrow			if(depth>=4)c = offColor[BaseColor]; // jca 2 Oct 93 -buttoncolor			else c.red = c.green = c.blue = 0xFFFF;			VForeColor(&c);		}		for (i = 0 ; i < ARROW_MARGIN ; i++)		{			VMoveTo(uparrowRect.left+i-1,uparrowRect.bottom-i-2);			VLineTo(uparrowRect.right-i-1,uparrowRect.bottom-i-2);		}		// down arrow		if ((top_row + visible_rows) < GetDocTextures()->ALength()+1+gCurrentTextures->ALength())			// we can scroll, so draw arrow			VForeColor(&vBlack);		else		{			// we can't scroll, so erase arrow			if(depth>=4)c = offColor[BaseColor];  // jca 2 Oct 93 -buttoncolor			else c.red = c.green = c.blue = 0xFFFF;			VForeColor(&c);		}		for (i = 0 ; i < ARROW_MARGIN ; i++)		{			VMoveTo(dnarrowRect.left+i-1,dnarrowRect.top+i+1);			VLineTo(dnarrowRect.right-i-1,dnarrowRect.top+i+1);		}	}/*----------------------------------------------------------------------------------*//* DrawRow() */voidVRTexture::DrawRow(int row)	{	Rect rr; 	RGBColor c; 	char str[256]; 	struct TextureItem *t; 	extern V_Offscreen *popScrn;		VSetPenNormal();		Row2Rect(row, &rr);		if (row != GetDocTextures()->ALength()+1)			{			Rect temprect;    //jam 11/9/93 for drawing rect below			VInsetRect(&rr, ENTRY_INSET, ENTRY_INSET); 	// jca 5 Oct 93  -inset so we don't wipe the borders			if(depth>=4)c = offColor[BaseColor];  // jca 2 Oct 93 -buttoncolor			else c.red = c.green = c.blue = 0xFFFF;			VForeColor(&c);			temprect = rr;   	//jam 11/9/93 have to subtract 1 from            temprect.right--;   // right so borders aren't overwritten			VPaintRect(&temprect);		// need to do this to erase check mark			}		Row2TextureItem(row, &t);		if (t == current_texture)		{			Rect r2 = rr;   	// jca 15 Oct 93			VForeColor(&vBlack);			r2.bottom -= 14;			r2.top += 5;#if MACINTOSH			//jam 11/9/93 moved next line inside #if			r2.left += 1;	 //		TextFace(0);				/* !!! MAC !!! */    DELETE jca 15 Oct {	 //		TextFont(systemFont);		/* !!! MAC !!! */	 //		TextSize(12);				/* !!! MAC !!! */     DELETE }			VSetFont(vSystemFont, vSystemFontSize, vNormal);    // jca 5 Oct 93 }			VDrawChar(TEXTUREMENU_CHECK, &r2);    // try this char, Elvis.   jca 15 Oct 93#elif WINDOWS			VSetFont(vButtonFont, vButtonFontSize, vNormal);    // jca 5 Oct 93 {			VTextMode(vSrcXor);			VDrawChar(TEXTUREMENU_CHECK, &r2);    // try this char, Elvis.        	VTextMode(vSrcOr);			VSetFont(vSystemFont, vSystemFontSize, vNormal);    // jca 5 Oct 93 }#endif 	// MACINTOSH		}		if (row != GetDocTextures()->ALength()+1)			{			rr.left += (35 + CHECK_MARGIN);			rr.right -= WINDOWS_RMARGIN;        // jca 5 Oct 93			if(depth>=4)c = offColor[TopFrame];  // jca 2 Oct 93 -buttoncolor			else c.red = c.green = c.blue = 0xFFFF;			VForeColor(&c);			VPaintRect(&rr);			VForeColor(&vBlack);			VFrameRect(&rr);			}				VSetFont(vAppFont, vAppFontSize, vBold);		VForeColor(&vBlack);		VBackColor(&vWhite);		if (row == NO_TEXTURE_ROW)			{			Rect	lr = rr;						VMoveTo(rr.left + 6, rr.bottom - 14);			lr.left += 6;			lr.bottom -= 14;#if WINDOWS    	// jca 5 Oct 93 {			lr.top += 10;#endif         	// jca 5 OCt 93 }			VDrawText(TXTI_NOTEXTURE, 0, strlen(TXTI_NOTEXTURE), &lr);			}		else if (row == GetDocTextures()->ALength()+1)			{			// MERGE26 [[[			Rect rrr;			Rect temprect;	//jam 11/9/93 for drawing rect below			Row2Rect(row, &rrr);  			VInsetRect(&rrr, ENTRY_INSET, ENTRY_INSET); 	// jam 11/9/93  -inset so we don't wipe the borders			if(depth>=4)c = offColor[BaseColor];  // jca 2 Oct 93 -buttoncolor			else c.red = c.green = c.blue = 0xFFFF;			VForeColor(&c);			temprect = rrr;      //jam 11/9/93 keep rectangle from			temprect.right--;    //drawing over border			VPaintRect(&temprect);			VForeColor(&vBlack);			// MERGE26 ]]]			VMoveTo(rr.left+5, rr.bottom - 18);			VLineTo(rr.right-5, rr.bottom - 18);			}		else	/* a row with an actual texture */			{					char str[256];			Rect	lr = rr;			int desired_width;		// MERGE19			Row2TextureItem(row, &t);			t->GetName(str);			VMoveTo(rr.left + 6, rr.bottom - 14);			lr.left += 6;			lr.bottom -= 14;#if WINDOWS    	// jca 5 Oct 93 {			lr.top += 10;#endif         	// jca 5 OCt 93 }			desired_width = ((lr.right - lr.left) - 5);		// MERGE19			Ellipsis(str, desired_width);		// MERGE19			VDrawText(str, 0, strlen(str), &lr);			/* !!! */			}		VSetFont(vSystemFont, vSystemFontSize, vNormal);	}	/*----------------------------------------------------------------------------------*//* DrawRowTexture() */voidVRTexture::DrawRowTexture(int row)	{	Rect rr, r_from, r_to;	extern V_Offscreen *popScrn;	RGBColor c;	struct TextureItem *t; 		VForeColor(&vBlack);		VBackColor(&vWhite);		/* if row 0 (== no texture) */		if (row == NO_TEXTURE_ROW)			{			VSetPenNormal();			Row2Rect(row, &rr);			VSetRect(&r_to, rr.left + CHECK_MARGIN, rr.top+2, 							rr.left + 32 + CHECK_MARGIN, rr.top+2+32);			if(depth>=4)c = offColor[BaseColor]; // jca 2 Oct 93 -buttoncolor			else c.red = c.green = c.blue = 0xFFFF;			VForeColor(&c);			VPaintRect(&r_to);						}		else if (row == GetDocTextures()->ALength() +1)			{			}		else 			{			VSetPenNormal();			Row2Rect(row, &rr);			VSetRect(&r_to, rr.left + CHECK_MARGIN,					rr.top+2, 					rr.left + 32 + CHECK_MARGIN, 					rr.top+2+32);					Row2TextureItem(row, &t);			r_from = t->GetThumbnailRect();			// jca 18 Oct 93 			t->GetThumbnail()->MetaTo(popScrn, &r_from, &r_to); #if WINDOWS0        // jca 7 Oct 93    		if (popScrn)        	{         // this puts the color rect on the screen        		SetMetaPort();     // jca				MetaCopy(&r_to); // jca        		UnsetMetaPort(); // jca			}#endif            // jca 7 Oct 93		}	}/*----------------------------------------------------------------------------------*//* DrawContent() */voidVRTexture::DrawContent()	{	int row;		/* !!! two-loop stupid hack because MetaTo resets the port to the main screen,		so all the drawing other than the textures is in bozo-land */				for ( row = top_row ; row < top_row + visible_rows ; row++ )		{			DrawRow(row);		}				UpdateArrows();					for ( row = top_row ; row < top_row + visible_rows ; row++ )		{			DrawRowTexture(row);		}	}/*----------------------------------------------------------------------------------*//* Display() * This is called from PopUp() to display the pane. */voidVRTexture::Display(int type,int h,int v)	{	int dv, cells_scrolled;	#if WINDOWS  		// jca 5 Oct 93	Rect 	pR;	pR = dataRect;	int offscr = TRUE;if(offscr)    SetMetaPort(); 	pR.left++; pR.top++;    // jca this isn't a button! 	pR.right--;          // these are done in the mac V_Pane::PopUp routine	pR.bottom--;	if(depth>2&&colorButton)        TallColorButton(&pR,offColor);    else         {        pR.right--;        pR.bottom--;        MonoButton(&pR,0);        VMoveTo(pR.left,pR.bottom);        VLineTo(pR.right,pR.bottom);        VLineTo(pR.right,pR.top);        pR.right++;        pR.bottom++;        }	VSetPenNormal();#endif                // jca 5 Oct 93		switch(type)		{			case SCROLL_DRAW:#if WINDOWS				UpdateArrows();				DrawContent();				break;#endif 				/* neg cells_scrolled means draw on bottom, pos means draw on top */				cells_scrolled = old_top_row - top_row;								dv = (old_top_row - top_row) * CELL_HEIGHT;#if MACINTOSH        // jca 27 Sept 93   {				ScrollRect(&lRect, 0, dv, NULL);					/* !!! */#elif WINDOWS				ScrollDC(GetGraphicContext(), 0, dv, &lRect, NULL, NULL, NULL);#endif // MACINTOSH// jca 27 Sept 93       }				if (cells_scrolled < 0) 	// scrolled up, draw bottom row				{					DrawRow(top_row + visible_rows - 1);					UpdateArrows();					DrawRowTexture(top_row + visible_rows - 1);				}				else if (cells_scrolled > 0) 	// scrolled down, draw top row				{					DrawRow(top_row);					UpdateArrows();					DrawRowTexture(top_row);				}				break;							default:				DrawContent();				break;		}#if WINDOWSif(offscr)	{	//jam 11/9/93 add frame	Rect temprect = pR;	temprect.bottom++;	temprect.top--;	temprect.right++;	temprect.left--;	VForeColor(&vBlack);	VFrameRect(&temprect);	MetaCopy(&temprect);    UnsetMetaPort();	}#endif	}/*----------------------------------------------------------------------------------*//* Pop() * This is the main callable routine.  Pass the point where the user clicked * (in local coordinates) and the texture to be edited.  The return value * indicated whether or not a new texture was selected.  If a new texture was * selected then the texture ptr t passed in will be set to point to the new  * default texture. */intVRTexture::Pop(Point pt, struct TextureItem **t, Rect *avoidRect)	{	int sel;	#if MACINTOSH             	// jca 5 Oct 93 {		LocalToGlobal(&pt);#endif	                    // jca 5 Oct 93 }		PopUp(pt, TRUE, avoidRect);		if (sel = Done())		{			*t = current_texture;		}		return(sel);	}/*----------------------------------------------------------------------------------*//* Row2TextureItem() * This returns the texture associated with a particular location in the * palette grid, or NULL if the texture associated with the location is "no texture" */voidVRTexture::Row2TextureItem(int row, struct TextureItem **t)	{	extern TextureArray *gCurrentTextures;		if (row == NO_TEXTURE_ROW) 		{			/* if the row is 0 (no texture) then there is no texture */			*t = NULL;		}	else if (row <= GetDocTextures()->ALength())		{		TextureItem *ti;				/* row-1 because row 0 is the "no texture" row and so there is one more			   row than the number of textures. */		GetDocTextures()->Get(row-1, &ti);		if (t) { *t = ti; }		}		else		{		TextureItem *ti;					gCurrentTextures->Get((row - GetDocTextures()->ALength()) - 2, &ti);			if (t) { *t = ti; }		}	}/*----------------------------------------------------------------------------------*//* Row2Rect() */voidVRTexture::Row2Rect(int row, Rect *r)	{	int y;			SetRect(r,0,0,cx,cy);#if MACINTOSH		y = row*cy + lRect.top - (top_row * cy);#elif WINDOWS		y = row*cy + lRect.top - (top_row * cy) + 2;#endif		OffsetRect(r, lRect.left, y);	}/*----------------------------------------------------------------------------------*//* SetCR() * stands for "Set Current Rectangle".  Updates cr to the given rectangle, * un-hiliting the old rectangle and hiliting the new one. */voidVRTexture::SetCR(int row)	{	RGBColor c;	Rect r;	Rect temprect;	//jam 11/9/93 for making a 1 pixel bigger frame			if (row == NO_ROW)		{			SetRect(&r, -32767, -32767,-32767,-32767);	// MERGE-BUG		}		else		{			Row2Rect(row, &r);			r.left += (35 + CHECK_MARGIN);			r.right -= WINDOWS_RMARGIN;		// jca 5 Oct 93//#if WINDOWS    	// jca 5 Oct 93 {			VInsetRect(&r, ENTRY_INSET, ENTRY_INSET);	// MERGE-BUG//#endif         	// jca 5 OCt 93 }		}		/* if it's the same as old current rect, do nothing */		if (EqualRect(&r, &cr)) return;		/* unhilite old rect */		if(depth>=4)c = offColor[BaseColor];  // jca 2 Oct 93 -buttoncolor		else c.red = c.green = c.blue = 0xFFFF;			VForeColor(&c);		/* JAM 11/9/93 the hilite frame needs to be a pixel bigger		   than the text frame, so it won't erase the		   text fram*/		temprect = cr;		temprect.top--;		temprect.bottom++;		temprect.left--;        temprect.right++;		VFrameRect(&temprect);				/* save the new rect */		cr = r;			/* hilite new rect */		VForeColor(&vBlack);		/* JAM 11/9/93 the hilite frame needs to be a pixel bigger		   than the text frame, so it won't go on top of the		   text fram*/		temprect = cr;		temprect.top--;		temprect.bottom++;		temprect.left--;        temprect.right++;		VFrameRect(&temprect);	}/*----------------------------------------------------------------------------------*//* Track() * This is called from PopUp() repeatedly, as long as the user holds down the * mouse button.  It handles hiliting the appropriate rectangle and showing the * current color, by calling SetCR() and Paint().  pt is in local coords. */voidVRTexture::Track(Point pt, long modifier, int inside)	{	Rect r;	int row;	RGBColor tmp;	extern TextureArray *gCurrentTextures;	int result;		if (VPtInRect(pt,&lRect))		{			row = ((pt.v - lRect.top) / cy) + top_row;			if (row == GetDocTextures()->ALength()+1)			{				SetCR(NO_ROW);				czone = TZoneNowhere;				crow = 0;			}#if MACINTOSH   			else			{				SetCR(row);				czone = TZoneList;				crow = row;			}#elif WINDOWS			/* the windows texture popup has more space at the bottom of the list			than the mac one does, so it is possible for the windows one to select			textures off the end of the list (and return a texture out in, as Drew			would say, bozo-land).  So we should check that we aren't going off the			end of the list.  jca 12 Dec 93            */			else if (row <= ( GetDocTextures()->ALength()+1+gCurrentTextures->ALength() ))			{				SetCR(row);				czone = TZoneList;				crow = row;			}			else  // bozo-land.			{				SetCR(NO_ROW);				czone = TZoneNowhere;				crow = 0;			}#endif			return;		}		else if ( (pt.v-DRAG_MARGIN > lRect.bottom) && 		          (pt.h > lRect.left) && 		          (pt.h < lRect.right) && 		          ((top_row + visible_rows) < (GetDocTextures()->ALength() + 2 + gCurrentTextures->ALength()) )	)		{			/* mouse is below pane and there is more down there, so scroll data up */			old_top_row = top_row;			top_row++;		/* top row is one more than before */						/* !!! if we can't scroll the data up any more, that is if 			   top_row + visible_rows is now >= than the number of rows,			   then we need to hide the little down-pointing arrow signifying that			   we can scroll more */			   			SetCR(NO_ROW);			czone = TZoneNowhere;			crow = 0;			Display(SCROLL_DRAW, 0, 0);			return;		}		else if ( (pt.v+DRAG_MARGIN < lRect.top) && 				  (pt.h > lRect.left) && 		          (pt.h < lRect.right) &&                   (top_row > 0) )			{			/* mouse is above pane and there is more up there, so scroll data down */			old_top_row = top_row;			top_row--;		/* top row is one less than before */			/* !!! if we can't scroll the data down any more, that is if 			   top_row is now equal to 0,			   then we need to hide the little up-pointing arrow signifying that			   we can scroll more */						SetCR(NO_ROW);			czone = TZoneNowhere;			crow = 0;			Display(SCROLL_DRAW, 0, 0);			return;		}		else	/* user not in appropriate area, or can't scroll any more */		{			SetCR(NO_ROW);			czone = TZoneNowhere;			crow = 0;		}	}/*----------------------------------------------------------------------------------*//* */intVRTexture::Done(void)	{		switch (czone)		{		struct TextureItem *t;					case TZoneNowhere:				return(FALSE);			case TZoneList:				Row2TextureItem(crow, &t);				current_texture = t;				break;		}			return(TRUE);	}/*----------------------------------------------------------------------------------*//**/struct TextureItem *VRTexture::GetCurrentTextureItem(void)	{		return current_texture;	}