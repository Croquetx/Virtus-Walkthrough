#include "VTypes.h"#if VR#include "VFile.h"#include "VError.h"#include "VRLibs.h"#include "AppFiles.h"#include "AppText.h"#include "VDialog.h"#include "VDebug.h"#include "VMain.h"#include "Textarry.h"#include "textsrvr.h"#include "VGUtil.h"#if WINDOWS#include <dir.h>#include <dos.h>// WARNING!!!!  icky DOS things ahead.#elif MACINTOSHstatic HFileInfo gHFI,gHFI2;static DirInfo gCPB,gCPB2;static char gName[63],gName2[63];#define IS_FOLDER(x) ((x) & (1<<4))#endif //WINDOWSint gLoadingTextureFolderTextures = FALSE;	// MERGE20int gLoadingCustomPicts = FALSE;	// MERGE25V_Array *gGalleries2D = NULL;V_Array *gGalleries3D = NULL;V_Array *gTextures = NULL;/* this routine finds all the files of a particular type in a   given directory(directoryName) and returns a V_Array of   V_Files (fileArray), with each V_File corresponding to one   of the files.  The defaultFile is the name of the default   file, for those cases where a particular file should   head the list.  Return a count of the objects found.*/intFindAllFilesInDir(V_Array *fileArray, char *directoryName,	char *defaultFile, ULong fileType){int i;int err = noErr;char str[256], str2[256];#if MACINTOSH// no code yet.  Mac me, Drew!!!#elif WINDOWSchar searchStr[256], winFileType[4], *ft;struct ffblk	ickyDosBlk;       // icky DOS thingVfsLocation *vfsLocation;	ft = (char*) &fileType;	winFileType[0] = ft[3];	winFileType[1] = ft[2];	winFileType[2] = ft[1];	winFileType[3] = ft[0];	if (!fileArray)	{		// ELVIS		// Do the Error handling thing, baby.  One, two, three.. kick!		return(-1);    }	// find the gallery dir.  Error if it isn't there.    // icky DOS thing  {	memset(&ickyDosBlk, 0, sizeof(struct ffblk));	err = findfirst(directoryName, &ickyDosBlk, FA_DIREC);    if (err)	{		// ELVIS  (error processing)	}	// icky DOS thing  {	sprintf(searchStr, "%s\\*.%s", directoryName, winFileType);	// find the first file in the directory	err = findfirst(searchStr, &ickyDosBlk, NULL);  // icky DOS call	while (err == noErr)	{	V_File *vf;    char  anFName[64];						strcpy(str, &(ickyDosBlk.ff_name[0]));		strcpy(str2, str);					// strip the file ext		i = strlen(str2)-1;		while(i > 0 && str2[i] != '.')			str2[i--] = 0x0;		if (i > 0) str2[i] = 0x0;		else strcpy(str2, str);		vf = new(V_File);		vf->cFile(REFERENCE, 0L, 0L, "", "");		vf->SetName(str2);   	// this will validate the name//		vf->SetLocation(directoryName, str2, winFileType);		vfsLocation = new(VfsLocation);        vfsLocation->cVfsLocation();		strcpy(vfsLocation->path, directoryName);		strcpy(vfsLocation->name, str2);		strcpy(vfsLocation->extension, winFileType);		vf->VSetLocation(vfsLocation);        vfsLocation->dVfsLocation();		err = vf->Find();							if (defaultFile)   // if there is a default name, stuff it in first		{			if (!strcmp(str2, defaultFile))			{				fileArray->Insert(0, &vf); 	// make basic shapes first entry always			}			else			{				fileArray->Append(&vf);			}        }							if (!err)   // get next file name		{  // icky DOS call            err = findnext(&ickyDosBlk);        }	}	// } end icky DOS thing	return(VA_Length(fileArray));#endif // MACINTOSH}/*----------------------------------------------------------------------------------------------*//*	This routine makes a V_Array of V_Files by loading all the files in the folder	with the name string contained in gallery_str.   All files of file_type are	loaded.  The "Basic Shapes" (default) library is guaranteed to be the first 	element of the array.*/voidInitLib(V_Array *gallery_array, char *gallery_str, 	char *basic_str, unsigned long file_type){V_File *theApp;int index, i;int err = noErr;char str[256], str2[256];#if MACINTOSH/* and by the way... where're the error cases for if we can't open thegalleries on the mac?  How about a dialog box and a warning?  jca 7 sept 93*/// Changes ABOUND							//GJR 10/06/93VfsLocation *fSpec;//AliasHandle als;	if (!gallery_array) return;	theApp = new(V_File);	theApp->cFile(REFERENCE,MakeID('?','?','?','?'),MakeID('?','?','?','?'), "", "");	theApp->FindApplication();	fSpec = new(VfsLocation);    fSpec->cVfsLocation();	theApp->VGetLocation(fSpec);	for (i=0;i<64;i++) 		gName[i]=gallery_str[i];	gCPB.ioNamePtr = (StringPtr)gName;	gCPB.ioVRefNum = fSpec->volume;	gCPB.ioDrDirID = fSpec->directory;	gCPB.ioFDirIndex = 0;	err = PBGetCatInfo((CInfoPBPtr)&gCPB, FALSE);		gHFI.ioNamePtr = (StringPtr)gName;	gHFI.ioVRefNum = fSpec->volume;	index = 1;	while (err == noErr)	{		gHFI.ioFDirIndex = index;		gHFI.ioDirID = gCPB.ioDrDirID;		// reset dirID		err = PBGetCatInfo((CInfoPBPtr)&gHFI, FALSE);		if (err == noErr)		{			if (!IS_FOLDER(gHFI.ioFlAttrib))			{				if (gHFI.ioFlFndrInfo.fdType == file_type)				{					V_File *vf;				int err;									for (i=0;i<64;i++) str[i]=gHFI.ioNamePtr[i];								//P2Cstr(str);					//sprintf(str2, "Registering р%sси", str);					//C2Pstr(str);					// file info is (gHFI.ioNamePtr, gCPB.ioDrDirID, fSpec->vRefNum)										for (i=0;i<64;i++) fSpec->name[i]=gHFI.ioNamePtr[i];			//GJR 10/06/93					P2Cstr(fSpec->name);					fSpec->directory = gCPB.ioDrDirID;					// volume left alone					fSpec->alias = 0;										vf = new(V_File);					vf->cFile(REFERENCE,MakeID('?','?','?','?'),MakeID('?','?','?','?'), "", "");					vf->VSetLocation(fSpec);					err = vf->Find();										if ((str[0] == basic_str[0]) && 						(memcmp(str, basic_str, str[0]) == 0))					{						gallery_array->Insert(0, &vf); 	// make basic shapes first entry always					}					else					{						gallery_array->Append(&vf);					}										if (err) Debugger();				}			}		}		index++;	}    fSpec->dVfsLocation();#elif WINDOWSchar galleryDirName[256], galleryFileName[256], fileType[4], *ft;int  nameLen;struct ffblk	ickyDosBlk;       // icky DOS thing	nameLen = GetModuleFileName(GetAppInstance(), galleryDirName, 256);	if (!nameLen)		{        // ELVIS  (error processing)		}	/* remove the app file name */	while((nameLen>0)&&(galleryDirName[nameLen] != '\\'))		galleryDirName[nameLen--] = 0x0;	// append the gallery name	strcat(galleryDirName, gallery_str);	// find the gallery dir.  Error if it isn't there.    // icky DOS thing  {	memset(&ickyDosBlk, 0, sizeof(struct ffblk));	err = findfirst(galleryDirName, &ickyDosBlk, FA_DIREC);    if (err)		{		// ELVIS  (error processing)		}	else		FindAllFilesInDir(gallery_array, galleryDirName, basic_str, file_type);#endif  // WINDOWS}voidInitTextureCustomPicts(TextureArray *);/*----------------------------------------------------------------------------------------------*/voidInitTextureCustomPicts(TextureArray *ta){V_File *theApp;int index, i;int err = noErr;char str[256], str2[256];VfsLocation *fSpec;					//Use VfsLocation				//GJR 10/06/93TextureItem *ti;#if MACINTOSH/* and by the way... where're the error cases for if we can't open thegalleries on the mac?  How about a dialog box and a warning?  jca 7 sept 93*///AliasHandle als;char gallery_str[64] = TEXTURES_DIR;extern int gQuickTime;	if (!ta) return;	theApp = new(V_File);	theApp->cFile(REFERENCE,MakeID('?','?','?','?'),MakeID('?','?','?','?'), "", "");	theApp->FindApplication();	fSpec=new(VfsLocation);    fSpec->cVfsLocation();	theApp->VGetLocation(fSpec);	for (i=0;i<64;i++) 		gName[i]=gallery_str[i];	gCPB.ioNamePtr = (StringPtr)gName;	gCPB.ioVRefNum = fSpec->volume;	gCPB.ioDrDirID = fSpec->directory;	gCPB.ioFDirIndex = 0;	err = PBGetCatInfo((CInfoPBPtr)&gCPB, FALSE);		gHFI.ioNamePtr = (StringPtr)gName;	gHFI.ioVRefNum = fSpec->volume;	index = 1;	while (err == noErr)	{		gHFI.ioFDirIndex = index;		gHFI.ioDirID = gCPB.ioDrDirID;		// reset dirID		err = PBGetCatInfo((CInfoPBPtr)&gHFI, FALSE);		if (err == noErr)		{			if (!IS_FOLDER(gHFI.ioFlAttrib))			{				for (i=0;i<64;i++) str[i]=gHFI.ioNamePtr[i];							P2Cstr(str);				for (i=0;i<64;i++) fSpec->name[i]=gHFI.ioNamePtr[i];				//GJR 10/06/93				P2Cstr(fSpec->name);				fSpec->directory = gCPB.ioDrDirID;				// volume left alone				fSpec->alias = 0;				if (gHFI.ioFlFndrInfo.fdType == appFileTypePICT)				{	sprintf(str2, TXTM_ADDPICT, str);					MeterSetText(str2);					ta->GetTextureItem(str, fSpec, &ti);		// MERGE25	//GJR 10/06/93					ti->settings.shade = FALSE;		// MERGE25 - never shade custom picts				}else if ((gQuickTime) && (gHFI.ioFlFndrInfo.fdType == appFileTypeQuickTime))				{	sprintf(str2, TXTM_ADDQT, str);					MeterSetText(str2);					ta->GetTextureItem(str, fSpec, &ti);		//GJR 10/06/93					ti->settings.shade = FALSE;		// MERGE25 - never shade custom picts				}			}		}		index++;	}    fSpec->dVfsLocation();#elif WINDOWS// BILBIL - custom .bmp's - 11/30/93 {{{char galleryDirName[256], galleryFileName[256], fileType[4], *ft;int  nameLen;struct ffblk	ickyDosBlk;       // icky DOS thingV_Array *		gallery_array;V_File**		files;	if (!ta) return;	gallery_array = new(V_Array);	gallery_array->cArray(0,sizeof(V_File*),4);	nameLen = GetModuleFileName(GetAppInstance(), galleryDirName, 256);	if (!nameLen)		{        // ELVIS  (error processing)		}	/* remove the app file name */	while((nameLen>0)&&(galleryDirName[nameLen] != '\\'))		galleryDirName[nameLen--] = 0x0;	// append the gallery name	strcat(galleryDirName, TEXTURES_DIR);	// find the gallery dir.  Error if it isn't there.    // icky DOS thing  {	memset(&ickyDosBlk, 0, sizeof(struct ffblk));	err = findfirst(galleryDirName, &ickyDosBlk, FA_DIREC);    if (err)		{		// ELVIS  (error processing)		}	else    	{		FindAllFilesInDir(gallery_array, galleryDirName, "", appFileTypeBMP);		FindAllFilesInDir(gallery_array, galleryDirName, "", appFileTypeDIB);		}	files = (V_File**)gallery_array->Use();	fSpec=new(VfsLocation);    fSpec->cVfsLocation();	for(i = 0; i < gallery_array->ALength(); i++)    	{		files[i]->GetFName(str);		sprintf(str2, TXTM_ADDFILE, str);		MeterSetText(str2);		if (noErr == files[i]->VGetLocation(fSpec))			{			// ABD added check for ti == NULL, which means an error happened 12/9/93			ta->GetTextureItem(str, fSpec, &ti);		// MERGE25	//GJR 10/06/93         if (ti != NULL)				ti->settings.shade = FALSE;		// MERGE25 - never shade custom picts			}		 files[i]->dFile();	// jam 6OCT94 jca 16AUG94 VR1.0.1 delete the temp vfiles		}	fSpec->dVfsLocation();	gallery_array->Unuse();	gallery_array->dArray();// BILBIL - custom .bmp's - 11/30/93 }}}#endif  // WINDOWS}/*----------------------------------------------------------------------------------------------*//*	This routine sets up a global V_Array's of V_Files -- one for 3D shapes, one	for 2D shapes, and one for textures.  We then call a routine to load the 	files in those folders.*/voidVRLibsInit(){V_File *theApp;int index, i;int err = noErr;char str[256], str2[256];char gallery_2d_str[64] = GALLERY2D_DIR;char gallery_3d_str[64] = GALLERY3D_DIR;char textures_str[64] = TEXTURES_DIR;char basic_shapes_str[64] = BASIC_SHAPES_LIB;char basic_textures_str[64] = BASIC_TEXTURES_LIB;extern V_Array *gTextureArrays;extern TextureArray *gCurrentTextures;extern TextureArray *gAllTextures;extern TextureServer *gTextureServer;extern TextureArray *gAllDocTextures;V_File **fl;TextureArray *ta;TextureArray **taa;extern TextureArray *gCustomPicts;		// MERGE24	if (gGalleries2D) return;	if (gGalleries3D) return;	if (gTextures) return;	#if (!VPLAYER)	gGalleries2D = new(V_Array);	gGalleries2D->cArray(0, sizeof(struct V_File *), 8);	gGalleries3D = new(V_Array);	gGalleries3D->cArray(0, sizeof(struct V_File *), 8);#endif //!VPLAYER	gTextures = new(V_Array);	gTextures->cArray(0, sizeof(struct V_File *), 8);	gAllTextures = new(TextureArray);		// MERGE16	gAllTextures->cTextureArray();	gAllDocTextures = new(TextureArray);	// MERGE20	gAllDocTextures->cTextureArray();		// MERGE20	#if (!VPLAYER)	InitLib(gGalleries2D, gallery_2d_str, basic_shapes_str, appFileTypeLibrary);	InitLib(gGalleries3D, gallery_3d_str, basic_shapes_str, appFileTypeLibrary);	InitLib(gTextures, textures_str, basic_textures_str, appFileTypeVRTextureLib);	// MERGE16	gLoadingTextureFolderTextures = TRUE;	// MERGE20	gTextureArrays = new(V_Array);	gTextureArrays->cArray(0, sizeof(TextureArray *), 8);	fl = (V_File**)gTextures->Use();	for ( i = 0 ; i < gTextures->ALength() ; i++ )	{			ta = new(TextureArray);		ta->cTextureArray();		fl[i]->Open(FALSE);		gTextureServer->BeginTextureIOLib(fl[i], ta);		// MERGE24		gTextureServer->IOTextureLibrary(fl[i]);		gTextureServer->EndTextureIOLib(fl[i]);		// MERGE24		fl[i]->Close();		gTextureArrays->Append(&ta);	}	gTextures->Unuse();		// custom picts/.BMPs - BG 11/20/93	ta = new(TextureArray);	ta->cTextureArray();	gLoadingCustomPicts = TRUE;	// MERGE25	InitTextureCustomPicts(ta);	gLoadingCustomPicts = FALSE;	// MERGE25	gTextureArrays->Append(&ta);	gLoadingTextureFolderTextures = FALSE;	// MERGE20	gCustomPicts = ta;		// MERGE24	taa = (TextureArray**)gTextureArrays->Use();	for ( i = 0 ; i < gTextureArrays->ALength() ; i++ )	{		TextureItem **ti;	int j;			ti = (TextureItem**)taa[i]->Use();		for ( j = 0 ; j < taa[i]->ALength() ; j++ )		{				gAllTextures->Append(&ti[j]);		}		taa[i]->Unuse();	}	gTextureArrays->Unuse();#endif //!VPLAYER}// MERGE-CLEANUP [[[ voidVRLibsDelete(){V_File **gg;int i;TextureItem **ti;TextureArray **ta;extern V_Array *gTextureArrays;extern TextureArray *gAllTextures;extern TextureArray *gAllDocTextures;#if (!VPLAYER)	gg = (V_File **)gGalleries2D->Use();	for ( i = 0 ; i < gGalleries2D->ALength() ; i++ )		gg[i]->dFile();	gGalleries2D->Unuse();	gGalleries2D->dArray();		gg = (V_File **)gGalleries3D->Use();	for ( i = 0 ; i < gGalleries3D->ALength() ; i++ )		gg[i]->dFile();	gGalleries3D->Unuse();	gGalleries3D->dArray();#endif // (!VPLAYER)	// jca 21APR94 delete the texture file refs	gg = (V_File **)gTextures->Use();	for ( i = 0 ; i < gTextures->ALength() ; i++ )		gg[i]->dFile();	gTextures->Unuse();	gTextures->dArray();/*	ti = (TextureItem **)gAllTextures->Use();	for ( i = 0 ; i < gAllTextures->ALength() ; i++ )		ti[i]->dTextureItem();	gAllTextures->Unuse();    */	gAllTextures->dTextureItemsInTextureArray();  // jca better way to do it?	gAllTextures->dArray();	gAllDocTextures->dArray();   // a subset of gAllTextures; they're already gone.#if (!VPLAYER)	ta = (TextureArray **)gTextureArrays->Use();	for ( i = 0 ; i < gTextureArrays->ALength() ; i++ )		ta[i]->dTextureArray();	gTextureArrays->Unuse();	gTextureArrays->dArray();#endif // (!VPLAYER)}// MERGE-CLEANUP ]]]#endif //VR