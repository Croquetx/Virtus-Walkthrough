/*------------------------------------------------------------------------------ * Copyright _ 1996 by Virtus Corporation * All Rights Reserved * Written by  David A. Smith * Virtus Corporation * 118 MacKenan Drive, Suite 250 * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File: Shard.CPP * 	A hole is cut into a surface in the following way: *  1. Clip the hole to the surface. After this, we have two convex polygons, one *     inside the other. *  2. Create a non-convex polygon by finding an edge between the two polygons that *     acts as a starting point. The top point of each is sufficient. Connecting these *     two points creates a non-convex polygon. *  3. Cut the non-convex polygon into a set of convex pieces. This is done by creating the *     largest convex polygons by incrementing each point along the edges until it is no  *     convex. *  4. Repeat for the next hole, now applying it to each of the new convex surfaces. *  Created DAS 96.02.22 based upon ExpShard.cpp. *------------------------------------------------------------------------------ */#include "Shard.h"#include "math.h"void DrawSurface(V_Array *surf, RGBColor *col,int dimension);void KillWindow(void);void MakeWindow(void);typedef struct {	double x;	double y;	double z;	}P3D;//#define TINY_NUMBER 0.0000000000001#define TINY_NUMBER 0.00000001#define DXP  1#define DXN -1#define DYP  2#define DYN -2#define DZP  3#define DZN -3#define COUNTERCLOCKWISE	0#define CLOCKWISE			1#define LINEAR				2#define UNKNOWN				3V_Array* Intersect(int sDimension, V_Array *s1, V_Array *s2);void RemoveSame(V_Array *poly);void Slice(int sDimension, V_Array* poly,P3D p0,P3D p1);double CrissCross3D(int sDimension, P3D p1, P3D p2, P3D q1, P3D q2);int CheckSide(int sDimension, P3D p0, P3D p1, P3D p2);V_Array * Shard(int sDimension, V_Array *outside, V_Array *inside);int CheckWidth(int sDimension, V_Array* surface);inline P3D NormNormalize(P3D p3d)	{	double d;	d=sqrt(p3d.x*p3d.x+p3d.y*p3d.y+p3d.z*p3d.z);	p3d.x/=d;	p3d.y/=d;	p3d.z/=d;	return p3d;	}	#if THINK_Cdouble dabs(double d);double dabs(double d){ return d<0?-d:d;}double dmax(double d1, double d2);double dmax(double d1, double d2){return d1<d2?d2:d1;}int next(int cval, int lval);int next(int cval, int lval){cval++; if(cval==lval)cval=0; return cval;}int previous(int cval, int lval);int previous(int cval, int lval){cval--;if(cval==-1)cval=lval-1; return cval;}#elseinline double dabs(double d){ return d<0?-d:d;}inline double dmax(double d1, double d2){return d1<d2?d2:d1;}	inline int next(int cval, int lval){cval++; if(cval==lval)cval=0; return cval;}inline int previous(int cval, int lval){cval--;if(cval==-1)cval=lval-1; return cval;}#endif// This creates a V_Array of convex polyhedra which is equivalent to aPoly-bPoly.// Returns NULL if bPoly >= aPoly.// Returns a V_Array with a single copy of the aPoly V_Array if aPoly-bPoly is NULLV_Array *SubPoly(Point3DFFixed normal, V_Array *aPoly, V_Array *bPoly)	{	P3D surfNormal;	double ax, ay, az;	int sDimension;	V_Array *sClip;	V_Array *convexClip;		surfNormal.x = FixedToDbl(normal.x);	surfNormal.y = FixedToDbl(normal.y);	surfNormal.z = FixedToDbl(normal.z);	surfNormal=NormNormalize(surfNormal);	ax=dabs(surfNormal.x);			ay=dabs(surfNormal.y);			az=dabs(surfNormal.z);			if(ax>ay && ax>az)		{if(surfNormal.x>0)sDimension=DXP; else sDimension=DXN;}	else if(ay>ax && ay>az)		{if(surfNormal.y>0)sDimension=DYP; else sDimension=DYN;}	else if(az>ax && az>ay)		{if(surfNormal.z>0)sDimension=DZP; else sDimension=DZN;}	if(sClip=Intersect(sDimension, aPoly, bPoly)) //intersection is non-NULL		{		convexClip = Shard(sDimension, aPoly, sClip);		sClip->dArray();		}	else // intersection is NULL, return copy of original array		{		sClip = new(V_Array);		sClip->cArray(0,sizeof(Point3DFFixed),4);		aPoly->CopyArray(sClip); // copy the main V_Array		convexClip=new(V_Array);		convexClip->cArray(0, sizeof(V_Array*),1);		convexClip->Append(&sClip);		}	return convexClip;	}/* *	Intersect() *  This will create a new polygon which is the intersection of the two argument polygons. */V_Array* Intersect(int sDimension, V_Array *s1, V_Array *s2)	{	V_Array * intersect;			int len;			P3D p0,p1;			int i;				intersect=new(V_Array);			intersect->cArray(0,sizeof(short),4);	s2->CopyArray(intersect);	len=s1->ALength();						s1->Get(0,&p0);	for( i=0;i<len;i++)		{		if(i<len-1)s1->Get(i+1,&p1);		else s1->Get(0,&p1);		Slice(sDimension, intersect,p0,p1);		if(intersect->ALength()==0)break;		p0=p1;		}	RemoveSame(intersect); // remove any extra points	if(intersect->ALength()<=2) // no intersection		{		intersect->dArray();		intersect=NULL;		}	return intersect;	}void RemoveSame(V_Array *poly)	{	P3D p0,p1,ps;	int len, i;				if(poly->ALength()>2)		{		len=poly->ALength();				poly->Get(0,&p0);		ps=p0;				for( i=1;i<len;i++)					{			poly->Get(i,&p1);			if(dabs(p0.x-p1.x)<TINY_NUMBER && 				dabs(p0.y-p1.y)<TINY_NUMBER && 				dabs(p0.z-p1.z)<TINY_NUMBER) // same point!					{					poly->Remove(i); //get rid of the identical one					i--;					len--;					}			else p0=p1;			}		if(poly->ALength()>2)		if(dabs(ps.x-p1.x)<TINY_NUMBER && 			dabs(ps.y-p1.y)<TINY_NUMBER && 			dabs(ps.z-p1.z)<TINY_NUMBER) // first and last are the same point!			poly->Remove(poly->ALength()-1); 		}	}/* *	Slice() *  This slices a polygon, pIndex by the line defined by p0 and p1. This is a 3-D slice, *  and the calculation is performed based upon the maximal normal index. For example, if *  the max normal value is in the z direction, we perform the slice in the x-y projection *  plane. *  This method looks for edges of the polygon that cross the specified line. If it finds such *  a line, it calculates the intersection point and adds it to the SurfArray and adds its *  new index value to the pIndex array. */void Slice(int sDimension, V_Array* poly,P3D p0,P3D p1)	{	int len=poly->ALength();	short nindex;	P3D p3d, lp3d, zp3d,np3d;	int side,lside,zside,i,count;			poly->Get(0,&lp3d);	zp3d=lp3d;	zside=lside=CheckSide(sDimension, lp3d,p0,p1);	count=1;			for( i=0;i<len;i++)				{		P3D p3d;		double d;		if(i<len-1)			{			poly->Get(count,&p3d); 			side=CheckSide(sDimension, p3d,p0,p1);			}		else // back to the original point			{			p3d=zp3d;			side=zside;			}				if(side>=CLOCKWISE && lside>=CLOCKWISE) // this line is just fine			{			count++; 			}		else if(side>=CLOCKWISE && lside==COUNTERCLOCKWISE) // last point is clipped			{// clip this line and replace the last point with the new one			d=CrissCross3D(sDimension, p3d, lp3d,p0,p1);			np3d.x=lp3d.x+(p3d.x-lp3d.x)*d;			np3d.y=lp3d.y+(p3d.y-lp3d.y)*d;			np3d.z=lp3d.z+(p3d.z-lp3d.z)*d;			// clip texture coordinates here...						poly->Put(count-1,&np3d);			count++;			}		else if(side==COUNTERCLOCKWISE && lside>=CLOCKWISE) // this point is clipped			{// clip this line and insert it			d=CrissCross3D(sDimension, p3d, lp3d,p0,p1);			np3d.x=lp3d.x+(p3d.x-lp3d.x)*d;			np3d.y=lp3d.y+(p3d.y-lp3d.y)*d;			np3d.z=lp3d.z+(p3d.z-lp3d.z)*d;			// clip texture coordinates here...						poly->Insert(count,&np3d);			count+=2;			}		else if(side==COUNTERCLOCKWISE && side==COUNTERCLOCKWISE) // both points are clipped away			{//kill the last point, don't increment count...			poly->Remove(count-1);			}		lp3d=p3d;		lside=side;		}	}double CrissCross3D(int sDimension, P3D p1, P3D p2, P3D q1, P3D q2)	{	double px,py,qx,qy,pqx,pqy,d;		switch(sDimension)		{		case DXP:		case DXN:			px=p1.y-p2.y;			py=p1.z-p2.z;			qx=q2.y-q1.y;			qy=q2.z-q1.z;			break;		case DYP:		case DYN:			px=p1.x-p2.x;			py=p1.z-p2.z;			qx=q2.x-q1.x;			qy=q2.z-q1.z;			break;		case DZP:		case DZN:			px=p1.x-p2.x;			py=p1.y-p2.y;			qx=q2.x-q1.x;			qy=q2.y-q1.y;			break;		}	 	d=px*qy-py*qx;	if(d==0)return 0;	else	    {	    switch(sDimension)	    	{	    	case DXP:	    	case DXN:			    pqx=q2.y-p2.y;			    pqy=q2.z-p2.z;	    		break;	    	case DYP:	    	case DYN:			    pqx=q2.x-p2.x;			    pqy=q2.z-p2.z;	    		break;	    	case DZP:	    	case DZN:			    pqx=q2.x-p2.x;			    pqy=q2.y-p2.y;			    break;			}		return (qy*pqx-qx*pqy)/d;	    }	}int CheckSide(int sDimension, P3D p0, P3D p1, P3D p2){double dx, dz, dxp, dzp;double b1, b2;	int rval;switch(sDimension)	{	case DXP:		dx = p2.y - p1.y;		dz = p2.z - p1.z;		dxp = p0.y - p1.y;		dzp = p0.z - p1.z;		break;	case DXN:		dx = p2.y - p1.y;		dz = p1.z - p2.z;		dxp = p0.y - p1.y;		dzp = p1.z - p0.z;		break;	case DYP:		dx = p2.x - p1.x;		dz = p1.z - p2.z;		dxp = p0.x - p1.x;		dzp = p1.z - p0.z;		break;	case DYN:		dx = p2.x - p1.x;		dz = p2.z - p1.z;		dxp = p0.x - p1.x;		dzp = p0.z - p1.z;		break;	case DZP:		dx = p2.x - p1.x;		dz = p2.y - p1.y;		dxp = p0.x - p1.x;		dzp = p0.y - p1.y;		break;	case DZN:		dx = p2.x - p1.x;		dz = p1.y - p2.y;		dxp = p0.x - p1.x;		dzp = p1.y - p0.y;		break;	}if(dx==0 && dz==0)rval= UNKNOWN;else if(dxp==0 && dzp==0)rval= UNKNOWN;else	{	b1=dz*dxp;	b2=dx*dzp;	if(dabs(b1-b2)<TINY_NUMBER)rval = UNKNOWN;	else if(dabs(b1)<TINY_NUMBER && dabs(b2)<TINY_NUMBER)rval = UNKNOWN;	else if (b1 > b2) rval= CLOCKWISE;	else if (b1 < b2) rval= COUNTERCLOCKWISE;	else rval= LINEAR;	}return rval;}V_Array *Shard(int sDimension, V_Array *outside, V_Array *inside){// subtract the in array from out->surface by creating an array of convex polygons// that we put in out->surfaces. We then destroy out->surface.// first, find the top points of both. Create an edge from the inside to the outside P3D *po, *pi;P3D p3d,lp3d;int lo=outside->ALength();int li=inside->ALength();int i,loindex,liindex,roindex,riindex,soindex,siindex;P3D plo,pro,pli,pri;		int toindex,lloindex,lliindex;		int notDoneEdge=TRUE;		int latch=TRUE;		V_Array* subPoly;		V_Array* rPoly;rPoly=new(V_Array);rPoly->cArray(0, sizeof(V_Array*), 4);po=(P3D*)outside->Use();pi=(P3D*)inside->Use();switch(sDimension)	{	case DXP: // find the minimal z (we need a consistent starting point)	case DXN: 		loindex=liindex=0;		lp3d=po[0];		for(i=1; i<lo; i++)			{			p3d=po[i];			if(p3d.z<lp3d.z){lp3d=p3d; loindex=i;}			}		lp3d=pi[0];		for(i=1;i<li;i++)			{			p3d=pi[i];			if(p3d.z<lp3d.z){lp3d=p3d; liindex=i;}			}		break;	case DYP: // find the minimal x	case DYN: 		loindex=liindex=0;		lp3d=po[0];		for(i=1; i<lo; i++)			{			p3d=po[i];			if(p3d.x<lp3d.x){lp3d=p3d; loindex=i;}			}		lp3d=pi[0];		for(i=1;i<li;i++)			{			p3d=pi[i];			if(p3d.x<lp3d.x){lp3d=p3d; liindex=i;}			}		break;	case DZP: // find the minimal y	case DZN: 		loindex=liindex=0;		lp3d=po[0];		for(i=1; i<lo; i++)			{			p3d=po[i];			if(p3d.y<lp3d.y){lp3d=p3d; loindex=i;}			}		lp3d=pi[0];		for(i=1;i<li;i++)			{			p3d=pi[i];			if(p3d.y<lp3d.y){lp3d=p3d; liindex=i;}			}		break;	}// find the largest convex polygon that we can by moving in the reverse direction// using the three point convexity test. // set the saved base line to be this new left line.roindex=loindex;riindex=next(liindex,li); plo=po[loindex];pli=pi[liindex];pri=pi[riindex];while(COUNTERCLOCKWISE==CheckSide(sDimension, pri,pli,plo)) // move to next exterior side	{	loindex=next(loindex,lo);	plo=po[loindex];	}// find the left most point on the exterior edgewhile(notDoneEdge)	{	toindex=previous(loindex,lo);	plo=po[toindex];	if(COUNTERCLOCKWISE!=CheckSide(sDimension, pri,pli,plo))		loindex=toindex;	else notDoneEdge=FALSE;	}lloindex=loindex; // save the outside left for comparison laterlliindex=liindex;// once the left most original point is found, cut the rest of the polygons.		for(i=0;i<li;i++)	{	notDoneEdge=TRUE;	plo=po[loindex];	// first, cut off the leading triangular piece if necessary	if(COUNTERCLOCKWISE==CheckSide(sDimension, pri,pli,plo)) 		{//		SurfInfo subPoly;		while(notDoneEdge)			{			if(roindex!=lloindex)latch=FALSE;			if(latch || roindex!=lloindex)				roindex=next(roindex,lo);			else notDoneEdge=FALSE;			pro=po[roindex];			if(COUNTERCLOCKWISE!=CheckSide(sDimension, pri,pli,pro))				notDoneEdge=FALSE;			}			//		subPoly=*out;//		subPoly.surfaces=0;		subPoly=new(V_Array);		subPoly->cArray(0,sizeof(short),4);		// add the inside point.		subPoly->Append(&pi[liindex]);				// add the outside points		toindex=loindex;		subPoly->Append(&po[toindex]);		while(toindex!=roindex)			{			toindex=next(toindex,lo);			subPoly->Append(&po[toindex]);			}		if(CheckWidth(sDimension, subPoly))			rPoly->Append(&subPoly);		else // kill the new array			subPoly->dArray();		loindex=roindex;		}	roindex=loindex;	notDoneEdge=TRUE;	while(notDoneEdge)		{		if(roindex==lloindex && riindex==lliindex)			notDoneEdge=FALSE; 		else			{			if(roindex!=lloindex)latch=FALSE;			if(latch || roindex!=lloindex)				toindex=next(roindex,lo);			else {toindex=roindex; notDoneEdge=FALSE;}			pro=po[toindex];			if(COUNTERCLOCKWISE!=CheckSide(sDimension, pro,pri,pli))				roindex=toindex;			else notDoneEdge=FALSE;			}		}	// make the new poly...	//	subPoly=*out;//	subPoly.surfaces=0;	subPoly=new(V_Array);	subPoly->cArray(0, sizeof(short), 4);	// add the inside points (right to left)	subPoly->Append(&pi[riindex]);	subPoly->Append(&pi[liindex]);	// add the outside points (left to right)	toindex=loindex;	subPoly->Append(&po[toindex]);	while(toindex!=roindex)		{		toindex=next(toindex,lo);		subPoly->Append(&po[toindex]);		}	if(CheckWidth(sDimension, subPoly))		rPoly->Append(&subPoly);	else // kill the new array		subPoly->dArray();	//right side becomes the left side and we repeat...	liindex=riindex;	riindex=next(riindex,li);	pli=pri;	pri=pi[riindex];		loindex=roindex;	}//if(roindex==lloindex && riindex==lliindex)if(lloindex!=loindex)// add the last surface	{//	SurfInfo subPoly;//	subPoly=*out;//	subPoly.surfaces=0;	subPoly=new(V_Array);	subPoly->cArray(0, sizeof(short), 4);	subPoly->Append(&pi[liindex]);	toindex=loindex;	subPoly->Append(&po[toindex]);	while(toindex!=lloindex)		{		toindex=next(toindex,lo);		subPoly->Append(&po[toindex]);		}	if(CheckWidth(sDimension, subPoly))		rPoly->Append(&subPoly);	else // kill the new array		subPoly->dArray();	}outside->Unuse();inside->Unuse();return rPoly;}int CheckWidth(int sDimension, V_Array* surface){P3D *ind;		P3D p0,p1,p2;		// if this poly has any width, then we get to keep itint subLen=surface->ALength();int valid=FALSE;int j;	if(subLen<=2)return FALSE;ind=(P3D*)surface->Use();		p0=ind[subLen-3]; p1=ind[subLen-2]; p2=ind[subLen-1];		for( j=0;j<subLen;j++)		{	if(CLOCKWISE==CheckSide(sDimension, p0,p1,p2))// this is all we need		{		valid=TRUE;		break;		}	p0=p1; p1=p2; p2=ind[j];	}surface->Unuse();return valid;}//---------------------------------------------------------------------------------#if trueP3D outarray[]={{0,0,0}, {200, 0, 0}, {200,200, 0}, {0, 200, 0}};#define OUTNUM 4P3D inarray[]={{0,0,0}, {100, 0, 0}, {100,100, 0}, {0, 100, 0}};#define INNUM 4Rect rscreen;void TestShard(void);void TestShard(void)	{	EventRecord	myEvent;	V_Array *outside=new V_Array;	V_Array *inside = new V_Array;	V_Array *moveInside = new V_Array;	V_Array *pArray; 	Point3DFFixed norm;	RGBColor blue;	RGBColor red;	int i;		blue.red=0; blue.green=0x8000; blue.blue=-1;	red.red=-1; red.green=0x5000; blue.red=0;	norm.x.l=norm.y.l=0;	norm.z.intg=-1;	norm.z.frac=0;	outside->cArray(0, sizeof(P3D), 4);	inside->cArray(0, sizeof(P3D), 4);	moveInside->cArray(0,sizeof(P3D),4);		for(i=0;i<OUTNUM;i++)		outside->Append(&outarray[i]);	for(i=0;i<INNUM;i++)		inside->Append(&inarray[i]);				MakeWindow();		do { 		if(WaitNextEvent(mDownMask|mUpMask|keyDownMask|autoKeyMask, &myEvent,0,0L))			if(myEvent.what==keyDown)break;		Point loc;		P3D delta;		GetMouse(&loc);				moveInside->SetLength(0);		for(i=0;i<inside->ALength();i++)			{			inside->Get(i,&delta);			delta.x+=loc.h;			delta.y+=loc.v;			moveInside->Append(&delta);			}				EraseRect(&rscreen);		DrawSurface(moveInside,&blue, DZP);		pArray= SubPoly(norm, outside, moveInside);		for(i=0;i<pArray->ALength();i++)			{			V_Array* convexPoly;			pArray->Get(i,&convexPoly);			DrawSurface(convexPoly, &red, DZP);			convexPoly->dArray();			}		pArray->dArray();		} while ( !Button());	KillWindow();	ExitToShell();	}	#include "VWINDOW.H"void GetScreen(Rect *);V_Window * win;VCGrafPort	savePort;VGrafDevice saveDevice;#define SCALE 1#define OFFSET_AMT 2void DrawSurface(V_Array *surf, RGBColor* col,int dimension)	{	int len=surf->ALength();	P3D *pind=(P3D*)surf->Use();	P3D p3d;	int i;			RGBColor blackColor;    PolyHandle poly;	blackColor.red=blackColor.green=blackColor.blue=0; poly=OpenPoly();	switch(dimension)		{		case DXP:		case DXN:			p3d=pind[0];			MoveTo(OFFSET_AMT+p3d.y*SCALE,OFFSET_AMT+p3d.z*SCALE);			for ( i=1;i<len;i++)				{				p3d=pind[i];				LineTo(OFFSET_AMT+p3d.y*SCALE,OFFSET_AMT+p3d.z*SCALE);				}			p3d=pind[0];			LineTo(OFFSET_AMT+p3d.y*SCALE,OFFSET_AMT+p3d.z*SCALE);			break;		case DYP:		case DYN:			p3d=pind[0];			MoveTo(OFFSET_AMT+p3d.x*SCALE,OFFSET_AMT+p3d.z*SCALE);			for ( i=1;i<len;i++)				{				p3d=pind[i];				LineTo(OFFSET_AMT+p3d.x*SCALE,OFFSET_AMT+p3d.z*SCALE);				}			p3d=pind[0];			LineTo(OFFSET_AMT+p3d.x*SCALE,OFFSET_AMT+p3d.z*SCALE);			break;		case DZP:		case DZN:				p3d=pind[0];			MoveTo(OFFSET_AMT+p3d.x*SCALE,OFFSET_AMT+p3d.y*SCALE);			for ( i=1;i<len;i++)				{				p3d=pind[i];				LineTo(OFFSET_AMT+p3d.x*SCALE,OFFSET_AMT+p3d.y*SCALE);				}			p3d=pind[0];			LineTo(OFFSET_AMT+p3d.x*SCALE,OFFSET_AMT+p3d.y*SCALE);			break;					}	RGBForeColor(col);     	ClosePoly();	PaintPoly(poly);	RGBForeColor(&blackColor);     	FramePoly(poly);		    KillPoly(poly);	surf->Unuse();	}	void MakeWindow(void){Rect r;int cx,cy;Point p;int style;style = BORDERLESS;p.h=p.v=0;VGetPort( &savePort,&saveDevice );GetScreen(&rscreen);rscreen.top+=50;win=new(V_Window);win->cWindow(&rscreen,(strPtr)"Surface Display",p,p,p,style,WINDOW_CLOSE);win->Show();win->SetWPort();rscreen.right-=rscreen.left;rscreen.left=0;rscreen.bottom-=rscreen.top;rscreen.top=0;}void KillWindow(void){/*EventRecord	myEvent;do { 	if(WaitNextEvent(mDownMask|mUpMask|keyDownMask|autoKeyMask, &myEvent,0,0L))		if(myEvent.what==keyDown)break;	} while ( !Button());	*/win->dWindow();VSetPort(savePort,saveDevice);FlushEvents(mDownMask|mUpMask|keyDownMask|keyUpMask|autoKeyMask,0);}#endif