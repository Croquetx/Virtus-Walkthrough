/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  * Platform: 	MACINTOSH 	X *				WINDOWS		X *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VPane.h"#include "CadCntrl.h"#include "CadBtn.h"#include "ClrPane.h"#include "CVLayer.h"#include "CVLItem.h"#include "CadPosn.h"#include "CadDraft.h"#include "CVDefs.h"#include "CVPolyh.h"#include "CVEnvirn.h"#include "CVWCntrl.h"#include "CVRuler.h"	#include "RuleItem.h"	#include "Unit.h"	#include "ToolDef.h"	#include "SurfDef.h"#include "TumAxis.h"#include "AppMssgs.h"#include "AppDeflt.h"#include "AppText.h"#include "WalkDefs.h"#include "Format.h"#include "VMath.h"#include "VWindow.h"#include "VMain.h"#include "VDialog.h"#include "VTextDef.h"#include "WalkThru.h"		// MERGE14#include "TextItem.h"			// ABD WILLIAMS MERGE-TEXTURE 9/13/93#include "DesEBtn.h"	// MERGE-GOURAUD#include "Surface.h"	// MERGE-GOURAUD#if VPRO#include "TEXTLITM.h"		// ABD TEXTURE#endif // VPRO #include "TEXSEL.H"	// ABD MERGE13#include "VRTEX.H"	// MERGE13#if VR// DAS-VR-VRTOOLS 8/14/93#include "VRTools.h"#endif //VR#include <string.h>#define	SNAP_DEGREE_INCREMENT	5#define SameColor(c1,c2) (((c1.red == c2.red)&&(c1.green == c2.green)&&(c1.blue == c2.blue))?TRUE:FALSE)void CadControl::SetPolyhedron(CAVPolyhedron *poly)	{		polyhedron = poly;		}void CadControl::cController(V_Document *doc)	{		PointFFixed origin;		Controller::cController(doc);		toolConsole = (V_Console*)controller->cTool(this,toolCTools);		/* create the polyhedron tool box console 	*/		color = (ColorSelect*)controller->cTool(this,toolPColor);			/* create the color selection pane		  	*/	modifierConsole = (V_Console*)controller->cTool(this,toolCModifiers);	/* create the polyhedron modifier console */	gouraud_modifierConsole = (V_Console*)controller->cTool(this,toolCGouraudModifiers);	/* MERGE-GOURAUD */#if VR	// MERGE-COURAUD-PRO	environmentConsole = (V_Console*)controller->cTool(this,toolCCad);	/* create the zoom console				  	*/	position = (CadPosition*)controller->cTool(this,toolPPosition);		/* create the position pane				  */	utilityTools = (UtilityToolButton*)controller->cTool(this,toolBUtility);	/* create the regular polyhedron buttons  */		zoom = (CadButton*)controller->cTool(this,toolBCad);			/* create the zoom buttons				  	*/#endif	tumbleAxis = NULL;	defaultRegSides = 3;	defaultLevels = 1;	toggleSpot = SELECTOR_SPOT;	guideLines = new(V_Array);	guideLines->cArray(0,sizeof(RulerItem*),4);	// { DAS-VR-VRTOOLS 8/15/93#if VWT 	emptyPane = new(EmptyPane);	emptyPane->cPane(FALSE);	emptyPane->SetController(this);#elif VR	expandPane = new(ExpandPane);	expandPane->cPane(GRAYOUT);	expandPane->Init(this);#endif// } DAS-VR-VRTOOLS 8/15/93			hRuler = new(Ruler);	hRuler->cPane(FALSE);	hRuler->SetController(this);	hRuler->SetAxis(INFL_X);	vRuler = new(Ruler);	vRuler->cPane(FALSE);	vRuler->SetController(this);	vRuler->SetAxis(INFL_Y);	vRuler->SetDirection(VERT_RULER);		// { DAS-VR-VRTOOLS 8/14/93	#if VR	vrTools=new(VRTools);	vrTools->cPane(GRAYOUT);	vrTools->Init(this);	// DAS-VR-VRTOOLS 8/21/93	vrColor=new(VRColor);	vrColor->cPane(GRAYOUT);	vrColor->SetController(this);	vrTexture=new(VRTexture);				// ABD WILLIAMS MERGE12 9/12/93	// ABD WILLIAMS MERGE13 removed this line	vrTexture->cPane(FALSE);			// jca 6 Oct 93	vrTexture->SetController(this);		// ABD WILLIAMS MERGE12 9/12/93//#if MACINTOSH       13 Nov 93 jca	textureTitle = new(VRTextureTitle); // ABD WILLIAMS MERGE16	textureTitle->cPane(GRAYOUT);		textureTitle->SetController(this);//#elif WINDOWS       13 Nov 93 jca {   the controller is not always a CadControl! (it's sometimes a CavWalkControl)// 	textureTitle = (VRTextureTitle*)controller->cTool(this,toolVRPTextureTitle);			// ABD WILLIAMS 8/10/93//#endif //MACINTOSH  13 Nov 93 jca }	vrTextureSelect=new(TextureSelect);				// ABD WILLIAMS MERGE13 9/12/93	vrTextureSelect->SetWalkController(((WalkDocument*)document)->walkController);	// ABD WILLIAMS MERGE14	vrTextureSelect->cPane(GRAYOUT);			// ABD WILLIAMS MERGE13 9/12/93	vrTextureSelect->SetController(this);	// ABD WILLIAMS MERGE14	vrTextureSelect->SetPopTexture(vrTexture);	// MERGE13	vrFiller=new(VRFiller);	vrFiller->cPane(GRAYOUT);	vrFiller->SetController(this);#endif //VR// } DAS-VR-VRTOOLS 8/14/93		cadDraft = NewDraft();	cadDraft->cPane(VERTSCROLLBAR|HORZSCROLLBAR);	cadDraft->SetController(this);	environment = cadDraft->environment;	hRuler->SetEnvironment(environment);	vRuler->SetEnvironment(environment);	}	void CadControl::dController()	{			RulerItemDef **pItems;	int		i,length;		length = guideLines->ALength();	pItems = (RulerItemDef **)guideLines->Use();	for(i = 0 ; i < length; i++,pItems++)		(*pItems)->dRulerItemDef();	guideLines->Unuse();	guideLines->dArray();#if VR	// jca 21APR94 clean up.	vrTexture->dPane();#endif // VR	Controller::dController();	}			void *CadControl::cTool(Controller *ctrl,int toolType)	{	void	*tool = NULL;		switch(toolType)		{#if VR		case toolVRPTextureTitle:			textureTitle = new(VRTextureTitle); // ABD WILLIAMS MERGE16			textureTitle->cPane(GRAYOUT);				textureTitle->SetController(this);			tool = textureTitle;			break;#endif //VR		case toolBUtility:/* utility button set */			// MERGE-GOURAUD-PRO utilityTools = new(UtilityToolButton);			// MERGE-GOURAUD-PRO utilityTools->cButtonSet();			// MERGE-GOURAUD-PRO tool = utilityTools;				break;		case toolBSelect:/* select button set */			selectTools = new(SelectToolButton);			selectTools->cButtonSet();			tool = selectTools;			break;		case toolBRegular:/* regular button set */			regularPoly = new(RegPolyButton);			regularPoly->cButtonSet();			tool = regularPoly;			break;		case toolPColor:/* create pop color tool */			color = new(ColorSelect);			color->cPane(FALSE);			tool = color;			break;		case toolCTools:/* create preference and view menu */			toolConsole = new(V_Console);			toolConsole->cPane(FALSE);			toolConsole->SetPosition(NULL,topLeftConsole);			tool = toolConsole;			break;		case toolCCad:/* create environment button console */			// MERGE-GOURAUD-PRO environmentConsole = new(V_Console);			// MERGE-GOURAUD-PRO environmentConsole->cPane(FALSE);			// MERGE-GOURAUD-PRO environmentConsole->SetPosition(NULL,bottomLeftConsole);			// MERGE-GOURAUD-PRO tool = environmentConsole;			break;		case toolCModifiers:			modifierConsole = new(V_Console);			modifierConsole->cPane(FALSE);			tool = modifierConsole;			break;		// MERGE-GOURAUD [[[		case toolCGouraudModifiers:			gouraud_modifierConsole = new(V_Console);			gouraud_modifierConsole->cPane(FALSE);			tool = gouraud_modifierConsole;			break;		// MERGE-GOURAUD ]]]		case toolLList:/* create layer list */			walkList = new(CAVLayer);			walkList->cPane(FALSE);			tool = walkList;			break;		case toolPPosition:/* create position pane */#if VR	// MERGE-GOURAUD-PRO			position = new(CadPosition);			position->cPane(FALSE);			tool = position;#endif			break;		case toolBCad:/* create zoom buttons */			// MERGE-GOURAUD-PRO zoom = new(CadButton);			// MERGE-GOURAUD-PRO zoom->cButtonSet();			// MERGE-GOURAUD-PRO environmentConsole->SetButton(zoom);			// MERGE-GOURAUD-PRO tool = zoom;			break;		default:			break;		}		return(tool);	}	voidCadControl::Activate(int install)	{	PointFFixed	orgn;	V_Window *window;		window = NULL;		Controller::Activate(install);		if((msgDeactivate != install) && (msgDummy2 != install))		{		color->SetController(this);#if VPRO		pwc(controller)->SetPaletteController(toolWCoord, this);// MERGE-GOURAUD-PRO		pwc(controller)->position->SetController(this);// MERGE-BUG-DEC94		pwc(controller)->position->SetEnvironment(environment);// MERGE-GOURAUD-PRO#endif#if VR //MERGE-GOURAUD-PRO		position->SetController(this);		position->SetEnvironment(environment);#endif		walkList->SetController(this);		// MERGE-GOURAUD-PRO environmentConsole->SetButton(zoom);		// MERGE-GOURAUD-PRO zoom->SetController(this);		if(selectTools)selectTools->SetController(this);		if(regularPoly)regularPoly->SetController(this);		if(toolSet)toolSet->SetController(this);		tools->SetController(this);		// MERGE-GOURAUD-PRO tools->SetHeir(UTILITY_SPOT,utilityTools);		#if VPRO		// ABD TEXTURE		// this routine associates this CadControl (actually a design/surf/tumble		// controller) to the texture palette, so the texture palette can update the		// texture in that window.  This is called whenever the cadcontrol is activated		// (i.e. the window is activated).		pwc(controller)->SetPaletteController(toolWTexture, this);		pwc(controller)->ActivatePalette(toolWTexture, TRUE);		pwc(controller)->SetPaletteController(toolWCoord, this);		// MERGE-GOURAUD-PRO		pwc(controller)->ActivatePalette(toolWCoord, TRUE);				// MERGE-GOURAUD-PRO		#endif // VPRO		}			switch(install)		{				case msgCreate:			window = GetWindow(type); #if VR			window->Install(vrTools); // DAS-VR-VRTOOLS 8/14/93			window->Install(vrColor); // DAS-VR-VRTOOLS 8/21/93			window->Install(textureTitle); // ABD WILLIAMS MERGE16			window->Install(vrTextureSelect); // ABD WILLIAMS MERGE13			window->Install(vrFiller); // DAS-VR-VRTOOLS 8/21/93#endif //VR			window->Install(hRuler);			window->Install(vRuler);#if VWT // DAS-VR-VRTOOLS 8/15/93			window->Install(emptyPane);#elif VR			window->Install(expandPane);#endif			window->Install(cadDraft);						cadDraft->SetOrigin(SetOrigin(cadDraft->origin));			OrientRuler();			break;				case msgReset:					InstallTools();			Response(NULL,msgReset,objTools,0);			cadDraft->SetTrackSet(POSITION_TRACK);			break;				case msgDeactivate:	/* a deactivate call */			cadDraft->ResetTools();			break;					case msgInit:#if VR //MERGE-PRO-JAM-2			if(zoom->GetTool(0))				ZoomUser(FALSE);#endif VR //MERGE-PRO-JAM-2			break;		}	}	void CadControl::InstallTools()	{	V_Window *window;		controller->cTool(this,toolFlush);	window = GetWindow(objTools);		modifierConsole->SetPosition(color,topConsole);	gouraud_modifierConsole->SetPosition(modifierConsole,topConsole);	// MERGE-GOURAUD	window->Install(toolConsole);	window->Install(color);	window->Install(modifierConsole);	window->Install(gouraud_modifierConsole);	// MERGE-GOURAUD	// MERGE-GOURAUD-PRO window->Install(environmentConsole);	// MERGE-GOURAUD-PRO window->Install(position);	window->Install(walkList);	}	void CadControl::GetPlace(Rect *r,int warning,int who)	{	Rect	tr;	char	state;	int 	d; // DAS-VR-TOOLS 8/14/93		switch(who)		{		case toolPEmpty:#if VR		case toolVRExpand: // DAS-VR-VRTOOLS 8/15/93#endif //VR			hRuler->GetRect(&tr);			r->right = tr.left;			r->top = tr.top; // DAS-VR-VRTOOLS 8/15/93			vRuler->GetRect(&tr);			r->left = tr.left; // DAS-VR-VRTOOLS 8/15/93			r->bottom = tr.top;			break;		case toolPPosition:			pwc(controller)->GetPlace(r, warning, who);	// MERGE-GOURAUD-PRO			//environmentConsole->GetRect(&tr);			//r->right = tr.right;			//r->left = tr.left;			//r->bottom = tr.top;			break;				case toolLList:#if 0			modifierConsole->GetRect(&tr);			r->top = tr.bottom;			position->GetRect(&tr);			r->right = tr.right;			r->left = tr.left;			r->bottom = tr.top;#endif			gouraud_modifierConsole->GetRect(&tr);	// MERGE-GOURAUD			r->top = tr.bottom;		// MERGE-GOURAUD-PRO-6 (no -1)			GetWindow(objTools)->GetRect(&tr);	// MERGE-GOURAUD-PRO			r->right = tr.right;			r->left = tr.left;			r->bottom = tr.bottom;			break;				case toolPColor:			toolConsole->GetRect(&tr);			r->right = tr.right;			r->left = tr.left;			r->top = tr.bottom -1;		// MERGE-GOURAUD-PRO-5еее			r->bottom=r->top+COLOR_HEIGHT;			break;				case toolCCad:/* WRONG */			hRuler->GetRect(&tr);			r->top = tr.bottom;			r->right = tr.right;			vRuler->GetRect(&tr);			r->left = tr.right;			r->bottom = tr.bottom;			break;// { DAS-VR-EDITBUTTONS 8/14/93  need to move the rulers over!#if VR		case objHorzRuler:			vrTools->GetRect(&tr);			r->left+=(tr.right-tr.left); // just move it over			break;					case objVertRuler:				vrTools->GetRect(&tr);			d=r->right-r->left; // old d			r->left+=(tr.right-tr.left);			r->right=r->left+d;			break;					case toolToolVR:			if(vrTools->GetState())				{				vrTools->GetRect(&tr);				*r=tr;				}			else r->right=r->left; //make it really small			break;		case toolColorVR:	// DAS-VR 8/21/93 Color pane			if(vrTools->GetState())				{				vrTools->GetRect(&tr);				*r=tr;				r->top=tr.bottom;				r->bottom=r->top+COLOR_HEIGHT;				}			else r->right=r->left; // make it really small			break;// ABD WILLIAMS MERGE12 9/12/93 [[[		case toolTextureVR:			if(vrTools->GetState())				{				textureTitle->GetRect(&tr);				*r=tr;				r->top=tr.bottom;				r->bottom=r->top+TEXTURE_HEIGHT;	// ABD MERGE13 9/17/93				}			else r->right=r->left; // make it really small// ABD WILLIAMS MERGE12 9/12/93	]]]				break;			 // ABD WILLIAMS MERGE16 [[[		case toolVRPTextureTitle:			if(vrTools->GetState())				{				vrColor->GetRect(&tr);				*r = tr;				r->top = tr.bottom;				r->bottom = r->top + TEXTITLE_HEIGHT;				}			else r->right=r->left; // make it really small			break;			 // ABD WILLIAMS MERGE16 ]]]#endif// } DAS-VR-EDITBUTTONS 8/14/93		default:			break;		}	}	void CadControl::SetTrackSet(TrackSet *trackSet)	{#if VPRO	pwc(controller)->position->SetTrackSet(trackSet);	// MERGE-GOURAUD-PRO#elif VR	position->SetTrackSet(trackSet);#endif	}	int CadControl::GetOpacity()	{	int	opacity;		switch(modifiers->GetTool(0))		{		case  bOPAQUE: 		opacity = OPAQUE_NOM; break;		case  bTRANSLUCENT: opacity = TRANSLUCENT_NOM; break;		case  bTRANSPARENT: opacity = TRANSPARENT_NOM; break;			}	return(opacity);	}// MERGE-GOURAUD [[[int CadControl::GetShadeType()	{	int	the_shade_type;	#if !SPECIAL_EDITION         	// merge SE, vrmadness		// GJR 7/4/95	switch(gouraud_modifiers->GetTool(0))		{		case  bFLAT_SHADE: 	the_shade_type = SHADE_FLAT; break;		case  bGOURAUD_SHADE: the_shade_type = SHADE_GOURAUD; break;		}#else  //SPECIAL_EDITION		// merge SE, vrmadness		// GJR 7/4/95    	// no get tool, since button is not turned on.	the_shade_type = SHADE_FLAT;#endif //!SPECIAL_EDITION		// merge SE, vrmadness		// GJR 7/4/95	return(the_shade_type);	}// MERGE-GOURAUD ]]]voidCadControl::Track(TrackData *trackData)	{	trackData->flag = 0;#if VPRO	if(pwc(controller)->position)		// MERGE-GOURAUD-PRO    {		pwc(controller)->position->SetController(this);// MERGE-BUG-DEC94		pwc(controller)->position->SetEnvironment(environment);// MERGE-GOURAUD-PRO		pwc(controller)->position->SetPositionValue(trackData);		// MERGE-GOURAUD-PRO	}#elif VR	if(position)		position->SetPositionValue(trackData);#endif	}void CadControl::RulerTrack(TrackData *trackData)	{			trackData->point = environment->Translate3DFFixed(TO_WORLD,trackData->point);	trackData->anchor = environment->Translate3DFFixed(TO_WORLD,trackData->anchor);#if VPRO	pwc(controller)->position->SetController(this);// MERGE-BUG-DEC94	pwc(controller)->position->SetEnvironment(environment);// MERGE-GOURAUD-PRO	pwc(controller)->position->SetPositionValue(trackData);		// MERGE-GOURAUD-PRO#elif VR	position->SetPositionValue(trackData);#endif	}void CadControl::ClearTrack()	{	Point	p;	TrackData	trackData;	p = PtZero;	trackData.point = Pt3DFFZero;	trackData.anchor = Pt3DFFZero;	trackData.angle = FFAngleZero;	trackData.flag = POSITION_UPDATE;	hRuler->RulerTrack(&p.h,FALSE);	vRuler->RulerTrack(&p.v,FALSE);#if VPRO	if(pwc(controller)->position)	{		pwc(controller)->position->SetController(this);// MERGE-BUG-DEC94		pwc(controller)->position->SetEnvironment(environment);// MERGE-GOURAUD-PRO		pwc(controller)->position->SetPositionValue(&trackData);		// MERGE-GOURAUD-PRO	}#elif VR	if(position) position->SetPositionValue(&trackData);#endif	}int CadControl::GetNumSides()	{	int numSides;	switch(regularPoly->GetTool(0))		{		case bREGPOLY_ROOM3: numSides = 3; break;			case bREGPOLY_ROOM4: numSides = 4; break;			case bREGPOLY_ROOM6: numSides = 6; break;		case bREGPOLY_ROOM8: numSides = 8; break;			case bREGPOLY_ROOM:  		default:			numSides = defaultRegSides; break;			}	return(numSides);	}// { DAS-VR-VRTOOLS 8/22/93 added the VR tool buttonsvoid CadControl::ControlMessage(int message,long mod,int state)	{		int	oldTool = editTool;		switch(message)		{		case bHAND: 		editTool = message; if(LOCKSTATE == state) VSendMessage(MSG_DEFAULTS); break;		case bDROPPER: 		editTool = message; break;		case bMEASURE_TOOL: editTool = message; break;		case bARROW:			editTool = message;			if(LOCKSTATE == state) cadDraft->SelectAll(TRUE);			VSendMessage(MSG_SETARROW); // set back to arrow tool			break;		case bHIDE: 		editTool = message; if(LOCKSTATE == state) cadDraft->SetEditState(EDIT_HIDDEN,mod,FALSE); break;		case bLOCK: 		editTool = message; if(LOCKSTATE == state) cadDraft->SetEditState(EDIT_LOCKED,mod,FALSE); break;		case bROTATE_ROOM:  editTool = message; if(LOCKSTATE == state) cadDraft->UnPosition(bROTATE_ROOM); break;		case bSCALE_ROOM:	editTool = message; cadDraft->editFlags &= ~EDIT_ANCHOR; if(LOCKSTATE == state) cadDraft->UnPosition(bSCALE_ROOM); break;		case bSKEW_TOOL:    editTool = message; if(LOCKSTATE == state) cadDraft->UnPosition(bSKEW_TOOL); break;		case bPLUS_MINUS:   editTool = message; break;		case bPOLY_ROOM:    editTool = message; break;		case bRECT_ROOM:    editTool = message; break;		case bREGPOLY_ROOM:  		case bREGPOLY_ROOM3:		case bREGPOLY_ROOM4:		case bREGPOLY_ROOM6:		case bREGPOLY_ROOM8: editTool = bREGPOLY_ROOM; if(LOCKSTATE == state) VSendMessage(MSG_DEFAULTS); break;		case bOPAQUE: 		if(LOCKSTATE == state) cadDraft->SetOpacity(OPAQUE_NOM); break;		case bTRANSLUCENT: 	if(LOCKSTATE == state) cadDraft->SetOpacity(TRANSLUCENT_NOM); break;		case bTRANSPARENT: 	if(LOCKSTATE == state) cadDraft->SetOpacity(TRANSPARENT_NOM); break;		case bLIGHT_EDITOR: editTool = message; if(LOCKSTATE == state) VSendMessage(MSG_E_WLIGHT); break;		case bTUMBLE_EDITOR: editTool = message; break;		case bSURFACE_EDITOR: 	editTool = message; break;		// MERGE-GOURAUD [[[		case bFLAT_SHADE: 	if(LOCKSTATE == state) cadDraft->SetShadeType(SHADE_FLAT); break;		case bGOURAUD_SHADE: if(LOCKSTATE == state) cadDraft->SetShadeType(SHADE_GOURAUD); break;		// MERGE-GOURAUD ]]]		case bZOOM_UP:			SetScale(GetScale()*2,TRUE);			Request(NULL,msgUpdate,objTools,0);			break;					case bZOOM_BACK: 				SetScale(GetScale()/2,TRUE);			Request(NULL,msgUpdate,objTools,0);			break;					case bZOOM_USER:			//MERGE-GOURAUD-PRO	ZoomUser(zoom->GetState(2));			break;		// DAS-VR 8/22/93// MERGE-GOURAUD-PRO-3 [[[#if VPRO		case bZOOMIN:		// MERGE-GOURAUD-PRO			if(LOCKSTATE == state)				{//					if (optionKey & mod)					if (V_OPTION & mod)					{						SetScale(GetScale()/2,TRUE);						Request(NULL,msgUpdate,objTools,0);					}					else					{						SetScale(GetScale()*2,TRUE);						Request(NULL,msgUpdate,objTools,0);					}				}			editTool = message;			break;#endif // VPRO// MERGE-GOURAUD-PRO-3 ]]]#if VR		case bZOOMIN:			if(LOCKSTATE == state)				{				SetScale(GetScale()*2,TRUE);				Request(NULL,msgUpdate,objTools,0);				}			editTool = message;			break;		case bZOOMOUT:			if(LOCKSTATE == state)				{				SetScale(GetScale()/2,TRUE);				Request(NULL,msgUpdate,objTools,0);				}			editTool = message;			break;		case bSHAPE: editTool = message;			break;#endif // VR		default: Controller::ControlMessage(message,mod,state); break;		}		}// } DAS-VR-VRTOOLS 8/22/93 added the VR tool buttons		int CadControl::GetEditTool()	{	if(TRUE == zoomState) return(bZOOM_USER);	return(editTool);	}	voidCadControl::LaunchEditor(Polyhedron *poly,FFixed scale,SurfDef *surfDef,Point3DFFixed orient,int type)	{	pwc(controller)->LaunchEditor(poly,DblToFixed(cadDraft->userZoom),surfDef,orient,type);	}voidCadControl::SetPosition(short who,double where)	{	cadDraft->SetPosition(who,where);	}	voidCadControl::Display(int type)	{	hRuler->VDisplay(DRAW);	vRuler->VDisplay(DRAW);	}voidCadControl::Push(int dh,int dv)	{	cadDraft->Push(dh,dv);	}PointFFixedCadControl::SetOrigin(PointFFixed origin)	{	origin.h = hRuler->SetOrigin(origin.h);	origin.v = vRuler->SetOrigin(origin.v);	cadDraft->SetGrid(hRuler->tickTable,vRuler->tickTable);		cadDraft->SetGuide(hRuler->rulerItems,hRuler->localOrigin,vRuler->rulerItems,vRuler->localOrigin);		return(origin);	}voidCadControl::DrawGuide(int where,int direction,int type)	{	cadDraft->DrawGuide(where,direction,type);		}	PointFFixedCadControl::GridUnit()	{	PointFFixed	gridUnit;		gridUnit.h = hRuler->GetGrid();	gridUnit.v = vRuler->GetGrid();			return(gridUnit);	}	voidCadControl::SetScale(double newScale,int fixLastPt)	{		RulerScaleInfo	scaleInfo;	hRuler->SetScale(newScale);	hRuler->FFGetScale(&scaleInfo);	vRuler->FFSetScale(&scaleInfo);		if(fixLastPt)		cadDraft->ffLastPt = cadDraft->MakePtInWorld(cadDraft->ffLastPt,TRUE);			cadDraft->FFSetScale(scaleInfo.scale2Local,scaleInfo.localPrecision,scaleInfo.scale2World,scaleInfo.worldPrecision);			}	double CadControl::GetScale() { return(hRuler->GetScale()); }	LayerItem *CadControl::GetLayer()	{	return(((CAVLayer*)walkList)->GetLayer());	}			voidCadControl::ZoomUser(int state)	{	zoomState = state;#if VR //MERGE-PRO-JAM-2	if(!zoomState)			{				zoom->SetState(2,OFFSTATE);		environmentConsole->VDisplay(DRAW);	 	}#endif //MERGE-PRO-JAM-2	}voidCadControl::ResetPositionBox(long mod)	{#if VPRO	pwc(controller)->position->VDisplay(DRAW);	// MERGE-GOURAUD-PRO#elif VR	position->VDisplay(DRAW);#endif	}	V_Window *CadControl::GetWindow(int type)	{	V_Window	*window;		switch(type)		{		case objDepth:		#if VPRO		case objTexturePal:		case objCoord:	/* ABD MERGE-GOURAUD-PRO */		#endif // VPRO		case objTools: 			window = controller->GetWindow(type); 			break;		default: 			if(cadDraft->theWindow)				window = cadDraft->theWindow; 			else				window = controller->GetWindow(type);			break;		}			return(window);	}voidCadControl::ColorDropper(RGBColor newColor, TextureItem *newTexture)	// ABD MERGE-TEXTURE 9/14/93	{	color->Remember(newColor);	color->SetColor(newColor);	color->VDisplay(DRAW);	#if VR || VPRO  // jca 17JAN94	SetTexture(newTexture);	// ABD MERGE-TEXTURE 9/14/93#endif	}RGBColor CadControl::GetColor() { return(color->GetColor()); }void CadControl::SetColor(RGBColor clr) { color->SetColor(clr); }void CadControl::SetOpacity(long opc) { cadDraft->SetOpacity(opc); }int CadControl::CreateOK() { return(((CAVLayer*)walkList)->CreateOK()); }CadDraft *CadControl::NewDraft() 	{ 	return( new(CadDraft)); 	}intCadControl::EditLayer(LayerItem *lyr,int msgType, int objType)	{	int layerFlag,result;		layerFlag = lyr->GetFlag();	result = TRUE;		switch(msgType)		{		case msgDestroy:			if(result = WarningMessage(TXTW_LAYDELET,TXTC_CANCEL,TXTC_OK,DEFAULT_BUTTON_ONE|POSITIVE_BUTTON_TWO))				{				cadDraft->EditLayer(lyr,msgType);				walkList->RemoveItem();				}			break;				case msgEdit:			if( objView == objType)				polyhedron->HideLayer(lyr);			else				{				if(layerFlag&(HIDE_LAYER|LOCK_LAYER))					cadDraft->EditLayer(lyr,msgType);				}			break;				case msgUpdate:			if(result = WarningMessage(TXTW_LAYMOVE,TXTC_CANCEL,TXTC_OK,DEFAULT_BUTTON_TWO|POSITIVE_BUTTON_TWO))				result = cadDraft->EditLayer(lyr,msgType);			break;				}		return(result);	}		voidCadControl::Request(void *val,int action,int who,int scope)	{	switch(action)		{		case objTools:			switch(who)				{				case bZOOM_UP:					SetScale(GetScale()*2,TRUE);					Request(NULL,msgUpdate,objTools,0);					Request(NULL,msgReset,objHeight,0);					break;								case bZOOM_BACK:					SetScale(GetScale()/2,TRUE);					Request(NULL,msgUpdate,objTools,0);					Request(NULL,msgReset,objHeight,0);					break;								case bZOOMIN:	// MERGE-GOURAUD-PRO				case bZOOM_USER:#if VR //MERGE-PRO-JAM-2					ZoomUser(zoom->GetState(2));#endif //MERGE-PRO-JAM-2					break;				}			break;		}	}	PointFFixed CadControl::Constrain(Point *p,FFixed *angle)	{	TrackData	trackData;	Point3DFFixed	worldPt,worldAnchor;	PointFFixed		contPt;		contPt.h = hRuler->RulerTrack(&p->h,TRUE);	contPt.v = vRuler->RulerTrack(&p->v,TRUE);	if( bROTATE_ROOM == editTool && hRuler->snapState)		{		angle->intg+=((SNAP_DEGREE_INCREMENT)>>1);		angle->intg/=SNAP_DEGREE_INCREMENT;		angle->intg*=SNAP_DEGREE_INCREMENT;		if(360 <= angle->intg)angle->intg-=360;		}	#if VPRO	if(pwc(controller)->position)	// MERGE-GOURAUD-PRO#elif VR	if(position)#endif		{		trackData.anchor = cadDraft->worldAnchor;		trackData.point = environment->MakeVector(TO_WORLD,contPt);			trackData.angle.yaw =*angle;			trackData.scale = cadDraft->worldScaleMult;		trackData.flag = 0;		#if VPRO		pwc(controller)->position->SetController(this);// MERGE-BUG-DEC94		pwc(controller)->position->SetEnvironment(environment);// MERGE-GOURAUD-PRO		pwc(controller)->position->SetPositionValue(&trackData);	// MERGE-GOURAUD-PRO#elif VR		position->SetPositionValue(&trackData);#endif		worldPt = environment->Translate3DFFixed(TO_CAD,trackData.point);		contPt.h = worldPt.x;		contPt.v = worldPt.y;		}		return(contPt);	}void CadControl::ChangeView(int view)	{	char str[256];		strcpy(str,title);	environment->SetView(view);	OrientRuler();			SetTitle(str);	SetScale(GetScale(),FALSE);	Request(NULL,msgUpdate,objTools,0);	cadDraft->SetTrackSet(POSITION_TRACK);	}	void CadControl::SetGuideLines()	{	RulerItemDef **pItem;	int	i,length;	char hAxis,vAxis,gAxis,hSide;		if(guideLines)		{		switch(environment->GetView())			{			case topView: 			case rightView: 			case frontView: 			case outsideView:				hSide = POSITIVE_SIDE;				break;				default:				hSide = NEGATIVE_SIDE;				break;			}		hAxis = hRuler->defAxis;		vAxis = vRuler->defAxis;		hRuler->KillList();		vRuler->KillList();		length = guideLines->ALength();		if(length)			{			pItem = (RulerItemDef **)guideLines->Use();			for(i = 0; i < length; i++,pItem++)				{				gAxis = (*pItem)->axis;				if(hAxis == gAxis)  hRuler->CopyItem(*pItem,hSide);				else if(vAxis == gAxis)  vRuler->CopyItem(*pItem,POSITIVE_SIDE);				}			guideLines->Unuse();			}		}	}	void CadControl::OrientRuler()	{	AppPreference	*appPref;	DefaultPreference	*defPref;	Point3DFFixed	pt;	FFixed hOrg,vOrg;	int	hAxis,vAxis,hSide;			if( toolCRTLDesign == type )		{		appPref = GetPreference();		defPref = (DefaultPreference*)appPref->GetPreference(preferDefaults);		pt = defPref->localOrigin;		}	else		{		pt.x = hRuler->GetOriginOffset();		if(NEGATIVE_SIDE == hRuler->side) pt.x = FFNeg(pt.x);		pt.y = FFZero;		}				switch(environment->GetAxis())		{		case INFL_X: 			hAxis = INFL_Y; 			vAxis = INFL_Z; 			hOrg = pt.y;			vOrg = pt.z;					break;		case INFL_Y: 			hAxis = INFL_X; 			vAxis = INFL_Z; 			hOrg = pt.x;			vOrg = pt.z;					break;		case INFL_Z: 			hAxis = INFL_X; 			vAxis = INFL_Y; 			hOrg = pt.x;			vOrg = pt.y;					break;		}			switch(environment->GetView())		{		case topView: 		case rightView: 		case frontView: 		case outsideView:			hSide = POSITIVE_SIDE;			break;		case leftView: 		case backView: 		case bottomView:		case insideView:			hSide = NEGATIVE_SIDE;			break;		}			hRuler->SetAxis(hAxis); 	hRuler->SetSide(hSide);	hRuler->SetOriginOffset(hOrg);		vRuler->SetAxis(vAxis); 	vRuler->SetSide(POSITIVE_SIDE);	vRuler->SetOriginOffset(vOrg);	SetPositionOrigin();	SetGuideLines();	}	void CadControl::SetTool(long mod,int type)	{	if(_TOGGLE == type && (mod&V_OPTION))		type = _STEP_TOGGLE;	tools->Reset(toggleSpot,type);	}voidCadControl::SetPreference(AppPreference *appPref,int initFlag)	{	EditorPreference	*editPref;	DefaultPreference	*defPref;	UnitPreference		*unitPref;	Formatter			*formatter;	RGBColor			rColor;	int					reDrawFlag,state,changeFlag;	short				unitMagnitude;    unitType			uType;		reDrawFlag = FALSE;	editPref = (EditorPreference*)appPref->GetPreference(preferEditor);	defPref = (DefaultPreference*)appPref->GetPreference(preferDefaults);	unitPref = (UnitPreference*)appPref->GetPreference(preferUnits);		/* COMPARE EDITOR CONFIGURATION */	changeFlag = editPref->GetChange();	if(PREF_NOCHANGE != changeFlag || initFlag)		{		if(!SameColor(cadDraft->color,editPref->backColor)) 			{ 			reDrawFlag = 0x01; 			cadDraft->Color(editPref->backColor);			hRuler->SetBackColor(editPref->backColor);			vRuler->SetBackColor(editPref->backColor);			}					if(!SameColor(cadDraft->gridColor,editPref->gridColor)) 			{ 			reDrawFlag = 0x01;			cadDraft->GridColor(editPref->gridColor);			}		if(!SameColor(hRuler->color,editPref->rulerColor)) 			{ 			hRuler->SetColor(editPref->rulerColor);			vRuler->SetColor(editPref->rulerColor);			reDrawFlag |= 0x02;			}				if(toolCRTLDesign == type)			{			rColor = hRuler->GetItemColor(rangeItem);			if(!SameColor(rColor,editPref->extrRangeColor)) 				{ 				hRuler->SetItemColor(rangeItem,editPref->extrRangeColor);				vRuler->SetItemColor(rangeItem,editPref->extrRangeColor);				reDrawFlag |= 0x02;				}			}						rColor = hRuler->GetItemColor(guideItem);		if(!SameColor(rColor,editPref->guideColor)) 			{ 			hRuler->SetItemColor(guideItem,editPref->guideColor);			vRuler->SetItemColor(guideItem,editPref->guideColor);			cadDraft->GuideColor(editPref->guideColor);			reDrawFlag |= 0x02;			}		rColor = hRuler->GetItemColor(originItem);		if(!SameColor(rColor,editPref->homeColor)) 			{ 			hRuler->SetItemColor(originItem,editPref->homeColor);			vRuler->SetItemColor(originItem,editPref->homeColor);			reDrawFlag = 0x03;			}				state = RULER_SNAP&editPref->editorState ? TRUE : FALSE;		if( hRuler->GetState(SNAP_STATE) != state)			{			reDrawFlag |= 0x00;			hRuler->SetState(state,SNAP_STATE);			vRuler->SetState(state,SNAP_STATE);			}				state = FALSE;		if(GRID_DISPLAY&editPref->editorState)state |= DRAW_GRID;		if(GUIDE_DISPLAY&editPref->editorState)state |= DRAW_GUIDE;		if(ORIGIN_DISPLAY&editPref->editorState)state |= DRAW_ORIGIN;		#if VRML_ANCHOR		// ABD PRO25 AUG95		if(URL_DISPLAY&editPref->editorState)state |= DRAW_URL;		#endif 		if( cadDraft->displayFlags != state)			{			reDrawFlag |= 0x01;			cadDraft->GridOn(state);			}		if(positionWorld==editPref->trackState)state = TRACK_WORLD;		else state = TRACK_VIEW;		if( cadDraft->trackMethod != state)			{			cadDraft->SetTrackMethod(state);			cadDraft->SetTrackSet(POSITION_TRACK);			}		state = 0;		if(RULER_DISPLAY&editPref->editorState)state |= SHOW_RULER;		if(TAB_DISPLAY&editPref->editorState)state |= SHOW_RANGE;		if(GUIDE_DISPLAY&editPref->editorState)state |= SHOW_GUIDE;		if(ORIGIN_DISPLAY&editPref->editorState)state |= SHOW_ORIGIN;		if(editPref->editorState&(TAB_DISPLAY|GUIDE_DISPLAY|ORIGIN_DISPLAY))state |= (SHOW_TAB|SHOW_BADTHING);		if(hRuler->GetState(TAB_STATE) != state)			{			reDrawFlag = 0x04;			hRuler->SetState(state,TAB_STATE);			vRuler->SetState(state,TAB_STATE);			}					/*THE cadDraft is now the guy who cares	pwc(controller)->position->TrackReset(editPref->trackState);		// MERGE-GOURAUD-PRO//	position->TrackReset(editPref->trackState);*/		}			/* COMPARE DEFAULT CONFIGURATION */	changeFlag = defPref->GetChange();	if(PREF_NOCHANGE != changeFlag || initFlag)		{		defaultRegSides = defPref->regularSides;		defaultLevels = defPref->ellipseLevels;		if(!SameColor(GetColor(),defPref->objColor)) 			SetColor(defPref->objColor);		}				/* COMPARE UNIT CONFIGURATION */	changeFlag = unitPref->GetChange();	if(PREF_NOCHANGE != changeFlag || initFlag)		{		formatter = new(Formatter);		formatter->cFormat();				switch(unitPref->unitSystem)			{			case unitInch: uType = inch; unitMagnitude = 0; break;			case unitFoot: uType = foot; unitMagnitude = 0;break;			case unitYard: uType = yard; unitMagnitude = 0;break;			case unitMile: uType = mile; unitMagnitude = 0;break;			case unitMillimeter: uType = meter; unitMagnitude = -1;break;			case unitCentimeter: uType = centimeter; unitMagnitude = 0;break;			case unitMeter: uType = meter; unitMagnitude = 0;break;			case unitKilometer: uType = meter; unitMagnitude = 1;break;			case unitPica: uType = pica; unitMagnitude = 0;break;			case unitPoint: uType = point; unitMagnitude = 0;break;			case unitAngstrom: uType = angstrom; unitMagnitude = 0;break;			case unitParsec: uType = parsec; unitMagnitude = 0;break;			case unitCustom: 				uType = custom; unitMagnitude = 0;				formatter->SetCustom((char *)HDeref(unitPref->customSym));				break;			}				formatter->SetPromotion(unitPref->promoteFlag);		formatter->SetType(uType);		formatter->SetMagnitude(unitMagnitude);		formatter->SetScale(DblToFixed(unitPref->baseSize));		#if VPRO		pwc(controller)->position->SetFormat(formatter) ;	// MERGE-GOURAUD-PRO#elif VR		position->SetFormat(formatter) ;#endif		hRuler->SetFormat(formatter);		vRuler->SetFormat(formatter);		SetPositionOrigin();		formatter->dFormat();				reDrawFlag = 0x04;		}			switch(reDrawFlag)		{		case 0x01:/* CAD */			cadDraft->VDisplay(DRAW);			break;		case 0x02:/* RULER REDRAW REQUIRED */			hRuler->VDisplay(DRAW);			vRuler->VDisplay(DRAW);			break;		case 0x03:/* CAD & RULER REDRAW REQUIRED */			cadDraft->VDisplay(DRAW);			break;					case 0x04:/* COMPLETE RESET */			SetScale(hRuler->GetScale(),TRUE);			hRuler->Reset();			vRuler->Reset();// { DAS-VR-VRTOOLS 8/15/93#if VWT			emptyPane->Reset();#elif VR			expandPane->Reset();#endif// } DAS-VR-VRTOOLS 8/15/93			cadDraft->Reset();			break;		default:/* NOTHING SPECIAL */			break;		}	}intCadControl::UnitConversion(double factor)	{	double	scal;	FFixed fFactor;				fFactor = DblToFixed(factor);	cadDraft->ffLastPt.h = FFMult(cadDraft->ffLastPt.h,fFactor);	cadDraft->ffLastPt.v = FFMult(cadDraft->ffLastPt.v,fFactor);		scal = GetScale();	scal /= factor;	SetScale(scal,FALSE);		return FALSE;	}voidCadControl::SetPositionOrigin()	{	PointFFixed	pt;	pt.h = hRuler->GetOriginOffset();	pt.v = vRuler->GetOriginOffset();#if VPRO	pwc(controller)->position->SetOrigin(pt) ;	// MERGE-GOURAUD-PRO#elif VR	position->SetOrigin(pt) ;#endif	}/* THIS SHOULD REINSTALL THE ITEMS OF type */void CadControl::SetRulerValue(int itemType,RulerItemDef *itemDef)	{	AppPreference *appPref;	DefaultPreference	*defPref;	FFixed point,base,tmp;	int	objType;	char defAxis;		defAxis = itemDef->GetAxis();	point = itemDef->GetValue();		switch(itemType)		{		case guideItem: 			objType = objHorzRuler;			break;					case originItem: 			objType = objOrigin;			if( toolCRTLDesign == type)				{				appPref = GetPreference();				defPref = (DefaultPreference*)appPref->GetPreference(preferDefaults);				switch(defAxis)						{					case INFL_X:defPref->localOrigin.x = point; break;					case INFL_Y:defPref->localOrigin.y = point; break;					case INFL_Z:defPref->localOrigin.z = point; break;					}				OrientRuler();				}			else				{				switch(defAxis)						{					case INFL_X:hRuler->SetOriginOffset(point); break;					case INFL_Y:vRuler->SetOriginOffset(point); break;					case INFL_Z:break;					}				}			break;					case rangeItem:			tmp = itemDef->GetValue2();			if(GRTR == FFLogic(point,tmp))				base = tmp;			else				{				base = point;				point = tmp;				}			objType = objHeight;			appPref = GetPreference();			defPref = (DefaultPreference*)appPref->GetPreference(preferDefaults);			switch(defAxis)					{				case INFL_X:defPref->extrusionMin.x = base;defPref->extrusionMax.x = point; break;				case INFL_Y:defPref->extrusionMin.y = base;defPref->extrusionMax.y = point; break;				case INFL_Z:defPref->extrusionMin.z = base;defPref->extrusionMax.z = point; break;				}				break;		}	Request(NULL,msgEdit,objType,0);	}int CadControl::ExportContents(V_Buffer *buffer,int flag)	{	int err;	err = 0;	switch(flag)		{		case formatPICT:		case formatBMP:		case formatTIFF:		case formatEPS:		case formatIllustrator:			err = cadDraft->TakeSnapShot(buffer,flag);break;		default: err = -1; break;		}	return(err);	}voidCadControl::SetTexture(TextureItem * dummy) {#if VR	vrTextureSelect->SetTexture(dummy);#elif VPRO//	pwc(controller)->SetTextureItem(tex_item);	pwc(controller)->SetTextureItem(dummy);	//JAM#endif // VR}	TextureItem*CadControl::GetTexture(void) {#if VR	return vrTextureSelect->GetTexture();#elif VPRO	if (pwc(controller)->GetTextureListItem() != NULL)		return(pwc(controller)->GetTextureListItem()->GetTextureItem());	else		return NULL;#else // no texture interface	return(NULL);#endif // VR	}	// ABD WILLIAMS MERGE14// MERGE-GOURAUD [[[voidCadControl::SetShadeType(unsigned char sh) {	if (cadDraft) cadDraft->SetShadeType(sh);}	// MERGE-GOURAUD ]]]#if VPROstruct TextureList * CadControl::GetTextureList()  	// ABD TEXTURE{ 	return (pwc(controller)->GetTextureList());}//JAM TXTRFIDDLE 06/14/94 [[[struct TextureBackPane *		// ABD TEXTURECadControl::GetTextureBackPane()	{	return (pwc(controller)->GetTextureBackPane());	}	//JAM TXTRFIDDLE 06/14/94 ]]]		#endif // VPRO// jca 23MAR94 return the state of the selected list.  Is anything in it?// And can we cut, copy, paste?intCadControl::IsAnythingSelected(void){	return(cadDraft->IsAnythingSelected());}// to tell the edit menu if we can paste the buffer stuffintCadControl::CanBufferPaste(struct V_Buffer *cBuf){    ULong	bufPosition;	int direction, ok = 0;	bufPosition = cBuf->IOGetPosition();	if (bufPosition > 0)		{		direction = cBuf->IODirection();		cBuf->IOSetPosition(0);		cBuf->IOSetDirection(DATA_IN);		ok = IO_ID(cBuf,IFF_PRSM);		cBuf->IOSetPosition(bufPosition);		cBuf->IOSetDirection(direction);		}    return(ok);}// and if anything is selected, is it (or are they) opaque, translucent,// transparent, straight, rounded, pointed, scaled, rotated, skewed, etc.ULongCadControl::SelectedConditions(void){	return(cadDraft->SelectedConditions());}