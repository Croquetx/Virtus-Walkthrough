/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				David W. Easter *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "WalkPane.h"#include "WalkBPne.h"	// DAS 8/25/93#include "Clip.h"		// DAS 8/25/93#include "Drawing.h"	// DAS-VR 8/29/93#include "CVWCntrl.h"	// DAS-VR 8/29/93#include "PolyDefs.h"	// DAS-VR 8/29/93#include "CVPolyh.h"	// DAS-VR 9/6/93#include "CADCNTRL.H"	// DAS-VR 9/6/93#include "CVEnvirn.h"	// DAS-VR 9/6/93#include "VwCntrl.h"#include "View.h"#include "AppMssgs.h"#include "AppDeflt.h"#include "AppText.h"#include "BallHelp.h"#include "WMenus.h"/* THIS IS FOR PRIORITY enum */#include "IntfDlog.h"#include "DlogTran.h"#include "QuickTim.h"#include "EPSF.h"#include "imgHandl.h"#include "BMPHandl.h"#include "TIFHandl.h"#include "ToolDef.h"#include "SmthPath.h"#include "Observer.h"#include "Misc.h"#include "WalkMovi.h"#include "AdskAnim.h"#include "QTMovie.h"#include "PICSMovi.h"#include "AVIMovie.h"#include "VMain.h"#include "VGraphic.h"#include "VGUtil.h"#include "VWindow.h"#include "VPrint.h"#include "VMemUtil.h"#include "VError.h"#include <stdio.h>#include <stddef.h>#include "TextSrvr.h"	// ABD MERGE-TEXTURE 9/13/93#include "PolyConv.h"	// ABD DEBUG 9/15/93#include "VDebug.h"#include "ShowTest.h"#if USE_HMD				// MERGE-HMD#include "HMD.h"		// MERGE-HMD#endif					// MERGE-HMD// MERGE-GOURAUD-PRO [[[#if ((VR) || (VPRO))#include "DesCntrl.h"#include "WalkDefs.h"#include "Button.h"#include "WalkThru.h"#include "VwBtn.h"#include "CvDefs.h"#include "VTimer.h"		// MERGE-HMD ARROW-KEYS#endif					// MERGE-GOURAUD-PRO ]]]#if VR#include "VRWLKPAN.h"	// MERGE16#include "VSound.h"		//ELVIS#endif#if VPLAYER#include "VPlayer.h"#endif //VPLAYERvoidWalkPane::cPane(int flag)	{	V_MenuMgr	*mgr;	V_Pane::cPane(flag);	vcenterX = 1;	vcenterY = -1;	fullScreen = NULL;	aspectH = 0; aspectV = 0;	lastType = 0;	inAnimation = FALSE;	#if VWT	mgr = GetMenuMgr();	walkMenu = new(MenuWalk);	walkMenu->ctheMenu();	mgr->Append(walkMenu);#endif //VWT	#if WINKEYBOARDVAVIGATION	//17OCT94 JAM-WINDOWS-KEYBOARD-NAVIGATION [[[	//instance variables which indicate which keys are currently	//depressed.  handled in keyaction and keyupaction. initially not down. [[[	WinOptionDown = FALSE;	WinShiftDown = FALSE;	WinControlDown = FALSE;	WinRightDown = FALSE;	WinLeftDown = FALSE;	WinUpDown = FALSE;	WinDownDown = FALSE;	WinStrafeLeftDown = FALSE;	// keypad 1 or 7	WinStrafeRightDown = FALSE;	// keypad 3 or 9	//instance variables which indicate which keys are currently    //depressed.  handled in keyaction and keyupaction ]]]	#endif //WINKEYBOARDVAVIGATION //17OCT94 JAM-WINDOWS-KEYBOARD-NAVIGATION ]]]	}voidWalkPane::dPane()	{#if VWT	walkMenu->dMenu();#endif //VWT	V_Pane::dPane();	}void WalkPane::Init(ViewController *ctrl, View *vw)	{	control = ctrl;#if VWT	walkMenu->SetController(control);#endif //VWT	view = vw;	}voidWalkPane::FullScreen(V_Offscreen *theOffscreen)	{	fullScreen = theOffscreen;	}intWalkPane::AspectRatio(int hAspect,int vAspect)	{	int changed = FALSE;	if (aspectH != hAspect) { aspectH = hAspect; changed = TRUE; }	if (aspectV != vAspect) { aspectV = vAspect; changed = TRUE; }	if (changed) SizeNotify();	return(changed);	}voidWalkPane::CalcSize(Rect *r, Point *p, int type, int warning)	{#if VPLAYER  // BILBIL	if (((WalkController*)(control->controller))->fullFlag == FALSE)		r->bottom-=(VScrollWidth()-1);#else	control->GetPlace(r,warning,toolPWalk);#endif //VPLAYER	}voidWalkPane::SizeNotify()	{		vcenterX = centerX / 6;	vcenterY = -centerY / 7;	if (vcenterX == 0) vcenterX = 1;	if (vcenterY == 0) vcenterY = -1;	if (aspectH != 0 && aspectV != 0)		{		long width, height;		width = (long)aspectH * dataRect.bottom;		height = (long)aspectV * dataRect.right;		aspectRect = dataRect;		aspectEdge1 = aspectRect;		aspectEdge2 = aspectRect;		if (width < height)			{			width = (width + (aspectV >> 1)) / aspectV;			aspectRect.left = centerX - (width >> 1);			aspectRect.right = aspectRect.left + width;			aspectEdge1.right = aspectRect.left;			aspectEdge2.left = aspectRect.right;			}		else			{			height = (height + (aspectH >> 1)) / aspectH;			aspectRect.top = centerY - (height >> 1);			aspectRect.bottom = aspectRect.top + height;			aspectEdge1.bottom = aspectRect.top;			aspectEdge2.top = aspectRect.bottom;			}		}	else		{		aspectRect = dataRect;		aspectEdge1 = VZeroRect;		aspectEdge2 = VZeroRect;		}	view->UpdatePane(aspectRect.right - centerX, aspectRect.bottom - centerY);	}voidWalkPane::Display(int type, int h, int v)	{	Rect copyRect;	int options, tmpOptions;	AppPreference *appPreference;	RenderPreference *renderPref;#if WINDOWS	HDC hdcPrint;	Angle3D saveAngle, rotAngle;	V_Print *printer;	int devCaps;	FFixed saveWindowClipMin;	//JAM 6-3-94 for saving and resetting gGlobalWindowClipMin;#endif //WINDOWS    Rect	tempRect;		//JAM make banding work with new clip	extern int gCurrentlyDoingIO;	//MERGE-PRO-JAM-2	#if USE_HMD	extern int gUseHMDs;		// MERGE-HMD ABD HMD MAR95	#endif // USE_HMD		if(gCurrentlyDoingIO) return;	//MERGE-PRO-JAM-2 don't display walkpane or cad pane while doing i/o	//JAM 17FEB95 low memory walk rendering [[[	//if memory was too low for rendering the walkview, we'd pause for	//a full minute before MyGrowZone() is called.  I inserted this code	//to abort drawing if memory becomes low.  Doesn't appear to be a problem	//in Windows.	#if MACINTOSH	if(gmemoryLowForWalkView)	{//		if(FreeMem() > (4*WALKVIEW_RENDER_MEM_THRESHOLD))		if (MemThreshholdTest(4*WALKVIEW_RENDER_MEM_THRESHOLD))		gmemoryLowForWalkView = 0;	}	//code to help surface features not take up more memory if memory is somewhat low	if(gmemoryLowForSurfaceFeatures)	{//		if(FreeMem() > (2*SURFFEAT_RENDER_MEM_THRESHOLD))		if (MemThreshholdTest(2*SURFFEAT_RENDER_MEM_THRESHOLD))		gmemoryLowForSurfaceFeatures = 0;	}	#endif	//JAM 17FEB95 low memory walk rendering ]]]		SetMetaPort();		gTextureServer->LockTextures();	// ABD MERGE-TEXTURE 9/14/93	copyRect = aspectRect;	switch (type)		{#if (!VPLAYER) // BILBIL		case PRINT_DRAW:			options = view->GetOptions(-1);			tmpOptions = options;			appPreference = control->GetPreference();			renderPref = (RenderPreference*)appPreference->GetPreference(preferRenderer);			if (renderPref->printWhiteShade)				{				tmpOptions |= DRAW_WHITE_SHADE;				tmpOptions &= ~(DRAW_SHADE|DRAW_NO_SHADE);				}			view->SetOptions(tmpOptions);#if MACINTOSH			if((tmpOptions&DRAW_WHITE_SHADE) || !(tmpOptions&RENDER_FILL))				#if USE_HMD					// MERGE-HMD draw with the HMD					((Observer*)(view))->DrawHMD(FALSE, FALSE);		// MERGE-HMD				#else					view->Draw(FALSE, FALSE);// MERGE-HMD				#endif // USE_HMD			else			{			Rect br,or,dummy;			long sz,ht,snum,i,count=0;			OSErr err=-1;			sz=(long)(dataRect.right-dataRect.left)*(long)(dataRect.bottom-dataRect.top);			switch(depth)				{				case 0: case 1: sz>>=8; break;				case 2:	sz>>=4; break;				case 4: sz>>=2; break;				case 8: sz>>=0; break;				case 16: sz<<=1; break;				case 32: sz<<=2; break;				}			while(err && count<4)				{				snum=sz/(65536L>>count);				snum++;				ht=1+(dataRect.bottom-dataRect.top)/snum;								or.top=dataRect.top;				or.bottom=or.top+ht; 				or.left=dataRect.left;				or.right=dataRect.right;				br=or;								if(offscreen)offscreen->dOffscreen();				offscreen=new(V_Offscreen);								err=offscreen->cOffscreen(&or,depth,NULL,NULL);				if(err)					{					offscreen->dOffscreen();					offscreen=0;					count++;					}				}			if(!err)				{				offscreen->SetCurrent();								usePlatformDrawFlag=FALSE; // DAS THIS NEEDS TO CHECK FOR WHAT IS IN USE				for(i=0;i<snum;i++)					{									offscreen->SetMetaPort();					offscreen->SetCurrent();					tempRect = currentPane->dataRect;	//JAM make banding work with new clip					currentPane->dataRect = br;			//JAM make banding work with new clip										#if USE_HMD						// MERGE-HMD draw with the HMD						((Observer*)(view))->DrawHMD(FALSE, FALSE);		// MERGE-HMD					#else						view->Draw(FALSE, FALSE);// MERGE-HMD 					#endif // USE_HMD					currentPane->dataRect = tempRect;	//JAM make banding work with new clip					offscreen->UnsetMetaPort();					offscreen->SetMetaPort();					outputOn->SetMetaPort();					offscreen->MetaTo(outputOn,&br,&or);					centerY-=ht;					or.top+=ht;					or.bottom+=ht;					if(or.bottom>dataRect.bottom)						{						or.bottom=dataRect.bottom;						br.bottom=or.bottom-or.top;						}					offscreen->UnsetMetaPort();					outputOn->UnsetMetaPort();					if(or.top>dataRect.bottom)break;					}				}//			else//				ResultError(iMemFullErr);			}#else // WINDOWS		// jca 4Feb94 fix the landscape print problem		printer = theWindow->GetVPrint();        if (!printer)	break; // should never happen, but...		hdcPrint = printer->printDC;      // get printer device context		devCaps = GetDeviceCaps(hdcPrint, RASTERCAPS);//#if !VWT //JAM 10/6/94 should also work in PRO#if ((!VWT) || VPRO)		if ((!(devCaps & RC_DIBTODEV)) || ((!offscreen->IsFlashOn()) || (!VGetUserFlash())))  // can we band?#endif // VWT			{  // nope, no banding.			bandPrint = FALSE;            printer->OpenPage();			view->Draw(FALSE, FALSE);			printer->ClosePage();			bandPrint = TRUE;			break;			}//JAM 10/6/94 should also work in PRO -- now we should be up to printing this way//#if !VWT // jca 30MAR94 we're not up to printing this way.  Yet.#if ((!VWT) || VPRO)		//JAM 6-3-93 when printing, we don't want object precision clipping to		//reject windows that are a small number of pixels tall, since a whole		//band may only be a small number of pixels tall		saveWindowClipMin = gGlobalWindowClipMin;		gGlobalWindowClipMin.intg = 0;        gGlobalWindowClipMin.frac = 0x1000;		// we have already set up the printer, with StartDoc etc, so now we have to do the banding		// thing.  We loop through each band.  For each band, we try to create an offscreen of that      // size.  If we can't, then we try to band the band.  Blech.  		for (;;)		{		Rect rcRect;		OSErr err;		int iOk;		HBITMAP hBits, hOldBitmap, tempBits;		LPBITMAPINFO	lpbmi;		char	*bits;		Handle bmpinfo = NULL;		ULong localRowSize, nLinesMax, nLinesThisPass, linesLeft;		Handle bitbuf = NULL;		short max_height;		long max_size;		long the_width;		long physical_width;	//physical width in pixels actually allocated. for dumb drivers		long long_max_height;		int i, j, k, num_stripes;		Rect off_rect, drawRect;		int printer_top;			Escape(hdcPrint, NEXTBAND, 0, (LPSTR)NULL, &rcRect);			if (IsRectEmpty(&rcRect)) break;      // if empty rect, no more bands//		printer->ScalePrinterRect(&rcRect);		// adjust for the right												// DPI settings.			// convert rcRect coordinates from device			DPtoLP(hdcPrint, (POINT FAR *)&rcRect, 2);			// now figure out the size of the bands in this offscreen -- we want only one			// band per offscreen, because GetDIBits does not work unless top is zero for			// some reason, so we need to take the max of num_stripes and num_bands and fix			// everything else up appropriately.			// create a temp offscreen so we can test the row width -- this will be deleted			// make sure the left/right is correct, we don't really care about top/bottom			off_rect.left = rcRect.left;			off_rect.right = rcRect.right;			off_rect.top = 0;			off_rect.bottom = 1;			if (offscreen) offscreen->dOffscreen();			offscreen = new(V_Offscreen);			err = offscreen->cOffscreen(&off_rect, -1, NULL, NULL);    // get GDI depth //GJR 12/20/93			// first check the offscreen memory usage.			// Get its byte length per row. Calc max_height.          // moved here. //GJR 10/20/93			max_size = (long)60 * (long)1024;			the_width = offscreen->GetRowWidth();  // length of row in bytes			long_max_height = max_size / the_width;			max_height = (int)long_max_height;         // Now calc the DIB memory usage. Its 24 bits per pixel. So get actual pixel width *3 gives bytes.			physical_width = ((long)offscreen->GetRowWidth()* 8) / (long)offscreen->GetDepth();	//Get actual row width in pixels.								// width in bytes *(bits per byte) / (bits per pixel) gives pixels   //GJR 12/20/93			localRowSize = LWORD_ALIGN((long)physical_width * (long)24);   // align the matching number of bits			nLinesMax = ((long)60 * (long)1024) / localRowSize;			// now nLinesMax and max_height both contain a potential maximum size for each			// band.  We want the minimum of these two, so we can make it always be one band			// per offscreen.			max_height = nLinesMax = min(max_height, nLinesMax);			if (max_height <= 0)			// do something; we got an error			{				AlertMessage(TXTW_MEMORY);				goto bailout;			}			// determine the number of stripes based on the new max_height			num_stripes = (((rcRect.bottom - rcRect.top)+(max_height-1)) / max_height);			// fix up the rect of this pane so drawing occurs correctly			// dataRect = rcRect;			// dataRect.bottom = dataRect.top + max_height;			// if (dataRect.bottom > rcRect.bottom)			// 	dataRect.bottom = rcRect.bottom;			off_rect.left = rcRect.left;			off_rect.right = rcRect.right;			off_rect.top = 0;			off_rect.bottom = max_height;			if (offscreen) offscreen->dOffscreen();   		// delete old offscreen			offscreen = new(V_Offscreen);			err = offscreen->cOffscreen(&off_rect, -1, NULL, NULL);    // get GDI depth //GJR 12/20/93			offscreen->SetMetaPort();			//offscreen->SetCurrent();			if (err)			// do something; we got an error			{				AlertMessage(TXTW_MEMORY);				goto bailout;			}			// get the DI Bits from the offscreen			bmpinfo = NewHandle(sizeof(BITMAPINFOHEADER) + 256*sizeof(RGBQUAD));			if (bmpinfo == NULL)			{				AlertMessage(TXTW_MEMORY);				goto bailout;			}			HLock(bmpinfo);			lpbmi = (LPBITMAPINFO) HDeref(bmpinfo);			memset(lpbmi, 0, sizeof(BITMAPINFOHEADER) + 256*sizeof(RGBQUAD));			// do the obvious initing			lpbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);			lpbmi->bmiHeader.biPlanes = 1;			lpbmi->bmiHeader.biCompression = BI_RGB;			lpbmi->bmiHeader.biHeight = nLinesMax;			lpbmi->bmiHeader.biWidth = physical_width;    // number of pixels per byte width			lpbmi->bmiHeader.biBitCount = 24;			bitbuf = NewHandle(localRowSize * nLinesMax);			if (bitbuf == NULL)  // err, not enough memory			{				AlertMessage(TXTW_MEMORY);				goto bailout;			}						HLock(bitbuf);			bits = (char *) HDeref(bitbuf);			//memset(bits, 0, localRowSize*nLinesMax);  // clear the buffer     will this work in FAR code????			linesLeft = rcRect.bottom - rcRect.top;  // jca 25APR94 init the linesLeft counter			nLinesThisPass = min(linesLeft, nLinesMax);	// jca 25APR94 how many lines this time?			VSetRect(&drawRect, rcRect.left, 0, rcRect.right, nLinesThisPass);	// jca 25APR94 set pane rect			printer_top = 0;            iOk = TRUE;			for ( i = 0 ; i < num_stripes && iOk ; i++ )			{				VSetCursor(vCursorEarth);				// create an offscreen to draw into				usePlatformDrawFlag = FALSE; // DAS THIS NEEDS TO CHECK FOR WHAT IS IN USE				tempRect = currentPane->dataRect;	//JAM make banding work with new clip				currentPane->dataRect = drawRect;			//JAM make banding work with new clip				view->Draw(FALSE, FALSE);				currentPane->dataRect = tempRect;	//JAM make banding work with new clip				// ShowOffscreen(offscreen);			// DEBUG				// convert the offscreen to a DIB and then copy it to the printer				// get DI bits from the offscreen -- make sure the bits are selected out				// of the offscreen dc				tempBits = SelectObject(offscreen->metaPort, offscreen->oldBitmap);				ASSERT(tempBits == offscreen->bitmap);				iOk = GetDIBits(offscreen->metaPort, tempBits, 0,  		// was top in place of 0					nLinesMax, bits, lpbmi, DIB_RGB_COLORS);				iOk = SelectObject(offscreen->metaPort, tempBits);				// SetDIBitsToDevice is buggy.  It can't handle row chunks wider				// than 2700 pixels, unless the chunk is a single scan wide.				// So, we do a GetDIBits on nLinesMax rows (since GetDIBits is the				// slow call) and then make nLinesMax calls to SetDIBitsToDevice.  jca 22FEB94				for (j = 0, k = nLinesThisPass-1; j < nLinesThisPass && iOk; j++, k-- )					{					if (k < 0)	DEBUGGER();					iOk = SetDIBitsToDevice(hdcPrint, 0, printer_top+j, off_rect.right - off_rect.left,					1, 0, 0, 0, 1, &bits[localRowSize*k], lpbmi, DIB_RGB_COLORS);					}				// increment the top				printer_top += nLinesThisPass;				centerY -= max_height;				// jca 25APR94 make all the pane rect things tidy.				linesLeft -= nLinesThisPass;                nLinesThisPass = min(linesLeft, nLinesMax);                drawRect.bottom = nLinesThisPass;				}bailout:				if (bmpinfo) DisposHandle(bmpinfo);				if (bitbuf) DisposHandle(bitbuf);				//offscreen->UnSetCurrent();				if (offscreen)					{					if (offscreen->lock)offscreen->UnsetMetaPort();#if 0			// leave offscreen around if possible. Avoids popscrn problems. \\GJR 12/21/93				offscreen->dOffscreen();				offscreen = NULL;#endif //0         	}		}		//JAM 6-3-93 reset the variable changed before to restore to its old value		gGlobalWindowClipMin = saveWindowClipMin;#endif // VWT jca 30MAR94#endif // WINDOWS// } DAS-VR 9/22/93 printing pixMaps AGAIN			view->SetOptions(options);			break;#endif //!VPLAYER		case PICT_DRAW:			#if USE_HMD				// MERGE-HMD draw with the HMD				((Observer*)(view))->DrawHMD(FALSE, FALSE);		// MERGE-HMD			#else				view->Draw(FALSE, FALSE); // BILBIL - TRUE);		// MERGE-HMD			#endif // USE_HMD			break;		default:			// MERGE-HMD [[[ draw with the HMD			#if USE_HMD				((Observer*)(view))->DrawHMD(!inAnimation && FrontApp(), FALSE);		// MERGE-HMD			#else				view->Draw(!inAnimation && FrontApp(), FALSE);		// MERGE-HMD			#endif // USE_HMD			// MERGE-HMD ]]]						if (type != DRAW || lastType != DRAW || GetOptions(VIEW_VELOCITY))				{				Rect r;				VForeColor(&vBlack);				r = aspectEdge1; VPaintRect(&r);				r = aspectEdge2; VPaintRect(&r);				copyRect = dataRect;				}			#if USE_HMD			if ( (((Observer*)(view))->use_hmds) &&				(gHMD) &&				((gHMD->GetType() == HMD_STEREO_PAIR) ||				 (gHMD->GetType() == HMD_CYBERSCOPE)) )			{			Rect r = dataRect;				VForeColor(&vBlack);				VFrameRect(&r);				VForeColor(&vBlack);				VMoveTo(centerX-1, 0); VLineTo(centerX-1, centerY<<1);			}			else if ((((Observer*)(view))->use_hmds) && gHMD)			{            Rect r = dataRect;				VForeColor(&vBlack);				VFrameRect(&r);				VInsetRect(&r, 1, 1);                VFrameRect(&r);			}			else			{				// MERGE-HMD ABD HMD MAR95			#endif // USE_HMD			if (GetOptions(VIEW_CROSSHAIR))				{				VForeColor(&vBlack);				VMoveTo(centerX-10, centerY); VLineTo(centerX+10, centerY);				VMoveTo(centerX, centerY-10); VLineTo(centerX, centerY+10);				// jca 12FEB94 add white sections so we can see the crosshair on				// dark surfaces				VForeColor(&vWhite);				VMoveTo(centerX-10, centerY); VLineTo(centerX-13, centerY);				VMoveTo(centerX+10, centerY); VLineTo(centerX+13, centerY);				VMoveTo(centerX, centerY-10); VLineTo(centerX, centerY-13);				VMoveTo(centerX, centerY+10); VLineTo(centerX, centerY+13);				VForeColor(&vBlack);	  // clean up				}			if (GetOptions(VIEW_VELOCITY))				{				int x, y, i;				x = vcenterX;				y = vcenterY;				for (i = 1; i < 6; i++)					{					// jca 12FEB94 make this be black on white, so it will show up on dark backgrounds.					VForeColor(&vWhite);					VMoveTo(centerX-VGRID_MINUS_WHITE, centerY-y);					VLineTo(centerX+VGRID_PLUS_WHITE, centerY-y);							VMoveTo(centerX-VGRID_MINUS_WHITE, centerY+y);					VLineTo(centerX+VGRID_PLUS_WHITE, centerY+y);							VMoveTo(centerX-x, centerY-VGRID_MINUS_WHITE);					VLineTo(centerX-x, centerY+VGRID_PLUS_WHITE);							VMoveTo(centerX+x, centerY-VGRID_MINUS_WHITE);					VLineTo(centerX+x, centerY+VGRID_PLUS_WHITE);					VForeColor(&vBlack);					VMoveTo(centerX-VGRID_MINUS_BLACK, centerY-y);					VLineTo(centerX+VGRID_PLUS_BLACK, centerY-y);							VMoveTo(centerX-VGRID_MINUS_BLACK, centerY+y);					VLineTo(centerX+VGRID_PLUS_BLACK, centerY+y);							VMoveTo(centerX-x, centerY-VGRID_MINUS_BLACK);					VLineTo(centerX-x, centerY+VGRID_PLUS_BLACK);							VMoveTo(centerX+x, centerY-VGRID_MINUS_BLACK);					VLineTo(centerX+x, centerY+VGRID_PLUS_BLACK);					x += vcenterX;					y += vcenterY;					}                VForeColor(&vWhite);				VMoveTo(centerX-VGRID_MINUS_WHITE, centerY-y);				VLineTo(centerX+VGRID_PLUS_WHITE, centerY-y);						VMoveTo(centerX-VGRID_MINUS_WHITE, centerY+y);				VLineTo(centerX+VGRID_PLUS_WHITE, centerY+y); 				VForeColor(&vBlack);				VMoveTo(centerX-VGRID_MINUS_BLACK, centerY-y);				VLineTo(centerX+VGRID_PLUS_BLACK, centerY-y);						VMoveTo(centerX-VGRID_MINUS_BLACK, centerY+y);				VLineTo(centerX+VGRID_PLUS_BLACK, centerY+y);				VForeColor(&vBlack);	  // clean up				}				#if USE_HMD				}	// MERGE-HMD ABD HMD MAR95				#endif // USE_HMD// ABD MERGE-PRINT [[[// only do MetaCopy if we are actually drawing to the screen#if MACINTOSH	if (fullScreen != NULL && theWindow->Active())		{		Rect destRect = copyRect, r;				/* Icky Mac stuff */		fullScreen->GetRect(&r);		destRect.left += r.left; destRect.right += r.left;		destRect.top += r.top; destRect.bottom += r.top;        fullScreen->SetMetaPort();		if (offscreen != NULL)			offscreen->MetaTo(fullScreen, &copyRect, &destRect);		fullScreen->UnsetMetaPort();		}	else if(!polyCheckMode)MetaCopy(&copyRect);#elif WINDOWS	/*JAM 11/5/93 added line to bottom of walk view so      walk buttons have dark line above them*/	if(!polyCheckMode) {#if VR		VForeColor(&vBlack);		VMoveTo(copyRect.left, copyRect.bottom-1);        VLineTo(copyRect.right, copyRect.bottom-1);#endif //VR		MetaCopy(&copyRect);    }#endif// ABD MERGE-PRINT ]]]			break;		}	gTextureServer->UnlockTextures();	// ABD MERGE-TEXTURE 9/14/93	UnsetMetaPort();	//JAM 17FEB95 low memory walk rendering [[[	//if memory was too low for rendering the walkview, we'd pause for	//a full minute before MyGrowZone() is called.  I inserted this code	//to abort drawing if memory becomes low.  Doesn't appear to be a problem	//in Windows.	#if MACINTOSH	if(gmemoryLowForWalkView)	{		if(gmemoryLowForWalkView == 1)		{			gmemoryLowForWalkView = 2;			AlertMessage(TXT_MEMSHORT);		}	}	//JAM 17FEB95 low memory walk rendering ]]]	#endif		lastType = type;	}	// MERGE-HMD ARROW-KEYS [[[//#if ((VPRO) && (MACINTOSH))#if ((VPRO))// these are the values that the observer bobs up and down by -- these values can// be changed right here, and you can change the number of these items, without// having to worry about changing any constants or anything.  It is all done// automatically!!!int vert_vels[] = { 1, 3, 5, 7, 9, 11, 12, 12, 11, 9, 7, 5, 3, 1, 0, 0 };#define num_vals  (sizeof(vert_vels) / sizeof(vert_vels[0]))#endif // VPRO // MERGE-HMD ARROW-KEYS ]]]intWalkPane::KeyAction(char c,long modifiers)	{	int return_val = FALSE;	// MERGE-HMD ARROW-KEYS	if((buttonDown & modifiers)) return(FALSE);	// MERGE-HMD DEBUG ONLY [[[	#if USE_HMD	// CrystalEyes calibration	if ((gUseHMDs) && (gHMD) && (gHMD->hmd_type == HMD_CRYSTALEYES))	// ABD HMD JUL95	{		if (c == 44)		// < or , character		{		// ABD HMD MAR95		AppPreference *appPref = control->GetPreference();		HMDPreference *hmdPref = (HMDPreference*)appPref->GetPreference(preferHMD);		RenderPreference *renderPref = (RenderPreference*)appPref->GetPreference(preferRenderer);					hmdPref->yblank--;			renderPref->SetChange(TRUE);			control->Request(NULL,msgReset,objDefaults,0);		}		else if (c == 46)	// > or . character		{		AppPreference *appPref = control->GetPreference();		HMDPreference *hmdPref = (HMDPreference*)appPref->GetPreference(preferHMD);		RenderPreference *renderPref = (RenderPreference*)appPref->GetPreference(preferRenderer);					hmdPref->yblank++;			renderPref->SetChange(TRUE);			control->Request(NULL,msgReset,objDefaults,0);		}	}	#endif // USE_HMD	// MERGE-HMD DEBUG ONLY ]]]#if USE_HMD	if (((Observer*)(view))->use_hmds)	{		AppPreference *appPref = control->GetPreference();		HMDPreference *hmdPref = (HMDPreference*)appPref->GetPreference(preferHMD);		RenderPreference *renderPref = (RenderPreference*)appPref->GetPreference(preferRenderer);        #if WINDOWS		if (c == -67)		#else		if ((c == '-') || (c == '_'))		#endif // WINDOWS		{			if ((hmdPref->ipd.l - DblToFixed(0.1).l) > 0.0)			{				hmdPref->ipd.l -= DblToFixed(0.1).l;				renderPref->SetChange(TRUE);				gHMD->ComputeIODandFOV();			 //	control->Request(NULL,msgReset,objDefaults,0);			}		}        #if WINDOWS		else if (c == -69)        #else		else if ((c == '=') || (c == '+'))		#endif // WINDOWS		{			hmdPref->ipd.l += DblToFixed(0.1).l;			renderPref->SetChange(TRUE);            gHMD->ComputeIODandFOV();		 //	control->Request(NULL,msgReset,objDefaults,0);		}	}#endif // USE_HMD// MERGE-HMD ARROW-KEYS [[[#if ((VPRO) && (MACINTOSH))	{	int xV, yV, angxV, angyV, keypad_strafe;	int runxV, runyV, runangxV, runangyV, runkeypad_strafe;	KeyMap theKeys;	int velocity, latVelocity, vertVelocity;	int yawVelocity, pitchVelocity, rollVelocity;	Boolean shift_down = FALSE, option_down = FALSE, control_down = FALSE;	int key_pressed = FALSE;	int first_loop = TRUE;	int vel = 1;	int angvel = 1;	Boolean right_down = FALSE, left_down = FALSE, up_down = FALSE, down_down = FALSE, strafe_left_down = FALSE, strafe_right_down = FALSE;	Boolean last_shift_down = FALSE, last_option_down = FALSE, last_control_down = FALSE;	Boolean last_right_down = FALSE, last_left_down = FALSE, last_up_down = FALSE, last_down_down = FALSE, 		last_strafe_left_down = FALSE, last_strafe_right_down = FALSE;	FFixed vert_pos = FFZero;	int initial_z = view->point.z;	int reset_initial_z;	int vert_positions[num_vals];	long micro_secs;	FFixed next_vert_pos_jump = FFOne;	int i;    int gBounce = FALSE;		// never bounce for now				for ( i = 0 ; i < num_vals ; i++ )			{				vert_positions[i] = initial_z + vert_vels[i];			}						do			{				reset_initial_z = FALSE;			 	xV = 0; yV = 0; angxV = 0; angyV = 0;			 	keypad_strafe = 0;			 	runxV = 0; runyV = 0; runangxV = 0; runangyV = 0;			 	runkeypad_strafe = 0;				velocity = 0; latVelocity = 0; vertVelocity = 0;				yawVelocity = 0; pitchVelocity = 0; rollVelocity = 0;			 	 				// here we check to see what arrow keys are down, and update				// xV and yV appropriately, so that we can get the effect of walking and 				// turning simultaneously like when using the mouse.  Note that we also				// read the option and shift keys this way, and ignore the modifier				// passed in							GetKeys(theKeys);				if (key_pressed)				{					last_option_down = option_down;					last_shift_down = shift_down;					last_control_down = control_down;					last_right_down = right_down;					last_left_down = left_down;					last_up_down = up_down;					last_down_down = down_down;					last_strafe_left_down = strafe_left_down;					last_strafe_right_down = strafe_right_down;				}								// this is a major hack that works but is ugly and should be fixed.  The				// problem is that the KeyMap data structure is probably byte-order				// dependent and doesn't work as document.				option_down = ((theKeys[1] & 4) == 4);				shift_down = ((theKeys[1] & 1) == 1);				control_down = ((theKeys[1] & 8) == 8);				right_down = ((theKeys[3] & 8) == 8) || ((theKeys[2] & 16384) == 16384);				left_down = ((theKeys[3] & 16) == 16) || ((theKeys[2] & 1) == 1);				up_down = ((theKeys[3] & 64) == 64) || ((theKeys[2] & 8) == 8);				down_down = ((theKeys[3] & 32) == 32) || ((theKeys[2] & 4096) == 4096);				strafe_left_down = ((theKeys[2] & 8192) == 8192) || ((theKeys[2] & 2) == 2);	// keypad 3 or 9				strafe_right_down = ((theKeys[2] & 2048) == 2048) || ((theKeys[2] & 16) == 16);	// keypad 1 or 7								key_pressed = right_down || left_down || up_down || down_down ||					strafe_left_down || strafe_right_down;								if (right_down || (last_right_down && !key_pressed))  // right				{						xV -= vel; angxV -= angvel; runxV -= vel+2; runangxV -= angvel+2; 				}				if (left_down || (last_left_down && !key_pressed)) // left				{						xV += vel; angxV += angvel; runxV += vel+2; runangxV += angvel+2; 				}				if (up_down || (last_up_down && !key_pressed)) 	// up				{						yV += vel; angyV += angvel; runyV += vel+2; runangyV += angvel+2; 				}				if (down_down || (last_down_down && !key_pressed))	// down				{						yV -= vel; angyV -= angvel; runyV -= vel+2; runangyV -= angvel+2; 				}									if (strafe_left_down || (last_strafe_left_down && !key_pressed))				{						keypad_strafe += vel; runkeypad_strafe += vel+1; 				}				if (strafe_right_down || (last_strafe_right_down && !key_pressed)) 				{						keypad_strafe -= vel; runkeypad_strafe -= vel+1; 				}									// control key makes us take longer steps				if ((control_down && key_pressed) || (last_control_down && !key_pressed))				{					xV = runxV;					yV = runyV;					angxV = runangxV; 					angyV = runangyV; 					keypad_strafe = runkeypad_strafe;				}				if ((option_down && key_pressed) || (last_option_down && !key_pressed))				{					latVelocity = Velocity(xV);					vertVelocity = Velocity(yV);					reset_initial_z = TRUE;				}				else if ((shift_down && key_pressed) || (last_shift_down && !key_pressed))				{					rollVelocity = AngVelocity(angxV);					pitchVelocity = AngVelocity(angyV);				}				else				{					yawVelocity = -AngVelocity(angxV);					velocity = Velocity(yV);					if (keypad_strafe)						latVelocity = Velocity(keypad_strafe);				}								if (gBounce)				{					// if we are moving forward/back or sliding, we want to bounce					// if we are not pressing any keys, we want to 					if ((velocity != 0) || (latVelocity != 0) || !key_pressed)					{						vertVelocity = vert_positions[vert_pos.intg] - view->point.z;							if (key_pressed)						{							vert_pos.l += next_vert_pos_jump.l;							if (vert_pos.intg >= num_vals)								vert_pos.intg -= num_vals;									}						else						{						int diff = initial_z - view->point.z;													if ((diff == 1) || (diff == -1))								vertVelocity = diff;							else								vertVelocity = diff >> 1;							if (vertVelocity == 0)								vert_pos = FFZero;						}					}					else					{						vert_pos = FFZero;					}				}												StartTimingMicro();				if (GetOptions(VIEW_COLLISIONS))					view->MoveCollision(velocity, latVelocity, vertVelocity,						yawVelocity, pitchVelocity, rollVelocity);				else					view->Move(velocity, latVelocity, vertVelocity,						yawVelocity, pitchVelocity, rollVelocity);						control->Request(NULL, msgUpdate, objObserver, 0);				micro_secs = EndTimingMicro();								// how many values to jump in the ver_pos table?  We want to do the whole table				// (i.e num_vals) in 2 seconds, so if the last frame took 2.0/num_vals seconds,				// then we want to jump one value.  If the last frome took twice that long, then				// we want to jump two values, etc. 				next_vert_pos_jump = DblToFixed((double)-micro_secs / (800000.0/(double)num_vals));									if (next_vert_pos_jump.intg >= 3)				{					next_vert_pos_jump.intg = 3;					next_vert_pos_jump.frac = 0;				}									if (reset_initial_z)				{					initial_z = view->point.z;					for ( i = 0 ; i < num_vals ; i++ )					{						vert_positions[i] = initial_z + vert_vels[i];					}				}								if ((key_pressed) && (first_loop))					return_val = TRUE;				first_loop = FALSE;								// MERGE-GOURAUD-PRO-8 [[[				// use this line if you want to slide in/out				#if 0				if (key_pressed)				{						vel++; angvel++; 				}				else 				{											vel--; angvel--; 				}				if (vel > 3) vel = 3;				if (vel < 0) vel = 0;				if (angvel > 2) angvel = 2;				if (angvel < 0) angvel = 0;				#else				if (key_pressed)				{						vel = 3;					angvel = 2;				}				else 				{						vel = 0;					angvel = 0;				}				#endif				// MERGE-GOURAUD-PRO-8 ]]]								// ¥¥¥Êneed to check here for pending events, like command-period or mouse				// down events, and break out of the loop immediately:  we must reset the				// observer z position however!!!			}			while (key_pressed || (vel != 0) || (angvel != 0)  || (!FFZero(vert_pos)));	}	return return_val;#endif // MACINTOSH// MERGE-HMD ARROW-KEYS ]]]//JAM-WINDOWS-KEYBOARD-NAVIGATION [[[#if WINKEYBOARDVAVIGATION	{	int xV, yV, angxV, angyV, keypad_strafe;	int runxV, runyV, runangxV, runangyV, runkeypad_strafe;	int velocity, latVelocity, vertVelocity;	int yawVelocity, pitchVelocity, rollVelocity;	Boolean shift_down = FALSE, option_down = FALSE, control_down = FALSE;	int key_pressed = FALSE;	int first_loop = TRUE;	int vel = 1;	int angvel = 1;	Boolean right_down = FALSE, left_down = FALSE, up_down = FALSE, down_down = FALSE, strafe_left_down = FALSE, strafe_right_down = FALSE;	Boolean last_shift_down = FALSE, last_option_down = FALSE, last_control_down = FALSE;	Boolean last_right_down = FALSE, last_left_down = FALSE, last_up_down = FALSE, last_down_down = FALSE, 		last_strafe_left_down = FALSE, last_strafe_right_down = FALSE;	FFixed vert_pos = FFZero;	int initial_z = view->point.z;	int reset_initial_z;	int vert_positions[num_vals];	long micro_secs;	FFixed next_vert_pos_jump = FFOne;	int i;	int gBounce = FALSE;		// never bounce for now	MSG testMsg;	int DoNavigation;	//if there are any mouse events pending, turn off movement and	//clear all keyups and keydowns	if(PeekMessage(&testMsg,NULL,WM_MOUSEFIRST,WM_MOUSELAST,PM_NOYIELD|PM_NOREMOVE))	{		WinOptionDown = FALSE;		WinShiftDown = FALSE;		WinControlDown = FALSE;		WinRightDown = FALSE;		WinLeftDown = FALSE;		WinUpDown = FALSE;		WinDownDown = FALSE;		WinStrafeLeftDown = FALSE;	// keypad 1 or 7		WinStrafeRightDown = FALSE;	// keypad 3 or 9		while(PeekMessage(&testMsg,NULL,WM_KEYDOWN,WM_KEYUP,PM_NOYIELD|PM_REMOVE));		return_val = TRUE;		return(return_val);	}    DoNavigation = TRUE;	if(c == UPARROW) {WinUpDown = TRUE; WinDownDown = FALSE; }	else if (c == DOWNARROW) {WinUpDown = FALSE; WinDownDown = TRUE; }	else if(c == RIGHTARROW) {WinLeftDown = TRUE; WinRightDown = FALSE; }	else if(c == LEFTARROW) {WinLeftDown = FALSE; WinRightDown = TRUE; }	else if((c==DOWNLEFTARROW) || (c==UPLEFTARROW)) {WinStrafeLeftDown = FALSE; WinStrafeRightDown = TRUE; }	else if((c==UPRIGHTARROW) || (c==DOWNRIGHTARROW)) {WinStrafeLeftDown = TRUE; WinStrafeRightDown = FALSE; }	else if(c == CTRLKEY) {WinOptionDown = TRUE;}	else if(c == SHIFTKEY) {WinShiftDown = TRUE;}	else if(c == TABKEY) {WinControlDown = TRUE;}	else		{ /*clear movement and pass through to other stuff*/		WinOptionDown = FALSE;		WinShiftDown = FALSE;		WinControlDown = FALSE;		WinRightDown = FALSE;		WinLeftDown = FALSE;		WinUpDown = FALSE;		WinDownDown = FALSE;		WinStrafeLeftDown = FALSE;	// keypad 1 or 7		WinStrafeRightDown = FALSE;	// keypad 3 or 9        DoNavigation = FALSE;		}		if(DoNavigation)        {			for ( i = 0 ; i < num_vals ; i++ )			{				vert_positions[i] = initial_z + vert_vels[i];			}						if(WinUpDown || WinDownDown || WinLeftDown || WinRightDown ||            	WinStrafeLeftDown || WinStrafeRightDown)			{				reset_initial_z = FALSE;			 	xV = 0; yV = 0; angxV = 0; angyV = 0;			 	keypad_strafe = 0;			 	runxV = 0; runyV = 0; runangxV = 0; runangyV = 0;			 	runkeypad_strafe = 0;				velocity = 0; latVelocity = 0; vertVelocity = 0;				yawVelocity = 0; pitchVelocity = 0; rollVelocity = 0;			 	 				// here we check to see what arrow keys are down, and update				// xV and yV appropriately, so that we can get the effect of walking and 				// turning simultaneously like when using the mouse.  Note that we also				// read the option and shift keys this way, and ignore the modifier				// passed in				if (key_pressed)				{					last_option_down = option_down;					last_shift_down = shift_down;					last_control_down = control_down;					last_right_down = right_down;					last_left_down = left_down;					last_up_down = up_down;					last_down_down = down_down;					last_strafe_left_down = strafe_left_down;					last_strafe_right_down = strafe_right_down;				}								// this is a major hack that works but is ugly and should be fixed.  The				// problem is that the KeyMap data structure is probably byte-order				// dependent and doesn't work as document.				option_down = WinOptionDown;				shift_down = WinShiftDown;				control_down = WinControlDown;				right_down = WinRightDown;				left_down = WinLeftDown;				up_down = WinUpDown;				down_down = WinDownDown;				strafe_left_down = WinStrafeLeftDown;	// keypad 3 or 9				strafe_right_down = WinStrafeRightDown;	// keypad 1 or 7								key_pressed = right_down || left_down || up_down || down_down ||					strafe_left_down || strafe_right_down;								if (right_down || (last_right_down && !key_pressed))  // right				{						xV -= vel; angxV -= angvel; runxV -= vel+2; runangxV -= angvel+2; 				}				if (left_down || (last_left_down && !key_pressed)) // left				{						xV += vel; angxV += angvel; runxV += vel+2; runangxV += angvel+2; 				}				if (up_down || (last_up_down && !key_pressed)) 	// up				{						yV += vel; angyV += angvel; runyV += vel+2; runangyV += angvel+2; 				}				if (down_down || (last_down_down && !key_pressed))	// down				{						yV -= vel; angyV -= angvel; runyV -= vel+2; runangyV -= angvel+2; 				}									if (strafe_left_down || (last_strafe_left_down && !key_pressed))				{						keypad_strafe += vel; runkeypad_strafe += vel+1; 				}				if (strafe_right_down || (last_strafe_right_down && !key_pressed)) 				{						keypad_strafe -= vel; runkeypad_strafe -= vel+1; 				}									// control key makes us take longer steps				if ((control_down && key_pressed) || (last_control_down && !key_pressed))				{					xV = runxV;					yV = runyV;					angxV = runangxV; 					angyV = runangyV; 					keypad_strafe = runkeypad_strafe;				}				if ((option_down && key_pressed) || (last_option_down && !key_pressed))				{					latVelocity = Velocity(xV);					vertVelocity = Velocity(yV);					reset_initial_z = TRUE;				}				else if ((shift_down && key_pressed) || (last_shift_down && !key_pressed))				{					rollVelocity = AngVelocity(angxV);					pitchVelocity = AngVelocity(angyV);				}				else				{					yawVelocity = -AngVelocity(angxV);					velocity = Velocity(yV);					if (keypad_strafe)						latVelocity = Velocity(keypad_strafe);				}								if (gBounce)				{					// if we are moving forward/back or sliding, we want to bounce					// if we are not pressing any keys, we want to 					if ((velocity != 0) || (latVelocity != 0) || !key_pressed)					{						vertVelocity = vert_positions[vert_pos.intg] - view->point.z;							if (key_pressed)						{							vert_pos.l += next_vert_pos_jump.l;							if (vert_pos.intg >= num_vals)								vert_pos.intg -= num_vals;									}						else						{						int diff = initial_z - view->point.z;													if ((diff == 1) || (diff == -1))								vertVelocity = diff;							else								vertVelocity = diff >> 1;							if (vertVelocity == 0)								vert_pos = FFZero;						}					}					else					{						vert_pos = FFZero;					}				}												if (GetOptions(VIEW_COLLISIONS))					view->MoveCollision(velocity, latVelocity, vertVelocity,						yawVelocity, pitchVelocity, rollVelocity);				else					view->Move(velocity, latVelocity, vertVelocity,						yawVelocity, pitchVelocity, rollVelocity);						control->Request(NULL, msgUpdate, objObserver, 0);								// how many values to jump in the ver_pos table?  We want to do the whole table				// (i.e num_vals) in 2 seconds, so if the last frame took 2.0/num_vals seconds,				// then we want to jump one value.  If the last frome took twice that long, then				// we want to jump two values, etc. 				next_vert_pos_jump = DblToFixed((double)-micro_secs / (800000.0/(double)num_vals));									if (next_vert_pos_jump.intg >= 3)				{					next_vert_pos_jump.intg = 3;					next_vert_pos_jump.frac = 0;				}									if (reset_initial_z)				{					initial_z = view->point.z;					for ( i = 0 ; i < num_vals ; i++ )					{						vert_positions[i] = initial_z + vert_vels[i];					}				}								if ((key_pressed) && (first_loop))					return_val = TRUE;				first_loop = FALSE;								// MERGE-GOURAUD-PRO-8 [[[				// use this line if you want to slide in/out				#if 0				if (key_pressed)				{						vel++; angvel++; 				}				else 				{											vel--; angvel--; 				}				if (vel > 3) vel = 3;				if (vel < 0) vel = 0;				if (angvel > 2) angvel = 2;				if (angvel < 0) angvel = 0;				#else				if (key_pressed)				{						vel = 3;					angvel = 2;				}				else 				{						vel = 0;					angvel = 0;				}				#endif				// MERGE-GOURAUD-PRO-8 ]]]								// ¥¥¥Êneed to check here for pending events, like command-period or mouse				// down events, and break out of the loop immediately:  we must reset the				// observer z position however!!!					if(!PeekMessage(&testMsg,NULL,WM_KEYDOWN,WM_KEYUP,PM_NOYIELD|PM_NOREMOVE))			    {					PostMessage(this->theWindow->GetParentWindow(), WM_KEYDOWN, c, 0);				}			}			return_val = TRUE;	        return return_val;        }	}#endif //WINKEYBOARDVAVIGATION//JAM-WINDOWS-KEYBOARD-NAVIGATION ]]]#if WINDOWS	if ((fullScreen != NULL)&&(c == ' '))		{		Point p;        ULong l;		//BUGBUG - do popup menu stuff here!		l = GetMessagePos();		p.v = HIWORD(l);		p.h = LOWORD(l);#if VWT		walkMenu->Action(walkMenu->PopUp(this,p,0),modifiers);#elif VPLAYER		((Player*)ActiveDocument())->walkMenu->Action(				((Player*)ActiveDocument())->walkMenu->PopUp(this,p,0),modifiers);#endif //VWT		VDisplay(DRAW);		return (TRUE);		}#endif //WINDOWS	if ((fullScreen != NULL)&&(c == V_ESCAPE))		{#if VWT		walkMenu->Action(menuFullScreen,128L); // BG - calling menu action fixes bus error#elif VPLAYER		((Player*)ActiveDocument())->walkMenu->Action(menuVPlayFullScr,128L);#endif //VWT		return(TRUE);		}	else//#endif //WINDOWS	return(V_Pane::KeyAction(c, modifiers));	}#if WINKEYBOARDVAVIGATION		//JAM-WINDOWS-KEYBOARD-NAVIGATION [[[intWalkPane::KeyUpAction(char c,long modifiers)	{	int return_val = FALSE;	// MERGE-HMD ARROW-KEYS	MSG testMsg;	if((buttonDown & modifiers)) return(FALSE);	//if there are any mouse events pending, turn off movement and	//clear all keyups and keydowns	if(PeekMessage(&testMsg,NULL,WM_MOUSEFIRST,WM_MOUSELAST,PM_NOYIELD|PM_NOREMOVE))	{		WinOptionDown = FALSE;		WinShiftDown = FALSE;		WinControlDown = FALSE;		WinRightDown = FALSE;		WinLeftDown = FALSE;		WinUpDown = FALSE;		WinDownDown = FALSE;		WinStrafeLeftDown = FALSE;	// keypad 1 or 7		WinStrafeRightDown = FALSE;	// keypad 3 or 9		while(PeekMessage(&testMsg,NULL,WM_KEYDOWN,WM_KEYUP,PM_NOYIELD|PM_REMOVE));		return_val = TRUE;		return(return_val);	}	if(c == UPARROW) {WinUpDown = FALSE; }	else if(c == DOWNARROW) {WinDownDown = FALSE; }	else if(c == RIGHTARROW) {WinLeftDown = FALSE;}	else if(c == LEFTARROW) {WinRightDown = FALSE; }	else if((c==DOWNLEFTARROW) || (c==UPLEFTARROW)) {WinStrafeRightDown = FALSE; }	else if((c==UPRIGHTARROW) || (c==DOWNRIGHTARROW)) {WinStrafeLeftDown = FALSE; }	else if(c == CTRLKEY) {WinOptionDown = FALSE;}	else if(c == SHIFTKEY) {WinShiftDown = FALSE;}	else if(c == TABKEY) {WinControlDown = FALSE;}	else		{		WinOptionDown = FALSE;		WinShiftDown = FALSE;		WinControlDown = FALSE;		WinRightDown = FALSE;		WinLeftDown = FALSE;		WinUpDown = FALSE;		WinDownDown = FALSE;		WinStrafeLeftDown = FALSE;	// keypad 1 or 7		WinStrafeRightDown = FALSE;	// keypad 3 or 9		return(FALSE);		}	if(!PeekMessage(&testMsg,NULL,WM_KEYDOWN,WM_KEYUP,PM_NOYIELD|PM_NOREMOVE))	{		if(WinUpDown)        {		PostMessage(this->theWindow->GetParentWindow(), WM_KEYDOWN, UPARROW, 0);		}		else if(WinDownDown)		{		PostMessage(this->theWindow->GetParentWindow(), WM_KEYDOWN, DOWNARROW, 0);		}		else if(WinLeftDown)		{		PostMessage(this->theWindow->GetParentWindow(), WM_KEYDOWN, RIGHTARROW, 0);		}		else if(WinRightDown)		{		PostMessage(this->theWindow->GetParentWindow(), WM_KEYDOWN, LEFTARROW, 0);		}		else if(WinStrafeLeftDown)		{		PostMessage(this->theWindow->GetParentWindow(), WM_KEYDOWN, UPRIGHTARROW, 0);		}		else if(WinStrafeRightDown)		{		PostMessage(this->theWindow->GetParentWindow(), WM_KEYDOWN, DOWNLEFTARROW, 0);		}	}	return_val = TRUE;    return(return_val);	}#endif // WINKEYBOARDVAVIGATION //JAM-WINDOWS-KEYBOARD-NAVIGATION ]]]voidWalkPane::MouseDown(Point pt, long modifier)	{//  DAS-VR-WALKBPNE 8/25/93 select surface/polyhedron#if ((VR) || (VPRO))			// MERGE-GOURAUD-PRO	int tool;	struct ObjSpec obj;	Polyhedron *grp;	#if VR			// MERGE-GOURAUD-PRO	if (!control->walkBPane) DEBUGGER();		tool = control->walkBPane->GetTool();	// MERGE-GOURAUD-PRO [[[#endif // VR#if VPRO	if (control->GetType() != toolCRTLLibrary)	//MERGE-GOURAUD-PRO-3    {	tool = control->three_d_pick_button->GetTool(0);	if (tool == b3DPICK_WALK)		tool = WTOOL_WALK;	else if (tool == b3DPICK_OBJECT)		tool = WTOOL_POLY;	else if (tool == b3DPICK_SURFACE)		tool = WTOOL_SURF;	}	else    	tool = WTOOL_WALK;	//MERGE-GOURAUD-PRO-3#endif // VPRO	// MERGE-GOURAUD-PRO ]]]	#if USE_HMD	if ((((Observer*)view)->use_hmds) && (tool != WTOOL_WALK))      	{	char str[256] = "Cannot do 3D selection in stereo mode.";		AlertMessage(str);		return;    }    #endif // USE_HMD	#if (!VPLAYER)	if(tool != WTOOL_WALK)		{		FindPoly(control,pt,&obj);		switch(tool)			{			case WTOOL_SURF: // DAS 9/6/93				if(obj.surfNum !=NO_SURFACE_SPEC)					{					Controller *ctrl;					int length,i,tp;					CAVEnvironment	*environment=0;					FFixed scale;					int crtl_type = toolCRTLSurface;		// ABD MERGE25					// PRO-17 don't select locked polys					if (((CAVPolyhedron *)obj.poly)->editState & EDIT_LOCKED)                    	break;					// ABD MERGE25 [[[					if (obj.surfSide == SURF_INSIDE)						crtl_type = insideView;					else if (obj.surfSide == SURF_OUTSIDE)						crtl_type = outsideView;					// ABD MERGE25 ]]]										length=((CAVWalkController*)(control->controller))->						controllers->ALength();					for(i=0;i<length;i++)						{						((CAVWalkController*)(control->controller))->controllers->Get(i,&ctrl);						tp=ctrl->GetType();						if(toolCRTLSurface == tp)							{							environment=((CadControl*)ctrl)->environment;							break;							}						#if VR						else if(toolCRTLDesign == tp && ((CAVWalkController*)(control->controller))->savePanes==0)						#else						else if(toolCRTLDesign == tp)						#endif							{							environment=((CadControl*)ctrl)->environment;							break;							}						}					if(environment)scale=environment->GetScale();					else scale=FFOne;										((CAVWalkController*)(control->controller))->					LaunchEditor(obj.poly,						environment->GetScale(),						((CAVPolyhedron *)obj.poly)->GetSurfDef(obj.surfNum),						Pt3DFFZero,crtl_type);		// ABD MERGE25					VSendMessage(MSG_CENTER_SURFACE_EDITOR);					}				break;			case WTOOL_POLY:// { DAS-VR-FIX 9/22/93 select groups				grp=obj.poly->FindGroup();				if(grp->type==POLY_GROUP)					control->Request(grp,msgEdit,objCenterPoly,!(modifier&MULTIPLE_SELECT));				else					control->Request(obj.poly,msgEdit,objCenterPoly,!(modifier&MULTIPLE_SELECT));// } DAS-VR-FIX 9/22/93 select groups				#if VR				if (!((WalkDocument*)ActiveDocument())->currently_3d)					((WalkDocument*)ActiveDocument())->SwitchLibs(FALSE);				#endif				break;			}		}	else#endif //!VPLAYER#endif // ((VR) || (VPRO))		if (!GetOptions(VIEW_BUTTON))		control->Request(NULL, msgReset, objAxis, 0);		#if !WINDOWS		// 2JUN94 jca corrected for the DELL version of VR.  We lose a mouse up		// somewhere along the line, and so things are locked at the wrong time        // and we get killed by the all the alertMessages.		// ABD MERGE-TEXTURE 9/13/93		// lock all the texture offscreens		gTextureServer->LockTextures();#endif // !WINDOWS	}voidWalkPane::MouseUp(Point pt, long modifier)	{//  DAS-VR-WALKBPNE 8/25/93 select surface/polyhedron#if VR && (!VPLAYER)	if(control->walkBPane->GetTool()==WTOOL_WALK)#endif 	if (GetOptions(VIEW_BUTTON))		control->Request(NULL, msgReset, objAxis, 0);#if !WINDOWS		// 2JUN94 jca corrected for the DELL version of VR.  We lose a mouse up		// somewhere along the line, and so things are locked at the wrong time        // and we get killed by the all the alertMessages.		// ABD MERGE-TEXTURE 9/13/93		// unlock all the texture offscreens		gTextureServer->UnlockTextures();#endif // !WINDOWS	}intWalkPane::GetAction(long action,long modifiers)	{	AppPreference	*appPreference;	DefaultPreference *defPref;	Point3DFFixed	pt;	Angle3DFFixed	ang;		switch(action)		{		case MSG_RESETTILT:			view->ResetTilt();			control->Request(NULL, msgReset, objObserver, 0);#if VPLAYER			VDisplay(DRAW);#endif //VPLAYER			break;		case MSG_E_WLIGHT:			control->Request(NULL,msgEdit,objLight,0);			break;		case  MSG_PRINT: /* PRINT */#if !SAVE_DISABLED 	// ABD-SAVE-DISABLED#if (!VPLAYER)			// ABD MERGE-PRINT			// for printing the walkpane, we want to use banding, and for banding, we don't			// want to call StartPage/EndPage, but we do want to call StartDoc/EndDoc.  So			// we set this magic variable in the pane, to let printing know not to call			// StartPage/EndPage.#if WINDOWS			bandPrint = TRUE;        // ABD MERGE-PRINT#endif //WINDOWS			VOutput(theWindow->GetVPrint());#if WINDOWS	        bandPrint = FALSE;		// reset variable just for the hell of it.		// ABD MERGE-PRINT#endif //WINDOWS#endif //!VPLAYER#endif // SAVE_DISABLED 	// ABD-SAVE-DISABLED			break;		case MSG_VIEWHOME:/* BRING THE OBSERVER HOME */			appPreference = control->GetPreference();			defPref = (DefaultPreference*)appPreference->GetPreference(preferDefaults);			((Observer  *)view)->GetPosition(&pt,&ang);			((Observer  *)view)->SetPosition(defPref->homePosition,FFAngleZero);			control->Request(NULL, msgUpdate, objObserver, 0);			break;		case MSG_HOMEVIEW:/* BRING THE OBSERVER HOME */			appPreference = control->GetPreference();			defPref = (DefaultPreference*)appPreference->GetPreference(preferDefaults);			((Observer  *)view)->GetPosition(&(defPref->homePosition),&ang);			break;		default:			return(FALSE);			break;		}		return(TRUE);	}voidWalkPane::TrackHelp(Point pt,long modifier)// DAS-VWINDOWS 9/30/93	{	char *text = NULL;	Rect rect;	int xV,yV;	// { DAS-VR-HELP 9/30/93#if VWT	if (text == NULL && GetOptions(VIEW_CROSSHAIR))		{		rect.left = centerX-10;		rect.right = centerX+10;		rect.top = centerY-10;		rect.bottom = centerY+10;		if (VPtInRect(pt, &rect)) text = TXTB_CROSSHAIRWALK;		}	if (text == NULL && GetOptions(VIEW_VELOCITY))		{		rect = dataRect;		rect.top = centerY - 5;		rect.bottom = centerY + 5;		if (VPtInRect(pt, &rect)) text = TXTB_VELOCITYGRID;		}	if (text == NULL && GetOptions(VIEW_VELOCITY))		{		rect = dataRect;		rect.left = centerX - 5;		rect.right = centerX + 5;		if (VPtInRect(pt, &rect)) text = TXTB_VELOCITYGRID;		}	if (text == NULL)		{		rect = dataRect;		text = TXTB_WALKVIEW;		}#elif VR	int	tool;	//BILBIL - used to find which walk pane button is down - 12/8/93	xV = (pt.h - centerX) / vcenterX;	yV = (centerY-pt.v) / vcenterY;	xV=(xV<0)?1:(xV==0)?2:3;	yV=(yV<0)?10:(yV==0)?20:30;	xV+=yV;	if (modifier & V_OPTION)		{		switch(xV)			{			case 11:text=TXTB_ULOPTION; break;			case 12:text=TXTB_UMOPTION; break;			case 13:text=TXTB_UROPTION; break;			case 21:text=TXTB_MLOPTION; break;			case 22:text=TXTB_MM; break;			case 23:text=TXTB_MROPTION; break;			case 31:text=TXTB_LLOPTION; break;			case 32:text=TXTB_LMOPTION; break;			case 33:text=TXTB_LROPTION; break;			}		}	else if (modifier & V_SHIFT)		{		switch(xV)			{			case 11:text=TXTB_ULSHIFT; break;			case 12:text=TXTB_UMSHIFT; break;			case 13:text=TXTB_URSHIFT; break;			case 21:text=TXTB_MLSHIFT; break;			case 22:text=TXTB_MM; break;			case 23:text=TXTB_MRSHIFT; break;			case 31:text=TXTB_LLSHIFT; break;			case 32:text=TXTB_LMSHIFT; break;			case 33:text=TXTB_LRSHIFT; break;			}		}	else		{		switch(xV)			{			case 11:text=TXTB_UL; break;			case 12:text=TXTB_UM; break;			case 13:text=TXTB_UR; break;			case 21:text=TXTB_ML; break;			case 22:text=TXTB_MM; break;			case 23:text=TXTB_MR; break;			case 31:text=TXTB_LL; break;			case 32:text=TXTB_LM; break;			case 33:text=TXTB_LR; break;			}		}#if (!VPLAYER)// BILBIL - if selecting surface or object use proper help string - 12/8/93 [[[	tool = control->walkBPane->GetTool();	switch(tool)		{		case WTOOL_SURF:			text = TXTB_SELECTASURFACE;        	break;		case WTOOL_POLY:			text = TXTB_SELECTANOBJECT;			break;		default:        	break;		}// BILBIL ]]]#endif //!VPLAYER#endif// } DAS-VR-HELP 9/30/93	BalloonHotRect(&rect, pt);	Bubble(pt, &rect, text);	}voidWalkPane::Track(Point pt, long modifier, int inside)	{	int xV, yV;	int velocity = 0, latVelocity = 0, vertVelocity = 0;	int yawVelocity = 0, pitchVelocity = 0, rollVelocity = 0;	int tool;	//MERGE-GOURAURD-3		if (!control) DEBUGGER();#if VR // jca 14JAN94	if (!control->walkBPane) DEBUGGER();#endif // VR// { DAS-VR-WALKBPNE 8/25/93 select surface/polyhedron#if VR && (!VPLAYER)// DAS-VR-ARROWS 9/11/93 this is to insure that there is always an arrow when editing	if(control->walkBPane->GetTool()!=WTOOL_WALK)		{		VSetCursor(vCursorArrow);		return;		}#endif// } DAS-VR-WALKBPNE 8/25/93 select surface/polyhedron#if VPRO //MERGE-GOURAUD-PRO-3	if((control->GetType() != toolCRTLLibrary)		&& (tool = control->three_d_pick_button->GetTool(0)!=b3DPICK_WALK))		{		VSetCursor(vCursorArrow);		return;		}#endif	if (!inside) return;	VSetCursor(vCursorCross);	if (GetOptions(VIEW_BUTTON) && !(modifier & buttonDown) ||		!GetOptions(VIEW_BUTTON) && (modifier & buttonDown))		return;	xV = (pt.h - centerX) / vcenterX;	yV = (pt.v - centerY) / vcenterY;	if (modifier & V_OPTION)		{		latVelocity = Velocity(xV);		vertVelocity = Velocity(yV);		}	else if (modifier & V_SHIFT)		{		rollVelocity = AngVelocity(xV);		pitchVelocity = AngVelocity(yV);		}	else		{		yawVelocity = -AngVelocity(xV);		velocity = Velocity(yV);		}// MERGE18 [[[	if (GetOptions(VIEW_COLLISIONS))		view->MoveCollision(velocity, latVelocity, vertVelocity,			yawVelocity, pitchVelocity, rollVelocity);	else		view->Move(velocity, latVelocity, vertVelocity,			yawVelocity, pitchVelocity, rollVelocity);// MERGE18 ]]]	control->Request(NULL, msgUpdate, objObserver, 0);#if MACINTOSHif (modifier & V_CONTROL)control->Request(NULL, msgReset, objAxis, 0);#endif	}#if WINDOWS/* jca 5APR94 return TRUE if we are flying with the button up(button down is not set)*/intWalkPane::ContinuousTrack(void)	{	return(gWithoutButtonDown & BUTTONUP_FLYING);    }#endif // WINDOWSintWalkPane::Velocity(int velocity)	{	if (velocity > 0)		{		if (velocity > 6) velocity = 6;		velocity = 1 << (velocity + 1);		}	else if (velocity < 0)		{		velocity = -velocity;		if (velocity > 6) velocity = 6;		velocity = 1 << (velocity + 1);		velocity = -velocity;		}		return(velocity);	}		intWalkPane::AngVelocity(int velocity)	{	if (velocity > 0)		{		if (velocity > 6) velocity = 6;		velocity = 1 << (velocity - 1);		}	else if (velocity < 0)		{		velocity = -velocity;		if (velocity > 6) velocity = 6;		velocity = 1 << (velocity - 1);		velocity = -velocity;		}		return(velocity);	}voidWalkPane::SetOptions(int opt)	{	options = opt;	}intWalkPane::GetOptions(int mask)	{	return(options & mask);	}int		WalkPane::TakeSnapShot(V_Buffer *buffer,int snapShotFormat)	{	int	err = 0;#if (!VPLAYER)	AppPreference *appPref;	TranslatorPreference	*transPref;	V_Picture *pict;	BMPWriter	*bmp;#if VWT && !SPECIAL_EDITION         	// merge SE, vrmadness		// GJR 7/4/95/* jca 17 Sept 93.  Not in VR { */	EPSBase *epsf;	TIFFWriter *tiff;	int	viewOptions;#endif // VWT.  jca 17 Sept 93 }    V_Offscreen *imageScreen;	Rect r;	Point	p;	int bmapDepth;	// jca VR1.0.1 23AUG94// there a bug in the texturing code that messes up the snapshot if we don't// let it set up the depth itself (under Windows).  Jeff said he'd look into it.// In newText8.cpp, the code that sets the texturing routines looks at the depth// variable, rather than calling the FindDepth routine (like flash does).  Bad.#if MACINTOSH   // jca VR1.0.1 23AUG94  [[[	bmapDepth = 8;	// typically, we want it to be 8.#elif WINDOWS	bmapDepth = -1;  // get around a texturing bug#endif // MACINTOSH   // jca VR1.0.1 23AUG94   ]]]	appPref = control->GetPreference();	transPref = (TranslatorPreference*)appPref->GetPreference(preferTranslator);	if(transPref->screenSize==screenCustom)		r = transPref->outputRect;	else 		{		ScreenSize(transPref->screenSize,&p,theWindow);		r.left = r.top = 0;		r.right = p.h;		r.bottom = p.v;		}		switch(snapShotFormat)		{		case formatPICT:			pict=new(V_Picture);			pict->cPicture(transPref->bitmapFlag);			pict->SetDepth(transPref->outputColorDepth);			pict->PutRect(&r);			VOutput(pict);										pict->IOPictFile(buffer);			pict->dPicture();			break;#if WINDOWS// BILBIL - ELVIS - what is the deal here ????		case formatBMP:			bmp = new(BMPWriter);            imageScreen = new(V_Offscreen);			imageScreen->cOffscreen(&r, bmapDepth, NULL, NULL);			imageScreen->SetDisplayType(DISPLAY_PICT);			bmp->cBMPWriter(buffer, imageScreen);			bmp->DrawImage(this);			bmp->WriteImage(transPref);						bmp->dBMPWriter();			imageScreen->dOffscreen();			break;#endif //WINDOWS#if VWT && !SPECIAL_EDITION         	// merge SE, vrmadness		// GJR 7/4/95/* jca 17 Sept 93.  Not in VR { */		case formatTIFF:			tiff = new(TIFFWriter);			imageScreen = new(V_Offscreen);			imageScreen->cOffscreen(&r, bmapDepth, NULL, NULL);			imageScreen->SetDisplayType(DISPLAY_PICT);					tiff->cTIFFWriter(buffer, imageScreen);						tiff->DrawImage(this);			tiff->WriteImage(transPref);						tiff->dTIFFWriter();			imageScreen->dOffscreen();			break;		case formatEPS:        case formatIllustrator:			switch(snapShotFormat)		    	{		    	case formatEPS:		    		epsf=new(EPSF);					epsf->cEPSBase(buffer);		    		break;		    	case formatIllustrator:		    	default:		    		epsf=new(EPSF_Adobe1_1);					epsf->cEPSBase(buffer);		    		break;				}			// set up the right drawing options			viewOptions = view->GetOptions(0xFFFF);			view->SetOptions(viewOptions &~DRAW_TEXTURES);			view->SetOptions(viewOptions &~DRAW_GOURAUD);	// PRO-14			epsf->SetDepth(transPref->EPSColorFlag ? depth : 0);			if (transPref->EPSFDevice==EPSForThePC)	/* the machine code is stored here */				epsf->SetPCFlags();			else /*if (transPref->EPSFDevice==EPSForTheMac)*/				epsf->SetMacFlags();			if (transPref->EPSPreviewFlag == TRUE)				epsf->SetPreviewFlag(TRUE);			epsf->PutRect(&r);			epsf->MakeHeader();			err = VOutput(epsf);									if(!err)epsf->MakeFooter();									if((!err) && (transPref->EPSPreviewFlag == TRUE))				{				switch (transPref->EPSFDevice)	/* stores the machine type */					{					case EPSForTheMac:						((V_File *)buffer)->OpenResource(FALSE);						pict=new(V_Picture);						pict->cPicture(FALSE);						pict->PutRect(&r);						pict->SetDepth(transPref->EPSColorFlag ? depth : 0);						err = VOutput(pict);						if(!err)err = pict->IOResource((V_File*)buffer,256,NULL);						pict->dPicture();						((V_File *)buffer)->CloseResource();						break;					case EPSForThePC:						tiff = new(TIFFWriter);						imageScreen = new(V_Offscreen);						imageScreen->cOffscreen(&r, bmapDepth, NULL, NULL);						imageScreen->SetDisplayType(PICT_DRAW);									tiff->cTIFFWriter(buffer, imageScreen);						tiff->WriteIntel();												tiff->DrawImage(this);						tiff->WriteImage(transPref);															tiff->dTIFFWriter();						imageScreen->dOffscreen();						break;					}				}			if (!err) epsf->UpdateHeader();			// reset texture options			view->SetOptions(viewOptions);			epsf->dEPSBase();            break;#endif // VWT.  jca 17 Sept 93 }		}#endif //(!VPLAYER)	return err;	}	#define SMOOTH_EXPANSION 2#if (!VPLAYER)intWalkPane::Animation(V_Buffer *buffer,int animationFormat)	{#if !SPECIAL_EDITION         	// merge SE, vrmadness		// GJR 7/4/95	AppPreference *appPref;	TranslatorPreference	*transPref;	AlertDialog	*memAlert;	Observer  *observer;	AnimatorMovie	*ADAnimMovie;	AVIMovie		*aviMovie;	QuickTimeMovie	*qtimeMovie;	PICSMovie		*picsMovie;	WalkMovie		*movie;	V_Array	*newPath,*oldPath;	ObserverStep **twoStep;	Rect r;	Point3DFFixed point;	Angle3DFFixed angle;	Point	p;	char	str[256];	long	numFrames,i,length;	long	fromFrame,toFrame,frameCount;	int		isBitMap,outDepth,delta;	int		tmpOptions;	int		err;		err = 0;		observer = (Observer  *)view;			point = observer->FFpoint;	angle = observer->FFangle;	appPref = control->GetPreference();	transPref = (TranslatorPreference*)appPref->GetPreference(preferTranslator);	outDepth = transPref->outputColorDepth;	if(transPref->screenSize==screenCustom)		r = transPref->outputRect;	else 		{		ScreenSize(transPref->screenSize,&p,theWindow);		r.left = r.top = 0;		r.right = p.h;		r.bottom = p.v;		}	oldPath = observer->path;	fromFrame = transPref->startFrame;	toFrame = transPref->endFrame;	if(transPref->smoothFlag)		{		newPath = SmoothPath(oldPath,fromFrame,toFrame,SMOOTH_EXPANSION);		observer->path = newPath;		}	else		{		newPath = new(V_Array);		newPath->cArray(0,sizeof(ObserverStep*),4);		observer->CopyPath(newPath,fromFrame,toFrame);		observer->path = newPath;		}		if(fromFrame>toFrame)delta = -1; else delta = 1;	numFrames = newPath->ALength();	MeterSetTotal(numFrames);	tmpOptions = options;	options &= ~(VIEW_CROSSHAIR|VIEW_VELOCITY);	SetOptions(options);			switch(animationFormat)		{		case  formatPICS:			picsMovie = new(PICSMovie);            picsMovie->cWalkMovie(transPref, buffer);			movie = picsMovie;			break;		case formatQuickTime:			qtimeMovie = new(QuickTimeMovie);            qtimeMovie->cWalkMovie(transPref, buffer);			movie = qtimeMovie;			break;		case formatFLIC:			ADAnimMovie = new(AnimatorMovie);            ADAnimMovie->cWalkMovie(transPref, buffer);			movie = ADAnimMovie;			break;		case formatAVI:			aviMovie = new(AVIMovie);            aviMovie->cWalkMovie(transPref, buffer);			movie = aviMovie;			break;		}	err = movie->BeginMovie(&r, outDepth, numFrames);	inAnimation = TRUE;	err = movie->AnimateMovie(this, observer);    inAnimation = FALSE;	observer->SetFFPoint(point);	observer->SetFFAngle(angle);	err = movie->EndMovie();	movie->dWalkMovie();    	observer->path = oldPath;	twoStep = (ObserverStep **)newPath->Use();	for( i = 0; i < numFrames; i++,twoStep++)		(*twoStep)->dPathStep();	newPath->Unuse();	newPath->dArray();	SetOptions(tmpOptions);	return err;#else // !SPECIAL_EDITION	return (0);#endif // !SPECIAL_EDITION	}#endif //!VPLAYER// ABD HMD MAR95 removed globals here// ABD HMD MAR95 removed strings herevoidMenuWalk::ctheMenu()	{	cMenu(TXTM_WALK,0);	#if VPRO && !SPANISH		SetMenuKeyPos(menuWalkKeyPos);	#endif //!SPANISH  VPRO		Append(TXTM_BUTTONDN);	Append(TXTM_CROSSHAIR);    Append(TXTM_GRID);        #if VPRO // MERGE-GOURAUD-PRO-7 [[[	AppendSeparator();		// ABD WILLIAMS MERGE11 9/11/93	Append(TXTM_RBEST);	Append(TXTM_RBETTER);	Append(TXTM_RFAST);	Append(TXTM_RFASTEST);	#else	AppendSeparator();		// ABD WILLIAMS MERGE11 9/11/93	Append(TXTM_NORMALSP);	Append(TXTM_FASTERSP);	Append(TXTM_FASTESTSP);	#endif // VPRO // MERGE-GOURAUD-PRO-7 ]]]	AppendSeparator();		// ABD WILLIAMS MERGE11 9/11/93	Append(TXTM_VCRRECORD);	Append(TXTM_VCRPLAY);	Append(TXTM_VCRSTOP);	AppendSeparator();		// ABD WILLIAMS MERGE11 9/11/93	Append(TXTM_ASPECTRT);	Append(TXTM_FULLSCR);	#if USE_HMD	AppendSeparator();				// MERGE-ABD HMD MAR95	Append(TXTM_STEREO);			// MERGE-ABD HMD MAR95	Append(TXTM_CROSSEYES);			// MERGE-ABD HMD MAR95	#endif // USE_HMD	SetPriority(averagePriority);	#if VPRO // MERGE-GOURAUD-PRO-7		#if GERMAN			SetKeyPos(menuRFastest, menuFastestSpeedKeyPos);			SetKeyPos(menuRFast, menuFasterSpeedKeyPos);			SetKeyPos(menuVCRPlay, menuVCRPlayKeyPos);			SetKeyPos(menuVCRStop, menuVCRStopKeyPos);			SetKeyPos(menuAspectRatio, menuAspectRatioKeyPos);		#elif SPANISH			SetKeyPos(menuRBest, menuRBestKeyPos);			SetKeyPos(menuRFastest, menuRFastestKeyPos);			SetKeyPos(menuVCRPlay, menuVCRPlayKeyPos);			SetKeyPos(menuAspectRatio, menuAspectRatioKeyPos);			SetKeyPos(menuFullScreen, menuFullScreenKeyPos);		#else // default ENGLISH			SetKeyPos(menuRFastest, menuFastestSpeedKeyPos);			SetKeyPos(menuRFast, menuFasterSpeedKeyPos);			SetKeyPos(menuFullScreen, menuFullScreenKeyPos);        #endif // German	#else	//SetKeyPos(menuFastestSpeed, menuFastestSpeedKeyPos);	#endif // MERGE-GOURAUD-PRO-7    #if USE_HMD	SetKeyPos(menuUseHMDs, menuUseHMDsKeyPos);	SetKeyPos(menuCrossEyes, menuCrossEyesKeyPos);    #endif // USE_HMD	SetMenuEuroKey(menuWalkEuroKey);	SetEuroKey(menuButtonDown, menuButtonDownEuroKey);	SetEuroKey(menuCrossHair, menuCrossHairEuroKey);	SetEuroKey(menuGrid, menuGridEuroKey);	SetEuroKey(menuRBest, menuRBestEuroKey);	SetEuroKey(menuRBetter, menuRBetterEuroKey);	SetEuroKey(menuRFast, menuRFastEuroKey);	SetEuroKey(menuRFastest, menuRFastestEuroKey);	SetEuroKey(menuVCRRecord, menuVCRRecordEuroKey);	SetEuroKey(menuVCRPlay, menuVCRPlayEuroKey);	SetEuroKey(menuVCRStop, menuVCRStopEuroKey);	SetEuroKey(menuAspectRatio, menuAspectRatioEuroKey);	SetEuroKey(menuFullScreen, menuFullScreenEuroKey);	SetEuroKey(menuAspectRatio, menuAspectRatioEuroKey);	SetEuroKey(menuFullScreen, menuFullScreenEuroKey);	#if USE_HMD	SetEuroKey(menuUseHMDs, menuUseHMDsEuroKey);	SetEuroKey(menuCrossEyes, menuCrossEyesEuroKey);	#endif // USE_HMD	}voidMenuWalk::SetController(ViewController *ctrl)	{	controller = ctrl;	}voidMenuWalk::Preempt()	{	AppPreference		*appPref;	NavigatePreference	*navigatePref;	RenderPreference	*renderPref;	long	rMode,oMode,norm,faster,fastest;	long	best,better;	int		recState;		recState = controller->GetRecordState();	if(toolCRTLLibrary==controller->GetType())		recState = 0;		appPref = controller->GetPreference();	navigatePref = (NavigatePreference*)appPref->GetPreference(preferNavigate);	renderPref = (RenderPreference*)appPref->GetPreference(preferRenderer);	rMode = renderPref->renderDrawMode;	oMode = renderPref->renderOpenMode;	norm = faster = fastest = FALSE;	if (rMode == (RENDER_FILL|RENDER_FRAME))		{		if (oMode == (RENDER_SEEIN|RENDER_SEEOUT|RENDER_SEECONN))			norm = TRUE;		else if (oMode == (RENDER_SEECONN))			faster = TRUE;		}	else if (rMode == RENDER_FRAME)		fastest = TRUE;	Select(menuButtonDown, (navigatePref->navigateMode & NAVIG_BUTTON) ? TRUE : FALSE);	Select(menuCrossHair, (navigatePref->navigateMode & NAVIG_CROSS) ? TRUE : FALSE);    Select(menuGrid, (navigatePref->navigateMode & NAVIG_GRID) ? TRUE : FALSE);	#if VPRO	// MERGE-GOURAUD-PRO-7	rMode = renderPref->renderDrawMode;	oMode = renderPref->renderOpenMode;	best = better = faster = fastest = FALSE;	if (rMode == (RENDER_FILL|RENDER_FRAME|RENDER_NOTEXTURES|RENDER_NOGOURAUD))		{		if (oMode == (RENDER_SEEIN|RENDER_SEEOUT|RENDER_SEECONN))			better = TRUE;		else if (oMode == (RENDER_SEECONN))			faster = TRUE;		}	else if (rMode == (RENDER_FRAME|RENDER_NOTEXTURES|RENDER_NOGOURAUD))		fastest = TRUE;	else if (rMode == (RENDER_FILL|RENDER_FRAME))		best = TRUE;	Select(menuRBest,best);	Select(menuRBetter,better);	Select(menuRFast,faster);	Select(menuRFastest,fastest);	#else	Select(menuNormalSpeed,norm);	Select(menuFasterSpeed,faster);	Select(menuFastestSpeed,fastest);	#endif // VPRO	// MERGE-GOURAUD-PRO-7		if(recState)		{		Select(menuVCRRecord,recState&WALK_RECORD);		Select(menuVCRPlay,recState&WALK_PLAY);		Select(menuVCRStop,recState&WALK_STOP);		}	else		{		Activate(menuVCRRecord,FALSE);		Activate(menuVCRPlay,FALSE);		Activate(menuVCRStop,FALSE);		}			Select(menuAspectRatio,navigatePref->aspectState);		// MERGE-HMD [[[	#if USE_HMD	{	// ABD HMD MAR95	HMDPreference *hmdPref = (HMDPreference*)appPref->GetPreference(preferHMD);	Select(menuUseHMDs, (((Observer*)(((ViewController*)(controller))->view))->use_hmds));	Select(menuCrossEyes, hmdPref->cross_eyed);	}	#endif // USE_HMD	// MERGE-HMD ]]]	}#include "VDocumnt.h" // JOEBOBvoidMenuWalk::Action(int num, long modifier)	{	AppPreference		*appPref;	NavigatePreference	*navigatePref;	RenderPreference	*renderPref;	int 				itemState;	// jca 17FEB94	#if USE_HMD	HMDPreference *hmdPref;    #endif // USE_HMD	appPref = controller->GetPreference();    #if USE_HMD	hmdPref = (HMDPreference*)appPref->GetPreference(preferHMD);	#endif // USE_HMD	switch (num)		{		case menuButtonDown:			navigatePref = (NavigatePreference*)appPref->GetPreference(preferNavigate);			if(navigatePref->navigateMode & NAVIG_BUTTON) navigatePref->navigateMode ^= NAVIG_BUTTON;			else navigatePref->navigateMode |= NAVIG_BUTTON;			itemState = ((navigatePref->navigateMode&NAVIG_BUTTON) ? TRUE : FALSE);	// jca 17FEB94 set the state for the item, then use it.			Select(menuButtonDown, itemState);			controller->SetOptions(0);#if WINDOWS			if (itemState)	gWithoutButtonDown &= ~BUTTONUP_FLYING; // jca 17FEB94 set the global used to tell if we should be flying without button down.			else			gWithoutButtonDown |= BUTTONUP_FLYING; // jca 17FEB94 set the global used to tell if we should be flying without button down.#endif			/* controller->Request(NULL,msgUpdate,objView,0);*/			break;					case menuCrossHair: 			navigatePref = (NavigatePreference*)appPref->GetPreference(preferNavigate);			if(navigatePref->navigateMode & NAVIG_CROSS) navigatePref->navigateMode ^= NAVIG_CROSS;			else  navigatePref->navigateMode |= NAVIG_CROSS;			Select(menuCrossHair, (navigatePref->navigateMode&NAVIG_CROSS) ? TRUE : FALSE );			controller->SetOptions(0);			controller->Request(NULL,msgUpdate,objView,0);			break;					case menuGrid:			navigatePref = (NavigatePreference*)appPref->GetPreference(preferNavigate);			if(navigatePref->navigateMode & NAVIG_GRID) navigatePref->navigateMode ^= NAVIG_GRID;			else  navigatePref->navigateMode |= NAVIG_GRID;			Select(menuGrid, (navigatePref->navigateMode&NAVIG_GRID) ? TRUE : FALSE );			controller->SetOptions(0);			controller->Request(NULL,msgUpdate,objView,0);			break;					#if VPRO		case menuRBest: //BILBIL this is the same as better right now!			renderPref = (RenderPreference*)appPref->GetPreference(preferRenderer);			Select(menuRBest, TRUE);			Select(menuRBetter, FALSE);			Select(menuRFast, FALSE);			Select(menuRFastest, FALSE);			renderPref->renderDrawMode = RENDER_FILL|RENDER_FRAME;			renderPref->renderOpenMode = RENDER_SEEIN|RENDER_SEEOUT|RENDER_SEECONN;			renderPref->SetChange(TRUE);			controller->Request(NULL,msgReset,objDefaults,0);			break;		case menuRBetter:			renderPref = (RenderPreference*)appPref->GetPreference(preferRenderer);			Select(menuRBest, FALSE);			Select(menuRBetter, TRUE);			Select(menuRFast, FALSE);			Select(menuRFastest, FALSE);			renderPref->renderDrawMode = RENDER_FILL|RENDER_FRAME|RENDER_NOTEXTURES|RENDER_NOGOURAUD;			renderPref->renderOpenMode = RENDER_SEEIN|RENDER_SEEOUT|RENDER_SEECONN;			renderPref->SetChange(TRUE);			controller->Request(NULL,msgReset,objDefaults,0);			break;		case menuRFast:			renderPref = (RenderPreference*)appPref->GetPreference(preferRenderer);			Select(menuRBest, FALSE);			Select(menuRBetter, FALSE);			Select(menuRFast, TRUE);			Select(menuRFastest, FALSE);			renderPref->renderDrawMode = RENDER_FILL|RENDER_FRAME|RENDER_NOTEXTURES|RENDER_NOGOURAUD;			renderPref->renderOpenMode = RENDER_SEECONN;			renderPref->SetChange(TRUE);			controller->Request(NULL,msgReset,objDefaults,0);			break;		case menuRFastest:			renderPref = (RenderPreference*)appPref->GetPreference(preferRenderer);			Select(menuRBest, FALSE);			Select(menuRBetter, FALSE);			Select(menuRFast, FALSE);			Select(menuRFastest, TRUE);			renderPref->renderDrawMode = RENDER_FRAME|RENDER_NOTEXTURES|RENDER_NOGOURAUD;			renderPref->renderOpenMode = 0;			renderPref->SetChange(TRUE);			controller->Request(NULL,msgReset,objDefaults,0);			break;		#else		case menuNormalSpeed:			renderPref = (RenderPreference*)appPref->GetPreference(preferRenderer);			Select(menuNormalSpeed, TRUE);			Select(menuFasterSpeed, FALSE);			Select(menuFastestSpeed, FALSE);			renderPref->renderDrawMode = RENDER_FILL|RENDER_FRAME;			renderPref->renderOpenMode = RENDER_SEEIN|RENDER_SEEOUT|RENDER_SEECONN;			controller->SetOptions(0);			controller->Request(NULL,msgUpdate,objView,0);			break;								case menuFasterSpeed: 			renderPref = (RenderPreference*)appPref->GetPreference(preferRenderer);			Select(menuNormalSpeed, FALSE);			Select(menuFasterSpeed, TRUE);			Select(menuFastestSpeed, FALSE);			renderPref->renderDrawMode = RENDER_FILL|RENDER_FRAME;			renderPref->renderOpenMode = RENDER_SEECONN;			controller->SetOptions(0);			controller->Request(NULL,msgUpdate,objView,0);			break;		case menuFastestSpeed: 			renderPref = (RenderPreference*)appPref->GetPreference(preferRenderer);			Select(menuNormalSpeed, FALSE);			Select(menuFasterSpeed, FALSE);			Select(menuFastestSpeed, TRUE);			renderPref->renderDrawMode = RENDER_FRAME;			renderPref->renderOpenMode = 0;			controller->SetOptions(0);			controller->Request(NULL,msgUpdate,objView,0);			break;		#endif // VPRO // MERGE-GOURAUD-PRO-7		case menuVCRRecord: controller->SetRecordState(WALK_RECORD);break;		case menuVCRPlay: controller->SetRecordState(WALK_PLAY);break; 		case menuVCRStop: controller->SetRecordState(WALK_STOP);break; 		case menuAspectRatio: 			navigatePref = (NavigatePreference*)appPref->GetPreference(preferNavigate);			navigatePref->aspectState = !navigatePref->aspectState;			controller->SetPreference(appPref,TRUE);			break;					case menuFullScreen:			state = !GetState(num);			Select(num, state);			controller->FullScreen(state);			break;		// MERGE-HMD DEBUG ONLY [[[		#if USE_HMD		case menuUseHMDs:		// Use HMDs			((Observer*)(((ViewController*)(controller))->view))->use_hmds = 				!((Observer*)(((ViewController*)(controller))->view))->use_hmds;			((Observer*)(((ViewController*)(controller))->view))->drawing->Sequence();							if (((Observer*)(((ViewController*)(controller))->view))->use_hmds)		// ABD HMD MAR95			{			int err;				err = ((Observer*)(((ViewController*)(controller))->view))->CreateHMD(hmdPref->hmd_type);									if (err != HMD_NO_ERR)				{					DEBUGGER();				}								}			else			{				if (gHMD)					gHMD->RestoreOldFilmWidth();			}			renderPref = (RenderPreference*)appPref->GetPreference(preferRenderer);			renderPref->SetChange(TRUE);			controller->Request(NULL,msgReset,objDefaults,0);			Select(menuUseHMDs, (((Observer*)(((ViewController*)(controller))->view))->use_hmds));			break;		case menuCrossEyes:		// cross eyes			if (((Observer*)(((ViewController*)(controller))->view))->use_hmds)		// ABD HMD MAR95			{				hmdPref->cross_eyed = !hmdPref->cross_eyed;				hmdPref->SetChange(TRUE);			}			renderPref = (RenderPreference*)appPref->GetPreference(preferRenderer);			renderPref->SetChange(TRUE);			controller->Request(NULL,msgReset,objDefaults,0);			Select(menuCrossEyes, hmdPref->cross_eyed);			break;					#endif // USE_HMD		// MERGE-HMD DEBUG ONLY ]]]		}	}