/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "LitPane.h"#include "LitCntrl.h"#include "CVTumObj.h"#include "CVEnvirn.h"#include "TumAxis.h"#include "Polyhdrn.h"#include "PolyConv.h"#include "Surface.h"#include "WalkDefs.h"#include "PolyDefs.h"#include "Geometry.h"#include "Light.h"#include "Drawing.h"#include "AppMssgs.h"#include "AppText.h"#include "Misc.h"#include "WMenus.h"/* THIS IS FOR PRIORITY enum */#include "BallHelp.h"#include "Space.h"#include "VGraphic.h"#include "VMain.h"#include <math.h>#define mSPACE_MOMENTUM		1/*** struct LightPane ***********************************************/voidLightPane::cPane(int flag)	{	V_MenuMgr	*mgr;	FFixed	cubeSide = INITFIXXED(100,0);			backColor = vWhite;	polyinit=FALSE;	tumble = new(OrientObject);	SpacePane::cPane(flag);	cubeSpace  = space;	lampSpace  = ((Space *)new(Space))->cSpace();		MakeCube(cubeSide);	MakeLamp();	tumble->SetDrawState(TUMBLE_FILL|TUMBLE_FRAME);	mgr = GetMenuMgr();	menu = new(MenuLight);	menu->ctheMenu();	mgr->Append(menu);	}void LightPane::SetPolyhedron(Polyhedron * p)	{	LightModel *copy;	if(!polyinit)		{		copy = new(LightModel);		copy->cLightModel();		p->GetLightModel()->Copy(copy);		polyhedron->SetLightModel(copy);		polyinit=TRUE;		}	}	voidLightPane::dPane(void)	{	polyhedron->dPolyhedron();/*	lampPolyhedron->dPolyhedron();*/	lamp->dCAVTumbleObject();	nirvana->dWalkDrawing();	studio->dWalkDrawing();		menu->dtheMenu();		SpacePane::dPane();	}voidLightPane::SetController(Controller *ctrl)	{	controller = ctrl;	}	voidLightPane::TrackHelp(Point pt,long modifier)// DAS-VWINDOWS 9/30/93	{// { DAS-VR-HELP 9/30/93#if VWT	Rect r;		r = dataRect;	BalloonHotRect(&r,pt);	Bubble(pt,&r,TXTB_LIGHTVIEW);#endif// } DAS-VR-HELP 9/30/93	}/* Display() recalculates all of the shades on the subject (CubePoly), and * then draws the cube, and the lamp if appropriate.  The lamp and cube are * sorted simply by checking the y-coordinate of the lamp. */voidLightPane::Display(int type,int offsetx,int offsety)	{	Rect r,wr;	int direction,lampfront;		 r = dataRect;	 wr = VMaxRect;	origin.h = -r.right>>1;	origin.v = -r.bottom>>1;	tumble->environment->SetEnvironment(&r,&wr,origin,scale,depth);	lamp->environment->SetEnvironment(&r,&wr,origin,lampScale,depth);	if(!lampVisible)tumble->Update(space->m);	else  lamp->Update(space->m);		if(-DRAW == type)		{		if(!lampVisible)tumble->Update(space->m);		else  lamp->Update(space->m);		}	else		{		tumble->Update(cubeSpace->m);		lamp->Update(lampSpace->m);		}		UpdateSource();	SetMetaPort();		VForeColor(&backColor);	VPaintRect(&r);	VForeColor(&vBlack);		NewY(direction,space->m,256,0,0);	lampfront=direction<0;	if (lampfront) tumble->Display();	if(light)		{		if (!light->active) VPenMode(vSrcOr); 					if (lampVisible)			{						lamp->Display(); 			}		VSetPenNormal();		}	if (!lampfront) tumble->Display();		MetaCopy(&r);	UnsetMetaPort();	}void LightPane::CalcSize(Rect *r,Point *p,int type,int warning)	{	controller->GetPlace(r,warning,objLight);	}void LightPane::SizeNotify() 	{	Rect r;	int h,v;		h = ( dataRect.right - dataRect.left ) >> 2;	v = ( dataRect.bottom - dataRect.top ) >> 2;	r.top = centerY - v;	r.bottom = centerY + v;	r.left = centerX - h;	r.right = centerX + h;	scale = tumble->Fit(&r);		h = ( dataRect.right - dataRect.left ) >> 3;	v = ( dataRect.bottom - dataRect.top ) >> 3;	r.top = centerY - v;	r.bottom = centerY + v;	r.left = centerX - h;	r.right = centerX + h;	lampScale = lamp->Fit(&r);	}/* UpdateSource() updates the light in the drawing's light list, based on the lamp's * space (which the user controls).  This info is then used to update the shades on * the various surfaces of the cube. */voidLightPane::UpdateSource()	{	Surface* surface;	if (!lampVisible) return;	OldX(light->source.x,cubeSpace->m,lampSpace->m[A][X],lampSpace->m[A][Y],lampSpace->m[A][Z]);	OldY(light->source.y,cubeSpace->m,lampSpace->m[A][X],lampSpace->m[A][Y],lampSpace->m[A][Z]);	OldZ(light->source.z,cubeSpace->m,lampSpace->m[A][X],lampSpace->m[A][Y],lampSpace->m[A][Z]);	light->source.x >>= 6;	light->source.y >>= 6;	light->source.z >>= 6;	/*XYZZY  this is really really really bad.  It makes assumptions about the  polyhedron type which may become invalid.  It needs a better interface  with the polyhedron object.  Actually, polyhedron should support light source  colors with light source surface features and SetLightSource() method, but this  will not happen soon, so this code assumes that polyhedra are designed with  the top and bottoms as the first and last surfaces which was true on 10/27/90  XYZZY*//*DUDE  speaking of really really really bad.  I need to jump in here to set the changed		flag, which I'd rather do on a mouse up than everytime through the track.  For 		right now, this is the only place I can be assured to catch a change flag event.		I admittedly have a limited knowledge of this editor, so there may be a better		spot, but I can't scope it out if there is.  2/3/91  DUDE*/	plc(controller)->SetChange(TRUE);		if (!light->active)lamp->polyhedron->SetColor(lamp->polyhedron->GetColor(SURF_OUTSIDE),0x8000,SURF_OUTSIDE); 	else lamp->polyhedron->SetColor(lamp->polyhedron->GetColor(SURF_OUTSIDE),0xFFFF,SURF_OUTSIDE); 	lamp->polyhedron->piece->surfaces->Get(0,&surface);	surface->outsideShade=light->color;	lamp->polyhedron->piece->surfaces->Get(lamp->polyhedron->piece->surfaces->ALength()-1,&surface);	surface->outsideShade=light->color;	polyhedron->CalcShade();	}	voidLightPane::Track(Point p,long modifiers,int inside)	{	Point	tp = lastPt;		if (!inside) return;		VSetCursor(vCursorHand);	SpacePane::Track(p,modifiers,inside);	}/*=========================================================================*	int TumblePane::MouseDown(Point p,long modifiers)*-------------------------------------------------------------------------*/voidLightPane::MouseDown(Point p,long modifiers)	{		if(modifiers&doubleClick)		{		int		sel;		p.h+=origin.h;		p.v+=origin.v;		if(NO_MARK != (sel = tumble->Find(p)))			{			FrontSurface(sel);			controller->Request(NULL,msgEdit,objAxis,0);			}		}	else SpacePane::MouseDown(p,modifiers);	}/*=========================================================================*	int LightPane::GetAction( long action, long modifiers )*-------------------------------------------------------------------------*/int LightPane::GetAction(long action,long modifiers)	{		switch(action)		{			case  MSG_MOMENTUM: momentum =! momentum; break;		case  MSG_APPLY: 			controller->Request(this,msgEdit,objView,0);  			plc(controller)->SetChange(FALSE);			break;		case  MSG_REVERT: /* Revert */			controller->Request(this,msgInit,objLight,0);  			controller->Request(this,msgEdit,objPreference,0);			plc(controller)->SetChange(FALSE);			break;		case  MSG_ADDLIGHT: 			controller->Request(this,msgCreate,objLight,0); 			polyhedron->CalcShade();			VDisplay(DRAW);			break;					case  MSG_REMLIGHT: 			controller->Request(this,msgDestroy,objLight,0); 			polyhedron->CalcShade();			VDisplay(DRAW);			break;					default: return(FALSE); break;		}			return(TRUE);	}/* Shows or hides the lamp, based on flag */voidLightPane::ShowLamp(int flag)	{	lampVisible = flag;	}/* InstallLight() sets the current light in the lightpane.  It handles indices to * ambient lights or the subject, in which case the lamp is made invisible. */voidLightPane::InstallLight(struct Light *newLight)	{	int visible;		light = newLight;	if(light)	subject = light->brightness<0;	else subject=TRUE;	if (subject)		{		ambient = FALSE;		visible = FALSE;		}	else		{		ambient = light->Ambient();		visible = !ambient;		}	if (visible) space = lampSpace; else space = cubeSpace;		if (ambient && light) backColor = light->color; 	else backColor = vWhite;			if (!visible)		{		ShowLamp(visible);		VDisplay(DRAW);		return;		}			NewX(lampSpace->m[A][X],cubeSpace->m,light->source.x,light->source.y,light->source.z);	NewY(lampSpace->m[A][Y],cubeSpace->m,light->source.x,light->source.y,light->source.z);	NewZ(lampSpace->m[A][Z],cubeSpace->m,light->source.x,light->source.y,light->source.z);	space->Normalize();	ShowLamp(visible);	SetColor(); /* this calls VDisplay() */	}/* SetColor() sets the color of the current light, or of the subject if there is * no current light. */voidLightPane::SetColor(void)	{	if (subject) polyhedron->SetColor(light->color,0xFFFF,SURF_SHARED); else if (light->Ambient())  backColor = light->color;	polyhedron->CalcShade();	VDisplay(DRAW);	}voidLightPane::SetPin(int newpin)	{	lampSpace->SetPin(newpin);	cubeSpace->SetPin(newpin);		}/* MakeLamp() creates a prism with the given dimensions and number of sides. */voidLightPane::MakeLamp()	{	CAVEnvironment	*environment;/* MJU */	LightModel	*lm;	Light	*l;	V_Array	*ffoutl;	PointFFixed pt;	FFixed	tmp25 = INITFIXXED(25,0);	FFixed	tmp100 = INITFIXXED(150,0);	FFixed	tmp200 = INITFIXXED(250,0);	int i,num = 8;	double phi;		nirvana = new(WalkDrawing);	nirvana->cWalkDrawing(NULL);	lm = nirvana->polyhedron->GetLightModel();	lm->AddLight(l = ((Light *)new(Light))->cLight());	l->SetAmbient();	l->SetShade(0x6000);	lm->AddLight(l = ((Light *)new(Light))->cLight());	l->SetSource(0,256,0);	l->SetShade(0xA000);	lm->AddLight(l = ((Light *)new(Light))->cLight());	l->SetSource(256,0,0);	l->SetShade(0xA000);	lm->AddLight(l = ((Light *)new(Light))->cLight());	l->SetSource(-256,0,0);	l->SetShade(0xA000);	ffoutl = new(V_Array);	ffoutl->cArray(0,sizeof(PointFFixed),4);	for (i=0; i<num; i++)		{		phi = i*6.282/num;		pt.h = DblToFixed(sin(phi));		pt.v = DblToFixed(cos(phi));		pt.h = FFMult(tmp25,pt.h);		pt.v = FFMult(tmp25,pt.v);		ffoutl->Append(&pt);		}		(lampPolyhedron = new(Polyhedron))->cPolyhedron(nirvana);	lampPolyhedron->CreateInflate(INFL_X,INFL_EXTRUDE,ffoutl,tmp200,tmp100);	lampPolyhedron->SetColor(vWhite,0xFFFF,SURF_SHARED);	lampPolyhedron->drawing->polyhedron->Install(lampPolyhedron);	ffoutl->dArray();	lamp = new(CAVTumbleObject);	lamp->cCAVTumbleObject();	environment = new(CAVEnvironment);/* MJU */	environment->cCAVEnvironment();/* MJU */	lamp->SetEnvironment(environment);/* MJU */	lamp->SetPolyhedron(lampPolyhedron);	lamp->SetDrawState(TUMBLE_FILL|TUMBLE_FRAME);	}voidMenuLight::ctheMenu()	{	cMenu(TXTT_LITEDITOR,0);	Append(TXTM_APPLY);	Append(TXTM_REVERT);	AppendSeparator();		// ABD WILLIAMS MERGE11 9/11/93	Append(TXTM_LITNEW);	Append(TXTM_LITDEL);	#if !SPANISH    	SetKeyPos(menuLightApply, menuLightApplyKeyPos);		SetKeyPos(menuLightRemove, menuLightRemoveKeyPos);	#endif // SPANISH	SetMenuEuroKey(menuLightEuroKey);	SetEuroKey(menuLightApply, menuLightApplyEuroKey);	SetEuroKey(menuLightRevert, menuListRevertEuroKey);	SetEuroKey(menuLightAdd, menuLightAddEuroKey);	SetEuroKey(menuLightRemove, menuLightRemoveEuroKey);	SetPriority(averagePriority);	}	voidMenuLight::dtheMenu()	{	dMenu();	}voidMenuLight::Action(int num, long modifier)	{	switch(num)		{		case menuLightApply: VSendMessage(MSG_APPLY); break;		case menuLightRevert: VSendMessage(MSG_REVERT); break;			case menuLightAdd: VSendMessage(MSG_ADDLIGHT); break;			case menuLightRemove: VSendMessage(MSG_REMLIGHT); break;		}	}