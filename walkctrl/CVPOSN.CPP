/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  * Platform: 	MACINTOSH 	X *				WINDOWS		X *------------------------------------------------------------------------------ */#include "VTypes.h"#include "CVPosn.h"#include "CadPosn.h"#include "VMath.h"#include "Cntrl.h"#include "DesCntrl.h"#include "CVEnvirn.h"#include "Polyhdrn.h"#include "VGraphic.h"#include <string.h>	#include <math.h>	FFixed threeSixty = INITFIXXED(360,0x0000);#define TEXT_HEIGHT	16#define LOCK_SYMBOL	62#if MACINTOSH #if JAPANESE  #define TEXT_GAP			10  #define CHARACTER_OFFSET	15 #else  #define TEXT_GAP			10  #define CHARACTER_OFFSET	8 #endif // JAPANESE#elif WINDOWS #if JAPANESE  #define TEXT_GAP			8  #define CHARACTER_OFFSET	15 #else  #define TEXT_GAP			8  #define CHARACTER_OFFSET	9 #endif // JAPANESE#endif // MACINTOSHvoid CAVPosition::cItem()	{			controller = NULL;	state = 1;	deltaFlag = 0;	id = 0;	textLength = 0;	V_Text::cItem();	font = vAppFont;	size = vAppFontSize;	}FFixed CAVPosition::GetValue() { return(value); }void  CAVPosition::SetValue(FFixed newValue) { value = newValue; }void CAVPosition::DisplayValue(char *str)	{	Rect r;	r = bounds;	VEraseRect(&r);	r.left+=2;r.bottom-=1;r.top=r.bottom-7;	VDrawText(str,0,strlen(str),&r);	}	void CAVPosition::Display()	{	Rect	r;	r = bounds;	r.top-=1;	r.bottom+=1;	r.left -=1;	r.right+=1;	VSetPenNormal();	VFrameRect(&r);	DisplayTitle();	}	void CAVPosition::DisplayTitle()	{		Rect r;	char *pStr;		SetUp();			pStr = (char *)HDeref(text);	r = bounds;	r.left-=CHARACTER_OFFSET;//	VDrawChar(*pStr,&r);	VDrawText(pStr, 0, TextLength(), &r);	if(DELTA_MARK&deltaFlag)		{		VMoveTo(bounds.left-7,bounds.top);		VLineTo(bounds.left-7,bounds.top+2);		VLineTo(bounds.left-5,bounds.top+2);		VLineTo(bounds.left-5,bounds.top);		VLineTo(bounds.left-7,bounds.top);		}	}	void  CAVPosition::SetController(Controller *ctrl) { controller = ctrl; }	void  CAVPosition::SetID(int d) { id = d; }	int   CAVPosition::GetID() { return id; }	void  CAVPosition::SetState(int newstate) { state = newstate; }int CAVPosition::GetState(void) { return(state); }void  CAVPosition::SetDeltaFlag(int f) { deltaFlag = f; }	int  CAVPosition::Track(Point pt, long modifier) { return(FALSE); }int CAVPosition::Action(char c,long modifier) { return(TRUE); }FFixed CAVPosition::CalcValue(TrackData *data,CAVEnvironment *e)	{ 	return(value);	}// jca 21APR95 added for japanese and multi-char CAVPositions     [[[void CAVPosition::SetText(strPtr str)	{	V_Text::SetText(str);	textLength = V_Text::TextLength();     // keep a local copy for greater speed	}int CAVPosition::TextLength(void)	{	if (textLength)		return(textLength);  // if there is one, we've set it.	else		return(V_Text::TextLength());  // if textLength is unset, something is weird.  Double-check.    }// jca 21APR95 added for japanese and multi-char CAVPositions    ]]]/*========================================================================= *-----------------------------------------------------------------------*/FFixed CAVPosX::CalcValue(TrackData *data,CAVEnvironment *e)	{ 	FFixed	val1;	if(INFL_X != e->GetAxis()) value = data->point.x;	else ppc(controller)->GetDepth(&val1,&value,trackX);	return(value);	}	FFixed CAVPosY::CalcValue(TrackData *data,CAVEnvironment *e)	{ 	FFixed	val1;	if(INFL_Y != e->GetAxis()) value = data->point.y;	else ppc(controller)->GetDepth(&val1,&value,trackY);	return(value);	}	FFixed CAVPosZ::CalcValue(TrackData *data,CAVEnvironment *e)	{ 	FFixed	val1;	if(INFL_Z != e->GetAxis())  value = data->point.z;	else  ppc(controller)->GetDepth(&val1,&value,trackZ);	return(value);	}FFixed CAVPosDX::CalcValue(TrackData *data,CAVEnvironment *e)	{ 	FFixed	val1;	if(INFL_X != e->GetAxis()) value = FFSub(data->point.x,data->anchor.x);	else 		{		ppc(controller)->GetDepth(&val1,&value,trackZ); 		value = FFSub( val1, value); 		}	return(value);	}	FFixed CAVPosDY::CalcValue(TrackData *data,CAVEnvironment *e)	{ 	FFixed	val1;	if(INFL_Y != e->GetAxis())  value = FFSub(data->point.y,data->anchor.y); 	else 		{		ppc(controller)->GetDepth(&val1,&value,trackY); 		value = FFSub( val1, value); 		}	return(value);	}FFixed CAVPosDZ::CalcValue(TrackData *data,CAVEnvironment *e)	{ 	FFixed	val1;	if(INFL_Z != e->GetAxis())  value = FFSub(data->point.z,data->anchor.z);	else 		{		ppc(controller)->GetDepth(&val1,&value,trackZ); 		value = FFSub( val1, value); 		}	return(value);	}	FFixed CAVPosH::CalcValue(TrackData *data,CAVEnvironment *e)	{ 	Point3DFFixed	tp;	tp = e->Translate3DFFixed(TO_CAD,data->point);	value = tp.x;	return(value);	}FFixed CAVPosV::CalcValue(TrackData *data,CAVEnvironment *e)	{ 	Point3DFFixed	tp;	tp = e->Translate3DFFixed(TO_CAD,data->point);	value = tp.y;	return(value);	}FFixed CAVPosDH::CalcValue(TrackData *data,CAVEnvironment *e)	{ 	Point3DFFixed	tp,ta;	tp = e->Translate3DFFixed(TO_CAD,data->point);	ta = e->Translate3DFFixed(TO_CAD,data->anchor);	value = FFSub(tp.x,ta.x);	return(value);	}FFixed CAVPosDV::CalcValue(TrackData *data,CAVEnvironment *e)	{ 	Point3DFFixed	tp,ta;	tp = e->Translate3DFFixed(TO_CAD,data->point);	ta = e->Translate3DFFixed(TO_CAD,data->anchor);	value = FFSub(tp.y,ta.y);	return(value);	}FFixed CAVPosFloor::CalcValue(TrackData *data,CAVEnvironment *e)	{ 	FFixed	val1;	ppc(controller)->GetDepth(&val1,&value,e->GetAxis()); 	return(value);	}FFixed CAVPosDepth::CalcValue(TrackData *data,CAVEnvironment *e)	{ 	FFixed	val1;	ppc(controller)->GetDepth(&val1,&value,e->GetAxis());	value = FFSub( val1, value);	return(value);	}FFixed CAVPosAngle::CalcValue(TrackData *data,CAVEnvironment *e)	{ 		value = data->angle.yaw;	if(180<value.intg)value = FFSub(value,threeSixty);	return(value);	}		FFixed CAVPosLine2D::CalcValue(TrackData *data,CAVEnvironment *e)	{ 	Point3DFFixed	tp,ta;	FFixed	horz,vert;	double	xx,yy;		tp = e->Translate3DFFixed(TO_CAD,data->point);	ta = e->Translate3DFFixed(TO_CAD,data->anchor);	xx = FixedToDbl(horz = FFSub(tp.x,ta.x));	yy = FixedToDbl(vert = FFSub(tp.y,ta.y));	value = DblToFixed(sqrt(xx*xx+yy*yy));		return(value);	}FFixed CAVScaleH::CalcValue(TrackData *data,CAVEnvironment *e)	{ 	Point3DFFixed	tp,ta,ts;	tp = e->Translate3DFFixed(TO_CAD,data->point);	ta = e->Translate3DFFixed(TO_CAD,data->anchor);	ts = e->Translate3DFFixed(TO_CAD,data->scale);	tp.x = FFSub(tp.x,ta.x);	ts.x = FFSub(ts.x,ta.x);	if(FFZero(tp.x)||FFZero(ts.x))value = FFOne;	else value = FFDiv(tp.x,ts.x); 	return(value);	}FFixed CAVScaleV::CalcValue(TrackData *data,CAVEnvironment *e)	{ 	Point3DFFixed	tp,ta,ts;	tp = e->Translate3DFFixed(TO_CAD,data->point);	ta = e->Translate3DFFixed(TO_CAD,data->anchor);	ts = e->Translate3DFFixed(TO_CAD,data->scale);	tp.y = FFSub(tp.y,ta.y);	ts.y = FFSub(ts.y,ta.y);	if(FFZero(tp.y)||FFZero(ts.y))value = FFOne;	else value = FFDiv(tp.y,ts.y); 	return(value);	}