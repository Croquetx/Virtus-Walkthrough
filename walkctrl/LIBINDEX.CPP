/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				David W. Easter *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "LibIndex.h"#include "WalkBuff.h"#include "VMDL.h"#include "VDialog.h"#include "VFile.h"#include "AppText.h"#include <stddef.h>#include <string.h>voidLibraryIndex::cIndex()	{	cArray(0, sizeof(LibraryEntry *), 4);	}voidLibraryIndex::dIndex()	{	int nEntries, i;	LibraryEntry **entry;	nEntries = ALength();	entry = (LibraryEntry **)Use();	for (i = 0; i < nEntries; i++)		(*entry++)->dEntry();	Unuse();	dArray();	}voidLibraryIndex::InsertEntry(V_Buffer *buf, int loc, V_Buffer *from)	{	LibraryEntry *entry, **ent;	long fromLength, insertLength, posn, bufLength, id, size;	char *fromBuffer;	int nEntries, i;	from->IOLength(&fromLength);	fromBuffer = (char *)from->buffer->Use();	insertLength = (fromLength+12 + 1) & ~1;	if (loc < ALength())		{		Get(loc, &entry);		posn = entry->GetPosition() - 12;		buf->IOInsert(posn, insertLength);		buf->IOSetPosition(posn);		}	else		{		buf->IOLength(&bufLength);		buf->IOSetPosition(bufLength);		posn = bufLength;		}	buf->OpenChunkW(IFF_FORM);	id = IFF_VCLP;/*IOD*/	buf->IOType(&id, IO_LONG);	buf->IOData(fromBuffer, fromLength);	buf->CloseChunk();	from->buffer->Unuse();	buf->IOSetPosition(posn);	buf->IOSetDirection(DATA_IN);	buf->OpenChunkR();	IO_FORM(buf, loc);	buf->CloseChunk();	buf->IOSetDirection(DATA_OUT);	buf->IOSetPosition(4);	buf->IOSetDirection(DATA_IN);	buf->IOType(&size, IO_LONG);	size += insertLength;	buf->IOSetDirection(DATA_OUT);	buf->IOSetPosition(4);	buf->IOType(&size, IO_LONG);	nEntries = ALength();	ent = (LibraryEntry **)Use();	ent += loc+1;		for (i = loc+1; i < nEntries; i++, ent++)		(*ent)->SetPosition((*ent)->GetPosition() + insertLength);	Unuse();	}voidLibraryIndex::RemoveEntry(V_Buffer *buf, int loc)	{	LibraryEntry *entry, **ent;	long posn, removeLength, size;	int nEntries, i;	Get(loc, &entry);	posn = entry->GetPosition() - 12;	removeLength = (entry->GetLength()+12 + 1) & ~1;	buf->IODelete(posn, removeLength);	Remove(loc);	entry->dEntry();	buf->IOSetPosition(4);	buf->IOSetDirection(DATA_IN);	buf->IOType(&size, IO_LONG);	size -= removeLength;	buf->IOSetDirection(DATA_OUT);	buf->IOSetPosition(4);	buf->IOType(&size, IO_LONG);	nEntries = ALength();	ent = (LibraryEntry **)Use();	ent += loc;		for (i = loc; i < nEntries; i++, ent++)		(*ent)->SetPosition((*ent)->GetPosition() - removeLength);	Unuse();	}voidLibraryIndex::OpenEntry(V_Buffer *buf, int loc)	{	LibraryEntry *entry;	long id;	Get(loc, &entry);	buf->IOSetPosition(entry->GetPosition() - 12);	buf->OpenChunkR();	buf->IOType(&id, IO_LONG);	}voidLibraryIndex::CloseEntry(V_Buffer *buf)	{	buf->CloseChunk();	}voidLibraryIndex::NameEntry(V_Buffer *buf, int loc, char *name)	{	long id;	long nameSize = 0, posn = 0, headerPosn, size;	int insert, newSize;	LibraryEntry **ent;	int nEntries, i;	buf->IOSetDirection(DATA_IN);	OpenEntry(buf, loc);	buf->SetRefCon(0);	headerPosn = buf->IOGetPosition() - 12;	buf->IOType(&id, IO_LONG);	posn = buf->IOGetPosition();	while (nameSize == 0)		{		id = buf->OpenChunkR();		if (id == 0) break;		switch(id)			{			case IFF_VERS:				IO_VERS(buf);				posn = buf->IOGetPosition();				break;			case IFF_NAME:				posn = buf->IOGetPosition() - 8;				nameSize = (buf->ChunkSize() + 1) & ~1;				break;			}		buf->CloseChunk();		}	CloseEntry(buf);	buf->IOSetDirection(DATA_OUT);	newSize = (strlen(name)+1 + 1) & ~1;	if (nameSize != 0)		insert = newSize - nameSize;	else		insert = newSize + 8;	if (insert > 0)		buf->IOInsert(posn, insert);	else if (insert < 0)		buf->IODelete(posn, -insert);	buf->IOSetPosition(posn);	buf->OpenChunkW(IFF_NAME);	IOType(buf, name, IO_CSTR);	buf->CloseChunk();	buf->IOSetPosition(headerPosn+4);	buf->IOSetDirection(DATA_IN);	buf->IOType(&size, IO_LONG);	size += insert;	buf->IOSetDirection(DATA_OUT);	buf->IOSetPosition(headerPosn+4);	buf->IOType(&size, IO_LONG);	buf->IOSetPosition(4);	buf->IOSetDirection(DATA_IN);	buf->IOType(&size, IO_LONG);	size += insert;	buf->IOSetDirection(DATA_OUT);	buf->IOSetPosition(4);	buf->IOType(&size, IO_LONG);	nEntries = ALength();	ent = (LibraryEntry **)Use();	ent += loc;	(*ent)->SetName(name);	(*ent)->SetLength((*ent)->GetLength() + insert);	ent++;	for (i = loc+1; i < nEntries; i++, ent++)		(*ent)->SetPosition((*ent)->GetPosition() + insert);	Unuse();	}intLibraryIndex::IO(V_Buffer *buf)	{	int err = 0;	long id;	long total;		// MERGE21	// MERGE21 [[[	MeterNoButtonCreate();	if (buf->GetBufferType() == V_FILETYPE);	{	char str[256];	char name[256];		((V_File*)buf)->GetFName(name);		sprintf(str,TXT_METREADING,name);		MeterTitle(TXT_APPNAME);		MeterSetText(str);	}	buf->IOLength(&total);	MeterSetTotal(total);	MeterSetCount(0);	MeterStart();// MERGE21 ]]]	if (buf->IODirection() == DATA_IN)		{		id = buf->OpenChunkR();     //DUDE PORT		switch(id)			{			case IFF_CAT:				err = IO_CAT(buf);				break;			}				if (id != 0) buf->CloseChunk();		}	else		{		buf->OpenChunkW(IFF_CAT);		err = IO_CAT(buf);		buf->CloseChunk();		}	MeterStop();		// MERGE21		return(err);	}intLibraryIndex::IO_CAT(V_Buffer *buf)	{	int err = 0;	long id;	if (buf->IODirection() == DATA_IN)		{		err = buf->IOType(&id, IO_LONG);		if (!err && id == IFF_VCLP)			{			while (!err)				{				id = buf->OpenChunkR();				if (id == 0) break;					switch(id)					{					case IFF_FORM:						err = IO_FORM(buf, ALength());						MeterSetCount(buf->IOGetPosition());		// MERGE21						MeterUpdate(0);		// MERGE22						break;					}					buf->CloseChunk();				}			}		}	else		{		int nEntries, i;		LibraryEntry **entry;		id = IFF_VCLP;		err = buf->IOType(&id, IO_LONG);		/* 0 VCLP FORMs */		}	return(err);	}intLibraryIndex::IO_FORM(V_Buffer *buf, int loc)	{	int err = 0, nameFlag = FALSE;	long id;	LibraryEntry *entry;	Handle name;	char *namePtr;		if (buf->IODirection() == DATA_IN)		{		err = buf->IOType(&id, IO_LONG);		if (!err && id == IFF_VCLP)			{			entry = new(LibraryEntry);			entry->cEntry();			entry->SetPosition(buf->IOGetPosition());			entry->SetLength(buf->ChunkSize());				buf->SetRefCon(0);			err = buf->IOType(&id, IO_LONG);			entry->SetType(id);				while (!err && !nameFlag)				{				id = buf->OpenChunkR();				if (id == 0) break;								switch(id)					{					case IFF_VERS:						err = IO_VERS(buf);						break;						case IFF_NAME:						name = NewHandle(256);						HLock((Handle)name);						namePtr = (char *)HDeref(name);						err = IOType(buf, namePtr, IO_CSTR);						entry->SetName(namePtr);						HUnlock((Handle)name);						DisposHandle((Handle)name);						nameFlag = TRUE;						break;					}					buf->CloseChunk();				}			}			if (!err)			Insert(loc, &entry);		else			entry->dEntry();		}	return(err);	}voidLibraryEntry::cEntry()	{	name = NULL;	type = 0;	position = 0;	length = 0;	}voidLibraryEntry::dEntry()	{	if (name != NULL)		DisposHandle((Handle)name);	delete(this);	}voidLibraryEntry::SetName(char *nm)	{	char *namePtr;		if (name != NULL)		DisposHandle((Handle)name);	name = NewHandle(strlen(nm) + 1);	HLock((Handle)name);	namePtr = (char *)HDeref(name);	strcpy(namePtr, nm);	HUnlock((Handle)name);	}HandleLibraryEntry::GetName()	{ return(name); }voidLibraryEntry::SetType(long t)	{ type = t; }longLibraryEntry::GetType()	{ return(type); }voidLibraryEntry::SetPosition(long p)	{ position = p; }longLibraryEntry::GetPosition()	{ return(position); }voidLibraryEntry::SetLength(long l)	{ length = l; }longLibraryEntry::GetLength()	{ return(length); }