/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VDisplay.h"#include "CVTumObj.h"#include "Polyhdrn.h"#include "Space.h"#include "PolyConv.h"#include "Surface.h"#include "SurfDef.h"#include "PolyDefs.h"#include "CVEnvirn.h"#include "Geometry.h"#include "Clip.h"#include "Misc.h"#include "Position.h"#include "Flash.h"			// ABD MERGE-TEXTURE 9/13/93 //GJR 09/24/93#include "TextItem.h"		// ABD MERGE-TEXTURE 9/13/93#include "Texture.h"#include "TextSrvr.h"		// ABD MERGE-TEXTURE 9/13/93#include "SrfObj.h"			// ABD TEXTURE       // MERGE BUG 17MAR94 ABD//#include "View.h"				// ABD TEXTURE//#include "Debug.h"			// ABD//#include "ShowTest.h"			// ABD#include "Gouraud.h"	// MERGE-GOURAUD#if VPRO#include "TumCntrl.h"	// ABD MERGE-VPRO-2#endif // VPRO#include "VGraphic.h"#include "VGUtil.h"#include "VArray.h"#include <math.h>extern TextureShader gTextureShader;	// ABD-JAM TEXTURE	//GJR 09/24/93FFixed	Six(FFixed n, FFixed o, int i, int s);int	iMatrix[3][3] = { 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 };voidCAVTumbleObject::cCAVTumbleObject()	{		polyhedron = NULL;	environment = NULL;		spoints = new(V_Array);	spoints->cArray(0,sizeof(Point3DLong),4);		rpoints = new(V_Array);	rpoints->cArray(0,sizeof(PointLong),4);	visibleFlags = new(V_Array);	visibleFlags->cArray(0,sizeof(short),4);		surfNormals = new(V_Array);	surfNormals->cArray(0,sizeof(Point3D),4);		drawState = TUMBLE_FILL|TUMBLE_FRAME;	dirty = TRUE;	origin = Pt3DFFZero;	}voidCAVTumbleObject::dCAVTumbleObject()	{		spoints->dArray();	rpoints->dArray();	visibleFlags->dArray();	surfNormals->dArray();	delete(this);	}void CAVTumbleObject::SetOrigin(Point3DFFixed org) { origin = org; }Point3DFFixed CAVTumbleObject::GetOrigin() { return(origin); }	voidCAVTumbleObject::Update(int	m[3][3])	{	int i,j,length;	Point3D *pNormal;	Point3DLong *lp;	PointLong *rp,*rp2;	Surface	**surface;	short	*visibleFlag;			if(!polyhedron) 		return;			if(dirty) Scale();				length = spoints->ALength();		rp = (PointLong*)rpoints->Use();	lp = (Point3DLong*)spoints->Use();	rp2 = rp;		for (i=0; i<length; i++,lp++,rp++)		{		NewX(rp->h,m,lp->x,lp->y,lp->z);		NewZ(rp->v,m,-lp->x,-lp->y,-lp->z);		}			spoints->Unuse();		rpoints->Unuse();	length = polyhedron->piece->surfaces->ALength();	surface = (Surface	**)polyhedron->piece->surfaces->Use();	pNormal = (Point3D *)surfNormals->Use();	visibleFlag = (short*)visibleFlags->Use();	for(i = 0; i < length; i++,visibleFlag++,surface++,++pNormal)		NewY(*visibleFlag,m,pNormal->x,pNormal->y,pNormal->z);	visibleFlags->Unuse();	surfNormals->Unuse();	polyhedron->piece->surfaces->Unuse();	}voidCAVTumbleObject::Display()	{	PolyConvex **convex;	PointLong *rp;		if(!polyhedron)  return;			if(dirty)Scale();	rp = (PointLong *)rpoints->Use();	DisplaySurface(rp,polyhedron->piece,drawState,NO_MARK);	rpoints->Unuse();	}voidCAVTumbleObject::Select(int surfNum,int method)	{	PolyConvex **convex;	PointLong *rp;		if(method) method = TUMBLE_SELECT|TUMBLE_FRAME; else  method = drawState;	rp = (PointLong *)rpoints->Use();	if (polyhedron->piece)		DisplaySurface(rp,polyhedron->piece,method,surfNum);	rpoints->Unuse();	}/*voidCAVTumbleObject::DisplaySurface(PointLong *rp,PolyConvex *convex,int method,int surfSelect)	{	Surface **surfaces;	PointLong	drawOrigin;	Point	pt;	RGBColor color,patColor;	int sel,depth;	int i,ilength;	int j,jlength;	short	*visibleFlag,*index;#if MACINTOSH	PolyHandle qdpoly;#endif //MACINTOSH		drawOrigin = environment->GetDrawOrigin();	depth = environment->GetCAVDepth();		surfaces = (Surface **)convex->surfaces->Use();	jlength = convex->surfaces->ALength();	visibleFlag = (short*)visibleFlags->Use();		for (j=0; j<jlength; j++,visibleFlag++,surfaces++)		{		if(*visibleFlag < 0 && 			(surfSelect == (*surfaces)->surfNum || ( NO_MARK == surfSelect)))			{						ilength = (*surfaces)->points->ALength();			index = (short*)(*surfaces)->points->Use();			#if MACINTOSH			qdpoly = OpenPoly();			IndexLongClipPoly(rpoints,(*surfaces)->points,&(environment->dataRect),drawOrigin);			ClosePoly();#endif //MACINTOSH			if(TRANSPARENT((*surfaces)->opacity)) { VSetPattern(vPatBlack);color = vBlack; }			else if(TRANSLUCENT((*surfaces)->opacity)) { VSetPattern(vPatGray); color = (*surfaces)->outsideShade; }			else { VSetPattern(vPatBlack); color = (*surfaces)->outsideShade; }						if(TUMBLE_FILL & method)				{				VForeColor(&color);					#if MACINTOSH				PaintPoly(qdpoly);#endif //MACINTOSH				}			if(TUMBLE_SELECT & method)				{				pt.h = drawOrigin.h;				pt.v = drawOrigin.v;				VSelectPatternOrigin(pt);				VSetPattern(vPatSelect);								if(depth < 4 || Lightness(color)>0x7FFF) patColor = vBlack; 				else patColor = vWhite;				VBackColor(&color);				VForeColor(&patColor);#if MACINTOSH				PaintPoly(qdpoly);#endif //MACINTOSH				VSetPattern(vPatBlack);				VBackColor(&vWhite);				}			if(TUMBLE_FRAME & method)				{				VForeColor(&vBlack);#if MACINTOSH				FramePoly(qdpoly);#endif //MACINTOSH				}			VForeColor(&vBlack);#if MACINTOSH			KillPoly(qdpoly);#endif //MACINTOSH			(*surfaces)->points->Unuse();						MapSurface(j);						if(NO_MARK != surfSelect) break; 			}		}			visibleFlags->Unuse();	convex->surfaces->Unuse();	}*/voidCAVTumbleObject::DisplaySurface(PointLong *rp,PolyConvex *convex,int method,int surfSelect)	{	Surface **surfaces;	PointLong	drawOrigin;	Point	pt;	RGBColor color,lineColor;	int sel,depth;	int i;	int j,jlength;	short	*visibleFlag;	int newPattern,clipMode;	V_Array *clipPts;	Rect r;	int ick;    TextureItem *texture= NULL;   // ABD TEXTURE    FFixed ff_flip;     // ABD TEXTURE    int flip_height;        // ABD TEXTURE		drawOrigin = environment->GetDrawOrigin();	depth = environment->GetCAVDepth();		surfaces = (Surface **)convex->surfaces->Use();	jlength = convex->surfaces->ALength();	visibleFlag = (short*)visibleFlags->Use();		for (j=0; j<jlength; j++,visibleFlag++,surfaces++)		{		if(*visibleFlag < 0 && 			(surfSelect == (*surfaces)->surfNum || ( NO_MARK == surfSelect)))			{						// MERGE-VPRO-2 [[[#if VPRO			texture = (*surfaces)->GetTexture(SURF_OUTSIDE); 	// ABD TEXTURE			/*11-29-93 JAM [[[ patch to cause textures to			  not be used when doing GDI stuff*/		    //this if was copied (subtracting one or condition) from clip.cp			if (!offscreen || !gwUserFlash || !offscreen->wMethodInit || usePlatformDrawFlag || polyCheckMode)			{    			texture = NULL;	    	}			/*11-29-93 JAM ]]] patch to cause textures to	     	 not be used when doing GDI stuff*/			if (texture)				{				if (NULL == texture->GetPicture(0))					{  // Then no texture to draw. Turn texture off					texture = NULL;					}				}#endif // VPRO// MERGE-VPRO-2 ]]]			if (texture)			{// HUH? GJR 09/24/93 Ask ABD. One-frame? DeSelect vs Select?//				// if we are textured, then change fill/frame/deselect to just frame/deselect//				// because we can't fill because of this one-offscreen idiocy.//				if ((method & TUMBLE_FILL) && (method & TUMBLE_FRAME) && (method & TUMBLE_DESELECT))//					method = TUMBLE_FRAME | TUMBLE_SELECT;			}			if(IS_TRANSPARENT((*surfaces)->opacity)) { newPattern = vPatBlack;color = vBlack; }			else if(IS_TRANSLUCENT((*surfaces)->opacity)) { newPattern = vPatGray; color = (*surfaces)->outsideShade; }			else { newPattern = vPatBlack; color = (*surfaces)->outsideShade; }						lineColor = vBlack; //This should come from preferences						clipMode = (TUMBLE_FILL & method) ? CLIP_FILL : FALSE;			clipMode |= ((TUMBLE_FRAME & method) ? CLIP_FRAME : FALSE);			r = environment->dataRect;			clipPts = IndexLongClipPoly(rpoints,(*surfaces)->points,&r,drawOrigin);//-------------GJR 09/24/93 [[[ insert texture stuff (guessing)					if (CLIP_FILL|CLIP_FRAME & clipMode)  // jca 25 Jan 94 need to do it for CLIP_FRAME, too			{				if ((!texture) || (!offscreen))				{					// MERGE-GOURAUD [[[					if (0) // ((*surfaces)->GetRendIntensities(SURF_OUTSIDE) != NULL)					{					struct GouraudRendSettings grs;					int old_method;						grs.intensities = (*surfaces)->GetRendIntensities(SURF_OUTSIDE);								grs.unshaded_color = (*surfaces)->outsideColorIndex;						old_method = virtusClipper->method;						virtusClipper->method = FLASH_METHOD;				    	virtusClipper->DrawPoly(clipPts,clipMode,&grs,FALSE,newPattern,&color,&lineColor,TRUE,NULL);		// MERGE-GOURAUD						virtusClipper->method = old_method;					}					else					// MERGE-GOURAUD ]]]				    	virtusClipper->NewDrawPoly(clipPts,clipMode,NULL,FALSE,FALSE,newPattern,&color,&lineColor,TRUE,NULL);		// MERGE-GOURAUD				}// MERGE-VPRO-2 [[[#if VPRO				else        				{				VCGrafPort savePort;				VGrafDevice saveDevice;//				struct V_Port port;	 			V_Offscreen *texture_offscreen;				int has_texture = (texture != NULL);					int decal = FALSE;		/* !!! decal hack -- decal if not opaque */									if (has_texture)					{					FFixed ff_temp;     // jca 17Mar94 borland can't return a structure on the stack					Rect flip;				   	V_Array *ctp = GetShortSurfPointsIndex(rpoints,(*surfaces)->points,drawOrigin);				   	V_Array *it;				   	struct TextureRendSettings TextureInfo;				   	int i;				   	//V_Array *txtPnt1;				   										VGetPort(&savePort,&saveDevice);					//offscreen->SetMetaPort(&port);	 			    texture_offscreen = texture->GetPicture(0);//				    if (texture_offscreen == NULL)  	// can't get the picture, so try using thumbnail//				    	texture_offscreen = texture->GetThumbnail();					if (texture_offscreen == NULL) 	// can't even get the thumbnail, so give up!						has_texture = FALSE;												//txtPnt1 = new(V_Array);						//txtPnt1->cArray(0, sizeof(Point), 4);										 	texture->GetPaddedRect(&flip, 0);													ff_flip.intg = flip.bottom-flip.top;						ff_flip.frac = 0;						ff_temp = FFMult(ff_flip, texture->settings.vTiles); // jca 17MAR94 Borland needs a temp spaceholder						flip_height = FFRound(ff_temp);												//MakeTextureArray((*surfaces)->GetOutline(), txtPnt1, &flip);						// (*surfaces)->GetTexturePoints(SURF_OUTSIDE)				   					   		it = AbsoluteIdentTexture((*surfaces)->GetRawTexturePoints(SURF_OUTSIDE),				   			flip_height,0);				   		texture->SetupFrame();						TextureInfo.decal = texture->settings.decal;						TextureInfo.colorize = texture->settings.colorize;						TextureInfo.hFlip = texture->settings.hFlip;						TextureInfo.vFlip = texture->settings.vFlip;						TextureInfo.hMirror = texture->settings.hMirror;						TextureInfo.vMirror = texture->settings.vMirror;						TextureInfo.textureShade = &(gTextureShader[0]);						for (i = 0 ; i < MAX_NUM_MIPS ; i++ )						{							TextureInfo.mip[i] = texture->GetPicture(i);							texture->GetPaddedRect(&TextureInfo.mip_rect[i], i);						}//						if(TextureInfo.mip[0] == NIL) {//							TextureInfo.mip[0] = texture->GetThumbnail();//							TextureInfo.mip[0]->GetRect(&TextureInfo.mip_rect[0]);//							//texture->GetPaddedRect(&TextureInfo.mip_rect[0], 0); ????//							}						texture->texture->Lock();					 	ShadedLinearTexture8(&TextureInfo, offscreen, it, ctp, NULL);				 								texture->texture->Unlock();					 //txtPnt1->dArray();					//offscreen->UnsetMetaPort(&port);					}					VSetPort(savePort,saveDevice);				  }#endif // VPRO// MERGE-VPRO-2 ]]]				}		//-------------GJR 09/24/93 ]]]			if(TUMBLE_SELECT & method)				{					if ((!texture) || (!offscreen))					{#if MACINTOSH	 				if(depth < 4 || Lightness(color)>0x7FFF) color = vBlack;					else color = vWhite;#elif WINDOWS	 				if(depth < 4 || Lightness(color)>0x4000) color = vBlack;	 				else color = vWhite;#endif // MACINTOSH					// MERGE-GOURAUD [[[					if (0) // ((*surfaces)->GetRendIntensities(SURF_OUTSIDE) != NULL)					{					struct GouraudRendSettings grs;					int old_method;						grs.intensities = (*surfaces)->GetRendIntensities(SURF_OUTSIDE);								grs.unshaded_color = (*surfaces)->outsideColorIndex;						old_method = virtusClipper->method;						virtusClipper->method = FLASH_METHOD;		 				virtusClipper->DrawPoly(clipPts,CLIP_FILL,&grs,vPatXor,vPatSelect,&color,NULL,TRUE,NULL);	// MERGE-GOURAUD						virtusClipper->DrawPoly(clipPts,CLIP_FRAME,&grs,vSrcOr,vPatBlack,NULL,&vBlack,TRUE,NULL);	// MERGE-GOURAUD						virtusClipper->method = old_method;					}					else					// MERGE-GOURAUD ]]]					{	 				virtusClipper->NewDrawPoly(clipPts,CLIP_FILL,NULL,vPatXor,vPatSelect,FALSE,&color,NULL,TRUE,NULL);	// MERGE-GOURAUD					virtusClipper->NewDrawPoly(clipPts,CLIP_FRAME,NULL,vSrcOr,vPatBlack,FALSE,NULL,&vBlack,TRUE,NULL);	// MERGE-GOURAUD					}										VSetPenNormal();					}					else 					{						if(depth < 4 || Lightness(color)>0x7FFF) color = vBlack; 						else color = vWhite;												// MERGE-GOURAUD [[[						if (0) // ((*surfaces)->GetRendIntensities(SURF_OUTSIDE) != NULL)						{						struct GouraudRendSettings grs;						int old_method;							grs.intensities = (*surfaces)->GetRendIntensities(SURF_OUTSIDE);									grs.unshaded_color = (*surfaces)->outsideColorIndex;							old_method = virtusClipper->method;							virtusClipper->method = FLASH_METHOD;							virtusClipper->DrawPoly(clipPts,CLIP_FILL,&grs,vPatXor,vPatSelect,&color,NULL,TRUE,NULL);	// MERGE-GOURAUD							virtusClipper->method = old_method;						}						else						// MERGE-GOURAUD ]]]	 					virtusClipper->NewDrawPoly(clipPts,CLIP_FILL,NULL,vPatXor,vPatSelect,FALSE,&color,NULL,TRUE,NULL);	// MERGE-GOURAUD						VPenMode(vPatCopy);					}				}			VSetPattern(vPatBlack);			VForeColor(&vBlack);			MapSurface(j);						if(NO_MARK != surfSelect) break; /* optimization */			}		}		visibleFlags->Unuse();	convex->surfaces->Unuse();	}			voidCAVTumbleObject::FaceFront(FFixed sinX,FFixed cosX,FFixed sinZ,FFixed cosZ,Point3D *point)	{	Point3DFFixed pt,pt1;	pt.x.intg = point->x; pt.x.frac = 0;	pt.y.intg = point->y; pt.y.frac = 0;	pt.z.intg = point->z; pt.z.frac = 0;		pt1.x = FFAdd(FFMult(pt.y, sinZ), FFMult(pt.x, cosZ));	pt1.y = FFSub(FFMult(pt.y, cosZ), FFMult(pt.x, sinZ));	pt1.z = pt.z;		pt.x = pt1.x;	pt.y = FFAdd(FFMult(pt1.z, sinX), FFMult(pt1.y, cosX));	pt.z = FFSub(FFMult(pt1.z, cosX), FFMult(pt1.y, sinX));			point->x = 	pt.x.intg;	point->y = 	pt.y.intg;	point->z = 	pt.z.intg;	}SurfDef *CAVTumbleObject::NewFind(Point p)	{	SurfDef *surfDef;	Surface	*surface;	int 	which;			which = Find(p);	if(0 > which) return(NULL);	surface = polyhedron->FindSurface(which);	if (!surface->surfDef) surface->surfDef = polyhedron->GetSurfDef(which);	surfDef = surface->surfDef;		return(surfDef);	}intCAVTumbleObject::Find(Point p)	{	int i,ilength;	int j,jlength;	PointLong *rp;	Point	a,b,tp;	Point3D 	*rNormal;	Surface **surfaces;	short *index,*visibleFlag;	int in,result,selected;		in = FALSE;	selected = NO_MARK;	tp = p;		rp = (PointLong *)rpoints->Use();		jlength = polyhedron->piece->surfaces->ALength();	surfaces = (Surface **)polyhedron->piece->surfaces->Use();	visibleFlag = (short*)visibleFlags->Use();	for (j=0; j<jlength; j++,visibleFlag++,surfaces++)		{		if(*visibleFlag < 0)			{			ilength = (*surfaces)->points->ALength();			index = (short*)(*surfaces)->points->Use();			for(i = 0; i < ilength; i++)				{				/*dude - asignments must go */				a.h = rp[index[i]].h;				a.v = rp[index[i]].v;				b.h = rp[index[nextNum(i,ilength)]].h;				b.v = rp[index[nextNum(i,ilength)]].v;				result = Clockwise(tp,a,b);				if(CLOCKWISE == result) break;				}							if (CLOCKWISE != result)				selected = (*surfaces)->surfNum;							(*surfaces)->points->Unuse();			}		}	polyhedron->piece->surfaces->Unuse();		visibleFlags->Unuse();	rpoints->Unuse();		return(selected);	}voidCAVTumbleObject::SelectAll(V_Array *list)	{	Surface **pSurf;	int length,i,surfNum;		length = polyhedron->piece->surfaces->ALength();	pSurf = (Surface **)polyhedron->piece->surfaces->Use();	for(i = 0; i < length; i++,pSurf++)		{		surfNum = (*pSurf)->surfNum;		Select(surfNum,TRUE);		list->Append(&surfNum);		}	polyhedron->piece->surfaces->Unuse();	}		voidCAVTumbleObject::Scale()	{	Position		*posn;	Surface			**pSurf;	Point3DFFixed 	*pp,wp,scal;	Shear3DFFixed	shr;	Point3DLong		*p,*p2;	Point3D			*pNormal;	FFixed			scale,boundFFR;	FFixed 			xTerm, yTerm;	int 			i,length,surfLength,shearFlag,scaleFlag;		scale = environment->GetScale();	posn = new(Position);	posn->cPosition();	posn->SetScale(polyhedron->posn->GetScale());	posn->SetShear(polyhedron->posn->GetShear());		length = polyhedron->points->ALength();	spoints->SetLength(length);	rpoints->SetLength(length);	surfLength = polyhedron->piece->surfaces->ALength();	visibleFlags->SetLength(surfLength);	/* DUDE THIS IS FOR Transforming surfNormals */	surfNormals->SetLength(surfLength);			pp = (Point3DFFixed *)polyhedron->points->Use();	p = (Point3DLong*)spoints->Use();	for(i = 0; i < length; i++,pp++,p++)		{		wp = posn->Transform3D(*pp);		*p = environment->WorldToScale(wp);		}	boundFFR = FFMultIntShift(scale,polyhedron->piece->posnBoundR,0);	boundR = FFRound(boundFFR);		scal = polyhedron->posn->GetScale3D();	if (Pt3DFFOne(scal))		scaleFlag = FALSE;	else		{		scaleFlag = TRUE;		scal.x = FFDiv(FFOne, scal.x);		scal.y = FFDiv(FFOne, scal.y);		scal.z = FFDiv(FFOne, scal.z);		}	shr = polyhedron->posn->GetShear3D();	if (Shr3DFFZero(shr)) shearFlag = FALSE;	else shearFlag = TRUE;				wp = Pt3DFFZero;	pNormal = (Point3D*)surfNormals->Use();	pSurf = (Surface**)polyhedron->piece->surfaces->Use();	for(i = 0; i < surfLength; i++,pNormal++,pSurf++)		{		wp.x.intg = (*pSurf)->normal.x;		wp.y.intg = (*pSurf)->normal.y;		wp.z.intg = (*pSurf)->normal.z;		if(scaleFlag)			{			wp.x = FFMult(scal.x,wp.x);			wp.y = FFMult(scal.y,wp.y);			wp.z = FFMult(scal.z,wp.z);			}		if (shearFlag)			{			yTerm = FFMult(wp.y, shr.yz);			xTerm = FFMult(wp.x, FFSub(shr.xz, FFMult(shr.xy, shr.yz)));				wp.z = FFSub(wp.z, FFAdd(yTerm, xTerm));			wp.y = FFSub(wp.y, FFMult(wp.x, shr.xy));			}		wp = posn->Transform3D(wp);		pNormal->x = FFRound(wp.x);		pNormal->y = FFRound(wp.y);		pNormal->z = FFRound(wp.z);		}	surfNormals->Unuse();	polyhedron->piece->surfaces->Unuse();		posn->dPosition();			spoints->Unuse();	polyhedron->points->Unuse();	dirty = FALSE;	}void CAVTumbleObject::SetPolyhedron(Polyhedron *poly) { polyhedron = poly; }void CAVTumbleObject::SetEnvironment(CAVEnvironment *e) { environment = e; }void CAVTumbleObject::SetDirty(int newState) { dirty = newState; }void CAVTumbleObject::SetDrawState(int newState) { drawState = newState; }int  CAVTumbleObject::GetDrawState() { return(drawState); }	FFixedCAVTumbleObject::Fit(Rect *r)	{	Point3D boundMin,boundMax,ctr;	Point3D *lp;	double	xy,xyz,x,y,z,h,v,dscale;	int 	i,length;			boundMin = polyhedron->boundMin;	boundMax = polyhedron->boundMax;			x = boundMax.x - boundMin.x;	y = boundMax.y - boundMin.y;	z = boundMax.z - boundMin.z;		xyz = sqrt(x*x + y*y + z*z);		h = r->right - r->left;	v = r->bottom - r->top;	xy = min(h,v);		if(!xyz) xyz = 1;			dscale = xy/xyz;			return(DblToFixed(dscale));	}          voidCAVTumbleObject::GetBounds(Rect *r,int x,int y)	{	r->left = x - boundR;	r->right = x + boundR;	r->top = y - boundR;	r->bottom = y + boundR;	}voidCAVTumbleObject::MapSurface(int surf)	{	}	voidOrientObject::cCAVTumbleObject()	{		CAVTumbleObject::cCAVTumbleObject();		wLetters = new(V_Array);	wLetters->cArray(0,sizeof(Point3DFFixed),4);	lLetters = new(V_Array);	lLetters->cArray(0,sizeof(Point3DLong),4);	rLetters = new(V_Array);	rLetters->cArray(0,sizeof(PointLong),4);	}voidOrientObject::dCAVTumbleObject()	{		wLetters->dArray();	lLetters->dArray();	rLetters->dArray();		CAVTumbleObject::dCAVTumbleObject();	}voidOrientObject::MakeBox(FFixed x, FFixed y, FFixed z)	{	Point3DFFixed	p;	FFixed			ox,oy,oz;	 	ox = FFNeg(FFShift(x,0));	oy = FFNeg(FFShift(y,0));	oz = FFNeg(FFShift(z,0));	#if JAPANESE	/* how to make letters:  x, y, and z are the sides of the cube. ox, oy, and oz    are the negatives of x,y,z and     *//* Top */	p.z = FFShift(z,0);	p.x = Six(x,ox,1,+1); p.y = Six(y,oy,1,+1); wLetters->Append(&p);	p.x = Six(x,ox,11,+1); p.y = Six(y,oy,1,+1); wLetters->Append(&p);	p.x = Six(x,ox,6,+1); p.y = Six(y,oy,1,-1); wLetters->Append(&p);	p.x = Six(x,ox,6,+1); p.y = Six(y,oy,11,-1); wLetters->Append(&p);	p.x = Six(x,ox,6,+1); p.y = Six(y,oy,6,+1); wLetters->Append(&p);	p.x = Six(x,ox,10,+1); p.y = Six(y,oy,6,+1); wLetters->Append(&p);/* Front */	p.y = FFNeg(FFShift(y,0));	p.x = Six(x,ox,1,+1); p.z = Six(z,oz,1,+1); wLetters->Append(&p);	p.x = Six(x,ox,11,+1); p.z = Six(z,oz,1,+1); wLetters->Append(&p);	p.x = Six(x,ox,6,+1); p.z = Six(z,oz,1,-1); wLetters->Append(&p);	p.x = Six(x,ox,6,+1); p.z = Six(z,oz,11,-1); wLetters->Append(&p);	p.x = Six(x,ox,2,+1); p.z = Six(z,oz,1,-1); wLetters->Append(&p);	p.x = Six(x,ox,11,+1); p.z = Six(z,oz,1,-1); wLetters->Append(&p);	p.x = Six(x,ox,6,+1); p.z = Six(z,oz,6,+1); wLetters->Append(&p);	p.x = Six(x,ox,10,+1); p.z = Six(z,oz,6,+1); wLetters->Append(&p);	p.x = Six(x,ox,3,+1); p.z = Six(z,oz,1,+1); wLetters->Append(&p);	p.x = Six(x,ox,3,+1); p.z = Six(z,oz,7,+1); wLetters->Append(&p);/* Back */	p.y = FFShift(y,0);	p.x = Six(x,ox,1,-1); p.z = Six(z,oz,5,-1); wLetters->Append(&p);	p.x = Six(x,ox,5,-1); p.z = Six(z,oz,5,-1); wLetters->Append(&p);	p.x = Six(x,ox,7,-1); p.z = Six(z,oz,5,-1); wLetters->Append(&p);	p.x = Six(x,ox,11,-1); p.z = Six(z,oz,5,-1); wLetters->Append(&p);	p.x = Six(x,ox,3,-1); p.z = Six(z,oz,2,-1); wLetters->Append(&p);	p.x = Six(x,ox,5,-1); p.z = Six(z,oz,2,-1); wLetters->Append(&p);	p.x = Six(x,ox,7,-1); p.z = Six(z,oz,2,-1); wLetters->Append(&p);	p.x = Six(x,ox,9,-1); p.z = Six(z,oz,2,-1); wLetters->Append(&p);	p.x = Six(x,ox,5,-1); p.z = Six(z,oz,1,-1); wLetters->Append(&p);	p.x = Six(x,ox,5,-1); p.z = Six(z,oz,5,-1); wLetters->Append(&p);	p.x = Six(x,ox,7,-1); p.z = Six(z,oz,1,-1); wLetters->Append(&p);	p.x = Six(x,ox,7,-1); p.z = Six(z,oz,5,-1); wLetters->Append(&p);	p.x = Six(x,ox,3,-1); p.z = Six(z,oz,11,-1); wLetters->Append(&p);	p.x = Six(x,ox,3,-1); p.z = Six(z,oz,6,-1); wLetters->Append(&p);	p.x = Six(x,ox,9,-1); p.z = Six(z,oz,6,-1); wLetters->Append(&p);	p.x = Six(x,ox,9,-1); p.z = Six(z,oz,11,-1); wLetters->Append(&p);	p.x = Six(x,ox,7,-1); p.z = Six(z,oz,11,-1); wLetters->Append(&p);	p.x = Six(x,ox,3,-1); p.z = Six(z,oz,7,-1); wLetters->Append(&p);	p.x = Six(x,ox,9,-1); p.z = Six(z,oz,7,-1); wLetters->Append(&p);	p.x = Six(x,ox,3,-1); p.z = Six(z,oz,8,-1); wLetters->Append(&p);	p.x = Six(x,ox,9,-1); p.z = Six(z,oz,8,-1); wLetters->Append(&p);/* Left */	p.x = FFNeg(FFShift(x,0));	p.y = Six(y,oy,1,+1); p.z = Six(z,oz,4,-1); wLetters->Append(&p);	p.y = Six(y,oy,11,+1); p.z = Six(z,oz,4,-1); wLetters->Append(&p);	p.y = Six(y,oy,5,-1); p.z = Six(z,oz,6,-1); wLetters->Append(&p);	p.y = Six(y,oy,10,-1); p.z = Six(z,oz,6,-1); wLetters->Append(&p);	p.y = Six(y,oy,5,-1); p.z = Six(z,oz,10,-1); wLetters->Append(&p);	p.y = Six(y,oy,11,-1); p.z = Six(z,oz,10,-1); wLetters->Append(&p);	p.y = Six(y,oy,6,+1); p.z = Six(z,oz,6,-1); wLetters->Append(&p);	p.y = Six(y,oy,6,+1); p.z = Six(z,oz,10,-1); wLetters->Append(&p);	p.y = Six(y,oy,1,-1); p.z = Six(z,oz,2,+1); wLetters->Append(&p);	p.y = Six(y,oy,6,+1); p.z = Six(z,oz,1,-1); wLetters->Append(&p);/* Right */	p.x = FFShift(x,0);	p.y = Six(y,oy,1,+1); p.z = Six(z,oz,4,-1); wLetters->Append(&p);	p.y = Six(y,oy,11,+1); p.z = Six(z,oz,4,-1); wLetters->Append(&p);	p.y = Six(y,oy,5,+1); p.z = Six(z,oz,6,-1); wLetters->Append(&p);	p.y = Six(y,oy,10,+1); p.z = Six(z,oz,6,-1); wLetters->Append(&p);	p.y = Six(y,oy,10,+1); p.z = Six(z,oz,10,-1); wLetters->Append(&p);	p.y = Six(y,oy,5,+1); p.z = Six(z,oz,10,-1); wLetters->Append(&p);	p.y = Six(y,oy,1,+1); p.z = Six(z,oz,8,-1); wLetters->Append(&p);	p.y = Six(y,oy,6,+1); p.z = Six(z,oz,11,+1); wLetters->Append(&p);/* Bottom */	p.z = FFNeg(FFShift(z,0));	p.x = Six(x,ox,1,+1); p.y = Six(y,oy,1,-1); wLetters->Append(&p);	p.x = Six(x,ox,11,+1); p.y = Six(y,oy,1,-1); wLetters->Append(&p);	p.x = Six(x,ox,6,+1); p.y = Six(y,oy,1,-1); wLetters->Append(&p);	p.x = Six(x,ox,6,+1); p.y = Six(y,oy,11,-1); wLetters->Append(&p);	p.x = Six(x,ox,6,+1); p.y = Six(y,oy,6,+1); wLetters->Append(&p);	p.x = Six(x,ox,10,-1); p.y = Six(y,oy,7,-1); wLetters->Append(&p);#elif SPANISH/* Top */   // character 'S'	p.z = FFShift(z,0);	p.x = Six(x,ox,11,+1); p.y = Six(y,oy,1,-1); wLetters->Append(&p);	p.x = Six(x,ox,1,+1); p.y = Six(y,oy,1,-1); wLetters->Append(&p);	p.x = Six(x,ox,1,+1); p.y = Six(y,oy,6,-1); wLetters->Append(&p);	p.x = Six(x,ox,11,+1); p.y = Six(y,oy,6,-1); wLetters->Append(&p);	p.x = Six(x,ox,11,+1); p.y = Six(y,oy,11,-1); wLetters->Append(&p);	p.x = Six(x,ox,1,+1); p.y = Six(y,oy,11,-1); wLetters->Append(&p);/* Front */    // character 'F'	p.y = FFNeg(FFShift(y,0));	p.x = Six(x,ox,11,+1); p.z = Six(z,oz,1,-1); wLetters->Append(&p);	p.x = Six(x,ox,1,+1); p.z = Six(z,oz,1,-1); wLetters->Append(&p);	p.x = Six(x,ox,1,+1); p.z = Six(z,oz,11,-1); wLetters->Append(&p);	p.x = Six(x,ox,1,+1); p.z = Six(z,oz,6,-1); wLetters->Append(&p);	p.x = Six(x,ox,10,+1); p.z = Six(z,oz,6,-1); wLetters->Append(&p);/* Back */    // character 'P'	p.y = FFShift(y,0);	p.x = Six(x,ox,1,-1); p.z = Six(z,oz,1,-1); wLetters->Append(&p);	p.x = Six(x,ox,7,-1); p.z = Six(z,oz,1,-1); wLetters->Append(&p);	p.x = Six(x,ox,10,-1); p.z = Six(z,oz,4,-1); wLetters->Append(&p);	p.x = Six(x,ox,7,-1); p.z = Six(z,oz,6,-1); wLetters->Append(&p);	p.x = Six(x,ox,2,-1); p.z = Six(z,oz,6,-1); wLetters->Append(&p);	p.x = Six(x,ox,2,-1); p.z = Six(z,oz,1,-1); wLetters->Append(&p);	p.x = Six(x,ox,2,-1); p.z = Six(z,oz,11,-1); wLetters->Append(&p);	/* Left */    // character 'I'	p.x = FFNeg(FFShift(x,0));	p.y = Six(y,oy,3,+1); p.z = Six(z,oz,11,-1); wLetters->Append(&p);	p.y = Six(y,oy,9,+1); p.z = Six(z,oz,11,-1); wLetters->Append(&p);	p.y = Six(y,oy,6,+1); p.z = Six(z,oz,11,-1); wLetters->Append(&p);	p.y = Six(y,oy,6,+1); p.z = Six(z,oz,1,-1); wLetters->Append(&p);	p.y = Six(y,oy,3,+1); p.z = Six(z,oz,1,-1); wLetters->Append(&p);	p.y = Six(y,oy,9,+1); p.z = Six(z,oz,1,-1); wLetters->Append(&p);	/* Right */    // character 'D'	p.x = FFShift(x,0);	p.y = Six(y,oy,1,+1); p.z = Six(z,oz,1,-1); wLetters->Append(&p);	p.y = Six(y,oy,7,+1); p.z = Six(z,oz,1,-1); wLetters->Append(&p);	p.y = Six(y,oy,11,+1); p.z = Six(z,oz,6,-1); wLetters->Append(&p);	p.y = Six(y,oy,7,+1); p.z = Six(z,oz,11,-1); wLetters->Append(&p);	p.y = Six(y,oy,1,+1); p.z = Six(z,oz,11,-1); wLetters->Append(&p);	p.y = Six(y,oy,2,+1); p.z = Six(z,oz,11,-1); wLetters->Append(&p);	p.y = Six(y,oy,2,+1); p.z = Six(z,oz,1,-1); wLetters->Append(&p);/* Bottom */     // character 'i'	p.z = FFNeg(FFShift(z,0));	p.x = Six(x,ox,4,+1); p.y = Six(y,oy,11,-1); wLetters->Append(&p);	p.x = Six(x,ox,8,+1); p.y = Six(y,oy,11,-1); wLetters->Append(&p);	p.x = Six(x,ox,4,+1); p.y = Six(y,oy,10,-1); wLetters->Append(&p);	p.x = Six(x,ox,8,+1); p.y = Six(y,oy,10,-1); wLetters->Append(&p);	p.x = Six(x,ox,6,+1); p.y = Six(y,oy,10,-1); wLetters->Append(&p);	p.x = Six(x,ox,6,+1); p.y = Six(y,oy,5,-1); wLetters->Append(&p);	p.x = Six(x,ox,7,+1); p.y = Six(y,oy,6,-1); wLetters->Append(&p);	p.x = Six(x,ox,6,+1); p.y = Six(y,oy,3,-1); wLetters->Append(&p);	p.x = Six(x,ox,6,+1); p.y = Six(y,oy,2,-1); wLetters->Append(&p);#else   // default ENGLISH/* Top */	p.z = FFShift(z,0);	p.x = Six(x,ox,1,+1); p.y = Six(y,oy,1,-1); wLetters->Append(&p);	p.x = Six(x,ox,3,+1); p.y = Six(y,oy,1,-1); wLetters->Append(&p);	p.x = Six(x,ox,5,+1); p.y = Six(y,oy,1,-1); wLetters->Append(&p);	p.x = Six(x,ox,3,+1); p.y = Six(y,oy,5,-1); wLetters->Append(&p);/* Front */	p.y = FFNeg(FFShift(y,0));	p.x = Six(x,ox,1,+1); p.z = Six(z,oz,1,-1); wLetters->Append(&p);	p.x = Six(x,ox,5,+1); p.z = Six(z,oz,1,-1); wLetters->Append(&p);	p.x = Six(x,ox,1,+1); p.z = Six(z,oz,3,-1); wLetters->Append(&p);	p.x = Six(x,ox,4,+1); p.z = Six(z,oz,3,-1); wLetters->Append(&p);	p.x = Six(x,ox,1,+1); p.z = Six(z,oz,5,-1); wLetters->Append(&p);/* Back */	p.y = FFShift(y,0);	p.x = Six(x,ox,1,-1); p.z = Six(z,oz,1,-1); wLetters->Append(&p);	p.x = Six(x,ox,4,-1); p.z = Six(z,oz,1,-1); wLetters->Append(&p);	p.x = Six(x,ox,5,-1); p.z = Six(z,oz,2,-1); wLetters->Append(&p);	p.x = Six(x,ox,1,-1); p.z = Six(z,oz,3,-1); wLetters->Append(&p);	p.x = Six(x,ox,4,-1); p.z = Six(z,oz,3,-1); wLetters->Append(&p);	p.x = Six(x,ox,5,-1); p.z = Six(z,oz,4,-1); wLetters->Append(&p);	p.x = Six(x,ox,1,-1); p.z = Six(z,oz,5,-1); wLetters->Append(&p);	p.x = Six(x,ox,4,-1); p.z = Six(z,oz,5,-1); wLetters->Append(&p);/* Left */	p.x = FFNeg(FFShift(x,0));	p.y = Six(y,oy,1,-1); p.z = Six(z,oz,1,-1); wLetters->Append(&p);	p.y = Six(y,oy,1,-1); p.z = Six(z,oz,5,-1); wLetters->Append(&p);	p.y = Six(y,oy,5,-1); p.z = Six(z,oz,5,-1); wLetters->Append(&p);/* Right */	p.x = FFShift(x,0);	p.y = Six(y,oy,1,+1); p.z = Six(z,oz,1,-1); wLetters->Append(&p);	p.y = Six(y,oy,4,+1); p.z = Six(z,oz,1,-1); wLetters->Append(&p);	p.y = Six(y,oy,5,+1); p.z = Six(z,oz,2,-1); wLetters->Append(&p);	p.y = Six(y,oy,1,+1); p.z = Six(z,oz,3,-1); wLetters->Append(&p);	p.y = Six(y,oy,3,+1); p.z = Six(z,oz,3,-1); wLetters->Append(&p);	p.y = Six(y,oy,4,+1); p.z = Six(z,oz,3,-1); wLetters->Append(&p);	p.y = Six(y,oy,1,+1); p.z = Six(z,oz,5,-1); wLetters->Append(&p);	p.y = Six(y,oy,5,+1); p.z = Six(z,oz,5,-1); wLetters->Append(&p);	/* Bottom */	p.z = FFNeg(FFShift(z,0));	p.x = Six(x,ox,2,-1); p.y = Six(y,oy,1,-1); wLetters->Append(&p);	p.x = Six(x,ox,2,-1); p.y = Six(y,oy,2,-1); wLetters->Append(&p);	p.x = Six(x,ox,3,-1); p.y = Six(y,oy,2,-1); wLetters->Append(&p);	p.x = Six(x,ox,4,-1); p.y = Six(y,oy,3,-1); wLetters->Append(&p);	p.x = Six(x,ox,2,-1); p.y = Six(y,oy,4,-1); wLetters->Append(&p);	p.x = Six(x,ox,3,-1); p.y = Six(y,oy,4,-1); wLetters->Append(&p);	p.x = Six(x,ox,2,-1); p.y = Six(y,oy,5,-1); wLetters->Append(&p);	p.x = Six(x,ox,4,-1); p.y = Six(y,oy,5,-1); wLetters->Append(&p);#endif // JAPANESE	lLetters->SetLength(wLetters->ALength());	rLetters->SetLength(wLetters->ALength());	}voidOrientObject::Scale()	{	Point3DFFixed *wp;	Point3DLong *p;	int i,length;			if(!polyhedron) return;		CAVTumbleObject::Scale();		length = wLetters->ALength();		wp = (Point3DFFixed *)wLetters->Use();	p = (Point3DLong *)lLetters->Use();				for(i = 0; i < length; i++,wp++,p++)		*p = environment->WorldToScale(*wp);	wLetters->Unuse();	lLetters->Unuse();	}voidOrientObject::Update(int m[3][3])	{	int i,length;	Point3DLong *lp;	PointLong *rp;		if(!polyhedron) return;		CAVTumbleObject::Update(m);		length = lLetters->ALength();		rp = (PointLong *)rLetters->Use();	lp = (Point3DLong *)lLetters->Use();		for (i=0; i<length; i++,rp++,lp++)		{		NewX(rp->h,m,lp->x,lp->y,lp->z);		NewZ(rp->v,m,-lp->x,-lp->y,-lp->z);		}			lLetters->Unuse();		rLetters->Unuse();	}voidOrientObject::MapSurface(int surf)	{	PointLong	drawOrigin;	PointLong	*p;	drawOrigin = environment->GetDrawOrigin();	p = (PointLong	*)rLetters->Use();	switch (surf)		{#if JAPANESE		case BOTTOM_LETTER:			VMoveTo(p[nBottom+0].h-drawOrigin.h,p[nBottom+0].v-drawOrigin.v);			VLineTo(p[nBottom+1].h-drawOrigin.h,p[nBottom+1].v-drawOrigin.v);			VMoveTo(p[nBottom+2].h-drawOrigin.h,p[nBottom+2].v-drawOrigin.v);			VLineTo(p[nBottom+3].h-drawOrigin.h,p[nBottom+3].v-drawOrigin.v);			VMoveTo(p[nBottom+4].h-drawOrigin.h,p[nBottom+4].v-drawOrigin.v);			VLineTo(p[nBottom+5].h-drawOrigin.h,p[nBottom+5].v-drawOrigin.v);			break;		case BACK_LETTER: 			VMoveTo(p[nBack+0].h-drawOrigin.h,p[nBack+0].v-drawOrigin.v);			VLineTo(p[nBack+1].h-drawOrigin.h,p[nBack+1].v-drawOrigin.v);			VMoveTo(p[nBack+2].h-drawOrigin.h,p[nBack+2].v-drawOrigin.v);			VLineTo(p[nBack+3].h-drawOrigin.h,p[nBack+3].v-drawOrigin.v);			VMoveTo(p[nBack+4].h-drawOrigin.h,p[nBack+4].v-drawOrigin.v);			VLineTo(p[nBack+5].h-drawOrigin.h,p[nBack+5].v-drawOrigin.v);			VMoveTo(p[nBack+6].h-drawOrigin.h,p[nBack+6].v-drawOrigin.v);			VLineTo(p[nBack+7].h-drawOrigin.h,p[nBack+7].v-drawOrigin.v);			VMoveTo(p[nBack+8].h-drawOrigin.h,p[nBack+8].v-drawOrigin.v);			VLineTo(p[nBack+9].h-drawOrigin.h,p[nBack+9].v-drawOrigin.v);			VMoveTo(p[nBack+10].h-drawOrigin.h,p[nBack+10].v-drawOrigin.v);			VLineTo(p[nBack+11].h-drawOrigin.h,p[nBack+11].v-drawOrigin.v);			VMoveTo(p[nBack+12].h-drawOrigin.h,p[nBack+12].v-drawOrigin.v);			VLineTo(p[nBack+13].h-drawOrigin.h,p[nBack+13].v-drawOrigin.v);			VLineTo(p[nBack+14].h-drawOrigin.h,p[nBack+14].v-drawOrigin.v);			VLineTo(p[nBack+15].h-drawOrigin.h,p[nBack+15].v-drawOrigin.v);			VLineTo(p[nBack+16].h-drawOrigin.h,p[nBack+16].v-drawOrigin.v);			VMoveTo(p[nBack+17].h-drawOrigin.h,p[nBack+17].v-drawOrigin.v);			VLineTo(p[nBack+18].h-drawOrigin.h,p[nBack+18].v-drawOrigin.v);			VMoveTo(p[nBack+19].h-drawOrigin.h,p[nBack+19].v-drawOrigin.v);			VLineTo(p[nBack+20].h-drawOrigin.h,p[nBack+20].v-drawOrigin.v);			break;					case FRONT_LETTER: 			VMoveTo(p[nFront+0].h-drawOrigin.h,p[nFront+0].v-drawOrigin.v);			VLineTo(p[nFront+1].h-drawOrigin.h,p[nFront+1].v-drawOrigin.v);			VMoveTo(p[nFront+2].h-drawOrigin.h,p[nFront+2].v-drawOrigin.v);			VLineTo(p[nFront+3].h-drawOrigin.h,p[nFront+3].v-drawOrigin.v);			VMoveTo(p[nFront+4].h-drawOrigin.h,p[nFront+4].v-drawOrigin.v);			VLineTo(p[nFront+5].h-drawOrigin.h,p[nFront+5].v-drawOrigin.v);			VMoveTo(p[nFront+6].h-drawOrigin.h,p[nFront+6].v-drawOrigin.v);			VLineTo(p[nFront+7].h-drawOrigin.h,p[nFront+7].v-drawOrigin.v);			VMoveTo(p[nFront+8].h-drawOrigin.h,p[nFront+8].v-drawOrigin.v);			VLineTo(p[nFront+9].h-drawOrigin.h,p[nFront+9].v-drawOrigin.v);			break;					case LEFT_LETTER:			VMoveTo(p[nLeft+0].h-drawOrigin.h,p[nLeft+0].v-drawOrigin.v);			VLineTo(p[nLeft+1].h-drawOrigin.h,p[nLeft+1].v-drawOrigin.v);			VMoveTo(p[nLeft+2].h-drawOrigin.h,p[nLeft+2].v-drawOrigin.v);			VLineTo(p[nLeft+3].h-drawOrigin.h,p[nLeft+3].v-drawOrigin.v);			VMoveTo(p[nLeft+4].h-drawOrigin.h,p[nLeft+4].v-drawOrigin.v);			VLineTo(p[nLeft+5].h-drawOrigin.h,p[nLeft+5].v-drawOrigin.v);			VMoveTo(p[nLeft+6].h-drawOrigin.h,p[nLeft+6].v-drawOrigin.v);			VLineTo(p[nLeft+7].h-drawOrigin.h,p[nLeft+7].v-drawOrigin.v);			VMoveTo(p[nLeft+8].h-drawOrigin.h,p[nLeft+8].v-drawOrigin.v);			VLineTo(p[nLeft+2].h-drawOrigin.h,p[nLeft+2].v-drawOrigin.v);			VLineTo(p[nLeft+9].h-drawOrigin.h,p[nLeft+9].v-drawOrigin.v);			break;								case RIGHT_LETTER: 			VMoveTo(p[nRight+0].h-drawOrigin.h,p[nRight+0].v-drawOrigin.v);			VLineTo(p[nRight+1].h-drawOrigin.h,p[nRight+1].v-drawOrigin.v);			VMoveTo(p[nRight+2].h-drawOrigin.h,p[nRight+2].v-drawOrigin.v);			VLineTo(p[nRight+3].h-drawOrigin.h,p[nRight+3].v-drawOrigin.v);			VLineTo(p[nRight+4].h-drawOrigin.h,p[nRight+4].v-drawOrigin.v);			VLineTo(p[nRight+5].h-drawOrigin.h,p[nRight+5].v-drawOrigin.v);			VLineTo(p[nRight+2].h-drawOrigin.h,p[nRight+2].v-drawOrigin.v);			VMoveTo(p[nRight+6].h-drawOrigin.h,p[nRight+6].v-drawOrigin.v);			VLineTo(p[nRight+2].h-drawOrigin.h,p[nRight+2].v-drawOrigin.v);			VLineTo(p[nRight+7].h-drawOrigin.h,p[nRight+7].v-drawOrigin.v);			break;					case TOP_LETTER: 			VMoveTo(p[nTop+0].h-drawOrigin.h,p[nTop+0].v-drawOrigin.v);			VLineTo(p[nTop+1].h-drawOrigin.h,p[nTop+1].v-drawOrigin.v);			VMoveTo(p[nTop+2].h-drawOrigin.h,p[nTop+2].v-drawOrigin.v);			VLineTo(p[nTop+3].h-drawOrigin.h,p[nTop+3].v-drawOrigin.v);			VMoveTo(p[nTop+4].h-drawOrigin.h,p[nTop+4].v-drawOrigin.v);			VLineTo(p[nTop+5].h-drawOrigin.h,p[nTop+5].v-drawOrigin.v);			break;#elif SPANISH		case BOTTOM_LETTER:			VMoveTo(p[nBottom+0].h-drawOrigin.h,p[nBottom+0].v-drawOrigin.v);			VLineTo(p[nBottom+1].h-drawOrigin.h,p[nBottom+1].v-drawOrigin.v);			VMoveTo(p[nBottom+2].h-drawOrigin.h,p[nBottom+2].v-drawOrigin.v);			VLineTo(p[nBottom+3].h-drawOrigin.h,p[nBottom+3].v-drawOrigin.v);			VMoveTo(p[nBottom+4].h-drawOrigin.h,p[nBottom+4].v-drawOrigin.v);			VLineTo(p[nBottom+5].h-drawOrigin.h,p[nBottom+5].v-drawOrigin.v);			VLineTo(p[nBottom+6].h-drawOrigin.h,p[nBottom+6].v-drawOrigin.v);			VMoveTo(p[nBottom+7].h-drawOrigin.h,p[nBottom+7].v-drawOrigin.v);			VLineTo(p[nBottom+8].h-drawOrigin.h,p[nBottom+8].v-drawOrigin.v);			break;		case BACK_LETTER: 			VMoveTo(p[nBack+0].h-drawOrigin.h,p[nBack+0].v-drawOrigin.v);			VLineTo(p[nBack+1].h-drawOrigin.h,p[nBack+1].v-drawOrigin.v);			VLineTo(p[nBack+2].h-drawOrigin.h,p[nBack+2].v-drawOrigin.v);			VLineTo(p[nBack+3].h-drawOrigin.h,p[nBack+3].v-drawOrigin.v);			VLineTo(p[nBack+4].h-drawOrigin.h,p[nBack+4].v-drawOrigin.v);			VMoveTo(p[nBack+5].h-drawOrigin.h,p[nBack+5].v-drawOrigin.v);			VLineTo(p[nBack+6].h-drawOrigin.h,p[nBack+6].v-drawOrigin.v);			break;					case FRONT_LETTER: 			VMoveTo(p[nFront+0].h-drawOrigin.h,p[nFront+0].v-drawOrigin.v);			VLineTo(p[nFront+1].h-drawOrigin.h,p[nFront+1].v-drawOrigin.v);			VLineTo(p[nFront+2].h-drawOrigin.h,p[nFront+2].v-drawOrigin.v);			VMoveTo(p[nFront+3].h-drawOrigin.h,p[nFront+3].v-drawOrigin.v);			VLineTo(p[nFront+4].h-drawOrigin.h,p[nFront+4].v-drawOrigin.v);			break;					case LEFT_LETTER:			VMoveTo(p[nLeft+0].h-drawOrigin.h,p[nLeft+0].v-drawOrigin.v);			VLineTo(p[nLeft+1].h-drawOrigin.h,p[nLeft+1].v-drawOrigin.v);			VMoveTo(p[nLeft+2].h-drawOrigin.h,p[nLeft+2].v-drawOrigin.v);			VLineTo(p[nLeft+3].h-drawOrigin.h,p[nLeft+3].v-drawOrigin.v);			VMoveTo(p[nLeft+4].h-drawOrigin.h,p[nLeft+4].v-drawOrigin.v);			VLineTo(p[nLeft+5].h-drawOrigin.h,p[nLeft+5].v-drawOrigin.v);			break;								case RIGHT_LETTER: 			VMoveTo(p[nRight+0].h-drawOrigin.h,p[nRight+0].v-drawOrigin.v);			VLineTo(p[nRight+1].h-drawOrigin.h,p[nRight+1].v-drawOrigin.v);			VLineTo(p[nRight+2].h-drawOrigin.h,p[nRight+2].v-drawOrigin.v);			VLineTo(p[nRight+3].h-drawOrigin.h,p[nRight+3].v-drawOrigin.v);			VLineTo(p[nRight+4].h-drawOrigin.h,p[nRight+4].v-drawOrigin.v);			VMoveTo(p[nRight+5].h-drawOrigin.h,p[nRight+5].v-drawOrigin.v);			VLineTo(p[nRight+6].h-drawOrigin.h,p[nRight+6].v-drawOrigin.v);			break;					case TOP_LETTER: 			VMoveTo(p[nTop+0].h-drawOrigin.h,p[nTop+0].v-drawOrigin.v);			VLineTo(p[nTop+1].h-drawOrigin.h,p[nTop+1].v-drawOrigin.v);			VLineTo(p[nTop+2].h-drawOrigin.h,p[nTop+2].v-drawOrigin.v);			VLineTo(p[nTop+3].h-drawOrigin.h,p[nTop+3].v-drawOrigin.v);			VLineTo(p[nTop+4].h-drawOrigin.h,p[nTop+4].v-drawOrigin.v);			VLineTo(p[nTop+5].h-drawOrigin.h,p[nTop+5].v-drawOrigin.v);			break;#else // ENGLISH		case BOTTOM_LETTER: 			VMoveTo(p[nBottom+0].h-drawOrigin.h,p[nBottom+0].v-drawOrigin.v);			VLineTo(p[nBottom+4].h-drawOrigin.h,p[nBottom+4].v-drawOrigin.v);			VLineTo(p[nBottom+5].h-drawOrigin.h,p[nBottom+5].v-drawOrigin.v);			VLineTo(p[nBottom+3].h-drawOrigin.h,p[nBottom+3].v-drawOrigin.v);			VLineTo(p[nBottom+2].h-drawOrigin.h,p[nBottom+2].v-drawOrigin.v);			VLineTo(p[nBottom+1].h-drawOrigin.h,p[nBottom+1].v-drawOrigin.v);			VMoveTo(p[nBottom+6].h-drawOrigin.h,p[nBottom+6].v-drawOrigin.v);			VLineTo(p[nBottom+7].h-drawOrigin.h,p[nBottom+7].v-drawOrigin.v);			break;		case BACK_LETTER: 			VMoveTo(p[nBack+3].h-drawOrigin.h,p[nBack+3].v-drawOrigin.v);			VLineTo(p[nBack+4].h-drawOrigin.h,p[nBack+4].v-drawOrigin.v);			VLineTo(p[nBack+5].h-drawOrigin.h,p[nBack+5].v-drawOrigin.v);			VLineTo(p[nBack+7].h-drawOrigin.h,p[nBack+7].v-drawOrigin.v);			VLineTo(p[nBack+6].h-drawOrigin.h,p[nBack+6].v-drawOrigin.v);			VLineTo(p[nBack+0].h-drawOrigin.h,p[nBack+0].v-drawOrigin.v);			VLineTo(p[nBack+1].h-drawOrigin.h,p[nBack+1].v-drawOrigin.v);			VLineTo(p[nBack+2].h-drawOrigin.h,p[nBack+2].v-drawOrigin.v);			VLineTo(p[nBack+4].h-drawOrigin.h,p[nBack+4].v-drawOrigin.v);			break;					case FRONT_LETTER: 			VMoveTo(p[nFront+1].h-drawOrigin.h,p[nFront+1].v-drawOrigin.v);			VLineTo(p[nFront+0].h-drawOrigin.h,p[nFront+0].v-drawOrigin.v);			VLineTo(p[nFront+4].h-drawOrigin.h,p[nFront+4].v-drawOrigin.v);			VMoveTo(p[nFront+2].h-drawOrigin.h,p[nFront+2].v-drawOrigin.v);			VLineTo(p[nFront+3].h-drawOrigin.h,p[nFront+3].v-drawOrigin.v);			break;					case LEFT_LETTER:			VMoveTo(p[nLeft+0].h-drawOrigin.h,p[nLeft+0].v-drawOrigin.v);			VLineTo(p[nLeft+1].h-drawOrigin.h,p[nLeft+1].v-drawOrigin.v);			VLineTo(p[nLeft+2].h-drawOrigin.h,p[nLeft+2].v-drawOrigin.v);			break;								case RIGHT_LETTER: 			VMoveTo(p[nRight+6].h-drawOrigin.h,p[nRight+6].v-drawOrigin.v);			VLineTo(p[nRight+0].h-drawOrigin.h,p[nRight+0].v-drawOrigin.v);			VLineTo(p[nRight+1].h-drawOrigin.h,p[nRight+1].v-drawOrigin.v);			VLineTo(p[nRight+2].h-drawOrigin.h,p[nRight+2].v-drawOrigin.v);			VLineTo(p[nRight+5].h-drawOrigin.h,p[nRight+5].v-drawOrigin.v);			VLineTo(p[nRight+3].h-drawOrigin.h,p[nRight+3].v-drawOrigin.v);			VMoveTo(p[nRight+4].h-drawOrigin.h,p[nRight+4].v-drawOrigin.v);			VLineTo(p[nRight+7].h-drawOrigin.h,p[nRight+7].v-drawOrigin.v);			break;					case TOP_LETTER: 			VMoveTo(p[nTop+0].h-drawOrigin.h,p[nTop+0].v-drawOrigin.v);			VLineTo(p[nTop+2].h-drawOrigin.h,p[nTop+2].v-drawOrigin.v);			VMoveTo(p[nTop+1].h-drawOrigin.h,p[nTop+1].v-drawOrigin.v);			VLineTo(p[nTop+3].h-drawOrigin.h,p[nTop+3].v-drawOrigin.v);			break;#endif // JAPANESE		}	rLetters->Unuse();	}FFixedSix(FFixed n, FFixed o,int i, int s)	{	FFixed	tmp;	#if JAPANESE || SPANISH	if (s<0) i=12-i;#else	if (s<0) i=6-i;#endif // JAPANESE	switch(i)		{#if JAPANESE || SPANISH		// jca 19APR95 if this is Japanese, then add a few extra.  I suppose this routine        // should be called "ten" or "twelve" or something, but this was much easier.		case 0: tmp = FFZero; break;		case 1: tmp.intg = 0; tmp.frac = 0x4000; break;		case 2: tmp.intg = 0; tmp.frac = 0x7000; break;		case 3: tmp.intg = 0; tmp.frac = 0x8000; break;		case 4: tmp.intg = 0; tmp.frac = 0x9000; break;		case 5: tmp.intg = 0; tmp.frac = 0xB000; break;		case 6: tmp = FFOne; break;		case 7: tmp.intg = 1; tmp.frac = 0x4000; break;		case 8: tmp.intg = 1; tmp.frac = 0x7000; break;		case 9: tmp.intg = 1; tmp.frac = 0x8000; break;		case 10: tmp.intg = 1; tmp.frac = 0x9000; break;		case 11: tmp.intg = 1; tmp.frac = 0xB000; break;#else		case 0: tmp = FFZero; break;		case 1: tmp.intg = 0; tmp.frac = 0x5556; break;			case 2: tmp.intg = 0; tmp.frac = 0xAAAA; break;			case 3: tmp = FFOne; break;		case 4: tmp.intg = 1; tmp.frac = 0x5556; break;		case 5: tmp.intg = 1; tmp.frac = 0xAAAA; break;#endif //		}	tmp = FFMult(n,tmp);	tmp = FFAdd(o,tmp);		return(tmp);	}