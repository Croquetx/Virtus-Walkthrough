/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				David A. Smith * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "FoclPane.h"#include "VwCntrl.h"#include "Clip.h"#include "AppText.h"#include "AppDeflt.h"#include "ToolDef.h"#include "BallHelp.h"#include "VGraphic.h"#include "VGUtil.h"#include "VWindow.h"#include "Misc.h"#include "Geometry.h"#include <stdio.h>#include <string.h>#include <math.h>#define MASK_PICT -32762#define SLIDER_PICT	-32761#define SLIDER_LENGTH	31#define FOCAL_TEXT_FONT vTimesFont#define FOCAL_TEXT_SIZE vMediumFont#define MAX_FOCAL	500#define MIN_FOCAL	15#define RULER_WIDTH	13#define RULER_LEFT	18#if WINDOWS#define RULER_TOP_OFFSET 40#define EDITBOX_CONST 	7#define EDITBOX_UNIT_OFFSET	38#elif MACINTOSH#define RULER_TOP_OFFSET 34#define EDITBOX_CONST 	6#define EDITBOX_UNIT_OFFSET	39#endif // WINDOWS// {DAS-VR 10/23/93 turning this guy OFF#if VWTPoint mountain[]={InitPt(-135,-120),InitPt(25,-30),InitPt(-5,-10),InitPt(-5,10),InitPt(-35,30),InitPt(25,60),InitPt(-135,120)};Point house[]={InitPt(-5,-5),InitPt(5,-5),InitPt(10,0),InitPt(5,5),InitPt(-5,5)};Point window[]={InitPt(-3,-3),InitPt(3,-3),InitPt(3,3),InitPt(-3,3)};Point pane[]={InitPt(-3,0),InitPt(3,0),InitPt(0,3),InitPt(0,-3)};#endifvoid FocalPane::SetController(Controller *ctrl) 	{		controller = ctrl;	}// { DAS-VR 10/23/93voidFocalPane::cPane(int flag) 	{		VStyleRec style;		Rect r;	char str[256];	double n1,n2,d;	int i;	focal = 36;	V_Pane::cPane(flag);#if VWT	mask=new(V_Offscreen);	if(mask->LoadPNum(MASK_PICT,0))mask=NULL;	slider=new(V_Offscreen);	if(slider->LoadPNum(SLIDER_PICT,0))slider=NULL;		r.left=dataRect.left+RULER_WIDTH+20;r.right=r.left+35;	r.top=dataRect.top+4;	r.bottom=r.top+10;	zoom=new(CameraText);	zoom->cItem();#if WINDOWS	/*because Windows includes the frame in the definition*/	r.top--;	r.bottom++;	r.left--;	r.right++;#endif	zoom->SetRect(&r);	zoom->GetStyle(&style);	style.font = FOCAL_TEXT_FONT;	style.size = FOCAL_TEXT_SIZE;	zoom->SetStyle(&style);	AddItem(zoom);			/*build the table*/	n1=log(MAX_FOCAL);	n2=log(MIN_FOCAL);	d=(n1-n2)/(CAMERA_LENGTH-1);	n1=0;	for(i=0;i<CAMERA_LENGTH;i++)		{		//table[i]=exp(n1+n2);  jca.  the system has been truncating.		table[i]=(exp(n1+n2) + 0.5);		n1+=d;		}	table[CAMERA_LENGTH-1]=MAX_FOCAL;	i=0;	while(focal>table[i])i++;	fval=i;	fval>>=warn;	sprintf(str,"%d",focal);	zoom->SetText(str);		VSetCursor(vCursorArrow);#endif	}void FocalPane::dPane() 	{#if VWT	if(mask)mask->dOffscreen();	if(slider)slider->dOffscreen();#endif	V_Pane::dPane();	}voidFocalPane::TrackHelp(Point pt,long modifier)// DAS-VWINDOWS 9/30/93	{// { DAS-VR-HELP 9/30/93#if VWT	Rect r;		r = dataRect;	BalloonHotRect(&r,pt);	Bubble(pt,&r,TXTB_FOCALLENGTH);#endif// } DAS-VR-HELP 9/30/93	}void FocalPane::CalcSize(Rect *r,Point *p,int type,int warning)	{#if VWT	Rect zR;		controller->GetPlace(r,warning,toolPFocal);		if(warning)		{		zR.top=2;		zR.bottom=zR.top+10;		}	else		{		zR.top=2+((r->right-r->left)*4)/5;		zR.bottom=zR.top+10;		}	zR.left=RULER_WIDTH+EDITBOX_CONST;	zR.right=r->right-(RULER_WIDTH+EDITBOX_CONST);#if WINDOWS	/*because Windows includes the frame in the definition*/	zR.top--;	zR.bottom++;	zR.left--;	zR.right++;#endif //WINDOWS	zoom->SetRect(&zR);//	lastRuler=-1000;   xyzzy this is always called	warn=warning?1:0;#endif	}int myOffscrn = TRUE;void FocalPane::Display(int type,int x,int y)	{#if VWT	Rect	r;		int		w,h;	VGrafPort savePort;	VGrafPort port;	VGrafDevice saveDev;			switch(type)		{		default:			r = dataRect;						//savePort = (*(zoom->textbox))->inPort;						SetMetaPort();							//VGetPort(&savePort, &saveDev);		// MERGE-GOURAUD-PRO-4			DrawBackGround();			if(!warn)DrawScene();			DrawSlider();			MetaCopy(&r);			UnsetMetaPort();			V_Pane::Display(type,x,y);			//itemList->SetDisplay(savePort);		// MERGE-GOURAUD-PRO-4						//GetWMgrPort(&port);			//if (savePort == port) 			//	Debugger();			//if (thePort == port) 			//	Debugger();			break;							case -DRAW:  			//savePort = (*(zoom->textbox))->inPort;			//GetWMgrPort(&port);			//if (savePort == port) 			//	Debugger();			SetMetaPort();				//VGetPort(&savePort, &saveDev);		// MERGE-GOURAUD-PRO-4			slider->GetRect(&r);			h=(r.bottom-r.top)>>1;			w = r.right-r.left;						r.top=rulerRect.top-h;			r.bottom=rulerRect.bottom+h;			r.left=rulerRect.right+2;			r.right=r.left+w;			if(!warn)DrawScene();			MetaCopy(&pictureFrame);			UnsetMetaPort(); 			//savePort = (*(zoom->textbox))->inPort;			//GetWMgrPort(&port);			//if (savePort == port) 			//	Debugger();			SetMetaPort();			DrawSlider();		 	MetaCopy(&r);   		 	UnsetMetaPort();			V_Pane::Display(type,x,y);		// MERGE-GOURAUD-PRO-4			//itemList->SetDisplay(savePort);		// MERGE-GOURAUD-PRO-4						//GetWMgrPort(&port);			//if (savePort == port) 			//	Debugger();			//if (thePort == port) 			//	Debugger();						break;		}#endif		}voidFocalPane::DrawBackGround()	{			#if VWT	Rect	r,tR,txtR;	char	str[256];	int 	i,count;		VPenMode(vPatCopy);		r = dataRect;	pictureFrame=dataRect;	if(!warn)		{		pictureFrame.bottom=((pictureFrame.right-pictureFrame.left)*4)/5;		pictureFrame.top+=1;		pictureFrame.left+=1;		pictureFrame.bottom-=1;		pictureFrame.right-=1;		}	else pictureFrame.bottom=pictureFrame.top;		if(depth>=4)		VForeColor(&vColorSlateM);	else VForeColor(&vWhite);	VPaintRect(&r);	VForeColor(&vBlack);	slider->GetRect(&tR);	VForeColor(&vWhite);	rulerRect.left=RULER_LEFT;	rulerRect.right=RULER_LEFT+RULER_WIDTH+1;	rulerRect.top=(pictureFrame.bottom-pictureFrame.top)+RULER_TOP_OFFSET;	rulerRect.bottom=rulerRect.top+CAMERA_LENGTH;		VPaintRect(&rulerRect);	VForeColor(&vBlack);	VFrameRect(&rulerRect);	rulerRect.bottom--;	i=0;	for(count=25;count<MAX_FOCAL;count+=25)		{		while(count>table[i] && i<CAMERA_LENGTH-1)i++;		VMoveTo(rulerRect.left,rulerRect.bottom-i);		VLineTo(rulerRect.right-8,rulerRect.bottom-i);		table[i]=count;		}	i=0;	for(count=50;count<MAX_FOCAL;count+=100)		{		while(count>table[i] && i<CAMERA_LENGTH-1)i++;		VMoveTo(rulerRect.left,rulerRect.bottom-i);		VLineTo(rulerRect.right-6,rulerRect.bottom-i);		table[i]=count;		}	i=0;	for(count=100;count<MAX_FOCAL;count+=100)		{		while(count>table[i] && i<CAMERA_LENGTH-1)i++;		VMoveTo(rulerRect.left,rulerRect.bottom-i);		VLineTo(rulerRect.right-4,rulerRect.bottom-i);		table[i]=count;		}			TextSetUp(vAppFont,vAppFontSize,vNormal);#if WINDOWS	VTextMode(vSrcXor);	txtR = rulerRect;	txtR.left+=2;txtR.bottom+=10;txtR.top=txtR.bottom-vAppFontSize;	sprintf(str,"%d",MIN_FOCAL);	VDrawText(str,0,strlen(str),&txtR);	txtR = rulerRect;	txtR.left-=2;txtR.bottom+=18;txtR.top=txtR.bottom-vAppFontSize;	VDrawText(TXTI_FOCALUNIT,0,strlen(TXTI_FOCALUNIT),&txtR);	txtR = rulerRect;	txtR.left-=4;txtR.bottom=txtR.top-12;txtR.top=txtR.bottom-vAppFontSize;	sprintf(str,"%d",MAX_FOCAL);	VDrawText(str,0,strlen(str),&txtR);	txtR = rulerRect;	txtR.left-=2;txtR.bottom=txtR.top-4;txtR.top=txtR.bottom-vAppFontSize;	VDrawText(TXTI_FOCALUNIT,0,strlen(TXTI_FOCALUNIT),&txtR);	zoom->GetRect(&r);	//r.left+=2;	r.left+=EDITBOX_UNIT_OFFSET;	VDrawText(TXTI_FOCALUNIT,0,strlen(TXTI_FOCALUNIT),&r);	VTextMode(vSrcOr);#elif MACINTOSH	VTextMode(vSrcOr);	sprintf(str,"%d",MIN_FOCAL); 	txtR = rulerRect; 	txtR.left-=2;txtR.bottom+=10;txtR.top=txtR.bottom-vAppFontSize;		// MERGE-GOURAUD-PRO-5	VDrawText(str,0,strlen(str),&txtR);	txtR.bottom+=8;txtR.top=txtR.bottom-vAppFontSize;	VDrawText(TXTI_FOCALUNIT,0,strlen(TXTI_FOCALUNIT),&txtR);		sprintf(str,"%d",MAX_FOCAL); 	txtR = rulerRect; 	txtR.left-=2;txtR.bottom=txtR.top-1;txtR.top=txtR.bottom-vAppFontSize;		// MERGE-GOURAUD-PRO-5	VDrawText(TXTI_FOCALUNIT,0,strlen(TXTI_FOCALUNIT),&txtR);	txtR.left-=6;txtR.bottom=txtR.top+1;txtR.top=txtR.bottom-vAppFontSize;	VDrawText(str,0,strlen(str),&txtR);	zoom->GetRect(&r);	//r.left+=2;	r.left+= EDITBOX_UNIT_OFFSET;	VDrawText(TXTI_FOCALUNIT,0,strlen(TXTI_FOCALUNIT),&r);	VTextMode(vSrcOr);#endif //WINDOWS	VForeColor(&vBlack);	VFrameRect(&pictureFrame);	pictureFrame.top++;	pictureFrame.left++;	pictureFrame.right--;	pictureFrame.bottom--;#endif	}voidFocalPane::DrawSlider()	{#if VWT	Rect	tR,cR,loc;	int 	h,w;	slider->GetRect(&cR);	h=(cR.bottom-cR.top)>>1;	loc.top=rulerRect.top-h;	loc.bottom=rulerRect.bottom+h;	loc.left=rulerRect.right+2;	loc.right=loc.left+cR.right-cR.left;		/*erase the old strip*/	if(depth>=4)		VForeColor(&vColorSlateM);	else VForeColor(&vWhite);	VPaintRect(&loc);	/*draw the sliders new track*/	tR=rulerRect;	tR.left+=RULER_WIDTH+12;	tR.right=tR.left+6;	VForeColor(&vBlack);	VSetPattern(vPatGray);	VFillRect(&tR);	VSetPattern(vPatBlack);	VFrameRect(&tR);	tR.top++;	tR.left++;	VFrameRect(&tR);	/*draw the slider in its new position*/	tR.top=rulerRect.bottom-(fval+h-1);	tR.bottom=tR.top+cR.bottom-cR.top;	tR.left=rulerRect.right+2;	tR.right=tR.left+(cR.right-cR.left);	if(offscreen)		{		if(depth>=4)slider->MaskMetaTo(offscreen,mask,&cR,&tR);		else slider->MetaTo(offscreen,&cR,&tR);		}	else		{		if(depth>=4)slider->MaskMetaTo(theWindow,mask,&cR,&tR);		else slider->MetaTo(theWindow,&cR,&tR);		}#endif	}	void FocalPane::DrawScene()	{#if VWT	PointLong scale[7],p1,p2;	long i,val;	int temp,f=focal;		int cX=(pictureFrame.left+pictureFrame.right)>>1;	int cY=(pictureFrame.top+pictureFrame.bottom)>>1;		VForeColor(&vWhite);	VPaintRect(&pictureFrame);	VForeColor(&vBlack);	for(i=0;i<7;i++)		{		temp=mountain[i].h;		val=(long)temp*f;		scale[i].h=cX+(val>>6);		temp=mountain[i].v;		val=(long)temp*f;		scale[i].v=cY-(val>>6);		}	for(i=0;i<6;i++)		{		p1=scale[i];		p2=scale[i+1];		if (LongClipRect(&p1,&p2,&pictureFrame))			{			VMoveTo(p1.h,p1.v);			VLineTo(p2.h,p2.v);			}		}	for(i=0;i<5;i++)		{		temp=house[i].h;		val=(long)temp*f;		scale[i].h=cX+(val>>6);		temp=house[i].v;		val=(long)temp*f;		scale[i].v=cY-(val>>6);		}	for(i=0;i<4;i++)		{		p1=scale[i];		p2=scale[i+1];		if (LongClipRect(&p1,&p2,&pictureFrame))			{			VMoveTo(p1.h,p1.v);			VLineTo(p2.h,p2.v);			}		}	for(i=0;i<4;i++)		{		temp=window[i].h;		val=(long)temp*f;		scale[i].h=cX+(val>>6);		temp=window[i].v;		val=(long)temp*f;		scale[i].v=cY-(val>>6);		}	for(i=0;i<4;i++)		{		p1=scale[i];		p2=scale[nextNum(i,4)];		if (LongClipRect(&p1,&p2,&pictureFrame))			{			VMoveTo(p1.h,p1.v);			VLineTo(p2.h,p2.v);			}		}	for(i=0;i<4;i++)		{		temp=pane[i].h;		val=(long)temp*f;		scale[i].h=cX+(val>>6);		temp=pane[i].v;		val=(long)temp*f;		scale[i].v=cY-(val>>6);		}	p1=scale[0];	p2=scale[1];	if (LongClipRect(&p1,&p2,&pictureFrame))		{		VMoveTo(p1.h,p1.v);		VLineTo(p2.h,p2.v);		}		p1=scale[2];	p2=scale[3];	if (LongClipRect(&p1,&p2,&pictureFrame))		{		VMoveTo(p1.h,p1.v);		VLineTo(p2.h,p2.v);		}	//MetaCopy(&pictureFrame);		//			UnsetMetaPort();	//			SetMetaPort();#endif //VWT	}void  FocalPane::MouseDown(Point p,long modifiers)	{#if VWT	offset=rulerRect.bottom-p.v;	lastLoc=offset;	offset-=fval;	if(offset>=-SLIDER_LENGTH>>1 && offset<=SLIDER_LENGTH>>1)		{		lastRuler=-1000;		TrackRuler(fval,TRUE);		tracking=TRUE;		}	VSetCursor(vCursorArrow);#endif	}void  FocalPane::Track(Point p,long modifiers,int lastCall)	{#if VWT	char str[256];	int loc,delta;		VSetCursor(vCursorArrow);	if((modifiers & buttonDown) && tracking)/*track the camera*/		{		loc=rulerRect.bottom-p.v-offset;		if(loc<0)loc=0;		if(loc>CAMERA_LENGTH-1)loc=CAMERA_LENGTH-1;		if(loc!=fval)			{			fval=loc;			TrackRuler(fval,TRUE);			sprintf(str,"%d",focal=table[fval]);			zoom->SetText(str);			Display(-DRAW,0,0);			}		}#endif	}voidFocalPane::TrackRuler(int loc,int force)	{#if VWT	int h;	VSetPattern(vPatGray);	VPenMode(vPatXor);	if(force)  //Draw the new one		{		if(loc>=0 && loc<(CAMERA_LENGTH))			{			h=rulerRect.bottom-loc;			VMoveTo(RULER_LEFT+1,h);			VLineTo(RULER_LEFT+RULER_WIDTH,h);			}		}	if(lastRuler>=0 && lastRuler<(CAMERA_LENGTH))//erase the old one		{		h=rulerRect.bottom-lastRuler;		VMoveTo(RULER_LEFT+1,h);		VLineTo(RULER_LEFT+RULER_WIDTH,h);		}	lastRuler=loc;	VPenMode(vPatCopy);	VSetPattern(vPatBlack);#endif	}void  FocalPane::MouseUp(Point p,long modifiers)	{#if VWT	VSetCursor(vCursorArrow);	if(tracking)		{		TrackRuler(fval,FALSE);		SetFocal(focal);		Update();		}	tracking=FALSE;#endif	}	int FocalPane::KeyAction(char c,long modifiers)	{#if VWT	switch(c)		{		#if 0	// MERGE-GOURAUD-PRO-5 don't want this anymore -- navigate with arrow keys		case V_UPARROW:			if(fval<CAMERA_LENGTH-1)				while(table[fval]==table[fval+1])fval++;			fval++;			if(fval>=CAMERA_LENGTH)fval=CAMERA_LENGTH-1;			SetFocal(table[fval]);			Update();			break;		case V_DOWNARROW:			fval-=2;			if(fval<0)fval=0;			SetFocal(table[fval]);			Update();			break;		#endif		default:			return FALSE;			break;		}	return(TRUE);#endif	}	void FocalPane::SetFocal(int f)	{// { DAS-VR 10/23/93#if VWT	int i=0;	char str[256];		if(f<MIN_FOCAL || f >MAX_FOCAL)return;		focal=f;	while(focal>table[i])i++;	fval=i;	sprintf(str,"%d",focal);	zoom->SetText(str);	VDisplay(-DRAW);	#endif// } DAS-VR 10/23/93	}voidFocalPane::Update()	{	AppPreference	*appPref;	NavigatePreference *navPref;	appPref = controller->GetPreference();	navPref = (NavigatePreference*)appPref->GetPreference(preferNavigate);	navPref->focalLength = focal;		navPref->SetChange(TRUE);	controller->Request(NULL, msgReset, objView, 0);	navPref->SetChange(FALSE);	}	int CameraText::Action(char c,long modifier)	{#if VWT	if(c==V_RETURN || c==V_ENTER)		{		char str[256];		int num;				GetText(str);		num=((FocalPane*)thePane)->focal;		sscanf(str,"%d",&num);		if(num<MIN_FOCAL)num=MIN_FOCAL;		if(num>MAX_FOCAL)num=MAX_FOCAL;		((FocalPane *)thePane)->SetFocal(num);		((FocalPane *)thePane)->Update();		return(TRUE);		}	else return ((FocalPane *)thePane)->KeyAction(c,modifier);#endif	}