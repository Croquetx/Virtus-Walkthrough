/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "Observer.h"#include "WalkBuff.h" /* DWEE */#include "WlkCntrl.h"#include "Drawing.h"#include "Polyhdrn.h"#include "PolyConv.h"#include "VMath.h"#include "VArray.h"#include "VSound.h"#include "VDisplay.h"#include "VGUtil.h"#include "VMemUtil.h"#include "VError.h"// MERGE-FPS2 [[[// define this, and also FRAMES_PER_SECOND in WALKPANE.CP to get FPS indicator//# define FRAMES_PER_SECOND// MERGE-FPS2 ]]]// MERGE-HMD [[[#if USE_HMD#include "HMD.h"#endif // USE_HMD// MERGE-HMD ]]]#ifdef FRAMES_PER_SECOND#if MACINTOSH#include "VTimer.h"#include <stdio.h>#include "ShowTest.h"#endif //MACINTOSH#endif // FRAMES_PER_SECONDvoid Observer::cView(WalkDrawing *dwg)	{		controller = NULL;		View::cView(dwg);		record = FALSE;	frame = 0;	FFpoint = lastPoint = Pt3DFFZero;	FFangle = lastAngle = Ang3DFFZero;		path = new(V_Array);	path->cArray(0,sizeof(ObserverStep*),4);	#if USE_HMD	use_hmds = FALSE; 	// ABD HMD MAR95	hmd = NULL;			// ABD HMD MAR95	#endif // USE_HMD	}void Observer::dView()	{	KillPath();	path->dArray();	// MERGE-HMD [[[	#if USE_HMD	// destroy the hmd if there is one	DestroyHMD();	#endif // USE_HMD	// MERGE-HMD ]]]	View::dView();	}void Observer::SetController(Controller *ctrl)	{		controller = ctrl;	}Polyhedron * Observer::FindContainer()	{	Polyhedron *polyhedron;	polyhedron = viewPoly->polyhedron;	return(polyhedron);	}void Observer::GetPosition(Point3DFFixed *pt,Angle3DFFixed *ang)	{	FFixed	conv = INITFIXXED(0, 0x0649);		*pt = FFpoint;		ang->roll = FFMult(FFangle.roll,conv);	ang->pitch = FFMult(FFangle.pitch,conv);	ang->yaw = FFMult(FFangle.yaw,conv);	}void Observer::SetPosition(Point3DFFixed newView,Angle3DFFixed newAngle)	{		ObserverStep *step;	/*	lastPoint = FFpoint;	lastAngle = FFangle;		FFpoint = newView;	FFangle = newAngle;		point.x = FFpoint.x.intg;	point.y = FFpoint.y.intg;	point.z = FFpoint.z.intg;		angle.roll = FFangle.roll.intg;	angle.pitch = FFangle.pitch.intg;	angle.yaw = FFangle.yaw.intg;*/		SetFFPoint(newView);	SetFFAngle(newAngle);		if(TRUE == record) 		RecordPosition();	}void Observer::KillPath()	{	ObserverStep **step;	int	i,length;		length = path->ALength();	step = (ObserverStep **)path->Use();	for(i = 0;i < length; i++,step++)		(*step)->dPathStep();	path->Unuse();	path->SetLength(0);	}int Observer::GetFrame() { return(frame); }int Observer::SetFrame(int newFrame) 	{ 	ObserverStep *step;	Point3DFFixed	pt;	Angle3DFFixed	agl;	long	length;	int		result;		length = path->ALength();	if(!length) 		result  = TRUE;	else		{		length--;		result = FALSE;		frame = newFrame;				if(frame > length){ frame = length; result = TRUE; }		if(frame < 0){ frame = 0; result = TRUE; }				path->Get(frame,&step);		step->GetStep(&pt,&agl);		SetPosition(pt,agl);	SetFFAngleHiRes(agl);		}			if(result)VPlaySound(beepSound);	return(result);	}void Observer::RecordPosition() 	{ 	ObserverStep *step;		step = new(ObserverStep);		step->cPathStep();	step->SetStep(FFpoint,FFangle);	path->Append(&step);			}void Observer::Record(int state,int flush)	{	record = state;	if(TRUE == flush)		KillPath();	}void Observer::Walk()	{	ObserverStep **step,**step2;	Point3DFFixed	pt;	Angle3DFFixed	agl;	long	i,length;	int		btnDown;#if WINDOWS	int 	btnUp=FALSE;#endif	length = path->ALength();	if(!length)return;	btnDown = FALSE;	step2 = (ObserverStep **)path->Use();	if(frame>=length)frame=0; // DAS-VR-FIX 9/26/93	while(!btnDown)		{// MERGE_FPS2 [[[#ifdef FRAMES_PER_SECOND#if MACINTOSH		StartTimingMilli();		// for entire path#endif //MACINTOSH#endif //FRAMES_PER_SECOND		step = &step2[frame]; // DAS-VR-FIX 9/26/93 begin where we left off		for(i = frame;i < length; i++,step++) 			{// MERGE_FPS2 [[[#ifdef FRAMES_PER_SECOND#if MACINTOSH			StartTimingMilli();		// for this frame only#endif //MACINTOSH#endif //FRAMES_PER_SECOND			frame = i;			(*step)->GetStep(&pt,&agl);			SetPosition(pt,agl);			controller->Request(NULL,msgUpdate,objObserver,0);#if (WINDOWS && (!VR))			// this is only used if the record/play/stop buttons are on a console,			// which can cause some window mouse up/mouse down funkiness.  Ignore			// in VR, or if the buttons are not on a button tool thing. Billg softkey march			/*  look for a button up event, and (if found)			discard it.  It's the mouse up from pushing the			play button.  JCA 29 April 93*/			if(!btnUp && VEventWaiting(mDownMask))				{	// are there any messages?                MSG	msg;				if ((PeekMessage(&msg, NULL, WM_LBUTTONUP, WM_LBUTTONUP, PM_REMOVE|PM_NOYIELD) ||					PeekMessage(&msg, NULL, WM_MBUTTONUP, WM_MBUTTONUP, PM_REMOVE|PM_NOYIELD)) ||					PeekMessage(&msg, NULL, WM_RBUTTONUP, WM_RBUTTONUP, PM_REMOVE|PM_NOYIELD))					btnUp = TRUE;				}#endif  // (WINDOWS && (!VR))			if(VEventWaiting(mDownMask|keyDownMask|diskMask))				{#if WINDOWS				/* this is to prevent the key up from using the key equivalent from				stopping the path playing.  This happens under VR, Player, and possibly				Pro (though I haven't checked.  Someone should, if they get the chance)				jca 23MAR95 */				MSG	msg;				if (PeekMessage(&msg, NULL, WM_KEYUP, WM_KEYUP, PM_REMOVE|PM_NOYIELD))					{					}				else					{					btnDown = TRUE;					break;					}#else // !(windows)				btnDown = TRUE; // MERGE-FPS2 [[[ #ifdef FRAMES_PER_SECOND #if MACINTOSH				EndTimingMilli();		// to make sure timer is released, ignore result #endif //MACINTOSH #endif //FRAMES_PER_SECOND // MERGE-FPS2 ]]]				break;#endif // WINDOWS && VR				}			}			if(i>=length)			{			long t;			// MERGE-FPS2			double secs;	// MERGE-FPS2			char str[256];	// MERGE-FPS2			frame = 0;// MERGE-FPS2 [[[#ifdef FRAMES_PER_SECOND#if MACINTOSH			t = EndTimingMilli();			if (t != 0)				{				secs = (double)t / 1000.0;				sprintf(str,"%4.2f total, %4.2f fps", secs, (double)length/secs);				ShowInfo2(str);				}#endif //MACINTOSH#endif //FRAMES_PER_SECOND            }		}			path->Unuse();	}			voidObserver::SetFFPoint(Point3DFFixed pnt)	{	Point3D	tmpPt;			tmpPt.x = FFRound(pnt.x);	tmpPt.y = FFRound(pnt.y);	tmpPt.z = FFRound(pnt.z);		SetPoint(tmpPt);	}	voidObserver::SetFFAngle(Angle3DFFixed angl)	{	Angle3D	tmpAngle;			tmpAngle.roll = FFRound(angl.roll);	tmpAngle.pitch = FFRound(angl.pitch);	tmpAngle.yaw = FFRound(angl.yaw);	SetAngle(tmpAngle);	}voidObserver::SetPoint(Point3D pnt)	{	lastPoint = FFpoint;	FFpoint.x.frac = FFpoint.y.frac = FFpoint.z.frac = 0;	FFpoint.x.intg = pnt.x;	FFpoint.y.intg = pnt.y;	FFpoint.z.intg = pnt.z;	View::SetPoint(pnt);	}	voidObserver::SetAngle(Angle3D angl)	{	lastAngle = FFangle;	FFangle.roll.frac = FFangle.pitch.frac = FFangle.yaw.frac = 0;	FFangle.roll.intg = angl.roll;	FFangle.pitch.intg = angl.pitch;	FFangle.yaw.intg = angl.yaw;	View::SetAngle(angl);	}voidObserver::ResetTilt()	{	lastAngle = FFangle;	lastPoint = FFpoint;	View::ResetTilt();	FFangle.roll.frac = FFangle.pitch.frac = FFangle.yaw.frac = 0;		FFangle.roll.intg = angle.roll;	FFangle.pitch.intg = angle.pitch;	FFangle.yaw.intg = angle.yaw;		}	voidObserver::Move(int velocity, int latVelocity, int vertVelocity,	int yawVelocity, int pitchVelocity, int rollVelocity)	{	lastPoint = FFpoint;	lastAngle = FFangle;		View::Move(velocity,latVelocity,vertVelocity,yawVelocity,pitchVelocity,rollVelocity);		FFpoint.x.frac = FFpoint.y.frac = FFpoint.z.frac = 0;	FFangle.roll.frac = FFangle.pitch.frac = FFangle.yaw.frac = 0;			FFpoint.x.intg = point.x;	FFpoint.y.intg = point.y;	FFpoint.z.intg = point.z;	FFangle.roll.intg = angle.roll;	FFangle.pitch.intg = angle.pitch;	FFangle.yaw.intg = angle.yaw;		if(TRUE == record) 		RecordPosition();	}	// MERGE18 [[[voidObserver::MoveCollision(int velocity, int latVelocity, int vertVelocity,	int yawVelocity, int pitchVelocity, int rollVelocity)	{	lastPoint = FFpoint;	lastAngle = FFangle;		View::MoveCollision(velocity,latVelocity,vertVelocity,yawVelocity,pitchVelocity,rollVelocity);		FFpoint.x.frac = FFpoint.y.frac = FFpoint.z.frac = 0;	FFangle.roll.frac = FFangle.pitch.frac = FFangle.yaw.frac = 0;			FFpoint.x.intg = point.x;	FFpoint.y.intg = point.y;	FFpoint.z.intg = point.z;	FFangle.roll.intg = angle.roll;	FFangle.pitch.intg = angle.pitch;	FFangle.yaw.intg = angle.yaw;		if(TRUE == record) 		RecordPosition();	}// MERGE18 ]]]void Observer::CopyPath(V_Array *toPath,int fromFrame,int toFrame) 	{ 	ObserverStep	**fromStep,**toStep;	long	i,length,frame,numFrames;	int delta;		length = path->ALength();	if(toFrame>length) toFrame = length-1;	if(toFrame<0)toFrame = 0;	if(fromFrame>length) fromFrame = length-1;	if(fromFrame<0) fromFrame = 0;		if(fromFrame>toFrame) 		{		numFrames = fromFrame - toFrame + 1;		delta = -1; 		}	else 		{		numFrames = toFrame - fromFrame + 1;		delta = 1;		}			toPath->SetLength(numFrames);	fromStep = (ObserverStep **)path->Use();	toStep = (ObserverStep **)toPath->Use();	for(i = 0,frame = fromFrame; i < numFrames; i++,toStep++,frame+=delta)		{		*toStep = new(ObserverStep);		(*toStep)->cPathStep();		(*toStep)->Copy(fromStep[frame]);		}	toPath->Unuse();	path->Unuse();	}/* DWEE *//* Local version # for this chunk only */#define VPRF_VERS		1int Observer::IO(V_Buffer *buf)	{	ObserverStep	**step;	Point3DFFixed pt;	Angle3DFFixed agl;	short vers;	short	i,length;	FFixed pi, halfPeriod, tmp;	ObjLock((ObjectHandle)this);	pi = DblToFixed(PI);	halfPeriod.intg = 128; halfPeriod.frac = 0;	if (buf->IODirection() == DATA_IN)		{		buf->IOType(&vers, IO_SHORT);		if (vers <= VPRF_VERS)			{			IOType(buf, &FFpoint, IO_POINT3D_FFIXED);			IOType(buf, &agl, IO_ANGLE3D_FFIXED);			buf->IOType(&focalLength, IO_SHORT);			buf->IOType(&filmWidth, IO_SHORT);							FFangle.roll = FFDiv(FFMult(agl.roll, halfPeriod), pi);			FFangle.pitch = FFDiv(FFMult(agl.pitch, halfPeriod), pi);			FFangle.yaw = FFDiv(FFMult(agl.yaw, halfPeriod), pi);						SetFFPoint(FFpoint);			SetFFAngle(FFangle);			/*			walkPath->IO(buf);*/			{			buf->IOType(&length, IO_SHORT);			path->SetLength(length);			step = (ObserverStep **)path->Use();				for (i = 0; i < length; i++,step++)				{				*step = new(ObserverStep);				(*step)->IO(buf);				}						path->Unuse();			}			}		}	else		{		vers = VPRF_VERS;		agl.roll = FFDiv(FFMult(FFangle.roll, pi), halfPeriod);		agl.pitch = FFDiv(FFMult(FFangle.pitch, pi), halfPeriod);		agl.yaw = FFDiv(FFMult(FFangle.yaw, pi), halfPeriod);		buf->IOType(&vers, IO_SHORT);		IOType(buf, &FFpoint, IO_POINT3D_FFIXED);		IOType(buf, &agl, IO_ANGLE3D_FFIXED);		buf->IOType(&focalLength, IO_SHORT);		buf->IOType(&filmWidth, IO_SHORT);		/*		walkPath->IO(buf);*/		{		length = path->ALength();		step = (ObserverStep **)path->Use();		buf->IOType(&length, IO_SHORT);		for (i = 0; i < length; i++,step++)			(*step)->IO(buf);		path->Unuse();		}		}		ObjUnlock((ObjectHandle)this);    return(noErr);	}void ObserverStep::cPathStep() { point = Pt3DFFZero; angle = Ang3DFFZero; }	void ObserverStep::dPathStep() { delete(this); }void ObserverStep::SetStep(Point3DFFixed p,Angle3DFFixed a) { point = p; angle = a; }void ObserverStep::GetStep(Point3DFFixed *p,Angle3DFFixed *a) { *p = point; *a = angle; }void ObserverStep::Copy(ObserverStep *fromStep) { fromStep->GetStep(&point,&angle); }/* DWEE */intObserverStep::IO(V_Buffer *buf)	{	Point3DFFixed pt;	Angle3DFFixed agl;	FFixed pi, halfPeriod, tmp;	pi = DblToFixed(PI);	halfPeriod.intg = 128; halfPeriod.frac = 0;	ObjLock((ObjectHandle)this);	if (buf->IODirection() == DATA_OUT)		{				pt = point;		agl = angle;				agl.roll = FFDiv(FFMult(agl.roll, pi), halfPeriod);		agl.pitch = FFDiv(FFMult(agl.pitch, pi), halfPeriod);		agl.yaw = FFDiv(FFMult(agl.yaw, pi), halfPeriod);		IOType(buf, &pt, IO_POINT3D_FFIXED);		IOType(buf, &agl, IO_ANGLE3D_FFIXED);		}	else		{		IOType(buf, &pt, IO_POINT3D_FFIXED);		IOType(buf, &agl, IO_ANGLE3D_FFIXED);		point = pt;		angle.roll = FFDiv(FFMult(agl.roll, halfPeriod), pi);		angle.pitch = FFDiv(FFMult(agl.pitch, halfPeriod), pi);		angle.yaw = FFDiv(FFMult(agl.yaw, halfPeriod), pi);		}		ObjUnlock((ObjectHandle)this);	return(noErr);	}