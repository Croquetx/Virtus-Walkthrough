/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VPane.h"#include "DesCntrl.h"#include "CVObserv.h"#include "CVEnvirn.h"#include "CVWCntrl.h"#include "DesEBtn.h"#include "ClrPane.h"#include "DesDraft.h"#include "CVRuler.h"#include "RuleItem.h"	#include "CadPosn.h"#include "CVLayer.h"#include "CVLItem.h"#include "CadBtn.h"#include "CVDefs.h"#include "CVPolyh.h"#include "CVSrfFet.h"#include "AppMssgs.h"#include "AppDeflt.h"#include "AppText.h"#include "ToolDef.h"#include "WalkDefs.h"#include "Informtn.h"#include "VMath.h"#include "VWindow.h"#include "VGraphic.h"  #include "TEXSEL.h"#if ((VR) || (VPRO))		// MERGE-GOURAUD-PRO#include "Clip.h"	// DAS-VR-SurfEdit	9/6/93#endif#if VPRO#include "TEXTLIST.h"	// ABD TEXTURE#include "TextPalt.h"#endif // VPRO#if VR#include "VRTools.h"#include "VRTex.h"#endif#include <stdio.h>#include <string.h>#define SameColor(c1,c2) (((c1.red == c2.red)&&(c1.green == c2.green)&&(c1.blue == c2.blue))?1:0)#define POLY_LWIDTH		345#define POLY_LHEIGHT	230#define POLY_SWIDTH		125#define POLY_SHEIGHT	132#define XY_RULER	0x01#define Z_RULER		0x02#define RANGE_RULER	0x04#define ORG_RULER	0x08#define GID_RULER	0x10#define XYZ_RULER	XY_RULER|Z_RULERvoid DesignControl::cController(V_Document *doc)	{		Rect	r;		CADid = information->environment->uniqueID;			CadControl::cController(doc);			tools = (PolyToolButton*)controller->cTool(this,toolBPolyTools);		/* create the polyhedron tool box buttons */		modifiers = (PolyModButton*)controller->cTool(this,toolBPolyModifiers);/* create the polyhedron modifier buttons */	gouraud_modifiers = (GouraudModButton*)controller->cTool(this,toolBPolyGouraudModifiers);/* MERGE-GOURAUD */	selectTools = (SelectToolButton*)controller->cTool(this,toolBSelect);	/* create the regular polyhedron buttons  */		regularPoly = (RegPolyButton*)controller->cTool(this,toolBRegular);	/* create the regular polyhedron buttons  */		toolSet = (PosnToolButton*)controller->cTool(this,toolBToolSet);		/* create the regular polyhedron buttons  */		walkList = (WalkList*)controller->cTool(this,toolLList);			/* create the layer List				  */	zRuler = (CAVZRuler*)controller->cTool(this,toolPDepth);		/* create the extrusion pane  	*/	controller->cTool(this,toolPDrag);						/* create the drag pane			*/	hRuler->AddRange();	vRuler->AddRange();	zRuler->SetEnvironment(environment);	SetRuler(RANGE_RULER|XYZ_RULER);	cacheFlag = 0;	}void DesignControl::dController()	{		#if VR	// jca 21APR94 this is done in CadControl::dController(), but	// we aren't calling that (for whatever reason).  So we should	// delete it here.  IF WE EVER DO CALL CadControl::dController()	// HERE< REMOVE THIS LINE!	vrTexture->dPane();#endif // VR	Controller::dController();	}void *DesignControl::cTool(Controller *ctrl,int toolType)	{	DragPane	*dragPane;	void *tool = NULL;		switch(toolType)		{		case toolBPolyTools:/* create polyhedron tools */			tools = new(PolyToolButton);			tools->cButtonSet();			tool = tools;			break;		case toolBPolyModifiers:/* create modifier buttons */			modifiers = new(PolyModButton);			modifiers->cButtonSet();			tool = modifiers;			break;		// MERGE-GOURAUD [[[		case toolBPolyGouraudModifiers:/* create modifier buttons */			gouraud_modifiers = new(GouraudModButton);			gouraud_modifiers->cButtonSet();			tool = gouraud_modifiers;			break;		// MERGE-GOURAUD ]]]				case toolBToolSet:			toolSet = new(PosnToolButton);			toolSet->cButtonSet();			tool = toolSet;			break;		case toolPDepth:			zRuler = new(CAVZRuler);			zRuler->cPane(VERTSCROLLBAR);			zRuler->SetAxis(INFL_Z);			zRuler->SetDirection(VERT_RULER);			zRuler->SetState(SHOW_RANGE|SHOW_TAB|SHOW_RULER,TAB_STATE);			zRuler->AddRange();			tool = zRuler;			break;					case toolPDrag:			dragPane = new(DragPane);			dragPane->cPane(FALSE);			tool = dragPane;			break;		default:			tool = CadControl::cTool(ctrl,toolType);			break;		}		return(tool);	}voidDesignControl::Activate(int install)	{	CAVPolyhedron	*poly;	V_Window 	*window;	char 		str[256];		if((msgDeactivate != install) && (msgDummy2 != install))		{		toolConsole->SetButton(tools);		tools->SetHeir(ALTSELECTOR_SPOT,selectTools);		tools->SetHeir(REGULAR_SPOT,regularPoly);		tools->SetHeir(TOOL_SPOT,toolSet);		modifiers->SetController(this);		modifierConsole->SetButton(modifiers);					// MERGE-GOURAUD [[[		gouraud_modifiers->SetController(this);		gouraud_modifierConsole->SetButton(gouraud_modifiers);			gouraud_modifiers->SetButtonWidth(38);		// MERGE-GOURAUD ]]]				SetDepthControl();		// jca 13APR94 [[		if (environment && (!tumbleAxis))			{			// if there is an environment (from which we can get the information)			// and there is no tumbleAxis (the little tumble cube thing in the toolbar			// for the walk, tumble, and surf views).  The tumbleAxis, when defined,			//  gets updated when we draw the tool bars, and as a side effect it sets			// the SelectPatternOrigin.  There is no tumbleAxis defined for the			// design tool bar, so we need to reset the SelectPatternOrigin manually			// (otherwise the select pattern can be set for the wrong pane.  Like this:			// Select something in the design view, then activate the walk view. Now			// reactivate the design view, and click outside the selected object (which			// deselects it).  Note the two dot patterns.  The deselect draws the pattern			// according to the origin for the tumbleAxis/spacepane for the walk view's			// tool bar)			Point		oPoint;			PointLong	lOPoint;			lOPoint = environment->GetDrawOrigin();			oPoint.h = lOPoint.h;			oPoint.v = lOPoint.v;			VSelectPatternOrigin(oPoint);			}		// jca 13APR94 ]]			}	CadControl::Activate(install);		switch(install)		{		case msgCreate:			window = GetWindow(objDepth);			if(!window->panes || !window->panes->ALength())					{#if MACINTOSH				DragPane 	*dragPane;				dragPane = (DragPane *)controller->cTool(this,toolPDrag);				window->Install(zRuler);				window->Install(dragPane);#elif WINDOWS				window->Install(zRuler);#endif				}							strcpy(str,title);			SetTitle(str);			break;				case msgDummy2:		case msgReset:			zRuler->Reset();			break;					case msgInit:			editTool = FALSE;			ControlMessage(tools->GetTool(0),0L,ONSTATE);			break;				case msgDeactivate:			zRuler->Reset();			break;		}		Request(NULL,msgReset,objDepth,0);	}			void DesignControl::GetPlace(Rect *r,int warning,int who)	{		  	switch(who)		{		case objDepth: cadDraft->theWindow->Locate(r); break;				default: CadControl::GetPlace(r,warning,who); break;		}	}void DesignControl::UpdateCache(int flag)	{	AppPreference *appPref;	DefaultPreference	*defPref;			appPref = GetPreference();	defPref = (DefaultPreference*)appPref->GetPreference(preferDefaults);	localFloor = defPref->extrusionMin;	localCeil = defPref->extrusionMax;	cacheFlag |= flag;	}	void DesignControl::GetVirtualDepth(Rect *r)	{	Point3DFFixed	defNear,defFar;	FFixed	bMin,bMax;		if(!(cacheFlag&CACHE_DEPTH))UpdateCache(CACHE_DEPTH);		r->left = 0;	r->right = 0;	defNear = environment->Translate3DFFixed(TO_CAD,localFloor);	defFar = environment->Translate3DFFixed(TO_CAD,localCeil);	FFMax(bMax,defNear.z,defFar.z);	FFMin(bMin,defNear.z,defFar.z);	r->top = FFRound(bMax);	r->bottom = FFRound(bMin); 	}void DesignControl::GetInflation(char *inflation,int *direction)	{	switch(modifiers->GetTool(3))		{		case bEXTRUSION: 	*inflation = INFL_EXTRUDE;  *direction = POLY_BOTH; break;			case bCONVERGE_UP: 	*inflation = INFL_CONVERGE; *direction = POLY_UP; break;		case bCONVERGE_DOWN:*inflation = INFL_CONVERGE; *direction = POLY_DOWN; break; 			case bCONVERGE_DUAL:*inflation = INFL_CONVERGE; *direction = POLY_BOTH; break; 			case bELLIPSE_UP: 	*inflation = INFL_ELLIPSE;  *direction = POLY_UP; break;		case bELLIPSE_DOWN: *inflation = INFL_ELLIPSE;  *direction = POLY_DOWN; break; 			case bELLIPSE_DUAL: *inflation = INFL_ELLIPSE;  *direction = POLY_BOTH; break; 			default:			*inflation = INFL_EXTRUDE;  *direction = POLY_BOTH;break;			}	}void DesignControl::ControlMessage(int message,long modifiers,int state)	{	int	oldTool;		oldTool = editTool;		switch(message)		{		case bCONNECTOR: 			case MOVE_EYE: 		case ROTATE_EYE: 		case SET_HEIGHT:  	editTool = message; break;		case bEXTRUSION:    if(LOCKSTATE == state) ppd(cadDraft)->SetInflate(INFL_EXTRUDE,INFL_BOTH); break;		case bCONVERGE_UP:  if(LOCKSTATE == state) ppd(cadDraft)->SetInflate(INFL_CONVERGE,INFL_UP);break;		case bCONVERGE_DOWN:if(LOCKSTATE == state) ppd(cadDraft)->SetInflate(INFL_CONVERGE,INFL_DOWN); break;		case bCONVERGE_DUAL:if(LOCKSTATE == state) ppd(cadDraft)->SetInflate(INFL_CONVERGE,INFL_BOTH); break;		case bELLIPSE_UP:   if(LOCKSTATE == state) ppd(cadDraft)->SetInflate(INFL_ELLIPSE,INFL_UP); break;		case bELLIPSE_DOWN: if(LOCKSTATE == state) ppd(cadDraft)->SetInflate(INFL_ELLIPSE,INFL_DOWN); break;		case bELLIPSE_DUAL: if(LOCKSTATE == state) ppd(cadDraft)->SetInflate(INFL_ELLIPSE,INFL_BOTH); break;		default: CadControl::ControlMessage(message,modifiers,state); break;		}	switch(oldTool)		{		case bSCALE_ROOM:		case bPOLY_ROOM: cadDraft->ResetTools(); break;		default: 			if(bZOOM_USER != message && TRUE == zoomState) 				ZoomUser(FALSE); 			break;		}	}	voidDesignControl::NewPolyhedron(int what,int direction,CAVPolyhedron *npoly)	{	switch(direction)		{		case objDraft:			pwc(controller)->NewPolyhedron(what,npoly);			break;		case objWalk: 			ppd(cadDraft)->NewPolyhedron(npoly);			break;		}		}voidDesignControl::NewSurfFeature(V_Array	*featList)	{	ppd(cadDraft)->NewSurfFeature(featList);	}	voidDesignControl::SetExtrudeHeight(short defAxis)	{	ppd(cadDraft)->SetExtrudeHeight(defAxis);	}charDesignControl::GetDefAxis()	{	return(ppd(cadDraft)->GetDefAxis());	}				voidDesignControl::Select(CAVPolyhedron *poly,V_Array *list)	{	pwc(controller)->Select(poly,list);	}voidDesignControl::SetLastPoly(CAVPolyhedron *poly)	{	pwc(controller)->SetLastPoly(poly);	}voidDesignControl::SelectPolyhedron(CAVPolyhedron *poly,V_Array *list)	{	ppd(cadDraft)->SelectPolyhedron(poly,list);	}CAVPolyhedron *DesignControl::GetLastPoly()	{	return(pwc(controller)->GetLastPoly());	}voidDesignControl::Request(void *val,int action,int who,int scope)	{	V_Buffer	*buffer;	LayerItem 	*clayr;		switch(action)		{		case objTools:CadControl::Request(val,action,who,scope); break;		case msgInit: break;				case msgCreate:			switch(who)				{					case objList: if(!walkList->AddItem()) break;				case objPolyhedron: 				default:					controller->Request(this,action,who,scope); 					break;				}			break;	//JAM TXTRFIDDLE 06/14/94 [[[		#if VPRO		case msgForceRedraw:			switch(who)				{				//JAM--perhaps we should add a case objTextureBackPane				//and require both to be requested seperately				case objTextureList:					GetTextureList()->VForceRedraw(DRAW);					GetTextureBackPane()->VForceRedraw(DRAW);					break;					}							break;#endif//JAM TXTRFIDDLE 06/14/94 ]]]					case msgUpdate:			switch(who)				{				case objTools: 					cadDraft->VDisplay(DRAW); 					zRuler->VDisplay(DRAW); 					// MERGE-GOURAUD-PRO ZoomUser(FALSE);					break;				case objList: walkList->VDisplay(ACT_REBUILD_DRAW); break;								case objPosition: controller->Request(NULL,msgUpdate,objHeight,0); break;				case objColor: cadDraft->SetColor(color->GetColor()); break;					case objTexture: cadDraft->SetTexture(GetTexture()); break; /* ABD WILLIAMS MERGE-TEXTURE 9/13/93 */	//				case objTextureList: /*¥¥¥¥¥¥*/ break; /* ABD WILLIAMS MERGE-TEXTURE 9/13/93 */	#if VPRO				//JAM perhaps we should add a case for objTextureBackpane                //and require each to be requested separtely				case objTextureList:					GetTextureList()->VDisplay(DRAW); /* ABD TEXTURE */						GetTextureBackPane()->VDisplay(DRAW);	//JAM 8/9/94                    break;#else				case objTextureList: /*„„„„„„*/ break; /* ABD WILLIAMS MERGE-TEXTURE 9/13/93 */	#endif				case objHeight:cacheFlag=0 ;				default: controller->Request(this,action,who,scope); break;				}							break;												case msgEdit:			switch(who)				{				case objList: 					walkList->VInvalidate(); 	// ABD JaN95					controller->Request(this,action,who,scope);					break;// ABD WILLIAMS MERGE-TEXTURE 9/13/93 [[[				case objTextureList: 				#if VPRO					GetTextureList()->VDisplay(DRAW);					GetTextureBackPane()->VDisplay(DRAW);	//JAM 8/9/94					controller->Request(this,action,who,scope);					break; /* ABD TEXTURE */					#else					// „„„„„					// GetTextureList()->VDisplay(DRAW);					// controller->Request(this,action,who,scope);				#endif					break; /* ABD TEXTURE */									case objTexture: 			/* ABD TEXTURE */					cadDraft->SetTexture(GetTexture()); 					break;// ABD WILLIAMS MERGE-TEXTURE 9/13/93 ]]]									case objColor: #if VWT					color->VDisplay(DRAW);					cadDraft->SetColor(color->GetColor()); #elif VR					vrColor->VDisplay(DRAW);					cadDraft->SetColor(vrColor->GetColor()); #endif					break;								case objOrigin:					SetPositionOrigin();					controller->Request(NULL,action,who,0);					break;									case objHeight:					cacheFlag=0 ;					controller->Request(NULL,action,who,0);					zRuler->VDisplay(DRAW);					break;									case objCad: 					controller->Request(NULL,msgUpdate,objPolyhedron,0);					break;									default: controller->Request(this,action,who,scope); break;				}			break;				case msgDestroy:			switch(who)				{				case objHorzRuler: 				case objVertRuler: 					break;									case objDepth: 					zRuler = NULL; 					break;										case objList: 					if(!EditLayer(GetLayer(),msgDestroy,objList))						break;					who = objPolyhedron;									default: controller->Request(this,action,who,scope); break;				}						break;				case msgReset:			switch(who)				{				case objTools: 					SetTool(0L,_TOGGLE); 					break;				case objHeight:				case objDepth:					cacheFlag=0 ;					break;																			default: controller->Request(this,action,who,scope); break;				}			break;				}	}voidDesignControl::Response(void *val,int action,int who,int scope)	{			AppPreference *appPref;	DefaultPreference	*defPref;	switch(action)		{		case msgInit:			switch(who)				{					case objObserver:						ppd(cadDraft)->MoveObserver();					break;									case objPolyhedron:					cadDraft->Reset();					break;									case objIO: 					color->SetController(this);					color->VDisplay(DRAW);					cadDraft->SetController(this);									case objDefaults: 					appPref = GetPreference();					defPref = (DefaultPreference*)appPref->GetPreference(preferDefaults);					if(guideLines!=defPref->guideLines)						{						guideLines->dArray();						guideLines = defPref->guideLines;						}					SetGuideLines();						walkList->SetList(information->list);					SetScale(GetScale(),TRUE);					Request(NULL,msgUpdate,objTools,0);					break;				}			break;					case msgCreate:			switch(who)				{					case objPolygon:				case objPolyhedron:					if(val != this) cadDraft->VDisplay(ACT_REBUILD_DRAW);					break;				case objList: break;				}			break;				case msgEdit:			switch(who)				{#if ((VR) || (VPRO)) // jca 17JAN94	// MERGE-GOURAUD-PRO	 			case objEditSurface: // DAS-VR 9/6/93					{					CAVPolyhedron *poly=(CAVPolyhedron *)((struct ObjSpec *)val)->poly;					pcc(ppd(cadDraft)->controller)->						LaunchEditor(poly,							environment->GetScale(),							poly->GetSurfDef(((struct ObjSpec*)val)->surfNum),							Pt3DFFZero,							toolCRTLSurface);					}					break;				case objCenterPoly: // DAS-VR 8/29/93					((CAVWalkController*)controller)->RestoreDesign(NULL);// DAS-VR 9/7/93					if (val)					{						if (!(((CAVPolyhedron*)val)->editState & EDIT_LOCKED))						{							ppd(cadDraft)->NewSelect((CAVPolyhedron*)val,scope);						}                    }                  					if(val)ppd(cadDraft)->CenterPoly((struct CAVPolyhedron*)val);					break;#endif // ((VR) || (VPRO))				case objObserver:	ppd(cadDraft)->MoveObserver(); break;#if VPRO				case objPosition:pwc(controller)->position->VDisplay(ACT_REBUILD_DRAW);break;	// MERGE-GOURAUD-PRO#else				case objPosition:position->VDisplay(ACT_REBUILD_DRAW);break;	// MERGE-GOURAUD-PRO#endif				case objColor:color->VDisplay(ACT_REBUILD_DRAW);break;#if VR // jca 17JAN94				case objTexture:vrTextureSelect->VDisplay(ACT_REBUILD_DRAW);break;			// MERGE14	#endif // VR				case objCad:				case objPolyhedron:				case objPolygon:					cadDraft->VDisplay(ACT_REBUILD_DRAW);					break;									case objHorzRuler: 				case objVertRuler: 					SetRuler(XY_RULER|GID_RULER);					hRuler->VDisplay(-DRAW);					vRuler->VDisplay(-DRAW);					cadDraft->VDisplay(DRAW);					break;				case objOrigin: 					SetRuler(XYZ_RULER|ORG_RULER);					hRuler->VDisplay(-DRAW);					vRuler->VDisplay(-DRAW);					zRuler->VDisplay(DRAW);					cadDraft->VDisplay(DRAW);					break;									case objHeight: 					cacheFlag=0 ;					SetRuler(XYZ_RULER|RANGE_RULER);					hRuler->VDisplay(-DRAW);					vRuler->VDisplay(-DRAW);					zRuler->VDisplay(-DRAW);					break;								case objPreference:					SetPreference(controller->GetPreference(),FALSE); break;				}			break;//JAM TXTRFIDDLE 06/14/94 [[[#if VPRO		case msgForceRedraw:			switch(who)				{				case objTextureList:					GetTextureList()->VForceRedraw(DRAW);					GetTextureBackPane()->VForceRedraw(DRAW);					break;				}			break;#endif//JAM TXTRFIDDLE 06/14/94 ]]]				case msgUpdate:			switch(who)				{				case objList:cadDraft->VDisplay(DRAW);break;#if VPRO				case objPosition:pwc(controller)->position->VDisplay(ACT_REBUILD_DRAW);break;		// MERGE-GOURAUD-PRO#else				case objPosition:position->VDisplay(ACT_REBUILD_DRAW);break;		// MERGE-GOURAUD-PRO#endif				case objCad:				case objPolyhedron:cadDraft->VDisplay(ACT_REBUILD_DRAW);break;				case objColor:	color->VDisplay(DRAW);break;					case objObserver:	ppd(cadDraft)->MoveObserver();break;				case objHeight:	cacheFlag=0 ;break;#if VPRO	//JAM added				case objTextureList:					GetTextureList()->VDisplay(DRAW); /* ABD TEXTURE */					GetTextureBackPane()->VDisplay(DRAW);	//JAM 8/9/94                    break;#else				case objTextureList: /*„„„„„„*/ break; /* ABD WILLIAMS MERGE-TEXTURE 9/13/93 */	#endif				}			break;				case msgDestroy:			switch(who)				{				case objList: 					cadDraft->Reset(); 					break;									case objPolyhedron:				case objPolygon:					cadDraft->VDisplay(ACT_REBUILD_DRAW);break;				}						break;				case msgReset:			switch(who)				{				case objObserver:						ppd(cadDraft)->MoveObserver();					break;									case objList:					walkList->Reset();					break;								case objHeight: cacheFlag=0 ;break;				case objSlice:				case objPolyhedron: cadDraft->Reset(); break;				case objTools:  editTool = bARROW; SetTool(0L,_NO_TOGGLE); break;				case objDepth:  ppd(cadDraft)->menu->SetController(this); break;/* dude */								case objVirtRect: 					hRuler->RulerTrack(0,FALSE);					vRuler->RulerTrack(0,FALSE);					cadDraft->Reset(); 					break; /* dude hack for paste to update the virt rect */				}			break;					default:			break;		}	}int DesignControl::CheckPolyhedron(void *obj) { return(TRUE); }CadDraft *DesignControl::NewDraft()  {  return( new(DesignDraft));  	}PointFFixedDesignControl::GetWorldOffset(Point p)	{	PointFFixed result;	result = cadDraft->Local2World(p,SCALE_RELATIVE);	return(result);	}voidDesignControl::SetScale( double newScale , int fixFlag)	{	RulerScaleInfo	scaleInfo;	CadControl::SetScale(newScale,fixFlag);	hRuler->FFGetScale(&scaleInfo);	zRuler->FFSetScale(&scaleInfo);		}void DesignControl::ChangeView(int view)	{	CAVPolyhedron	*lastPoly;	Point3DFFixed	bMin,bMax,origin;	PointFFixed		pt1,pt2;	FFixed			depth1,depth2;		if(view == environment->GetView()) return;	// { DAS-VR/VWT/PRO-FIX 9/9/93//	if(!cadDraft->selectedList->ALength())//		zRuler->GetTabs(&depth1,&depth2);//	else		{		cadDraft->selectedList->CopyArray(cadDraft->editList);		pt1=cadDraft->ObjectCenter(&depth1);		cadDraft->editList->SetLength(0);		depth2 = depth1;		}			origin.x = pt1.h; // cadDraft->ffLastPt.h;	origin.y = pt1.v; // cadDraft->ffLastPt.v;	origin.z =  depth1; // FFAdd(depth1,FFShift(FFSub(depth2,depth1),-1));// } DAS-VR/VWT/PRO-FIX 9/9/93	origin = environment->Translate3DFFixed(TO_WORLD,origin);	environment->SetView(view);	polyhedron->SetDirty(POLY_DIRTY);	origin = environment->Translate3DFFixed(TO_CAD,origin);	cadDraft->ffLastPt.h = origin.x;	cadDraft->ffLastPt.v = origin.y;	GetDepth(&depth1,&depth2,environment->GetAxis());	zRuler->SetAxis(environment->GetAxis());	depth1 = FFAdd(FFShift(FFSub(depth1,depth2),-1),depth2);	zRuler->Center(depth1);		CadControl::ChangeView(view);		}	void DesignControl::SetTitle(char *newTitle)	{	char str[256];		switch(environment->GetView())			{#if SPANISH  // jca 27FEB95 spanish has a "noun adjective" structure		case topView: 		sprintf(str,"%s %s",TXTT_VIEW,TXTM_VTOP); 	 break;		case bottomView: 	sprintf(str,"%s %s",TXTT_VIEW,TXTM_VBOTTOM);break;		case frontView: 	sprintf(str,"%s %s",TXTT_VIEW,TXTM_VFRONT); break;		case backView:		sprintf(str,"%s %s",TXTT_VIEW,TXTM_VBACK);  break;		case leftView: 		sprintf(str,"%s %s",TXTT_VIEW,TXTM_VLEFT);  break;		case rightView: 	sprintf(str,"%s %s",TXTT_VIEW,TXTM_VRIGHT); break;#else   // english		case topView: 		sprintf(str,"%s %s",TXTM_VTOP,TXTT_VIEW); 	 break;		case bottomView: 	sprintf(str,"%s %s",TXTM_VBOTTOM,TXTT_VIEW);break;		case frontView: 	sprintf(str,"%s %s",TXTM_VFRONT,TXTT_VIEW); break;		case backView:		sprintf(str,"%s %s",TXTM_VBACK,TXTT_VIEW);  break;		case leftView: 	sprintf(str,"%s %s",TXTM_VLEFT,TXTT_VIEW);  break;		case rightView: 	sprintf(str,"%s %s",TXTM_VRIGHT,TXTT_VIEW); break;#endif // SPANISH		}		CadControl::SetTitle(str);	}void DesignControl::SetRuler(int doDepth)	{	AppPreference *appPref;	DefaultPreference	*defPref;	Point3DFFixed	org,point,base,test;		if(RANGE_RULER&doDepth)		{		GetDepth( &point.z,&base.z, INFL_Z);		GetDepth( &point.x,&base.x, INFL_X);		GetDepth( &point.y,&base.y, INFL_Y);	/*		point = environment->Translate3DFFixed(TO_CAD,point);		base = environment->Translate3DFFixed(TO_CAD,base);*/		if( Z_RULER & doDepth ) 			{			switch(zRuler->defAxis)				{				case INFL_X:zRuler->SetTabs(point.x,base.x);break;				case INFL_Y:zRuler->SetTabs(point.y,base.y);break;				case INFL_Z:zRuler->SetTabs(point.z,base.z);break;				}			}								if( XY_RULER & doDepth )			{			switch(hRuler->defAxis)				{				case INFL_X:hRuler->SetTabs(point.x,base.x);break;				case INFL_Y:hRuler->SetTabs(point.y,base.y);break;				case INFL_Z:hRuler->SetTabs(point.z,base.z);break;				}			switch(vRuler->defAxis)				{				case INFL_X:vRuler->SetTabs(point.x,base.x);break;				case INFL_Y:vRuler->SetTabs(point.y,base.y);break;				case INFL_Z:vRuler->SetTabs(point.z,base.z);break;				}			}		}	if(ORG_RULER&doDepth)		{		appPref = GetPreference();		defPref = (DefaultPreference*)appPref->GetPreference(preferDefaults);		org = defPref->localOrigin;		if( XY_RULER & doDepth )			{						switch(hRuler->defAxis)				{				case INFL_X:hRuler->SetOriginOffset(org.x);break;				case INFL_Y:hRuler->SetOriginOffset(org.y);break;				case INFL_Z:hRuler->SetOriginOffset(org.z);break;				}			switch(vRuler->defAxis)				{				case INFL_X:vRuler->SetOriginOffset(org.x);break;				case INFL_Y:vRuler->SetOriginOffset(org.y);break;				case INFL_Z:vRuler->SetOriginOffset(org.z);break;				}			}									if( Z_RULER & doDepth ) 			{			switch(zRuler->defAxis)				{				case INFL_X:zRuler->SetOriginOffset(org.x);break;				case INFL_Y:zRuler->SetOriginOffset(org.y);break;				case INFL_Z:zRuler->SetOriginOffset(org.z);break;				}			}		}	if(GID_RULER&doDepth)		{			SetGuideLines();					}	}	void DesignControl::GetDepth(FFixed *point,FFixed *base, char defAxis)	{	if(!(cacheFlag&CACHE_DEPTH))UpdateCache(CACHE_DEPTH);	switch(defAxis)			{		case INFL_X:*point = localCeil.x;*base = localFloor.x; break;		case INFL_Y:*point = localCeil.y;*base = localFloor.y; break;		case INFL_Z:*point = localCeil.z;*base = localFloor.z; break;		}		}void DesignControl::SetDepthRuler(FFixed point,FFixed base, char defAxis)	{	AppPreference *appPref;	DefaultPreference	*defPref;	Point3DFFixed	pt,bs;		appPref = GetPreference();	defPref = (DefaultPreference*)appPref->GetPreference(preferDefaults);		pt = environment->Translate3DFFixed(TO_CAD,defPref->extrusionMax);	bs = environment->Translate3DFFixed(TO_CAD,defPref->extrusionMin);		switch(defAxis)			{		case INFL_X: pt.x = point; bs.x = base; break;		case INFL_Y: pt.y = point; bs.y = base; break;		case INFL_Z: pt.z = point; bs.z = base; break;		}				pt = environment->Translate3DFFixed(TO_WORLD,pt);	bs = environment->Translate3DFFixed(TO_WORLD,bs);		FFMax(defPref->extrusionMax.x,pt.x,bs.x);	FFMax(defPref->extrusionMax.y,pt.y,bs.y);	FFMax(defPref->extrusionMax.z,pt.z,bs.z);	FFMin(defPref->extrusionMin.x,pt.x,bs.x);	FFMin(defPref->extrusionMin.y,pt.y,bs.y);	FFMin(defPref->extrusionMin.z,pt.z,bs.z);		UpdateCache(CACHE_DEPTH);	}voidDesignControl::GetWorldSize(Point3DFFixed *bMin,Point3DFFixed *bMax)	{	pwc(controller)->GetWorldSize(bMin,bMax);	}voidDesignControl::SetPreference(AppPreference *appPref,int initFlag)	{	EditorPreference	*editPref;	DefaultPreference	*defPref;	UnitPreference		*unitPref;	Point3DFFixed		pt;	RGBColor			rColor;	int	reDrawFlag,state,changeFlag;	CadControl::SetPreference(appPref,initFlag);	reDrawFlag = 0;	editPref = (EditorPreference*)appPref->GetPreference(preferEditor);	unitPref = (UnitPreference*)appPref->GetPreference(preferUnits);	defPref = (DefaultPreference*)appPref->GetPreference(preferDefaults);		changeFlag = editPref->GetChange();	if(PREF_NOCHANGE != changeFlag || initFlag)		{		if(!SameColor(zRuler->backColor,editPref->backColor)) 			{			zRuler->SetBackColor(editPref->backColor);			reDrawFlag |= 0x02;			}		if(!SameColor(zRuler->color,editPref->rulerColor)) 			{ 			zRuler->SetColor(editPref->rulerColor);			reDrawFlag |= 0x02;			}		rColor = zRuler->GetItemColor(rangeItem);		if(!SameColor(rColor,editPref->extrRangeColor)) 			{ 			zRuler->RangeColor(editPref->extrRangeColor);			reDrawFlag |= 0x02;			}		rColor = zRuler->GetItemColor(originItem);		if(!SameColor(rColor,editPref->homeColor)) 			{ 			zRuler->SetItemColor(originItem,editPref->homeColor);			reDrawFlag |= 0x02;			}				state = RULER_SNAP&editPref->editorState ? TRUE : FALSE;		if( zRuler->GetState(SNAP_STATE) != state)			zRuler->SetState(state,SNAP_STATE);		state = SHOW_RANGE|SHOW_TAB|SHOW_RULER;		if(ORIGIN_DISPLAY&editPref->editorState)state |= SHOW_ORIGIN;		if(zRuler->GetState(TAB_STATE) != state)			{			reDrawFlag = 0x04;			zRuler->SetState(state,TAB_STATE);			}		}	/* COMPARE DEFAULT CONFIGURATION */	changeFlag = defPref->GetChange();	if(PREF_NOCHANGE != changeFlag || initFlag)		{		if(!FFEqual(localCeil.x,defPref->extrusionMax.x)||			!FFEqual(localCeil.y,defPref->extrusionMax.y)||			!FFEqual(localCeil.z,defPref->extrusionMax.z)||			!FFEqual(localFloor.x,defPref->extrusionMin.x)||			!FFEqual(localFloor.y,defPref->extrusionMin.y)||			!FFEqual(localFloor.z,defPref->extrusionMin.z))				{ 				localCeil=defPref->extrusionMax; 				localFloor=defPref->extrusionMin; 				SetRuler(XYZ_RULER|RANGE_RULER);				hRuler->VDisplay(DRAW);				vRuler->VDisplay(DRAW);				reDrawFlag = 0x02;				}									pt = ppd(cadDraft)->home;		if(!FFEqual(pt.x,defPref->homePosition.x)||			!FFEqual(pt.y,defPref->homePosition.y)||			!FFEqual(pt.z,defPref->homePosition.z))			ppd(cadDraft)->SetHome(defPref->homePosition);		SetRuler(ORG_RULER|XY_RULER);		}			/* COMPARE UNIT CONFIGURATION */	changeFlag = unitPref->GetChange();	if(PREF_NOCHANGE != changeFlag || initFlag)		{		zRuler->SetFormat(hRuler->formatter);		reDrawFlag = 0x04;		}		switch(reDrawFlag)		{		case 0x01:break;/* CAD */		case 0x02:zRuler->VDisplay(DRAW);break;	/* RULER REDRAW REQUIRED */				case 0x03:break;/* CAD & RULER REDRAW REQUIRED */		case 0x04:zRuler->Reset();break;/* COMPLETE RESET */				default:break;/* NOTHING SPECIAL */				}	}void DesignControl::OrientRuler()	{		zRuler->SetAxis(environment->GetAxis());		CadControl::OrientRuler();	SetRuler(XYZ_RULER|RANGE_RULER);	}void DesignControl::SetDepthControl()	{		zRuler->SetController(this);		zRuler->SetAxis(environment->GetAxis());	SetRuler(Z_RULER|RANGE_RULER|ORG_RULER);	if(zRuler->theWindow)		zRuler->Reset();	}