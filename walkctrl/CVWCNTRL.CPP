/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "CVWCntrl.h"#include "Informtn.h"#include "VwCntrl.h"#include "DesCntrl.h"#include "SrfCntrl.h"#include "TumCntrl.h"#include "LitCntrl.h"#include "UndoBuf.h"#include "CVDraw.h"#include "View.h"#include "PolyDefs.h"#include "SurfDef.h"#include "CVPolyh.h"#include "CVSrfDef.h"#include "CVSrfFet.h"#include "CVEnvirn.h"#include "CVObserv.h"#include "Light.h" #include "CVLItem.h"#include "Ruler.h"#include "Walkthru.h"#include "WalkDefs.h"#include "ToolDef.h"#include "Unit.h"#include "AppText.h"#include "AppDeflt.h"#include "VwMenu.h"#include "Trace.h"#include "ScoreCrd.h"#include "VMath.h"#include "VDocumnt.h"#include "VWindow.h"#include "VFile.h"#include "VButton.h"#include "VGraphic.h"#include "VGUtil.h"#include "VTextDef.h"#include "Library.h"#include "AppMssgs.h"// MERGE-GOURAUD-PRO-10#if VPRO#include "CadPosn.h"#endif // VPRO#if VR || VPRO	// MERGE-GOURAUD-PRO-4#include "Credits.h"#endif // VR || VPRO#if VR	// MERGE-GOURAUD-PRO-4#include "WMenus.h"#include "VWI.H"#endif //VR#include <stddef.h>#include <string.h>#include <stdio.h>/* top left of next window */#define TOOLBOX_WARN		430#define TOOLBOX_WIDTH		75#define TOOLBOX_HEIGHT		305#define TOOLBOX_LEFT		12#if MACINTOSH#define TOOLBOX_TOP			38		// MERGE-GOURAUD-PRO-12#else#define TOOLBOX_TOP			34#endif // MACINTOSH#define COORD_HEIGHT		81		/* ABD MERGE-GOURAUD-PRO */#define EXTRUSION_WIDTH		(1+RULER_WIDTH+TAB_WIDTH+VScrollWidth())#define EXTRUSION_HEIGHT 	200#define FLOATRULER_WIDTH 	27#if VPRO#define TEXTURE_HEIGHT_MIN 		150		// ABD TEXTURE#define TEXTURE_HEIGHT_MAX 		4096		// ABD TEXTURE#if WINDOWS#define TEXTURE_WIDTH_MIN 		186		// ABD TEXTURE#else#define TEXTURE_WIDTH_MIN 		170		// ABD TEXTURE#endif#define TEXTURE_WIDTH_MAX 	170		// ABD TEXTURE#include "TEXTPALT.h"	// ABD TEXTURE#include "TEXTLITM.h"	// ABD TEXTURE#include "TEXTLIST.h"		// ABD TEXTURE#include "TEXTMENU.h"	// ABD TEXTURE#endif // VPROV_Offscreen *MakeSIcon(int inum);V_Offscreen *MakeSIcon(int inum)	{	V_Offscreen *obs;	Rect r;#if WINDOWS		// jca 19 Oct 93 {	r.top=r.left=0;    r.bottom=r.right=16;	obs=new(V_Offscreen);	obs->cOffscreen(&r,1,&vWhite,NULL);	obs->SetMetaPort();	TextSetUp(vButtonFont,vButtonFontSize,vNormal);	VTextMode(vPatCopy);	VTextMode(vSrcXor);     // jca.  The diamond stealth is persnickety about text modes	VDrawChar(inum,&r);	VPenMode(vPatXor);	VPaintRect(&r);	VTextMode(vSrcOr);      // jca	TextSetUp(vSystemFont,vSystemFontSize,vNormal);  // jca 31 Oct 93  We should reset the state, properly speaking	obs->UnsetMetaPort();	return obs;#elif MACINTOSH	return(NULL);#endif	// WINDOWS // jca 19 Oct 93 }	}voidCAVWalkController::cController(V_Document *doc)	{	V_Window	*window;		toolChest = NULL;	dropRoot = NULL;		#if VPRO	textureList = (TextureList *)cTool(this,toolTextureList);	// ABD TEXTURE	textureList->SetController(this);	// ABD TEXTURE	#if MACINTOSH // ABD FOR WINDOWS QQQ	tgrowPane = (GrowPane *)cTool(this,toolPTGrow);		// ABD TEXTURE	tgrowPane->SetController(this);	// ABD TEXTURE	#else	tgrowPane = NULL;    #endif // MACINTOSH // ABD FOR WINDOWS QQQ	textureBackPane = (TextureBackPane *)cTool(this,toolPTBlank);		// ABD TEXTURE	textureBackPane->SetController(this);	// ABD TEXTURE	#endif // VPRO	#if WINDOWS	// jca 19 Oct 93 {	sIcon[0]=MakeSIcon(134);  // Top Observer	sIcon[1]=MakeSIcon(135);  // Side Observer	sIcon[2]=MakeSIcon(136);  // X Marks the spot	sIcon[3]=MakeSIcon(87);   // Rotation tool#endif 		// jca 19 Oct 93 }	traceTree = new(V_Array);	traceTree->cArray(0,sizeof(Trace*),4);	#if VWT	viewMenu = new(MenuView);	viewMenu->ctheMenu(doc);	viewMenu->SetController(this);#elif VR	walkMenu = new(MenuVRWalk);	walkMenu->ctheMenu(doc);	walkMenu->SetController(this);#endif //VWT#if VPRO	// MERGE-GOURAUD-PRO	position = (CadPosition *)cTool(this,toolPPosition);		/* create the position pane				  */	position->SetController(this);#endif	windowMenu = new(MenuWindow);	windowMenu->ctheMenu(doc);	windowMenu->SetController(this);		modelSizeMin = Pt3DFFMax;	modelSizeMax = Pt3DFFMin;	information = new(Information);	information->cInformation();		selectlist = (V_Array*)cTool(this,toolTSelect);	environments = (V_Array*)cTool(this,toolTEnvironment);	layerlist = NULL;	layerlist = (V_Array*)cTool(this,toolTList);		duplicate = NULL;				SetChange(FALSE);	WalkController::cController(doc);#if 0	// MERGE-PRO no vdigs for now#if VPRO	// ELVIS -- 19JAN94 adding in texture-related parts of PRO to the	// system -- jca	docTextures->AddVDIGs();#endif // VPRO#endif	dropRoot = new(CAVPolyhedron);	dropRoot->cPolyhedron(drawing);	dropRoot->CreateRoot();	preFullWindowState = 0;			NewUndoItem(UNDO_NONE_FLAG);	Request(NULL,msgUpdate,objPolyhedron,0);	}	#if VPROvoidCAVWalkController::cAllPalettes()	// ABD TEXTURE	{		V_Window	*window;	// MERGE-GOURAUD-PRO [[[ move this!!! 본본	window = GetWindow(objCoord);  /* ABD 1 Mar */	if (window->panes == NULL)	{		if (position)window->Install(position);		// install position into coord window		else DEBUGGER();	}	// MERGE-GOURAUD-PRO ]]] move this!!! 본본	window = GetWindow(objTexturePal);  /* ABD */	if (window->panes == NULL)	{		if (textureList) 		{ 			window->Install(textureList);			textureList->SetVSpeed(15);			textureList->SetTextureBackPane(textureBackPane);		}		if (textureBackPane) 		{			textureBackPane->SetTextureList(textureList);			window->Install(textureBackPane);		}		textureList->NewItem2();		// make no texture item		textureList->SetSelection(0);	// MERGE-GOURAUD-PRO-7				if (tgrowPane) window->Install(tgrowPane);	}	}void	CAVWalkController::ActivatePalette(int palette_tool, Boolean active) { 	switch(palette_tool)	{		case toolWTexture:			if(textureList)				if (active) textureList->Activate();				else textureList->Deactivate();			if(textureBackPane)				if (active) textureBackPane->Activate();				else textureBackPane->Deactivate();			break;		// MERGE-GOURAUD-PRO [[[		case toolWCoord:			if(position)				if (active) position->Activate();				else position->Deactivate();			break;		// MERGE-GOURAUD-PRO ]]]	}}void	CAVWalkController::SetPaletteController(int palette_tool, Controller *c) { 	switch(palette_tool)	{		case toolWTexture:			if(textureList)textureList->SetController(c);		// ABD			if(tgrowPane)tgrowPane->SetController(c);		// ABD			if(textureBackPane)textureBackPane->SetController(c);		// ABD			break;		// MERGE-GOURAUD-PRO [[[		case toolWCoord:			if(position) position->SetController(c);			break;		// MERGE-GOURAUD-PRO ]]]	}}#endif // VPRO		voidCAVWalkController::dController()	{	Trace	**pTrace;	int		i,length;		#if WINDOWS		// jca 19 Oct 93 {	for(i=0;i<4;i++)sIcon[i]->dOffscreen();#endif			// jca 19 Oct 93 }	length = traceTree->ALength();	if(length)		{		pTrace = (Trace	**)traceTree->Use();		for(i =0; i < length; i++,pTrace++)			(*pTrace)->dTrace();		traceTree->Unuse();		}	traceTree->dArray();		selectlist->dArray();	environments->dArray();	windowMenu->dMenu();#if VWT	viewMenu->dMenu();#elif VR	walkMenu->dMenu();#endif //VWT	dropRoot->dPolyhedron();		#if VPRO	//퉌본툓elete texture things here !!! XYZZY DEBUG BUGBUG BILBIL ELVIS WHATEVER	//JAM MEMLEAK1 FIX 25MAY94 [[[	textureList->dPane();	if (tgrowPane) tgrowPane->dPane();		// ABD TEXTURE  for windows qqq	textureBackPane->dPane();		// ABD TEXTURE		position->dPane(); //delete position pane jam 7OCT94	//JAM MEMLEAK1 FIX 25MAY94 ]]]	#endif // VPRO		if (creditScreen) creditScreen->dOffscreen();	if (creditText) creditText->dArray();			WalkController::dController();	}	void CAVWalkController::SetDocument(V_Document *doc) 	{ 	V_MenuMgr	*gmenu;	WalkController::SetDocument(doc);	gmenu =document->GetMenuMgr();#if VWT	gmenu->Append(viewMenu);#elif VR	gmenu->Append(walkMenu);#endif //VWT	gmenu->Append(windowMenu);	}	int CAVWalkController::GetWindowState()  	{ 	V_Window	*window;	ToolDef		**toolDef;	int	i,length,flag;		flag = 0;	length = toolChest->ALength();	toolDef = (ToolDef**)toolChest->Use();	for(i = 0; i < length; i++,toolDef++)		{			switch((*toolDef)->GetType())			{			case	toolWToolBox: 				window = (*toolDef)->GetWindow();if(window->Visible())flag|=TOOLS_ON; break;			case	toolWDepth: 				window = (*toolDef)->GetWindow();if(window->Visible())flag|=DEPTH_ON; break;#if VPRO			case	toolWCoord: 	/* ABD MERGE-GOURAUD-PRO */				window = (*toolDef)->GetWindow();if(window->Visible())flag|=COORD_ON; break;			case	toolWTexture: 	/* ABD TEXTURE */				window = (*toolDef)->GetWindow();if(window->Visible())flag|=TEXTURE_ON; break;#endif // VPRO			case	toolCRTLWalk: 				window = (*toolDef)->GetWindow();if(window->Visible())flag|=WALK_ON; break;			default: break;			}		}			toolChest->Unuse();		return flag; 	}/*========================================================================= * int CAVWalkController::React(V_Window *whichWindow,int state) *	method reacts to a window coming to front or being destroyed. *	it returns the front window type of controller to the document so  *	can mess with the menus.  This method should be known as DUDE solely because *	he knows too much about the V_Windows environment.  He needs to die. *-------------------------------------------------------------------------*/intCAVWalkController::React(V_Window *whichWindow,int state)	{	V_Window	*window;	ToolDef		*toolDef;	Controller	*ctrl,*nextCtrl;	int			NULLEnviron = -1;	int			ctrlType,returnType,length,i,found;		if(!whichWindow) return(type);		returnType = -1;	length = toolChest->ALength();	for(i = 0; i < length; i++)		{		toolChest->Get(i,&toolDef);// DAS-VR-SURFEDITOR 9/6/93#if VWT		if(whichWindow == toolDef->GetWindow())#elif VR		if(whichWindow == toolDef->GetWindow() && 			!(whichWindow == saveWindow && toolDef->GetType() == toolCRTLDesign))#endif			{			ctrlType = toolDef->GetType();			switch(ctrlType)				{				case toolWToolBox:				#if VPRO				case toolWCoord:  	/* ABD MERGE-GOURAUD-PRO */				case toolWTexture:  	/* ABD TEXTURE */				#endif // VPRO				case toolWDepth: 					switch(state)						{						case HIDE: /* HIDE */ break;						case ACTIVATE: /* ACTIVATE */ break;						case DEACTIVATE: /* DEACTIVATE */ break;						case CLOSE: /* DESTROY */							FlushPallette(ctrlType);							toolDef->SetWindow(NULL);							break;						}					break;									case toolCRTLDesign: 					case toolCRTLSurface: 					case toolCRTTumble: 				case toolCRTLView: 				case toolCRTLLibrary:				case toolCRTLLight: 						ctrl = (Controller*)toolDef->GetTool(); 					switch(state)						{						case ACTIVATE: 							if( lastController != ctrl )								{								if(lastController->GetType() == ctrl->GetType()) 									ctrl->Activate(msgInit);								else ctrl->Activate(msgReset);								}							else								ctrl->Activate(msgDummy2);							found = controllers->Find(&ctrl);							if(VARY_NOTFOUND != found)							 	{							 	controllers->Remove(found);							 	controllers->Insert(0,&ctrl);							 	}							 								lastController = ctrl;							returnType = ctrlType;							break;													case HIDE: 							break;																case DEACTIVATE: 							ctrl->Activate(msgDeactivate);							break;												case CLOSE: 							switch(ctrlType)								{								case toolCRTLTool:								case toolCRTLWalk:									break;																	case toolCRTLDesign:									environments->Put(ppc(ctrl)->CADid,&NULLEnviron);																		default:									found = controllers->Find(&ctrl);									controllers->Remove(found);									if(lastController == ctrl)										lastController = this;									ctrl->dController();									toolChest->Remove(i);									toolDef->dToolDef();									if(!controllers->ALength())  										{										ShowPallette(toolWToolBox,HIDE);										returnType = type;										}									if(toolCRTLDesign == ctrlType)										{										nextCtrl = FindController(toolCRTLDesign);										if(!nextCtrl)ShowPallette(toolWDepth,HIDE); 										else ppc(nextCtrl)->SetDepthControl();																					#if VPRO // tell the texture list we have no controller										textureList->SetController(NULL);										#endif // VPRO										}									break;								}							break;						}					break;				default: 						break;				}			break; /* out of the if loop */			}		}			return(returnType);	}voidCAVWalkController::LaunchController(LaunchInit launchInit, int type)	{	V_Window			*window;	Controller			*ctrl,**pctrl;	ToolDef				*toolDef;	CAVSurfDef			*surfDef;	Rect				r;	Point				p,w;	CAVEnvironment		*environment = NULL;	Information			*information;	int					i,length,viewType;	int inOutView = outsideView;	// ABD MERGE25 		// ABD MERGE25 [[[	if ((type == insideView) || (type == outsideView))	{		inOutView = type;		type = toolCRTLSurface;	}	// ABD MERGE25 ]]]		viewType = type;	r = launchInit.location;		defaultWindowRect = r;		switch(type)		{		case toolWToolBox:		#if VPRO		case toolWCoord:  		 	/* ABD MERGE-GOURAUD-PRO */		case toolWTexture:  		 	/* ABD TEXTURE */		#endif // VPRO		case toolWDepth:  					window = cPallette(type);			window->Move(&r);			window->Show();			return;			break;					case toolCRTLTool: 			break;					case toolCRTTumble: 			NewUndoItem(UNDO_NONE_FLAG); 			ctrl = new(TumbleControl); 			pcc(ctrl)->SetPolyhedron((CAVPolyhedron*)launchInit.data.polyhedron);			break;					case toolCRTLLight: 			NewUndoItem(UNDO_NONE_FLAG);			ctrl = new(LightController);					plc(ctrl)->SetPolyhedron((CAVPolyhedron*)launchInit.data.polyhedron);			break;		case topView:		case bottomView:					case rightView:		case leftView:		case frontView:		case backView:			ctrl = new(DesignControl); 			type = toolCRTLDesign; 			environment = SetCAVEnvironment(msgCreate,toolCRTLDesign);			((CadControl*)ctrl)->SetPolyhedron(pcp(root));			break;		case toolCRTLSurface: 			NewUndoItem(UNDO_NONE_FLAG); 			ctrl = new(SurfControl); 			environment = SetCAVEnvironment(msgCreate,toolCRTLSurface); 			surfDef = (CAVSurfDef*)launchInit.data.surfDef;			psc(ctrl)->SetSurfDef(surfDef);			pcc(ctrl)->SetPolyhedron(pcp(surfDef->polyhedron));			break;				default: 			WalkController::LaunchController(launchInit,type); 			return; 			break;		}		information = new(Information);	information->cInformation();	ctrl->information = information;	ctrl->SetController(this);	ctrl->SetType(type);	InitInfo(ctrl);	if(environment)		{		environment->SetView(viewType);		ctrl->information->environment = environment;		}	ctrl->cController(document);	#if VR // jca 17JAN94	// ABD MERGE25 [[[	if (type == toolCRTLSurface)	{		if (inOutView == insideView)			psc(ctrl)->SetSurfSide(SURF_INSIDE);		else // outsideView			psc(ctrl)->SetSurfSide(SURF_OUTSIDE);		ctrl->information->environment->SetView(inOutView);	}	// ABD MERGE25 ]]]#endif // VR		if( toolCRTLDesign == type || toolCRTLSurface == type || toolCRTTumble == type )		pcc(ctrl)->SetScale(FixedToDbl(launchInit.scale),TRUE);	ctrl->Activate(msgCreate);	toolDef = new(ToolDef);	toolDef->cToolDef(ctrl,type);		window = ctrl->GetWindow(type);		// MERGE-VR-FIX moved this line up// DAS-VR-SURFEDIT 9/6/93#if VWT	if(window) window->Move(&r);#elif VR 	if ((type == toolCRTLDesign) && (window))		window->Move(&r);       // jca 13 sept 93.  this places the design view in the right place.#endif     // VWT	toolDef->SetWindow(window);	toolChest->Append(&toolDef);	controllers->Append(&ctrl);	ctrl->SetPreference(appPreferences,TRUE);	ctrl->Response(NULL,msgInit,objDefaults,0);		if(window)			{		document->React(window,ACTIVATE);		window->Show();		}			if(environment) 		environment->dCAVEnvironment();	}				// ABD WILLIAMS MERGE-TEXTURE 9/13/93 [[[		struct TextureItem * CAVWalkController::GetTexture()	{		#if VPRO	if ( GetTextureListItem())		return GetTextureListItem()->GetTextureItem();	#else		// return current texture		DEBUGGER();		// MERGE25		return(NULL);	// must return something jca 31MAY94	#endif // VPRO	}#if VPRO//JAM TXTRFIDDLE 06/14/94 [[[struct TextureBackPane *		// ABD TEXTURECAVWalkController::GetTextureBackPane()	{	return (TextureBackPane *)(textureBackPane);	}	//JAM TXTRFIDDLE 06/14/94 ]]]			struct TextureList *		// ABD TEXTURECAVWalkController::GetTextureList()	{	return (TextureList *)(textureList);	}	struct TextureListItem *		// ABD TEXTURECAVWalkController::GetTextureListItem()	{	return (TextureListItem *)(textureList->GetTextureListItem());	}	#endif // VPROvoid		// ABD TEXTURECAVWalkController::SetTextureItem(struct TextureItem *ti)	{//	#if VPRO//	if ( GetTextureListItem())//		return GetTextureListItem()->GetTextureItem();	#if VPRO		textureList->SetTextureItem(ti);	#else		// return current texture		DEBUGGER();		// MERGE25	#endif // VPRO	}		voidCAVWalkController::AddTextureItem(struct TextureItem *ti)		// ABD TEXTURE	{	#if VPRO		// AddItem2 checks to see if the specified texture item is already in		// the list and does not add it if it is already there		struct TextureItem *ti0 = GetTexture();		// MERGE-GOURAUD-PRO-12		textureList->AddItem2(ti);		SetTextureItem(ti0);		// MERGE-GOURAUD-PRO-12	#else		// IN VR, DO NOTHING (no texture pallete per se)	// MERGE25		// AddItem2 checks to see if the specified texture item is already in		// the list and does not add it if it is already there		// textureList->AddItem2(ti);	#endif // VPRO	}		voidCAVWalkController::AddTextureItem3(struct TextureItem *ti)		// ABD TEXTURE	{	#if VPRO		// AddItem2 checks to see if the specified texture item is already in		// the list and does not add it if it is already there		struct TextureItem *ti0 = GetTexture();		// MERGE-GOURAUD-PRO-12		textureList->AddItem3(ti);		SetTextureItem(ti0);		// MERGE-GOURAUD-PRO-12	#else		// IN VR, DO NOTHING (no texture pallete per se)	// MERGE25		// AddItem2 checks to see if the specified texture item is already in		// the list and does not add it if it is already there		// textureList->AddItem3(ti);	#endif // VPRO	}// ABD WILLIAMS MERGE-TEXTURE 9/13/93 ]]]	CAVEnvironment *CAVWalkController::SetCAVEnvironment(int action,int ctrlType)	{		CAVEnvironment *environment = NULL;	int	emptySpot,nilEnviron;		nilEnviron = -1;	emptySpot = environments->Find(&nilEnviron);	environment = new(CAVEnvironment);	environment->cCAVEnvironment();		if(toolCRTLDesign == ctrlType)		{		if(VARY_NOTFOUND != emptySpot)			environments->Put(emptySpot,&emptySpot);			else			{			emptySpot = environments->ALength();			environments->Append(&emptySpot);			}		environment->SetID(emptySpot);			}				return(environment);	}	voidCAVWalkController::InitInfo(Controller *ctrl)	{	WalkController::InitInfo(ctrl);	ctrl->information->list = layerlist;	ctrl->information->selectList = selectlist;/* dude */	ctrl->information->tracePolyhedron = dropRoot;/* dude */	}	voidCAVWalkController::NewPolyhedron(int what,CAVPolyhedron  *npoly)	{	Controller **pctrl;	int		length,i,resetFlag = FALSE;			length = controllers->ALength();	pctrl = (Controller **)controllers->Use();	for(i = 0; i < length; i++,pctrl++) 		{		switch((*pctrl)->GetType())			{			case toolCRTLDesign:				ppc((*pctrl))->NewPolyhedron(what,objWalk,npoly);					break;			default: break;			}		}	controllers->Unuse();		SetChange(TRUE);	}	voidCAVWalkController::NewSurfFeature(V_Array  *featList)	{	Controller **pctrl;	int		length,i;			length = controllers->ALength();	pctrl = (Controller **)controllers->Use();	for(i = 0; i < length; i++,pctrl++) 		if(toolCRTLDesign == (*pctrl)->GetType())			ppc((*pctrl))->NewSurfFeature(featList);	controllers->Unuse();	SetChange(TRUE);	}voidCAVWalkController::Select(CAVPolyhedron *poly,V_Array *list)	{	Controller	**pCtrl;	int			length,i;			length = controllers->ALength();	pCtrl = (Controller **)controllers->Use();	for(i = 0; i < length; i++,pCtrl++)		{		switch((*pCtrl)->GetType())			{			case toolCRTLDesign:				if (ppc((*pCtrl))->environment)					ppc((*pCtrl))->environment->SetPatternOrigin();				ppc((*pCtrl))->SelectPolyhedron(poly,list);				break;			default:				break;			}		}	controllers->Unuse();	}#if VPRO// MERGE-GOURAUD-PRO ]]]void CAVWalkController::GetPlace(Rect *r,int warning,int who)	{	Rect	tr;		switch(who)		{						case toolPPosition:			(GetWindow(objCoord))->GetRect(&tr);			/* we only care about left and right -- top and bottom set in the			   CadPosition:CalcSize.  This assumes that the tool and position windows			   are the same size horizontally.  We add one to the right side so that			   the rect drawn around the position palette looks good. */			r->right = tr.right+1;			r->left = tr.left;			break;		}	}// MERGE-GOURAUD-PRO ]]]#endifvoid CAVWalkController::SetLastPoly(CAVPolyhedron *poly) {  duplicate = poly; }CAVPolyhedron *CAVWalkController::GetLastPoly() { return(duplicate); }// MERGE-GOURAUD-PRO [[[V_Window * CAVWalkController::GetWindowOfType(int ctrlType){V_Window *window = NULL;int length, i;Controller	*ctrl;	length = controllers->ALength();	for(i = 0; i < length; i++)	{		controllers->Get(i,&ctrl);		if (ctrl->GetType() == ctrlType)		{			window = ctrl->GetWindow(ctrlType);			break;		}	}	return window;}// MERGE-GOURAUD-PRO ]]]voidCAVWalkController::LaunchEditor(Polyhedron *poly,FFixed scale,SurfDef *surfDef,Point3DFFixed orient,int ctrlType)	{	V_Window 	*window;	LaunchInit	launchInit;	Controller	*ctrl;	Rect		r;	int			i,length;	int view = ctrlType;	// ABD MERGE25 which view shall we use?  (inside or outside?)			// ABD MERGE25 [[[	// !!! 휴BD major bogisity -- insideView and outsideView come from enums	// that are different from toolCRTLSurface, so they could be equal if someone	// changes the numbering scheme.  This is bad but it works for now, since	// toolCRTLSurface is probably 40 or 50-something and insideView/outsideView	// is less than 10.  This should be fixed.  This is here to support bringing	// up the surface editor in the inside instead of outside view when the inside	// surface is clicked	if ((ctrlType == insideView) || (ctrlType == outsideView))		ctrlType = toolCRTLSurface;	// ABD MERGE25 ]]]		if(!poly) poly = root;		length = controllers->ALength();	for(i = 0; i < length; i++)		{		controllers->Get(i,&ctrl);		if(ctrl->CheckPolyhedron(poly))			{			if(ctrlType == ctrl->GetType())				{ 				if(toolCRTLSurface != ctrlType || (surfDef == psc(ctrl)->GetSurfDef()))					{// { DAS-VR-SURFEDIT 9/22/93 don't hilite already selected surfaces#if VWT					window = ctrl->GetWindow(ctrlType);					window->Select();#endif// } DAS-VR-SURFEDIT 9/22/93 don't hilite already selected surfaces					return;					}				}			}		}	// MERGE-GOURAUD-PRO [[[		// if the front controller is a view or walk controller, then look for a controller	// of the type we want and use it instead of this controller.  If we cant find	// a window of the same type that we want, we look for a design, surface, tumble,	// or light window instead.  	window = NULL;	if (!((ctrlType == toolCRTLView) || (ctrlType == toolCRTLWalk)))		// ABD		{		window = GetWindowOfType(ctrlType);		if (window == NULL) window = GetWindowOfType(toolCRTLDesign);		if (window == NULL) window = GetWindowOfType(toolCRTLSurface);		if (window == NULL) window = GetWindowOfType(toolCRTTumble);		if (window == NULL) window = GetWindowOfType(toolCRTLLight);	}	// MERGE-GOURAUD-PRO ]]]		controllers->Get(0,&ctrl);	if (window == NULL)		// MERGE-GOURAUD-PRO		window = ctrl->GetWindow(ctrl->GetType());	window->Locate(&r);	r.top +=VTitleBarHeight();	switch(ctrlType)		{		case toolCRTTumble:			launchInit.scale = scale;			launchInit.data.polyhedron = poly;			launchInit.location = r;			LaunchController(launchInit,ctrlType);			break;				case toolCRTLSurface:			launchInit.scale = scale;			launchInit.data.surfDef = surfDef;			launchInit.location = r;			LaunchController(launchInit,view);		// ABD MERGE25 -- tell surfed to use inside or outside#if VR // jca 17JAN94			((WalkDocument*)ActiveDocument())->SwitchLibs(TRUE);	// MERGE15#endif // VR			break;				case toolCRTLLight:			launchInit.scale = scale;			launchInit.data.polyhedron = poly;				launchInit.location = r;		LaunchController(launchInit,ctrlType);			break;				default:			launchInit.scale = scale;			launchInit.data.polyhedron = poly;			launchInit.location = r;			LaunchController(launchInit,ctrlType);			break;		}	}			voidCAVWalkController::Request(void *val,int action,int who,int scope)	{	AppPreference		*appPref;	DefaultPreference	*defPref;	CAVPolyhedron		*pPoly;	Light	*l;	LightModel	*lm;	Point3DFFixed defDepth;	LayerItem	*item;		Unit	*unit,*worldUnit;	Point3DFFixed	pt;	Point3D			p;	Angle3DFFixed	angle;	double	ratio,result;	int noScale;	V_File	*file;	Trace   **pTrace;	int i,length,err;	ScoreRecord	scoreRec;	char *namePtr;		switch(action)		{		case msgCreate:			SetChange(TRUE);			break;		case msgDestroy:			if(objIO == who)				{				Activate(msgReset); 				layerlist = (V_Array*)cTool(this,toolTList);					}			else				SetChange(TRUE);			break;								case msgInit: 					switch(who)				{				case objIO:					length = traceTree->ALength();					if(length)						{						pTrace = (Trace**)traceTree->Use();						for(i = 0; i < length; i++,pTrace++)							{							file = (*pTrace)->GetFile();							err = file->Find();/* check error here...if I didn't find it  Popup SFGetFile to go get it */							DoImport(*pTrace,file,&scoreRec);							EndImport(*pTrace);							InstallTrace(*pTrace);							}						traceTree->Unuse();						}					ModelSize(root);					break;								case objDefaults:					appPref = GetPreference();					defPref = (DefaultPreference*)appPref->GetPreference(preferDefaults);										layerlist = (V_Array*)cTool(this,toolTList);							item = new(LayerItem);					HLock(defPref->layerName);					namePtr = (char *)HDeref(defPref->layerName);					item->cListItem(namePtr);					HUnlock(defPref->layerName);					layerlist->Append(&item);										ModelSize(root);											break;				}							break;					case msgEdit: 			SetChange(TRUE);			if((objDepth == who) || (objPolyhedron == who))				if(ModelSize(root)) 					action = msgReset; 			break;				case msgReset: 			if((objDepth == who) || (objPolyhedron == who))				ModelSize(root); 			break;					default: 			break;		}							WalkController::Request(val,action,who,scope);	}intCAVWalkController::EditPolyhedron(void *obj,int flag)	{	V_Array		*deadWindows;	V_Window	*deadGuy;	Trace		**pTrace,*dTrace;	CAVPolyhedron	*pPoly,*dPoly;	LayerItem	*layer;	Controller	**pctrl;	int		i,length,where,theType,num;			length = controllers->ALength();	pctrl = (Controller **)controllers->Use();		switch(flag)		{		case msgDestroy: 			deadWindows = new(V_Array);			deadWindows->cArray(0,sizeof(V_Window*),4);			for(i = 0; i < length; i++,pctrl++) 				{				theType = (*pctrl)->GetType();				switch(theType)					{					case toolCRTLDesign: 					case toolCRTLView: 					case toolCRTLLibrary:						break;					default:						if((*pctrl)->CheckPolyhedron(obj))							{							deadGuy =(*pctrl)->GetWindow(theType);							deadWindows->Append(&deadGuy);							}						break;					}				}							length = deadWindows->ALength();			for(i = 0; i < length; i++) 				{				deadWindows->Get(i,&deadGuy);				deadGuy->Delete();				}						deadWindows->dArray();			break;				default: 				for(i = 0; i < length; i++,pctrl++) 				if((*pctrl)->CheckPolyhedron(obj))					(*pctrl)->Response(NULL,msgReset,flag,0);			break;		}	controllers->Unuse();	}	voidCAVWalkController::ShowPallette(int ctrlType,int state)	{	V_Window	*window;	int			visible;		if(!(window = cPallette(ctrlType))) return;	visible = window->Visible();	switch(state)		{		case SHOW: if(!visible)window->Show(); break;		case HIDE: if(visible)window->Hide(); break;		}	}void	CAVWalkController::GetWorldSize(Point3DFFixed*bMin,Point3DFFixed*bMax)/* NEW */	{	*bMin = modelSizeMin;	*bMax = modelSizeMax;	}intCAVWalkController::ModelSize(Polyhedron  *newPoly)	{	AppPreference		*prefs;	DefaultPreference	*defPrefs;	Point3DFFixed	defNear,defFar,extrN,extrF,testMin,testMax,bndMin,bndMax;	int				resize = FALSE;			if(newPoly->container != root && newPoly != root)  return(FALSE);		bndMin = defBoundMin;	bndMax = defBoundMax;		testMin = modelSizeMin;	testMax = modelSizeMax;	if(pcp(root)->ModelSize(&testMin,&testMax)) resize = TRUE;	if(dropRoot)		if(pcp(dropRoot)->ModelSize(&testMin,&testMax)) resize = TRUE;	prefs = GetPreference();	defPrefs = (DefaultPreference*)prefs->GetPreference(preferDefaults);	defNear = defPrefs->extrusionMin;	defFar = defPrefs->extrusionMax;		/* make sure extrusion lines are included */	if(LESS == FFLogic(defNear.x,defFar.x)) { extrN.x = defNear.x; extrF.x = defFar.x; }	else { extrN.x = defFar.x; extrF.x = defNear.x; }		if(LESS == FFLogic(defNear.y,defFar.y)) { extrN.y = defNear.y; extrF.y = defFar.y; }	else { extrN.y = defFar.y; extrF.y = defNear.y; }		if(LESS == FFLogic(defNear.z,defFar.z)) { extrN.z = defNear.z; extrF.z = defFar.z; }	else { extrN.z = defFar.z; extrF.z = defNear.z; }		/* height boundary */	if(LESS == FFLogic(extrN.x,testMin.x)){ testMin.x = extrN.x; resize = TRUE; } 	if(LESS == FFLogic(extrN.y,testMin.y)){ testMin.y = extrN.y; resize = TRUE; } 	if(LESS == FFLogic(extrN.z,testMin.z)){ testMin.z = extrN.z; resize = TRUE; } 	if(GRTR == FFLogic(extrN.x,testMax.x)){ testMax.x = extrF.x; resize = TRUE; } 	if(GRTR == FFLogic(extrN.y,testMax.y)){ testMax.y = extrF.y; resize = TRUE; } 	if(GRTR == FFLogic(extrN.z,testMax.z)){ testMax.z = extrF.z; resize = TRUE; } /* minimum boundary */	if(LESS == FFLogic(bndMin.x,testMin.x)){ testMin.x = bndMin.x; resize = TRUE; } 	if(LESS == FFLogic(bndMin.y,testMin.y)){ testMin.y = bndMin.y; resize = TRUE; } 	if(LESS == FFLogic(bndMin.z,testMin.z)){ testMin.z = bndMin.z; resize = TRUE; } 	if(GRTR == FFLogic(bndMax.x,testMax.x)){ testMax.x = bndMax.x; resize = TRUE; } 	if(GRTR == FFLogic(bndMax.y,testMax.y)){ testMax.y = bndMax.y; resize = TRUE; } 	if(GRTR == FFLogic(bndMax.z,testMax.z)){ testMax.z = bndMax.z; resize = TRUE; } 	if(resize)		{		modelSizeMin = testMin;		modelSizeMax = testMax;		}			return(resize);	}V_Window *CAVWalkController::cPallette(int ctrlType)	{	V_Window	*window;	V_Console	*vcrConsole;	ToolDef		*toolDefinition;	Rect		r;	Point		w,pMin,pMax,buttonPt;	int			i,length;			length = toolChest->ALength();	for(i = 0; i < length; i++)		{		toolChest->Get(i,&toolDefinition);		if(ctrlType == toolDefinition->GetType())			return(toolDefinition->GetWindow());		}			switch(ctrlType)		{		case toolWToolBox:			GetLimitedScreen(&r);			w.v = TOOLBOX_WARN; w.h = 0;#if MACINTOSH			r.left = TOOLBOX_LEFT; r.top = TOOLBOX_TOP; r.right = r.left+TOOLBOX_WIDTH; r.bottom -= 6;		// MERGE-GOURAUD-PRO-12#else			r.left = TOOLBOX_LEFT; r.top = TOOLBOX_TOP; r.right = r.left+TOOLBOX_WIDTH; r.bottom -= 10;#endif // MACINTOSH			pMax.h = TOOLBOX_WIDTH;			pMax.v = r.bottom- r.top;			pMin.h = TOOLBOX_WIDTH;			pMin.v = TOOLBOX_HEIGHT;			window = new(V_Window);#if MACINTOSH			window->cWindow(&r,TXT_EMPTYSTRING,pMin,pMax,w,DRAGBAR|GOAWAY|GROWBOX|ZOOMBOX|WINDOID,WINDOW_HIDE);		// ABD MERGE12 WILLIAMS 9/12/93#elif WINDOWS			// On Windows, GROWBOX gets you 'dem thick grow edges. We'd rather not have them            // around the tool window.			window->cWindow(&r,TXT_EMPTYSTRING,pMin,pMax,w,DRAGBAR|GOAWAY|WINDOID,WINDOW_HIDE);#endif //WINDOWS			break;				case toolWDepth:			GetLimitedScreen(&r);			pMax.h = EXTRUSION_WIDTH;			pMax.v = r.bottom- r.top;			pMin.h = EXTRUSION_WIDTH;			pMin.v = EXTRUSION_HEIGHT;			r.left = ((r.right - r.left)>>1) -10;			r.right = r.left + EXTRUSION_WIDTH;			r.top = 64; 			r.bottom = r.top + EXTRUSION_HEIGHT;			window = new(V_Window);#if MACINTOSH			window->cWindow(&r,TXT_EMPTYSTRING,pMin,pMax,maxPoint,DRAGBAR|GOAWAY|GROWBOX|ZOOMBOX|WINDOID,WINDOW_HIDE);		// ABD MERGE12 WILLIAMS 9/12/93#elif WINDOWS			window->cWindow(&r,TXT_EMPTYSTRING,pMin,pMax,maxPoint,DRAGBAR|GOAWAY|WINDOID,WINDOW_HIDE);		// jca 27JAN94 no grow/zoom boxes#endif // MACINTOSH			break;					#if VPRO		case toolWTexture: 	/* ABD TEXTURE */			GetScreen(&r);			w.v = 0; w.h = 0;			r.left = r.right - 10 - (TEXTURE_WIDTH_MIN * 2); 			r.top = r.bottom - 10 - TEXTURE_HEIGHT_MIN; 			r.right = r.left + TEXTURE_WIDTH_MIN+1; 			r.bottom -= 10;			pMax.h = TEXTURE_WIDTH_MIN+1;			pMax.v = TEXTURE_HEIGHT_MAX;			pMin.h = TEXTURE_WIDTH_MIN;			pMin.v = TEXTURE_HEIGHT_MIN;			window = new(V_Window);			window->cWindow(&r,TXT_TEXTURES,pMin,pMax,w,DRAGBAR|GOAWAY|GROWBOX|WINDOID,WINDOW_HIDE);	// PRO-JAP			break;					// MERGE-GOURAUD-PRO [[[		case toolWCoord: 	/* ABD MERGE-GOURAUD-PRO */			GetScreen(&r);			//w.v = TOOLBOX_WARN; w.h = 0;			w.v = 0; w.h = 0;			r.left = TOOLBOX_LEFT+TOOLBOX_WIDTH+2; r.top = TOOLBOX_TOP; r.right = r.left+TOOLBOX_WIDTH; r.bottom = TOOLBOX_TOP + COORD_HEIGHT;		// MERGE-GOURAUD-PRO-5			pMax.h = TOOLBOX_WIDTH+1;			pMax.v = r.bottom- r.top;			pMin.h = TOOLBOX_WIDTH;			pMin.v = COORD_HEIGHT;			window = new(V_Window);			window->cWindow(&r,(strPtr)"",pMin,pMax,w,DRAGBAR|GOAWAY|WINDOID,WINDOW_HIDE);			break;		// MERGE-GOURAUD-PRO ]]]		#endif // VPRO		}		toolDefinition = new(ToolDef);	toolDefinition->cToolDef(NULL,ctrlType);		toolDefinition->SetWindow(window);		toolChest->Append(&toolDefinition);	document->Install(window);	return(window);	}/*========================================================================= * void	CAVWalkController::FlushPallette(int ctrlType) *-------------------------------------------------------------------------*/voidCAVWalkController::FlushPallette(int ctrlType)	{	V_Window	*window;			if(!(window = cPallette(ctrlType))) return;	if(window->panes)		{		V_Pane *pane;		while(window->panes->ALength())			{			window->panes->Get(0,&pane);			window->UnInstall(pane);			}		}	}void *CAVWalkController::cTool(Controller *ctrl,int toolType)	{	V_Window	*window;	ToolDef		*toolDefinition;	V_Array		*list;	ListItem 	**item;	Observer	*newObserver;	void		*tool = NULL;	int			i,length;		if(toolChest)		{		length = toolChest->ALength();		for(i = 0; i < length; i++)			{			toolChest->Get(i,&toolDefinition);			if(toolType == toolDefinition->GetType())				return(toolDefinition->GetTool());			}		}			switch(toolType)		{		case toolFlush:	/* flush out the tool  pallette */			FlushPallette(toolWToolBox);			break;		case toolTEnvironment:			list = new(V_Array);			list->cArray(0,sizeof(int),4);			tool = list;			break;					case toolTView:/* create view *//* this exists here so I dont loop twice */			newObserver = NewObserver();			newObserver->cView(drawing);			newObserver->SetController(this);			// ABD HMD MAR95 removed newObserver->DefaultHMD() call			tool = newObserver;				break;		case toolTSelect:/* create select list */			list = new(V_Array);			list->cArray(0,sizeof(CAVPolyhedron*),4);			tool = list;			break;				#if VPRO		case toolPPosition:/* create position pane */			position = new(CadPosition);			position->cPane(0);			tool = position;			break;		case toolPTBlank:		// ABD TEXTURE			tool = (TextureBackPane*)new(TextureBackPane);			((TextureBackPane*)tool)->cPane(GRAYOUT);			break;		case toolPTGrow:		// ABD TEXTURE			tool = (GrowPane*)new(GrowPane);			((GrowPane*)tool)->cPane(GRAYOUT);			break;		case toolTextureList:/* ABD TEXTURE create texture list */			textureList = new(TextureList);			textureList->cPane(GRAYOUT);			textureList->SetController(this);			tool = textureList;			break;		#endif // VPRO		case toolTList:/* create layer list */			if(layerlist)				{				length = layerlist->ALength();				item = (ListItem**)layerlist->Use();				for(i = 0; i < length; i++,item++)					(*item)->dListItem();				layerlist->Unuse();				layerlist->SetLength(0);				}			else				{				layerlist = new(V_Array);				layerlist->cArray(0,sizeof(LayerItem*),4);					}					tool = layerlist;			break;		default:			/* eventually this is a good idea */			/* return(WalkController::cTool(ctrl,toolType));*/			if(tool = ctrl->cTool(ctrl,toolType))				{				toolDefinition = new(ToolDef);				toolDefinition->cToolDef(tool,toolType);					toolChest->Append(&toolDefinition);							}			break;		}		return(tool);	}	V_Window *CAVWalkController::GetWindow(int toolType)	{	V_Window	*aWindow=NULL,*oWindow;	Controller	*ctrl;	Rect		r = { 0 , 0 , 10 , 10 };	Point		p,w;		switch(toolType)		{		case toolCRTLLight:		case toolCRTTumble:		case toolCRTLSurface:// { DAS-VR-SURFACE_EDITOR 9/6/93#if VR		// MERGE-GOURAUD-PRO-5 rearranged this section (moved #if VWT down there)			{			int i,tp;#if MACINTOSH			extern WindowPeek  lastWindow;#endif //MACINTOSH// find the first type that is either a design or a surface editor						for(i=0;i<controllers->ALength();i++)				{				controllers->Get(i,&ctrl);				tp=ctrl->GetType();				if(tp==toolCRTLSurface || tp==toolCRTLDesign)					aWindow=ctrl->GetWindow(tp);				#if VR				// need to use the next guy				if(tp==toolCRTLDesign && aWindow==saveWindow)					aWindow=NULL;				#endif				if(aWindow)					{					if(tp==toolCRTLSurface) // need to clear this out!						{						React(aWindow,CLOSE); // kill this unsightly controller// { DAS-BUGFIX 10/26/93		while(aWindow->panes->ALength())			{			V_Pane *aPane;			aWindow->panes->Get(0,&aPane);			aWindow->UnInstall(aPane);			aPane->dPane();			}//						for(i=0;i<aWindow->panes->ALength();i++)//							{//							V_Pane *pn;//							aWindow->panes->Get(i,&pn);//							pn->dPane();//							}// } DAS-BUGFIX 10/26/93						aWindow->panes->dArray();						aWindow->panes=0;						}					else	// it is the main design window						{						V_Pane *pn;						int i,length;												savePanes=new(V_Array);						savePanes->cArray(0,sizeof(struct V_Pane*),8);						length=aWindow->panes->ALength();						for(i=0;i<length;i++)							{							aWindow->panes->Get(0,&pn);							aWindow->UnInstall(pn);							savePanes->Append(&pn);							}						saveWindow=aWindow;						}					aWindow->lastPane=NULL;#if MACINTOSH					lastWindow=NULL;#endif // MACINTOSH					return aWindow;					}				}// this should never happen, it is the same as above			controllers->Get(0,&ctrl);			oWindow = ctrl->GetWindow(ctrl->GetType());			oWindow->Locate(&r);			r.top+=VTitleBarHeight();			}#elif VPRO   // MERGE-GOURAUD-PRO-5			// MERGE-GOURAUD-PRO-5			// we're trying to get a window of type tooltype -- we want to try to create			// this window over a window of the appropriate type, but for some unknown			// stupid reason, the VWT code calls ctrl->GetType() to get the type of this			// controller, so if we launch a surface editor from a design view or a 			// walk view we get different results.  So we always look for a window of the			// appropriate type			oWindow = GetWindowOfType(toolType);			if (oWindow == NULL) oWindow = GetWindowOfType(toolCRTLDesign);			if (oWindow == NULL) oWindow = GetWindowOfType(toolCRTLSurface);			if (oWindow == NULL) oWindow = GetWindowOfType(toolCRTTumble);			if (oWindow == NULL) oWindow = GetWindowOfType(toolCRTLLight);			oWindow->Locate(&r);			r.top+=VTitleBarHeight();#elif VWT			controllers->Get(0,&ctrl);			oWindow = ctrl->GetWindow(ctrl->GetType());			oWindow->Locate(&r);			r.top+=VTitleBarHeight();#endif //VWT// } DAS-VR-SURFACE_EDITOR 9/6/93			break;		case toolCRTLDesign:		case toolCRTLView:		case toolCRTLLibrary:			r = defaultWindowRect;			break;					case objDepth:			oWindow = cPallette(toolWDepth);			return(oWindow);			break;					// MERGE-GOURAUD-PRO [[[		case objCoord:			oWindow = cPallette(toolWCoord); 	/* ABD */			return(oWindow);			break;				// MERGE-GOURAUD-PRO ]]]		case objTools:			oWindow = cPallette(toolWToolBox);			return(oWindow);			break;					#if VPRO		case objTexturePal:			oWindow = cPallette(toolWTexture); 	/* ABD TEXTURE */			return(oWindow);			break;		#endif // VPRO				default:			return(WalkController::GetWindow(toolType));			break;		}	w.v=430;p.v=100; 	w.h=430;p.h=100;	aWindow = new(V_Window);#if VWT	aWindow->cWindow(&r,title,p,maxPoint,w,DRAGBAR|GROWBOX|ZOOMBOX|GOAWAY,WINDOW_DESTROY);	// ABD MERGE12 WILLIAMS 9/12/93#elif VR//JAM 11-18-93 [[[ altered so walk view can't get too small for buttons	/*	aWindow->cWindow(&r,title,p,maxPoint,w,DRAGBAR|GROWBOX|ZOOMBOX|GOAWAY,WINDOW_HIDE);		// ABD MERGE12 WILLIAMS 9/12/93	if (toolType == toolCRTLDesign)		((WalkDocument*)document)->designWindow = aWindow;	else if (toolType == toolCRTLView)		((WalkDocument*)document)->walkWindow = aWindow;	else if (toolType == toolCRTLLibrary)		((Library*)document)->libWindow = aWindow;    */	if (toolType == toolCRTLDesign)			{			p.v = DESIGNVIEWMINHEIGHT;            p.h = DESIGNVIEWMINWIDTH;			aWindow->cWindow(&r,title,p,maxPoint,w,DRAGBAR|GROWBOX|ZOOMBOX|GOAWAY,WINDOW_HIDE);		// ABD MERGE12 WILLIAMS 9/12/93			((WalkDocument*)document)->designWindow = aWindow;			}	else if (toolType == toolCRTLView)			{			p.v = WALKVIEWMINHEIGHT;            p.h = WALKVIEWMINWIDTH;			aWindow->cWindow(&r,title,p,maxPoint,w,DRAGBAR|GROWBOX|ZOOMBOX|GOAWAY,WINDOW_HIDE);		// ABD MERGE12 WILLIAMS 9/12/93			((WalkDocument*)document)->walkWindow = aWindow;        	}	else if (toolType == toolCRTLLibrary)			{			p.v = LIBWINMINHEIGHT;			p.h = LIBWINMINWIDTH;			aWindow->cWindow(&r,title,p,maxPoint,w,DRAGBAR|GROWBOX|ZOOMBOX|GOAWAY,WINDOW_HIDE);		// ABD MERGE12 WILLIAMS 9/12/93			((Library*)document)->libWindow = aWindow;			}//JAM 11-18-93 ]]] altered so walk view can't get too small for buttons#endif	document->Install(aWindow);	return(aWindow);	}	/*========================================================================= * WalkDrawing	*CAVWalkController::NewDrawing() *-------------------------------------------------------------------------*/WalkDrawing	*CAVWalkController::NewDrawing()	{	WalkDrawing	*newDrawing = new(CAVDrawing);	return(newDrawing);	}				/*========================================================================= * Observer	*CAVWalkController::NewObserver() *-------------------------------------------------------------------------*/Observer	*CAVWalkController::NewObserver()	{	Observer	*newObserver = new(CAVObserver);	return(newObserver);	}void CAVWalkController::ControlMessage(int message,long modifiers,int type)	{	/* DUDE MOVE TO VIEW CONTROLLER 	int frame,atEnd;	switch(message)		{		case bVCR_RECORD: 					observer->Record(TRUE,TRUE);			break;					case bVCR_STOP: 					observer->Record(FALSE,FALSE);			observer->SetFrame(0);			break;					case bVCR_FASTREWIND: 				frame = observer->GetFrame();			frame -= 2;			atEnd = observer->SetFrame(frame);			break;					case bVCR_REWIND: 					frame = observer->GetFrame();			frame--;			atEnd = observer->SetFrame(frame);			break;					case bVCR_PLAY: 				observer->Walk();				break;					case bVCR_FORWARD: 					frame = observer->GetFrame();			frame++;			atEnd = observer->SetFrame(frame);			break;					case bVCR_FASTFORWARD: 				frame = observer->GetFrame();			frame += 2;			atEnd = observer->SetFrame(frame);			break;					case bVCR_PAUSE: 					observer->Record(FALSE,FALSE);			break;		}	*/	}voidCAVWalkController::SetPreference(AppPreference *appPref,int initFlag)	{	WalkController::SetPreference(appPref,initFlag);	}intCAVWalkController::UnitConversion(double factor)	{	Controller	**pCtrl;	AppPreference		*appPref;	DefaultPreference	*defPrefs;	Point3DFFixed	pt3DFFMin,pt3DFFMax,pt;	Point3D bMin,bMax;	FFixed	fFactor;	int i,length,tooBig,tooSmall;		appPref = GetPreference();	defPrefs = (DefaultPreference*)appPref->GetPreference(preferDefaults);	pt3DFFMax = defPrefs->extrusionMax;	pt3DFFMin = defPrefs->extrusionMin;	pcp(root)->ModelSize(&pt3DFFMin,&pt3DFFMax);	bMin.x = FFRound(pt3DFFMin.x);bMin.y = FFRound(pt3DFFMin.y);bMin.z = FFRound(pt3DFFMin.z);	bMax.x = FFRound(pt3DFFMax.x);bMax.y = FFRound(pt3DFFMax.y);bMax.z = FFRound(pt3DFFMax.z);	tooBig = FALSE;	if(VMin > (factor*bMin.x))tooBig = TRUE;	if(VMin > (factor*bMin.y))tooBig = TRUE;	if(VMin > (factor*bMin.z))tooBig = TRUE;	if(VMax < (factor*bMax.x))tooBig = TRUE;	if(VMax < (factor*bMax.y))tooBig = TRUE;	if(VMax < (factor*bMax.z))tooBig = TRUE;	tooSmall = TRUE;	if(-1 > factor*bMin.x)tooSmall = FALSE;	if(-1 > factor*bMin.y)tooSmall = FALSE;	if(-1 > factor*bMin.z)tooSmall = FALSE;	if(1 < factor*bMax.x)tooSmall = FALSE;	if(1 < factor*bMax.y)tooSmall = FALSE;	if(1 < factor*bMax.z)tooSmall = FALSE;	if(!tooBig && !tooSmall)		{		fFactor = DblToFixed(factor);		pt = defPrefs->extrusionMin;		pt.x = FFMult(fFactor,pt.x);		pt.y = FFMult(fFactor,pt.y);		pt.z = FFMult(fFactor,pt.z);		defPrefs->extrusionMin = pt;				pt = defPrefs->extrusionMax;		pt.x = FFMult(fFactor,pt.x);		pt.y = FFMult(fFactor,pt.y);		pt.z = FFMult(fFactor,pt.z);		defPrefs->extrusionMax = pt;				WalkController::UnitConversion(factor);		}		return tooBig || tooSmall;	}#if VR || VPRO	// MERGE-GOURAUD-PRO-4voidCAVWalkController::ShowPlayerCredits()	{	ShowCredits(creditScreen, creditText);	}#endif //VR#if VPRO	// MERGE-GOURAUD-PRO-4voidCAVWalkController::GetCredits()	{//#if MACINTOSH	//need to do for windows  MERGE-PRO-JAM-4	DoTheCreditThing(this);//#endif	}#endif //VPROvoid CAVWalkController::LoadWindowPref(AppPreference *appPref) 	{ 	Controller			**pCtrl;	V_Window			*window;	WindowPreference	*windowPref;	WindowPreference	*newWindowPref;	Rect	r;	Point	scrollPosition;	double	scl;	FFixed	theScale;	int		i,length,theType,ctrlType,change;		windowPref = (WindowPreference*)appPref->GetPreference(preferWindows);	windowPref->ClearRecords();	if(0 == controllers->ALength())		windowPref->BuildDefault();	else		{		window = cPallette(toolWToolBox);		if((fullFlag&&(TOOLS_ON&preFullWindowState)) || window->Visible())			{			window->Locate(&r);			scrollPosition = PtZero;			windowPref->AddRecord(&r,FFOne,scrollPosition,PREF_VIEW_TOOLSET);					}							window = cPallette(toolWDepth);		if((fullFlag&&(DEPTH_ON&preFullWindowState)) || window->Visible())			{			window->Locate(&r);			scrollPosition = PtZero;			windowPref->AddRecord(&r,FFOne,scrollPosition,PREF_VIEW_DEPTH);					}							#if VPRO		// MERGE-GOURAUD-PRO [[[						window = cPallette(toolWCoord); 	/* ABD */		if((fullFlag&&(COORD_ON&preFullWindowState)) || window->Visible())			{			window->Locate(&r);			scrollPosition = PtZero;			windowPref->AddRecord(&r,FFOne,scrollPosition,PREF_VIEW_COORD);					}		// MERGE-GOURAUD-PRO ]]]					window = cPallette(toolWTexture); 	/* ABD TEXTURE */		if((fullFlag&&(TEXTURE_ON&preFullWindowState)) || window->Visible())			{			window->Locate(&r);			scrollPosition = PtZero;			windowPref->AddRecord(&r,FFOne,scrollPosition,PREF_VIEW_TEXTURE);					}		#endif // VPRO					#if WINDOWS		r = document->GetFrameRect();		scrollPosition = PtZero;        windowPref->AddRecord(&r,FFOne,scrollPosition,PREF_VIEW_DOCUMENT);#endif //WINDOWS		length = controllers->ALength();		pCtrl = (Controller **)controllers->Use();		for( i = 0; i < length; i++,pCtrl++)			{			ctrlType = (*pCtrl)->GetType();			theScale = FFOne;			scrollPosition = PtZero;			switch(ctrlType)				{				case toolCRTLDesign:					scl = pcc((*pCtrl))->GetScale();					theScale = DblToFixed(scl);					switch(pcc((*pCtrl))->environment->GetView())						{						case topView:theType = PREF_VIEW_TOP; break;						case bottomView:theType = PREF_VIEW_BOTTOM; break;						case leftView:theType = PREF_VIEW_LEFT; break;						case rightView:theType = PREF_VIEW_RIGHT; break;						case frontView:theType = PREF_VIEW_FRONT; break;						case backView:theType = PREF_VIEW_BACK; break;						}					window = (*pCtrl)->GetWindow(ctrlType);					window->Locate(&r);					windowPref->AddRecord(&r,theScale,scrollPosition,theType);					break;				// MERGE-GOURAUD-PRO-3 [[[				case toolCRTLSurface:					scl = pcc((*pCtrl))->GetScale();					theScale = DblToFixed(scl);					switch(pcc((*pCtrl))->environment->GetView())						{						case insideView:theType = PREF_VIEW_SURF_INSIDE; break;						case outsideView:theType = PREF_VIEW_SURF_OUTSIDE; break;						}					window = (*pCtrl)->GetWindow(ctrlType);					window->Locate(&r);					windowPref->AddRecord(&r,theScale,scrollPosition,theType);					break;								case toolCRTTumble:					scl = pcc((*pCtrl))->GetScale();					theScale = DblToFixed(scl);					theType = PREF_VIEW_TUMBLE; 					window = (*pCtrl)->GetWindow(ctrlType);					window->Locate(&r);					windowPref->AddRecord(&r,theScale,scrollPosition,theType);					break;				case toolCRTLLight:					//JAM 24OCT94 we are coercing to cadcontrol,					//and this isn't, so there is no scale:  Bad.					//as a fix, we just set it to a reasonable value.//					scl = pcc((*pCtrl))->GetScale();					scl = 0.5;					theScale = DblToFixed(scl);					theType = PREF_VIEW_LIGHT; 					window = (*pCtrl)->GetWindow(ctrlType);					window->Locate(&r);					windowPref->AddRecord(&r,theScale,scrollPosition,theType);					break;				// MERGE-GOURAUD-PRO-3 ]]]									case toolCRTLView:				case toolCRTLLibrary:					theType = PREF_VIEW_WALK; 					if(fullFlag)						r = preFullScreenRect;					else						{						window = (*pCtrl)->GetWindow(ctrlType);						window->Locate(&r);						}					windowPref->AddRecord(&r,theScale,scrollPosition,theType);					break;									default:					theType = -1; 					break;				}			}		controllers->Unuse();		}	}voidCAVWalkController::Activate(int state) 	{	Controller			**pCtrl,*aCtrl;	WindowPreference	*windowPref;	WindowPreRec		*pCtrlRecs;	LaunchInit			launchInit;	V_Window			*window;	int					i,length;	int no_normal_views;	switch(state)		{		case msgInit:			windowPref = (WindowPreference*)appPreferences->GetPreference(preferWindows);						launchInit.data.polyhedron = root;			length = windowPref->windows->ALength()-1;			for( i = 0; i <= length; i++)				{				windowPref->windows->Get(i,&pCtrlRecs);				if(pCtrlRecs->type == PREF_VIEW_DOCUMENT)                	{					document->SetFrameRect(pCtrlRecs->where);					break;					}				}			no_normal_views = TRUE;            for ( i = 0 ; i < length ; i++ )            {            	if ((pCtrlRecs->type != PREF_VIEW_SURF_INSIDE) &&					(pCtrlRecs->type != PREF_VIEW_SURF_OUTSIDE) &&					(pCtrlRecs->type != PREF_VIEW_TUMBLE) &&					(pCtrlRecs->type != PREF_VIEW_LIGHT))					{					no_normal_views = FALSE;					break;					}            }                           if (no_normal_views)            {				launchInit.location = pCtrlRecs->where;				launchInit.scrollPosition = pCtrlRecs->scrollPosition;				launchInit.scale = pCtrlRecs->scale;				LaunchController(launchInit,topView);        	}            // ABD 23JAN95 ]]]			for( i = length; i >= 0; i--)				{				windowPref->windows->Get(i,&pCtrlRecs);				launchInit.location = pCtrlRecs->where;				launchInit.scrollPosition = pCtrlRecs->scrollPosition;				launchInit.scale = pCtrlRecs->scale;				switch(pCtrlRecs->type)					{					case PREF_VIEW_TOP: 	LaunchController(launchInit,topView); break;					case PREF_VIEW_BOTTOM:  LaunchController(launchInit,bottomView); break;					case PREF_VIEW_LEFT:  	LaunchController(launchInit,leftView); break;					case PREF_VIEW_RIGHT: 	LaunchController(launchInit,rightView); break;					case PREF_VIEW_FRONT: 	LaunchController(launchInit,frontView); break;					case PREF_VIEW_BACK:  	LaunchController(launchInit,backView); break;					case PREF_VIEW_WALK:  	LaunchController(launchInit,toolCRTLView); break;					case PREF_VIEW_TOOLSET:  	LaunchController(launchInit,toolWToolBox); break;					case PREF_VIEW_DEPTH:  		LaunchController(launchInit,toolWDepth); break;					#if VPRO					// MERGE-GOURAUD-PRO					case PREF_VIEW_COORD:  		LaunchController(launchInit,toolWCoord); break; 	/* ABD */					case PREF_VIEW_TEXTURE:  		LaunchController(launchInit,toolWTexture); break; 	/* ABD TEXTURE */					#endif // VPRO					case PREF_VIEW_SURF_INSIDE:					case PREF_VIEW_SURF_OUTSIDE:					case PREF_VIEW_TUMBLE: 					case PREF_VIEW_LIGHT:                           break;	#if 0 // ABD JAN95					case PREF_VIEW_SURF_INSIDE:  LaunchController(launchInit,topView); break; 	/* MERGE-GOURAUD-PRO-3 */					case PREF_VIEW_SURF_OUTSIDE:  LaunchController(launchInit,topView); break; 	/* MERGE-GOURAUD-PRO-3 */					case PREF_VIEW_TUMBLE:  	LaunchController(launchInit,topView); break; 	/* MERGE-GOURAUD-PRO-3 */					case PREF_VIEW_LIGHT:  		LaunchController(launchInit,topView); break; 	/* MERGE-GOURAUD-PRO-3 */	#endif	#if 0					case PREF_VIEW_SURF_INSIDE:  LaunchController(launchInit,insideView); break; 	/* MERGE-GOURAUD-PRO-3 */					case PREF_VIEW_SURF_OUTSIDE:  LaunchController(launchInit,outsideView); break; 	/* MERGE-GOURAUD-PRO-3 */					case PREF_VIEW_TUMBLE:  	LaunchController(launchInit,toolCRTTumble); break; 	/* MERGE-GOURAUD-PRO-3 */					case PREF_VIEW_LIGHT:  		LaunchController(launchInit,toolCRTLLight); break; 	/* MERGE-GOURAUD-PRO-3 */	#endif					}				}			break;				case msgReset:			while(controllers->ALength())				{				controllers->Get(0,&aCtrl);				window =aCtrl->GetWindow(aCtrl->GetType());				if(window)window->dWindow();				}			break;		}	}V_Offscreen *CAVWalkController::FullScreen(Controller *ctrl,int flag) 	{	V_Offscreen *offScreen;	int		newWindowState;		fullFlag = flag;	if(!fullFlag)		{		newWindowState = preFullWindowState;		ShowPallette(toolWToolBox,(TOOLS_ON&preFullWindowState) ? SHOW : HIDE);		ShowPallette(toolWDepth,(DEPTH_ON&preFullWindowState) ? SHOW : HIDE);				#if VPRO		// MERGE-GOURAUD-PRO		ShowPallette(toolWCoord,(COORD_ON&preFullWindowState) ? SHOW : HIDE); 	/* ABD */		ShowPallette(toolWTexture,(TEXTURE_ON&preFullWindowState) ? SHOW : HIDE); 	/* ABD TEXTURE */		#endif // VPRO			#if VR_ELVIS		{   // ELVIS    		Rect screen;      // no full screen in vr        GetScreen(&screen);		VWIInit(&screen);		}	#endif //VR		}	else		{		preFullWindowState = GetWindowState(); 		ShowPallette(toolWToolBox,HIDE);		ShowPallette(toolWDepth,HIDE);				#if VPRO		ShowPallette(toolWCoord,HIDE); 	/* ABD MERGE-GOURAUD-PRO */		ShowPallette(toolWTexture,HIDE); 	/* ABD TEXTURE */		#endif // VPRO			#if VR_ELVIS		VWIEnd();  // no full screen in VR	#endif //VR		}		offScreen = WalkController::FullScreen(ctrl,flag);		return(offScreen);	}int CAVWalkController::ExportContents(V_Buffer *buffer,int flag)	{	Controller *pCtrl;	int err = 0;	switch(flag)		{		case formatPICS:		case formatQuickTime:		case formatFLIC:		case formatAVI:			pCtrl = FindController(toolCRTLView);			if(pCtrl) err = pCtrl->ExportContents(buffer,flag);			else err = -1;			break;		default:			pCtrl = GetFrontController();			err = pCtrl->ExportContents(buffer,flag);			break;		}	return err;	}	// { DAS-VR-SURFEDIT 9/7/93'#include "AppMssgs.h"#include "VMain.h"void CAVWalkController::RestoreDesign(V_Window *aWindow){int i,tp,length;V_Pane *pn;Controller	*ctrl;#if VR // jca 17JAN94if(aWindow==0 && saveWindow) // force the window to be this	aWindow=saveWindow;if(savePanes && saveWindow==aWindow) // this should definately be true!	{	React(aWindow,CLOSE); // clear out this controller	length=aWindow->panes->ALength();	for(i=0;i<length;i++) // kill all of the panes		{		aWindow->panes->Get(0,&pn);		aWindow->UnInstall(pn);		pn->dPane();		}	// restore the window pointer to the pane	length=savePanes->ALength();	for(i=0;i<length;i++)		{		savePanes->Get(i,&pn);		aWindow->Install(pn);		}	savePanes->dArray();	savePanes=0;	saveWindow=0;#if MACINTOSH	aWindow->DrawPanes();	// DAS-VR-SURFEDIT 9/9/93 draw it NOW#endif //MACINTOSH - ELVIS!!!!!  ^^^^^^	aWindow->lastPane=NULL;	for(i=0;i<controllers->ALength();i++)		{		controllers->Get(i,&ctrl);		tp=ctrl->GetType();		if(aWindow==ctrl->GetWindow(tp))ctrl->SetTitle(NULL);		}	if(aWindow->Active())aWindow->Activate();// happens automatically if we switch to design	VSendMessage(MSG_SETARROW); // set back to arrow tool	}#endif // VR}// } DAS-VR-SURFEDIT 9/7/93