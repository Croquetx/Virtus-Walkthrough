/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	 *				David W. Easter *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "WlkCntrl.h"#include "CVDraw.h"#include "CVPolyh.h"#include "CVLItem.h"#include "Light.h"#include "Observer.h"#include "VMDL.h"#include "DXFOUT.h"#include "WalkBuff.h"#include "AppText.h"#include "AppDeflt.h"#include "AppFiles.h"#include "VFile.h"#include "VDialog.h"#include "TextSrvr.h"		// ABD MERGE-TEXTURE 9/13/93#include "TextArry.h"	// MERGE16#include <stddef.h>#include <string.h>#include <stdio.h>intWalkController::IO(V_Buffer *buf)	{	int err = -1;	long id;			if (buf->IODirection() == DATA_IN)		{		switch(id = buf->OpenChunkR())			{			case IFF_FORM:				Request(NULL,msgDestroy,objIO,0);				if ((err = IO_FORM(buf)) != 0)					{					// jca 26APR94 if we cancel, we must reset the observer's					// viewPoly.  The current viewPoly will probably be invalid,					// since we've been adding and deleting things from the root.					if (observer)	observer->ResetViewPoly();					Request(NULL,msgInit,objDefaults,0);                    }				else					Request(NULL,msgInit,objIO,0);				break;			}		if (id != 0) buf->CloseChunk();		}	else		{		buf->OpenChunkW(IFF_FORM);		err = IO_FORM(buf);		buf->CloseChunk();		}	return(err);	}	// ABD MERGE-TEXTURE 9/13/93 [[[intWalkController::IO_TEXTURELIB(V_Buffer *buf)	{	V_File	*file;	int err;	extern struct TextureServer *gTextureServer;		// ABD TEXTURE // REMOVE jca 19JAN94 	extern TextureArray *gAllTextures;	// MERGE16		err = 0;		if (buf->GetBufferType() == V_FILETYPE)	{		file = (V_File*)buf;		if(file->Stationery())			SetTitle(TXT_UNTITLED);	// PRO-JAP	}// REMOVE jca 19JAN94	gTextureServer->BeginTextureIO(buf, gAllTextures);		// ABD TEXTURE 	// MERGE16	gTextureServer->BeginTextureIO(buf, docTextures);		// ABD TEXTURE 	// MERGE16	gTextureServer->IOTextureLibrary(buf);	gTextureServer->EndTextureIO(buf);		return(err);	}// ABD MERGE-TEXTURE 9/13/93 ]]]intWalkController::IO_FORM(V_Buffer *buf)	{	V_File	*file;	Polyhedron	**ppoly;	V_Array	*contents;	long id;	int err,oldIOPrefFlag;	extern struct TextureServer *gTextureServer;		// ABD MERGE-TEXTURE 9/13/93// REMOVE jca 19JAN94	extern TextureArray *gAllTextures;				// MERGE16#if VPRO	//JAM 14JULY94 added to handle embed/notembed textures [[[	AppPreference *appPref;	TranslatorPreference	*transPref;	//JAM 14JULY94 added to handle embed/notembed textures ]]]#endif	err = 0;	oldIOPrefFlag = TRUE;	file = (V_File*)buf;#if VPRO	//JAM 14JULY94 added to handle embed/notembed textures [[[	appPref = GetPreference();	transPref = (TranslatorPreference*)appPref->GetPreference(preferTranslator);	gTextureServer->SetEmbedTextures(transPref->EmbedTexturesFlag);	//JAM 14JULY94 added to handle embed/notembed textures ]]]	if (file->cryptOn)                           // PRO-22		gTextureServer->SetEmbedTextures(TRUE);  // PRO-22#endifif(file->Stationery())	SetTitle(TXT_UNTITLED);	// PRO-JAP// REMOVE jca 19JAN94	gTextureServer->BeginTextureIO(buf, gAllTextures);		// MERGE16 docTextures ABD MERGE-TEXTURE 9/13/93	gTextureServer->BeginTextureIO(buf, docTextures);		// MERGE16 docTextures ABD MERGE-TEXTURE 9/13/93	if (buf->IODirection() == DATA_IN)		{		err = buf->IOType(&id, IO_LONG);		if (!err && id == IFF_VMDL)			{			buf->SetRefCon(0);			while (!err)				{				id = buf->OpenChunkR();				if (id == 0) break;				switch(id)					{					case IFF_VERS:						err = IO_VERS(buf);						if (!err && (buf->GetRefCon() < 0x01000000L ||							buf->GetRefCon() >= 0x02000000L))							err = 1;						break;					case IFF_PPRF: appPreferences->IO(buf); oldIOPrefFlag = FALSE; break;					case IFF_CPRF: if(oldIOPrefFlag)appPreferences->OLD_IO(buf); break;					case IFF_TXTB: err = gTextureServer->IOTextureTable(buf, 0); break; /* ABD MERGE-TEXTURE 9/13/93 purge textures ignored on input */					case IFF_VPRF: observer->IO(buf); break;/* MJU */					case IFF_ROOT: err = drawing->polyhedron->IORoot(buf); break;					default: err = IO_ReadExtra(buf, id); break;					}					buf->CloseChunk();				}			}		}	else		{		id = IFF_VMDL;		buf->IOType(&id, IO_LONG);			buf->OpenChunkW(IFF_VERS);		IO_VERS(buf);		buf->CloseChunk();				IO_WriteFirst(buf);				LoadWindowPref(appPreferences); 		buf->OpenChunkW(IFF_PPRF);		appPreferences->IO(buf);		buf->CloseChunk();		buf->OpenChunkW(IFF_CPRF);		appPreferences->OLD_IO(buf);		buf->CloseChunk();		buf->OpenChunkW(IFF_VPRF);		observer->IO(buf);		buf->CloseChunk();				IO_WriteLast(buf);				buf->OpenChunkW(IFF_ROOT);		err = drawing->polyhedron->IORoot(buf);		// jca 8 aug 93		buf->CloseChunk();		// ABD MERGE-TEXTURE 9/13/93 [[[		// ABD TEXTURE 		// Write out all the texture refs.  This must be done after the model		// has been written out, so that all the textures that are used 		// have been given id's. 		 		buf->OpenChunkW(IFF_TXTB);	// texture table chunk		err = err?err:gTextureServer->IOTextureTable(buf, FALSE);	// don't purge textures		// jca 25 Oct 93.  Let's not overwrite the error, shall we?		buf->CloseChunk();// ABD MERGE-TEXTURE 9/13/93 ]]]		}			// ABD MERGE-TEXTURE 9/13/93	// tell texture server we are done with io, do any cleanup necessary	gTextureServer->EndTextureIO(buf);#if VPRO	//JAM 14JULY94 added to handle embed/notembed textures [[[	appPref = GetPreference();	transPref = (TranslatorPreference*)appPref->GetPreference(preferTranslator);	gTextureServer->SetEmbedTextures(transPref->EmbedTexturesFlag);	//JAM 14JULY94 added to handle embed/notembed textures ]]]#endif	return(err);	}intWalkController::IO_ReadExtra(V_Buffer *buf,long chunkID)	{	int err;	err = 0;	return err;	}intWalkController::IO_WriteFirst(V_Buffer *buf)	{	int err;	err = 0;	return err;	}	intWalkController::IO_WriteLast(V_Buffer *buf)	{	int err;	err = 0;	return err;	}