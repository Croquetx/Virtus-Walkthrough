/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  David A. Smith *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "LitCntrl.h"#include "Layout.h"#include "CVWCntrl.h"#include "Button.h"#include "LitSItem.h"#include "LitSrce.h"#include "LitPane.h"#include "Polyhdrn.h"#include "PolyDefs.h"#include "Light.h"#include "LitMajor.h"#include "AppText.h"#include "ToolDef.h"#include "ClrPane.h"#include "VWindow.h"#include "VGraphic.h"#include "VGUtil.h"#include "VTextDef.h"#include <string.h>void LightController::cController(V_Document *doc)	{			Controller::cController(doc);		lightPane = new(LightPane);	lightPane->cPane(FALSE);	lightPane->SetController(this);	lightObject = (ObjectLight*)controller->cTool(this,toolPLight);		/* create the polyhedron tool box console 	*/	ambient = (ColorSelect*)controller->cTool(this,toolPColor);		/* create the polyhedron tool box buttons 	*/		source = (LightSource*)controller->cTool(this,toolPSource);			/* create the color selection pane		  	*/	environmentConsole = (V_Console*)controller->cTool(this,toolCCad);	/* create the zoom console				  	*/	pin = (PinButton*)controller->cTool(this,toolBPin);			/* create the zoom buttons				  	*/	SetSelection(-1);	}	void LightController::dController()	{	if(changed&&WarningMessage(TXTC_LITAPPLY,TXTC_CANCEL,TXTC_APPLY,DEFAULT_BUTTON_TWO|POSITIVE_BUTTON_TWO))		Request(NULL,msgEdit,objView,0);	Controller::dController();	}	void *LightController::cTool(Controller *ctrl,int toolType)	{	void	*tool = NULL;		switch(toolType)		{		case toolBPin:			pin = new(PinButton);			pin->cButtonSet();			tool = pin;			break;		case toolPLight:/* create light object pane */			lightObject = new(ObjectLight);			lightObject->cPane(FALSE);			tool = lightObject;			break;		case toolCCad:/* create environment button console */			environmentConsole = new(V_Console);			environmentConsole->cPane(FALSE);			environmentConsole->SetPosition(NULL,bottomLeftConsole);			tool = environmentConsole;			break;		case toolPColor:/* create pop color tool */			ambient = new(ColorSelect);			ambient->cPane(FALSE);			tool = ambient;			break;					case toolPSource:/* create layer list */			source = new(LightSource);			source->cPane(FALSE);			tool = source;			break;		default:			break;		}		return(tool);	}voidLightController::Activate(int install)	{		char str[256];	V_Window *window;window = NULL;	if((msgDeactivate != install) && (msgDummy2 != install))		{			lightPane->SetController(this);		lightObject->SetController(this);		ambient->SetController(this);		source->SetController(this);		pin->SetController(this);				#if VPRO		// ABD TEXTURE set the texture palette controller to this, so no texture		// updates occur (our controller ignores objTexture updates).		pwc(controller)->SetPaletteController(toolWTexture, this);		pwc(controller)->ActivatePalette(toolWTexture, FALSE);		controller->SetPaletteController(toolWCoord, this);		// MERGE-GOURAUD-PRO		controller->ActivatePalette(toolWCoord, TRUE);				// MERGE-GOURAUD-PRO		#endif // VPRO		}			switch(install)		{		case msgCreate:			window = GetWindow(toolCRTLLight);			window->Install(lightPane);			Request(NULL,msgInit,objPolyhedron,0);						strcpy(str,TXTT_LITEDITOR);				SetTitle(str);			window->Show();			SetChange(FALSE);			break;				case msgReset:			controller->cTool(this,toolFlush);									window = GetWindow(objTools);			environmentConsole->SetButton(pin);			window->Install(environmentConsole);			window->Install(lightObject);			window->Install(ambient);			window->Install(source);			break;		}	}#if VPROstruct TextureItem * LightController::GetTexture()	{		return(NULL);	}#endif // VPROV_Window *LightController::GetWindow(int type)	{	V_Window	*window;	switch(type)		{		case objTools: window = controller->GetWindow(type); break;		case toolCRTLLight:			if(!(lightPane->theWindow))				window = controller->GetWindow(toolCRTLLight);			else				window = lightPane->theWindow; 			break;		}			return(window);	}void LightController::SetPolyhedron(Polyhedron *poly)	{	polyhedron=poly;	}void LightController::GetPlace(Rect *r,int warning,int who)	{	Rect	tr;		switch(who)		{		case toolPLight:			r->bottom = r->top+SUBJECT_HEIGHT;			break;				case toolPColor:			lightObject->GetRect(&tr);			r->top = tr.bottom; 			r->bottom = COLOR_HEIGHT+r->top;			break;								case toolLList:			ambient->GetRect(&tr);			r->top = tr.bottom;			r->right = tr.right;			r->left = tr.left;			environmentConsole->GetRect(&tr);			r->bottom = tr.top;			break;		}	}			voidLightController::Request(void *val,int action,int who,int scope)	{	LightModel *copy;	Light *light;	SourceItem *item;	switch(action)		{		case msgEdit:			switch(who)				{				case objPin:					lightPane->SetPin(pin->GetPin());					break;									case objColor:					lightObject->SetSelect(TRUE);                    source->SetSelection(-1);					lightPane->polyhedron->SetColor(ambient->GetColor(), OPAQUE_NOM, SURF_SHARED);					lightPane->InstallLight(NULL);					break;								default:					copy = new(LightModel);					copy->cLightModel();					source->GetLightModel()->Copy(copy);					polyhedron->SetLightModel(copy);					polyhedron->CalcShade();					SetChange(TRUE);					controller->Request(NULL,action,who,0);					break;				}					break;					case msgInit:/*the main window is going away, we need to get ready for the next*/			if(polyhedron)				{				/* there will be a COPY of the polyhedron light source in both the				 * LightSource pane and in the LightPane cube polyhedron.  When I 				 * install the new lights into the cube, it will destroy the old				 * set of light sources which are already there.  This means that				 * if we are being reinstalled, the lights in the source pane				 * are quite invalid.  All we need to do is zero the handle out				 * so that when we reset the lights it reacts appropriately.				 *///				 if(val==lightPane)				 	{				 	selection=-1;				 	lightPane->polyinit=FALSE;				 	lightPane->InstallLight(NULL);				 	}				lightPane->SetPolyhedron(polyhedron);				source->lights=0;				source->SetLightModel(lightPane->polyhedron->GetLightModel(),this);				if(selection==-1)lightObject->SetSelect(TRUE);				else source->SetSelection(selection);				lightPane->polyhedron->CalcShade();				ambient->SetColor(lightPane->polyhedron->GetColor(SURF_SHARED));				if(source->theWindow)source->VDisplay(DRAW);				if(lightObject->theWindow)lightObject->VDisplay(DRAW);				lightPane->VDisplay(DRAW);				}			break;					case msgUpdate:/*copy the lights over to the poly and then recalc*/			copy = new(LightModel);			copy->cLightModel();			source->GetLightModel()->Copy(copy);			polyhedron->SetLightModel(copy);			polyhedron->CalcShade();			controller->Request(NULL,action,who,0);			break;					case msgCreate:/*add a new light source*/			if(objLight == who)				{				source->AddItem();				source->SendLight();				SetChange(TRUE);				}			break;					case msgDestroy:/*remove selected light source*/			if(objLight == who)				{				source->RemoveItem();				source->Reset();				/* lightObject->SendLight();*/				SetChange(TRUE);				}			break;					case msgDraw:/*change the color of the current selected light source*/			lightObject->SetSelect((-1==who)?TRUE:FALSE);			if(-1==who)source->SetSelection(-1);			source->VDisplay(DRAW);			item = (SourceItem*)source->GetCurrentItem();            light = (item)?item->light:NULL;			lightPane->InstallLight(light);			break;		}	}voidLightController::Response(void *val,int action,int who,int scope)	{	}voidLightController::SetSelection(int sel)	{	selection = sel;//	lightObject->SetSelect((0>selection) ? TRUE : FALSE);	}	intLightController::CheckPolyhedron(void *obj)	{	return(obj == polyhedron);	}voidLightController::SetPin(int pin)	{	lightPane->SetPin(pin);	}int LightController::GetChange(void) { return(changed); }void LightController::SetChange(int newChange) { changed = newChange; }