/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "DesDraft.h"#include "BallHelp.h"#include "Position.h"#include "CVObj.h"#include "PolyDefs.h"#include "DesCntrl.h"#include "CVPolyh.h"#include "CVSrfFet.h"#include "CVSrfDef.h"#include "CVDefs.h"#include "CVDraw.h"#include "CVObserv.h"#include "CVEnvirn.h"#include "Geometry.h"#include "LibDefs.h"#include "CVLItem.h"#include "CVWCntrl.h"#include "VMDL.h"#include "AppMssgs.h"#include "AppDeflt.h"#include "AppText.h"#include "ToolDef.h"#include "CadPosn.h"#include "PolyDefs.h"#include "Informtn.h"#include "VMath.h"#include "Misc.h"#include "UndoBuf.h"#include "PolyUndo.h"#include "Unit.h"#include "VSound.h"#include "VGraphic.h"#include "VGUtil.h"#include "VButton.h"#include "VDialog.h"#include "VError.h"				// jca 20 Oct 93#if VPRO#include "TEXTLIST.h"		// ABD TEXTURE#endif // VPRO#include "TextSrvr.h"			// ABD WILLIAMS MERGE-TEXTURE 9/13/93#include "TextItem.h"			// ABD WILLIAMS MERGE-TEXTURE 9/13/93#include "TextArry.h"			// MERGE16#if VR			// ABD MERGE8 WILLIAMS 9/5/93 [[[#include "VRLBLIST.H"			// ABD MERGE8 WILLIAMS 9/5/93#include "LBVCNTRL.H"			// ABD MERGE8 WILLIAMS 9/5/93#endif // VR	// ABD MERGE8 WILLIAMS 9/5/93 ]]]#if DLLMOVESOBSERVER#include "worldDLL.h"#endif DLLMOVESOBSERVER#include <math.h>#include <stdio.h>#include <string.h>extern	struct V_Buffer *clipBuf;/* in WalkThrough.c */extern	PointFFixed BuildScale(Point p1,Point p2,Point anch,int constrain);void DesignDraft::SetController(Controller *ctrl) 	{	Information *info;		CadDraft::SetController(ctrl);	info = ctrl->information;		polyhedron = info->polyhedron;	tracePolyhedron = info->tracePolyhedron;	polyhedron->AddCAVCtrl(environment);	tracePolyhedron->AddCAVCtrl(environment);	selectedList = info->selectList;	observer = ((CAVObserver*)info->observer);/* dude */	currentPeer = polyhedron;#if VWT	menu->SetController(controller);#endif //VWT	}	void DesignDraft::cPane(int flag) 	{					V_MenuMgr	*mgr;	CadDraft::cPane(flag);	observerSelect = FALSE;	home = Pt3DFFZero;		#if VWT	mgr = GetMenuMgr();	menu = new(MenuDesign);	menu->ctheMenu();	mgr->Append(menu);	#endif //VWT	#if VRML_ANCHOR		// ABD PRO25 AUG95	lastVRMLPoly = NULL;	#endif 	}void DesignDraft::dPane() 	{#if VWT	menu->dMenu();#endif //VWT	polyhedron->RemoveCAVCtrl(environment);	tracePolyhedron->RemoveCAVCtrl(environment);	CadDraft::dPane();	}	void DesignDraft::GetVirtual(Rect *r) 	{		Point3DFFixed	bMin,bMax;	Point3D	tmin,tmax;		ppc(controller)->GetWorldSize(&bMin,&bMax);	tmin = FFixed2Point3D(environment->Translate3DFFixed(TO_CAD,bMin));	tmax = FFixed2Point3D(environment->Translate3DFFixed(TO_CAD,bMax));	r->left = min(tmin.x,tmax.x);	r->top =  max(tmax.y,tmin.y);	r->right = max(tmax.x,tmin.x);	r->bottom = min(tmin.y,tmax.y); 	CadDraft::GetVirtual(r);	}	#if VR// ABD MERGE9 WILLIAMS 9/8/93 [[[void DesignDraft::Drop(Point pt, struct V_Pane *drag){	// reset ffLastPt to specify paste position	ffLastPt = Local2World(pt, SCALE_ABSOLUTE);	lastPositionR = World2Local(ffLastPt,SCALE_ABSOLUTE);	((LibViewController*)(((VRLibraryList*)drag)->controller))->EditBuffer(MSG_COPY, 0);	if (EditBuffer(MSG_PASTE, 0) < noErr)			// jca 20 Oct 93  return error if something bad happens		VPlaySound(beepSound);				// jca 20 Oct 93  at least give a beep}// ABD MERGE9 WILLIAMS 9/8/93 ]]]#endif // VRvoid DesignDraft::CalcSize(Rect *r,Point *p,int type,int warning)	{		AppPreference	*appPreference;	DefaultPreference *defPref;	Point3DFFixed home3D;	PointFFixed home2D,pt;	Point	c;	 	CadDraft::CalcSize(r,p,type,warning);	if(INSTALL == type)		{				appPreference = controller->GetPreference();		defPref = (DefaultPreference*)appPreference->GetPreference(preferDefaults);		home3D = environment->Translate3DFFixed(TO_CAD,defPref->homePosition);		home2D.h = home3D.x;		home2D.v = home3D.y;		// { DAS-BUGFIX 10/17/93 this insures that the inside surface is centered/*		This uses window coordinates! We need PANE coordinates. This will be		wrong even for VWT.		c.h = r->left + ((r->right-r->left)>>1);		c.v = r->top + ((r->bottom-r->top)>>1);*/		c.h=(r->right-r->left)>>1;		c.v=(r->bottom-r->top)>>1;// } DAS-BUGFIX 10/17/93 this insures that the inside surface is centered		pt = Local2World(c,SCALE_ABSOLUTE);		MoveView(home2D,pt);		ffLastPt = home2D;	lastPositionR = World2Local(ffLastPt,SCALE_ABSOLUTE);		}	}void  DesignDraft::DrawContent(int type)	{	CAVPolyhedron	**ppoly;	int			i,length;		switch(type)		{		case PICT_DRAW:				polyhedron->Display(environment);			break;					case PRINT_DRAW:			tracePolyhedron->SetDirty(POLY_MUSSED);			polyhedron->SetDirty(POLY_MUSSED);			tracePolyhedron->Display(environment);			polyhedron->Display(environment);			polyhedron->SetDirty(POLY_MUSSED);			tracePolyhedron->SetDirty(POLY_MUSSED);			break;				default:			tracePolyhedron->Display(environment);			polyhedron->Display(environment);									length = selectedList->ALength();			ppoly = (CAVPolyhedron**)selectedList->Use();			for(i=0; i < length; i++,ppoly++)  				(*ppoly)->Select(environment);			selectedList->Unuse();							observer->Display(environment);			break;		}		CadDraft::DrawContent(type);		}int DesignDraft::GetAction(long action,long modifiers)	{	InputTextDialog	*inputDialog;	AppPreference	*appPreference;	DefaultPreference *defPref;	char		str[256];	PointFFixed 	newView,wrlLast,pt;	Point3DFFixed	viewPoint,oldViewPoint;	Point 			p;	int				newSide,numLevels;	if(editMode) return(FALSE);	switch(action)		{			case  MSG_TOPVIEW: ppc(controller)->ChangeView(topView); break;		case  MSG_BOTTOMVIEW: ppc(controller)->ChangeView(bottomView); break;		case  MSG_FRONTVIEW: ppc(controller)->ChangeView(frontView); break;		case  MSG_BACKVIEW: ppc(controller)->ChangeView(backView); break;		case  MSG_RIGHTVIEW: ppc(controller)->ChangeView(rightView); break;		case  MSG_LEFTVIEW: ppc(controller)->ChangeView(leftView); break;		case  MSG_OPPVIEW:			switch(environment->GetView())				{				case topView: newSide = bottomView; break;				case bottomView: newSide = topView; break;				case frontView: newSide = backView; break;				case backView: newSide = frontView; break;				case leftView: newSide = rightView; break;				case rightView: newSide = leftView; break;				}			ppc(controller)->ChangeView(newSide); break;									break;				case MSG_RESETTILT:			observer->ResetTilt();			controller->Request(NULL, msgEdit, objObserver, 0);			break;		case  MSG_FLIP: 	SetFlip(-1);  break;		case  MSG_SINGLE: 	SetInflate(-1,INFL_SINGLE);  	break;			case  MSG_DOUBLE: 	SetInflate(-1,INFL_BOTH);  		break;			case  MSG_EXTRUDE: 	SetInflate(INFL_EXTRUDE,-1); break;			case  MSG_ELLIPSE: 	SetInflate(INFL_ELLIPSE,-1); break;			case  MSG_CONVERGE: SetInflate(INFL_CONVERGE,-1);break;			case  MSG_LEVELS:   			appPreference = controller->GetPreference();			defPref = (DefaultPreference*)appPreference->GetPreference(preferDefaults);			numLevels = defPref->ellipseLevels;			if(!(OPT_EDIT_MODE&modifiers))				{				sprintf(str,"%i",numLevels);				inputDialog = new(InputTextDialog);				if(!inputDialog->cInputDialog(TXT_LEVELS,TXT_SET_NUM_LEVELS,str,inputNumber))break;		// PRO-JAP				sscanf(str,"%i",&numLevels);				numLevels = min(numLevels,16);				numLevels = max(numLevels,1);				}			SetSides(numLevels,FALSE);			break;					case MSG_OBS2CENTER:			p.h = centerX; p.v = centerY;			viewPoint = environment->Translate3DFFixed(TO_CAD,observer->FFpoint);			newView = Local2World(p,SCALE_ABSOLUTE);			newView.h = FFSub(newView.h,viewPoint.x); 			newView.v = FFSub(newView.v,viewPoint.y);			viewPoint = environment->MakeVector(TO_WORLD,newView);			observer->ObserverTranslation(viewPoint);						controller->Request(NULL,msgEdit,objObserver,0);			break;					case MSG_CENTER2OBS:			viewPoint = environment->Translate3DFFixed(TO_CAD,observer->FFpoint);			newView.h = viewPoint.x;			newView.v = viewPoint.y;			p.h = centerX;p.v = centerY;			pt = Local2World(p,SCALE_ABSOLUTE);			MoveView(pt,newView);			VDisplay(ACT_REBUILD_DRAW);			break;				#if DLLMOVESOBSERVER		case MSG_VIEWDLLSPOT:/* SET THE OBSERVER TO DLL-sent spot*/			{				Point3DFFixed pt;				Angle3DFFixed ang;				observer->GetPosition(&pt, &ang);				DLLGetObserver(&pt, &ang);				observer->SetPosition(pt, ang);				controller->Request(NULL,msgEdit,objObserver,0);			}            break;            #if 0			appPreference = controller->GetPreference();			defPref = (DefaultPreference*)appPreference->GetPreference(preferDefaults);			home = environment->Translate3DFFixed(TO_CAD,defPref->homePosition);            DLLGetObserver(&home);			viewPoint = environment->Translate3DFFixed(TO_CAD,observer->FFpoint);			newView.h = home.x;			newView.v = home.y;			newView.h = FFSub(newView.h,viewPoint.x); 			newView.v = FFSub(newView.v,viewPoint.y);			viewPoint = environment->MakeVector(TO_WORLD,newView);			observer->ObserverTranslation(viewPoint);			{				Point3DFFixed pt;				Angle3DFFixed ang;				observer->GetPosition(&pt, &ang);				pt.x.l += 1;                ang.pitch.l += 1;			}									controller->Request(NULL,msgEdit,objObserver,0);			break;			#endif		case MSG_DONOTHING:/* just a message to force main-event looping*/			break;		#endif //DLLMOVESOBSERVER		case MSG_VIEWHOME:/* BRING THE OBSERVER HOME */			appPreference = controller->GetPreference();			defPref = (DefaultPreference*)appPreference->GetPreference(preferDefaults);			home = environment->Translate3DFFixed(TO_CAD,defPref->homePosition);			viewPoint = environment->Translate3DFFixed(TO_CAD,observer->FFpoint);			newView.h = home.x;			newView.v = home.y;			newView.h = FFSub(newView.h,viewPoint.x); 			newView.v = FFSub(newView.v,viewPoint.y);			viewPoint = environment->MakeVector(TO_WORLD,newView);			observer->ObserverTranslation(viewPoint);						controller->Request(NULL,msgEdit,objObserver,0);			break;		case MSG_EDITORHOME:/* BRING THE EDITOR HOME */			appPreference = controller->GetPreference();			defPref = (DefaultPreference*)appPreference->GetPreference(preferDefaults);			home = environment->Translate3DFFixed(TO_CAD,defPref->homePosition);			newView.h = home.x;			newView.v = home.y;			p.h = centerX;p.v = centerY;			pt = Local2World(p,SCALE_ABSOLUTE);			MoveView(newView,pt);			VDisplay(ACT_REBUILD_DRAW);			break;			case MSG_HOMEVIEW:/* SET HOME TO THE OBSERVER */			appPreference = controller->GetPreference();			defPref = (DefaultPreference*)appPreference->GetPreference(preferDefaults);			defPref->homePosition = observer->FFpoint;			break;					case MSG_HOMEEDITOR:/* SET HOME TO THE EDITOR */			appPreference = controller->GetPreference();			defPref = (DefaultPreference*)appPreference->GetPreference(preferDefaults);			viewPoint = environment->Translate3DFFixed(TO_CAD,defPref->homePosition);			p.h = centerX;p.v = centerY;			pt = Local2World(p,SCALE_ABSOLUTE);			viewPoint.x = pt.h;			viewPoint.y = pt.v;			defPref->homePosition = environment->Translate3DFFixed(TO_WORLD,viewPoint);			break;					default:			return(CadDraft::GetAction(action,modifiers));			break;		}			return(TRUE);	}			// { DAS-VR 8/29/93void DesignDraft::CenterPoly(struct CAVPolyhedron *poly)	{	PointFFixed 	newView,pt;	Point p;	FFixed dp;	Point3D pMin,pMax;		pMin = poly->posnBoundMin;	pMax = poly->posnBoundMax;	pMin.x = pMin.x + (((long)pMax.x-(long)pMin.x)>>1);	pMin.y = pMin.y + (((long)pMax.y-(long)pMin.y)>>1);	pMin.z = pMin.z + (((long)pMax.z-(long)pMin.z)>>1);	newView = PtFFZero;	pMin = environment->Translate3D(TO_CAD,pMin);	newView.h.intg = pMin.x;	newView.v.intg = pMin.y;	p.h = centerX;p.v = centerY; // current center of the display	pt = Local2World(p,SCALE_ABSOLUTE);		MoveView(newView,pt);	VDisplay(ACT_REBUILD_DRAW);	}// } DAS-VR 8/29/93void DesignDraft::MouseDown(Point p,long modifiers)	{		CadDraft::MouseDown(p,modifiers); 		if(bCONNECTOR == editTool)		{					currentPeer = polyhedron;		SelectObject(currentPositionR,modifiers,MOUSE_DOWN); 		if(editList->ALength())			SearchPeers(currentPositionR,modifiers,drawPush);		}	}voidDesignDraft::TrackHelp(Point pt,long modifier)// DAS-VWINDOWS 9/30/93	{	Rect r;		if(modeNone == editMode)		{		r = dataRect;		BalloonHotRect(&r,pt);		if(observer->Find(&pt,environment)) 			Bubble(pt,&r,TXTB_OBSERVER);		else// { DAS-VR-HELP 9/30/93#if VWT			Bubble(pt,&r,TXTB_DESIGNVIEW);#elif VR			switch(editTool)				{				case bARROW:					Bubble(pt,&r,TXTB_DOARROW);					break;				case bSCALE:					Bubble(pt,&r,TXTB_DORESIZE);					break;				case bROTATE:					Bubble(pt,&r,TXTB_DOROTATE);					break;				case bSURFACE_EDITOR:					Bubble(pt,&r,TXTB_DOSELECTSURFACE);					break;#endif#if VPRO			switch(editTool)				{#endif#if ((VR) || (VPRO))				// MERGE-GOURAUD-PRO				case bZOOMIN:		// MERGE-GOURAUD-PRO					if (modifier&V_OPTION)						Bubble(pt,&r,TXTB_DOZOOMOUT);					else						Bubble(pt,&r,TXTB_DOZOOMIN);					break;				case bZOOMOUT:		// MERGE-GOURAUD-PRO					if (modifier&V_OPTION)						Bubble(pt,&r,TXTB_DOZOOMIN);					else						Bubble(pt,&r,TXTB_DOZOOMOUT);					break;#endif // ((VR) || (VPRO))				}// } DAS-VR-HELP 9/30/93		}	}			voidDesignDraft::SearchPeers(Point p,long modifiers,int type)	{		    CAVPolyhedron **pPolys,*cPoly,*oPoly,*nPoly,*tmpPeer,*oldPeer;    PointLong     sp;    int     i,length,surf,isDifferent,theAxis,mode;	     switch(editTool)         {		 case bCONNECTOR:			if (peerList)   // jca 13DEC94 check that the peerList exists				length =  peerList->ALength();			else             	length = 0;             if(length)                 {                 surf = NO_MARK;                 theAxis = environment->GetAxis();                 sp.h = p.h + lOrigin.h ;                 sp.v = p.v + lOrigin.v;                 nPoly = currentPeer;                  /* see if I got the same guy */                 editList->Get(0,&cPoly);                 if(currentPeer && (POLY_SHARED & currentPeer->DepthContained(cPoly,theAxis)))                     {                     if(!currentPeer->GetEditState()                         && NO_MARK != (surf = currentPeer->FindEdge(&sp,environment)))                             currentPeer->cavsurf = surf;                     }                 if(NO_MARK == surf)                     { /* see if I have any peers other than the one before */                     nPoly = polyhedron;                     pPolys = (CAVPolyhedron**)peerList->Use();                     for(i = 0; i < length; i++,pPolys++)                         {                         isDifferent = ((*pPolys) != cPoly && (*pPolys) != currentPeer) ? TRUE : FALSE;                         if(isDifferent)                             {                             if(POLY_SHARED & (*pPolys)->DepthContained(cPoly,theAxis) && !(*pPolys)->GetEditState())                                 {                                 surf = (*pPolys)->FindEdge(&sp,environment);                                 if(NO_MARK != surf)                                     {                                     (*pPolys)->cavsurf = surf;									 nPoly = (*pPolys);                                     break;                                     }                                 }                             }                         }                    peerList->Unuse();                      if(NO_MARK == surf)                         {                         /* see if I have a container */                         oPoly = (CAVPolyhedron*)cPoly->FindContainer();                         isDifferent = (oPoly != polyhedron && oPoly != currentPeer) ? TRUE : FALSE;                         if(isDifferent)                             {                             surf = oPoly->FindEdge(&sp,environment);                             if(NO_MARK != surf)                                 {                                 oPoly->cavsurf = surf;                                 nPoly = oPoly;                                 }                             }                          }                     }                 }                             isDifferent = (nPoly != currentPeer) ? TRUE : FALSE;			if(isDifferent)                {                currentPeer = nPoly;                VPlaySound(clickSound);				}			break;				case bARROW:				if(!currentPeer || V_CONTROL&modifiers) return;						if (peerList)   // jca 13DEC94 check that the peerList exists				length =  peerList->ALength();			else             	length = 0;			if(length)				{								oldPeer = currentPeer;				editList->Get(0,&cPoly);								mode = cPoly->GetMode();								if(IN_POLY != mode && ON_POLY_SIDLINE != mode)					return;			/*	if(modifiers & OPT_EDIT_MODE)					return;*/													sp.h = p.h + lOrigin.h ; sp.v = p.v + lOrigin.v;/*dude */tmpPeer = currentPeer->PointContained(cPoly,environment,sp,editList);				if(currentPeer != tmpPeer)					{ 					if(tmpPeer)currentPeer = tmpPeer; else currentPeer = polyhedron;					while(POLY_ROOT != currentPeer->type)						{						currentPeer = pcp(currentPeer->FindContainer());/*dude */tmpPeer = currentPeer->PointContained(cPoly,environment,sp,editList);						if(OUT_POLY != tmpPeer->GetMode())tmpPeer = NULL;						if(tmpPeer)break;						}					if(tmpPeer)currentPeer = tmpPeer; else currentPeer = polyhedron;					}								switch(type)					{					case drawMove:						if(currentPeer == oldPeer) break;						oldPeer->Hilite(environment,FALSE);										case drawStep:					case drawCancel:						currentPeer->Hilite(environment,TRUE);						break;					}				}			break;		}	}	void DesignDraft::Update() 	{	polyhedron->SetDirty(POLY_MUSSED);	tracePolyhedron->SetDirty(POLY_MUSSED);	CadDraft::Update();	controller->Request(NULL,msgReset,objDepth,0);	}	voidDesignDraft::MoveObserver()	{	if (theWindow)		{		SetPane();		observer->MoveObserver(environment);		UnsetPane();		}	}	void DesignDraft::CreateObject(Point p,long modifiers) 	{	CAVPolyhedron	*foundPoly,*leadPoly;	LayerItem		*layer;	Point3DFFixed	baseVector,pointVector,vector;	Angle3DFFixed	baseAngle,pointAngle;	PointFFixed		wrlAnchorPt,wrlLastPt;	FFixed			wrlAnchorAngle,wrlLastAngle,point,base,tmp,tmp2 = INITFIXXED(2,0);	EditSpecList	*undoItem;	EditSpec		*undoSpec;	int	 			editType,levels,inflateType,opacity,extrude,direction;	char			inflate,defAxis;	PointLong		sp;		if(!pcc(controller)->CreateOK()) 		{		SetBuildPoint(PtFFZero,currentPosition,FALSE);		VDisplay(ACT_REBUILD_DRAW);/* dude ??? */		return;		}		NewSelect(NULL,TRUE);			undoItem = NewUndoItem(UNDO_POLY_FLAG);		layer = pcc(controller)->GetLayer();		leadPoly = new(CAVPolyhedron);	leadPoly->cPolyhedron(polyhedron->drawing);	leadPoly->SetLayer(layer,TRUE);	ppc(controller)->GetInflation(&inflate,&direction);	opacity = ppc(controller)->GetOpacity();	wrlAnchorAngle = ConvertAngle(anchorAngle);	wrlLastAngle = ConvertAngle(lastAngle);		tempFFPoints->Get(0,&wrlAnchorPt);	tempFFPoints->Get(tempFFPoints->ALength()-1,&wrlLastPt);		baseVector = Pt3DFFZero;	baseAngle = Ang3DFFZero;	pointAngle = Ang3DFFZero;		defAxis = GetDefAxis();	switch(editTool)		{		case bPOLY_ROOM:			editType = EDIT_POLYGON;			pointVector = environment->OrientPolyhedron(tempFFPoints,pointVector,FALSE);			break;					case bRECT_ROOM:			editType = EDIT_RECTANGLE;			pointVector = environment->OrientPolyhedron(tempFFPoints,pointVector,FALSE);			break;				case bREGPOLY_ROOM:			pointVector = environment->MakeVector(TO_WORLD,wrlAnchorPt);				pointVector = environment->Translate3DFFixed(TO_CAD,pointVector);			pointVector = environment->OrientPolyhedron(tempFFPoints,pointVector,FALSE);			editType = EDIT_REGPOLYGON;			break;		default:			pointVector = Pt3DFFZero;	// init just in case we fall through -- jca			break;		} 	 	ppc(controller)->GetDepth(&point,&base,defAxis); 		tmp = FFSub(point,base);	tmp2 = FFDiv(tmp,tmp2);	switch(defAxis)		{		case INFL_X: pointVector.x = FFAdd(base,tmp2);;break;		case INFL_Y: pointVector.y = FFAdd(base,tmp2);;break;		case INFL_Z: pointVector.z = FFAdd(base,tmp2);break;		}	undoSpec = undoItem->cEditSpec(_EDIT_MOVE);	undoSpec->SetMark(leadPoly->OutlineMark(environment));	((UPolyMove*)undoSpec)->SetVector(baseVector,pointVector);	undoSpec = undoItem->cEditSpec(_EDIT_ROTATEABS);	undoSpec->SetMark(leadPoly->OutlineMark(environment));	((UPolyRotate*)undoSpec)->SetAngle(baseAngle,pointAngle);	((UPolyRotate*)undoSpec)->SetVector(baseVector,baseVector);	switch(inflate)		{		case INFL_EXTRUDE: 			break;					case INFL_CONVERGE:			if(POLY_BOTH == direction) inflate = INFL_DUALCONVERGE;			break;					case INFL_ELLIPSE:			levels = pcc(controller)->defaultLevels;			if(POLY_BOTH == direction) inflate = INFL_DUALELLIPSE;			break;		}	switch(direction)		{		case POLY_BOTH:  		case POLY_UP: 			point = tmp2;			base = FFNeg(tmp2);			break;		case POLY_DOWN: 			point = FFNeg(tmp2);			base = tmp2;			break;		}		leadPoly->CreateInflate(environment->GetAxis(),inflate,tempFFPoints,point,base);	leadPoly->SetEditType(editType);	if(levels)leadPoly->SetLevels(levels);			undoSpec = undoItem->cEditSpec(_EDIT_COLOR);	undoSpec->SetMark(leadPoly->OutlineMark(environment));	((UPolyColor*)undoSpec)->SetColor(pcc(controller)->GetColor(),opacity,SURF_SHARED);				sp.h = p.h + lOrigin.h; 	sp.v = p.v + lOrigin.v;/*dude */foundPoly = polyhedron->PointContained(leadPoly,environment,sp,editList);	undoSpec = undoItem->cEditSpec(_EDIT_CREATE);	((UPolyCreate*)undoSpec)->SetContainer(foundPoly);	((UPoly*)undoSpec)->SetInherit(FALSE);// ABD WILLIAMS MERGE-TEXTURE 9/13/93 [[[	undoSpec = undoItem->cEditSpec(_EDIT_TEXTURE);	// ABD TEXTURE	((UPolyTexture*)undoSpec)->SetTexture(pcc(controller)->GetTexture(),SURF_SHARED);// ABD WILLIAMS MERGE-TEXTURE 9/13/93 ]]]	// MERGE-GOURAUD [[[	undoSpec = undoItem->cEditSpec(_EDIT_GOURAUD);	((UPolyGouraud*)undoSpec)->SetShadeType(pcc(controller)->GetShadeType(), SURF_SHARED);	// MERGE-GOURAUD ]]]	undoItem->SetEditObject(leadPoly,NULL,UNDO_POLY_FLAG);	undoItem->Edit();	leadPoly->CalcShade();	// MERGE-GOURAUD // HACK there's gotta be a better way... ABD			DisplayObject(drawCancel);/* dude */		if(!(LAYER_NOCREATE&layer->GetFlag()))		{		leadPoly->SetMode(IN_POLY);			/* NOTE 1: this is a shortcut so it draws correctly */		selectedList->Append(&leadPoly);	/* NOTE 1: this is a shortcut so it draws correctly */		}			ppc(controller)->NewPolyhedron(msgCreate,objDraft,leadPoly);	controller->Request(NULL,msgEdit,objVirtRect,0);	controller->Request(NULL,msgEdit,objView,0);	}void DesignDraft::NewPolyhedron(CAVPolyhedron *newPoly) 	{	SetPane();		newPoly->AddCAVCtrl(environment);	observer->Display(environment);	newPoly->Display(environment);	observer->Display(environment);	if(OUT_POLY != newPoly->GetMode())		newPoly->Select(environment);	UnsetPane();	}void DesignDraft::NewSurfFeature(V_Array *featList) 	{	CAVPolyhedron	*poly;	CAVSurfFeature **pFeat;	int	i,length;	int	oldMode;		length = featList->ALength();	pFeat = (CAVSurfFeature**)featList->Use();	poly = pcp((*pFeat)->surfDef->polyhedron);	for(i = 0; i < length; i++,pFeat++)		(*pFeat)->AddCAVCtrl(environment);	featList->Unuse();		if (theWindow != NULL)	// MERGE15 ееее debug test dum !!!	{		SetPane();		oldMode = poly->GetMode();		poly->SetMode(OUT_POLY);		poly->Display(environment);		poly->SetMode(oldMode);		UnsetPane();	}	}				int DesignDraft::InSelectedList(Point p,long modifiers) 	{	CAVPolyhedron	**ppolys,*foundPoly;	RGBColor	color;	PointLong	sp;	PointFFixed worldPt;	Point3DFFixed observerLoc;	Angle3DFFixed observerAngle;	Point		tp;	EditSpecList	*undoItem;	EditSpec		*undoSpec;		int			i,length,place,err;	int			editType,previousSelect,found,allObjects,findMode;	editList->SetLength(0);	tempFFPoints->Get(0,&worldPt);	foundPoly = NULL;		if(observer->Find(&p,environment)) 		{ 		currentPositionR = anchorPositionR = lastPositionR = p; 		lastAngle = angle;		draftAction = editTool;		if(modifiers&OPT_EDIT_MODE)			editTool = ROTATE_EYE;		else			editTool = MOVE_EYE;		controller->ControlMessage(editTool,modifiers,ONSTATE);		editAction = TRUE;		observer->GetPosition(&observerLoc,&observerAngle);		worldPt = environment->MakeOutline(TO_CAD,observerLoc);		tempFFPoints->Put(0,&worldPt);		return(IN_POLY);		}		previousSelect = FALSE;	found = OUT_POLY;	allObjects = FALSE;				sp.h = lOrigin.h + p.h;	sp.v = lOrigin.v + p.v;			length = selectedList->ALength();	ppolys = (CAVPolyhedron**)selectedList->Use();		for(i = 0; i < length; i++,ppolys++) 			{		found = (*ppolys)->FindDetail(&sp,&worldPt,environment);		if(OUT_POLY != found) 			{ 			foundPoly = *ppolys;			previousSelect = TRUE; 			break; 			}		}		selectedList->Unuse();	if(OUT_POLY == found) 		{		if(OPT_EDIT_MODE&modifiers && (bLOCK == editTool))			findMode = FIND_LOCKED;		else			findMode = FIND_NORMAL; 					foundPoly = polyhedron->Find(&sp,environment,polyhedron,findMode);		if(polyhedron == foundPoly) 			{			foundPoly = tracePolyhedron->Find(&sp,environment,tracePolyhedron,findMode);			if(tracePolyhedron == foundPoly) 				foundPoly = NULL;			}				if(err = NewSelect(foundPoly,!(modifiers&MULTIPLE_SELECT)))			{			foundPoly = NULL;			return(POLY_ERROR);			}					if(foundPoly) 			found = foundPoly->GetMode();					}		else		{		if(modifiers&MULTIPLE_SELECT)			{ 			NewSelect(foundPoly,!(modifiers&MULTIPLE_SELECT));  			foundPoly = NULL;			found = OUT_POLY;			}		}	if(OUT_POLY == found) return(OUT_POLY);		editType = foundPoly->GetEditType();	currentPositionR.h = sp.h - lOrigin.h;currentPositionR.v = sp.v - lOrigin.v;lastPositionR = anchorPositionR = currentPositionR;lastAngle = anchorAngle = angle;/* realPt = World2Local(worldPt,SCALE_ABSOLUTE);*//*anchorPosition = lastPosition = currentPosition = anchorPositionR;lastPositionR = currentPositionR = anchorPositionR;lastAngle = anchorAngle = angle;*//* dudeif(OPT_EDIT_MODE&modifiers)	{ VMoveTo(p.h,p.v); VLineTo(p.h,p.v); }	if(V_CONTROL&modifiers)	{ VMoveTo(realPt.h,realPt.v); VLineTo(realPt.h,realPt.v); }	if(V_COMMAND&modifiers)	{ VMoveTo(sp.h - offset.h,sp.v - offset.v); VLineTo(sp.h - offset.h,sp.v - offset.v); }*/				currentPeer = pcp(foundPoly->FindContainer());	if(currentPeer) peerList = currentPeer->contents;	else currentPeer = polyhedron;		switch(editTool)		{		case bCONNECTOR:			if((ON_POLY_DEFLINE != found && ON_POLY_SIDLINE != found)				|| NO_MARK == foundPoly->SurfMark(environment))				found = OUT_POLY;			else				{				foundPoly->SetMode(IN_POLY);				found = IN_POLY;				currentPeer = polyhedron;				}			break;					case bLIGHT_EDITOR:		case bSURFACE_EDITOR:		case bTUMBLE_EDITOR:			if(!previousSelect)found = OUT_POLY;			else found = IN_POLY;			break;						case bPLUS_MINUS:			if(IN_DEF_VIEW != foundPoly->GetEditMode(environment))				found = OUT_POLY; 							switch(found)				{				case ON_POLY_DEFLINE:				case ON_POLY_POINT:					break;									case ON_POLY_SIDLINE:				case IN_POLY:					foundPoly->FindDetail(&sp,&worldPt,environment);					if(ON_POLY_DEFLINE == foundPoly->GetMode())						found = IN_POLY; 					else 						found = OUT_POLY; 					break;				}			break;				case bSCALE_ROOM:			allObjects = TRUE;			found = IN_POLY;			break;					case bDROPPER:		case bLOCK:		case bHIDE:			found = IN_POLY;			break;				  		case bSKEW_TOOL:			switch(found)				{				case ON_POLY_DEFLINE: 					break;				case ON_POLY_POINT:						case IN_POLY:					if(IN_DEF_VIEW != foundPoly->GetEditMode(environment))						found = OUT_POLY; 					break;				default:					found = OUT_POLY; 					break;				}			break;					case bARROW:				if((ON_POLY_SIDLINE == found) || (IN_POLY == found))				allObjects = TRUE;			break;		}		if( OUT_POLY != found)		{		if(allObjects)selectedList->CopyArray(editList);		else editList->Append(&foundPoly);		tempFFPoints->Put(0,&worldPt);		}		return(found);	}void DesignDraft::SelectAll(int state) 	{	CAVPolyhedron **ppoly;	int	i,length;	if(TRUE == state)		{		if(polyhedron->contents)				{			NewSelect(NULL,TRUE);								length = polyhedron->contents->ALength();			ppoly = (CAVPolyhedron**)polyhedron->contents->Use();			for(i = 0; i < length; i++,ppoly++)				{				if( !(*ppoly)->GetEditState() )					NewSelect(*ppoly,FALSE);				}			polyhedron->contents->Unuse();			}					if(tracePolyhedron->contents)				{			length = tracePolyhedron->contents->ALength();			ppoly = (CAVPolyhedron**)tracePolyhedron->contents->Use();			for(i = 0; i < length; i++,ppoly++)				{				if( !(*ppoly)->GetEditState() )					NewSelect(*ppoly,FALSE);				}			tracePolyhedron->contents->Unuse();			}		}	else		NewSelect(NULL,TRUE);	}void DesignDraft::SelectRect(Rect *r,long modifiers) 	{	V_Array		*tmpList;	CAVPolyhedron **pPoly;	Polyhedron *container = NULL;	int	i,length,walk,findMode;	EditSpecList	*undoItem;	EditSpec		*undoSpec;			walk = FALSE;		MakeWorldRect(r,r->top,r->left,r->bottom,r->right);	if( bLOCK == editTool && (OPT_EDIT_MODE&modifiers)) findMode =  FIND_LOCKED;	else findMode = FIND_NORMAL; 	tmpList = new(V_Array);	tmpList->cArray(0,sizeof(CAVPolyhedron*),4);	container = NULL;	polyhedron->SelectRect(&tmpList,r,&container,environment,findMode);	tracePolyhedron->SelectRect(&tmpList,r,&container,environment,findMode);	NewSelect(NULL,TRUE);	length = tmpList->ALength();	switch(editTool)		{		case bLOCK:		case bHIDE:			editList->SetLength(0);			tmpList->CopyArray(editList);			UpdateObject(modifiers);			break;					case bARROW:			pPoly = (CAVPolyhedron**)tmpList->Use();			for(i = 0; i < length; i++,pPoly++)				NewSelect(*pPoly,FALSE);			tmpList->Unuse();				break;		}		tmpList->dArray();	}	int DesignDraft::DoTranslate(long modifiers) 	{	CAVPolyhedron	**pPoly;	Point			tp,pp;	int				i,length,okay;		length = editList->ALength();	pPoly = (CAVPolyhedron**)editList->Use();		switch(editTool)		{		case bROTATE_ROOM:				VMoveTo(anchorPosition.h,anchorPosition.v);			VLineTo(lastPosition.h,lastPosition.v);			for(i = 0; i < length; i++,pPoly++)				(*pPoly)->RotatePolyhedron(anchorPosition,lastAngle,environment); 			okay = TRUE;			break;					case bPLUS_MINUS:			for(i = 0; i < length; i++,pPoly++)				okay = (*pPoly)->BreakLine(lastPosition,lastAngle,modifiers,environment);			break;				case bSCALE_ROOM:					for(i = 0; i < length; i++,pPoly++)				okay = (*pPoly)->ScalePoly(dropAnchor,lastScale,modifiers,environment);			break;					case ROTATE_EYE:		case MOVE_EYE: 			observer->HiliteObserver(environment,lastPosition,editTool);			okay = TRUE;			break;					case bHIDE:		case bLOCK:			for(i = 0; i < length; i++,pPoly++)				okay = (*pPoly)->MovePoly(anchorPosition,anchorPosition,lastAngle,modifiers,environment);			break;					case bSKEW_TOOL:				for(i = 0; i < length; i++,pPoly++)				okay = (*pPoly)->SkewPoly(anchorPosition,lastPosition,lastAngle,modifiers,environment);			break;		case bCONNECTOR:		case bARROW:			if((modifiers &OPT_EDIT_MODE) && (ON_POLY_POINT == (*pPoly)->GetMode())) tp = currentPosition;			else tp = anchorPosition; 			for(i = 0; i < length; i++,pPoly++)				okay = (*pPoly)->MovePoly(tp,lastPosition,lastAngle,modifiers,environment);			break;		}			editList->Unuse();		return(okay);	}	void DesignDraft::UpdateObject(long modifiers) 	{	TextureItem		*texture;		// ABD WILLIAMS MERGE-TEXTURE 9/13/93	CAVPolyhedron	*leadPoly,**ppoly,*foundPoly;	EditSpecList	*undoItem,*dupItem;	V_Array			*editSpecList;	EditSpec		*undoSpec;	RGBColor		color;	Point3DFFixed	baseVector,pointVector,vector1,vector2,scaleVector,scaleMult;	Angle3DFFixed	baseAngle,pointAngle;	PointFFixed		wrlAnchorPt,wrlLastPt,wrlScaleAnchorPt,mult;	FFixed			wrlAnchorAngle,wrlLastAngle,newTop,newBot,tmpMult,depth;	PointLong		sp;	int				i,length, mode,doType,makeIrr,updateEditor,place,removeFromSelect;	int				constrain,msgType;	int				installFlag,oldRecord;			length = editList->ALength();	if(!editAction && !length) return;	foundPoly = NULL;	if(length)		{		editList->Get(0,&leadPoly);		mode = leadPoly->GetMode();		}	updateEditor = FALSE;	makeIrr = FALSE;	installFlag = FALSE;	removeFromSelect = FALSE;	msgType = msgEdit;	tempFFPoints->Get(0,&wrlAnchorPt);	tempFFPoints->Get(1,&wrlLastPt);		wrlAnchorAngle = ConvertAngle(anchorAngle);	wrlLastAngle = ConvertAngle(lastAngle);	baseVector = environment->MakeVector(TO_WORLD,wrlAnchorPt);	pointVector = environment->MakeVector(TO_WORLD,wrlLastPt);	baseAngle = environment->TranslateFFAngle(wrlAnchorAngle);	pointAngle = environment->TranslateFFAngle(wrlLastAngle);			switch(editTool)		{		case bSKEW_TOOL:				if((modeWait >= editMode) || !(editFlags&EDIT_CURSOR_MOVE)) return;							updateEditor = TRUE;				switch(mode)				{				case ON_POLY_POINT:				case ON_POLY_SIDLINE:				case IN_POLY: 						if(leadPoly->defAxis == environment->GetAxis())						{						if(TOP_SIDE == leadPoly->GetSide(environment))doType = _EDIT_MOVE_TOPEND; 						else doType = _EDIT_MOVE_BOTEND; 						updateEditor = TRUE;						}					else						return;					break;				case ON_POLY_DEFLINE:					switch(leadPoly->GetSide(environment))						{						case TOP_SIDE: doType = _EDIT_MOVE_TOPEND; break; 						case BOTTOM_SIDE: doType = _EDIT_MOVE_BOTEND; break;						}					break;				}			undoItem = NewUndoItem(UNDO_POLY_FLAG);			undoSpec = undoItem->cEditSpec(doType);			((UPolyMove*)undoSpec)->SetVector(baseVector,pointVector);			undoSpec->SetMark(leadPoly->OutlineMark(environment));			break;					case bARROW:				if((modeWait >= editMode) || !(editFlags&EDIT_CURSOR_MOVE)) return;							undoItem = NewUndoItem(UNDO_POLY_FLAG);			switch(mode)				{				case ON_POLY_SIDLINE:				case IN_POLY: 						doType = _EDIT_MOVE; 					sp = lOrigin;					sp.h += lastPosition.h; 					sp.v += lastPosition.v;					foundPoly = polyhedron->PointContained(leadPoly,environment,sp,editList);					break;									case ON_POLY_DEFLINE: 					updateEditor = TRUE;					if(leadPoly->defAxis == environment->GetAxis())						{						if(OPT_EDIT_MODE&modifiers) makeIrr = TRUE;						doType = _EDIT_MOVELINE;						}					else						{						switch(leadPoly->GetSide(environment))							{							case TOP_SIDE: doType = _EDIT_MOVE_TOPEND; break; 							case BOTTOM_SIDE: doType = _EDIT_MOVE_BOTEND; break;							default: return; break;							}												switch(leadPoly->GetAxis())							{							case INFL_X: newTop = pointVector.x;newBot = baseVector.x; break;								case INFL_Y: newTop = pointVector.y;newBot = baseVector.y; break;							case INFL_Z: newTop = pointVector.z;newBot = baseVector.z; break;							}						pointVector = leadPoly->OutlToWorld(PtFFZero,newTop);						baseVector = leadPoly->OutlToWorld(PtFFZero,newBot);						}					break;									case ON_POLY_ORIGIN:doType = _EDIT_MOVEORG; updateEditor = TRUE; if(OPT_EDIT_MODE&modifiers) makeIrr = TRUE; break;				case ON_POLY_POINT: doType = _EDIT_MOVEPT; updateEditor = TRUE; if(OPT_EDIT_MODE&modifiers) makeIrr = TRUE; break;				default: return; break;				} 			if(foundPoly && foundPoly != leadPoly->FindContainer()) 				{				undoSpec = undoItem->cEditSpec(_EDIT_INSTALL);				((UPolyInstall*)undoSpec)->SetContainer(foundPoly);				installFlag = TRUE;				}						if(makeIrr) 				{				undoSpec = undoItem->cEditSpec(_EDIT_TYPE);				((UPolyType*)undoSpec)->SetEditType(EDIT_POLYGON);				}			undoSpec = undoItem->cEditSpec(doType);			if(modifiers&OPT_EDIT_MODE)((UPoly*)undoSpec)->SetInherit(FALSE);			undoSpec->SetMark(leadPoly->OutlineMark(environment));			((UPolyMove*)undoSpec)->SetVector(baseVector,pointVector);			break;					case bPLUS_MINUS:				undoItem = NewUndoItem(UNDO_POLY_FLAG);			updateEditor = TRUE;			switch(leadPoly->GetEditType())				{				case EDIT_REGPOLYGON: if(!(OPT_EDIT_MODE&modifiers)) makeIrr = TRUE; break;				case EDIT_RECTANGLE: makeIrr = TRUE; break;				case EDIT_POLYGON: makeIrr = FALSE; break;				}			switch(mode)				{				case ON_POLY_POINT: doType = _EDIT_REMPT; break;				case ON_POLY_DEFLINE: doType = _EDIT_ADDPT; break;				default: return; break;				}			if(makeIrr) 				{				undoSpec = undoItem->cEditSpec(_EDIT_TYPE);				((UPolyType*)undoSpec)->SetEditType(EDIT_POLYGON);				}			undoSpec = undoItem->cEditSpec(doType);			((UPolyMove*)undoSpec)->SetVector(baseVector,pointVector);			undoSpec->SetMark(leadPoly->OutlineMark(environment));			break;					case bCONNECTOR: 			SearchPeers(currentPosition,modifiers,drawPush);			if(currentPeer==polyhedron) return;			/* DUDE THIS SHOULDNT BE */			wrlAnchorPt = Local2World(anchorPosition,SCALE_ABSOLUTE);			baseVector = environment->MakeVector(TO_WORLD,wrlAnchorPt);			undoItem = NewUndoItem(UNDO_POLY_FLAG);			/* recalculate the pointVector here and the angleVector here */			pointVector = currentPeer->PointOnSurface(pointVector,currentPeer->SurfMark(environment));			baseVector = leadPoly->PointOnSurface(baseVector,leadPoly->SurfMark(environment));			if(!FFEqual(pointVector.x,baseVector.x) || !FFEqual(pointVector.y,baseVector.y)				|| !FFEqual(pointVector.z,baseVector.z))				{				undoSpec = undoItem->cEditSpec(_EDIT_MOVE);				undoSpec->SetMark(leadPoly->SurfMark(environment));				((UPolyMove*)undoSpec)->SetVector(baseVector,pointVector);				}							/* recalculate the pointVector here abd the angleVector here */			vector1 = currentPeer->GetSurfNormal(currentPeer->SurfMark(environment));			vector2 = leadPoly->GetSurfNormal(leadPoly->SurfMark(environment));			if(currentPeer == (CAVPolyhedron*)leadPoly->FindContainer())				{				vector2.x = FFNeg(vector2.x);				vector2.y = FFNeg(vector2.y);				vector2.z = FFNeg(vector2.z);				}			if(OPT_EDIT_MODE&modifiers)				{				vector2.x = FFNeg(vector2.x);				vector2.y = FFNeg(vector2.y);				vector2.z = FFNeg(vector2.z);				}							constrain = environment->GetAxis();			pointAngle = AlignToVector(vector1,vector2,constrain);			if(!FFZero(pointAngle.roll) || !FFZero(pointAngle.pitch) 				|| !FFZero(pointAngle.yaw))				{				undoSpec = undoItem->cEditSpec(_EDIT_ROTATE);				undoSpec->SetMark(leadPoly->SurfMark(environment));				((UPolyRotate*)undoSpec)->SetAngle(baseAngle,pointAngle);				((UPolyRotate*)undoSpec)->SetVector(pointVector,baseVector);				}												undoSpec = undoItem->cEditSpec(_EDIT_CONNECT);			((UPolyConnect*)undoSpec)->SetConnection(currentPeer,currentPeer->SurfMark(environment));			undoSpec->SetMark(leadPoly->SurfMark(environment));			break;								case bSCALE_ROOM:			if(!(editFlags&EDIT_CURSOR_MOVE)) return;			updateEditor = TRUE;						undoItem = NewUndoItem(UNDO_POLY_FLAG);			undoSpec = undoItem->cEditSpec(_EDIT_SCALE);			if(modifiers&OPT_EDIT_MODE)((UPoly*)undoSpec)->SetInherit(FALSE);			undoSpec->SetMark(0);		tempFFPoints->Get(0,&wrlAnchorPt);	tempFFPoints->Get(1,&wrlScaleAnchorPt);	tempFFPoints->Get(2,&wrlLastPt);/*		wrlScaleAnchorPt = ffDropAnchor;*/			wrlLastPt.h = FFSub(wrlLastPt.h,wrlAnchorPt.h);			wrlLastPt.v = FFSub(wrlLastPt.v,wrlAnchorPt.v);			wrlScaleAnchorPt.h = FFSub(wrlScaleAnchorPt.h,wrlAnchorPt.h);			wrlScaleAnchorPt.v = FFSub(wrlScaleAnchorPt.v,wrlAnchorPt.v);			pointVector = environment->MakeVector(TO_WORLD,wrlLastPt);			baseVector = environment->MakeVector(TO_WORLD,wrlScaleAnchorPt);			if(FFZero(baseVector.x))scaleMult.x = FFZero; else scaleMult.x = FFDiv(pointVector.x,baseVector.x);			if(FFZero(baseVector.y))scaleMult.y = FFZero; else scaleMult.y = FFDiv(pointVector.y,baseVector.y);			if(FFZero(baseVector.z))scaleMult.z = FFZero; else scaleMult.z = FFDiv(pointVector.z,baseVector.z);						if(modifiers&CONSTRAIN)				{				FFMax(tmpMult,scaleMult.x,scaleMult.y);				FFMax(tmpMult,tmpMult,scaleMult.z);				scaleMult.x = tmpMult;				scaleMult.y = tmpMult;				scaleMult.z = tmpMult;				ObjectCenter(&depth);				baseVector.x = wrlAnchorPt.h;				baseVector.y = wrlAnchorPt.v;				baseVector.z = depth;				baseVector = environment->Translate3DFFixed(TO_WORLD,baseVector);				}			else				baseVector = environment->MakeVector(TO_WORLD,wrlAnchorPt);							if(FFZero(scaleMult.x))scaleMult.x = FFOne;			if(FFZero(scaleMult.y))scaleMult.y = FFOne;			if(FFZero(scaleMult.z))scaleMult.z = FFOne;			((UPolyScale*)undoSpec)->SetScale(scaleMult,baseVector);				break;					case bROTATE_ROOM:  			if(!(editFlags&EDIT_CURSOR_MOVE)) return;			undoItem = NewUndoItem(UNDO_POLY_FLAG);			undoSpec = undoItem->cEditSpec(_EDIT_ROTATE);			if(modifiers&OPT_EDIT_MODE)((UPoly*)undoSpec)->SetInherit(FALSE);			((UPolyRotate*)undoSpec)->SetAngle(baseAngle,pointAngle);			((UPolyRotate*)undoSpec)->SetVector(baseVector,pointVector); 			break; 					case bLOCK:			undoItem = NewUndoItem(UNDO_POLY_FLAG);			if(OPT_EDIT_MODE&modifiers)				undoSpec = undoItem->cEditSpec(_EDIT_UNLOCK);			else				{				msgType = msgUpdate;				removeFromSelect = TRUE;				undoSpec = undoItem->cEditSpec(_EDIT_LOCK);				}			break;		case bHIDE:			undoItem = NewUndoItem(UNDO_POLY_FLAG);			if(OPT_EDIT_MODE&modifiers)				undoSpec = undoItem->cEditSpec(_EDIT_HIDEWALK);			else				{				msgType = msgUpdate;				removeFromSelect = TRUE;				undoSpec = undoItem->cEditSpec(_EDIT_HIDE);				}			updateEditor = FALSE;			break;		case bDROPPER:// ABD WILLIAMS MERGE-TEXTURE 9/13/93 [[[			if(OPT_EDIT_MODE&modifiers) 			{				color = leadPoly->GetColor(SURF_INSIDE);				texture = leadPoly->GetTexture(SURF_INSIDE);		// ABD TEXTURE			}			else 			{				color = leadPoly->GetColor(SURF_OUTSIDE);				texture = leadPoly->GetTexture(SURF_OUTSIDE);		// ABD TEXTURE			}			pcc(controller)->ColorDropper(color, texture);		// ABD TEXTURE// ABD WILLIAMS MERGE-TEXTURE 9/13/93 ]]]			return;			break;					case MOVE_EYE:			pointVector = environment->MakeVector(TO_WORLD,wrlLastPt);			baseVector = environment->Translate3DFFixed(TO_CAD,observer->FFpoint);			baseVector.z = FFZero;			baseVector = environment->Translate3DFFixed(TO_WORLD,baseVector);			pointVector = FF3DSub(pointVector,baseVector);				oldRecord = observer->record;					observer->record = FALSE;					observer->ObserverTranslation(pointVector);			observer->record = oldRecord;					observer->Select(environment);			controller->ControlMessage(draftAction,modifiers,ONSTATE);			editAction = FALSE;			controller->Request(NULL,msgEdit,objObserver,0);			return;			break;							case ROTATE_EYE:			pointAngle = observer->GetObserverRotation();			pointAngle = environment->Translate3DFFAngle(TO_CAD,pointAngle);			angle = ConvertAngle(angle);			wrlLastPt.h = FFSub(wrlLastPt.h,wrlAnchorPt.h);			wrlLastPt.v = FFSub(wrlLastPt.v,wrlAnchorPt.v);			if(wrlLastPt.h.l==0 && wrlLastPt.v.l==0)angle.l=0;			else	angle = DblToFixed(atan2(FixedToDbl(wrlLastPt.v),FixedToDbl(wrlLastPt.h)));			switch(environment->GetAxis())				{				case INFL_X: break;				case INFL_Y:				case INFL_Z: angle = FFSub(angle,FFHalfPi); break;				}			pointAngle.yaw = angle;			pointAngle = environment->Translate3DFFAngle(TO_WORLD,pointAngle);			oldRecord = observer->record;					observer->record = FALSE;					observer->ObserverRotation(pointAngle);			observer->record = oldRecord;					observer->Select(environment);			controller->ControlMessage(draftAction,modifiers,ONSTATE);			editAction = FALSE;			controller->Request(NULL,msgEdit,objObserver,0);			return;			break;								default: 			break;		}		ppoly = (CAVPolyhedron**)editList->Use();	for(i = 0; i < length; i++,ppoly++)		{		if(removeFromSelect)			{			place = selectedList->Find(&(*ppoly));			if(0 <= place)  selectedList->Remove(place);			(*ppoly)->SetMode(OUT_POLY);			}					editSpecList = undoItem->SetEditObject(*ppoly,NULL,UNDO_POLY_FLAG);		(*ppoly)->SetMode(IN_POLY);		(*ppoly)->SetDirty(POLY_MUSSED);		if(installFlag && ((*ppoly)->container == tracePolyhedron))			{			EditSpec	*spec;			int	tmpLength,j;						tmpLength = editSpecList->ALength();			for(j = tmpLength-1; j >= 0; j--)				{				editSpecList->Get(i,&spec);				if(_EDIT_INSTALL == spec->GetAction())					editSpecList->Remove(i);				}			}		}				editList->Unuse();	undoItem->Edit();			if(updateEditor)		{		ppoly = (CAVPolyhedron**)editList->Use();		for(i = 0; i < length; i++,ppoly++) 			controller->EditPolyhedron(*ppoly,objCad);				editList->Unuse();		}			editList->SetLength(0);		controller->Request(NULL,msgType,objPolyhedron,0);	}// MERGE-GOURAUD-PRO-3 [[[void DesignDraft::Nudge(char direction,long modifiers) 			// ABD{CAVPolyhedron	*leadPoly,**ppoly,*foundPoly;EditSpecList	*undoItem;V_Array			*editSpecList;EditSpec		*undoSpec;int i, length;Point3DFFixed	baseVector,pointVector;Point p, pz;PointFFixed gridUnit;	length = selectedList->ALength();	if (length == 0) return;		undoItem = NewUndoItem(UNDO_POLY_FLAG);	undoSpec = undoItem->cEditSpec(_EDIT_MOVE);		// with option key nudge one grid unit, otherwise one pixel	if ((modifiers & V_OPTION) == V_OPTION)	{		FFixed FFZ={0};			gridUnit = pcc(controller)->GridUnit();		switch (direction)		{			case V_LEFTARROW:  gridUnit.h = FFNeg(gridUnit.h); gridUnit.v = FFZ; break;			case V_RIGHTARROW:  gridUnit.v = FFZ; break;			case V_UPARROW:  gridUnit.h = FFZ; break;			case V_DOWNARROW:  gridUnit.h = FFZ; gridUnit.v = FFNeg(gridUnit.v); break;			default: gridUnit.h = FFZ; gridUnit.v = FFZ; break;		}			baseVector = environment->MakeVector(TO_WORLD, FFPointZero);		pointVector = environment->MakeVector(TO_WORLD, gridUnit);	}	else	{			pz.h = 0; pz.v = 0;		switch (direction)		{			case V_LEFTARROW:  p.h = -1; p.v = 0; break;			case V_RIGHTARROW:  p.h = +1; p.v = 0; break;			case V_UPARROW:  p.h = 0; p.v = -1; break;			case V_DOWNARROW:  p.h = 0; p.v = +1; break;			default: p.h = 0; p.v = 0; break;		}		baseVector = environment->MakeVector(TO_WORLD, Local2World(pz,SCALE_ABSOLUTE));		pointVector = environment->MakeVector(TO_WORLD, Local2World(p,SCALE_ABSOLUTE));	}		((UPolyMove*)undoSpec)->SetVector(baseVector,pointVector);					ppoly = (CAVPolyhedron **)selectedList->Use();	for(i = 0; i < length; i++,ppoly++)	{		editSpecList = undoItem->SetEditObject(*ppoly,NULL,UNDO_POLY_FLAG);		(*ppoly)->SetMode(IN_POLY);		(*ppoly)->SetDirty(POLY_MUSSED);	}				selectedList->Unuse();	undoItem->Edit();	if(TRUE)	// was undoItem->UpdateEditor()	{		ppoly = (CAVPolyhedron **)selectedList->Use();		for(i = 0; i < length; i++,ppoly++) 			controller->EditPolyhedron(*ppoly,objCad);				selectedList->Unuse();	}		controller->Request(NULL,msgEdit,objPolyhedron,0);}	// MERGE-GOURAUD-PRO-3 ]]]voidDesignDraft::LaunchEditor() 	{	CAVPolyhedron	*poly;	SurfDef			*surfDef;	Point3DFFixed	orient;	int				ctrlType;		if(!editList->ALength())return;	editList->Get(0,&poly);	if(POLY_GROUP == poly->type) { editList->SetLength(0); return; }	surfDef = poly->GetSurfDef(poly->cavsurf);	if(!surfDef)return;		orient = Pt3DFFZero;		switch(editTool)		{		case bSURFACE_EDITOR: ctrlType = toolCRTLSurface; break;		case bTUMBLE_EDITOR:ctrlType = toolCRTTumble; break;		case bLIGHT_EDITOR:	ctrlType = toolCRTLLight; break;		}			CadDraft::LaunchEditor();	pcc(controller)->LaunchEditor(poly,environment->GetScale(),surfDef,orient,ctrlType);	}		void DesignDraft::SelectPolyhedron(CAVPolyhedron *poly,V_Array *list) 	{	CAVPolyhedron 	**ppoly;	int				i,length;	SetPane();		if(poly)		poly->Select(environment);	else		{		length = selectedList->ALength();		ppoly = (CAVPolyhedron**)selectedList->Use();		for(i = 0; i < length; i++,ppoly++)			(*ppoly)->Select(environment);		selectedList->Unuse();		}			UnsetPane();	}	int DesignDraft::NewSelect(CAVPolyhedron *newPoly,int	resetFlag) 	{	CAVPolyhedron	**ppoly,*poly;	Polyhedron		*newCont,*oldCont;	int				i,length,whichNum,pleaseAppend,err;		pleaseAppend = (newPoly != NULL);	err = FALSE;		if(length = selectedList->ALength())		{		if(resetFlag)			{			ppoly = (CAVPolyhedron**)selectedList->Use();			for(i=0; i < length; i++,ppoly++) 				(*ppoly)->SetMode(OUT_POLY);			selectedList->Unuse();				ppc(controller)->Select(NULL,selectedList);					selectedList->SetLength(0);			}		else			{			if(newPoly)				{				whichNum = selectedList->Find(&newPoly);				if(0<=whichNum) 					{ 					selectedList->Remove(whichNum); 					newPoly->SetMode(OUT_POLY);					ppc(controller)->Select(newPoly,NULL);					pleaseAppend = FALSE; 					}				else					{					selectedList->Get(0,&poly); 					newCont = newPoly->FindContainer();					oldCont = poly->FindContainer();					if(newPoly && (newCont != oldCont) 						&& (oldCont != tracePolyhedron) && (newCont != tracePolyhedron))						{						newPoly->SetMode(OUT_POLY);						AlertMessage(TXTW_PEERSELC);						pleaseAppend = FALSE; 						err = TRUE;						}					}				}			}			}		if(pleaseAppend && newPoly && newPoly != polyhedron) 		{		selectedList->Append(&newPoly);		newPoly->SetMode(IN_POLY);		ppc(controller)->Select(newPoly,NULL);		}			ppc(controller)->SetLastPoly(NULL);	SetPane();	return(err);	}	int DesignDraft::EditLayer(LayerItem *layer,int action) 	{	CAVPolyhedron	**ppoly,*tPoly;	int			i,length,layerFlag;	length = selectedList->ALength();			switch(action)		{		case msgDestroy:		case msgEdit:			for(i = length-1; i >= 0; i--) 				{				selectedList->Get(i,&tPoly);				if(layer == tPoly->GetLayer())					{					tPoly->SetMode(OUT_POLY);					selectedList->Remove(i);					}				}			if(msgDestroy == action)				{				if(TRACE_LAYER&layer->GetFlag()) tracePolyhedron->DeleteLayer(layer);				else polyhedron->DeleteLayer(layer);					}			break;				case msgUpdate:			ppoly = (CAVPolyhedron**)selectedList->Use();			for(i = 0; i < length; i++,ppoly++) 				(*ppoly)->SetLayer(layer,FALSE);			selectedList->Unuse();						layerFlag = layer->GetFlag();			if(layerFlag&(HIDE_LAYER|LOCK_LAYER))				NewSelect(NULL,TRUE);			break;		}			return(TRUE);	}void DesignDraft::UnPosition(int type) 	{	CAVPolyhedron	**ppoly;	Angle3DFFixed	rotate;	EditSpecList		*undoItem;	EditSpec		*undoSpec;	Angle3DFFixed	baseAngle,pointAngle;	Point3DFFixed	baseVector,pointVector;	int				i,length,updateEditor;		pointAngle = Ang3DFFZero;	baseAngle = Ang3DFFZero;	pointVector = Pt3DFFZero;	baseVector = Pt3DFFZero;	 	switch(type) 		{ 		case bROTATE_ROOM:			undoItem = NewUndoItem(UNDO_POLY_FLAG);			undoSpec = undoItem->cEditSpec(_EDIT_ROTATEABS);			((UPolyRotate*)undoSpec)->SetAngle(baseAngle,pointAngle);			((UPolyRotate*)undoSpec)->SetVector(baseVector,pointVector); 			updateEditor = FALSE;				break; 			 		case bSCALE_ROOM:			undoItem = NewUndoItem(UNDO_POLY_FLAG);			undoSpec = undoItem->cEditSpec(_EDIT_SCALEABS);			((UPolyScale*)undoSpec)->SetScale(Pt3DFFOne,Pt3DFFZero);			updateEditor = TRUE;				break; 		  		case bSKEW_TOOL:			undoItem = NewUndoItem(UNDO_POLY_FLAG);			undoSpec = undoItem->cEditSpec(_EDIT_UNSKEW);			((UPolySkew*)undoSpec)->SetSkew(PtFFZero,PtFFZero);			updateEditor = TRUE;				break;		default: 			return;		}	length = selectedList->ALength();	ppoly = (CAVPolyhedron**)selectedList->Use();		for(i = 0; i < length; i++,ppoly++)		{		undoItem->SetEditObject(*ppoly,NULL,UNDO_POLY_FLAG);		(*ppoly)->SetMode(IN_POLY);		(*ppoly)->SetDirty(POLY_MUSSED);		}				selectedList->Unuse();		undoItem->Edit();	if(updateEditor)		{		ppoly = (CAVPolyhedron**)selectedList->Use();		for(i = 0; i < length; i++,ppoly++) 			controller->EditPolyhedron(*ppoly,objCad);				selectedList->Unuse();		}		controller->Request(NULL,msgEdit,objPolyhedron,0);	}void DesignDraft::SetFlip(int direction) 	{	CAVPolyhedron	**ppoly;	EditSpecList		*undoItem;	EditSpec		*undoSpec;	int		length,i;		if(!(length = selectedList->ALength())) return;		undoItem = NewUndoItem(UNDO_POLY_FLAG);	undoSpec = undoItem->cEditSpec(_EDIT_DIRECTION);	((UPolyDirection*)undoSpec)->SetDirection(direction);	ppoly = (CAVPolyhedron**)selectedList->Use();	for(i = 0; i < length; i++,ppoly++) 		{		if(POLY_INFLATE == (*ppoly)->type)			undoItem->SetEditObject(*ppoly,NULL,UNDO_POLY_FLAG);		}	selectedList->Unuse();		undoItem->Edit();		ppoly = (CAVPolyhedron**)selectedList->Use();	for(i = 0; i < length; i++,ppoly++)		controller->EditPolyhedron(*ppoly,objPolygon);	selectedList->Unuse();	controller->Request(NULL,msgEdit,objPolyhedron,0); 	}void DesignDraft::SetInflate(int InflateType, int direction) 	{	AppPreference	*appPreference;	DefaultPreference *defPref;	CAVPolyhedron	**ppoly;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	int				length,i,numLevels;		if(!(length = selectedList->ALength())) return;			undoItem = NewUndoItem(UNDO_POLY_FLAG);		appPreference = controller->GetPreference();	defPref = (DefaultPreference*)appPreference->GetPreference(preferDefaults);	numLevels = defPref->ellipseLevels;	undoSpec = undoItem->cEditSpec(_EDIT_INFLATE);	undoSpec->SetMark(-1);	((UPolyInflate*)undoSpec)->SetInflate(InflateType,numLevels,direction);		if((-1 != InflateType) && (-1 != direction))		{		undoSpec = undoItem->cEditSpec(_EDIT_DIRECTION);		((UPolyDirection*)undoSpec)->SetDirection(direction);		}			ppoly = (CAVPolyhedron**)selectedList->Use();	for(i = 0; i < length; i++,ppoly++) 		{		if(POLY_INFLATE == (*ppoly)->type)			undoItem->SetEditObject(*ppoly,NULL,UNDO_POLY_FLAG);		}	selectedList->Unuse();		undoItem->Edit();		ppoly = (CAVPolyhedron**)selectedList->Use();	for(i = 0; i < length; i++,ppoly++)		controller->EditPolyhedron(*ppoly,objPolygon);	selectedList->Unuse();	controller->Request(NULL,msgEdit,objPolyhedron,0);	}	void DesignDraft::SetEditState(int editState,long modifiers,int dir)	{	CAVPolyhedron	**ppoly;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	int				i,length,walkView,result;		walkView = (OPT_EDIT_MODE&modifiers)? TRUE : FALSE;	if(!dir)		{		polyhedron->ResetEditState(editState,walkView);		tracePolyhedron->ResetEditState(editState,walkView); 		}	else		{		if(!(length = selectedList->ALength()))return;		undoItem = NewUndoItem(UNDO_POLY_FLAG);		if(walkView)			undoSpec = undoItem->cEditSpec(_EDIT_HIDEWALK);		else			{			if(editState&EDIT_HIDDEN) 				undoSpec = undoItem->cEditSpec(_EDIT_HIDE);			if(editState&EDIT_LOCKED) 				undoSpec = undoItem->cEditSpec(_EDIT_LOCK);			}						ppoly = (CAVPolyhedron**)selectedList->Use();		for(i = 0; i < length; i++,ppoly++)			undoItem->SetEditObject(*ppoly,NULL,UNDO_POLY_FLAG);		selectedList->Unuse();				if(walkView)NewSelect(NULL,TRUE);				undoItem->Edit();		}		if(walkView)		controller->Request(NULL,msgEdit,objView,0);	else		controller->Request(NULL,msgUpdate,objPolyhedron,0);	}void DesignDraft::SetSides(int numSides,int editType)	{		V_Array			*tmpList;	CAVPolyhedron	**pPoly;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	int				i,length,editActionType;		length = selectedList->ALength();	if((editType) && (numSides < 3)) return;			tmpList = new(V_Array);	tmpList->cArray(0,sizeof(CAVPolyhedron*),4);		pPoly = (CAVPolyhedron**)selectedList->Use();	if(editType)		{		editActionType = _EDIT_NUMSIDES;		for(i = 0; i < length; i++,pPoly++)			if( EDIT_REGPOLYGON == (*pPoly)->GetEditType())				tmpList->Append(&(*pPoly));		}	else		{		editActionType = _EDIT_NUMLEVELS;		for(i = 0; i < length; i++,pPoly++) 			if( (INFL_ELLIPSE == (*pPoly)->inflate) || (INFL_DUALELLIPSE == (*pPoly)->inflate))				tmpList->Append(&(*pPoly));		}	selectedList->Unuse();		length = tmpList->ALength();	if(length)		{			undoItem = NewUndoItem(UNDO_POLY_FLAG);		undoSpec = undoItem->cEditSpec(editActionType);		((UPolyNumSides*)undoSpec)->SetNumber(numSides);			pPoly = (CAVPolyhedron**)tmpList->Use();		for(i = 0; i < length; i++,pPoly++)			undoItem->SetEditObject(*pPoly,NULL,UNDO_POLY_FLAG);		tmpList->Unuse();				undoItem->Edit();			pPoly = (CAVPolyhedron**)tmpList->Use();		for(i = 0; i < length; i++,pPoly++)			controller->EditPolyhedron(*pPoly,objPolygon);		tmpList->Unuse();			controller->Request(NULL,msgEdit,objPolyhedron,0);		}			tmpList->dArray();	}	void DesignDraft::SetOpacity(int opacity)	{	CAVPolyhedron	*leadPolyhedron,**ppoly;	EditSpecList		*undoItem;	EditSpec		*undoSpec;	int				i,length;		if(!(length = selectedList->ALength())) return;		selectedList->Get(0,&leadPolyhedron);	undoItem = NewUndoItem(UNDO_POLY_FLAG);	undoSpec = undoItem->cEditSpec(_EDIT_COLOR);	undoSpec->SetMark(-1);	((UPolyColor*)undoSpec)->SetColor(leadPolyhedron->GetColor(SURF_OUTSIDE),opacity,SURF_SHARED);		ppoly = (CAVPolyhedron**)selectedList->Use();/* set the polyhedron opacity value here */	for(i = 0; i < length; i++,ppoly++)		undoItem->SetEditObject(*ppoly,NULL,UNDO_POLY_FLAG);	selectedList->Unuse();	undoItem->Edit();	ppoly = (CAVPolyhedron**)selectedList->Use();	for(i = 0; i < length; i++,ppoly++)		controller->EditPolyhedron(*ppoly,objPolygon);	selectedList->Unuse();	controller->Request(NULL,msgEdit,objView,0);	}/*=========================================================================*	void DesignDraft::SetColor( RGBColor color )*-------------------------------------------------------------------------*/void DesignDraft::SetColor(RGBColor color)	{	CAVPolyhedron	**ppoly,*leadPolyhedron;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	int				i,length,redrawType,layerFlag;		if(!(length = selectedList->ALength())) return;	redrawType = objView;	selectedList->Get(0,&leadPolyhedron);		undoItem = NewUndoItem(UNDO_POLY_FLAG);	undoSpec = undoItem->cEditSpec(_EDIT_COLOR);	undoSpec->SetMark(-1);	((UPolyColor*)undoSpec)->SetColor(color,leadPolyhedron->GetOpacity(),SURF_SHARED);		length = selectedList->ALength();	ppoly = (CAVPolyhedron**)selectedList->Use();	for(i = 0; i < length; i++,ppoly++)		{		undoItem->SetEditObject(*ppoly,NULL,UNDO_POLY_FLAG);		layerFlag = (*ppoly)->layer->GetFlag();		if(!(layerFlag&COLOR_LAYER)) redrawType = objPolyhedron;		}	selectedList->Unuse();		undoItem->Edit();		ppoly = (CAVPolyhedron**)selectedList->Use();	for(i = 0; i < length; i++,ppoly++)		controller->EditPolyhedron(*ppoly,objPolygon);	selectedList->Unuse();	  	controller->Request(NULL,msgEdit,redrawType,0);	}char DesignDraft::GetDefAxis()	{ 	return(environment->GetAxis());	}void DesignDraft::SetExtrudeHeight(short defAxis)	{	CAVPolyhedron	**pPoly;	Point3DFFixed	baseVector,pointVector;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	FFixed			swap,newPoint,newBase;	int				i,length;		length = selectedList->ALength();		if(!length) return;		ppc(controller)->GetDepth(&newPoint,&newBase,defAxis);		baseVector = pointVector = Pt3DFFZero;	if(GRTR == FFLogic(newPoint,newBase))		{		swap = newPoint;		newPoint = newBase;		newBase = swap;		}	switch(defAxis)		{		case INFL_X: pointVector.x = newPoint; baseVector.x = newBase; break;		case INFL_Y: pointVector.y = newPoint; baseVector.y = newBase; break;		case INFL_Z: pointVector.z = newPoint; baseVector.z = newBase; break;		}			undoItem = NewUndoItem(UNDO_POLY_FLAG);	undoSpec = undoItem->cEditSpec(_EDIT_MOVE_BOTHEND);	undoSpec->SetMark(-1);	((UPolyMove*)undoSpec)->SetVector(baseVector,pointVector);		pPoly = (CAVPolyhedron**)selectedList->Use();	for(i = 0; i < length; i++,pPoly++)		if((defAxis == (*pPoly)->defAxis) && (POLY_INFLATE == (*pPoly)->type)			&& (tracePolyhedron != (*pPoly)->container))			undoItem->SetEditObject(*pPoly,NULL,UNDO_POLY_FLAG);	selectedList->Unuse();	undoItem->Edit();	controller->Request(NULL,msgEdit,objPolyhedron,0);	}	void DesignDraft::Grouping(int state) 	{	V_Array			*tmpList,*tmp2List;	Polyhedron 		*container;	CAVPolyhedron	**ppoly,*newGroup,**contents;	EditSpecList		*undoItem;	int				length,i,j,clength,spot;	#if VRML_ANCHOR		// ABD PRO25 AUG95	if (!state)	// only ungroup	{	int i, length;	int found = FALSE;	CAVPolyhedron **ppoly;		length = selectedList->ALength();		ppoly = (CAVPolyhedron**)selectedList->Use();		for(i = 0; i < length; i++,ppoly++)			if ((POLY_GROUP == (*ppoly)->type) && (*ppoly)->HasVRMLAnchor())			{				found = TRUE;				break;			}		selectedList->Unuse();				if (found)		{			if(!QOKCancel("A selected group has a VRML anchor (URL) attached.  Ungrouping will delete that URL.  Ungroup?"))			{				// cancel				return;			}			else			{				// ok				// just continue as if nothing had happened...			}		}	}	#endif		RemoveTraceLayer(selectedList);		if(length = selectedList->ALength())		{			if(TRUE == state)	/* group them together */			{			if(2 > length) return;			undoItem = NewUndoItem(UNDO_POLY_FLAG);/* clears out undo */						newGroup = new(CAVPolyhedron);			newGroup->cPolyhedron(polyhedron->drawing);			newGroup->SetLayer(pcc(controller)->GetLayer(),FALSE);			newGroup->CreateGroup();			newGroup->GroupMembers(selectedList);			NewSelect(NULL,TRUE);			newGroup->SetMode(IN_POLY);			selectedList->Append(&newGroup);			ppc(controller)->NewPolyhedron(msgCreate,objDraft,newGroup);/* dude - this is because connections are being broken by Remove.  This should change */			controller->Request(NULL,msgEdit,objPolyhedron,0);			}		else				/* break any groups selected */			{			undoItem = NewUndoItem(UNDO_POLY_FLAG);/* clears out undo */			tmpList = new(V_Array);			tmpList->cArray(0,sizeof(CAVPolyhedron*),4);			tmp2List = new(V_Array);			tmp2List->cArray(0,sizeof(CAVPolyhedron*),4);			selectedList->CopyArray(tmpList);			ppoly = (CAVPolyhedron**)tmpList->Use();			for(i = 0; i < length; i++,ppoly++)				{				if(POLY_GROUP == (*ppoly)->type)					{					(*ppoly)->contents->CopyArray(tmp2List);					(*ppoly)->RemoveMulti(tmp2List);					(*ppoly)->container->InstallMulti(tmp2List);					(*ppoly)->container->Remove(*ppoly);					if(VARY_NOTFOUND != (spot = selectedList->Find(&(*ppoly))))						selectedList->Remove(spot);										clength = tmp2List->ALength();					contents = (CAVPolyhedron**)tmp2List->Use();					for(j = 0; j < clength; j++,contents++)						{						(*contents)->SetMode(IN_POLY);						selectedList->Append(&(*contents));						}					tmp2List->Unuse();					(*ppoly)->dPolyhedron();					} 				}			tmpList->Unuse();									tmpList->dArray();			tmp2List->dArray();			controller->Request(NULL,msgEdit,objPolyhedron,0);			}		}	}	int DesignDraft::EditBuffer(long action,long modifiers) 	{	CAVPolyhedron	**ppoly,*curDup,*dupPeer;	Position		*relPosn;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	V_Array			*undoItems, *shadowSelectList;			// jca 25 Oct 93  save the last selected thing 	int	length,i,err,found,mode,undoType;		err = noErr;		// jca 20 Oct 93			switch(action)		{		case  MSG_COPY:/* Copy */			clipBuf->IOSetLength(0);			clipBuf->IOSetPosition(0);			clipBuf->IOSetDirection(DATA_OUT);			IO_ID(clipBuf,IFF_PRSM);			err = IO_OBJECT(clipBuf);			break; 					case  MSG_DUPLICATE:/* Duplicate */			if(pcc(controller)->CreateOK())				{ 							if(EditBuffer(MSG_COPY,modifiers) < noErr) break;				length = selectedList->ALength();				if(!length) return(-1);					curDup = ppc(controller)->GetLastPoly();				selectedList->Get(0,&dupPeer);								// jca 25 Oct 93 {				shadowSelectList = new(V_Array);				err = shadowSelectList->cArray(selectedList->ALength(), sizeof(CAVPolyhedron*), 1);				if (err)					{					delete(shadowSelectList);		// we failed the cArray; delete now					shadowSelectList = NULL;					}				else					{					err = selectedList->CopyArray(shadowSelectList);					if (err)						{						shadowSelectList->dArray();		// we failed the copy;  dArray						shadowSelectList = NULL;						}					}				// jca 25 Oct 93 }									NewSelect(NULL,TRUE);				clipBuf->IOSetPosition(0);				clipBuf->IOSetDirection(DATA_IN);				IO_ID(clipBuf,IFF_PRSM);				err = IO_OBJECT(clipBuf);				if(!err)					{					if(!curDup)						DuplicatePosition(NULL,curDup);   // jca 22FEB95  changed from dupPeer to curDup					else						{						relPosn = new(Position);						relPosn->cPosition();								dupPeer->posn->Copy(relPosn);						relPosn->UnPosition(curDup->posn);						DuplicatePosition(relPosn,curDup);  // jca 22FEB95  changed from dupPeer to curDup						relPosn->dPosition();						}											controller->Request(NULL,msgEdit,objView,0);					controller->Request(NULL,msgEdit,objTextureList,0);		// ABD WILLIAMS MERGE-TEXTURE 9/13/93					ppc(controller)->SetLastPoly(dupPeer);					}								if (err)	// jca 25 Oct 93 {					{	// if we can't duplicate the objects...					if (shadowSelectList != NULL)						{						int salvageErr = noErr;						salvageErr = shadowSelectList->CopyArray(selectedList);		// leave the last object selected						if (salvageErr)							selectedList->SetLength(0);		// inconceivable!						else							{	// all okay, save the info back							ppoly = (CAVPolyhedron**)shadowSelectList->Use();							for(i = 0; i < shadowSelectList->ALength(); i++)  								ppoly[i]->SetMode(IN_POLY);							shadowSelectList->Unuse();							ppc(controller)->Select(NULL,selectedList);									}						shadowSelectList->dArray();                        shadowSelectList = NULL;						}					else						selectedList->SetLength(0);		// fail gracefully					}                // 17MAY94 jca oops-- forgot to delete it				if (shadowSelectList)                	{					shadowSelectList->dArray();		// we failed the copy;  dArray					shadowSelectList = NULL;                    }				// jca 25 Oct 93 }				}			break; 					case  MSG_PASTE:/* Paste */			if(pcc(controller)->CreateOK())				{ 							// jca 26 Oct 93 {				shadowSelectList = new(V_Array);				err = shadowSelectList->cArray(selectedList->ALength(), sizeof(CAVPolyhedron*), 1);				if (err)					{					delete(shadowSelectList);		// we failed the cArray; delete now					shadowSelectList = NULL;					}				else					{					err = selectedList->CopyArray(shadowSelectList);					if (err)						{						shadowSelectList->dArray();		// we failed the copy;  dArray						shadowSelectList = NULL;						}					}				// jca 26 Oct 93 }								NewSelect(NULL,TRUE);				clipBuf->IOSetPosition(0);				clipBuf->IOSetDirection(DATA_IN);				IO_ID(clipBuf,IFF_PRSM);				err = IO_OBJECT(clipBuf);				if(!err)					{					PastePosition();					controller->Request(NULL,msgEdit,objView,0);					#if VPRO					controller->Request(NULL,msgEdit,objTextureList,0);		// ABD TEXTURE					#endif // VPRO					}						if (err)	// jca 26 Oct 93 {					{	// if we can't duplicate the objects...					if (shadowSelectList != NULL)						{						int salvageErr = noErr;						salvageErr = shadowSelectList->CopyArray(selectedList);		// leave the last object selected						if (salvageErr)							selectedList->SetLength(0);		// inconceivable!						else							{	// all okay, save the info back							ppoly = (CAVPolyhedron**)shadowSelectList->Use();							for(i = 0; i < shadowSelectList->ALength(); i++)  								ppoly[i]->SetMode(IN_POLY);							shadowSelectList->Unuse();							ppc(controller)->Select(NULL,selectedList);									}						shadowSelectList->dArray();                        shadowSelectList = NULL;						}					else						selectedList->SetLength(0);		// fail gracefully					}                // 17MAY94 jca oops-- forgot to delete it				if (shadowSelectList)                	{					shadowSelectList->dArray();		// we failed the copy;  dArray					shadowSelectList = NULL;                    }				// jca 26 Oct 93 }				}			break; 				case  MSG_CUT:	/* Cut */			err = EditBuffer(MSG_COPY,modifiers);						// jca 20 Oct 93		case  MSG_CLEAR:	/* Clear */			length = selectedList->ALength();			if(!length) return(-1);			undoItem = NewUndoItem(UNDO_POLY_FLAG);			undoSpec = undoItem->cEditSpec(_EDIT_DESTROY);			if(modifiers&OPT_EDIT_MODE)((UPoly*)undoSpec)->SetInherit(FALSE);			ppoly = (CAVPolyhedron**)selectedList->Use();			for(i = 0; i < length; i++,ppoly++)  				undoItem->SetEditObject(*ppoly,NULL,UNDO_POLY_FLAG);			selectedList->Unuse();			selectedList->SetLength(0);			editList->SetLength(0);/* dude */			undoItem->Edit();			controller->Request(NULL,msgDestroy,objPolyhedron,0);			controller->Request(NULL,msgEdit,objTextureList,0);		// ABD WILLIAMS MERGE-TEXTURE 9/13/93			break;					case  MSG_UNDO:/* Undo */			undoItem = UndoItem();			undoType = undoItem->GetType();			if(UNDO_POLY_FLAG == undoType)				{				undoItems = new(V_Array);				undoItems->cArray(0,sizeof(CAVPolyhedron*),4);				undoType = undoItem->GetItems(UNDO_POLY_FLAG,undoItems);								undoItem->Reverse();				undoItem->Edit();				length = undoItems->ALength();				ppoly = (CAVPolyhedron**)undoItems->Use();				for(i = 0; i < length; i++,ppoly++)					{					mode = (*ppoly)->GetMode();					found = selectedList->Find(&(*ppoly));					if(OUT_POLY == mode)						{						if(0 <= found)							selectedList->Remove(found);						}					else						{						if(0 > found)							selectedList->Append(&(*ppoly));						}					}				undoItems->Unuse();				undoItems->dArray();				controller->Request(NULL,msgEdit,objPolyhedron,0);				controller->Request(NULL,msgEdit,objTextureList,0);		// ABD MERGE-TEXTURE 9/13/93				}			break; 		}	return(err);	}int gCurrentlyDoingIO = FALSE;	//MERGE-PRO-JAM-2 don't update walk and cad panes when doing iointDesignDraft::IO_OBJECT(V_Buffer *buf)	{	CAVPolyhedron	**ppoly,*npoly;	Unit	*unit,*worldUnit;	FFixed	factor;	long	id;	int		i,length,err;	extern struct TextureServer *gTextureServer;		// ABD MERGE-TEXTURE 9/13/93// REMOVE jca 19JAN94 	extern TextureArray *gAllTextures;		ASSERT(gCurrentlyDoingIO == 0);	//MERGE-PRO-JAM-2 we think IO_OBJECT is not reenterend, but it might be--this is to check	gCurrentlyDoingIO++;	err = 0;// REMOVE jca 19JAN94	gTextureServer->BeginTextureIO(buf, gAllTextures);      // ABD MERGE-TEXTURE 9/13/93	gTextureServer->BeginTextureIO(buf, pwc(controller->controller)->docTextures);      // jca 19JAN94 converted VR to PRO	if(buf->IODirection() == DATA_IN)		{			while (TRUE)			{			id = buf->OpenChunkR();			if (id == 0) break;						switch(id)				{				case IFF_VERS:					IO_VERS(buf);					break;// ABD MERGE-TEXTURE 9/13/93 [[[				case IFF_TXTB:	// texture table ABD TEXTURE					gTextureServer->IOTextureTable(buf, 0);	// purge textures param ignored on input					break;// ABD MERGE-TEXTURE 9/13/93 ]]]				case IFF_PGRP:				case IFF_PRSM:				case IFF_MESH:					npoly = new(CAVPolyhedron);					npoly->cPolyhedron(polyhedron->drawing);					if(IFF_PGRP == id) err = npoly->IOGroup(buf);		// jca 20 Oct 93					else err = npoly->IO(buf);							// jca 20 Oct 93					if (err)				// jca 20 Oct 93 {						{	// if there's an error (typically low memory)  get out						npoly->dPolyhedron();						npoly = NULL;						break;						}					// jca 20 Oct 93 }											if(!npoly->GetUnit())						{						unit = new(Unit);						unit->cUnit();						unit->SetSize(SI_INCH); 						npoly->SetUnit(unit);						unit->dUnit();						}					unit = npoly->GetUnit();					worldUnit = polyhedron->GetUnit();					factor = DblToFixed(unit->ConvertTo(worldUnit));					npoly->SetUnit(worldUnit);					selectedList->Append(&npoly);					break;				}					buf->CloseChunk();			}				length = selectedList->ALength();		if(!length) err = 1;		}	else		{			length = selectedList->ALength();		if(!length) err = 1;		else			{			/* load it up */			buf->OpenChunkW(IFF_VERS);			IO_VERS(buf);			buf->CloseChunk();		/* dude temp for demo purposes 			buf->OpenChunkW(IFF_VPRF);			observer->IO(buf);			buf->CloseChunk();				buf->OpenChunkW(IFF_LIBROOT);			polyhedron->IO_COLR(buf);			buf->CloseChunk();		dude temp for demo purposes */				ppoly = (CAVPolyhedron**)selectedList->Use();			unit = polyhedron->GetUnit();			for(i = 0; i < length; i++,ppoly++)				{				(*ppoly)->SetUnit(unit);				switch((*ppoly)->type)					{					case POLY_GROUP:						buf->OpenChunkW(IFF_PGRP);						(*ppoly)->IOGroup(buf);						buf->CloseChunk();						break;										case POLY_INFLATE:						buf->OpenChunkW(IFF_PRSM);						(*ppoly)->IO(buf);						buf->CloseChunk();						break;					case POLY_MESH:						buf->OpenChunkW(IFF_MESH);						(*ppoly)->IO(buf);						buf->CloseChunk();						break;					}				(*ppoly)->RemoveUnit();				}			selectedList->Unuse();	// ABD MERGE-TEXTURE 9/13/93 [[[			// write out texture table -- must be done after writing out objects			buf->OpenChunkW(IFF_TXTB);			gTextureServer->IOTextureTable(buf, TRUE);		// ABD TEXTURE purge textures			buf->CloseChunk();// ABD MERGE-TEXTURE 9/13/93 ]]]			}		}	gTextureServer->EndTextureIO(buf);		// ABD MERGE-TEXTURE 9/13/93	gCurrentlyDoingIO--;	return err;	}	voidDesignDraft::PastePosition()	{	CAVPolyhedron 	*leadPoly,**ppoly;	AppPreference	*prefs;	DefaultPreference	*defPrefs;	V_Array			*tmpList;	Point3DFFixed	ptMin,ptMax,ptOrigin,pointVector,baseVector;	Point3D			tmpMin;	PointFFixed		displace;	Point			p;	FFixed			bottom,floor,tmp;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	int				length,i;			tmpList = new(V_Array);	tmpList->cArray(0,sizeof(CAVPolyhedron*),4);	selectedList->CopyArray(tmpList);	selectedList->SetLength(0);			tmpList->Get(0,&leadPoly);	bottom = VFFMax;	length = tmpList->ALength();	ppoly = (CAVPolyhedron**)tmpList->Use();	for(i = 0; i < length; i++,ppoly++)		{		(*ppoly)->Extrema(&ptMin,&ptMax);		ptMin = environment->Translate3DFFixed(TO_CAD,ptMin);		ptMax = environment->Translate3DFFixed(TO_CAD,ptMax);		FFMin(tmp,ptMin.z,ptMax.z);		FFMin(bottom,bottom,tmp);		}	tmpList->Unuse();		prefs = controller->GetPreference();	defPrefs = (DefaultPreference*)prefs->GetPreference(preferDefaults);	ptMin = environment->Translate3DFFixed(TO_CAD,defPrefs->extrusionMin);	ptMax = environment->Translate3DFFixed(TO_CAD,defPrefs->extrusionMax);	FFMin(floor,ptMin.z,ptMax.z);	ptOrigin = leadPoly->posn->GetOrigin();	ptOrigin = environment->Translate3DFFixed(TO_CAD,ptOrigin);	displace = MakePtInWorld(ffLastPt,TRUE);	displace.h = FFSub(displace.h,ptOrigin.x);	displace.v = FFSub(displace.v,ptOrigin.y);	displace = SetToGrid(displace,pcc(controller)->GridUnit());	pointVector.x = displace.h;	pointVector.y = displace.v;	pointVector.z = FFSub(floor,bottom);	pointVector = environment->Translate3DFFixed(TO_WORLD,pointVector);										undoItem = NewUndoItem(UNDO_POLY_FLAG);	undoSpec = undoItem->cEditSpec(_EDIT_MOVE);	undoSpec->SetMark(0);	((UPolyMove*)undoSpec)->SetVector(Pt3DFFZero,pointVector);	undoSpec = undoItem->cEditSpec(_EDIT_CREATE);	((UPoly*)undoSpec)->SetContainer(polyhedron);	((UPoly*)undoSpec)->SetInherit(FALSE);	ppoly = (CAVPolyhedron**)tmpList->Use();	for(i = 0; i < length; i++,ppoly++)		{		(*ppoly)->SetLayer(pcc(controller)->GetLayer(),TRUE);		(*ppoly)->SetMode(IN_POLY);		undoItem->SetEditObject(*ppoly,NULL,UNDO_POLY_FLAG);		selectedList->Append(&(*ppoly));		}	tmpList->Unuse();		undoItem->Edit();	ppoly = (CAVPolyhedron**)tmpList->Use();	for(i = 0; i < length; i++,ppoly++)		ppc(controller)->NewPolyhedron(msgCreate,objDraft,*ppoly);	tmpList->Unuse();		tmpList->dArray();		controller->Request(NULL,msgEdit,objVirtRect,0);	}voidDesignDraft::DuplicatePosition(Position *relPosn,CAVPolyhedron *dupPoly)	{	CAVPolyhedron 	*original,*copy,**pPoly,**pPoly2;	Position 		*currPolyPos, *basePolyPos;   // jca 22FEB95 positions for the current feature and the base feature	V_Array			*tmpList;	Point3DFFixed	pointVector;	PointFFixed		displace;	Point			p;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	int				length,i;			undoItem = NewUndoItem(UNDO_POLY_FLAG);	tmpList = new(V_Array);	tmpList->cArray(0,sizeof(CAVPolyhedron*),4);	selectedList->Get(0,&original);	selectedList->CopyArray(tmpList);	selectedList->SetLength(0);	undoSpec = undoItem->cEditSpec(_EDIT_CREATE);	((UPoly*)undoSpec)->SetContainer(polyhedron);	((UPoly*)undoSpec)->SetInherit(FALSE);	length = tmpList->ALength();	pPoly = (CAVPolyhedron**)tmpList->Use();	pPoly2 = pPoly;		if(relPosn)		{		currPolyPos = new(Position);  // jca 22FEB95 changed variable name {{		currPolyPos->cPosition();		basePolyPos = new(Position);  // position for the poly we're basing off		basePolyPos->cPosition();    // jca 22FEB95 }}		for(i = 0; i < length; i++,pPoly++)			{			(*pPoly)->rPosn->Copy(currPolyPos);     // get the position of the current poly			dupPoly->rPosn->Copy(basePolyPos);  // get our base feature poly			currPolyPos->UnPosition(basePolyPos); // unposition our object (like using an inverse matrix)			currPolyPos->Copy((*pPoly)->rPosn);    // the position is now in base-space			(*pPoly)->rPosn->PositionX(relPosn);   // offset by the relative position			(*pPoly)->rPosn->PositionX(basePolyPos);// reposition the object in its poly space			(*pPoly)->UpdateMove();			}		currPolyPos->dPosition();		basePolyPos->dPosition();  // delete the vars		}	else		{		displace = pcc(controller)->GridUnit();		pointVector = environment->MakeVector(TO_WORLD,displace);		undoSpec = undoItem->cEditSpec(_EDIT_MOVE);		((UPolyMove*)undoSpec)->SetVector(Pt3DFFZero,pointVector);		}											pPoly = pPoly2;	for(i = 0; i < length; i++,pPoly++)		{		(*pPoly)->SetLayer(pcc(controller)->GetLayer(),TRUE);		(*pPoly)->SetMode(IN_POLY);		undoItem->SetEditObject(*pPoly,NULL,UNDO_POLY_FLAG);		selectedList->Append(&(*pPoly));		}		undoItem->Edit();	pPoly = pPoly2;	for(i = 0; i < length; i++,pPoly++)		ppc(controller)->NewPolyhedron(msgCreate,objDraft,*pPoly);		tmpList->Unuse();		tmpList->dArray();		controller->Request(NULL,msgEdit,objVirtRect,0);	}CAVPolyhedron *DesignDraft::GetSelectedPolyhedron()	{	CAVPolyhedron *theGuy;	if(selectedList->ALength())		selectedList->Get(0,&theGuy);	else		theGuy = polyhedron;		return(theGuy);	}void DesignDraft::RemoveTraceLayer(V_Array *list)	{		CAVPolyhedron *pPoly;	int	i,length;		length = list->ALength();	for(i = length-1 ; i >= 0; i--)		{		list->Get(i,&pPoly);		if(pPoly->container == tracePolyhedron)			list->Remove(i);		}	}PointFFixed DesignDraft::ObjectCenter(FFixed *depth)	{ 	CAVPolyhedron	**pPoly;	PointFFixed pt;	Point3D	pMin,pMax;	Point	p;	int	i,length;	length = editList->ALength();// DAS-VR/VWT/PRO-FIX 9/9/93	if(length==0)return CadDraft::ObjectCenter(depth);	pMin = Pt3DMax;	pMax = Pt3DMin;	pPoly = (CAVPolyhedron**)editList->Use();	for(i = 0; i < length; i++,pPoly++)		{		pMin.x = min(pMin.x,(*pPoly)->posnBoundMin.x);		pMin.y = min(pMin.y,(*pPoly)->posnBoundMin.y);		pMin.z = min(pMin.z,(*pPoly)->posnBoundMin.z);		pMax.x = max(pMax.x,(*pPoly)->posnBoundMax.x);		pMax.y = max(pMax.y,(*pPoly)->posnBoundMax.y);		pMax.z = max(pMax.z,(*pPoly)->posnBoundMax.z);		}	editList->Unuse();			pMin.x = pMin.x + ((pMax.x-pMin.x)>>1);	pMin.y = pMin.y + ((pMax.y-pMin.y)>>1);	pMin.z = pMin.z + ((pMax.z-pMin.z)>>1);		pt = PtFFZero;	*depth = FFZero;	pMin = environment->Translate3D(TO_CAD,pMin);	pt.h.intg = pMin.x;	pt.v.intg = pMin.y;	depth->intg = pMin.z;		return(pt);	}void DesignDraft::SetHome(Point3DFFixed newHome){ home = newHome; }voidMenuDesign::ctheMenu()	{	cMenu(TXTT_DESEDITOR,0);/* DUDE _ WRONG */	SetMenuEuroKey(menuDesignEuroKey);	MenuCad::ctheMenu();	AppendSeparator();		// ABD WILLIAMS MERGE11 9/11/93			#if !SPECIAL_EDITION         	// merge SE, vrmadness		// GJR 7/4/95	Append(TXTM_LAYERNEW);	Append(TXTM_LAYERDEL);	SetEuroKey(menuNewLayer, menuNewLayerEuroKey);	SetEuroKey(menuDeleteLayer, menuDeleteLayerEuroKey);#endif //!SPECIAL_EDITION		// merge SE, vrmadness		// GJR 7/4/95	Append(TXTM_GROUP);	Append(TXTM_UNGROUP);		SetKey(menuGroup,menuGroupKey);// MERGE-GOURAUD-PRO-7 #if !MACINTOSH	// ABD MERGE-BUG	// should not happen for mac because Mac does not show shift key equivalents in menu	SetKey(menuUngroup,menuUngroupKey);// MERGE-GOURAUD-PRO-7 #endif // !MACINTOSH	SetEuroKey(menuGroup, menuGroupEuroKey);	SetEuroKey(menuUngroup, menuUngroupEuroKey);	#if GERMAN	  SetKeyPos(menuNewLayer, menuNewLayerKeyPos);	  SetKeyPos(menuDeleteLayer, menuDeleteLayerKeyPos);	  SetKeyPos(menuUngroup, menuUngroupKeyPos);  	#elif SPANISH      #if VPRO		SetKeyPos(menuGroup, menuGroupKeyPos);	  #elif VR		SetKeyPos(menuUngroup, menuUngroupKeyPos);      #endif //VPRO	#endif // SPANISH	#if VRML_ANCHOR				// VRML-ABD 23JUN95	AppendSeparator();				Append(TXTM_VRML_ANCHOR);		#endif // VRML_ANCHOR		}voidMenuDesign::Preempt()	{	Activate(menuGroup, (controller->SelectedConditions() & SELECTED_CAN_GROUP) ? 1 : 0);	Activate(menuUngroup, (controller->SelectedConditions() & SELECTED_GROUP) ? 1 : 0);	#if VRML_ANCHOR				// VRML-ABD 23JUN95	Activate(menuDesVRMLAnchor, (pcc(controller)->cadDraft->selectedList->ALength() == 1) ? 1 : 0);	#endif // VRML_ANCHOR	MenuCad::Preempt();    }voidMenuDesign::Action(int num, long modifier)	{		switch (num)		{#if !SPECIAL_EDITION         	// merge SE, vrmadness		// GJR 7/4/95		case menuNewLayer: controller->Request(NULL,msgCreate,objList,0); break;		case menuDeleteLayer: controller->Request(NULL,msgDestroy,objList,0);break;#endif //!SPECIAL_EDITION		// merge SE, vrmadness		// GJR 7/4/95		case menuGroup:if(!(modifier&V_SHIFT)) { pcc(controller)->cadDraft->Grouping(TRUE); break; }		case menuUngroup: pcc(controller)->cadDraft->Grouping(FALSE); break;		#if VRML_ANCHOR				// VRML-ABD 23JUN95		case menuDesVRMLAnchor: 		{ 		Polyhedron	*the_obj;		WideInputTextDialog *dialog;		int			result;			char		newName[256];			if (pcc(controller)->cadDraft->selectedList->ALength() == 1)			{				pcc(controller)->cadDraft->selectedList->Get(0, &the_obj);				if (the_obj == NULL) break;		// should not happen				if (!the_obj->HasVRMLAnchor())					strcpy(newName, "");				else				{				V_Array *va = the_obj->GetVRMLAnchor();				char *c = (char *)va->Use();					strncpy(newName, c, va->ALength());					va->Unuse();					newName[va->ALength()] = '\0';				}				dialog = new(WideInputTextDialog);				if (dialog->cInputDialog(ANCHOR_URL,ANCHOR_URL_COLON,newName,inputText))					{						the_obj->SetVRMLAnchor(newName);					}								}		}				break;		#endif // VRML_ANCHOR		default: MenuCad::Action(num,modifier); break;		}	}// ABD MERGE-TEXTURE 9/13/93 [[[/*=========================================================================*	void DesignDraft::SetTexture( struct TextureItem *texture )*-------------------------------------------------------------------------*/void DesignDraft::SetTexture( struct TextureItem *texture )	/* ABD TEXTURE */	{	CAVPolyhedron	**pPoly,*leadPolyhedron;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	int				i,length;	VGrafPort testPort; VGrafDevice testDevice;	// MERGE-VPRO-2 test and restore port	VGetPort(&testPort, &testDevice);	// MERGE-VPRO-2 test and restore port		if(!(length = selectedList->ALength())) return;	selectedList->Get(0,&leadPolyhedron);		undoItem = NewUndoItem(UNDO_POLY_FLAG);	undoSpec = undoItem->cEditSpec(_EDIT_TEXTURE);	undoSpec->SetMark(-1);	((UPolyTexture*)undoSpec)->SetTexture(texture,SURF_SHARED);		length = selectedList->ALength();	pPoly = (CAVPolyhedron **)selectedList->Use();	for(i = 0; i < length; i++,pPoly++)		{		undoItem->SetEditObject(*pPoly,NULL,UNDO_POLY_FLAG);		}	selectedList->Unuse();		undoItem->Edit();		if(TRUE)		// еее if undoItem->UpdateEditor()		{		pPoly = (CAVPolyhedron **)selectedList->Use();		for(i = 0; i < length; i++,pPoly++)			controller->EditPolyhedron(*pPoly,objPolygon);		selectedList->Unuse();		}	  	controller->Request(NULL,msgEdit,objPolyhedron,0);	VGetPort(&testPort, &testDevice);	// MERGE-VPRO-2 test and restore port	// еее update the list pane 	#if VPRO	ppc(controller)->GetTextureList()->Reset();	#endif // VPRO	VGetPort(&testPort, &testDevice);	// MERGE-VPRO-2 test and restore port	}// ABD MERGE-TEXTURE 9/13/93 ]]]// ABD MERGE-GOURAUD [[[/*=========================================================================*	void DesignDraft::SetShadeType( unsigned char do_gouraud )*-------------------------------------------------------------------------*/void DesignDraft::SetShadeType( unsigned char shade_type )		{	CAVPolyhedron	**pPoly,*leadPolyhedron;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	int				i,length;		if(!(length = selectedList->ALength())) return;	selectedList->Get(0,&leadPolyhedron);		undoItem = NewUndoItem(UNDO_POLY_FLAG);	undoSpec = undoItem->cEditSpec(_EDIT_GOURAUD);	undoSpec->SetMark(-1);	((UPolyGouraud*)undoSpec)->SetShadeType(shade_type,SURF_SHARED);		length = selectedList->ALength();	pPoly = (CAVPolyhedron **)selectedList->Use();	for(i = 0; i < length; i++,pPoly++)		{		undoItem->SetEditObject(*pPoly,NULL,UNDO_POLY_FLAG);		}	selectedList->Unuse();		undoItem->Edit();		if(TRUE)		{		pPoly = (CAVPolyhedron **)selectedList->Use();		for(i = 0; i < length; i++,pPoly++)			controller->EditPolyhedron(*pPoly,objPolygon);		selectedList->Unuse();		}	  	controller->Request(NULL,msgEdit,objPolyhedron,0);	}// ABD MERGE-GOURAUD ]]]#if VRML_ANCHOR		// ABD PRO25 AUG95voidDesignDraft::DrawURL(Point p, int redraw_only){Rect r;CAVPolyhedron	*foundPoly = NULL;PointLong	sp;	if (!redraw_only)	{		sp.h = lOrigin.h + p.h;		sp.v = lOrigin.v + p.v;			foundPoly = polyhedron->FindWithNoSideEffects(&sp,environment,polyhedron,FIND_NORMAL);	}	else		foundPoly = lastVRMLPoly;		// only draw if we are supposed to redraw, or the item is different	if (redraw_only || (foundPoly != lastVRMLPoly))	{		r = dataRect;				#if WINDOWS		r.bottom -= 17;		#endif				r.bottom++;		r.left--;		r.right++;		r.top = r.bottom - 18;		if (depth >= 4)		{		#if MACINTOSH		RGBColor col = {0xB800,0xB800,0xB800};		#elif WINDOWS		RGBColor col = {0xC000,0xC000,0xC000};		#else 		#error Mac or Windows?		#endif						VForeColor(&vBlack);			VFrameRect(&r);			r.left	+=1;	r.top	+=1;			r.bottom-=1;	r.right	-=1;			VForeColor(&col);			VPaintRect(&r);		}		else		{			VFrameRect(&r);				r.left	+=1;	r.top	+=1;			r.bottom-=1;	r.right	-=1;			VEraseRect(&r);		}		if (foundPoly && foundPoly->HasVRMLAnchor())		{		char *str;			TextSetUp(vAppFont,vMediumFont,vNormal);			r.bottom -= 5;			r.left += 3;			str = (char *)foundPoly->vrml_anchor->Use();						if (depth >= 4)			{			#if MACINTOSH			RGBColor col = {0xDDDD,0xDDDD,0xDDDD};			#elif WINDOWS			RGBColor col = {0xDDDD,0xDDDD,0xDDDD};			#else 			#error Mac or Windows?			#endif							VForeColor(&col);						r.left++;					r.top++;					r.right++;				r.bottom++;				#if WINDOWS				VTextMode(vSrcXor);				#endif				VDrawText(str,0,foundPoly->vrml_anchor->ALength(),&r);				r.left--;					r.top--;							r.right--;				r.bottom--;			}						VForeColor(&vBlack);					#if WINDOWS			VTextMode(vSrcXor);			#endif			VDrawText(str,0,foundPoly->vrml_anchor->ALength(),&r);			foundPoly->vrml_anchor->Unuse();			}		else		{		char str[256] = "";			TextSetUp(vAppFont,vMediumFont,vNormal);			r.bottom -= 5;			r.left += 3;						if (depth >= 4)			{			#if MACINTOSH			RGBColor col = {0xDDDD,0xDDDD,0xDDDD};			#elif WINDOWS			RGBColor col = {0xDDDD,0xDDDD,0xDDDD};			#else 			#error Mac or Windows?			#endif							VForeColor(&col);						r.left++;					r.top++;					r.right++;				r.bottom++;				#if WINDOWS				VTextMode(vSrcXor);				#endif				VDrawText(str,0,strlen(str),&r);				r.left--;					r.top--;							r.right--;				r.bottom--;			}						VForeColor(&vBlack);					#if WINDOWS			VTextMode(vSrcXor);			#endif			VDrawText(str,0,strlen(str),&r);		}		lastVRMLPoly = foundPoly;	}}#endif // VRML_ANCHOR