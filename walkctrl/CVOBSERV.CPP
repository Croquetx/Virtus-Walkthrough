/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  * Platform: 	MACINTOSH 	X *				WINDOWS		X *------------------------------------------------------------------------------ */#include "VTypes.h"#include "CVObserv.h"#include "SinTable.h"#include "Misc.h"#include "AppText.h"#include "CVDefs.h"#include "CVEnvirn.h"#include "CVWCntrl.h"#include "CVPolyh.h"#include "PolyConv.h"#include "Drawing.h"#include "VButton.h"#include "VGraphic.h"#include "VMath.h"#include <stdlib.h>FFixed	convAngle = INITFIXXED(40,0xBE61);void CAVObserver::cView(WalkDrawing *dwg)	{		Observer::cView(dwg);	oA = SIDE_OBSERVER;	oB = TOP_OBSERVER;	}CAVPolyhedron * CAVObserver::GetRoom()	{		return((CAVPolyhedron*)viewPoly->polyhedron);	}	int CAVObserver::Find(Point *p,CAVEnvironment *environment)	{	PointLong 		origin;		Point3DLong		center;	origin = environment->GetDrawOrigin();	center = environment->WorldToView(FFpoint);		center.x -= origin.h;	center.y -= origin.v;		if(abs(p->h - center.x) > 8 || abs(p->v - center.y) > 8 ) return(FALSE);		p->h = center.x;		p->v = center.y;			return(TRUE);	}Angle3DFFixed CAVObserver::GetObserverRotation()	{			Angle3DFFixed	result;		result.roll = FFDiv(FFangle.roll,convAngle);	result.pitch = FFDiv(FFangle.pitch,convAngle);	result.yaw = FFDiv(FFangle.yaw,convAngle);	return(result);	}void CAVObserver::ObserverRotation(Angle3DFFixed newAngle)	{				newAngle.roll = FFMult(convAngle,newAngle.roll);	newAngle.pitch = FFMult(convAngle,newAngle.pitch);	newAngle.yaw = FFMult(convAngle,newAngle.yaw);	lastPoint = FFpoint;	SetFFAngle(newAngle);	}void CAVObserver::ObserverTranslation(Point3DFFixed newPoint)	{	lastAngle = FFangle;	newPoint = FF3DAdd(newPoint,FFpoint);	SetFFPoint(newPoint);	if(TRUE == record) 		RecordPosition();	}void CAVObserver::HiliteObserver(CAVEnvironment *environment,Point last,int type)	{	Rect	r,body;	Point3DLong	where;	PointLong	origin;	switch(type)		{		case ROTATE_EYE:			origin = environment->GetDrawOrigin();			where = environment->WorldToView(FFpoint);			VMoveTo(where.x-origin.h,where.y-origin.v);			VLineTo(last.h,last.v);			break;		case MOVE_EYE:			body.left = last.h - 7;			body.right = body.left+15;			body.top = last.v - 7;			body.bottom = body.top+15;			VMoveTo(body.left+5,body.top);			VLineTo(body.left+10,body.top);			VLineTo(body.right,body.top+5);			VLineTo(body.right,body.top+10);			VLineTo(body.left+10,body.bottom);			VLineTo(body.left+5,body.bottom);			VLineTo(body.left,body.top+10);			VLineTo(body.left,body.top+5);			VLineTo(body.left+5,body.top);			break;		}		}void CAVObserver::MoveObserver(CAVEnvironment *environment)	{		Angle3D	agl;	 	TextSetUp(vButtonFont,vButtonFontSize,vNormal);		VTextMode(vSrcXor); 	VPenMode(vPatXor);	VSetPattern(vPatBlack);		agl.roll = lastAngle.roll.intg;	agl.pitch = lastAngle.pitch.intg;	agl.yaw = lastAngle.yaw.intg;		DrawObserver(environment,lastPoint,agl);	DrawObserver(environment,FFpoint,angle);	VPenMode(vPatCopy); 	VTextMode(vSrcOr);	}		void CAVObserver::Display(CAVEnvironment *environment)	{		TextSetUp(vButtonFont,vButtonFontSize,vNormal);		VTextMode(vSrcXor); 	VPenMode(vPatXor);	VSetPattern(vPatBlack);	DrawObserver(environment,FFpoint,angle);	VPenMode(vPatCopy); 	VTextMode(vSrcOr);	}void CAVObserver::Select(CAVEnvironment *environment)	{		Rect	body;	Point3DLong	where;		PointLong	origin;	Point	center;		return;		VPenMode(vPatXor);	VSetPattern(vPatGray);	VForeColor(&vBlack);		origin = environment->GetDrawOrigin();	where = environment->WorldToView(FFpoint);	center.h = where.x - origin.h;	center.v = where.y - origin.v;	body.left = center.h - 12;	body.right = center.h + 12;	body.top = center.v - 12;	body.bottom = center.v + 12;					VMoveTo(body.left,body.top+1);	VFrameOval(&body);	VPenMode(vPatCopy);	VSetPattern(vPatBlack);		}void CAVObserver::DrawObserver(CAVEnvironment *environment,Point3DFFixed pt,Angle3D agl)	{		char		c;	Rect		body;	Point3DLong	where;		PointLong	origin;	Point		center,eye;	int			direction;		Rect		r;	origin = environment->GetDrawOrigin();	where = environment->WorldToView(pt);	switch(environment->GetAxis())		{		case INFL_Z: direction = agl.yaw+32; 	c = 0; break;		case INFL_Y: direction = -agl.roll+32; 	c = 1; break;		case INFL_X: direction = agl.pitch-32; 	c = 1; break;		}			center.h = where.x - origin.h;	center.v = where.y - origin.v;	eye.h = ((8 * (cos256(direction) - sin256(direction))) +64) >> 7;	eye.v = ((8 * (sin256(direction) + cos256(direction))) +64) >> 7;				VForeColor(&vBlack);#if MACINTOSH	body.left = center.h-7;	body.bottom = center.v-3;	body.top = body.bottom;//-vButtonFontSize;	if(c == 0) c = oA;	else c = oB;	VDrawChar(c,&body);#endif //MACINTOSH    /*draw the direction arrow*/	VMoveTo(center.h,center.v);	VLineTo(center.h + eye.h,center.v - eye.v);	/*draw the small character icon*/	r.top=r.left=0;	r.bottom=r.right=16;#if WINDOWS	body.left = center.h-7;	body.right = body.left+16;	body.top = center.v-7;	body.bottom=body.top+16;	/* if the currentscreen is defined, use that, otherwise, use the currentPane...		this is not a particularly good way to do this, but the observer does not        know where the pane is nor what its state is. DAS */	((CAVWalkController*)controller)->sIcon[c]->MetaToMode(currentscreen?(V_Display*)currentscreen:(V_Display*)currentPane,&r,&body,SRCINVERT);#endif //WINDOWS	}