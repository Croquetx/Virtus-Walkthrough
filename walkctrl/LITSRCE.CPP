/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VPane.h"#include "LitSrce.h"#include "LitSItem.h"#include "LitCntrl.h"#include "Light.h"#include "Polyhdrn.h"#include "VMDL.h"#include "AppMssgs.h"#include "AppDeflt.h"#include "PopColor.h"#include "CVWCntrl.h"#include "BallHelp.h"#include "Misc.h"#include "VGUtil.h"#include "VError.h"extern	struct V_Buffer *clipBuf;/* in WalkThrough.c *//*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/void LightSource::SetController(Controller *ctrl)	{	int		i,length;		WalkList::SetController(ctrl);	if(length = theList->ALength())		{		SourceItem	**nSource = (SourceItem	**)theList->Use();		for(i = 0; i < length; i++,nSource++)			(*nSource)->SetController(controller);		theList->Unuse();		}	}void LightSource::SetLightModel(LightModel *plights, struct Controller *c)	{	SourceItem *source;	Light *ldata,*ndata;	int i;		controller=c;	WalkList::SetController(c);	if(!lights)/*this should be guaranteed*/		{		/*if there is anything in the list, dump it here*/		if(lights)lights->dLightModel();		lights=plights;		Clean();		/* load up the theList here */		for(i=0;i<lights->ALength();i++)			{			ldata=lights->GetLight(i);			source=new(SourceItem);			source->cListItem(ldata);			source->SetController(controller);			theList->Append(&source);/*remember that lists are actually panes and that										the Append assumes something else.*/			}		selection=-1;	/* outside of bounds on purpose *//*		SetSelection(0);/* sets the selection to the first guy */		}	}			struct LightModel *LightSource::GetLightModel(void)	{	return lights;	}voidLightSource::TrackHelp(Point pt,long modifier)// DAS-VWINDOWS 9/30/93	{// { DAS-VR-HELP 9/30/93#if VWT	Rect r;		r = dataRect;	BalloonHotRect(&r,pt);	Bubble(pt,&r,TXTB_LIGHTLIST);#endif// } DAS-VR-HELP 9/30/93	}voidLightSource::Clean(void)	{	SourceItem *source;	while(theList->ALength())		{		theList->Get(0,&source);		source->dListItem();		theList->Remove(0);		}	}intLightSource::AddItem()	{	Light *ldata;		ldata=new(Light);	ldata->cLight();	lights->Append(&ldata);	AddLight(ldata);		return(TRUE);	}voidLightSource::AddLight(Light *ldata)	{	SourceItem *source;		source=new(SourceItem);	source->cListItem(ldata);	source->SetController(controller);		theList->Append(&source);	SetSelection(theList->ALength()-1);	controller->Request(source->light,msgDraw,0,0);	Reset();	}/*========================================================================= * int LightSource::RemoveItem() *-------------------------------------------------------------------------*/intLightSource::RemoveItem()	{	SourceItem *source;	if(theList->ALength())		{		if(source=(SourceItem *)GetCurrentItem())			{			/* dude			if(!WalkWarning(TXTW_LITDEL,1,FALSE))				return(FALSE);			*/			lights->RemoveLight(source->light);			source->light->dLight();			WalkList::RemoveItem();			controller->Request(NULL,msgDraw,0,0);			}		}		return(TRUE);	}	intLightSource::GetHeight(void){return 13;}#if WINDOWSstatic int IsThePopUpUp=0; 	//jca--under Windows, the pop should only happen once.#endifvoid LightSource::MenuSelection(Point p,long modifiers)	{	AppPreference		*appPref;	DefaultPreference	*defPref;	SourceItem *thelight;	RGBColor color,oldColor;	Rect purportedAvoidR={0,0,0,0};#if WINDOWS	Point	pointLoc;	if (IsThePopUpUp)	return;	else IsThePopUpUp = 1;        	/* we'd like to avoid this button thing, but we can't get its size	So, we're going to approximate the size of the button */	pointLoc = p;	LocalToGlobal(&pointLoc);	purportedAvoidR.left = pointLoc.h - 15;	purportedAvoidR.right = pointLoc.h + 15;	purportedAvoidR.top = pointLoc.v - 6;	purportedAvoidR.bottom = pointLoc.v + 6;	p.v -= 4;	p.h += 5;		// move the color picker up and to the right#endif	thelight = (SourceItem *)GetCurrentItem();	oldColor = color = thelight->light->color;	appPref = controller->GetPreference();	defPref = (DefaultPreference*)appPref->GetPreference(preferDefaults);	if(defPref->popColor->Pop(p,&color,&purportedAvoidR))		{		if((oldColor.red != color.red) || (oldColor.green != color.green) || (oldColor.blue != color.blue))			plc(controller)->SetChange(TRUE);		thelight->light->color=color;		controller->Request(thelight->light,msgDraw,0,0);		}#if WINDOWS	IsThePopUpUp=0;#endif	}/*=========================================================================*-------------------------------------------------------------------------*/void LightSource::SelectPane(int tf)	{	ListItem *theItem;		theItem = GetCurrentItem();	if(theItem)		{		SetPane();		theItem->Display();		theItem->Hilite(tf?TRUE:FALSE);		if(!tf) selection=-1;		UnsetPane();		}	}/*=========================================================================*-------------------------------------------------------------------------*/voidLightSource::SendLight(void)	{	SourceItem *theItem;	Light *light;		if(selection>=0 && selection<theList->ALength())		{		theList->Get(selection,&theItem);		light=theItem->light;		controller->Request(light,msgDraw,selection,0);/*active and vector*/		}}int LightSource::KeyAction(char c,long modifiers)	{	if((buttonDown & modifiers)) return(FALSE);	switch((unsigned char)c)		{			case V_DELETE: 	return((EditBuffer(MSG_CLEAR,modifiers) < noErr) ? FALSE : TRUE); break;		default: return(FALSE); break;		}			return(TRUE);	}int LightSource::GetAction(long action,long modifiers)	{		switch(action)		{			case  MSG_CUT:		case  MSG_COPY:		case  MSG_DUPLICATE:		case  MSG_PASTE:		case  MSG_UNDO: 		case  MSG_CLEAR:			return((EditBuffer(action,modifiers) < noErr) ? FALSE : TRUE); break;		default: return(FALSE); break;		}		 return(TRUE);	 }int LightSource::EditBuffer(long type,long modifiers)	{	int err = noErr;			switch(type)		{		case  MSG_COPY:	/* Copy 		*/			clipBuf->IOSetLength(0);			clipBuf->IOSetPosition(0);			clipBuf->IOSetDirection(DATA_OUT);			IO_ID(clipBuf,IFF_LGHT);			IO_VERS(clipBuf);			IO_ELGT(clipBuf);			break;				case  MSG_DUPLICATE:	/* Duplicate 	*/			err = EditBuffer(MSG_COPY,modifiers);			if (err < noErr) break;				err = EditBuffer(MSG_PASTE,modifiers);			controller->Request(this,msgEdit,objPolyhedron,0);			break;					case MSG_PASTE:	/* Paste 		*/			clipBuf->IOSetPosition(0);			clipBuf->IOSetDirection(DATA_IN);			IO_ID(clipBuf,IFF_LGHT);			IO_VERS(clipBuf);			IO_ELGT(clipBuf);			controller->Request(this,msgEdit,objPolyhedron,0);			break;		case MSG_CUT:	/* Cut 			*/			err = EditBuffer(MSG_COPY,modifiers);		case  MSG_CLEAR:	/* Clear 		*/			RemoveItem();			break;		}	return(err);	}/*=========================================================================*	int LightSource::IO_ELGT(V_Buffer *buf)*-------------------------------------------------------------------------*/intLightSource::IO_ELGT(V_Buffer *buf)	{	Light 	*light = NULL;	long	id;	int		length,i,first;	int 	err = noErr;			if(buf->IODirection() == DATA_IN)		{				while (TRUE)			{			id = buf->OpenChunkR();			if (id == 0) break;						switch(id)				{				case IFF_LGHT:					light = new(Light);					light->cLight();					light->IO(buf);					lights->Append(&light);					break;										case IFF_ELGT: light->IO_ELGT(buf); break;				default: break;				}					buf->CloseChunk();			}		if(light) AddLight(light);			}	else		{			SourceItem	*item = (SourceItem	*)GetCurrentItem();			if(item)			{			light = item->light;						buf->OpenChunkW(IFF_LGHT);			light->IO(buf);			buf->CloseChunk();			buf->OpenChunkW(IFF_ELGT);			light->IO_ELGT(buf);			buf->CloseChunk();			}		}	return(err);	}