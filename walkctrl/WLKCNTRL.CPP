/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "WlkCntrl.h"#include "VwCntrl.h"#include "Drawing.h"#include "View.h"#include "Light.h"#include "CVPolyh.h"#include "Observer.h"#include "ToolDef.h"#include "Unit.h"#include "AppDeflt.h"#include "Informtn.h"#include "VMath.h"#include "Library.h"#include "VFile.h"#include "VWindow.h"#include "VDocumnt.h"#include "VGUtil.h"#include "VPane.h"#if VPRO#include "GETFOLD.h"#include "AppFiles.h"#endif // VPRO#include "AppText.h"#include "TextSrvr.h"		/* ABD MERGE-TEXTURE 9/13/93 */#include "TextArry.h"		/* ABD MERGE-TEXTURE 9/13/93 */#include <stddef.h>#include <string.h>#include <stdio.h>#if VPROintWalkController::AddTextures(void)		// ABD TEXTURE{#if MACINTOSHFSSpec fSpec;VfsLocation *vfs;int result = 0;int i;int rval;	vfs = new(VfsLocation);    vfs->cVfsLocation();	result = AddTexturesDialog(&fSpec);		for (i=0;i<63;i++)vfs->name[i] = fSpec.name[i];	P2Cstr(vfs->name);	vfs->directory = fSpec.parID;	vfs->volume = fSpec.vRefNum;	vfs->alias = NULL;	rval = TRUE;		if (result == ADD_TEXTURES_FOLDER)		docTextures->LoadTexturesInDir(vfs);	else if (result == ADD_TEXTURES_FILE)		docTextures->LoadTexture(vfs);	else		rval = FALSE;     vfs->dVfsLocation();	Request(NULL, msgUpdate, objObserver, 0);	//MERGE-PRO-JAM-3	return rval;	#else//FSSpec fSpec;VfsLocation *vfs;int result = 0;int i;char str[256];V_File *file;int err;//JAM PORTTOWINQQQV_Array *filelist;int returnval = TRUE;//#error we need to get a VfsLocation with a folder in it	vfs = new(VfsLocation);    vfs->cVfsLocation();	filelist = new(V_Array);	filelist->cArray(0,sizeof(VfsLocation *),8);	err = VfsGetListOfTextures(filelist);	if(!err)    {		docTextures->AddListOfTextures(filelist);	}	else	{    	returnval = FALSE;	}	{		VfsLocation **vfsl;		vfsl = (VfsLocation **)filelist->Use();		for(i=0;i<filelist->ALength();i++)		{			vfsl[i]->dVfsLocation();		}		filelist->Unuse();    }	filelist->dArray();    vfs->dVfsLocation();	return(returnval);#endif}#endif // VPROvoidWalkController::cController(V_Document *doc)	{		ModelPreference		*modelPref;	extern TextureArray *gAllTextures;	Controller::cController(doc);		appChange = FALSE;	appPreferences = new(AppPreference);	appPreferences->cAppPreference();	appPreferences->MakeDefault(LOAD);	modelPref = (ModelPreference*)appPreferences->GetPreference(preferModeler);		drawing = NewDrawing();	drawing->cWalkDrawing(this);	root = drawing->polyhedron;	root->SetColor(modelPref->skyColor,0xFFFF,SURF_SHARED);		controllers = new(V_Array);	controllers->cArray(0,sizeof(Controller*),4);	toolChest = new(V_Array);	toolChest->cArray(0,sizeof(ToolDef*),4);	#if VR	// jca 19JAN94  if this is VR, set docTextures to gALLTextures (if    // gAllTextures exists.  Otherwise, do docTextures (and ASSERT)	if (gAllTextures)		docTextures = gAllTextures;	else		{  // fall back, reasonably gracefully.		ASSERT(gAllTextures);		// ABD TEXTURE make a texture array		docTextures = new(TextureArray);		// ABD MERGE-TEXTURE 9/13/93		docTextures->cTextureArray();		// ABD MERGE-TEXTURE 9/13/93		docTextures->SetController((struct CAVWalkController *)this);		// ABD MERGE-TEXTURE 9/13/93    	}#else // multiple documents	// ABD TEXTURE make a texture array	docTextures = new(TextureArray);		// ABD MERGE-TEXTURE 9/13/93	docTextures->cTextureArray();		// ABD MERGE-TEXTURE 9/13/93	docTextures->SetController((struct CAVWalkController *)this);		// ABD MERGE-TEXTURE 9/13/93#endif // VR	lastController = this;	fullFlag = FALSE;		SetType(toolCRTLWalk);	observer = (Observer*)cTool(this,toolTView);			#if (!VPLAYER)	InitInfo(this);#endif // !VPLAYER	SetController(this);	SetPreference(appPreferences,TRUE);		Request(NULL,msgInit,objDefaults,0);	}	voidWalkController::dController()	{	Controller	**pctrl;	ToolDef	**toolDefinition;	int		i,length;		length = controllers->ALength();	pctrl = (Controller	**)controllers->Use();	for(i=0; i < length; i++,pctrl++) 		(*pctrl)->dController();			controllers->Unuse();	length = toolChest->ALength();	toolDefinition = (ToolDef	**)toolChest->Use();	for(i=0; i < length; i++,toolDefinition++) 		(*toolDefinition)->dToolDef();			toolChest->Unuse();			controllers->dArray();	controllers = NULL;		// ABD MERGE-HMD set controllers to NULL							// so FindController() won't try to use it accidentally							// (FindController() could be called by observer->dView()							// depending on the type of HMD we have)	toolChest->dArray();			//JAM MEMLEAK 2JAN95 moved code down to just before ::dcontroller()//#if !VR  // jca 19JAN94 everyone but VR does textures by document (VR has a global)//	// delete our texture array//	docTextures->dTextureArray();		// ABD MERGE-TEXTURE 9/13/93//#endif // !VR	drawing->dWalkDrawing();	observer->dView();	appPreferences->dAppPreference();//JAM MEMLEAK 2JAN95 [[[#if !VR  // jca 19JAN94 everyone but VR does textures by document (VR has a global)	// delete all the texture items in the texture array	docTextures->dTextureItemsInTextureArray();	// delete our texture array	docTextures->dTextureArray();		// ABD MERGE-TEXTURE 9/13/93#endif // !VR//JAM MEMLEAK 2JAN95 ]]]	Controller::dController();	}	Controller * WalkController::GetFrontController() { return(lastController); }int WalkController::Changed() { 	return(appChange); }	void WalkController::SetChange(int changed) { appChange = changed; }	intWalkController::React(V_Window *whichWindow,int state)	{	V_Window	*window;	ToolDef		*toolDef;	Controller	*ctrl;	int			ctrlType = type,length,i,found;			length = toolChest->ALength();	for(i = 0; i < length; i++)		{		toolChest->Get(i,&toolDef);		if(whichWindow == toolDef->GetWindow())			{			ctrlType = toolDef->GetType();			switch(ctrlType)				{				case toolCRTLLibrary:				case toolCRTLView: 					ctrl = (Controller*)toolDef->GetTool(); 					switch(state)						{						case HIDE: /* HIDE */ 								case ACTIVATE: /* ACTIVATE */							if( lastController != ctrl )								{								if(lastController->GetType() == ctrl->GetType()) 									ctrl->Activate(msgInit);								else ctrl->Activate(msgReset);								}							lastController = ctrl;							break;													case DEACTIVATE: /* DEACTIVATE */ break;												case CLOSE: /* DESTROY */							found = controllers->Find(&ctrl);							if(VARY_NOTFOUND != found)								controllers->Remove(found);							ctrl->dController();							lastController = this;							toolChest->Remove(i);							toolDef->dToolDef();							if(!controllers->ALength())  								ctrlType = toolCRTLWalk;							break;						}					break;									default: 						return(-1);					break;				}			break; /* out of the if loop */			}		}			return(ctrlType);	}voidWalkController::LaunchController( LaunchInit launchInit , int type )	{	Controller			*ctrl,**pctrl;	ToolDef				*toolDef;	V_Window			*window = NULL;	Information			*information;	Rect				r;	int					i,length;		r = launchInit.location;	switch(type)		{					case toolCRTLLibrary:		case toolCRTLView:			ctrl = FindController(type);			if(ctrl)				{				window = ctrl->GetWindow(type);				window->Select();						pvc(ctrl)->SetView(observer);				return;				}			ctrl = NewViewController();			pvc(ctrl)->SetView(observer);			break;				}		information = new(Information);	information->cInformation();	ctrl->information = information;	ctrl->SetController(this);	ctrl->SetType(type);	ctrl->cController(document);	InitInfo(ctrl);	ctrl->Activate(msgCreate);	toolDef = new(ToolDef);	toolDef->cToolDef(ctrl,type);	window = ctrl->GetWindow(type);#if VPLAYER	ctrl->SetTitle(title);#else	window->Move(&r);#endif //VPLAYER	toolDef->SetWindow(window);	toolChest->Append(&toolDef);	controllers->Append(&ctrl);	ctrl->Response(NULL,msgInit,objDefaults,0);		if(window)			{		document->React(window,ACTIVATE);#if WINDOWS	//ABD 24MAY94 This line causes libraries not to show in macintosh		if (type != toolCRTLLibrary)    // 17MAY94 jca don't show the library here; do it when it's ready.  //BILBIL VR don't show th galleries here.#endif			window->Show();		}	}		voidWalkController::SetTitle(char *name)	{	Controller	**pctrl;	char 		str[256];	int			i,length;		strcpy(str,name);	Controller::SetTitle(str);	strcpy(str,title);	length = controllers->ALength();	pctrl = (Controller	**)controllers->Use();	for(i = 0; i < length; i++,pctrl++) 		(*pctrl)->SetTitle(str);	controllers->Unuse();	}voidWalkController::InitInfo(Controller *ctrl)	{	ctrl->information->polyhedron = pcp(root);/* dude */	ctrl->information->observer = observer;/* dude */	}		voidWalkController::Request(void *val,int action,int who,int scope)	{	AppPreference		*appPref;	DefaultPreference	*defPref;	UnitPreference		*unitPref;	NavigatePreference	*navPref;	ModelPreference		*modelPref;	Controller	**pctrl;	V_Buffer	*buffer;	Unit	*unit;	Light	*l;	LightModel	*lm;	Point3DFFixed defStart;	int		i,length;		switch(action)		{		case msgDestroy:			if( objIO == who )				{				root->SetLightModel(NULL);				root->RemoveUnit();				}			break;					case msgInit:#if (!VPLAYER)			switch(who)				{				case objIO:					unit = root->GetUnit();					if(!unit)						{						unit = new(Unit);						unit->cUnit();							unit->SetSize(SI_INCH);							root->SetUnit(unit);						}											break;								case objDefaults:					appPref = GetPreference();					defPref = (DefaultPreference*)appPref->GetPreference(preferDefaults);					unitPref = (UnitPreference*)appPref->GetPreference(preferUnits);					navPref = (NavigatePreference*)appPref->GetPreference(preferNavigate);					modelPref = (ModelPreference*)appPref->GetPreference(preferModeler);					root->RemoveUnit();					unit = new(Unit);					unit->cUnit();						unit->SetSize(unitPref->unitSize);					root->SetUnit(unit);					unit->dUnit();        // jca 21APR94 root->SetUnit(unit) makes a copy of unit for root.  We must delete unit here.					SetPosition(defPref->homePosition,Ang3DFFZero);					SetFocalValue(navPref->focalLength,navPref->filmWidth);							root->SetLightModel(NULL);					lm = root->GetLightModel();					/* make sure lm is empty */					modelPref->lights->Copy(lm);					break;				}#endif //!VPLAYER			break;		}			length = controllers->ALength();	pctrl = (Controller	**)controllers->Use();	for(i = 0; i < length; i++,pctrl++) 		(*pctrl)->Response(val,action,who,scope);	controllers->Unuse();	}	intWalkController::Empty()	{	if(!drawing) return FALSE;  /* DAS changed 11/12/90 */	if(root->contents)		return(FALSE);	else		return(TRUE);	}voidWalkController::SetPosition(Point3DFFixed newView, Angle3DFFixed newAngle)	{	observer->SetPosition(newView,newAngle); 	}voidWalkController::GetPosition(Point3DFFixed *newView,Angle3DFFixed *newAngle)	{	observer->GetPosition(newView,newAngle);	}	voidWalkController::PlayBack()	{	observer->Record(FALSE,FALSE);	if(!observer->SetFrame(0))		{		controller->Request(NULL,msgUpdate,objObserver,0); 		observer->Walk();		}	}voidWalkController::ObserverRecord(int newstate)	{	int flush;	if(newstate) flush = TRUE; else flush = FALSE;	observer->Record(newstate,flush);	}voidWalkController::SetFocalValue(int newFocalLength,int newFilmWidth)	{	observer->SetFocalValue(newFocalLength,newFilmWidth);	}		void *WalkController::cTool(Controller *ctrl,int toolType)	{	V_Window	*window;	ToolDef		*toolDefinition;	Observer	*newObserver;	void		*tool = NULL;	int			i,length;		length = toolChest->ALength();	for(i = 0; i < length; i++)		{		toolChest->Get(i,&toolDefinition);		if(toolType == toolDefinition->GetType())			return(toolDefinition->GetTool());		}			switch(toolType)		{		case toolTView:			newObserver = NewObserver();			newObserver->cView(drawing);			newObserver->SetController(this);				tool = newObserver;			break;		default:			if(tool = ctrl->cTool(ctrl,toolType))				{				toolDefinition = new(ToolDef);				toolDefinition->cToolDef(tool,toolType);					toolChest->Append(&toolDefinition);							}			break;		}		return(tool);	}	V_Window *WalkController::GetWindow(int toolType)	{	V_Window	*window;	Rect		r;	Point		p,w;	int 		middle,offset;	int			flags = DRAGBAR|GROWBOX|ZOOMBOX|GOAWAY;	// ABD WILLIAMS MERGE12 9/12/93	switch(toolType)		{		case toolCRTLWalk:			return(NULL);			break;					case toolCRTLView:#if WINDOWS			flags = 0;#endif#if VPLAYER			GetLimitedScreen(&r);			middle = (r.right - r.left) >> 1;			offset =  (r.right - r.left) / 3; 			r.left = middle - offset; 			r.right = offset + middle;			middle = (r.bottom - r.top) >> 1;			offset =  (r.bottom - r.top) / 3; 			r.top =  middle - offset; 			r.bottom = offset + middle;						break;#endif //VPLAYER		case toolCRTLLibrary:// ABD MERGE2 WILLIAMS 8/17/93 v#if VR#if MACINTOSH			// make the VR library window a windoid			flags |= WINDOID;#elif WINDOWS			// make the VR library window an ontop window			flags |= ONTOP;#endif			flags &= ~(ZOOMBOX);		// ABD MERGE12 WILLIAMS 9/12/93 don't use zoom box on lib windoid			// make the VR library window have a title of "Gallery"		// ABD MERGE8 WILLIAMS 9/3/93			strcpy(title, TXT_GALLERY);					// PRO-JAP					// ABD MERGE8 WILLIAMS 9/3/93#endif // VR// ABD MERGE2 WILLIAMS 8/17/93 ^			GetLimitedScreen(&r);			middle = (r.right - r.left) >> 1;			offset =  (r.right - r.left) / 3; 			r.left = middle - offset; 			r.right = offset + middle;			middle = (r.bottom - r.top) >> 1;			offset =  (r.bottom - r.top) / 3; 			r.top =  middle - offset; 			r.bottom = offset + middle;						break;					default:			GetLimitedScreen(&r);			middle = (r.right - r.left) >> 1;			offset =  (r.right - r.left) / 3; 			r.left = middle - offset; 			r.right = offset + middle;			middle = (r.bottom - r.top) >> 1;			offset =  (r.bottom - r.top) / 3; 			r.top =  middle - offset; 			r.bottom = offset + middle;									break;		}			w.v=430;p.v=50; 	w.h=430;p.h=50;	window = new(V_Window);#if VR	if (toolType == toolCRTLLibrary)		{		p.v=250; 	// ABD WILLIAMS MERGE12 9/12/93		p.h=100; 	// ABD WILLIAMS MERGE12 9/12/93		window->cWindow(&r,title,p,maxPoint,w,flags,WINDOW_HIDE);		((Library*)document)->libWindow = window;		}	else#endif //VR#if VPLAYER	p.v=150; 	// VPLAYER - BILBIL - keep just so big	p.h=200; 	// VPLAYER - BILBIL - keep just so big#if WINDOWS	flags = BORDERLESS;#endif //WINDOWS#endif //VPLAYER	window->cWindow(&r,title,p,maxPoint,w,flags,WINDOW_DESTROY);	document->Install(window);	return(window);	}	voidWalkController::SetViewPoint(Point3DFFixed newView,Angle3DFFixed newAngle)	{	Controller	**pctrl;	int		i,length,type;		length = controllers->ALength();	pctrl = (Controller	**)controllers->Use();	observer->SetPosition(newView,newAngle);	for(i = 0; i < length; i++,pctrl++)		{		type = (*pctrl)->GetType();		if((toolCRTLView == type)||(toolCRTLLibrary == type))		 	pvc((*pctrl))->SetViewPoint(newView,newAngle);		 }	controllers->Unuse();	}void WalkController::SetDocument(V_Document *doc) { document = doc; }				WalkDrawing	*WalkController::NewDrawing()	{	WalkDrawing	*newDrawing = new(WalkDrawing);	return(newDrawing);	}				Observer	*WalkController::NewObserver()	{	Observer	*newObserver = new(Observer);	return(newObserver);	}			ViewController	*WalkController::NewViewController()	{	ViewController	*vctrl = new(ViewController);	return(vctrl);	}			AppPreference * WalkController::GetPreference() { return(appPreferences); }voidWalkController::SetPreference(AppPreference *appPref,int initFlag)	{	UnitPreference		*unitPref;	NavigatePreference	*navigPref;	Controller	**pCtrl;	Unit	*unit,*oldUnit;	double 	factor;	int		i,length,changeFlag,toBig;		unitPref = (UnitPreference*)appPref->GetPreference(preferUnits);	navigPref = (NavigatePreference*)appPref->GetPreference(preferNavigate);	/* COMPARE UNIT CONFIGURATION */#if(!VPLAYER)	changeFlag = navigPref->GetChange();	if(PREF_NOCHANGE != changeFlag || initFlag)		{			if((navigPref->focalLength != observer->focalLength) 			|| (navigPref->filmWidth != observer->filmWidth))			observer->SetFocalValue(navigPref->focalLength,navigPref->filmWidth);		}			changeFlag = unitPref->GetChange();	if(PREF_NOCHANGE != changeFlag || initFlag)		{			oldUnit = root->GetUnit();		if(!oldUnit || (unitPref->unitSize != oldUnit->GetSize()))			{			unit = new(Unit);			unit->cUnit();			unit->SetSize(unitPref->unitSize);			toBig = FALSE;			if(oldUnit)				{						factor = unit->ConvertFrom(oldUnit);				toBig = UnitConversion(factor);				}			if(!toBig)				root->SetUnit(unit);			unit->dUnit();							}		}#endif //!VPLAYER	length = controllers->ALength();	pCtrl = (Controller	**)controllers->Use();	for(i = 0; i < length; i++,pCtrl++)		(*pCtrl)->SetPreference(appPref,initFlag);	controllers->Unuse();	}intWalkController::UnitConversion(double factor)	{	Controller	**pCtrl;	Point3DFFixed	pt;	Angle3DFFixed	ang;	FFixed	fFactor;	int i,length,toBig;		toBig = FALSE;		length = controllers->ALength();	pCtrl = (Controller	**)controllers->Use();	for(i = 0; i < length; i++,pCtrl++)		if(toBig = (*pCtrl)->UnitConversion(factor))break;	controllers->Unuse();	if(!toBig)		{		GetPosition(&pt,&ang);		fFactor = DblToFixed(factor);		pt.x = FFMult(fFactor,pt.x);		pt.y = FFMult(fFactor,pt.y);		pt.z = FFMult(fFactor,pt.z);		SetViewPoint(pt,ang);		}			return toBig;	}	void WalkController::LoadWindowPref(AppPreference *appPref) {}Controller *WalkController::FindController(int ctrlType) 	{ 	Controller **pCtrl,*rCtrl;	int	i,length;	// ABD MERGE-HMD make sure that we have a list, and return NULL otherwise	if (controllers == NULL) return NULL;	// ABD MERGE-HMD		rCtrl = NULL;	length = controllers->ALength();	pCtrl = (Controller	**)controllers->Use();	for(i = 0; i < length; i++,pCtrl++)		if(ctrlType == (*pCtrl)->GetType())			rCtrl = *pCtrl;	controllers->Unuse();			return rCtrl;	}V_Offscreen *WalkController::FullScreen(Controller *ctrl,int flag)	{	V_Window *oldWindow,*newWindow;	V_Array	 *panes;	V_Pane **pPane;	ToolDef *toolDef;	V_Offscreen *offScreen;	char winTitle[256];	Rect	r;	Point	p;	int		i,length,theType;	fullFlag = flag;			panes = new(V_Array);	panes->cArray(0,sizeof(V_Pane *),4);	theType = ctrl->GetType();	ctrl->GetTitle(winTitle);	length = toolChest->ALength();	for(i = 0; i < length; i++)		{		toolChest->Get(i,&toolDef);		if(theType == toolDef->GetType())			{			oldWindow = toolDef->GetWindow();			break;			}		}#if WINDOWS	if (fullFlag)    	{		preFullScreenState = IsZoomed(oldWindow->GetParentWindow()); // jca 2MAR94		if (preFullScreenState)        	SendMessage(oldWindow->GetParentWindow(), WM_SYSCOMMAND, SC_RESTORE, 0);		}#endif // WINDOWS	/* FLUSH OLD WINDOW */	if(oldWindow->panes)		{		oldWindow->panes->CopyArray(panes);		length = oldWindow->panes->ALength();		pPane = (V_Pane**)oldWindow->panes->Use();		for(i = length-1;i >= 0; i--)			oldWindow->UnInstall(pPane[i]);		oldWindow->panes->Unuse();		}	p.h = 0;	p.v = 0;		/* SETUP NEW WINDOW */	if(fullFlag)		{		oldWindow->Locate(&r);		preFullScreenRect=r;#if WINDOWS		Point p2;		p2.v = 0;		p2.h = 0;		ScreenToClient(document->GetMDIClient(),(LPPOINT)(&p2));		preFullScreenRect = r;		preFullScreenRect.left += p2.h;		preFullScreenRect.right += p2.h;		preFullScreenRect.top += p2.v;		preFullScreenRect.bottom += p2.v;#endif //WINDOWS		offScreen = FindScreenR(&r);		offScreen->GetRect(&r);		r.top --;		r.left --;		r.bottom --;		r.right --;		newWindow = new(V_Window);#if WINDOWS		newWindow->cWindow(&r,winTitle,p,maxPoint,p,BORDERLESS|FULLSCREEN,WINDOW_DESTROY);#elif MACINTOSH		newWindow->cWindow(&r,winTitle,p,maxPoint,p,BORDERLESS|DRAGBAR|FULLSCREEN,WINDOW_DESTROY);#endif //WINDOWS#if WINDOWS		SendMessage(newWindow->GetParentWindow(),WM_ACTIVATE,WA_ACTIVE,NULL);#endif //WINDOWS		}	else		{		int	flags = DRAGBAR|GROWBOX|ZOOMBOX|GOAWAY;		offScreen = NULL;		newWindow = new(V_Window);#if VPLAYER		p.v=150; 	// VPLAYER - BILBIL - keep just so big		p.h=200; 	// VPLAYER - BILBIL - keep just so big#if WINDOWS		flags = BORDERLESS;#endif //WINDOWS#endif //VPLAYER		newWindow->cWindow(&preFullScreenRect,winTitle,p,maxPoint,p,flags,WINDOW_DESTROY);	// ABD WILLIAMS MERGE12 9/12/93		}	document->Install(newWindow);	toolDef->SetWindow(newWindow);	oldWindow->dWindow();/* REINSTALL PANES */	length = panes->ALength();	pPane = (V_Pane**)panes->Use();	for(i = 0;i < length; i++,pPane++)		newWindow->Install(*pPane);	panes->Unuse();	panes->dArray();		/* SHOWS NEW WINDOW */	ctrl->SetTitle(winTitle);	newWindow->Show();#if WINDOWS	if (!fullFlag && (preFullScreenState))        SendMessage(newWindow->GetParentWindow(), WM_SYSCOMMAND, SC_MAXIMIZE, 0);#endif // WINDOWS	return(offScreen);	}intWalkController::TreeSize(int flag) 	{	return root->TreeSize(flag);	}/* *	Estimate the Virtus Voyager partition required for this model. The *	equation was empirically determined and is: * *		1000K + (#-polys * 1500) + (#-surfaces * 250) + (#-features * 630) * *	The surface count in the equation doesn't include surfaces created from *	slices (strange, but true). The root polyhedron isn't counted so that a *	completely empty model gets a nice round number. */longWalkController::VoyagerPartition()	{	ModelInfo info;	long size0, size1, size2, size3;	long size;	root->TreeInfo(&info);	size0 = 1000 * 1024L;	size1 = (info.nPolyhedra - info.nPolyRoot) * 1500;	size2 = (info.nSurfaces - info.nSurfSlice) * 250;	size3 = info.nFeatures * 630;	size = size0 + size1 + size2 + size3;	size = (size + 1023) & ~1023;	return size;	}// ABD MERGE-TEXTURE 9/14/93 [[[struct TextureItem * WalkController::GetTexture()	{		return(NULL);	}// ABD MERGE-TEXTURE 9/14/93 ]]]