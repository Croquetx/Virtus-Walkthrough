/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "CVWCntrl.h"#include "DesCntrl.h"#include "CVDraw.h"#include "CVPolyh.h"#include "CVEnvirn.h"#include "CVLItem.h"#include "Light.h"#include "Observer.h"#include "VMDL.h"#include "Export.h"#include "AppText.h"#include "AppDeflt.h"#include "AppFiles.h"#include "ToolDef.h"#include "WalkDefs.h"#include "PolyDefs.h"#include "Trace.h"#include "IMP2D.h"#include "DXF_IN.h"#include "Position.h"#include "Informtn.h"#include "ScoreCrd.h"#include "ImgHandl.h"#include "TIFHandl.h"#include "BMPHandl.h"#include "VFile.h"#include "VGraphic.h"#include "VDialog.h"#include "VMath.h"#include "VTextDef.h"#include "VMemUtil.h"#include <stddef.h>#include <string.h>#include <stdio.h>Point3DFFixed CAVWalkController::GetViewVector() 	{ 	Controller	*pCtrl;	Point3DFFixed iVector;	int	err;		err = 0;	pCtrl = GetFrontController();	iVector = Pt3DFFZero;	if( toolCRTLDesign == pCtrl->GetType())		{		switch(pCtrl->information->environment->GetView())			{			case topView: iVector = topViewVector; break;			case bottomView: iVector = bottomViewVector; break;			case leftView: iVector = leftViewVector; break;			case rightView: iVector = rightViewVector; break;			case frontView: iVector = frontViewVector; break;			case backView: iVector = backViewVector; break;			}		}	return(iVector);	}#if (!VPLAYER)Trace *CAVWalkController::StartImport() 	{ 	Trace	*pTrace;	Polyhedron *pPoly;	int	err;		err = 0;		selectlist->SetLength(0);	pTrace = new(Trace);	pTrace->cTrace();	pPoly = dropRoot->NewPolyhedron();	pPoly->cPolyhedron(dropRoot->drawing);	pPoly->CreateGroup();	pTrace->SetPolyhedron(pPoly);	return(pTrace);	}void CAVWalkController::EndImport(Trace *pTrace) 	{ 	CAVPolyhedron	*pPoly;		if(pTrace)		{		pPoly = pTrace->GetPolyhedron();		pPoly->SetDirty(TRUE);		pPoly->CalcTraceOutline();		if (pPoly->contents)        	{  /*  (prevents die during reload of trace reference) */			pPoly->contents->Reverse();		/* Make sure order is right */			}		}	}voidCAVWalkController::Import(Point3DFFixed vect,V_File *file,ScoreRecord *scoreRec)	{	InputTextDialog	*inputDialog;	Trace	*pTrace;	char str[256];	double sc;	FFixed scale;		if (file->type == appFileTypeDXF) sc = 1.0; // TEXT	else sc = 72.0;/*	sprintf(str,"%lf.1",sc);	inputDialog = new(InputTextDialog);	inputDialog->cInputDialog("Enter Scale Factor",str,inputNumber);	sscanf(str,"%lf",&sc);*/	scale = DblToFixed(sc);	pTrace = StartImport();	pTrace->SetView(vect);	pTrace->SetScale(scale);	pTrace->SetFile(file);	DoImport(pTrace,file,scoreRec);	EndImport(pTrace);	traceTree->Append(&pTrace);		InstallTrace(pTrace);	SelectImport(pTrace);	}void CAVWalkController::InstallTrace(Trace *pTrace) 	{ 	Controller		*pCtrl;	CAVPolyhedron	*pPoly;		LayerItem	*layer;		/*	layer = pTrace->GetLayer();	pPoly = pTrace->GetPolyhedron();	pCtrl = GetFrontController();				layer->SetController(pCtrl);	layerlist->Append(&layer);	dropRoot->Install(pPoly);*/	pPoly = pTrace->GetPolyhedron();			dropRoot->Install(pPoly);	}void CAVWalkController::RemoveTrace(Trace *pTrace) 	{ 	CAVPolyhedron	*pPoly;	LayerItem	*layer;		int num;			pPoly = pTrace->GetPolyhedron();	layer = pTrace->GetLayer();	dropRoot->Remove(pPoly);	num = layerlist->Find(&layer);	layerlist->Remove(num);	num = traceTree->Find(&pTrace);	traceTree->Remove(num);	}	void CAVWalkController::SelectImport(Trace *pTrace) 	{ 	CAVPolyhedron	*pPoly;		pPoly = pTrace->GetPolyhedron();	pPoly->SetMode(IN_POLY);	selectlist->Append(&pPoly);	NewPolyhedron(-1,pPoly);	Request(NULL,msgReset,objList,0);	}int CAVWalkController::DoImport(Trace *pTrace,V_File *file,ScoreRecord *scoreRec) 	{ 	int		segments,err,c;#if VWT && !SPECIAL_EDITION         	// merge SE, vrmadness		// GJR 7/4/95/* jca 17 Sept 93.  Not in VR { */	CAVPolyhedron *pPoly;	void		**importData;	V_Picture	*pict;	V_Offscreen *tiffScreen;	TIFFReader	*tiff;    BMPReader	*bmp;	LayerItem	*li;	obj2d		the2DObject;	char	layerName[256],name[256],str[256];		PointFFixed *pts;	long 	nLayers,nObjects,numUsefulObjects,numTotalObjects,totalUseful,i,j,total,count;	err = 0;			scoreRec->traceRec.numUnusable = 0;	scoreRec->traceRec.numConstructed = 0;		MeterCreate();	file->GetFName(name);	sprintf(str,TXT_METREAD,name);	MeterTitle(TXT_APPNAME);	MeterSetText(str);		switch(file->type)		{		case appFileTypeBMP:			file->Open(TRUE);			file->IOLength(&total);			MeterSetTotal(-1);			MeterSetCount(0);			count = 0;			MeterStart();			layerName[0] = 0;			pPoly = SetImportLayer(pTrace, layerName);			bmp = new(BMPReader);			bmp->cBMPReader(file);			err = bmp->ReadImage(8);			tiffScreen = bmp->GetScreen();			if (!err)				{#if WINDOWS				SetImportElement(pTrace, pPoly, tiffScreen, 0, 0, vBlack, FFOne, FALSE, FALSE);				tiffScreen = NULL;#endif //WINDOWS				}			else				if (tiffScreen) tiffScreen->dOffscreen();			bmp->dBMPReader();			file->Close();			scoreRec->traceRec.numUnusable = 0;			scoreRec->traceRec.numConstructed = 1;			break;		case appFileTypeTIFF:			file->Open(TRUE);			file->IOLength(&total);			MeterSetTotal(-1);			MeterSetCount(0);			count = 0;			MeterStart();			layerName[0] = 0;			pPoly = SetImportLayer(pTrace, layerName);			tiff = new(TIFFReader);			tiff->cTIFFReader(file);			err = tiff->ReadImage(8);			tiffScreen = tiff->GetScreen();			if (!err)				{#if MACINTOSH				Rect 	pictRect;				Point	res;				V_Offscreen	*oldOffscreen;					//GrowMemory(FALSE);	// jca 26 Oct 93  not necessary.  ELVIS?				pict = new(V_Picture);				pict->cPicture(PICT_OFFSCREEN);				tiffScreen->GetResolution(&res);				pict->PutResolution(&res);				oldOffscreen = offscreen;				offscreen = NULL;				offscreen = tiffScreen;				tiffScreen->GetRect(&pictRect);				offscreen->SetMetaPort();				pict->PutRect(&pictRect);				pict->SetDepth(tiffScreen->GetDepth());				pict->End();				offscreen = oldOffscreen;				// GrowMemory(TRUE); // DAS-BUGFIX 10/9/93  // jca 26 Oct 93 not necessary				SetImportElement(pTrace, pPoly, pict, 0, 0, vBlack, FFOne, FALSE, FALSE);				tiffScreen->dOffscreen();#elif WINDOWS				SetImportElement(pTrace, pPoly, tiffScreen, 0, 0, vBlack, FFOne, FALSE, FALSE);#endif				}			else				if (tiffScreen) tiffScreen->dOffscreen();							tiffScreen = NULL;			tiff->dTIFFReader();			file->Close();			scoreRec->traceRec.numUnusable = 0;			scoreRec->traceRec.numConstructed = 1;			break;#if MACINTOSH		case appFileTypePICT:			file->Open(TRUE);file->IOLength(&total);MeterSetTotal(-1);MeterSetCount(0);MeterStart();			layerName[0] =0;			pPoly = SetImportLayer(pTrace,layerName);							pict=new(V_Picture);			pict->cPicture(TRUE);			pict->IOPictFile(file);			SetImportElement(pTrace, pPoly, pict, 0, 0, vBlack,FFOne,FALSE,FALSE);			file->Close();			scoreRec->traceRec.numUnusable = 0;			scoreRec->traceRec.numConstructed = 1;			break;#endif //MACINTOSH				case appFileTypeCLARISCAD:		case appFileTypeMDII:		case appFileTypeDXF: /* TEXT */			importData = OpenImportFile(file);						nLayers 	= Imp2dNrLayers(importData);			nObjects	= Imp2dNrObjects(importData);			total = 0;			totalUseful = 0;			for(i = 0; i < nLayers; i++)					{				Imp2dLayerInfo(importData, i, layerName,&numTotalObjects,&numUsefulObjects);				totalUseful += numUsefulObjects;				total += numTotalObjects;				}			scoreRec->traceRec.numUnusable = numTotalObjects - numUsefulObjects;			scoreRec->traceRec.numConstructed = numUsefulObjects;						if(total)					{				MeterSetTotal(total);				MeterSetCount(0);				MeterStart();				count = 0;				for(i = nLayers-1; i>=0; i--)						{					Imp2dLayerInfo(importData, i, layerName,&numTotalObjects ,&numUsefulObjects);					if(numUsefulObjects)						{						pPoly = SetImportLayer(pTrace,layerName);													/* set the state here  DUDE */						for(j = 0; j < numTotalObjects; j++)								{							count++;							Imp2dObject(importData,i,j,&the2DObject);							switch(the2DObject.type)                                 {                                 case 0: break;                                 case 998:/* THE WACKY DOUBLE WALL TYPE */                                     pts = *the2DObject.thePoints;                                    for(c = 0; c < the2DObject.nr_points; c+=2,pts+=2)                                         SetImportElement(pTrace,pPoly,NULL,pts,2, the2DObject.edgeColor,FFOne,FALSE,TRUE);                                     break;                                 case 999:								 default:									 SetImportElement(pTrace,pPoly,NULL,*the2DObject.thePoints,                                         the2DObject.nr_points, the2DObject.edgeColor,FFOne,FALSE,!(the2DObject.bits&O2D_CLOSED));                                     break;								}#if WINDOWS                            Imp2dFree(&the2DObject);#endif //WINDOWS							MeterSetCount(count);							if (MeterUpdate(0)) { err = -2; break; }							}						}					}				}					Imp2dEnd(importData);				break;		}	MeterStop();	if(-2 == err)		{		}#endif // VWT  jca 17 Sept 93.  }	return err;	}#define NUMBER_SEGMENTS 16void **CAVWalkController::OpenImportFile(V_File *file)	{	void **importData;#if VWT && !SPECIAL_EDITION         	// merge SE, vrmadness		// GJR 7/4/95/* jca 17 Sept 93.  Not in VR { */	fmt2d	type;#if MACINTOSH	SFReply		reply;#elif WINDOWS	char		fileName[256];#endif //MACINTOSH	switch(file->type)		{		case appFileTypeCLARISCAD: type = ccd2; break;		case appFileTypeMDII: type = md2; break;		case appFileTypeDXF: type = dxf; break;		}		#if MACINTOSH	MakeSFReply(&reply,file);	#if THINK_C	importData = Imp2DOpen(type,NUMBER_SEGMENTS,&reply);	#else	importData = Imp2DOpen(type,NUMBER_SEGMENTS,&reply);	#endif#elif WINDOWS	MakeFileName(fileName,file);	importData = Imp2DOpen(type,NUMBER_SEGMENTS,fileName);#endif //WINDOWS#endif // VWT.  jca 17 Sept 93 }		return importData;	}CAVPolyhedron *CAVWalkController::SetImportLayer(Trace *trace,char *layerName) 	{ 	Controller		*pCtrl;	CAVPolyhedron	*tracePoly,*nPoly;	LayerItem	*layerItem;	Point3DFFixed 	viewVector;	PointFFixed		pt;	V_Array	*pts;	int		layerNum;	char	defAxis;		if(!strlen(layerName))strcpy(layerName,TXT_TEMPLATE);	// PRO-JAP	layerItem = new(LayerItem);	layerItem->cListItem(layerName);	layerItem->SetColor(vBlack);	layerItem->SetFlag(TRACE_LAYER,TRUE);	tracePoly = trace->GetPolyhedron();	viewVector = trace->GetView();	trace->SetLayer(layerItem);				pCtrl = GetFrontController();		layerItem->SetController(pCtrl);	layerlist->Append(&layerItem);	pts = new(V_Array);	pts->cArray(0,sizeof(PointFFixed),4);	pt = PtFFZero; 	pts->Append(&pt);	pts->Append(&pt);	pts->Append(&pt);	pts->Append(&pt);		nPoly = (CAVPolyhedron*)dropRoot->NewPolyhedron();	nPoly->cPolyhedron(dropRoot->drawing);	if(!FFZero(viewVector.x))defAxis = INFL_X;	else { if(!FFZero(viewVector.y))defAxis = INFL_Y; else defAxis = INFL_Z; }	nPoly->CreateInflate(defAxis,INFL_EXTRUDE,pts,FFZero,FFZero);	nPoly->SetLayer(layerItem,FALSE);/* This is because he's a group but I don't want to propagate the layer information */	tracePoly->layer = layerItem;	nPoly->SetEditType(EDIT_RECTANGLE);	pts->dArray();	tracePoly->rPosn->Copy(nPoly->rPosn);	tracePoly->Install(nPoly);			return nPoly;	}void #if MACINTOSHCAVWalkController::SetImportElement(Trace *trace,CAVPolyhedron *pPoly, V_Picture *pict,PointFFixed *points, int nPoints, RGBColor color,FFixed scal,int flip,int open)#elif WINDOWSCAVWalkController::SetImportElement(Trace *trace,CAVPolyhedron *pPoly, V_Offscreen *pict,PointFFixed *points, int nPoints, RGBColor color,FFixed scal,int flip,int open)#endif	{	V_Array			*pts;	Point3DFFixed	viewVector;	PointFFixed		*pPt,*pPt2;	int		i;		viewVector = trace->GetView();		pts = new(V_Array);	pts->cArray(nPoints,sizeof(PointFFixed),4);	pPt = (PointFFixed*)pts->Use();	pPt2 = pPt;	memcpy(pPt, points, sizeof(PointFFixed) * nPoints);	if(flip)		{		for(i=0; i < nPoints; i++,pPt++)			pPt->v = FFNeg(pPt->v);		}	scal = trace->GetScale();	if(EQUL!=FFLogic(FFOne,scal))		{		for(i=0; i < nPoints; i++,pPt2++)			{			pPt2->h = FFMult(pPt2->h,scal);			pPt2->v = FFMult(pPt2->v,scal);			}		}	pts->Unuse();	if(pict) pPoly->AddPictElement(pict,viewVector,EDIT_PICTURE);	else if(open) pPoly->AddTraceElement(pts,viewVector,color,EDIT_TPOLYLINE);	else pPoly->AddTraceElement(pts,viewVector,color,EDIT_TPOLYGON);	pts->dArray();	}intCAVWalkController::Export(ModelExport *export)	{	V_Array *layers;	Layer lyr;	long	total;	int length, i,flagState,err;	LayerItem **layerItem;	char	name[256],str[256];		layers = new(V_Array);	layers->cArray(0, sizeof(Layer), 4);	length = layerlist->ALength();	layerItem = (LayerItem**)layerlist->Use();	for (i = 0; i < length; i++)		{		layerItem[i]->SetID(i);		lyr.name = layerItem[i]->name;		lyr.color = layerItem[i]->color;		lyr.state = 0;		flagState = layerItem[i]->GetFlag();		if (!(LOCK_LAYER&flagState)) lyr.state |= active;		if (!(HIDE_LAYER&flagState)) lyr.state |= visible;		layers->Append(&lyr);		}	layerlist->Unuse();	export->Layers(layers);	layers->dArray();	err = pcp(root)->Export(export);	return(err);	}#endif //!VPLAYER	intCAVWalkController::IO_ReadExtra(V_Buffer *buf,long chunkID)	{	Trace	*pTrace;	V_File	*file;	int err;	err = 0;		switch(chunkID)		{		case IFF_TRACE: #if (!VPLAYER)			pTrace = StartImport();			err = pTrace->IO(buf);			if(err) pTrace->dTrace(); 			else  				{				EndImport(pTrace);				traceTree->Append(&pTrace);				}			err = 0;	#endif //!VPLAYER			break;					case IFF_LAYR: #if (!VPLAYER)			err = IO_LAYR(buf); #endif //!VPLAYER			break;		case IFF_CRED:			err = IO_CRED(buf);#if (!JAPANESE)			MeterSetCreditInfo(creditScreen, creditText);#endif //!JAPANESE			break;		}			return err;	}intCAVWalkController::IO_WriteFirst(V_Buffer *buf)	{	int err = 0;	if (creditScreen || creditText)		{		buf->OpenChunkW(IFF_CRED);		if (creditScreen)			{			buf->OpenChunkW(IFF_BMAP);			err = creditScreen->IO_BMAP(buf, NULL, NoCompression);			buf->CloseChunk();			}		if (creditText)			{			char	end;						buf->OpenChunkW(IFF_TEXT);			err = creditText->IO(buf);			buf->CloseChunk();			}		buf->CloseChunk();		}		return err;	}	#if (!VPLAYER)intCAVWalkController::IO_WriteLast(V_Buffer *buf)	{	CAVPolyhedron *pPoly;	Trace	**pTrace;	int		i,length,num;	int err;	err = 0;	buf->OpenChunkW(IFF_LAYR);	err = IO_LAYR(buf);	buf->CloseChunk();		length = traceTree->ALength();	pTrace = (Trace	**)traceTree->Use();	for(i = 0; i < length; i++,pTrace++)		{		pPoly = (*pTrace)->GetPolyhedron();		if(dropRoot->contents) num = dropRoot->contents->Find(&pPoly);		else num = -1;		if(num>=0)			{			buf->OpenChunkW(IFF_TRACE);			(*pTrace)->IO(buf);			buf->CloseChunk();			}		if(err)break;		}	traceTree->Unuse();	return err;	}	intCAVWalkController::IO_LAYR(V_Buffer *buf)	{	short length, i,count;	LayerItem *inLayer, **outLayer,**countLayer;	int err;	err = 0;	if (buf->IODirection() == DATA_IN)		{/*IOD*/		buf->IOType(&length, IO_SHORT);		layerlist->SetLength(0);		for (i = 0; i < length; i++)			{			inLayer = new(LayerItem);			inLayer->cListItem(TXT_EMPTYSTRING);			inLayer->IO(buf);			#if SPECIAL_EDITION			// unlock first layer for special edition!			if (i == 0)				inLayer->flagState &= ~LOCK_LAYER;            #endif // SPECIAL_EDITION			layerlist->Append(&inLayer);						if (i == 0) inLayer->SetHilite(TRUE);			}		}	else		{		length = layerlist->ALength();				count = 0;		countLayer = (LayerItem**)layerlist->Use();		outLayer = countLayer;		for (i = 0; i < length; i++,countLayer++)			if(TRACE_LAYER&(*countLayer)->GetFlag())count++;		layerlist->Unuse();		length-=count;		/*IOD*/		buf->IOType(&length, IO_SHORT);				for (count = 0,i = 0; i < length; i++,outLayer++)			{			if(!(TRACE_LAYER&(*outLayer)->GetFlag()))				{				(*outLayer)->SetID(count++);				(*outLayer)->IO(buf);				}			}		layerlist->Unuse();		}	return err;	}#endif //!VPLAYERintCAVWalkController::IO_CRED(V_Buffer *buf)	{	int		err = 0;	long	id;		MeterSetCount(buf->IOGetPosition());	if (MeterUpdate(0)) err = -2;	while (!err)		{		id = buf->OpenChunkR();		if (id == 0) break;		switch (id)			{			case IFF_TEXT:				err = IO_TEXT(buf);				break;			case IFF_BMAP:				if (creditScreen)					creditScreen->dOffscreen();				creditScreen = new(V_Offscreen);				creditScreen->IO_BMAP(buf, NULL, 0);				break;			}		buf->CloseChunk();		}	MeterSetCount(buf->IOGetPosition());	if (MeterUpdate(0)) err = -2;		return (err);	}intCAVWalkController::IO_TEXT(V_Buffer *buf)	{	int err = 0;	if (creditText)		creditText->dArray();	creditText = new(V_Array);	creditText->cArray(buf->ChunkSize(), 1, 16);	creditText->IO(buf);	return(err);	}