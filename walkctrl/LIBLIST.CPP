/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "LibList.h"#include "LibItem.h"#include "LibIndex.h"#include "LibDefs.h"#include "LbVCntrl.h"#include "Polyhdrn.h"#include "VMDL.h"#include "AppMssgs.h"#include "AppText.h"#include "ToolDef.h"#include "Misc.h"#include "BallHelp.h"#include "VGraphic.h"#include "VGUtil.h"#include "VButton.h"#include "VWindow.h"#include "VDialog.h"#include "VError.h"#include <stdio.h>#include <string.h>void LibraryList::cPane(int flag)	{		controller = NULL;	beginSelection = -1;	List::cPane(flag);	SetVScroll();	}void LibraryList::SetController(Controller *ctrl)	{		LibraryItem	**item;	int		i,length;		controller = ctrl;		length = theList->ALength();	item = (LibraryItem	**)theList->Use();	for(i = 0; i < length; i++,item++) 		(*item)->SetController(controller);	theList->Unuse();	}void LibraryList::LoadIndex(LibraryIndex *index)	{		LibraryEntry **entry;	LibraryItem	*item,**ditems;	int		i,length;		length = theList->ALength();	ditems = (LibraryItem	**)theList->Use();	for(i = 0; i < length; i++) 		ditems[i]->dListItem();	theList->Unuse();		theList->SetLength(0);			length = index->ALength();	entry = (LibraryEntry **)index->Use();	for(i = 0; i < length; i++,entry++) 		{		item = new(LibraryItem);		item->cListItem();		item->SetController(controller);		if(*entry)			{			item->SetEntry(*entry,i);			theList->Append(&item);			}		}	index->Unuse();	}		void LibraryList::CalcSize(Rect *r,Point *p,int type,int warning)	{	controller->GetPlace(r,warning,toolLList);	}voidLibraryList::TrackHelp(Point pt,long modifier)// DAS-VWINDOWS 9/30/93	{// { DAS-VR-HELP 9/30/93#if VWT	Rect r;		r = dataRect;	BalloonHotRect(&r,pt);	Bubble(pt,&r,TXTB_LIBRARYITEM);#endif// } DAS-VR-HELP 9/30/93	}void LibraryList::SetVScroll()	{	SetVPage(5);		SetVMove(1);		}intLibraryList::GetHeight()	{	return(LIST_MAGIC_HEIGHT);	}voidLibraryList::Display(int type,int x,int y)	{	List::Display(type,x,y);#if WINDOWS	VMoveTo(dataRect.right-1,dataRect.top);	VLineTo(dataRect.right-1,dataRect.bottom);#endif //WINDOWS	}voidLibraryList::MouseDown(Point p,long modifiers)	{	delayTime = VGetTime();	doPopUp = TRUE;	List::MouseDown(p,modifiers);	beginSelection = selection;	}	void LibraryList::Track(Point p,long modifiers,int lastCall)	{	EditItem  *theItem;	LibListMenu	*theMenu;		VSetCursor(vCursorArrow);		if((buttonDown & modifiers))		{		//DUDE PORT		if((-1 != beginSelection) && WAITTIME(1000) < (VGetTime() - delayTime))			{			theMenu = new(LibListMenu);			p.h += POSITION_TAB;							theItem = (EditItem *)GetCurrentItem();		// ABD added coercion 8/12/93			theMenu->ctheMenu(p,modifiers,theItem,depth>2);				theMenu->Action(theMenu->PopUp(this,p,0),modifiers);			theMenu->dMenu();							VDisplay(DRAW);						doPopUp = FALSE;			}		else			if(beginSelection != selection) beginSelection = -1;		}	List::Track(p,modifiers,lastCall);	}void LibraryList::MouseUp(Point p,long modifiers)	{	doPopUp = FALSE;	List::MouseUp(p,modifiers);	if(-1 != beginSelection && theList->ALength())		plc(controller)->LoadLibraryItem(selection);	beginSelection = -1;	}int LibraryList::KeyAction(char c,long modifiers)	{	int err = noErr;			switch(c)		{	#if VWT		case V_DELETE:  err = plc(controller)->EditBuffer(MSG_CLEAR,modifiers); break;#endif //VWT		default: return(FALSE); break;		}	return((err < noErr) ? FALSE : TRUE);	}int LibraryList::GetAction(long action,long modifiers)	{	int err = noErr;	switch(action)		{#if VWT		case MSG_CUT:		case MSG_COPY: 		case MSG_DUPLICATE: 		case MSG_CLEAR: 		case MSG_PASTE: 			err = plc(controller)->EditBuffer(action,modifiers);			break;#endif //VWT					default: return(FALSE); break;		}			return((err < noErr) ? FALSE : TRUE);	}	intLibraryList::AddItem()	{ 	LibraryItem		*item;		if(item = (LibraryItem*)GetCurrentItem())		item->SetHilite(FALSE);		if(selection<0)selection = 0;	item = new(LibraryItem);	item->cListItem();	item->SetController(controller);	theList->Insert(selection,&item);	item->SetHilite(TRUE);		return(TRUE); 	}	int LibraryList::RemoveItem()	{ 	if(!theList->ALength()) return(FALSE);		if(RemoveCurrentItem()) Reset();	return(TRUE); 	}	void LibraryList::GetDefaultName(char *str)	{		int i;	i = theList->ALength();	sprintf(str,TXT_LIBRARY_OBJECT_NUM_I,i);		// PRO-JAP	}void LibraryTitle::cPane(int flag)	{	controller = NULL;	button = new(V_BItem);	button->cBItem(0x20);	V_Pane::cPane(flag);	moveSide = FALSE;	}void LibraryTitle::dPane()	{	button->dBItem();	V_Pane::dPane();	}	void LibraryTitle::SetController(Controller *ctrl) { controller = ctrl; }		void  LibraryTitle::CalcSize(Rect *r,Point *p,int type,int warning)	{ controller->GetPlace(r,warning,toolPTitle); }void LibraryTitle::Display(int type,int h,int v)	{	Rect	r,txtR;	RGBColor	color;			SetMetaPort();		r=dataRect;	r.right -= POSITION_TAB;	button->SetState(OFFSTATE);	button->MoveButton(&r);	color = vBlack;	if(depth>=4)button->CDraw(); // DAS-VBUTTON 8/17/93	else button->MDraw();		TextSetUp(vSystemFont,vSystemFontSize,vNormal);#if WINDOWS	VTextMode(vSrcXor);#endif //WINDOWS	VForeColor(&vBlack);	txtR = r;	txtR.left+=12;txtR.bottom=txtR.top+13;txtR.top=txtR.bottom-vSystemFontSize;	VDrawText(TXTI_OBJECTS,0,strlen(TXTI_OBJECTS),&txtR);#if WINDOWS	VTextMode(vSrcOr);#endif //WINDOWS	r.left = r.right;	r.right = dataRect.right;	VForeColor(&vBlack);	VSetPattern(vPatBlack);	if(depth>2)  VPaintRect(&r); else VFillRect(&r);	r = dataRect;	MetaCopy(&r);	UnsetMetaPort();	}	void LibraryTitle::MouseDown(Point p,long modifiers)	{	if((dataRect.right - p.h) < POSITION_TAB)		{		moveSide = TRUE;		DrawSide(p,0);		}	}void LibraryTitle::Track(Point p,long modifiers,int lastCall)	{	if(moveSide)		{ VSetCursor(vCursorSplit); DrawSide(p,1); }	else		{ if((dataRect.right - p.h) < POSITION_TAB)VSetCursor(vCursorSplit); else VSetCursor(vCursorArrow); }				}void LibraryTitle::MouseUp(Point p,long modifiers) 	{ 	if(moveSide) DrawSide(p,2); 	}void LibraryTitle::DrawSide(Point p,int flag)	{	Rect	r;	theWindow->GetRect(&r);	WindowPane();		if(p.h < 20) p.h = 20; else if(p.h > (r.right-20)) p.h = r.right -20;		VSetPenSize(3,3);	VSetPattern(vPatGray);	VPenMode(vPatXor);	switch(flag)		{		case 0:/* start */			lastPt = p;			VMoveTo(lastPt.h,0);			VLineTo(lastPt.h,r.bottom);			break;				case 1:/*track */			if(p.h != lastPt.h)				{				VMoveTo(lastPt.h,0);				VLineTo(lastPt.h,r.bottom);				lastPt = p;				VMoveTo(lastPt.h,0);				VLineTo(lastPt.h,r.bottom);				}						break;				case 2:/*finish */			VMoveTo(lastPt.h,0);			VLineTo(lastPt.h,r.bottom);			moveSide = FALSE;			plc(controller)->SetBreakPosition(lastPt.h);			break;		}	VSetPenSize(1,1);	VSetPattern(vPatBlack);	VPenMode(vPatCopy);	SetPane();	}void LibListMenu::ctheMenu(Point p,long modifiers,EditItem *theItem,int inColor)	{	char name[256];	item = (LibraryItem*)theItem;			cMenu(TXTM_LIBRARY,0);	SetMnemonics(FALSE);	Append(TXTM_LIBNAME);		strcpy(name,TXTM_LAYNAME);		SetTitle(menuLibraryName,name);	}void LibListMenu::Action(int iNum,long modifiers)	{	Controller	*controller = item->controller; /* dude */	char		newName[256];			switch(iNum)		{		case menuLibraryName:			item->GetName(newName);			if(ListName(newName))				{				#if !SAVE_DISABLED		// ABD-SAVE-DISABLED				item->SetName(newName);				controller->Request(NULL,msgEdit,objList,0);				#endif // SAVE_DISABLED				}			break;					}	}	int LibListMenu::ListName(char *str)	{	InputTextDialog *dialog = new(InputTextDialog);	return(dialog->cInputDialog(TXT_CHANGE_NAME,TXT_OBJECT_NAME,str,inputText));		// PRO-JAP	}