/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VDisplay.h"#include "SrfObj.h"#include "CVSrfDef.h"#include "CVSrfFet.h"#include "CVPolyh.h"#include "CVEnvirn.h"#include "PolyDefs.h"#include "Geometry.h"#include "Clip.h"#include "SinTable.h"#include "Position.h"#include "Misc.h"#include "VMath.h"#include "VGraphic.h"#include "VGUtil.h"#include "SurfFeat.h"	// ABD MERGE-TEXTURE 9/13/93#include "SurfDef.h"		// ABD MERGE-TEXTURE 9/13/93#include "Surface.h"		// ABD MERGE-TEXTURE 9/13/93#include "Unit.h"			// ABD MERGE-TEXTURE 9/13/93#include "TextItem.h"	// ABD MERGE-TEXTURE 9/13/93#include "TextSrvr.h"	// ABD MERGE-TEXTURE 9/13/93#include "View.h"			// ABD MERGE-TEXTURE 9/13/93#include "VDebug.h"			// ABD MERGE-TEXTURE 9/13/93#include "Flash.h"			// ABD MERGE-TEXTURE 9/13/93#include "Texture.h"extern TextureShader gTextureShader;	// ABD TEXTURE// JAM 6OCT94 copied from john's stuff [[[// jca 10AUG94 VR1.0.1 [[ tidy up our statics// jca 17MAR94 drew moved these to srfobj.h#define CLAMP(v,l,h)	((v)<(l) ? (l) : (v) > (h) ? (h) : v)V_Array *outArray=NULL,*tmArray=NULL;     // jca VR1.0.1 10AUG94 set to NULL.void CleanUpSrfObjStatics(void);void CleanUpSrfObjStatics(void)	{	if (outArray)		{		outArray->dArray();        outArray = NULL;		}	if (tmArray)		{		tmArray->dArray();        tmArray = NULL;		}	}// jca 10AUG94 VR1.0.1 moved these routines up here.// V_Array * GetShortSurfPoints(V_Array *,PointLong );// V_Array * GetShortSurfPointsIndex(V_Array *, V_Array *, PointLong );V_Array * GetShortSurfPoints(V_Array *parray, PointLong dp){PointLong *poly=(PointLong *)parray->Use();Point shpt;long i;if(!outArray)	{	outArray=new(V_Array);	outArray->cArray(0,sizeof(Point),8);	}outArray->SetLength(0);for(i=0;i<parray->ALength();i++)	{	shpt.h = CLAMP(-32767, poly[i].h-dp.h, 32767);     // jca 27 Sept 93	shpt.v = CLAMP(-32767, poly[i].v-dp.v, 32767);     // jca 27 Sept 93	outArray->Append(&shpt);	}parray->Unuse();return outArray;}V_Array * GetShortSurfPointsIndex(V_Array *parray, V_Array *pindex, PointLong dp){V_Array *a = NULL;short *index=(short *)pindex->Use();	// BILBIL - short NOT int !!! - 12/06/93int i,lngth=pindex->ALength();PointLong *p1,*p2;if(!tmArray)	{	tmArray=new(V_Array);	tmArray->cArray(lngth,sizeof(PointLong),8);	}else tmArray->SetLength(lngth);p1= (PointLong *) parray->Abuse();   // jca 27 Sept 93p2= (PointLong *)tmArray->Abuse();    // jca 27 Sept 93for(i=0;i<lngth;i++)	p2[i]=p1[index[i]];a = GetShortSurfPoints(tmArray,dp);pindex->Unuse();return a;}// jca VR1.0.1 ]]// JAM 6OCT94 copied from john's stuff ]]]voidSurfObject::cSurfObject() 	{			surfDef = NULL;	surfFeature = NULL;	environment = NULL;	mode = OUT_POLY;	mark = NO_MARK;	dirty = TRUE;	side = SURF_SHARED;	points = new(V_Array);	points->cArray(0,sizeof(PointLong),4);	}void SurfObject::dSurfObject()  { points->dArray(); delete(this); }void SurfObject::SetSurfDef(CAVSurfDef *sDef)  { surfDef = sDef; surfFeature = NULL; }void SurfObject::SetEnvironment(CAVEnvironment *newEnv)  { environment = newEnv; }void SurfObject::SetSurfFeature(CAVSurfFeature *sFeat)  	{ 	surfFeature = sFeat; 	surfDef = (CAVSurfDef *)surfFeature->surfDef; 	side = surfDef->GetSide(surfFeature);	}// jam 6OCT94 did jca 10AUG94 VR1.0.1  moved two routines up to the top of the filevoidSurfObject::Display(int lockState) 	{	V_Array	*clipPts;	Rect	r;	PointLong	drawOrigin;	RGBColor	color;	TextureItem *texture;	// ABD MERGE-TEXTURE 9/13/93	FFixed ff_flip, ff_temp;			// jca 27 Sept 93	int flip_height;		// ABD MERGE-TEXTURE 9/13/93	Rect flip, flip2;		// ABD MERGE-TEXTURE 9/13/93	int ins;				// ABD MERGE-TEXTURE 9/13/93	unsigned short opacity;	int	depth,viewSide;	int	patType,drawAllFlag;				if(dirty)Scale();	depth = environment->GetCAVDepth();	drawOrigin = environment->GetDrawOrigin();	viewSide = environment->GetSide();	r = environment->dataRect;		if(surfFeature)		{ 			color = surfFeature->GetColor(); 			texture = surfFeature->GetTexture(); 	// ABD MERGE-TEXTURE 9/13/93			opacity = surfFeature->GetOpacity(); 		}	else		{ 			color = surfDef->GetColor(viewSide); 		// ABD MERGE26			texture = surfDef->GetTexture(viewSide); 	// ABD MERGE-TEXTURE 9/13/93			opacity = surfDef->GetOpacity(); 		}	/*11-29-93 JAM [[[ patch to cause textures to	  not be used when doing GDI stuff*/    //this if was copied (subtracting one or condition) from clip.cp	if (!offscreen || !gwUserFlash || !offscreen->wMethodInit || usePlatformDrawFlag || polyCheckMode)	{    	texture = NULL;    }	/*11-29-93 JAM ]]] patch to cause textures to      not be used when doing GDI stuff*/	VPenMode(vPatCopy);	if((SURF_SHARED == side) || (viewSide == side ))		{			if(IS_TRANSPARENT(opacity)) { patType = vPatBlack; color = vBlack; }			else if(IS_TRANSLUCENT(opacity)) patType = vPatLtGray;			else patType = vPatBlack;			VSetPattern(patType);			if ((!texture) || (!offscreen))		// ABD			{				clipPts = LongClipPoly(points,&r,drawOrigin);			virtusClipper->NewDrawPoly(clipPts,CLIP_FRAME|CLIP_FILL,NULL,FALSE,FALSE,vPatBlack,&color,&vBlack,TRUE,NULL);		// MERGE-GOURAUD			if(lockState) VSetPattern(vPatGray); else VSetPattern(vPatBlack);			}			else	//  TEXTURED			{		    VGrafPort   savePort;		    VGrafDevice     saveDevice;			V_Offscreen *texture_offscreen;			int has_texture = (texture != NULL);	 				if(IS_TRANSPARENT(opacity)) 				{ 					clipPts = LongClipPoly(points,&r,drawOrigin);					virtusClipper->NewDrawPoly(clipPts,CLIP_FRAME|CLIP_FILL,NULL,FALSE,FALSE,vPatBlack,&color,&vBlack,TRUE,NULL);		// MERGE-GOURAUD				} 							VGetPort(&savePort,&saveDevice);			    texture_offscreen = texture->GetPicture(0);				if (texture_offscreen == NULL) 	// can't even get the thumbnail, so give up!					has_texture = FALSE;						 	texture->GetPaddedRect(&flip, 0);			 	texture->GetUnpaddedRect(&flip2, 0);									ff_flip.intg = flip.bottom-flip.top;				ff_flip.frac = 0;				ff_temp = FFMult(ff_flip, texture->settings.vTiles); // jca 27 Sept 93   Borland deficiency				flip_height = FFRound(ff_temp);    // jca 27 Sept 93									if (has_texture)				{				    				    if (surfFeature)				    {				   	V_Array *ctp = GetShortSurfPoints(points, drawOrigin);				   	V_Array *txtPnt1;				   	V_Array *it;				   	V_Array *ictp;				   	struct TextureRendSettings TextureInfo;				   	int i;				   					   		/*Do we need to Use() the arrays of points and texture points?				   		  --JAM*/				   		  						txtPnt1 = new(V_Array);						txtPnt1->cArray(0, sizeof(Point), 4);				   		it = AbsoluteIdentTexture(surfFeature->GetRawTexturePoints(),				   			flip_height,(viewSide == SURF_INSIDE));					 	//	AbsoluteIdentTexture(txtPnt1, flip_height,(viewSide == SURF_INSIDE)), 				   		ictp = RealAbsoluteIdent(ctp,(viewSide == SURF_INSIDE));						TextureInfo.decal = texture->settings.decal;						TextureInfo.colorize = texture->settings.colorize;						TextureInfo.hFlip = texture->settings.hFlip;						TextureInfo.vFlip = texture->settings.vFlip;						TextureInfo.hMirror = texture->settings.hMirror;						TextureInfo.vMirror = texture->settings.vMirror;						TextureInfo.textureShade = &(gTextureShader[0]);						for (i = 0 ; i < MAX_NUM_MIPS ; i++ )						{							TextureInfo.mip[i] = texture->GetPicture(i);							texture->GetPaddedRect(&TextureInfo.mip_rect[i], i);						}						if(TextureInfo.mip[0] == NULL) {							TextureInfo.mip[0] = texture->GetThumbnail();							TextureInfo.mip[0]->GetRect(&TextureInfo.mip_rect[0]);							//texture->GetPaddedRect(&TextureInfo.mip_rect[0], 0); ????						}						texture->texture->Lock();						texture->SetupFrame();		// MERGE25					 	ShadedLinearTexture8(&TextureInfo, offscreen, it, ictp, NULL);						texture->texture->Unlock();												 txtPnt1->dArray();				    }				    else				    {				   	V_Array *ctp = GetShortSurfPoints(points, drawOrigin);				   	V_Array *txtPnt1;				   	V_Array *it;				   	V_Array *ictp;				   	struct TextureRendSettings TextureInfo;				   	int i;				   							txtPnt1 = new(V_Array);						txtPnt1->cArray(0, sizeof(Point), 4);				   		it = AbsoluteIdentTexture(surfDef->surface->GetRawTexturePoints(viewSide),				   			flip_height,(viewSide == SURF_INSIDE));				   		ictp = RealAbsoluteIdent(ctp,(viewSide == SURF_INSIDE));				   							TextureInfo.decal = texture->settings.decal;						TextureInfo.colorize = texture->settings.colorize;						TextureInfo.hFlip = texture->settings.hFlip;						TextureInfo.vFlip = texture->settings.vFlip;						TextureInfo.hMirror = texture->settings.hMirror;						TextureInfo.vMirror = texture->settings.vMirror;						TextureInfo.textureShade = &(gTextureShader[0]);						for (i = 0 ; i < MAX_NUM_MIPS ; i++ )						{							TextureInfo.mip[i] = texture->GetPicture(i);							texture->GetPaddedRect(&TextureInfo.mip_rect[i], i);						}						if(TextureInfo.mip[0] == NULL) {							TextureInfo.mip[0] = texture->GetThumbnail();							TextureInfo.mip[0]->GetRect(&TextureInfo.mip_rect[0]);							//texture->GetPaddedRect(&TextureInfo.mip_rect[0], 0); ????						}						texture->texture->Lock();						texture->SetupFrame();		// MERGE25					 	ShadedLinearTexture8(&TextureInfo, offscreen, it, ictp, NULL);						texture->texture->Unlock();					 							 txtPnt1->dArray();				    }				}				VSetPort(savePort,saveDevice);			}									VForeColor(&vBlack);			VSetPattern(vPatBlack);		}	else		{		VSetPattern(vPatGray);		VForeColor(&color);		clipPts = LongClipPoly(points,&r,drawOrigin);virtusClipper->NewDrawPoly(clipPts,CLIP_FRAME,NULL,0,vPatGray,vPatGray,&color,&vBlack,TRUE,NULL);		// MERGE-GOURAUD		VSetPattern(vPatBlack);		}	}	void SurfObject::Select() 	{	PointLong	*lp,adjPt,drawOrigin;	Rect		handles,r;	int			i,length,depth;		depth = environment->GetCAVDepth();	drawOrigin = environment->GetDrawOrigin();	r = environment->dataRect;		VForeColor(&vBlack);	VPenMode(vPatXor);		length = points->ALength();	lp = (PointLong	*)points->Use();					for(i = 0; i < length; i++,lp++)		{		adjPt.h = lp->h - drawOrigin.h;		adjPt.v = lp->v - drawOrigin.v;		if(adjPt.v<=r.bottom&&adjPt.v>=r.top&&adjPt.h<=r.right&&adjPt.h>=r.left)			{			handles.left = adjPt.h - 2;			handles.right = adjPt.h + 3;			handles.top = adjPt.v - 2;			handles.bottom = adjPt.v + 3;				VPaintRect(&handles);			}		}	points->Unuse();		VPenMode(vPatCopy);			}	intSurfObject::Find(Point *p,long modifiers,int detailed)	{	PointLong	*lp;	Point		tp,a,b;		Rect		handles;	int			length,i,viewSide,editMode,next,found = FALSE,direction;			if( SURF_INSIDE == environment->GetSide()) direction = COUNTERCLOCKWISE;	else direction = CLOCKWISE;			tp.h = p->h;	tp.v = p->v;			length = points->ALength();	lp = (PointLong	*)points->Use();		editMode = IN_POLY;		if(detailed)	/* if it has been selected recently */		{		/* search end points */		for(i = 0; i < length; i++)			{			handles.left = lp[i].h - 3;			handles.right = lp[i].h + 3;			handles.top = lp[i].v - 3;			handles.bottom = lp[i].v + 3;				if(VPtInRect(tp,&handles)) 				{ editMode = ON_POLY_POINT; mark = i; p->h = lp[i].h; p->v = lp[i].v; break; }		}		/* end of searching for points */						/* search lines */		if(IN_POLY == editMode)			{				for(i = 0; i < length; i++)				{				next = nextIndex(i,1,length);				a.h = lp[i].h;a.v = lp[i].v;				b.h = lp[next].h;b.v = lp[next].v;				if(PtOnLine(tp,a,b)) 					{ 					tp = ExactPtOnLine(tp,a,b);					p->h = tp.h;					p->v = tp.v;					editMode = ON_POLY_DEFLINE; 					mark = i; 					break; 					}				}				}			}		if(IN_POLY == editMode)		{		for(i = 0; i < length; i++)			{			next = nextNum(i,length);			a.h = lp[i].h; 	a.v = lp[i].v;			b.h = lp[next].h; b.v = lp[next].v;			if(direction == Clockwise(tp,a,b)) { editMode = OUT_POLY; break; }			}		}		if(detailed)		{ if(OUT_POLY == editMode) mode = IN_POLY; else mode = editMode; }	else		{		if(modifiers&MULTIPLE_SELECT)			{ if(IN_POLY == editMode) mode = OUT_POLY; }		else		 	mode = editMode;		}								points->Unuse();		return(editMode);	}	#if VRML_ANCHOR 	// ABD PRO25 AUG95intSurfObject::FindNoSideEffects(Point *p,long modifiers,int detailed)	{	PointLong	*lp;	Point		tp,a,b;		Rect		handles;	int			length,i,viewSide,editMode,next,found = FALSE,direction;	short		mark;	short		mode;			if( SURF_INSIDE == environment->GetSide()) direction = COUNTERCLOCKWISE;	else direction = CLOCKWISE;			tp.h = p->h;	tp.v = p->v;			length = points->ALength();	lp = (PointLong	*)points->Use();		editMode = IN_POLY;		if(detailed)	/* if it has been selected recently */		{		/* search end points */		for(i = 0; i < length; i++)			{			handles.left = lp[i].h - 3;			handles.right = lp[i].h + 3;			handles.top = lp[i].v - 3;			handles.bottom = lp[i].v + 3;				if(VPtInRect(tp,&handles)) 				{ editMode = ON_POLY_POINT; mark = i; p->h = lp[i].h; p->v = lp[i].v; break; }		}		/* end of searching for points */						/* search lines */		if(IN_POLY == editMode)			{				for(i = 0; i < length; i++)				{				next = nextIndex(i,1,length);				a.h = lp[i].h;a.v = lp[i].v;				b.h = lp[next].h;b.v = lp[next].v;				if(PtOnLine(tp,a,b)) 					{ 					tp = ExactPtOnLine(tp,a,b);					p->h = tp.h;					p->v = tp.v;					editMode = ON_POLY_DEFLINE; 					mark = i; 					break; 					}				}				}			}		if(IN_POLY == editMode)		{		for(i = 0; i < length; i++)			{			next = nextNum(i,length);			a.h = lp[i].h; 	a.v = lp[i].v;			b.h = lp[next].h; b.v = lp[next].v;			if(direction == Clockwise(tp,a,b)) { editMode = OUT_POLY; break; }			}		}		if(detailed)		{ if(OUT_POLY == editMode) mode = IN_POLY; else mode = editMode; }	else		{		if(modifiers&MULTIPLE_SELECT)			{ if(IN_POLY == editMode) mode = OUT_POLY; }		else		 	mode = editMode;		}								points->Unuse();		return(editMode);	}#endif // VRML_ANCHORPoint SurfObject::GetAnchor(int theScaleThing) 	{	PointLong	lp,drawOrigin;	Point 		anchor;	int			where,length,theType;    anchor.h = anchor.v = 0;	if(!surfFeature) return(anchor);		drawOrigin = environment->GetDrawOrigin();	if(theScaleThing)theType = EDIT_POLYGON;	else theType = surfFeature->GetEditType();	switch(theType)		{		case EDIT_POLYGON:		case EDIT_REGPOLYGON:				anchor.h = origin.h - drawOrigin.h;			anchor.v = origin.v - drawOrigin.v;			break;				case EDIT_RECTANGLE:			length = points->ALength();			where = nextIndex(mark,2,length);			points->Get(where,&lp);			anchor.h = lp.h - drawOrigin.h;			anchor.v = lp.v - drawOrigin.v;			break;		}			return(anchor);	}void SurfObject::Scale() 	{	V_Array		*pnts;	Point3DFFixed	pt3D;	PointFFixed	*wp,pt;	PointFFixed	tmpMax,tmpMin,orgn;	PointLong	*lp,*lp2,cmin,cmax;	int		i,length,viewSide;		viewSide = environment->GetSide();			if(surfFeature) 		{ 		pnts = surfFeature->localOutline; 		orgn = surfFeature->posn->GetOrigin2D();		}	else 		{ 		pnts = surfDef->localOutline;		orgn = PtFFZero;		}		length = pnts->ALength();	points->SetLength(length);				wp = (PointFFixed*)pnts->Use();	lp = (PointLong*)points->Use();	lp2 = lp;			origin = environment->ScalePoint(orgn);	if(SURF_INSIDE == viewSide)origin.h = -origin.h;	tmpMin = PtFFMax;	tmpMax = PtFFMin;	cmin.h = cmax.h = origin.h;	cmin.v = cmax.v = origin.v;	for(i = 0;i < length; i++,lp++,wp++)		{				pt = *wp;				FFMin(tmpMin.h,tmpMin.h,pt.h);		FFMin(tmpMin.v,tmpMin.v,pt.v);		FFMax(tmpMax.h,tmpMax.h,pt.h);		FFMax(tmpMax.v,tmpMax.v,pt.v);		*lp = environment->ScalePoint(pt);		if(SURF_INSIDE == viewSide)lp->h = -lp->h;		cmin.h = min(cmin.h,lp->h);		cmin.v = min(cmin.v,lp->v);		cmax.h = max(cmax.h,lp->h);		cmax.v = max(cmax.v,lp->v);	 	}	 		featureMin.h = tmpMin.h.intg;	featureMin.v = tmpMin.v.intg;	featureMax.h = tmpMax.h.intg;	featureMax.v = tmpMax.v.intg;			points->Unuse();		pnts->Unuse();	origin.h = cmin.h + ((cmax.h - cmin.h)>>1);	origin.v = cmin.v + ((cmax.v - cmin.v)>>1);		dirty = FALSE;	}int SurfObject::SelectRect(Rect *r) 	{	if((r->top >= featureMax.v) && (r->bottom <= featureMin.v)		&& (r->left <= featureMin.h) && (r->right >= featureMax.h))		return(TRUE);	return(FALSE);	}	int SurfObject::MoveSurf(Point anchor,Point last,FFixed angle,long modifiers) 	{	V_Array 	*pp;	Point		pointArray[4];	PointLong	*lp,drawOrigin,ap;	Point		*rp,dif,p0,p2,pt,l1,l2,r1,r2,p1;	long		xx,yy;	int			i,length,tmpKind,prev1,prev,next,next1,next2;	int			restrict,rad,rotAngle,result = TRUE;			if(!surfFeature) return(FALSE);		drawOrigin = environment->GetDrawOrigin();	length = points->ALength();	lp = (PointLong*)points->Use();		if(IN_POLY == mode)		{		drawOrigin.h += anchor.h - last.h;		drawOrigin.v += anchor.v - last.v;		VMoveTo(lp[length-1].h - drawOrigin.h,lp[length-1].v - drawOrigin.v);		for(i = 0; i < length; i++,lp++) VLineTo(lp->h - drawOrigin.h,lp->v - drawOrigin.v);		}	else		{		if(modifiers&OPT_EDIT_MODE)tmpKind = EDIT_POLYGON; else tmpKind = surfFeature->GetEditType();				switch(tmpKind)			{			case EDIT_POLYGON:				prev1 = prevIndex(mark,2,length);				prev = prevIndex(mark,1,length);				next = nextIndex(mark,1,length);				next1 = nextIndex(mark,2,length);				switch(mode)					{					case ON_POLY_DEFLINE:						next2 = nextIndex(mark,3,length);						dif.h = anchor.h - last.h;						dif.v = anchor.v - last.v;						r1.h = lp[prev1].h - drawOrigin.h;r1.v = lp[prev1].v - drawOrigin.v;						r2.h = lp[prev].h - drawOrigin.h;r2.v = lp[prev].v - drawOrigin.v;						p1.h = lp[mark].h - drawOrigin.h - dif.h;p1.v = lp[mark].v - drawOrigin.v - dif.v;						p2.h = lp[next].h - drawOrigin.h - dif.h;p2.v = lp[next].v - drawOrigin.v - dif.v;						l2.h = lp[next1].h - drawOrigin.h;l2.v = lp[next1].v - drawOrigin.v;						l1.h = lp[next2].h - drawOrigin.h;l1.v = lp[next2].v - drawOrigin.v;			if((4 < length) && !(V_CONTROL&modifiers) 				&& !LineConvex(l1,l2,r1,r2,p1,p2))					result = FALSE;												if(result)							{							VMoveTo(r2.h,r2.v);							VLineTo(p1.h,p1.v);							VLineTo(p2.h,p2.v);							VLineTo(l2.h,l2.v);							}						else							{							VMoveTo(l2.h,l2.v);							VLineTo(r2.h,r2.v);							}							break;										case ON_POLY_POINT:						l1.h = lp[prev1].h - drawOrigin.h;l1.v = lp[prev1].v - drawOrigin.v;						l2.h = lp[prev].h - drawOrigin.h;l2.v = lp[prev].v - drawOrigin.v;						r2.h = lp[next].h - drawOrigin.h;r2.v = lp[next].v - drawOrigin.v;						r1.h = lp[next1].h - drawOrigin.h;r1.v = lp[next1].v - drawOrigin.v;												if(!(modifiers&V_CONTROL) && !PointConvex(l1,l2,r1,r2,last))							{							VMoveTo(l2.h,l2.v);							VLineTo(r2.h,r2.v);								result = FALSE;							}						else							{							VMoveTo(l2.h,l2.v);							VLineTo(last.h,last.v);							VLineTo(r2.h,r2.v);							result = TRUE;							}												break;					}				break;						case EDIT_RECTANGLE:				next1 = nextIndex(mark,2,length);				p0.h = lp[mark].h - drawOrigin.h;				p0.v = lp[mark].v - drawOrigin.v;				p2.h = lp[next1].h - drawOrigin.h;				p2.v = lp[next1].v - drawOrigin.v;				pt.h = last.h - p0.h;				pt.v = last.v - p0.v;				if(SURF_INSIDE == environment->GetSide()) 					angle = FFNeg(surfFeature->posn->GetOrientation2D());				else angle = surfFeature->posn->GetOrientation2D();				switch(mode)					{					case ON_POLY_DEFLINE:						if(0 == mark || 2 == mark) restrict = LIM_VERT; else restrict = LIM_HORZ;						break;										case ON_POLY_POINT:						restrict = LIM_NONE;						break;					}				RotateRect(pointArray,p0,p2,pt,angle,restrict,TRUE);				break;						case EDIT_REGPOLYGON:				pt.h = origin.h - drawOrigin.h;				pt.v = origin.v - drawOrigin.v;				last.h -= pt.h;last.v -= pt.v;				xx = (long)last.h * last.h;				yy = (long)last.v * last.v;				rad = LSqrt(xx + yy);				switch(mode)					{					case ON_POLY_DEFLINE: 						ap = *lp;						ap.h -= origin.h;						ap.v -= origin.v;						rotAngle = FindAngle(ap.h,ap.v);						break;											case ON_POLY_POINT: 						rotAngle = FindAngle(last.h,last.v);						break;					}									pp = RegularPoly(points->ALength(),pt,rad,rotAngle);				length = pp->ALength();				rp = (Point*)pp->Use();				VMoveTo(rp[length-1].h,rp[length-1].v);				for(i = 0; i < length; i++,rp++)					VLineTo(rp->h,rp->v);				pp->Unuse();				pp->dArray();				break;			}		}			points->Unuse();		return(result);	}	int SurfObject::ScaleSurf(Point refPt,PointFFixed mult,long modifiers) 	{	PointLong 	drawOrigin,refOrigin,*lp,tp;	PointFFixed	myMult,tmpFFPt;	Point		result;	int			i,length;	if(!surfFeature) return(FALSE);		if(!FFZero(mult.h))myMult.h = mult.h; else myMult.h = FFOne;	if(!FFZero(mult.v))myMult.v = mult.v; else myMult.v = FFOne;		drawOrigin = environment->GetDrawOrigin();	refOrigin.h = refPt.h + drawOrigin.h;			refOrigin.v = refPt.v + drawOrigin.v;						length = points->ALength();	lp = (PointLong*)points->Use();		tmpFFPt.h = FFMultIntShift(myMult.h,(lp[length-1].h - refOrigin.h),0);	tmpFFPt.v = FFMultIntShift(myMult.v,(lp[length-1].v - refOrigin.v),0);		tp.h = FFRound(tmpFFPt.h);	tp.v = FFRound(tmpFFPt.v);		result.h = tp.h + refOrigin.h - drawOrigin.h;	result.v = tp.v + refOrigin.v - drawOrigin.v;	VMoveTo(result.h,result.v);	for(i = 0; i < length; i++,lp++)		{		tmpFFPt.h = FFMultIntShift(myMult.h,(lp->h - refOrigin.h),0);		tmpFFPt.v = FFMultIntShift(myMult.v,(lp->v - refOrigin.v),0);			tp.h = FFRound(tmpFFPt.h);		tp.v = FFRound(tmpFFPt.v);		result.h = tp.h + refOrigin.h - drawOrigin.h;		result.v = tp.v + refOrigin.v - drawOrigin.v;		VLineTo(result.h,result.v);		}	points->Unuse();		return(TRUE);	}int SurfObject::RotateSurf(Point anchor,FFixed angle,long modifiers) 	{	PointLong	*lp,drawOrigin;	Point		np,p;	int			i,length,sinAngle,cosAngle;	SetAngle(360 - angle.intg,&sinAngle,&cosAngle);	drawOrigin = environment->GetDrawOrigin();	drawOrigin.h += anchor.h; drawOrigin.v += anchor.v;		length = points->ALength();	lp = (PointLong*)points->Use();			p.h = lp[length-1].h - drawOrigin.h;	p.v = lp[length-1].v - drawOrigin.v;	np.h = (((long)p.h * cosAngle - (long)p.v * sinAngle +64) >> 7) + anchor.h;	np.v = (((long)p.h * sinAngle + (long)p.v * cosAngle +64) >> 7) + anchor.v;	VMoveTo(np.h,np.v);		for(i = 0; i < length; i++,lp++)		{		p.h = lp->h - drawOrigin.h;		p.v = lp->v - drawOrigin.v;		np.h = (((long)p.h * cosAngle - (long)p.v * sinAngle +64) >> 7) + anchor.h;		np.v = (((long)p.h * sinAngle + (long)p.v * cosAngle +64) >> 7) + anchor.v;		VLineTo(np.h,np.v);		}	points->Unuse();		return(TRUE);	}	int SurfObject::BreakLine(Point p) 	{	PointLong	*lp,drawOrigin;	Point		l1,l2,r1,r2;	int		i,length,result;	short		next,next1,prev1;		drawOrigin = environment->GetDrawOrigin();	length = points->ALength();	lp = (PointLong*)points->Use();			next = nextIndex(mark,1,length);	l2.h = lp[mark].h - drawOrigin.h;l2.v = lp[mark].v - drawOrigin.v;	r2.h = lp[next].h - drawOrigin.h;r2.v = lp[next].v - drawOrigin.v;		prev1 = prevIndex(mark,1,length);	l1.h = lp[prev1].h - drawOrigin.h;l1.v = lp[prev1].v - drawOrigin.v;		if( ON_POLY_DEFLINE == mode)		{		next1 = nextIndex(mark,2,length);		r1.h = lp[next1].h - drawOrigin.h;r1.v = lp[next1].v - drawOrigin.v;		if(!PointConvex(l1,l2,r1,r2,p))			{			VMoveTo(l2.h,l2.v);			VLineTo(r2.h,r2.v);				result = FALSE;			}		else			{			VMoveTo(l2.h,l2.v);			VLineTo(p.h,p.v);			VLineTo(r2.h,r2.v);			result = TRUE;			}		}	else		{		VMoveTo(l1.h,l1.v);		VLineTo(l2.h,l2.v);		VLineTo(r2.h,r2.v);		result = TRUE;		}	points->Unuse();		return(result);	}	void SurfObject::SetRealFeature(CAVSurfFeature *newFeature)  { surfFeature = newFeature; }CAVSurfFeature *SurfObject::GetRealFeature(void)  { return(surfFeature); }void SurfObject::SetEditType(int newKind)  { surfFeature->SetEditType(newKind); }int SurfObject::GetEditType()  { return(surfFeature->GetEditType()); }void SurfObject::SetDirty(int newState)  { dirty = newState; }void SurfObject::SetMode(short newMode) { mode = newMode; }int SurfObject::GetMode() { return(mode); }void SurfObject::SetSide(int newSide) {  side = newSide; }int SurfObject::GetSide() { return(side); }int SurfObject::GetMark() { return(mark); }