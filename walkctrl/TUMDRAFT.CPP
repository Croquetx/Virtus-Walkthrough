/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "TumDraft.h"#include "CVTumObj.h"#include "CVEnvirn.h"#include "CVSlice.h"#include "TumCntrl.h"#include "Geometry.h"#include "CVPolyh.h"#include "PolyConv.h"#include "Surface.h"#include "CVSrfDef.h"#include "CVDefs.h"#include "PolyDefs.h"#include "Misc.h"#include "VMDL.h"#include "AppMssgs.h"#include "AppText.h"#include "Unit.h"#include "BallHelp.h"#include "UndoBuf.h"#include "PolyUndo.h"#include "SurfUndo.h"#include "ToolDef.h"#include "Space.h"#include "Position.h"#include "Clip.h"#include "VGraphic.h"#include "VGUtil.h"#include "VError.h"#if VPRO#include "TextList.h"	// MERGE-VPRO-2#include "TextItem.h"	//needed for prototype of textitem#endif // VPRO#include <stdlib.h>#include <math.h>extern	struct V_Buffer *clipBuf;/* in WalkThrough.c */void TumbleDraft::SetController(Controller *ctrl) 	{	CadDraft::SetController(ctrl);#if VWT	menu->SetController(controller);#endif //VWT	}voidTumbleDraft::cPane(int flag)	{		V_MenuMgr	*mgr;		CadDraft::cPane(flag);		dx = dy = 0;	polyhedron = NULL;	tumble = new(CAVTumbleObject);	tumble->cCAVTumbleObject();	tumble->SetEnvironment(environment);		space = ((Space *)new(Space))->cSpace();		selectedList = new(V_Array);	selectedList->cArray(0,sizeof(int),4);	editList->dArray();	editList = new(V_Array);	editList->cArray(0,sizeof(int),4);	#if VWT	mgr = GetMenuMgr();	menu = new(MenuTumble);	menu->ctheMenu();	mgr->Append(menu);#endif //VWT		SetOptions(0);	}voidTumbleDraft::dPane()	{#if VWT	menu->dMenu();#endif //VWT	selectedList->dArray();	space->dSpace();	tumble->dCAVTumbleObject();	CadDraft::dPane();	}	voidTumbleDraft::SetPolyhedron(CAVPolyhedron *newPoly)	{		polyhedron = newPoly;	tumble->SetPolyhedron(newPoly);	}void TumbleDraft::CalcSize(Rect *r,Point *p,int type,int warning)	{		Point3DFFixed	orgn;	PointFFixed	pt;	Point	c;	 	CadDraft::CalcSize(r,p,type,warning);	if(INSTALL == type)		{				orgn = polyhedron->posn->GetOrigin();		tumble->SetOrigin(orgn);		c.h = r->left + ((r->right-r->left)>>1);		c.v = r->top + ((r->bottom-r->top)>>1);		pt = Local2World(c,SCALE_ABSOLUTE);		MoveView(PtFFZero,pt);		ffLastPt = origin;		lastPositionR = World2Local(ffLastPt,SCALE_ABSOLUTE);		}	}voidTumbleDraft::TrackHelp(Point pt, long modifier)// DAS-VWINDOWS 9/30/93	{// { DAS-VR-HELP 9/30/93#if VWT	Rect r;		if(modeNone == editMode)		{		r = dataRect;		BalloonHotRect(&r,pt);		Bubble(pt,&r,TXTB_TUMBLEVIEW);		}#endif// } DAS-VR-HELP 9/30/93	}voidTumbleDraft::Display(int type,int h,int v)	{	Rect r;	if(-DRAW != type)		CadDraft::Display(type,h,v);	else		{		SetMetaPort();		r = dataRect;		if(DrawInColor())			{			VForeColor(&color);			VPaintRect(&r);			}		else			VEraseRect(&r);				if(displayFlags && horzGrid && vertGrid)		 	DrawGrid();			DrawContent(type);	   	MetaCopy(&r);		UnsetMetaPort();		}	}	voidTumbleDraft::DrawContent(int type)	{	Rect r;	int	i,length;	int	*selSurf;		r = dataRect;			switch(type)		{			case PICT_DRAW:				tumble->Display();			break;					case PRINT_DRAW:			tumble->SetDirty(TRUE);			tumble->Update(space->m);			tumble->Display();			tumble->SetDirty(TRUE);			break;		case -ACT_REBUILD_DRAW:			tumble->SetDirty(TRUE);			type = ACT_REBUILD_DRAW;					case ACT_REBUILD_DRAW:			selectedList->SetLength(0);				default:				sphereRadius = min(centerX,centerY);			sphereRadius = tumble->boundR + ((abs(sphereRadius-tumble->boundR))>>1);				case -DRAW:			tumble->Update(space->m);			tumble->Display();		 			if(lineState)DrawHandles(TRUE);			if(length = selectedList->ALength())				{				selSurf = (int*)selectedList->Use();				for(i = 0; i < length; i++,selSurf++)					tumble->Select(*selSurf,TRUE);				selectedList->Unuse();				}			break;		}	CadDraft::DrawContent(type);	}void TumbleDraft::Update() 	{	tumble->SetDirty(POLY_MUSSED);	CadDraft::Update();	}void TumbleDraft::GetVirtual(Rect *r) 	{		Point3DFFixed b3DMin,b3DMax;	FFixed	bMin,bMax;	int	bRadius;		((CAVPolyhedron*)polyhedron)->Extrema(&b3DMin,&b3DMax);	FFMin(bMin,b3DMin.x,b3DMin.y);	FFMin(bMin,bMin,b3DMin.z);	FFMax(bMax,b3DMax.x,b3DMax.y);	FFMax(bMax,bMax,b3DMax.z);	FFMax(bMax,bMax,FFNeg(bMin))	bRadius = FFRound(bMax);		r->top = bRadius;	r->left = -bRadius;	r->bottom = -bRadius;	r->right = bRadius;	 	CadDraft::GetVirtual(r);	}		void TumbleDraft::OrientNormal(Point3DFFixed normal)	{	double			roll,pitch,yaw,xx,yy,zz;	space->MatrixToAngle(&roll,&pitch,&yaw);			xx = FixedToDbl(normal.x);	yy = FixedToDbl(normal.y);	zz = FixedToDbl(normal.z);	if(0 != normal.x.l) roll = atan2(xx,zz); else roll = 0;	if(0 != normal.z.l) pitch = atan2(zz,yy);else pitch = 0;	if(0 != normal.y.l) yaw = atan2(yy,xx);  else yaw = 0;		space->AngleToMatrix(roll,pitch,yaw);	}void TumbleDraft::SetOrient(Angle3DFFixed orientation)	{		space->AngleToMatrix(FixedToDbl(orientation.roll),FixedToDbl(orientation.pitch),FixedToDbl(orientation.yaw));	}Angle3DFFixed TumbleDraft::GetOrient()	{		Angle3DFFixed orientation;	double	r,p,y;	space->MatrixToAngle(&r,&p,&y);	orientation.roll = DblToFixed(r);	orientation.pitch = DblToFixed(p);	orientation.yaw = DblToFixed(y);	return(orientation);	}voidTumbleDraft::SetSlice(CAVSlice *theSlice)	{	Angle3DFFixed	nO;			if(!theSlice) lineState = FALSE;	else		{		lineState = TRUE;		nO = theSlice->GetOrientation();		space->AngleToMatrix(FixedToDbl(nO.roll),FixedToDbl(nO.pitch),FixedToDbl(nO.yaw));			}	}	void TumbleDraft::Handles(int state)	{	if(lineState != state)		{		SetPane();		DrawHandles(state);		lineState = state;		UnsetPane();		}	}	void TumbleDraft::DrawHandles(int state)	{	CAVSlice *theSlice;	PointFFixed		wStart,wFinish;	Rect	handle;	Point	lStartPt,lEndPt;		lineState = state;		if(lineState && (theSlice = ptc(controller)->GetSlice()))		{		theSlice->GetEndPoints(&wStart,&wFinish);		WorldSpace(TO_CAD,&wStart,&wFinish);		startPt = World2Local(wStart,SCALE_RELATIVE);		endPt = World2Local(wFinish,SCALE_RELATIVE);			}			VPenMode(vPatXor);	VSetPattern(vPatBlack);	if(DrawInColor())		VForeColor(&vBlack);	else		VSetPattern(vPatBlack);			lStartPt.h = startPt.h - lOrigin.h;	lStartPt.v = startPt.v - lOrigin.v;	handle.left   = lStartPt.h - 2;	handle.right  = lStartPt.h + 3;	handle.top    = lStartPt.v - 2;	handle.bottom = lStartPt.v + 3;	VPaintRect(&handle);		lEndPt.h = endPt.h - lOrigin.h;	lEndPt.v = endPt.v - lOrigin.v;	handle.left   = lEndPt.h - 2;	handle.right  = lEndPt.h + 3;	handle.top    = lEndPt.v - 2;	handle.bottom = lEndPt.v + 3;	VPaintRect(&handle);	VMoveTo(lStartPt.h,lStartPt.v);	VLineTo(lEndPt.h,lEndPt.v);		VPenMode(vPatCopy);				if(!lineState)		{		controller->Request(NULL,msgReset,objSlice,0);		SetPane();		}	}voidTumbleDraft::WorldSpace(int direction,PointFFixed *pt1,PointFFixed *pt2)	{	Position	*posn,*polyPosn;	Angle3DFFixed	orient,rotateAngle;	Point3DFFixed	pt3D;		orient = GetOrient();	polyPosn = new(Position);	polyPosn->cPosition();	polyPosn->SetScale(polyhedron->posn->GetScale());	polyPosn->SetShear(polyhedron->posn->GetShear());	posn = new(Position);	posn->cPosition();	rotateAngle = Ang3DFFZero; rotateAngle.pitch = orient.yaw;	posn->Rotate3D(rotateAngle,Pt3DFFZero);	rotateAngle = Ang3DFFZero; rotateAngle.roll = orient.pitch;	posn->Rotate3D(rotateAngle,Pt3DFFZero);	rotateAngle = Ang3DFFZero; rotateAngle.yaw = orient.roll;	posn->Rotate3D(rotateAngle,Pt3DFFZero);	pt3D.x = pt1->h;	pt3D.y = FFZero;	pt3D.z = pt1->v;	pt3D = posn->UnTransform3D(pt3D);	if(TO_WORLD == direction)		pt3D = polyPosn->UnTransform3D(pt3D);	else		pt3D = polyPosn->Transform3D(pt3D);		pt3D = posn->Transform3D(pt3D);		pt1->h = pt3D.x;	pt1->v = pt3D.z;	pt3D.x = pt2->h;	pt3D.y = FFZero;	pt3D.z = pt2->v;	pt3D = posn->UnTransform3D(pt3D);	if(TO_WORLD == direction)		pt3D = polyPosn->UnTransform3D(pt3D);	else		pt3D = polyPosn->Transform3D(pt3D);		pt3D = posn->Transform3D(pt3D);		pt2->h = pt3D.x;	pt2->v = pt3D.z;	posn->dPosition();	polyPosn->dPosition();	}		voidTumbleDraft::MouseDown(Point p,long modifiers)	{		CadDraft::MouseDown(p,modifiers);		switch(editTool)		{					case bFINGER:			if(lineState)DrawHandles(FALSE);			InSelectedList(p,modifiers);			break;					default: 			break;		}	}void TumbleDraft::LaunchEditor() 	{	SurfDef	*surfDef;	int		ctrlType,surfNum;			editList->Get(0,&surfNum);	surfDef = GetSurface(surfNum);		switch(editTool)		{		case bSURFACE_EDITOR: ctrlType = toolCRTLSurface; break;		case bLIGHT_EDITOR:	ctrlType = toolCRTLLight; break;		}			CadDraft::LaunchEditor();	pcc(controller)->LaunchEditor(polyhedron,DblToFixed(userZoom),surfDef,Pt3DFFZero,ctrlType);	}intTumbleDraft::InSelectedList(Point p,long modifiers)	{	TextureItem		*texture;		// ABD WILLIAMS MERGE-TEXTURE 9/13/93	SurfDef	*surfDef;	Point	sp;	RGBColor color;		int	newSurf;	draftAction = OFF_SLICE;	sp.h = lOrigin.h + p.h;	sp.v = lOrigin.v + p.v;			if((TRUE == lineState) && (bARROW == editTool))		{		if(MY_SELECT_RANGE > abs(sp.h-endPt.h) &&  MY_SELECT_RANGE > abs(sp.v-endPt.v)) 			draftAction = ON_SLICE_END;		else if(MY_SELECT_RANGE > abs(sp.h-startPt.h) &&  MY_SELECT_RANGE > abs(sp.v-startPt.v)) 			draftAction = ON_SLICE_BEGIN;		else 			if(PtOnLine(sp,startPt,endPt)) draftAction = ON_SLICE; 				}			if( OFF_SLICE != draftAction )		editAction = modeTranslate;	else		{		editAction = modeNone;		newSurf = tumble->Find(sp);		if(NO_MARK == newSurf)  			TumbSelect(NO_MARK,!(MULTIPLE_SELECT&modifiers));		else			{			draftAction = ON_POLY;			TumbSelect(newSurf,!(MULTIPLE_SELECT&modifiers));			SetPane();			selectedList->CopyArray(editList);			if(doubleClick&modifiers) 				{				FrontSurface(newSurf);				controller->Request(NULL,msgEdit,objTumble,0);					}			if(bDROPPER == editTool)				{				surfDef = GetSurface(newSurf);                // jca 20OCT94 PRO [[[ added texture selecting				if(OPT_EDIT_MODE&modifiers)					{					color = surfDef->GetColor(SURF_INSIDE);					texture = surfDef->GetTexture(SURF_INSIDE);		// ABD MERGE-TEXTURE 9/13/93					}				else					{					color = surfDef->GetColor(SURF_OUTSIDE);					texture = surfDef->GetTexture(SURF_OUTSIDE);		// ABD MERGE-TEXTURE 9/13/93					}				pcc(controller)->ColorDropper(color, texture);		// DUDE !!! ??? pass texture here				// ]]] jca 20OCT94				draftAction = OFF_SLICE;				}			}		}				return(draftAction);	}	voidTumbleDraft::TumbSelect(int surfNum,int reset)	{	int	i,length,where;	int *selSurf;		SetPane();		length = selectedList->ALength();	if(reset && length)		{		selSurf = (int*)selectedList->Use();		for(i = 0; i < length; i++,selSurf++)		// MERGE-VPRO-2 [[[		#if VPRO			tumble->Select(*selSurf,DESELECT);		// ABD DESELECT == -1 to deselect surfaces		#else			tumble->Select(*selSurf,FALSE);		#endif // VPRO		// MERGE-VPRO-2 ]]]		selectedList->Unuse();		selectedList->SetLength(0);		length = 0;		}			if(NO_MARK != surfNum)		{		if(lineState) DrawHandles(FALSE);		where = selectedList->Find(&surfNum);		if(!reset && 0 <= where) 			{			selectedList->Remove(where);			tumble->Select(surfNum,FALSE);			}		else 			{			selectedList->Insert(0,&surfNum);			tumble->Select(surfNum,TRUE);			}		}		UnsetPane();	}intTumbleDraft::IO_OBJECT(V_Buffer *buf)	{	CAVSlice	*nSlice;	Unit		*worldUnit,*unit;	FFixed		factor;	long		id;    int 		err = 0;	worldUnit = polyhedron->GetUnit();nSlice = NULL;	if(buf->IODirection() == DATA_IN)		{				unit = new(Unit);		unit->cUnit();		worldUnit->Copy(unit);		while (TRUE)			{			id = buf->OpenChunkR();			if (id == 0) break;						switch(id)				{				case IFF_VERS:					IO_VERS(clipBuf);					break;									case IFF_UNIT:					unit->IO(buf);					break;				case IFF_SLIC:					nSlice = new(CAVSlice);					nSlice->cSlice(FFZero,FFZero,FFZero,FFZero);					nSlice->IO(buf);					polyhedron->AddSlice(nSlice);					break;										case IFF_ESLC: 					factor = DblToFixed(unit->ConvertTo(worldUnit));					nSlice->IO_ESLC(buf); 					nSlice->ChangeUnit(factor);					polyhedron->Update();					break;									default: break;				}					buf->CloseChunk();			}		unit->dUnit();		if(nSlice)			{			SetSlice(nSlice);			controller->EditPolyhedron(polyhedron,objSlice);			lineState = TRUE;			controller->Request(NULL,msgEdit,objSlice,0);			}		}	else		{				if(nSlice = ptc(controller)->GetSlice())			{			buf->OpenChunkW(IFF_VERS);			IO_VERS(clipBuf);			buf->CloseChunk();			buf->OpenChunkW(IFF_UNIT);			worldUnit->IO(buf);			buf->CloseChunk();			buf->OpenChunkW(IFF_SLIC);			nSlice->IO(buf);			buf->CloseChunk();			buf->OpenChunkW(IFF_ESLC);			nSlice->IO_ESLC(buf);			buf->CloseChunk();			}		}    return(err);	}int TumbleDraft::EditBuffer(long action,long modifiers) 	{	EditSpecList	*undoItem;	EditSpec		*undoSpec;	V_Array			*undoItems;	CAVSlice		*theSlice;	int				undoType;	int 			err = noErr;			// jca 20 Oct 93			switch(action)		{					case  MSG_COPY:			clipBuf->IOSetLength(0);			clipBuf->IOSetPosition(0);			clipBuf->IOSetDirection(DATA_OUT);			IO_ID(clipBuf,IFF_SLIC);			err = IO_OBJECT(clipBuf);					// jca 20 Oct 93 			break;				case  MSG_DUPLICATE:				if(EditBuffer(MSG_COPY,modifiers) < noErr)	break;			err = EditBuffer(MSG_PASTE,modifiers);				// jca 20 Oct 93			break;					case MSG_PASTE:			clipBuf->IOSetPosition(0);			clipBuf->IOSetDirection(DATA_IN);			IO_ID(clipBuf,IFF_SLIC);			err = IO_OBJECT(clipBuf);				// jca 20 Oct 93			controller->EditPolyhedron(polyhedron,objSlice);			lineState = TRUE;			controller->Request(NULL,msgEdit,objView,0);			break;		case MSG_CUT:				err = EditBuffer(MSG_COPY,modifiers);				// jca 20 Oct 93		case  MSG_CLEAR:				if(!(theSlice = ptc(controller)->GetSlice())) return(FALSE);						undoItem = NewUndoItem(UNDO_POLY_FLAG);			undoSpec = undoItem->cEditSpec(_EDIT_SLICEDES);			((UPolySlice*)undoSpec)->SetSlice(theSlice);			undoItem->SetEditObject((CAVPolyhedron*)polyhedron,NULL,UNDO_POLY_FLAG);			undoItem->Edit();			lineState = FALSE;			controller->Request(NULL,msgEdit,objSlice,0);			controller->EditPolyhedron(polyhedron,objSlice);			controller->Request(NULL,msgEdit,objView,0);			break;		case  MSG_UNDO:				undoItem = UndoItem();			undoType = undoItem->GetType();			if(UNDO_NONE_FLAG != undoType)				{				undoItems = new(V_Array);				undoItems->cArray(0,sizeof(void*),4);				undoType = undoItem->GetItems(UNDO_POLY_FLAG|UNDO_SURF_FLAG,undoItems);				undoItem->Reverse();				undoItem->Edit();								tumble->SetDirty(TRUE);				if(UNDO_POLY_FLAG == undoType)					{					lineState = FALSE;					undoSpec = undoItem->IsAction(_EDIT_SLICECRT);					if(undoSpec)						{						theSlice = ((UPolySlice*)undoSpec)->GetSlice();						SetSlice(theSlice);						}					controller->Request(NULL,msgEdit,objSlice,0);					controller->EditPolyhedron(polyhedron,objSlice);					}				else					{					controller->EditPolyhedron(polyhedron,objColor);					controller->Request(NULL,msgEdit,objView,0);					}				undoItems->dArray();				}			break; 		}	return(err);			// jca 20 Oct 93	}	voidTumbleDraft::SetColor(RGBColor color)	{	SurfDef			*surfDef;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	int 	i,length,opc,editSide;	int	*selSurf;		editSide = ptc(controller)->GetEditSide();	if (!selectedList->ALength()) 		{		opc = polyhedron->GetOpacity();		undoItem = NewUndoItem(UNDO_POLY_FLAG);		undoSpec = undoItem->cEditSpec(_EDIT_COLOR);		((UPolyColor*)undoSpec)->SetColor(color,opc,editSide);		undoItem->SetEditObject((CAVPolyhedron*)polyhedron,NULL,UNDO_POLY_FLAG);		}	else 		{		undoItem = NewUndoItem(UNDO_SURF_FLAG);		undoSpec = undoItem->cEditSpec(_EDIT_COLOR);		((USurfColor*)undoSpec)->SetColor(color,editSide);				length = selectedList->ALength();		selSurf = (int*)selectedList->Use();		for( i = 0; i < length; i++,selSurf++)			if(surfDef = GetSurface(*selSurf))				undoItem->EditSurface(surfDef,NULL);		selectedList->Unuse();		}	undoItem->Edit();					controller->EditPolyhedron(polyhedron,objColor);	/* dude -  if drawing color by poly I need to update the design views too */	controller->Request(NULL,msgEdit,objView,0);	}// ABD MERGE-GOURAUD [[[	void TumbleDraft::SetShadeType ( unsigned char shade_type )	{	SurfDef			*surfDef;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	int 	i,length,opc,editSide;	int	*selSurf;		editSide = ptc(controller)->GetEditSide();	if (!selectedList->ALength()) 		{		opc = polyhedron->GetOpacity();		undoItem = NewUndoItem(UNDO_POLY_FLAG);		undoSpec = undoItem->cEditSpec(_EDIT_GOURAUD);		((UPolyGouraud*)undoSpec)->SetShadeType(shade_type,editSide);		undoItem->SetEditObject((CAVPolyhedron*)polyhedron,NULL,UNDO_POLY_FLAG);		}	else 		{		undoItem = NewUndoItem(UNDO_SURF_FLAG);		undoSpec = undoItem->cEditSpec(_EDIT_GOURAUD);		((USurfGouraud*)undoSpec)->SetShadeType(shade_type,editSide);				length = selectedList->ALength();		selSurf = (int*)selectedList->Use();		for( i = 0; i < length; i++,selSurf++)			if(surfDef = GetSurface(*selSurf))				undoItem->EditSurface(surfDef,NULL);		selectedList->Unuse();		}	undoItem->Edit();					controller->EditPolyhedron(polyhedron,objColor);	/* dude -  if drawing color by poly I need to update the design views too */	controller->Request(NULL,msgEdit,objView,0);	}// ABD MERGE-GOURAUD ]]]voidTumbleDraft::SetOpacity(int opacity)	{	SurfDef			*surfDef;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	int		i,length,editSide;	int 	*selSurf;		editSide = ptc(controller)->GetEditSide();	if (!selectedList->ALength()) 		{		undoItem = NewUndoItem(UNDO_POLY_FLAG);		undoSpec = undoItem->cEditSpec(_EDIT_COLOR);		((UPolyColor*)undoSpec)->SetColor(polyhedron->GetColor(editSide),opacity,editSide);		undoItem->SetEditObject((CAVPolyhedron*)polyhedron,NULL,UNDO_POLY_FLAG);		}	else 		{		undoItem = NewUndoItem(UNDO_SURF_FLAG);		undoSpec = undoItem->cEditSpec(_EDIT_OPACITY);		((USurfOpacity*)undoSpec)->SetOpacity(opacity);				length = selectedList->ALength();		selSurf = (int*)selectedList->Use();		for( i = 0; i < length; i++,selSurf++)			if(surfDef = GetSurface(*selSurf))				undoItem->EditSurface(surfDef,NULL);		selectedList->Unuse();		}		undoItem->Edit();			controller->EditPolyhedron(polyhedron,objColor);	/* dude -  if drawing color by poly I need to update the design views too */	controller->Request(NULL,msgEdit,objView,0);	}int TumbleDraft::DoTranslate(long modifiers) 	{		Point	diff,lStartPt,lEndPt;		if(bARROW != editTool) return(FALSE);		lStartPt.h = startPt.h-lOrigin.h;	lStartPt.v = startPt.v-lOrigin.v;	lEndPt.h = endPt.h-lOrigin.h;	lEndPt.v = endPt.v-lOrigin.v;		switch(draftAction)		{		case ON_SLICE_END: 			VMoveTo(lStartPt.h,lStartPt.v);			VLineTo(lastPosition.h,lastPosition.v);				break;		case ON_SLICE_BEGIN:			VMoveTo(lastPosition.h,lastPosition.v);				VLineTo(lEndPt.h,lEndPt.v);			break;					case ON_SLICE: 			diff.h = lastPosition.h - anchorPosition.h;			diff.v = lastPosition.v - anchorPosition.v;			VMoveTo(lStartPt.h + diff.h,lStartPt.v + diff.v);				VLineTo(lEndPt.h + diff.h,lEndPt.v + diff.v);			break;				default:			return(FALSE);			break;		}			return(TRUE);	}		voidTumbleDraft::CreateObject(Point p,long modifiers)	{	EditSpecList	*undoItem;	EditSpec		*undoSpec;	Angle3DFFixed	new0;	PointFFixed		base,point;	FFixed aa,bb,cc,dd;	double		nr,np,ny;	undoItem = NewUndoItem(UNDO_POLY_FLAG);		tempFFPoints->Get(0,&base);	tempFFPoints->Get(1,&point);	BuildSlice(FALSE,&point,&base,&aa,&bb,&cc,&dd);	space->MatrixToAngle(&nr,&np,&ny);	new0.roll = DblToFixed(nr); 	new0.pitch = DblToFixed(np); 	new0.yaw = DblToFixed(ny);	undoSpec = undoItem->cEditSpec(_EDIT_SLICECRT);	((UPolySlice*)undoSpec)->SetOrientation(new0);	((UPolySlice*)undoSpec)->SetDefinition(aa,bb,cc,dd);	((UPolySlice*)undoSpec)->SetEnds(base,point);				undoItem->SetEditObject((CAVPolyhedron*)polyhedron,NULL,UNDO_POLY_FLAG);		undoItem->Edit();		controller->EditPolyhedron(polyhedron,objSlice);	lineState = TRUE;	controller->Request(NULL,msgEdit,objSlice,0);	}	voidTumbleDraft::UpdateObject(long modifiers)	{	CAVSlice		*theSlice;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	PointFFixed		base,point,offset;	FFixed 			cA,cB,cC,cD;	if( bARROW != editTool ) return;	undoItem = NewUndoItem(UNDO_POLY_FLAG);/*	base = Local2World(anchorPosition,SCALE_RELATIVE);	point = Local2World(lastPosition,SCALE_RELATIVE);*/	tempFFPoints->Get(0,&base);	tempFFPoints->Get(1,&point);	WorldSpace(TO_WORLD,&point,&base);	offset.h = FFSub(point.h,base.h);	offset.v = FFSub(point.v,base.v);		theSlice = ptc(controller)->GetSlice();	theSlice->GetEndPoints(&base,&point);		if(draftAction & ON_SLICE_END)		{		point.h = FFAdd(offset.h,point.h);		point.v = FFAdd(offset.v,point.v);		}	if(draftAction & ON_SLICE_BEGIN)		{		base.h = FFAdd(offset.h,base.h);		base.v = FFAdd(offset.v,base.v);		}	WorldSpace(TO_CAD,&point,&base);	BuildSlice(modifiers&OPT_EDIT_MODE ? TRUE : FALSE,&point,&base,&cA,&cB,&cC,&cD);		undoSpec = undoItem->cEditSpec(_EDIT_SLICE);	((UPolySlice*)undoSpec)->SetOrientation(theSlice->GetOrientation());	((UPolySlice*)undoSpec)->SetDefinition(cA,cB,cC,cD);	((UPolySlice*)undoSpec)->SetEnds(base,point);	((UPolySlice*)undoSpec)->SetSlice(theSlice);	lineState = TRUE;			((UPolySlice*)undoSpec)->SetEnds(base,point);				undoItem->SetEditObject((CAVPolyhedron*)polyhedron,NULL,UNDO_POLY_FLAG);		undoItem->Edit();			lineState = TRUE;	controller->EditPolyhedron(polyhedron,objSlice);	controller->Request(NULL,msgEdit,objView,0);	}voidTumbleDraft::BuildSlice(short altDirection,PointFFixed *point ,PointFFixed *base ,FFixed *a,FFixed *b,FFixed *c,FFixed *d)	{		Position	*posn;	Angle3DFFixed	orient,rotateAngle;	Point3DFFixed	pt;	PointFFixed	temp;	FFixed 	cA,cB,cC;	double 	dd;	int		m[3][3];	PointFFixed	center,start,end;	Point	p;		center = PtFFZero;	/* need the apparent origin of the object here */		if(TRUE == altDirection)		{		temp = *point;		point->h = FFSub(base->h,center.h);		point->v = FFSub(base->v,center.v);		base->h = FFSub(temp.h,center.h);		base->v = FFSub(temp.v,center.v);		}	else		{		point->h = FFSub(point->h,center.h);		point->v = FFSub(point->v,center.v);		base->h = FFSub(base->h,center.h);		base->v = FFSub(base->v,center.v);		}		WorldSpace(TO_WORLD,point,base);		cA = FFSub(point->v,base->v);	cB = FFZero;	cC = FFSub(base->h,point->h);		dd = (FixedToDbl(point->h) * FixedToDbl(base->v)) - (FixedToDbl(base->h) * FixedToDbl(point->v));		while(fabs(dd)>32767.0)		{		cA = FFShift(cA,-1);		cC = FFShift(cC,-1);		dd/=2;		}		*d = DblToFixed(dd);					pt.x = cA;	pt.y = cB;	pt.z = cC;	posn = new(Position);	posn->cPosition();	orient = GetOrient();	rotateAngle = Ang3DFFZero; rotateAngle.pitch = orient.yaw;	posn->Rotate3D(rotateAngle,Pt3DFFZero);	rotateAngle = Ang3DFFZero; rotateAngle.roll = orient.pitch;	posn->Rotate3D(rotateAngle,Pt3DFFZero);	rotateAngle = Ang3DFFZero; rotateAngle.yaw = orient.roll;	posn->Rotate3D(rotateAngle,Pt3DFFZero);		pt = posn->UnTransform3D(pt);	*a = pt.x;	*b = pt.y;	*c = pt.z;	posn->dPosition();	}void TumbleDraft::SetMatrix(int vector[3][3]) { space->SetMatrix(vector); }void TumbleDraft::GetMatrix(int m[3][3]) { space->GetMatrix(m); }/* GetSurface() puts appropriate values in surface and surfDef, based on the * surface number given. */SurfDef	*TumbleDraft::GetSurface(int surf)	{	SurfDef	*surfDef = NULL;	if (surf>=0)		{		Surface	*surface = polyhedron->FindSurface(surf);		if (!surface->surfDef) surface->surfDef = polyhedron->GetSurfDef(surf);		surfDef = surface->surfDef;		}	return(surfDef);	}/* FrontSurface() brings a specified surface frontmost by altering space.  It * does this with three (animated) intermediate steps, so the user has some * sense of what's going on. */voidTumbleDraft::FrontSurface(int surf)	{	SurfDef 	*sdef;	int i,j,k;	matrix step1,step2;	int qa,qb;	long qx,qy;	Position *posn;	Angle3DFFixed rot;	Point3DFFixed ptA, ptB;		sdef = GetSurface(surf);	posn = new(Position);	posn->cPosition();	rot = Ang3DFFZero; rot.pitch = FFNeg(FFHalfPi);	posn->Rotate3D(rot, Pt3DFFZero);	posn->PositionX(sdef->position);	posn->SetOrigin3D(Pt3DFFZero);		ptA = Pt3DFFZero; ptA.x.intg = 16384;	ptA = posn->UnTransform3D(ptA);	ptB = Pt3DFFZero; ptB.y.intg = 16384;	ptB = posn->UnTransform3D(ptB);	posn->dPosition();	step1[A][X] = FFRound(ptA.x); step1[A][Y] = FFRound(ptA.y); step1[A][Z] = FFRound(ptA.z);	step1[B][X] = FFRound(ptB.x); step1[B][Y] = FFRound(ptB.y); step1[B][Z] = FFRound(ptB.z);	space->GetMatrix(step2);	for (i=1; i<5; i++)		{		for (j=0; j<3; j++)			for(k=0;k<3;k++)				{				qa = step1[j][k];				qb = i;				qx = (long)qa * qb;				qa = step2[j][k];				qb = 4-i;				qy = (long)qa*qb;				space->m[j][k] = (qx+qy)>>2;				}		Normalize();		VDisplay(-DRAW);		}	VDisplay(-DRAW);	}void	TumbleDraft::DoMomentum(Point p,int x,int y)	{	if(tumbleOptions&FRICTION_FLAG)		{		dx=(dx*((1L<<16)-(1L<<14)))>>16;		dy=(dy*((1L<<16)-(1L<<14)))>>16;		}			space->Update(x,y,dx,dy,sphereRadius);	}	void TumbleDraft::Normalize(void)	{	space->Normalize();	}void TumbleDraft::Roll(int psi)	{	space->Roll(psi);	space->Normalize();	VDisplay(-DRAW);	}void TumbleDraft::Pitch(int phi)	{	space->Pitch(phi);	space->Normalize();	VDisplay(-DRAW);	}void TumbleDraft::Yaw(int theta)	{	space->Yaw(theta);	space->Normalize();	VDisplay(-DRAW);	}voidTumbleDraft::SetPin(int newpin)	{	space->SetPin(newpin);	}PointFFixed TumbleDraft::Constrain(Point *p,long modifiers)	{	PointFFixed	result;	Point	constPt,testPt;	FFixed	tmpAngle;	int		minDimension;	Point	spherePt;	long 	inSphere;		if(bHAND == editTool)		{		if( (CONSTRAIN&modifiers) && (modeNone != editMode) )				{			if( constrainNone == constrainMode)				{				currentPosition = anchorPosition;				constPt.h = p->h - currentPosition.h;				constPt.v = p->v - currentPosition.v;				testPt.h = abs(constPt.h);				testPt.v = abs(constPt.v);				minDimension = min(testPt.h,testPt.v);									spherePt.h = p->h - centerX;				spherePt.v = centerY - p->v;				inSphere = (long)spherePt.h*spherePt.h +(long)spherePt.v*spherePt.v;				if(inSphere > ((long)sphereRadius*sphereRadius))					constrainMode = constrainAngle; 				else					{					if(testPt.h == testPt.v)						constrainMode = constrainNone; 					else						{						if(testPt.h > testPt.v)constrainMode = constrainHorz; 						else constrainMode = constrainVert; 						}					}				}				else				{				constPt.h = p->h - currentPosition.h;				constPt.v = p->v - currentPosition.v;				minDimension = min(abs(constPt.h),abs(constPt.v));				}							if(constPt.h<0) constPt.h = -minDimension; else constPt.h = minDimension;			if(constPt.v<0) constPt.v = -minDimension; else constPt.v = minDimension;										switch(constrainMode)				{				case constrainNone: break;					case constrainHorz:  p->v = currentPosition.v; break;				case constrainVert:  p->h = currentPosition.h; break;				case constrainAngle: p->h = currentPosition.h+constPt.h;  p->v = currentPosition.v+constPt.v; break;				}			angle.intg = FindAngle(p->h - anchorPosition.h,p->v - anchorPosition.v);			}		else			{			constrainMode = constrainNone;				angle = FFZero;			}				result = pcc(controller)->Constrain(p,&angle);			SetPane();			}	else		result = CadDraft::Constrain(p,modifiers);			return(result);			}void TumbleDraft::SelectAll(int state) 	{	TumbSelect(NO_MARK,TRUE);	if(TRUE == state)		{		SetPane();		tumble->SelectAll(selectedList);		UnsetPane();		}	}	void TumbleDraft::SetOptions(int opt)  { tumbleOptions = opt; }int TumbleDraft::GetOptions()  { return tumbleOptions; }void TumbleDraft::ReverseSlice()  	{ 	Point	swap;	swap = startPt; startPt = endPt; endPt = swap; 	tumble->SetDirty(TRUE);	}void TumbleDraft::Hand(Point p, long modifiers, int eventType) 	{ 	int oldPinState,constrainPinState;	int moved,dd;		switch(eventType)		{		case MOUSE_DOWN:			if(lineState) DrawHandles(FALSE);			lastPosition = p; 			currentPosition = anchorPosition;			if(doubleClick&modifiers)InSelectedList(p,modifiers);			editMode = modeTranslate;			break;				case MOUSE_PUSH:		case MOUSE_TRACK:			moved = FALSE;			if((modifiers & buttonDown))				{				dx = p.h - lastPosition.h;				dy = p.v - lastPosition.v;				x = p.h + lOrigin.h;				y = p.v + lOrigin.v;				oldPinState = space->GetPin();				switch(constrainMode)					{					case constrainAngle:constrainPinState = PIN_P; break;					case constrainHorz:constrainPinState = PIN_R; break;					case constrainVert:constrainPinState = PIN_Y; break;					default: constrainPinState = oldPinState; break;					}				if(dx||dy)					{					space->SetPin(constrainPinState);					space->Update(x,y,dx,dy,sphereRadius);					Display(-DRAW,0,0);					if(!(modifiers&OPT_EDIT_MODE))moved = TRUE;					space->SetPin(oldPinState);					}				lastPosition = p;				}			else				{				if(!lineState && MOMENTUM_FLAG&tumbleOptions && (dx||dy))					{					DoMomentum(p,x,y);					Display(-DRAW,0,0);					if(!(modifiers&OPT_EDIT_MODE))moved = TRUE;					}				}			if( moved )				{ 				controller->Request(NULL,msgEdit,objTumble,0); 				SetPane(); 				}			break;				case MOUSE_UP:			if(editFlags&EDIT_CURSOR_MOVE)				{ 				controller->Request(NULL,msgEdit,objTumble,0); 				SetPane(); 				}			SetBuildPoint(PtFFZero,p,FALSE);			editMode = modeNone;			break;		}			}/* jca 6APR94 what with all the cross-platform stuff, Momentum gotbroken.  And, since it would be a pain to fix correctly (plus nobodyuses it, to our knowledge), I've chopped it out of WalkThrough forWindows 1.2*/voidMenuTumble::ctheMenu()	{	cMenu(TXTT_TUMEDITOR,0);/* DUDE _ WRONG */	#if SPANISH    	SetMenuKeyPos(menuTumbleKeyPos);	#endif //!SPANISH	MenuCad::ctheMenu();	AppendSeparator();		// ABD WILLIAMS MERGE11 9/11/93				Append(TXTM_REVERSE);#if TUMBLE_MOMENTUM	Append(TXTM_MOMENTUM);	Select(menuMomentum,FALSE);#endif // TUMBLE_MOMENTUM	SetKey(menuReverseSlice, menuReverseSliceKey);	SetMenuEuroKey(menuTumbleEuroKey);	SetEuroKey(menuReverseSlice, menuReverseSliceEuroKey);	}voidMenuTumble::Preempt()	{	int options;	MenuCad::Preempt();	// jca 6APR94 enable only if something is selected	Activate(menuReverseSlice, ptc(controller)->IsAnythingSelected());#if TUMBLE_MOMENTUM	options = ptc(controller)->GetOptions();	Select(menuMomentum,(options&MOMENTUM_FLAG) ? TRUE : FALSE);#endif // TUMBLE_MOMENTUM	}	voidMenuTumble::Action(int num, long modifier)	{	int options;	switch (num)		{		case menuReverseSlice: ptc(controller)->ReverseSlice();break;#if TUMBLE_MOMENTUM		case menuMomentum:			options = ptc(controller)->GetOptions();			options^=MOMENTUM_FLAG;			ptc(controller)->SetOptions(options);			break;#endif // TUMBLE_MOMENTUM		default: MenuCad::Action(num,modifier); break;		}	}#if VPRO// MERGE-VPRO-2 [[[/* ----- TEXTURE STUFF ----- */voidTumbleDraft::SetTexture(struct TextureItem *texture)	/* ABD TEXTURE */	{	SurfDef			*surfDef;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	int 		i,length,editSide,*selSurf;		editSide = ptc(controller)->GetEditSide();	if (!selectedList->ALength()) 		{		undoItem = NewUndoItem(UNDO_POLY_FLAG);		undoSpec = undoItem->cEditSpec(_EDIT_TEXTURE);		((UPolyTexture*)undoSpec)->SetTexture(texture,editSide);		undoItem->SetEditObject((CAVPolyhedron*)polyhedron,NULL,UNDO_POLY_FLAG);		}	else 		{		undoItem = NewUndoItem(UNDO_SURF_FLAG);		undoSpec = undoItem->cEditSpec(_EDIT_TEXTURE);		((USurfTexture*)undoSpec)->SetTexture(texture,editSide);				length = selectedList->ALength();		selSurf = (int *)selectedList->Use();		for( i = 0; i < length; i++,selSurf++)			if(surfDef = GetSurface(*selSurf))				undoItem->EditSurface(surfDef,NULL);		selectedList->Unuse();		}	undoItem->Edit();					controller->EditPolyhedron(polyhedron,objTexture);	/* dude -  I need to update the design views too if drawing textures in them */	controller->Request(NULL,msgEdit,objView,0);	controller->Request(NULL,msgEdit,objPolyhedron,0);	ptc(controller)->GetTextureList()->Reset();	}// MERGE-VPRO-2 ]]]#endif // VPRO