/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "SrfDraft.h"#include "Position.h"#include "Geometry.h"			#include "PolyDefs.h"#include "SrfCntrl.h"#include "CVDefs.h"#include "CVPolyh.h"#include "SrfObj.h"#include "CVSrfDef.h"#include "CVSrfFet.h"#include "CVEnvirn.h"#include "VMDL.h"#include "AppMssgs.h"#include "AppText.h"#include "Surface.h"#include "ToolDef.h"#include "WalkDefs.h"#include "BallHelp.h"#include "Misc.h"#include "UndoBuf.h"#include "SurfUndo.h"#include "Unit.h"#include "VMath.h"#include "VGraphic.h"#include "CVWCNTRL.H" 		// DAS-VR-SURFEDIT 9/6/93#include "TextSrvr.h"		// ABD MERGE-TEXTURE 9/13/93#include "TextItem.h"		// ABD MERGE-TEXTURE 9/13/93#include "Walkthru.h"		// ABD MERGE15#include "TextArry.h"		// MERGE16#include "VSound.h"			// jca 20 Oct 93#include "VError.h"#include "VDialog.h"		// MERGE-GOURAUD #if VR#include "LBVCNTRL.H"		// ABD MERGE9 WILLIAMS 9/8/93#include "VRLBLIST.H"		// ABD MERGE9 WILLIAMS 9/8/93#endif // VR#include <math.h>#if VRML_ANCHOR			// VRML-ABD 23JUN95#include <stdio.h>#include <string.h>#endif // VRML_ANCHORextern	struct V_Buffer *clipBuf;/* in WalkThrough.c */extern	PointFFixed BuildScale(Point p1,Point p2,Point anch,int constrain);void SurfDraft::SetController(Controller *ctrl) 	{	CadDraft::SetController(ctrl);#if VWT	menu->SetController(controller);#endif //VWT	}void SurfDraft::SetSurface(SurfDef *sDef) 	{	PointFFixed	pt;	Rect 	r;		polyhedron = (CAVPolyhedron*)sDef->polyhedron;	surfDef = (CAVSurfDef*)sDef;	surfDef->cSurfObject(environment);	environment->SetSide(SURF_OUTSIDE);	}void SurfDraft::SetSelect(V_Array *sList) 	{	selectedList = sList;	}		void SurfDraft::cPane(int flag) 	{				V_MenuMgr	*mgr;		surfDefSelect = FALSE;	selectedList = NULL;	CadDraft::cPane(flag);#if VWT	mgr = GetMenuMgr();	menu = new(MenuSurface);	menu->ctheMenu();	mgr->Append(menu);#endif //VWT	dupFeature = NULL;	surfDefSelect = TRUE;	#if VRML_ANCHOR		// ABD PRO25 AUG95	lastVRMLObj = NULL;	#endif	}void SurfDraft::dPane() 	{	surfDef->dSurfObject();#if VWT	menu->dMenu();#endif //VWT		CadDraft::dPane();	}	void SurfDraft::GetVirtual(Rect *r) 	{		int 	tmp;		*r = VMinRect;	if(surfDef)surfDef->ModelSize(r);		if(SURF_INSIDE == environment->GetSide())		{		tmp = r->left;		r->left = -r->right;		r->right = -tmp;		}			CadDraft::GetVirtual(r);	}void SurfDraft::CalcSize(Rect *r,Point *p,int type,int warning)	{		Rect size;	PointFFixed home,pt,ptMin,ptMax;	Point	c;	 	CadDraft::CalcSize(r,p,type,warning);	if(INSTALL == type)		{				surfDef->Extrema(&ptMin,&ptMax);// { DAS-BUGFIX 10/17/93 this insures that the inside surface is centered		if( insideView == environment->GetView()) 			{			pt.h=ptMin.h;			ptMin.h=FFNeg(ptMax.h);			ptMax.h=FFNeg(pt.h);			}// } DAS-BUGFIX 10/17/93 this insures that the inside surface is centered		home.h = FFAdd(FFShift(FFSub(ptMax.h,ptMin.h),-1),ptMin.h);		home.v = FFAdd(FFShift(FFSub(ptMax.v,ptMin.v),-1),ptMin.v);// DAS VR-SURFEDIT 9/11/93/*		This uses window coordinates! We need PANE coordinates. This will be		wrong even for VWT.		c.h = r->left + ((r->right-r->left)>>1);		c.v = r->top + ((r->bottom-r->top)>>1);*/		c.h=(r->right-r->left)>>1;		c.v=(r->bottom-r->top)>>1;		pt = Local2World(c,SCALE_ABSOLUTE);				MoveView(home,pt);		ffLastPt = home;		lastPositionR = World2Local(ffLastPt,SCALE_ABSOLUTE);		}	}// MERGE-GOURAUD-PRO-3 [[[void SurfDraft::Nudge(char direction,long modifiers) 		// ABD{CAVSurfFeature	**pFeat;EditSpecList	*undoItem;V_Array			*editSpecList;EditSpec		*undoSpec;int i, length;PointFFixed	baseVector,pointVector;Point p, pz;PointFFixed gridUnit;	length = selectedList->ALength();	if (length == 0) return;		undoItem = NewUndoItem(UNDO_SURF_FLAG);	undoSpec = undoItem->cEditSpec(_EDIT_MOVE);		if ((modifiers & V_OPTION) == V_OPTION)	{		FFixed FFZ={0};			gridUnit = pcc(controller)->GridUnit();		switch (direction)		{			case V_LEFTARROW:  gridUnit.h = FFNeg(gridUnit.h); gridUnit.v = FFZ; break;			case V_RIGHTARROW:  gridUnit.v = FFZ; break;			case V_UPARROW:  gridUnit.h = FFZ; break;			case V_DOWNARROW:  gridUnit.h = FFZ; gridUnit.v = FFNeg(gridUnit.v); break;			default: gridUnit.h = FFZ; gridUnit.v = FFZ; break;		}			baseVector = environment->Translate2DFFixed(TO_WORLD, FFPointZero);		pointVector = environment->Translate2DFFixed(TO_WORLD, gridUnit);	}	else	{			pz.h = 0; pz.v = 0;		switch (direction)		{			case V_LEFTARROW:  p.h = -1; p.v = 0; break;			case V_RIGHTARROW:  p.h = +1; p.v = 0; break;			case V_UPARROW:  p.h = 0; p.v = -1; break;			case V_DOWNARROW:  p.h = 0; p.v = +1; break;			default: p.h = 0; p.v = 0; break;		}		baseVector = environment->Translate2DFFixed(TO_WORLD, Local2World(pz,SCALE_ABSOLUTE));		pointVector = environment->Translate2DFFixed(TO_WORLD, Local2World(p,SCALE_ABSOLUTE));	}		((USurfMove*)undoSpec)->SetVector(baseVector,pointVector);					pFeat = (CAVSurfFeature **)selectedList->Use();	for(i = 0; i < length; i++,pFeat++)	{		editSpecList = undoItem->SetEditObject(surfDef,*pFeat,UNDO_SURF_FLAG);		(*pFeat)->SetMode(IN_POLY);		(*pFeat)->SetDirty(POLY_MUSSED);	}				selectedList->Unuse();	undoItem->Edit();	controller->EditPolyhedron(polyhedron,objCad);			controller->Request(NULL,msgEdit,objPolyhedron,0);}// MERGE-GOURAUD-PRO-3 ]]]voidSurfDraft::TrackHelp(Point pt,long modifier)// DAS-VWINDOWS 9/30/93	{	Rect r;		if(modeNone == editMode)		{		r = dataRect;		BalloonHotRect(&r,pt);		Bubble(pt,&r,TXTB_SURFVIEW);		}	}	#if VR// ABD MERGE9 WILLIAMS 9/8/93 [[[void SurfDraft::Drop(Point pt, struct V_Pane *drag){	// reset ffLastPt to specify paste position	ffLastPt = Local2World(pt, SCALE_ABSOLUTE);	lastPositionR = World2Local(ffLastPt,SCALE_ABSOLUTE);		((LibViewController*)(((VRLibraryList*)drag)->controller))->EditBuffer(MSG_COPY, 0);	if (EditBuffer(MSG_PASTE, 0) < noErr)			// jca 20 Oct 93  return error if something bad happens		VPlaySound(beepSound);				// jca 20 Oct 93  at least give a beep}// ABD MERGE9 WILLIAMS 9/8/93 ]]]#endif // VRvoid SurfDraft::DrawContent(int type)	{	CAVSurfFeature	**pFeat;	int	i,length;		switch(type)		{		case PICT_DRAW:				surfDef->Display();			break;					case PRINT_DRAW:			surfDef->SetDirty(TRUE);			surfDef->Display();			surfDef->SetDirty(TRUE);			break;				default:			surfDef->Display();						length = selectedList->ALength();			pFeat = (CAVSurfFeature	**)selectedList->Use();			for( i = 0 ; i < length ; i++,pFeat++)				(*pFeat)->Select();			selectedList->Unuse();						if(surfDefSelect)				surfDef->Select();			break;		}			CadDraft::DrawContent(type);	}			void SurfDraft::LaunchEditor() 	{	Surface			*surf;			Point3DFFixed	orient;	int				surfNum;		orient = Pt3DFFZero;	surfNum = polyhedron->surfDef->Find(&surfDef);	surf = polyhedron->FindSurface(surfNum);			CadDraft::LaunchEditor();	pcc(controller)->LaunchEditor(polyhedron,environment->GetScale(),surfDef,orient,toolCRTTumble);	}int SurfDraft::GetAction(long action,long modifiers)	{	CAVSurfFeature *pFeat;	SurfObject	**tfeat;	char		title[256];	int			i,length,pitchSide,update,newView;		if(editMode) return(FALSE);		update = FALSE;		switch(action)		{			case MSG_OPPVIEW:			if( insideView == environment->GetView()) 				{ newView = outsideView; pitchSide = SURF_INSIDE; }					else { newView = insideView; pitchSide = SURF_OUTSIDE; }				length = selectedList->ALength();			for(i = length-1; i >= 0; i--)				{				selectedList->Get(i,&pFeat);				if( pitchSide == surfDef->GetSide(pFeat))					{					pFeat->SetMode(OUT_POLY);					selectedList->Remove(i);					}				}						ffLastPt.h = FFNeg(ffLastPt.h);				psc(controller)->ChangeView(newView);			break;		case  MSG_POLYFORWARD: OrderFeature(32000); break;		case  MSG_POLYPOP: OrderFeature(1); break;		case  MSG_POLYPUSH: OrderFeature(-1); break;		case  MSG_POLYBACK: OrderFeature(-32000); break;				// MERGE-GOURAUD-PRO [[[		#if VPRO		case  MSG_CENTER_SURFACE_EDITOR:		{		#if 0		PointFFixed 	newView,pt;		Point p;		FFixed dp;		Point3D pMin,pMax;				pMin.x = 0;		pMin.y = 0;		pMin.z = 0;		pMax.x = 0;		pMax.y = 0;		pMax.z = 0;		newView = PtFFZero;		pMin = environment->Translate3D(TO_CAD,pMin);		newView.h.intg = pMin.x;		newView.v.intg = pMin.y;			p.h = centerX;p.v = centerY; // current center of the display		pt = Local2World(p,SCALE_ABSOLUTE);				MoveView(newView,pt);		VDisplay(ACT_REBUILD_DRAW);		#endif		}		break;		#endif		// MERGE-GOURAUD-PRO ]]]		#if VR// { DAS-VR-SURFDEF 9/17/93// { DAS-VR-SURFDEF 10/1/93		case  MSG_INSIDE:			newView = insideView; pitchSide = SURF_OUTSIDE;			length = selectedList->ALength();			for(i = length-1; i >= 0; i--)				{				selectedList->Get(i,&pFeat);				if( pitchSide == surfDef->GetSide(pFeat))					{					pFeat->SetMode(OUT_POLY);					selectedList->Remove(i);					}				}						if( newView != environment->GetView()) 				{				ffLastPt.h = FFNeg(ffLastPt.h);					psc(controller)->ChangeView(newView);				}			psc(controller)->EditView(SURF_INSIDE);			break;		case MSG_OUTSIDE:		case MSG_BOTH:			newView = outsideView; pitchSide = SURF_INSIDE;			length = selectedList->ALength();			for(i = length-1; i >= 0; i--)				{				selectedList->Get(i,&pFeat);				if( pitchSide == surfDef->GetSide(pFeat))					{					pFeat->SetMode(OUT_POLY);					selectedList->Remove(i);					}				}			if( newView != environment->GetView()) 				{				ffLastPt.h = FFNeg(ffLastPt.h);					psc(controller)->ChangeView(newView);				}			if(action==MSG_OUTSIDE)psc(controller)->EditView(SURF_OUTSIDE);			else if(action==MSG_BOTH)psc(controller)->EditView(SURF_SHARED);			break;// } DAS-VR-SURFDEF 9/17/93// } DAS-VR-SURFDEF 10/1/93		case  MSG_GOBACK: // DAS-VR-SURFEDIT 9/6/93			((CAVWalkController*)controller->controller)->RestoreDesign(theWindow);			((WalkDocument*)ActiveDocument())->SwitchLibs(FALSE);	// MERGE15			break;#endif // VR		default: return(CadDraft::GetAction(action,modifiers)); break;		}		return(TRUE);	}		void SurfDraft::Update() 	{	if(surfDef)surfDef->SetDirty(TRUE);	CadDraft::Update();	}void SurfDraft::CreateObject(Point p,long modifiers) 	{	V_Array			*tmpList;	CAVSurfFeature	*surfFeature;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	Point3DFFixed	vertex;	PointFFixed		pointVector,*pt;	Angle3DFFixed	rotate;	unsigned short	where,opacity;	FFixed			pointAngle;	int				editType,length,i;	/*	if(!pcc(controller)->CreateOK()) 		{		SetBuildPoint(PtFFZero,position,FALSE);		VDisplay(ACT_REBUILD_DRAW);		return;		}*/	Select(NULL,NULL,0L);	surfDefSelect = FALSE;			undoItem = NewUndoItem(UNDO_SURF_FLAG);	surfFeature = new(CAVSurfFeature);	surfFeature->cSurfFeature();	surfFeature->SetLayer(pcc(controller)->GetLayer());		opacity = psc(controller)->GetOpacity();		where = PlaceWhere();	pointAngle = FFZero;	WorldSpace(TO_WORLD,tempFFPoints);		switch(editTool)		{		case bPOLY_ROOM: editType = EDIT_POLYGON; break;			case bRECT_ROOM: editType = EDIT_RECTANGLE;  break;		case bREGPOLY_ROOM: editType = EDIT_REGPOLYGON; break;		}			vertex = environment->OrientPolyhedron(tempFFPoints,Pt3DFFZero,FALSE);	surfFeature->Create(tempFFPoints,PtFFZero);	surfFeature->SetEditType(editType);	pointVector.h = vertex.x;pointVector.v = vertex.y;	undoSpec = undoItem->cEditSpec(_EDIT_CREATE);	((USurfCreate*)undoSpec)->SetSide(where);	undoSpec = undoItem->cEditSpec(_EDIT_MOVE);	((USurfMove*)undoSpec)->SetVector(PtFFZero,pointVector);	undoSpec = undoItem->cEditSpec(_EDIT_ROTATEABS);	((USurfRotate*)undoSpec)->SetAngle(FFZero,pointAngle);	((USurfRotate*)undoSpec)->SetVector(PtFFZero,PtFFZero);	undoSpec = undoItem->cEditSpec(_EDIT_COLOR);	((USurfColor*)undoSpec)->SetColor(pcc(controller)->GetColor(),SURF_SHARED);// ABD MERGE-TEXTURE 9/13/93 [[[	undoSpec = undoItem->cEditSpec(_EDIT_TEXTURE);	((USurfTexture*)undoSpec)->SetTexture(pcc(controller)->GetTexture(),SURF_SHARED);// ABD MERGE-TEXTURE 9/13/93 ]]]	// MERGE-GOURAUD [[[	//undoSpec = undoItem->cEditSpec(_EDIT_GOURAUD);	//((USurfGouraud*)undoSpec)->SetShadeType(pcc(controller)->GetShadeType(), SURF_SHARED);	// MERGE-GOURAUD ]]]	undoSpec = undoItem->cEditSpec(_EDIT_OPACITY);	((USurfOpacity*)undoSpec)->SetOpacity(opacity);	undoItem->EditSurface(surfDef,surfFeature);	undoItem->Edit();		DisplayObject(drawCancel);/* dude */		if((SURF_SHARED == where) || (environment->GetSide() == where))		selectedList->Insert(0,&surfFeature);			VDisplay(DRAW); 		tmpList = new(V_Array);	tmpList->cArray(0,sizeof(CAVSurfFeature*),4);	tmpList->Append(&surfFeature);	psc(controller)->NewSurfFeature(tmpList);	tmpList->dArray();	controller->Request(NULL,msgEdit,objPolyhedron,0);/* dude ??? */	}int SurfDraft::InSelectedList(Point p,long modifiers) 	{		TextureItem	*texture;		// ABD MERGE-TEXTURE 9/13/93	CAVSurfFeature	**pFeat,*feat;	PointFFixed	worldPt;	RGBColor	color;	Point		tp;	int			i,length,found = OUT_POLY,where,direction;	int 		spot,newSDSelect,findMode,allObjects;		editList->SetLength(0);	tempFFPoints->Get(0,&worldPt);	feat = NULL;	allObjects = FALSE;	tp.h = p.h + lOrigin.h;	tp.v = p.v + lOrigin.v;		length = selectedList->ALength();	pFeat = (CAVSurfFeature	**)selectedList->Use();	for(i = 0; i < length; i++,pFeat++) 		if(feat = (*pFeat)->Find(&tp,&worldPt,modifiers,TRUE,FIND_NORMAL))break;	selectedList->Unuse();	if(!feat) 		{		if(OPT_EDIT_MODE&modifiers && (bLOCK == editTool))			findMode = FIND_LOCKED;		else			findMode = FIND_NORMAL; 		feat = surfDef->FindFeature(&tp,&worldPt,modifiers,FALSE,findMode);		if(feat && surfDefSelect) 			{			surfDefSelect = FALSE;			surfDef->Select();			}		Select(feat,NULL,modifiers);		if(!feat && !selectedList->ALength()) 			{			if(surfDef->Find(&tp,modifiers,FALSE,findMode)) newSDSelect = TRUE;			else newSDSelect = FALSE;			if(newSDSelect != surfDefSelect ) surfDef->Select();			surfDefSelect = newSDSelect;			}		}	else		if(modifiers&MULTIPLE_SELECT)			{			Select(feat,NULL,modifiers);			feat = NULL;			found = OUT_POLY;			}				currentPositionR.h = tp.h - lOrigin.h;currentPositionR.v = tp.v - lOrigin.v;lastPositionR = anchorPositionR = currentPositionR;lastAngle = anchorAngle = angle;		if( surfDefSelect)		{		switch(editTool)			{			case bDROPPER:				direction = environment->GetSide();													if(OPT_EDIT_MODE&modifiers) 					{					if( SURF_INSIDE == direction )direction = SURF_OUTSIDE;					else direction = SURF_INSIDE;					}				color = surfDef->GetColor(direction);				texture = surfDef->GetTexture(direction);		// ABD MERGE-TEXTURE 9/13/93				pcc(controller)->ColorDropper(color,texture);		// ABD MERGE-TEXTURE 9/13/93				break;						case bTUMBLE_EDITOR:			case bLIGHT_EDITOR:				LaunchEditor();				break;			}		}	if(feat)		{				switch(editTool)			{			case bTUMBLE_EDITOR:			case bLIGHT_EDITOR:				found = IN_POLY;				break;							case bLOCK:			case bHIDE:			case bDROPPER:				found = IN_POLY;				break;			case bPLUS_MINUS:				found = feat->GetMode();				if((ON_POLY_DEFLINE != found) && (ON_POLY_POINT != found))					found = OUT_POLY;				break;						case bSCALE_ROOM:				allObjects = TRUE;				found = IN_POLY;				break;			case bARROW:					found = feat->GetMode();				if((ON_POLY_SIDLINE == found) || (IN_POLY == found))					allObjects = TRUE;				break;			}		}			if( OUT_POLY != found)		{		if(allObjects)selectedList->CopyArray(editList);		else editList->Append(&feat);		tempFFPoints->Put(0,&worldPt);		}			return(found);	}void SurfDraft::SelectAll(int state) 	{	if(TRUE == state)		{		if(!(SDEF_FEATURE&surfDef->flags)) surfDefSelect = TRUE; 		else surfDefSelect = FALSE;		Select(NULL,NULL,0L);				surfDef->SelectAll(&selectedList);				if(0 == selectedList->ALength())	surfDefSelect = TRUE;				VDisplay(DRAW);		}	else		{		surfDefSelect = FALSE;		Select(NULL,NULL,0L);		}	}	int SurfDraft::DoTranslate(long modifiers) 	{	CAVSurfFeature	**pFeat;	Point		dp,tp,pp;	int			i,length,okay;		length = editList->ALength();	pFeat = (CAVSurfFeature	**)editList->Use();		switch(editTool)		{		case bROTATE_ROOM:				VMoveTo(anchorPosition.h,anchorPosition.v);			VLineTo(lastPosition.h,lastPosition.v);			for(i = 0; i < length; i++,pFeat++)				okay = (*pFeat)->RotateSurf(anchorPosition,lastAngle,modifiers);			okay = TRUE;			break;					case bPLUS_MINUS:			for(i = 0; i < length; i++,pFeat++)				okay = (*pFeat)->BreakLine(lastPosition,modifiers);			break;				case bSCALE_ROOM:			for(i = 0; i < length; i++,pFeat++)				okay = (*pFeat)->ScaleSurf(dropAnchor,lastScale,modifiers);			break;		case bHIDE:		case bLOCK:			for(i = 0; i < length; i++,pFeat++)				okay = (*pFeat)->MoveSurf(anchorPosition,anchorPosition,lastAngle,modifiers);			break;					case bARROW:			if((modifiers &OPT_EDIT_MODE) && (ON_POLY_POINT == (*pFeat)->GetMode())) dp = currentPosition;			else dp = anchorPosition; 			for(i = 0; i < length; i++,pFeat++)				okay = (*pFeat)->MoveSurf(dp,lastPosition,lastAngle,modifiers);			break;		}	editList->Unuse();	return(okay);	}void SurfDraft::UpdateObject(long modifiers) 	{	CAVSurfFeature	**pFeat,*leadSurf;	V_Array			*tmpArray;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	PointFFixed		baseVector,pointVector,scaleMult,scaleOrigin;	PointFFixed		surfMin,surfMax;	FFixed			baseAngle,pointAngle;		int				i,length,mode,doType,updateEditor,makeIrr,where;	int				removeFromSelect,place,msgType,doEdit;		if(!(length = editList->ALength())) return;	updateEditor = FALSE;	makeIrr = FALSE;	removeFromSelect = FALSE;	msgType = msgEdit;	doEdit = TRUE;		editList->Get(0,&leadSurf);	mode = leadSurf->GetMode();	/*	baseVector = Local2World(anchorPosition,SCALE_ABSOLUTE);	baseVector = Local2World(currentPositionR,SCALE_ABSOLUTE);	pointVector = Local2World(lastPosition,SCALE_ABSOLUTE);*/	WorldSpace(TO_WORLD,tempFFPoints);	tempFFPoints->Get(0,&baseVector);	tempFFPoints->Get(1,&pointVector);	baseAngle = ConvertAngle(anchorAngle);	pointAngle = ConvertAngle(lastAngle);	baseVector = environment->Translate2DFFixed(TO_WORLD,baseVector);	pointVector = environment->Translate2DFFixed(TO_WORLD,pointVector);	baseAngle = environment->Translate2DAngle(TO_WORLD,baseAngle);	pointAngle = environment->Translate2DAngle(TO_WORLD,pointAngle);				switch(editTool)		{		case bARROW:									if((modeWait >= editMode) || !(editFlags&EDIT_CURSOR_MOVE)) { doEdit = FALSE; break; }						undoItem = NewUndoItem(UNDO_SURF_FLAG);			if(OPT_EDIT_MODE&modifiers && (IN_POLY != mode)) makeIrr = TRUE;			updateEditor = TRUE;			switch(mode)				{				case IN_POLY: doType = _EDIT_MOVE; break;									case ON_POLY_DEFLINE: doType = _EDIT_MOVELINE; break;									case ON_POLY_ORIGIN: doType = _EDIT_MOVEORG;  break;									case ON_POLY_POINT: doType = _EDIT_MOVEPT;  break;									default: doEdit = FALSE; break;				}			if(makeIrr) 				{				undoSpec = undoItem->cEditSpec(_EDIT_TYPE);				((USurfType*)undoSpec)->SetEditType(EDIT_POLYGON);				}			undoSpec = undoItem->cEditSpec(doType);			((USurfMove*)undoSpec)->SetVector(baseVector,pointVector);						undoSpec->SetMark(leadSurf->GetMark());			break;				case bPLUS_MINUS:				undoItem = NewUndoItem(UNDO_SURF_FLAG);			updateEditor = TRUE;			switch(leadSurf->GetEditType())				{				case EDIT_REGPOLYGON: if(!(OPT_EDIT_MODE&modifiers)) makeIrr = TRUE; break;				case EDIT_RECTANGLE: makeIrr = TRUE; break;				case EDIT_POLYGON: makeIrr = FALSE; break;				}							switch(mode)				{				case ON_POLY_POINT: doType = _EDIT_REMPT; break;				case ON_POLY_DEFLINE: doType = _EDIT_ADDPT; break;				default: doEdit = FALSE; break;				}			if(makeIrr) 				{				undoSpec = undoItem->cEditSpec(_EDIT_TYPE);				((USurfType*)undoSpec)->SetEditType(EDIT_POLYGON);				}			undoSpec = undoItem->cEditSpec(doType);			((USurfMove*)undoSpec)->SetVector(baseVector,pointVector);			undoSpec->SetMark(leadSurf->GetMark());			break;				case bSCALE_ROOM:			if(!(editFlags&EDIT_CURSOR_MOVE)) { doEdit = FALSE; break; }			undoItem = NewUndoItem(UNDO_SURF_FLAG);			undoSpec = undoItem->cEditSpec(_EDIT_SCALE);			/* WorldSpace(TO_WORLD,tempFFPoints);*/			tempFFPoints->Get(0,&scaleOrigin);			tempFFPoints->Get(1,&baseVector);			tempFFPoints->Get(2,&pointVector);			scaleOrigin = environment->Translate2DFFixed(TO_WORLD,scaleOrigin);			baseVector = environment->Translate2DFFixed(TO_WORLD,baseVector);			pointVector = environment->Translate2DFFixed(TO_WORLD,pointVector);			pointVector.h = FFSub(pointVector.h,scaleOrigin.h);			pointVector.v = FFSub(pointVector.v,scaleOrigin.v);			baseVector.h = FFSub(baseVector.h,scaleOrigin.h);			baseVector.v = FFSub(baseVector.v,scaleOrigin.v);			if(FFZero(pointVector.h)||FFZero(baseVector.h))scaleMult.h = FFOne;			else scaleMult.h = FFDiv(pointVector.h,baseVector.h);			if(FFZero(pointVector.v)||FFZero(baseVector.v))scaleMult.v= FFOne;			else scaleMult.v = FFDiv(pointVector.v,baseVector.v);			if(modifiers&CONSTRAIN)				{				FFMax(scaleMult.h,scaleMult.h,scaleMult.v);				scaleMult.v = scaleMult.h;				}						((USurfScale*)undoSpec)->SetScale(scaleMult,scaleOrigin);				updateEditor = TRUE;			break;		case bROTATE_ROOM:			if(!(editFlags&EDIT_CURSOR_MOVE)) break;						undoItem = NewUndoItem(UNDO_SURF_FLAG);			undoSpec = undoItem->cEditSpec(_EDIT_ROTATE);			((USurfRotate*)undoSpec)->SetAngle(baseAngle,pointAngle);			((USurfRotate*)undoSpec)->SetVector(baseVector,pointVector);			updateEditor = TRUE;			break;				case bHIDE:			undoItem = NewUndoItem(UNDO_SURF_FLAG);			if(OPT_EDIT_MODE&modifiers)				{				undoSpec = undoItem->cEditSpec(_EDIT_HIDEWALK);				updateEditor = TRUE;				}			else				{				msgType = msgUpdate;				removeFromSelect = TRUE;				undoSpec = undoItem->cEditSpec(_EDIT_HIDE);				}			break;		case bDROPPER:			pcc(controller)->ColorDropper(leadSurf->GetColor(),leadSurf->GetTexture());		// ABD MERGE-TEXTURE 9/13/93			doEdit = FALSE;			break;		case bLOCK:			undoItem = NewUndoItem(UNDO_SURF_FLAG);			if(OPT_EDIT_MODE&modifiers)				undoSpec = undoItem->cEditSpec(_EDIT_UNLOCK);			else				{				msgType = msgUpdate;				removeFromSelect = TRUE;				undoSpec = undoItem->cEditSpec(_EDIT_LOCK);				}			break;		}			if(doEdit)		{		pFeat = (CAVSurfFeature	**)editList->Use();		for(i = 0; i < length; i++,pFeat++)			{			if(removeFromSelect)				{				place = selectedList->Find(&(*pFeat));				if(0 <= place)  selectedList->Remove(place);				(*pFeat)->SetMode(OUT_POLY);				}			undoItem->EditSurface(surfDef,*pFeat);			(*pFeat)->SetMode(IN_POLY);			(*pFeat)->SetDirty(POLY_MUSSED);			}		editList->Unuse();					undoItem->Edit();				if(updateEditor)			{			controller->EditPolyhedron(polyhedron,objPolygon);			controller->Request(NULL,msgType,objPolygon,0);/* THIS IS NEW ICKY */			}			else			VDisplay(DRAW);		}	else		{		pFeat = (CAVSurfFeature	**)editList->Use();		for(i = 0; i < length; i++,pFeat++)			(*pFeat)->SetMode(IN_POLY);		editList->Unuse();			}	editList->SetLength(0);			}// ABD MERGE-TEXTURE 9/13/93 [[[	void SurfDraft::SetTexture ( struct TextureItem *t )		// ABD TEXTURE	{	CAVSurfFeature	**pFeat;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	int				i,length; 	undoItem = NewUndoItem(UNDO_SURF_FLAG);	undoSpec = undoItem->cEditSpec(_EDIT_TEXTURE);	((USurfTexture*)undoSpec)->SetTexture(t,PlaceWhere());		if(length = selectedList->ALength())		{		pFeat = (CAVSurfFeature **)selectedList->Use();		for(i = 0; i < length; i++,pFeat++) 			undoItem->EditSurface(surfDef,*pFeat);		selectedList->Unuse();		undoItem->Edit();		}		if(surfDefSelect)		{		undoItem->EditSurface(surfDef,NULL);		undoItem->Edit();		controller->EditPolyhedron(polyhedron,objPolygon);		}		controller->Request(NULL,msgEdit,objPolygon,0);	// ееее reset the texture pane	}// ABD MERGE-TEXTURE 9/13/93 ]]]	// ABD MERGE-GOURAUD [[[	void SurfDraft::SetShadeType ( unsigned char shade_type )	{	CAVSurfFeature	**pFeat;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	int				i,length;		if (selectedList->ALength())	{		if (shade_type == SHADE_GOURAUD)			AlertMessage(TXTW_NO_SURF_GOURAUD);		return;	}	undoItem = NewUndoItem(UNDO_SURF_FLAG);	undoSpec = undoItem->cEditSpec(_EDIT_GOURAUD);	((USurfGouraud*)undoSpec)->SetShadeType(shade_type,PlaceWhere());			if(surfDefSelect)		{		undoItem->EditSurface(surfDef,NULL);		undoItem->Edit();		controller->EditPolyhedron(polyhedron,objPolygon);		}		controller->Request(NULL,msgEdit,objPolygon,0);	}// ABD MERGE-GOURAUD ]]]			void SurfDraft::SelectFeature(CAVSurfFeature *feat,V_Array *list) 	{	CAVSurfFeature	**pFeat;	int		i,length;		SetPane();		if(feat)		feat->Select();	else		{		length = selectedList->ALength();		pFeat = (CAVSurfFeature	**)selectedList->Use();		for(i = 0; i < length; i++,pFeat++) 			(*pFeat)->Select();		selectedList->Unuse();		}			UnsetPane();	}	int SurfDraft::Select(void *ply,V_Array *list,long modifiers) 	{	CAVSurfFeature	**feat,*ff;	int			i,length,found;	ff = (CAVSurfFeature*)ply;				if(ff)		{		if(modifiers & MULTIPLE_SELECT)			{			if(VARY_NOTFOUND == (found = selectedList->Find(&ff)))				{				ff->SetMode(IN_POLY);				selectedList->Insert(0,&ff);				}			else				{				ff->SetMode(OUT_POLY);				selectedList->Remove(found);				}				psc(controller)->Select(ff,list);			}		else			{									psc(controller)->Select(NULL,NULL);						selectedList->SetLength(0);			selectedList->Insert(0,&ff);											psc(controller)->Select(ff,list);			}		}	else		{		if(!(modifiers & MULTIPLE_SELECT))			{			psc(controller)->Select(NULL,NULL);			selectedList->SetLength(0);			}		}		SetPane();		dupFeature = NULL;		if(surfDefSelect && selectedList->ALength())		{		surfDefSelect = FALSE;		surfDef->Select();		}			return(0);	}		void SurfDraft::SelectRect(Rect *r,long modifiers) 	{	EditSpecList	*undoItem;	EditSpec		*undoSpec;	CAVSurfFeature	**pFeat;	int i,length,walk,findMode;		walk = FALSE;	Select(NULL,NULL,0L);		MakeWorldRect(r,r->top,r->left,r->bottom,r->right);	if( bLOCK == editTool && (OPT_EDIT_MODE&modifiers)) findMode =  FIND_LOCKED;	else findMode = FIND_NORMAL; 	surfDefSelect = surfDef->SelectRect(&selectedList,r,findMode);	length = selectedList->ALength();	switch(editTool)		{		case bLOCK:		case bHIDE:			editList->SetLength(0);			selectedList->CopyArray(editList);			UpdateObject(modifiers);			break;				case bARROW:			if(length)  surfDefSelect = FALSE;			break;		}		controller->Request(NULL,msgUpdate,objPolygon,0);	if(walk)controller->Request(NULL,msgUpdate,objView,0);	}	int SurfDraft::EditBuffer(long action,long modifiers) 	{	CAVSurfFeature	**pFeat,*feat;	Position		*relPosn;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	V_Array			*undoItems, *shadowSelectList;			// jca 25 Oct 93  save the last selected thing	CAVSurfFeature  *curDup,*dupPeer;	int			length,i,mode,found,err,undoType;		err = noErr;			// jca 20 Oct 93			switch(action)		{		case  MSG_COPY:				clipBuf->IOSetLength(0);			clipBuf->IOSetPosition(0);			clipBuf->IOSetDirection(DATA_OUT);			IO_ID(clipBuf,IFF_FEAT);			err = IO_OBJECT(clipBuf);				// jca 20 Oct 93			break; 					case  MSG_DUPLICATE: 			if(EditBuffer(MSG_COPY,modifiers) < noErr) break;			curDup = dupFeature;			selectedList->Get(0,&dupPeer);						// jca 25 Oct 93 {	// fallback stuff, do before we zero the selected list			shadowSelectList = new(V_Array);			err = shadowSelectList->cArray(selectedList->ALength(), sizeof(CAVSurfFeature*), 1);			if (err)				{				delete(shadowSelectList);	// failed the cArray; delete it manually.				shadowSelectList = NULL;				}			else				{				err = selectedList->CopyArray(shadowSelectList);				if (err)					{					shadowSelectList->dArray();	// faied the copy.  dArray.					shadowSelectList = NULL;					}				}			// jca 25 Oct 93 }						Select(NULL,NULL,0L);			surfDefSelect = FALSE;			clipBuf->IOSetPosition(0);			clipBuf->IOSetDirection(DATA_IN);			IO_ID(clipBuf,IFF_PRSM);			err = IO_OBJECT(clipBuf);			if(!err)				{				if(!curDup)					DuplicatePosition(NULL,curDup);				else					{					relPosn = new(Position);					relPosn->cPosition();							dupPeer->posn->Copy(relPosn);					relPosn->UnPosition(curDup->posn);					DuplicatePosition(relPosn,curDup);					relPosn->dPosition();										}				controller->Request(NULL,msgEdit,objPolygon,0);					dupFeature = dupPeer;				}						if (err)	// jca 25 Oct 93 {				{	// if we can't duplicate the objects...				if (shadowSelectList)					{					int salvageErr = noErr;					salvageErr = shadowSelectList->CopyArray(selectedList);		// leave the last object selected					if (salvageErr)						selectedList->SetLength(0);		// inconceivable!					else						{	// all okay, save the info back						pFeat = (CAVSurfFeature	**)shadowSelectList->Use();	// turn the features back on (select them)						for(i = 0; i < shadowSelectList->ALength(); i++)  							pFeat[i]->SetMode(IN_POLY); 						shadowSelectList->Unuse();						SelectFeature(NULL, selectedList);						}					shadowSelectList->dArray();                    shadowSelectList = NULL;					}				else					selectedList->SetLength(0);		// fail gracefully				}            // 17MAY94 jca oops-- forgot to delete it			if (shadowSelectList)            	{				shadowSelectList->dArray();		// we failed the copy;  dArray				shadowSelectList = NULL;                }			// jca 25 Oct 93 }			break;					case  MSG_PASTE:			// jca 26 Oct 93 {	// fallback stuff, do before we zero the selected list			shadowSelectList = new(V_Array);			err = shadowSelectList->cArray(selectedList->ALength(), sizeof(CAVSurfFeature*), 1);			if (err)				{				delete(shadowSelectList);	// failed the cArray; delete it manually.				shadowSelectList = NULL;				}			else				{				err = selectedList->CopyArray(shadowSelectList);				if (err)					{					shadowSelectList->dArray();	// faied the copy.  dArray.					shadowSelectList = NULL;					}				}			// jca 26 Oct 93 }			Select(NULL,NULL,0L);			surfDefSelect = FALSE;			clipBuf->IOSetPosition(0);			clipBuf->IOSetDirection(DATA_IN);			IO_ID(clipBuf,IFF_FEAT);			err = IO_OBJECT(clipBuf);			if(!err)				{				PastePosition();				controller->Request(NULL,msgEdit,objPolygon,0);				controller->Request(NULL,msgEdit,objTextureList,0);		// ABD MERGE-TEXTURE 9/13/93				}						if (err)	// jca 26 Oct 93 {				{	// if we can't duplicate the objects...				if (shadowSelectList)					{					int salvageErr = noErr;					salvageErr = shadowSelectList->CopyArray(selectedList);		// leave the last object selected					if (salvageErr)						selectedList->SetLength(0);		// inconceivable!					else						{	// all okay, save the info back						pFeat = (CAVSurfFeature	**)shadowSelectList->Use();	// turn the features back on (select them)						for(i = 0; i < shadowSelectList->ALength(); i++)  							pFeat[i]->SetMode(IN_POLY); 						shadowSelectList->Unuse();						SelectFeature(NULL, selectedList);						}					shadowSelectList->dArray();                    shadowSelectList = NULL;					}				else					selectedList->SetLength(0);		// fail gracefully				}			// 17MAY94 jca oops-- forgot to delete it			if (shadowSelectList)            	{				shadowSelectList->dArray();		// we failed the copy;  dArray				shadowSelectList = NULL;                }			// jca 26 Oct 93 }			break; 				case  MSG_CUT:	/* Cut */			err = EditBuffer(MSG_COPY,modifiers);		case  MSG_CLEAR:	/* Clear */			if(!(length = selectedList->ALength())) return(-1);			undoItem = NewUndoItem(UNDO_SURF_FLAG);			undoSpec = undoItem->cEditSpec(_EDIT_DESTROY);			pFeat = (CAVSurfFeature	**)selectedList->Use();			for(i = 0; i < length; i++,pFeat++)  				undoItem->EditSurface(surfDef,*pFeat); 			selectedList->Unuse();			selectedList->SetLength(0);			editList->SetLength(0);/* dude */			undoItem->Edit();			controller->Request(NULL,msgDestroy,objPolygon,0);			controller->Request(NULL,msgEdit,objTextureList,0);		// ABD MERGE-TEXTURE 9/13/93			break; 					case  MSG_UNDO:			undoItem = UndoItem();			undoType = undoItem->GetType();						if(UNDO_SURF_FLAG == undoType)				{				undoItems = new(V_Array);				undoItems->cArray(0,sizeof(void*),4);				undoType = undoItem->GetItems(UNDO_SURF_FLAG,undoItems);				length = undoItems->ALength();				undoItem->Reverse();				undoItem->Edit();				pFeat = (CAVSurfFeature	**)undoItems->Use();				for(i = 0; i < length; i++,pFeat++)					{					if(*pFeat)						{						mode = (*pFeat)->GetMode();						found = selectedList->Find(&(*pFeat));						if(OUT_POLY == mode)							{							if(0 <= found)								selectedList->Remove(found);							}						else							{							if(0 > found)								selectedList->Insert(0,&(*pFeat));							}						}					else						{						surfDefSelect = TRUE;						selectedList->SetLength(0);						}					}				undoItems->Unuse();				undoItems->dArray();				VDisplay(DRAW);				controller->Request(NULL,msgEdit,objPolyhedron,0);				controller->Request(NULL,msgEdit,objTextureList,0);		// ABD MERGE-TEXTURE 9/13/93				}			break; 		}		return(err);	}intSurfDraft::IO_OBJECT(V_Buffer *buf)	{	CAVSurfFeature	*newFeature,**pFeat;	Unit	*worldUnit,*unit;	FFixed	factor;	long	chunkID;	int		where,length,i,err,doSelect;	extern struct TextureServer *gTextureServer;		// ABD MERGE-TEXTURE 9/13/93// REMOVE jca 19JAN94	extern TextureArray *gAllTextures;		worldUnit = polyhedron->GetUnit();	err = 0;	gTextureServer->BeginTextureIO(buf, pwc(controller->controller)->docTextures); // jca 19JAN94 pro stuff -- ABD MERGE-TEXTURE 9/13/93		if(buf->IODirection() == DATA_IN)		{		where = PlaceWhere();		if((SURF_SHARED == where) || (environment->GetSide() == where)) doSelect = TRUE;		else doSelect = FALSE;		unit = new(Unit);		unit->cUnit();		worldUnit->Copy(unit);		factor = DblToFixed(unit->ConvertTo(worldUnit));		while (TRUE)			{			chunkID = buf->OpenChunkR();			if (chunkID == 0) break;						switch(chunkID)				{				case IFF_VERS:					IO_VERS(buf);					break;									case IFF_UNIT:					unit->IO(buf);					factor = DblToFixed(unit->ConvertTo(worldUnit));					// BILBIL - above line needed to be added so features' scale is correct 4/11/94					break;					// ABD MERGE-TEXTURE 9/13/93 [[[				case IFF_TXTB:	// texture table ABD TEXTURE					gTextureServer->IOTextureTable(buf, 0);	// purge textures param ignored on input					break;// ABD MERGE-TEXTURE 9/13/93 ]]]				case IFF_FEAT:					newFeature = new(CAVSurfFeature);					newFeature->cSurfFeature();					err = newFeature->IO(buf);			// jca 25 Oct 93 										if (err)		// jca 25 Oct 93 {						{ // if there's an error (typically lowMem) get out						newFeature->dSurfFeature();						newFeature = NULL;						break;						}			// jca 25 Oct 93 }											newFeature->ChangeUnit(factor);					if(doSelect) selectedList->Insert(0,&newFeature);					break;				}					buf->CloseChunk();			}		unit->dUnit();		length = selectedList->ALength();		if(!length) err = 1;		}	else		{				length = selectedList->ALength();				if(!length) err = 1;		else			{			buf->OpenChunkW(IFF_VERS);			IO_VERS(clipBuf);			buf->CloseChunk();				buf->OpenChunkW(IFF_UNIT);			worldUnit->IO(buf);			buf->CloseChunk();				pFeat = (CAVSurfFeature	**)selectedList->Use();			for(i = length-1; i >= 0; i--)				{				buf->OpenChunkW(IFF_FEAT);				pFeat[i]->IO(buf);				buf->CloseChunk();				}			selectedList->Unuse();			}// ABD MERGE-TEXTURE 9/13/93 [[[			// write out texture table -- must be done after writing out objects			buf->OpenChunkW(IFF_TXTB);			gTextureServer->IOTextureTable(buf, TRUE);		// ABD TEXTURE purge textures 			buf->CloseChunk();// ABD MERGE-TEXTURE 9/13/93 ]]]		}		gTextureServer->EndTextureIO(buf);		// ABD MERGE-TEXTURE 9/13/93 		return err;	}voidSurfDraft::DuplicatePosition(Position *relPosn,CAVSurfFeature *dupFeature)	{	CAVSurfFeature	**pFeat;	Position 		*currFeatPos, *baseFeatPos;   // jca 22FEB95 positions for the current feature and the base feature	EditSpecList	*undoItem;	EditSpec		*undoSpec;	V_Array			*tmpList;	PointFFixed		pointVector;	int				length,i,where;		undoItem = NewUndoItem(UNDO_SURF_FLAG);	tmpList = new(V_Array);	tmpList->cArray(0,sizeof(CAVSurfFeature*),4);	selectedList->CopyArray(tmpList);	selectedList->SetLength(0);	// jca 17 Oct 93 { this is to match smith's change in PastePosition()	where = PlaceWhere();	length=tmpList->ALength();	pFeat = (CAVSurfFeature	**)tmpList->Use();	for(i = 0; i < length; i++,pFeat++)		if(IS_TRANSPARENT((*pFeat)->opacity)||IS_TRANSLUCENT((*pFeat)->opacity))			{			where=SURF_SHARED;			break;			}	tmpList->Unuse();// jca 17 Oct 92 } hope it's for walkthrough as well as vr	undoSpec = undoItem->cEditSpec(_EDIT_CREATE);		if(relPosn)		{		((USurfCreate*)undoSpec)->SetSide(surfDef->GetSide(dupFeature));				currFeatPos = new(Position);  // jca 22FEB95 changed variable name {{		currFeatPos->cPosition();		baseFeatPos = new(Position);  // position for the feature we're basing off		baseFeatPos->cPosition();    // jca 22FEB95 }}		length = tmpList->ALength();		pFeat = (CAVSurfFeature	**)tmpList->Use();		for(i = 0; i < length; i++,pFeat++)			{			(*pFeat)->posn->Copy(currFeatPos);     // get the position of the current feature			dupFeature->posn->Copy(baseFeatPos);  // get our base feature position			currFeatPos->UnPosition(baseFeatPos); // unposition our object (like using an inverse matrix)			currFeatPos->Copy((*pFeat)->posn);    // the position is now in base-space			(*pFeat)->posn->PositionX(relPosn);   // offset by the relative position			(*pFeat)->posn->PositionX(baseFeatPos);// reposition the object in its feature space			(*pFeat)->Update();			}					tmpList->Unuse();		currFeatPos->dPosition();		baseFeatPos->dPosition();  // delete the vars		}	else		{		((USurfCreate*)undoSpec)->SetSide(where);	// jca 17 Oct 93		pointVector = pcc(controller)->GridUnit();		pointVector = environment->Translate2DFFixed(TO_WORLD,pointVector);		undoSpec = undoItem->cEditSpec(_EDIT_MOVE);		((USurfMove*)undoSpec)->SetVector(PtFFZero,pointVector);		}			length = tmpList->ALength();	pFeat = (CAVSurfFeature	**)tmpList->Use();	for(i = 0; i < length; i++,pFeat++)		{		(*pFeat)->SetLayer(pcc(controller)->GetLayer());		undoItem->EditSurface(surfDef,*pFeat);		selectedList->Append(&(*pFeat));		}	tmpList->Unuse();		undoItem->Edit();		psc(controller)->NewSurfFeature(tmpList);	tmpList->dArray();	}voidSurfDraft::PastePosition()	{	CAVSurfFeature	**pFeat,*leadFeat;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	V_Array			*tmpList;	PointFFixed		pointVector,ptOrigin,displace;	Point			p;	int				length,i,where;		undoItem = NewUndoItem(UNDO_SURF_FLAG);	tmpList = new(V_Array);	tmpList->cArray(0,sizeof(CAVSurfFeature*),4);	selectedList->CopyArray(tmpList);	selectedList->Get(0,&leadFeat);	selectedList->SetLength(0);		where = PlaceWhere();// { DAS-VR-SURFEDIT 9/30/93		length=tmpList->ALength();	pFeat = (CAVSurfFeature	**)tmpList->Use();	for(i = 0; i < length; i++,pFeat++)		if(IS_TRANSPARENT((*pFeat)->opacity)||IS_TRANSLUCENT((*pFeat)->opacity))			{			where=SURF_SHARED;			break;			}	tmpList->Unuse();// } DAS-VR-SURFEDIT 9/30/93		ptOrigin = leadFeat->posn->GetOrigin2D();	ptOrigin = environment->Translate2DFFixed(TO_CAD,ptOrigin);	displace = MakePtInWorld(ffLastPt,TRUE);	pointVector.h = FFSub(displace.h,ptOrigin.h);	pointVector.v = FFSub(displace.v,ptOrigin.v);	pointVector = SetToGrid(pointVector,pcc(controller)->GridUnit());	pointVector = environment->Translate2DFFixed(TO_WORLD,pointVector);	undoSpec = undoItem->cEditSpec(_EDIT_MOVE);	((USurfMove*)undoSpec)->SetVector(PtFFZero,pointVector);	undoSpec = undoItem->cEditSpec(_EDIT_CREATE);	((USurfCreate*)undoSpec)->SetSide(where);	length = tmpList->ALength();	pFeat = (CAVSurfFeature	**)tmpList->Use();	for(i = 0; i < length; i++,pFeat++)		{		(*pFeat)->SetLayer(pcc(controller)->GetLayer());		undoItem->EditSurface(surfDef,*pFeat);		selectedList->Append(&(*pFeat));		}	tmpList->Unuse();		undoItem->Edit();		psc(controller)->NewSurfFeature(tmpList);	tmpList->dArray();	}	void SurfDraft::SetEditState(int editState,long modifiers,int dir)	{			CAVSurfFeature	**pFeat;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	int				i,length,walkView;		walkView = (OPT_EDIT_MODE&modifiers)? TRUE : FALSE;	if(!dir)		{		surfDef->ResetEditState(editState,walkView); 		}	else		{		if(!(length = selectedList->ALength()))return;		undoItem = NewUndoItem(UNDO_SURF_FLAG);		if(walkView)			undoSpec = undoItem->cEditSpec(_EDIT_HIDEWALK);		else			{			if(editState&EDIT_HIDDEN) 				undoSpec = undoItem->cEditSpec(_EDIT_HIDE);			if(editState&EDIT_LOCKED) 				undoSpec = undoItem->cEditSpec(_EDIT_LOCK);			}					pFeat = (CAVSurfFeature	**)selectedList->Use();		for(i = 0; i < length; i++,pFeat++)			undoItem->EditSurface(surfDef,*pFeat); 		selectedList->Unuse();				if(walkView)Select(NULL,NULL,0);					undoItem->Edit();				}			if(walkView)		controller->Request(NULL,msgEdit,objView,0);	else		{		VDisplay(DRAW);		controller->Request(NULL,msgEdit,objPolyhedron,0);		}	}void SurfDraft::SetColor(RGBColor color)	{	CAVSurfFeature	**pFeat;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	int				i,length; 	undoItem = NewUndoItem(UNDO_SURF_FLAG);	undoSpec = undoItem->cEditSpec(_EDIT_COLOR);	((USurfColor*)undoSpec)->SetColor(color,PlaceWhere());		if(length = selectedList->ALength())		{		pFeat = (CAVSurfFeature	**)selectedList->Use();		for(i = 0; i < length; i++,pFeat++) 			undoItem->EditSurface(surfDef,*pFeat);		selectedList->Unuse();		undoItem->Edit();		}		if(surfDefSelect)		{		undoItem->EditSurface(surfDef,NULL);		undoItem->Edit();		controller->EditPolyhedron(polyhedron,objPolygon);		}		controller->Request(NULL,msgEdit,objPolygon,0);	}void SurfDraft::MoveFeature( int newSide )	{	CAVSurfFeature	**pFeat;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	int				i,length,deselect,view; 	if(!(length = selectedList->ALength())) return;	deselect = FALSE;	switch(environment->GetSide())		{		case SURF_INSIDE: 			switch(newSide)				{				case SURF_INSIDE: newSide = SURF_OUTSIDE; deselect = TRUE; break;				case SURF_SHARED: break;				case SURF_OUTSIDE:newSide = SURF_INSIDE; break; 				}			break;		case SURF_OUTSIDE:			switch(newSide)				{				case SURF_INSIDE: deselect = TRUE; break;				case SURF_SHARED: break;				case SURF_OUTSIDE:break; 				}			break;		}	undoItem = NewUndoItem(UNDO_SURF_FLAG);	undoSpec = undoItem->cEditSpec(_EDIT_SIDE);		((USurfSide*)undoSpec)->SetSide(newSide);	pFeat = (CAVSurfFeature	**)selectedList->Use();	for(i = 0; i < length; i++,pFeat++) 		undoItem->EditSurface(surfDef,*pFeat);	selectedList->Unuse();	undoItem->Edit();	if(deselect)selectedList->SetLength(0);	controller->Request(NULL,msgEdit,objPolygon,0);		}void SurfDraft::OrderFeature(int step)	{	CAVSurfFeature	**pFeat;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	int				i,length; 	if(!(length = selectedList->ALength())) return;	undoItem = NewUndoItem(UNDO_SURF_FLAG);	undoSpec = undoItem->cEditSpec(_EDIT_ORDER);	((USurfOrder*)undoSpec)->SetOrder(step);	pFeat = (CAVSurfFeature	**)selectedList->Use();	for(i = 0; i < length; i++,pFeat++) 		undoItem->EditSurface(surfDef,*pFeat);	selectedList->Unuse();	undoItem->Edit();		controller->Request(NULL,msgEdit,objPolygon,0);	}void SurfDraft::SetSides(int numSides,int editType)	{		V_Array			*tmpList;	CAVSurfFeature	**pFeat;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	int				i,length;		if(!(length = selectedList->ALength())) return;		tmpList = new(V_Array);	tmpList->cArray(0,sizeof(CAVSurfFeature*),4);		pFeat = (CAVSurfFeature	**)selectedList->Use();	for(i = 0; i < length; i++,pFeat++)		if( EDIT_REGPOLYGON == (*pFeat)->GetEditType())			tmpList->Append(&(*pFeat));	selectedList->Unuse();		length = tmpList->ALength();	if(length)		{			undoItem = NewUndoItem(UNDO_SURF_FLAG);		undoSpec = undoItem->cEditSpec(_EDIT_NUMSIDES);		((USurfNumSides*)undoSpec)->SetNumber(numSides);			pFeat = (CAVSurfFeature	**)tmpList->Use();		for(i = 0; i < length; i++,pFeat++)			undoItem->SetEditObject(surfDef,*pFeat,UNDO_SURF_FLAG);		tmpList->Unuse();				undoItem->Edit();			pFeat =(CAVSurfFeature	**) tmpList->Use();		for(i = 0; i < length; i++,pFeat++)			{			if( EDIT_REGPOLYGON == (*pFeat)->GetEditType())				controller->EditPolyhedron(*pFeat,objPolygon);			}		tmpList->Unuse();		VDisplay(DRAW);		controller->Request(NULL,msgEdit,objPolyhedron,0);		}			tmpList->dArray();	}	void SurfDraft::SetOpacity(int opacity)	{	CAVSurfFeature	**pFeat;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	int				i,length;	 	undoItem = NewUndoItem(UNDO_SURF_FLAG);	undoSpec = undoItem->cEditSpec(_EDIT_OPACITY);	((USurfOpacity*)undoSpec)->SetOpacity(opacity);			if(length = selectedList->ALength())		{		pFeat =(CAVSurfFeature	**) selectedList->Use();		for(i = 0; i < length; i++,pFeat++) 			undoItem->EditSurface(surfDef,*pFeat);		selectedList->Unuse();		undoItem->Edit();		controller->Request(NULL,msgEdit,objPolygon,0);		}		if(surfDefSelect)		{		undoItem->EditSurface(surfDef,NULL);		undoItem->Edit();		controller->EditPolyhedron(polyhedron,objPolygon);		VDisplay(DRAW);		controller->Request(NULL,msgEdit,objView,0);		}		}	void SurfDraft::UnPosition(int type) 	{	CAVSurfFeature	**pFeat;	EditSpecList	*undoItem;	EditSpec		*undoSpec;	int				i,length;	 	switch(type) 		{ 		case bROTATE_ROOM: 			undoItem = NewUndoItem(UNDO_SURF_FLAG);			undoSpec = undoItem->cEditSpec(_EDIT_ROTATEABS);			((USurfRotate*)undoSpec)->SetAngle(FFZero,FFZero); 			break; 			 		case bSCALE_ROOM: 			undoItem = NewUndoItem(UNDO_SURF_FLAG);			undoSpec = undoItem->cEditSpec(_EDIT_SCALEABS);			((USurfScale*)undoSpec)->SetScale(PtFFOne,PtFFZero); 			break; 		 		default: 			return;		}		if(length = selectedList->ALength())		{		pFeat = (CAVSurfFeature	**)selectedList->Use();		for(i = 0; i < length; i++,pFeat++) 			undoItem->EditSurface(surfDef,*pFeat);		selectedList->Unuse();		undoItem->Edit();		controller->Request(NULL,msgEdit,objPolygon,0);		}	}int SurfDraft::PlaceWhere()		{	int where;	int	view;		view = environment->GetSide();	where = psc(controller)->GetCreateSide();// { DAS-VR-SURFEDIT 10/1/93#if VWT	if(SURF_INSIDE == view) 		{		if(SURF_OUTSIDE == where)where = SURF_INSIDE;		else if(SURF_INSIDE == where)where = SURF_OUTSIDE;		}#endif// } DAS-VR-SURFEDIT 10/1/93	return(where);	}CAVSurfFeature * SurfDraft::GetFeature()		{	CAVSurfFeature *pFeat;		if(selectedList->ALength())		selectedList->Get(0,&pFeat);	else		pFeat = NULL;		return(pFeat);	}void SurfDraft::WorldSpace(int direction,V_Array *ptList) 	{ 	Position	*polyPosn,*posn;	Point3DFFixed pt3D;	PointFFixed	*pt;	int	i,length;		polyPosn = new(Position);	polyPosn->cPosition();	posn = new(Position);	posn->cPosition();	polyPosn->SetScale(surfDef->polyhedron->posn->GetScale());	polyPosn->SetShear(surfDef->polyhedron->posn->GetShear());/*	posn->SetScale(surfDef->position->GetScale());	posn->SetShear(surfDef->position->GetShear());*/	surfDef->position->Copy(posn);	posn->SetOrigin3D(Pt3DFFZero);		length = ptList->ALength();	pt = (PointFFixed*)ptList->Use();	for(i = 0; i < length; i++,pt++)		{		pt3D.x = pt->h;		pt3D.y = pt->v;		pt3D.z = FFZero;		pt3D = posn->Transform3D(pt3D);		if(TO_WORLD == direction) pt3D = polyPosn->UnTransform3D(pt3D);		else pt3D = polyPosn->Transform3D(pt3D);			pt3D = posn->UnTransform3D(pt3D);			pt->h = pt3D.x;		pt->v = pt3D.y;		}	ptList->Unuse();	polyPosn->dPosition();	posn->dPosition();	}	PointFFixed SurfDraft::ObjectCenter(FFixed *dpth) 	{ 	CAVSurfFeature	**pFeat;	PointFFixed ptMin,ptMax,pt1,pt2;	int	i,length;		ptMin = PtFFMax;	ptMax = PtFFMin;	length = editList->ALength();	pFeat = (CAVSurfFeature	**)editList->Use();	for(i = 0; i < length; i++,pFeat++)		{		(*pFeat)->Extrema(&pt1,&pt2);		FFMin(ptMin.h,pt1.h,ptMin.h);		FFMin(ptMin.v,pt1.v,ptMin.v);		FFMax(ptMax.h,pt2.h,ptMax.h);		FFMax(ptMax.v,pt2.v,ptMax.v);		}	editList->Unuse();			pt1.h = FFAdd(ptMin.h,FFShift(FFSub(ptMax.h,ptMin.h),-1));	pt1.v = FFAdd(ptMin.v,FFShift(FFSub(ptMax.v,ptMin.v),-1));		pt1 = environment->Translate2DFFixed(TO_CAD,pt1);		return(pt1);	}					voidMenuSurface::ctheMenu()	{	cMenu(TXTT_SURFEDITOR,0);/* DUDE _ WRONG */	MenuCad::ctheMenu();	AppendSeparator();		// ABD WILLIAMS MERGE11 9/11/93				Append(TXTM_POLYFORWRD);	Append(TXTM_POLY2FRNT);	Append(TXTM_POLYBACK);		Append(TXTM_POLY2BACK);	#if VRML_ANCHOR				// ABD PRO25	AppendSeparator();				Append(TXTM_VRML_ANCHOR);		#endif // VRML_ANCHOR	#if GERMAN		SetKeyPos(menuForward, menuForwardKeyPos);		SetKeyPos(menuBackward, menuBackwardKeyPos);		SetKeyPos(menuToBack, menuToBackKeyPos);	#elif SPANISH    	SetKeyPos(menuForward, menuForwardKeyPos);		SetKeyPos(menuToFront, menuToFrontKeyPos);		SetKeyPos(menuBackward, menuBackwardKeyPos);		SetKeyPos(menuToBack, menuToBackKeyPos);	#else // English default		SetKeyPos(menuForward, menuForwardKeyPos);		SetKeyPos(menuToFront, menuToFrontKeyPos);		SetKeyPos(menuBackward, menuBackwardKeyPos);		SetKeyPos(menuToBack, menuToBackKeyPos);	#endif // GERMAN	SetMenuEuroKey(menuSurfaceEuroKey);	SetEuroKey(menuForward, menuForwardEuroKey);	SetEuroKey(menuToFront, menuToFrontEuroKey);	SetEuroKey(menuBackward, menuBackwardEuroKey);	SetEuroKey(menuToBack, menuToBackEuroKey);	}#if VRML_ANCHOR				// ABD PRO25voidMenuSurface::Preempt()	{	Activate(menuSurfVRMLAnchor, (((SurfDraft*)(pcc(controller)->cadDraft))->surfDefSelect)							|| (pcc(controller)->cadDraft->selectedList->ALength() == 1) ? 1 : 0);	}#endif // VRML_ANCHOR		voidMenuSurface::Action(int num, long modifier)	{	SurfDraft	*draft;		draft = (SurfDraft	*)pcc(controller)->cadDraft;	switch (num)		{		case menuForward: draft->OrderFeature(1);  break;		case menuToFront: draft->OrderFeature(32000);  break;		case menuBackward: draft->OrderFeature(-1);   break;		case menuToBack: draft->OrderFeature(-32000);   break;		#if VRML_ANCHOR					// ABD PRO25 AUG95		case menuSurfVRMLAnchor: 		{ 		SurfFeature	*the_obj;		WideInputTextDialog *dialog;		int			result;			char		newName[256];			if (((SurfDraft*)(pcc(controller)->cadDraft))->surfDefSelect)			{				if (!((SurfDraft*)(pcc(controller)->cadDraft))->surfDef->HasVRMLAnchor())				{					strcpy(newName, "");				}				else				{				V_Array *va = ((SurfDraft*)(pcc(controller)->cadDraft))->surfDef->GetVRMLAnchor();				char *c = (char *)va->Use();					strncpy(newName, c, va->ALength());					va->Unuse();					newName[va->ALength()] = '\0';				}				dialog = new(WideInputTextDialog);				if (dialog->cInputDialog(ANCHOR_URL,ANCHOR_URL_COLON,newName,inputText))					{						((SurfDraft*)(pcc(controller)->cadDraft))->surfDef->SetVRMLAnchor(newName);					}							}			else if (pcc(controller)->cadDraft->selectedList->ALength() == 1)			{				pcc(controller)->cadDraft->selectedList->Get(0, &the_obj);				if (the_obj == NULL) break;		// should not happen				if (!the_obj->HasVRMLAnchor())					strcpy(newName, "");				else				{				V_Array *va = the_obj->GetVRMLAnchor();				char *c = (char *)va->Use();					strncpy(newName, c, va->ALength());					va->Unuse();					newName[va->ALength()] = '\0';				}				dialog = new(WideInputTextDialog);				if (dialog->cInputDialog(ANCHOR_URL,ANCHOR_URL_COLON,newName,inputText))					{						the_obj->SetVRMLAnchor(newName);					}								}		}				break;		#endif // VRML_ANCHOR		default: MenuCad::Action(num,modifier); break;		}	}#if VRML_ANCHOR		// ABD PRO25 AUG95voidSurfDraft::DrawURL(Point p, int redraw_only){Rect r;void *obj = NULL;Point	sp;PointFFixed	worldPt;	tempFFPoints->Get(0,&worldPt);	if (!redraw_only)	{		sp.h = lOrigin.h + p.h;		sp.v = lOrigin.v + p.v;		obj = (void *)surfDef->FindFeatureNoSideEffects(&sp,&worldPt,0,FALSE,FIND_NORMAL);		if (obj == NULL)		{			// Amazingly, the surfDef Find routine does not generate any side effects!			// So we can just use that routine instead of making a whole routine to			// do what should have been done in the first place, do a Find without			// generating any side effects!!!  Woo Hoo!!!			obj = (void *)surfDef->Find(&sp,0,FALSE,FIND_NORMAL);			if (obj != NULL)				obj_is_surfdef = TRUE;		}		else			obj_is_surfdef = FALSE;	}	else		obj = lastVRMLObj;		// only draw if we are supposed to redraw, or the item is different	if (redraw_only || (obj != lastVRMLObj))	{		r = dataRect;		r.bottom++;		r.left--;		r.right++;		r.top = r.bottom - 18;		if (depth >= 4)		{		#if MACINTOSH		RGBColor col = {0xB800,0xB800,0xB800};		#elif WINDOWS		RGBColor col = {0xC000,0xC000,0xC000};		#else 		#error Mac or Windows?		#endif						VForeColor(&vBlack);			VFrameRect(&r);			r.left	+=1;	r.top	+=1;			r.bottom-=1;	r.right	-=1;			VForeColor(&col);			VPaintRect(&r);		}		else		{			VFrameRect(&r);				r.left	+=1;	r.top	+=1;			r.bottom-=1;	r.right	-=1;			VEraseRect(&r);		}				if (obj && obj_is_surfdef && ((SurfDef*)obj)->HasVRMLAnchor())		{		char *str;					TextSetUp(vAppFont,vMediumFont,vNormal);			r.bottom -= 5;			r.left += 3;			str = (char *)surfDef->vrml_anchor->Use();						if (depth >= 4)			{			#if MACINTOSH			RGBColor col = {0xDDDD,0xDDDD,0xDDDD};			#elif WINDOWS			RGBColor col = {0xDDDD,0xDDDD,0xDDDD};			#else 			#error Mac or Windows?			#endif							VForeColor(&col);						r.left++;					r.top++;					r.right++;				r.bottom++;				VDrawText(str,0,surfDef->vrml_anchor->ALength(),&r);				r.left--;					r.top--;							r.right--;				r.bottom--;			}						VForeColor(&vBlack);					VDrawText(str,0,surfDef->vrml_anchor->ALength(),&r);			surfDef->vrml_anchor->Unuse();			}		else if (obj && !obj_is_surfdef && ((SurfFeature*)obj)->HasVRMLAnchor())		{		char *str;			TextSetUp(vAppFont,vMediumFont,vNormal);			r.bottom -= 5;			r.left += 3;			str = (char *)((SurfFeature*)obj)->vrml_anchor->Use();						if (depth >= 4)			{			#if MACINTOSH			RGBColor col = {0xDDDD,0xDDDD,0xDDDD};			#elif WINDOWS			RGBColor col = {0xDDDD,0xDDDD,0xDDDD};			#else 			#error Mac or Windows?			#endif							VForeColor(&col);						r.left++;					r.top++;					r.right++;				r.bottom++;				VDrawText(str,0,((SurfFeature*)obj)->vrml_anchor->ALength(),&r);				r.left--;					r.top--;							r.right--;				r.bottom--;			}						VForeColor(&vBlack);					VDrawText(str,0,((SurfFeature*)obj)->vrml_anchor->ALength(),&r);			((SurfFeature*)obj)->vrml_anchor->Unuse();			}		else		{				char str[256] = "";			TextSetUp(vAppFont,vMediumFont,vNormal);			r.bottom -= 5;			r.left += 3;						if (depth >= 4)			{			#if MACINTOSH			RGBColor col = {0xDDDD,0xDDDD,0xDDDD};			#elif WINDOWS			RGBColor col = {0xDDDD,0xDDDD,0xDDDD};			#else 			#error Mac or Windows?			#endif							VForeColor(&col);						r.left++;					r.top++;					r.right++;				r.bottom++;				VDrawText(str,0,strlen(str),&r);				r.left--;					r.top--;							r.right--;				r.bottom--;			}						VForeColor(&vBlack);					VDrawText(str,0,strlen(str),&r);		}		lastVRMLObj = obj;	}}#endif // VRML_ANCHOR