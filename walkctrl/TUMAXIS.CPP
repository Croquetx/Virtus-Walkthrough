/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "TumAxis.h"#include "CVTumObj.h"#include "TumCntrl.h"#include "Light.h"#include "Drawing.h"#include "Polyhdrn.h"#include "PolyDefs.h"#include "ToolDef.h"#include "BallHelp.h"#include "AppDeflt.h"#include "Misc.h"#include "VGraphic.h"#include "Space.h"voidTumbleAxis::cPane(int flag)	{		FFixed	cubeSide = INITFIXXED(100, 0x0000);			controller = NULL;		tumble = new(OrientObject);	SpacePane::cPane(flag);		MakeCube(cubeSide);	tumble->SetDrawState(TUMBLE_FRAME);	}voidTumbleAxis::dPane(void)	{	studio->dWalkDrawing();	polyhedron->dPolyhedron();	SpacePane::dPane();	}voidTumbleAxis::TrackHelp(Point pt, long modifier)// DAS-VWINDOWS 9/30/93	{// { DAS-VR-HELP 9/30/93#if VWT	Rect r;	r = dataRect;	BalloonHotRect(&r,pt);	Bubble(pt,&r,TXTB_ORIENTCUBE);	#endif// } DAS-VR-HELP 9/30/93		}	void TumbleAxis::SetController(Controller *ctrl)	{ controller = ctrl; }voidTumbleAxis::MouseDown(Point p,long modifiers)	{	anchorPt = p;	if(modifiers&doubleClick)		{		int		sel;		p.h+=origin.h;		p.v+=origin.v;		if(NO_MARK != (sel = tumble->Find(p)))			{			FrontSurface(sel);			controller->Request(NULL,msgEdit,objAxis,0);			}		}	else SpacePane::MouseDown(p,modifiers);	}	voidTumbleAxis::Track(Point p,long modifiers,int inside)	{	Point	tp = lastPt;	VSetCursor(vCursorHand);	SpacePane::Track(p,modifiers,inside);	if(!(modifiers&OPT_EDIT_MODE) && CursorMove(p,tp) && (buttonDown&modifiers))		{		controller->Request(NULL,msgEdit,objAxis,0);		SetPane();		}	lastPt = p;	}voidTumbleAxis::MouseUp(Point p,long modifiers)	{	if(CursorMove(anchorPt,lastPt))		{		controller->Request(NULL,msgEdit,objAxis,0);		SetPane();		anchorPt = lastPt;		}	}			voidTumbleAxis::Display(int type,int h,int v)	{	Rect r = dataRect;	SetMetaPort();	if( depth >= 4)		{		VForeColor(&vColorSlateM);		VPaintRect(&r);		VForeColor(&vBlack);		}	else		VEraseRect(&r);			VFrameRect(&r);			SpacePane::Display(type,h,v);	MetaCopy(&r);	UnsetMetaPort();	}voidTumbleAxis::CalcSize(Rect *r,Point *p,int type,int warning)	{	controller->GetPlace(r,warning,toolPAxis);	}/* *	Orient() and GetOrient() are for translation between a space object and RPY values *	used by the rest of the application.  Translation from space to RPY is not *	supported, so GetOrient() doesn't do anything.  The RPY values passed in and out *	here aren't the same ones used by the space object's AngleToMatrix() and *	MatrixToAngle() methods. */voidTumbleAxis::Orient(Angle3D orientation)	{	space->AngleToMatrix(0, 0, 0);	space->Roll(-orientation.yaw << 6);	space->Yaw(-orientation.pitch << 6);	space->Pitch(-orientation.roll << 6);	space->Normalize();	VDisplay(DRAW);	}Angle3DTumbleAxis::GetOrient()	{	Angle3D	orientation;	orientation.roll = 0;	orientation.pitch = 0;	orientation.yaw = 0;	return(orientation);	}