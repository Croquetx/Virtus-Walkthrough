/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				 *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VMemUtil.h"#include "VDisplay.h"#include "VDocumnt.h"#include "VWindow.h"#include "VPane.h"#include "VArray.h"#include "VMain.h" #include "VDialog.h" #include "VTextDef.h" #include "VGUtil.h"#include <stdio.h>#if WINDOWS#include "smrtheap.hpp"   // jca 30 Nov 93 for the totalmem stuff#include <time.h>#endif // WINDOWSHandle reserved;int lowMemory=memoryFine;//if memory was too low for rendering the walkview, we'd pause for//a full minute before MyGrowZone() is called.  I inserted this code//to abort drawing if memory becomes low.  Doesn't appear to be a problem//in Windows.int gmemoryLowForWalkView=0;		//JAM 17FEB95 low memory walk rendering//code to help surface features not take up more memory if memory is lowint gmemoryLowForSurfaceFeatures=0;	//JAM 17FEB95 low memory walk renderinglong reserveMemorySize;int growMemory; /*indicates whether we should attempt to grow this area*/Handle superReserved;void MemoryErr(int);#define SUPERSIZE 8000Lvoid GrowMemory(int gm) { growMemory=gm; }extern long availableMem; // DAS-VWI 10/2/93int percentMemoryShort = 3;int CheckMemory()									// GJR 10/22/93{return memoryFine;if (lowMemory < memoryShort)	{	// then check for lack of memory	long fMem;	fMem=FreeMem(); #if WINDOWS	availableMem = TotalMem();	// memsize can change dynamically under windows(tm) jca 30 Nov 93#endif // WINDOWS// the old code could (and did) overflow.  Smith's fix to this// was:  fMem = (fMem*100.0)/availableMem; which uses floating point.// a better solution (we think) is Greg's, which predivides (if// availableMem < 100 we're trouble anyway, so don't worry; be happy)	jca 10 Nov 93// fMem=(fMem*100)/availableMem;      // oops, overflow if fMem>20Meg  		fMem = fMem/((availableMem/100)+1);		// get percentage, avoid large (>20M) fMem overflows	//GJR 11/10/93	if(fMem<percentMemoryShort)lowMemory=memoryShort; // DAS-MEMORY 10/9/93 this allows the load to exit sooner.	}return lowMemory;}													// GJR 10/22/93voidObjLock(void * theObj){#ifndef __powerc	HLock((Handle)theObj);#endif //__powerc	}voidObjUnlock(void * theObj){#ifndef __powerc	HUnlock((Handle)theObj);#endif //__powerc	}voidMoveObjHi(void * theObj){#ifndef __powerc#if MACINTOSH	MoveHHi((Handle)theObj);#elif WINDOWS	// nothing equivalent, since we're doing pointers.   jca 26 aug 93#endif // MACINTOSH#endif //__powerc	}#if MACINTOSH/*------------------------------------------------------------------------------ * pascal long MyGrowZone(long sizeNeeded) * This routine is called by the Mac toolbox when an out of memory condition * occurs.  It will attempt to rescue the situation by first freeing up a  * reserved block of memory, then by destroying the offscreen pixmap and then... *------------------------------------------------------------------------------*/ long myCurrentA5;void SetMyA5(void);void RestoreMyA5(void);void SetMyA5(void)	{	myCurrentA5=(long)SetCurrentA5();	}	void RestoreMyA5(void)	{	SetA5(myCurrentA5); 	}pascal long MyGrowZone(long);pascal long MyGrowZone(long sizeNeeded){long length = 0;long *currentA5,oldA5;/*this appears to be the only way to set the A5 register to the "real" value.  See Tech Note #136 for more details.*/SetMyA5();if(!inMain)/*we can exit gracefully before we even start here*/	{	if(reserved)DisposHandle((Handle)reserved);reserved=NULL;	if(superReserved)DisposHandle((Handle)superReserved);superReserved=NULL;	AlertMessage(TXT_NOMEM);	VExitToShell();	}	else if(!growMemory)										// GJR 10/22/93	{	// Then handle large memory requests. No growing to be done. But be nice anyway.		// Try to get more memory, expecially with fragmented AlwaysLocked VArrays.		// Also, if growMemory is used, USER MUST CHECK FOR ERROR RETURNS!!!!!		// So, don't need to alert the world here.		// NOTE: DO NOT TELL WORLD OF PROBLEMS (via lowMemory). CALLER TAKES CARE OF IT.		length = CompactArrays();	// Give benefit of doubt. Try to defrag memory.	if (length)		{	// then the defrag did something. hope for the best.		length = 1;				// keep the "loop" going		goto memDone;		}	else		{ // no change, so we already did our best.		length = 0;				// tell Mac we failed, no more memory for this request.		goto memDone;		}	}else	{		//------------------------------------------------------------------		// Memory Warning Levels		// Each time through, try again to free up some memory		// As each method fails, bump up the lowMemory stage.		// The Mac does not distinguish between repeat calls here for the same		// block, and fresh new calls. Note that fresh new calls may only need		// a CompactArrays to succeed, even at severe lowMemory stages.		// So we go through each and every possibility to free up some memory.		// When a single block can't get its memory, this routine will behave as		// a loop, trying one thing and then another into deeper and		// deeper lowMemory stages.		// With a fresh block, early easy methods are tried again, just in case		// they are good enough.		//------------------------------------------------------------------		// memoryFine		//		// If this is the first time for this memory, try simple stuff first.		//GJR 10/22/93		length = CompactArrays(); // DAS-VARRAY 10/2/93			// GJR 10/26/93					if (length)			{			length = 1;				// keep the "loop" going			goto memDone;			}        #if 0	//JAM 17FEB95 Greg and Jeff decided this is a bad idea [[[		/*kill the offscreen pixmap (if we can) */		if(offscreen && !offscreen->lock)/*not in use*/			{			offscreen->dOffscreen();			offscreen=NULL;			length=1;			}		if (length)			{	// if we know we did something substantial, exit and give MacMem a try.			CompactArrays(); // DAS-VARRAY 10/2/93			length = 1;				// keep the "loop" going			goto memDone;			}		#endif //0	//JAM 17FEB95 Greg and Jeff decided this is a bad idea ]]]		if (lowMemory == memoryFine)			{	// if we already did this block at this severity,				// and we couldn't definitely change anything				// then bump up severity, and try again.			lowMemory=memoryShort;			length = 1;				// keep the "loop" going			goto memDone;			}		//------------------------------------------------------------------		// memoryShort		//					if (reserved)			{	// Then release the reserved block						//GJR 10/22/93			DisposHandle((Handle)reserved);			reserved=0;			length = 1;			}		if (length)			{	// if we know we did something substantial, exit and give MacMem a try.			CompactArrays(); // DAS-VARRAY 10/2/93			length = 1;				// keep the "loop" going			goto memDone;			}					if (lowMemory == memoryShort)			{	// if we already did this block at this severity,				// and we couldn't definitely change anything				// then bump up severity, and try again.			lowMemory = memoryCritical;			length = 1;				// keep the "loop" going			goto memDone;			}		//------------------------------------------------------------------		// memoryCritical		//	not much here but to abort via MemoryErr(memoryCritical)		if (superReserved)			{			DisposHandle((Handle)superReserved);			superReserved=NULL;			}					lowMemory=memoryGone;		CompactArrays(); // DAS-VARRAY 10/2/93		MemoryErr(memoryCritical); /*let the user know that he is down to the last bit*/		length=0;	 /*we'll never see this line, but what the hell...*/	}memDone:RestoreMyA5(); // DAS-BUGFIX 10/2/93return length;}#endif //MACINTOSH/*------------------------------------------------------------------------------ * void ReserveMemoryBlock(long size) * This routine allocates the reserved memory block. *------------------------------------------------------------------------------*/// In case we don't have the universal headers...#if MACINTOSH	#ifndef NewGrowZoneProc		#define NewGrowZoneProc(x) (ProcPtr)x	#endif#endifvoid ReserveMemoryBlock(long size)	{	superReserved=NewHandle(SUPERSIZE);	reserveMemorySize=size;	reserved=NewHandle(size);#if MACINTOSH	SetGrowZone(NewGrowZoneProc(MyGrowZone)); // DAS-C++ 10/2/93#elif WINDOWS	// need to install a SmartHeap handler // DWE#endif //MACINTOSH	}/*------------------------------------------------------------------------------ * void ReclaimMemory(void) * This routine will reallocate the reserved memory block if it can.  If the super * fund is gone (superReserved) then there is no bail out. *------------------------------------------------------------------------------*/int memoryCount;int lastLowMem;void ReclaimMemory(void)	{	int saveGrowMemory = growMemory;					// GJR 10/22/93 [[[	if(superReserved)		{	// if we are allowed to recover (superReserved gone says byebye to all...)		if (!reserved)			{	// and we need to recover,			if(FreeMem() > 2*reserveMemorySize)				{	// and we got enough for some hysterisis					// then recover it.				growMemory = FALSE;			// turn off grow zone for this large block				reserved=NewHandle(reserveMemorySize);				growMemory = saveGrowMemory;						// GJR 10/26/93				}			}		if(reserved)			{	// if we have a reserve, then hope for the best.				//  CheckMemory() will pessimistically correct us later.			lowMemory=memoryFine;#if MACINTOSH//			FlushEvents(app1Evt,0);			// don't flush things you know nothing about											// this seems like a paltry attempt to flush excess error messages											// Handle it differently. // GJR 10/22/93#endif //MACINTOSH			}		}			CheckMemory();				// Catch any other problems.	MemoryErr(lowMemory);		// Announce any problems now.	growMemory = saveGrowMemory;						// GJR 10/22/93 ]]]	}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/#if WINDOWSlongFreeMem(void)	{	MEM_POOL_INFO info; /* jca 1FEB 94 SmartHeap 2.0 no longer defines lFreeBytes 	info.dwSize = sizeof(MEM_POOL_INFO);	MemPoolInfo(MEM_DEFAULT_POOL, NULL, &info);	return GetFreeSpace(0) + info.lFreeBytes;	*/    return(GetFreeSpace(0));	// jca 1FEB94	}// { DAS-NEWTOOL 11/9/93long TotalMem(void)	{	// jca 1FEB94 I think there is only one pool now... smrtheap 2.0	// MEM_DEFAULT_POOL is where we allocate newHandle from; MemPool.GetPool is where get new from.//	return(MemPoolSize(MEM_DEFAULT_POOL)+MemPoolSize(MemPool.GetPool())+FreeMem());   // jca 30 Nov 93.  Swap space isn't what we want.	return(MemPoolSize(MemDefaultPool)+FreeMem());	}// } DAS-NEWTOLL 11/9/93// jca 7APR94 routines to init and clean up after smartheap, the windows// memory sub-manager that we're using. voidInitMemoryPool(void)	{	if (!MemDefaultPool)       MemInitDefaultPool();   // int the pool	// if you want debugging help, this is where to do it.#if DEBUG && MEM_DEBUG	// THESE ONLY WORK IF:  you have linked in the debug lib SHLW16BD.LIB    // AND #defined MEM_DEBUG, and preferably	// dbgMemSetSafetyLevel(MEM_SAFETY_DEBUG);      O(n^^2) speed.	// for O(n) speed checking, use MEM_SAFETY_FULL	dbgMemSetSafetyLevel(MEM_SAFETY_FULL);      // turn on mem checking	dbgMemSetCheckpoint(1);	// this is our reference point.  We will check for memory leaks against this point.#endif // DEBUG	}#ifdef DEBUG && MEM_DEBUG// jca 8APR94 debugging help with smartheap.  This callback is// to iterate through the list of memory leaks and print each one to a file.// correctReport gets the debug and and sends it to the file (the file has to be// static so the callback can find it)static FILE *memErrFile=NULL;static MEM_ERROR_FN old = NULL;extern HINSTANCE GetAppInstance(); 	// for setting up the callback.  It wants to know the instanceMEM_BOOL  pascal correctReport(MEM_ERROR_INFO *errorInfo);MEM_BOOL  pascal correctReport(MEM_ERROR_INFO *errorInfo)	{	if (errorInfo)   // check for wierd errors    	{		if (errorInfo->errorCode == MEM_LEAKAGE)  // this is the call we want			{            char str[1024];			if (memErrFile)				{				dbgMemFormatErrorInfo(errorInfo, str, 1024);				fputs(str, memErrFile);                return(1);	// keep sending us errors				}            else				return(0);   // no file, so don't report any more errors			}		else  // if this is something we aren't prepared for, send it to the standard handler			{   // old is the previous, more standard handler            if (old)	return(old(errorInfo));			}		}	else		return(0);   // error; send us nothing else	}#endif // DEBUGvoidEndMemoryPool(void)	{// if you want debugging help, this is where to do it.#if DEBUG && MEM_DEBUG	ULong i, poolCount, poolSize, totalCount, totalSize;	int corruptCount, badness;	time_t timer;	struct tm *tblock;	MEM_POOL_STATUS	status;	MEM_POOL_INFO info;	FARPROC proc;    corruptCount = badness = i = 0;    totalCount = totalSize = 0;	status = MemPoolFirst(&info, 0);	while (status == MEM_POOL_OK)		{        i++;		poolCount = MemPoolCount(info.pool);		poolSize = MemPoolSize(info.pool);		if ((poolCount == MEM_ERROR_RET) && (poolSize == MEM_ERROR_RET))			corruptCount++;		else			{			totalCount += poolCount;            totalSize += poolSize;			}        status = MemPoolNext(&info, 0);		}	if (status != MEM_POOL_END)    	badness = ++i;		proc=MakeProcInstance((FARPROC)correctReport,GetAppInstance());	old = MemSetErrorHandler(correctReport);	memErrFile = fopen("memdebug.log", "a");//  dbgMemSetDefaultErrorOutput doesn't output all the errors, so we do our own.//	dbgMemSetDefaultErrorOutput(DBGMEM_OUTPUT_FILE, "memdebug.log");  // write any info to a file	if (totalSize > 0)		{		timer = time(NULL);		tblock = localtime(&timer);		if (badness)			fprintf(memErrFile,				"\r\n%s -- %s\r\nMemory stats:\r\n %ld blocks not deallocated\r\n %ld bytes still allocated\r\n %d pools were corrupt\r\n %d pools examined\r\n hit bad data in pool %d\r\n\r\n",				PRODUCTNAME, asctime(tblock), totalCount, totalSize, corruptCount, i, badness);		else			fprintf(memErrFile,				"\r\n%s -- %s\r\nMemory stats:\r\n %ld blocks not deallocated\r\n %ld bytes still allocated\r\n %d pools in use\r\n %d pools were corrupt\r\n\r\n",				PRODUCTNAME, asctime(tblock), totalCount, totalSize, i, corruptCount);		}	dbgMemReportLeakage(MemDefaultPool, 1, 1); // report on leaks	fflush(memErrFile);    fclose(memErrFile);	MemSetErrorHandler(old);	FreeProcInstance(proc);#else  //12APR94 good idea, but it causes some crashes.  MemFreeDefaultPool();  // in the shipping version, clean up so we don't have large leaks#endif // DEBUG	}#endif //WINDOWS/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/// The memory problem dialogs force redraws on the windows, this causes our memory// to fluctuate (+/- 1Meg for large screens) and make infinite memory problem dialogs.static ULong memShortTime = 0L;static ULong memCriticalTime = 0L;voidMemoryErr(int lowMem)	{ 	ULong	currentTime;#if DEBUG	ULong	waitTime = 1L;#else	ULong	waitTime = 5*60*60; // 5 minutes#endif//DEBUG	if((lastLowMem != lowMem) && (lowMem<=memoryCritical))		{	// if edge detected, and recoverable error, start off fresh. Tell user.		memoryCount = 0;	// edge detect, start off fresh		}	else		{ // else rehash of same old warnings. Ignore them.		memoryCount = 1;		}														// GJR 10/22/93 ]]]			currentTime = VGetTime();	lastLowMem=lowMem;		if(memoryCount==0)	switch(lowMem)		{		case memoryFine:	/*everything is ok*/			break;		case memoryShort:	/*we have lost the offscreen pixmap here, this is not a disaster*/			if ((memShortTime == 0L) || (currentTime - memShortTime > waitTime)) // five minutes				{				AlertMessage(TXT_MEMSHORT);				memShortTime = currentTime;				}			break;		case memoryCritical:	/*we are in trouble! Let the user know!*/			if ((memCriticalTime == 0L) || (currentTime - memCriticalTime > waitTime)) // five minutes				{				AlertMessage(TXT_MEMCRITICAL);				memCriticalTime = currentTime;				}			break;		case memoryGone:		default: /*we are totally fucked, let's blow this place*/			MeterStop(); /*just in case the meter is running*/			AlertMessage(TXT_MEMGONE);	#if MACINTOSH			{			WindowPeek	whichWindow;			whichWindow = (WindowPeek)FrontWindow();/*need the front window*/			while(whichWindow && whichWindow->windowKind < userKind)whichWindow=whichWindow->nextWindow;/*ignore the DA's*/			if(whichWindow)				{				V_Window *win;								win=(V_Window *)GetWRefCon((GrafPtr)whichWindow);				win->theDocument->Quit();				}			else{/*there are no windows visible, so get the first doc*/				V_Document *doc;													theSuper->Get(0,&doc);				doc->Quit();				}			}	#endif //MACINTOSH	#if WINDOWS			VExitToShell();	#endif //WINDOWS			break;		}	}		