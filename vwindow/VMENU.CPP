/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				 *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VMenu.h"#include "VDocumnt.h"#include "VWindow.h"#include "VMain.h"#include "VGUtil.h"#include "VGraphic.h"#include "VMemUtil.h"#include "AppText.h"#include <stdio.h>#include <string.h>int hiMenu;int loMenu;MenuArray *visibleMMgr = NULL;char *menuBreak = (char *)"\p(-";char *specialKeyStr[] =	{	"", "Ins", "Del", "Tab",	// 0 - 3	"BkSp", "Enter", "", "",	// 4 - 7	"", "", "", "",				// 8 - 11	"", "", "", "",				// 12 - 15	"", "F1", "F2", "F3",		// 16 - 19	"F4", "F5", "F6", "F7",		// 20 - 23	"F8", "F9", "F10", "F11",	// 24 - 27	"F12", "", "", ""			// 28 - 31	};/*------------------------------------------------------------------------------ * V_MenuItem * I changed the MenuItem from a handle to an object to help in the port. This may work  * better overall for future ports. It's up to you. *------------------------------------------------------------------------------*/voidV_MenuItem::cMenuItem(int sep)		// ABD WILLIAMS MERGE11 9/10/93 	{ 	itemName[0]=0; 	helpStr = NULL;	state = MENU_ACTIVE;	divider_line = sep;		// ABD WILLIAMS MERGE11 9/10/93	keyAccelerator = 0L; 	keyEquivalent = 0;    euroKey = 0;	heirMenu = NULL; 	}void V_MenuItem::dMenuItem() { if(heirMenu)heirMenu->dMenu(); delete this; } // DAS-BUGFIX 11/2/93void V_MenuItem::SetName(char *str) { strcpy(itemName,str); }void V_MenuItem::GetName(char *str) { strcpy(str,itemName); }void V_MenuItem::SetState(int s) { state = s; }int  V_MenuItem::GetState() { return state; }void V_MenuItem::SetKey(long c) { keyAccelerator = c; }long V_MenuItem::GetKey() { return keyAccelerator; }void V_MenuItem::SetKeyPos(int e) { keyEquivalent = e; }int  V_MenuItem::GetKeyPos() { return keyEquivalent; }void V_MenuItem::SetEuroKey(int k) { euroKey = k; }int  V_MenuItem::GetEuroKey() { return euroKey; }void V_MenuItem::SetHeir(V_Menu *m) { heirMenu = m; }V_Menu *V_MenuItem::GetHeir() { return heirMenu; }	void V_Menu::cMenu(strPtr str,V_Document *doc)	{	document=doc;		cArray(0,sizeof(V_MenuItem*),4);	strcpy(menuName,str);	keyEquivalent=0;    euroKey=0;    mnemonics=TRUE;	type=0;	manager=0;	priority=0;	state = MENU_ACTIVE;	menu = NULL;	linkFrom=NULL;	linkTo=NULL;	manager=NULL;	onOff= FALSE;	mNum = 0;	}	void V_Menu::dMenu()	{	V_Menu *thisMenu;	V_MenuItem  *menuItem;	int i;		thisMenu=this;		if(manager)		manager->Delete(thisMenu);// DAS-BUGFIX 11/2/93 move this code here {	for(i=0;i<length;i++)		{		Get(i,&menuItem);		menuItem->dMenuItem();		}// DAS-BUGFIX 11/2/93 }	if(menu)		{#if MACINTOSH		DisposeMenu(menu);#elif WINDOWS		DestroyMenu(menu);#endif //WINDOWS		i=visibleMMgr->Find(&thisMenu);  		if(i>=0)visibleMMgr->Remove(i);  		}// DAS-BUGFIX 11/2/93 move code from here up#if WINDOWS	if((linkTo==WINDOW_MENU && document) && document->theWindowMenu)  		{		document->theWindowMenu->menu=NULL;		document->theWindowMenu->dMenu();		document->theWindowMenu=NULL;        }// PRO-15 [[[#elif MACINTOSH	if((linkTo==WINDOW_MENU) && theWindowMenu)		{		//JAM 1-20-94 [[[		//if theWindowMenu is in the visible menu manager, it		//should be removed.  If not, and you have library document		//opened, select open (from file menu), then cancel, and		//a crash occurs when it tries to clear this deleted menu		i=visibleMMgr->Find(&theWindowMenu);		if(i>=0)visibleMMgr->Remove(i);  		//JAM 1-20-94 ]]]		theWindowMenu->menu=NULL;		theWindowMenu->dMenu();		theWindowMenu=NULL;        }#else#error what are you a moron?// PRO-15 ]]]#endif //WINDOWS	dArray();	}	void V_Menu::SetMenuKeyPos(int e) { keyEquivalent = e; }int  V_Menu::GetMenuKeyPos() { return keyEquivalent; }void V_Menu::SetMenuEuroKey(int k) { euroKey = k; }int  V_Menu::GetMenuEuroKey() { return euroKey; }void V_Menu::SetMnemonics(int m) { mnemonics = m; }int  V_Menu::GetMnemonics() { return mnemonics; }/* *	MakeMenuEntry() creates a string with the menu entry info in it: * menu entry, the accelerator/key sequence, mnemonic, whatever. * Done only for windows now.  jca 2 Nov 93 */void V_Menu::MakeMenuEntry(char *completeMenuStr, V_MenuItem *menuItem){#if MACINTOSH	menuItem->SetName(completeMenuStr);	// BILBIL - does this do the same thing? - 11/15/93		// MERGE-Z1#elif WINDOWS	long keyDef;	int keyPos,euroKey;	char key;	char mItemStr[256],*charPtr;    int ellipsis;			/*Get the name of the menu item*/	menuItem->GetName(mItemStr);	keyDef = menuItem->GetKey();	key = keyDef&MENU_KEYCODE;#if JAPANESE	if(GetMnemonics()&&(euroKey=menuItem->GetEuroKey())!=0)		{		strcpy(completeMenuStr,mItemStr);		charPtr=completeMenuStr+strlen(completeMenuStr);		if(strcmp(charPtr-3,"...")==0)			{			ellipsis=TRUE;			charPtr-=3;			}		else        	ellipsis=FALSE;		sprintf(charPtr,"(&%c)",euroKey);        if(ellipsis)strcat(charPtr,"...");		}	else if(GetMnemonics()&&(keyPos=menuItem->GetKeyPos())>=0)#else	if(GetMnemonics()&&(keyPos=menuItem->GetKeyPos())>=0)#endif //JAPANESE		{		strncpy(completeMenuStr,mItemStr,keyPos);		completeMenuStr[keyPos]=0;		strcat(completeMenuStr,"&");		strcat(completeMenuStr,&mItemStr[keyPos]);		}	else strcpy(completeMenuStr,mItemStr);	if(keyDef!=0)		{		if(key!=0)keyDef|=ctrlKeyPrefix;		strcat(completeMenuStr,"\t");		if(keyDef&altKeyPrefix)strcat(completeMenuStr,TXT_ALT_PLUS);		// PRO-JAP		if(keyDef&ctrlKeyPrefix)strcat(completeMenuStr,TXT_CTRL_PLUS);		// PRO-JAP		if(keyDef&shiftKeyPrefix)strcat(completeMenuStr,TXT_SHIFT_PLUS);	// PRO-JAP		if(key!=0)			{			int n=strlen(completeMenuStr);			completeMenuStr[n++] = key;			completeMenuStr[n]=0;			}      else			{			int k=(keyDef&MENU_SPECIAL) >> 8;			strcat(completeMenuStr,specialKeyStr[k]);			}		}#endif // WINDOWS}/*------------------------------------------------------------------------------ * MenuHandle V_Menu::MakeMenu(int tMenu) * This method assembles the menus from the base definitions. * It builds the menu heirarchy recursively.   * The menu definition is identical for both the Mac and the * MSWindows incarnations of VWindows. Note that under * MSWindows, these are actually Pop-up menus that we are * defining here, thus the HEIRMENU flag is used to specify * which menu the menu item belongs to. The document then * can use this information to determine which menu/item * was selected by the user and make the proper method call. * The actual menu bar object is created and handled by the * document. *------------------------------------------------------------------------------*/VMenuHandle V_Menu::MakeMenu(int tMenu)	{	char str[256],mStr[256];	VMenuHandle hMenu;	int i,j,result;		ObjLock((ObjectHandle)this);	onOff=TRUE;	/*make the menu object*/	if(linkFrom)		{		menu=linkFrom->menu;		mNum=linkFrom->mNum;		}	else		{#if MACINTOSH		if(tMenu==HEIRMENU) 		{mNum=loMenu;	loMenu++;}		else						{mNum=hiMenu;	hiMenu++;}		strcpy(str,menuName);		C2Pstr(str);		menu=NewMenu(mNum,(unsigned char *)str);#elif WINDOWS		mNum=hiMenu;	    hiMenu++;		menu=CreatePopupMenu();#endif //WINDOWS		}	/*.... Build the menu items here....*/	for(i=0;i<length;i++)		{		V_MenuItem  *menuItem;		V_Menu	*hm;        long keyDef;		int sep,mState,keyPos;		char key;				/*Get the name of the menu item*/		Get(i,&menuItem);		menuItem->GetName(str);		mState = menuItem->GetState();		keyDef = menuItem->GetKey();		key = keyDef&MENU_KEYCODE;		hm = menuItem->GetHeir();	#if MACINTOSH		C2Pstr(str);	// ABD MERGE11 9/10/93 [[[		if (menuItem->divider_line)		{			AppendMenu(menu,(StringPtr)TXTM_BREAK);		}		else		{			AppendMenu(menu,(StringPtr)"\pdum");						// ABD -- if this item begins with a dash, insert a null character before			// the dash so we don't get a divider line menu item.  Note that str is a 			// pascal string so we can do this and get away with it			if (str[1] == '-')			{				for(j=str[0];j>=0;j--)str[j+1]=str[j];				str[0] += 1;				str[1] = '\0';			}			SetItem(menu, LocalToGlobalItem(i+1), (StringPtr)str);		}		/*is there a key equivalent?*/			// MERGE-GOURAUD-PRO-7 -- don't show key prefixes on command-shift-key equivalents		#if MACINTOSH		if ((key) && (!(keyDef & shiftKeyPrefix)))	// MERGE-GOURAUD-PRO-7		#else		if (key)	// MERGE-GOURAUD-PRO-7		#endif // MACINTOSH	// MERGE-GOURAUD-PRO-7			{			SetItemCmd(menu, LocalToGlobalItem(i+1), key);			}		/*do we own a heirarchical menu?*/		if(hm)			{			hMenu=hm->MakeMenu(HEIRMENU);			SetItemCmd(menu, LocalToGlobalItem(i+1), 0x1B);			SetItemMark(menu, LocalToGlobalItem(i+1), hm->mNum);			}// ABD MERGE11 9/10/93 ]]]			if(!hm)  //only worry about this if there if not heir			CheckItem(menu,LocalToGlobalItem(i+1),mState&MENU_SELECT);				if(mState&MENU_ACTIVE)EnableItem(menu,LocalToGlobalItem(i+1));		else DisableItem(menu,LocalToGlobalItem(i+1));#elif WINDOWS		if(hm) hMenu=hm->MakeMenu(0);				// ABD NOTE:  if this menu item is supposed to be a separator, menuItem->divider_line		// is TRUE.  Use this instead of the text of the string to make a separator.		  //		sep=((str[0]==menuBreak[0])&&(str[1]==menuBreak[1]))?TRUE:FALSE;		sep = menuItem->divider_line;		if(sep)mStr[0]=0;		else			{			MakeMenuEntry(mStr, menuItem);			}		AppendMenu(menu,			((mState&MENU_SELECT)?MF_CHECKED:MF_UNCHECKED)|			((mState&MENU_ACTIVE)?MF_ENABLED:MF_DISABLED)|			(sep?MF_SEPARATOR:MF_STRING)|(hm?MF_POPUP:FALSE),			(hm)?hMenu:BUILD_MENUID(mNum,LocalToGlobalItem(i+1)),			mStr);		#endif //WINDOWS		}			if(linkTo)		{		if(linkTo == DA_MENU)			AddDA();#if WINDOWS		else if(linkTo == WINDOW_MENU)			{			if(document && document->theWindowMenu) 	//DUDE PORT				{				document->theWindowMenu->linkFrom=this;    //DUDE PORT				document->theWindowMenu->MakeMenu(tMenu);  //DUDE PORT        		}			}#elif MACINTOSH		else if(linkTo == WINDOW_MENU)			{			if(theWindowMenu)				{				theWindowMenu->linkFrom=this;				theWindowMenu->MakeMenu(tMenu);				}			}#endif //WINDOWS		else 			linkTo->MakeMenu(tMenu);		}#if MACINTOSH	if(linkFrom==NULL)InsertMenu(menu,(tMenu==HEIRMENU)?-1:0);#endif //MACINTOSH	ObjUnlock((ObjectHandle)this);	return menu;	}	void V_Menu::UnmakeMenu()	{	V_MenuItem *menuItem;	V_Menu	*hm;	int i,ln,err;		if(onOff)		{		ObjLock((ObjectHandle)this);		onOff=FALSE;	#if WINDOWS/*We need to recurse to the linked menus, then come back up and destroy the real menu.*/		if(NULL != menu)			{			ln = GetMenuItemCount(menu);			for(i=0;i<ln;i++)				err=RemoveMenu(menu,0,MF_BYPOSITION);			}	#endif //WINDOWS		for(i=0;i<length;i++)			{			Get(i,&menuItem);			hm = menuItem->GetHeir();			if(hm)hm->UnmakeMenu();			}		if(menu && !linkFrom)  //We are at the top of the menu			{	#if MACINTOSH			DeleteMenu(mNum);  			DisposeMenu(menu);	#elif WINDOWS			DestroyMenu(menu);	#endif //MACINTOSH			}		menu=NULL;		if(linkTo==WINDOW_MENU)        	{	#if WINDOWS			if(document && document->theWindowMenu)				document->theWindowMenu->UnmakeMenu();	#elif MACINTOSH			if(theWindowMenu)				theWindowMenu->UnmakeMenu();	#endif //WINDOWS        	}		else if(linkTo && linkTo!=DA_MENU)			linkTo->UnmakeMenu();		ObjUnlock((ObjectHandle)this);		}	}void V_Menu::LinkMenu(V_Menu *link)	{	linkTo=link;	if(link!=DA_MENU && link!=WINDOW_MENU)		link->linkFrom=this;	if(onOff)CleanUp();	}int V_Menu::LocalToGlobalItem(int iNum)	{	V_Menu *lf;		lf=linkFrom;		while(lf)		{		iNum+=lf->ALength();		lf=lf->linkFrom;		}	return iNum;	}void V_Menu::CleanUp() { }void V_Menu::SetPriority(int p) { priority=p; }void V_Menu::AddDA()	{#if MACINTOSH	AppendMenu(menu,(StringPtr)"\p(-");	AddResMenu(menu,'DRVR');#endif //MACINTOSH	CleanUp();	}	void V_Menu::DoDA(int theItem)	{#if MACINTOSH	unsigned char name[256];	GetItem(menu, theItem, name);	OpenDeskAcc( (ConstStr255Param) name );#endif //MACINTOSH	}int V_Menu::Append(void *v)	{	V_MenuItem *menuItem;	char *str;	int rval;		str=(char*)v;	menuItem=new(V_MenuItem);	menuItem->cMenuItem(FALSE);		// ABD MERGE11 WILLIAMS 9/10/93 FALSE means don't make this a divider line		menuItem->SetName(str);	rval=V_Array::Append(&menuItem);	CleanUp();	return rval;	}// ABD MERGE11 WILLIAMS 9/10/93 [[[int V_Menu::AppendSeparator(void)	{	V_MenuItem *menuItem;	int rval;		menuItem=new(V_MenuItem);	menuItem->cMenuItem(TRUE);		// TRUE means make this a divider line		rval=V_Array::Append(&menuItem);	CleanUp();	return rval;	}// ABD MERGE11 WILLIAMS 9/10/93 ]]]int V_Menu::Insert(long iNum,void *v)	{	V_MenuItem *menuItem;	char *str;	int rval;		str=(char*)v;	iNum--;	menuItem=new(V_MenuItem);	menuItem->cMenuItem(FALSE);		// ABD MERGE11 WILLIAMS 9/10/93 FALSE means don't make this a divider line		rval=V_Array::Insert(iNum,&menuItem);	CleanUp();	return rval;	}int V_Menu::Remove(long iNum)	{	V_MenuItem *menuItem;	int rval;		iNum--;	Get(iNum,&menuItem);	menuItem->dMenuItem();	rval=V_Array::Remove(iNum);	CleanUp();	return rval;	}	void V_Menu::SetHeir(int iNum, V_Menu * mn)	{	V_MenuItem *menuItem;	V_Menu *hm;		iNum--;	Get(iNum,&menuItem);	if(onOff)		{		hm = menuItem->GetHeir();		if(hm)hm->UnmakeMenu();		}	menuItem->SetHeir(mn);	CleanUp();	}void V_Menu::SetKey(int iNum,long ch)	{	V_MenuItem *menuItem;		iNum--;	Get(iNum,&menuItem);	menuItem->SetKey(ch);	CleanUp();	}	voidV_Menu::SetKeyPos(int iNum,int pos)	{	V_MenuItem *menuItem;		iNum--;	Get(iNum,&menuItem);	menuItem->SetKeyPos(pos);	CleanUp();	}	voidV_Menu::SetEuroKey(int iNum,int ekey)	{	V_MenuItem *menuItem;		iNum--;	Get(iNum,&menuItem);	menuItem->SetEuroKey(ekey);	CleanUp();	}	void V_Menu::SetTitle(int iNum,strPtr str)	{	V_MenuItem *menuItem;		iNum--;	Get(iNum,&menuItem);	menuItem->SetName(str);		if(onOff)		{#if MACINTOSH		string name[256];		strcpy(name,str);		C2Pstr(name);		iNum=LocalToGlobalItem(iNum);		SetItem(menu,iNum+1,(StringPtr)name); // DAS-VWINDOWS-FIX 9/26/93#elif WINDOWS		char	mStr[256];		// jca 2 Nov 93 for fixing up menuitems		MakeMenuEntry(mStr, menuItem);	// jca 2 Nov 93 add the accelerators and what-not.		ModifyMenu(menu, LocalToGlobalItem(iNum), MF_BYPOSITION|MF_STRING,			BUILD_MENUID(mNum,LocalToGlobalItem(iNum+1)),mStr);  	// jca 2 Nov 93 (changed str to mStr, 0 to BUILD_MENUID)#endif //WINDOWS		}	CleanUp();	}void V_Menu::GetTitle(int iNum,strPtr str)	{	V_MenuItem *menuItem;		iNum--;	Get(iNum,&menuItem);	menuItem->GetName(str);		}voidV_Menu::Select(int iNum, int stte)	{	V_MenuItem *menuItem;		Get(iNum-1,&menuItem);	if(stte) menuItem->SetState(menuItem->GetState()|MENU_SELECT);	else menuItem->SetState(menuItem->GetState()&~MENU_SELECT);	if(onOff)#if MACINTOSH		CheckItem(menu,LocalToGlobalItem(iNum),stte);#elif WINDOWS		CheckMenuItem(menu,LocalToGlobalItem(iNum-1),			MF_BYPOSITION|(stte?MF_CHECKED:MF_UNCHECKED));#endif //WINDOWS	}void V_Menu::Activate(int iNum,int stte)	{	V_MenuItem *menuItem;		if(iNum)		{		Get(iNum-1,&menuItem);		if(stte) menuItem->SetState(menuItem->GetState()|MENU_ACTIVE);		else menuItem->SetState(menuItem->GetState()&~MENU_ACTIVE);		}			if(onOff)		{#if MACINTOSH		if(stte)EnableItem(menu,LocalToGlobalItem(iNum));		else DisableItem(menu,LocalToGlobalItem(iNum));#elif WINDOWS		EnableMenuItem(menu,LocalToGlobalItem(iNum-1),	    	MF_BYPOSITION|(stte?MF_ENABLED:MF_GRAYED));#endif //WINDOWS		}	}int V_Menu::GetState(int iNum)	{	V_MenuItem *menuItem;	Get(iNum-1,&menuItem);	return(menuItem->GetState() & MENU_SELECT);	}#include "VPane.h"int V_Menu::PopUp(V_Pane *pane,Point corner, int startItem)	{	long result;	int res;	MakeMenu(HEIRMENU);#if MACINTOSH	LocalToGlobal(&corner);	result=PopUpMenuSelect(menu,corner.v,corner.h,startItem);#elif WINDOWS{MSG msg;HWND hwnd;V_Document *doc;Rect	safetyRect;	// the mouse can come up here without disturbing the menuhwnd = pane->GetParentWindow();ClientToScreen(hwnd,(LPPOINT)&corner);doc= ActiveDocument();hwnd=doc->GetFrame();VSetRect(&safetyRect, corner.h-20, corner.v-10, corner.h+10, corner.v+10);	result = TrackPopupMenu(menu,TPM_LEFTALIGN | TPM_LEFTBUTTON,		corner.h,corner.v,		0,		hwnd, //owning window gets the menu select event		(Rect far*) &safetyRect);PostMessage(pane->GetParentWindow(), WM_LBUTTONUP, 0, MAKELONG(corner.h, corner.v));if(PeekMessage(&msg,hwnd,WM_COMMAND,WM_COMMAND,PM_NOYIELD|PM_REMOVE))	{	result = (!msg.lParam)?LOMENUID(msg.wParam):FALSE;	}else  // if nothing selected, return a null	result = 0;}#endif //WINDOWS	UnmakeMenu();	res=result&0x0FFFF;	return(res);	}int V_Menu::Width()	{	int width;#if MACINTOSH	width = (menu)?(*menu)->menuWidth:0;#elif WINDOWS	width = 0;#endif //WINDOWS	return width;	}	void V_Menu::VPreempt(void)	{	V_Menu	*hm;	V_MenuItem **menuItem;	int i;		menuItem = (V_MenuItem**)Use();	for(i=0;i<length;i++,menuItem++)		{		hm = (*menuItem)->GetHeir();		if(hm && hm!=DA_MENU && hm!=WINDOW_MENU)			hm->VPreempt();		}	Unuse();	Preempt();	if(linkTo && linkTo!=DA_MENU && linkTo!=WINDOW_MENU)		linkTo->VPreempt();	}void V_Menu::Preempt() { }void V_Menu::Action(int iNum,long modifier) { }intV_Menu::FindAccelerator(int k,long modifier)	{	V_MenuItem **menuItem;	V_Menu *hMenu;	int i,menuID;	int key;	long keyDef;	int ok;	menuID = 0;	menuItem = (V_MenuItem**)Use();	for(i=0;i<length;i++,menuItem++)		{		if (!((*menuItem)->GetState()&MENU_ACTIVE))	continue;  // jca 4APR94 skip inactive items		key=0x0FF&(keyDef = (*menuItem)->GetKey());		if(key)        	{			keyDef &= (altKeyPrefix|ctrlKeyPrefix|shiftKeyPrefix);			keyDef|=ctrlKeyPrefix;			ok=!(((keyDef&altKeyPrefix) ^ (modifier&altKeyPrefix))||				((keyDef&ctrlKeyPrefix) ^ (modifier&ctrlKeyPrefix))||				((keyDef&shiftKeyPrefix) ^ (modifier&shiftKeyPrefix)));			}		else if(keyDef == menuDelKey && k == menuDelKey)			{ok=TRUE; key=k;}		else ok=FALSE;		if(ok && key==k)#if MACINTOSH			menuID = mNum;#elif WINDOWS			menuID = GetMenuItemID(menu,LocalToGlobalItem(i));#endif //WINDOWS		else			{			hMenu = (*menuItem)->GetHeir();			if(hMenu) menuID=hMenu->FindAccelerator(k,modifier);			}		if(menuID) break;		}	Unuse();		if(!menuID)		{		if(linkTo)			{			if((linkTo!=DA_MENU)&&(linkTo!=WINDOW_MENU))				menuID = linkTo->FindAccelerator(k,modifier);#if WINDOWS			else if((linkTo==WINDOW_MENU && document) && document->theWindowMenu)				menuID=document->theWindowMenu->FindAccelerator(k,modifier);#endif //WINDOWS			}		}			return menuID;			}	void V_MenuMgr::cMenuMgr() { cArray(0,sizeof(struct V_Menu *),16); }void V_MenuMgr::dMenuMgr()	{	V_Menu **pMenu;	int i;		pMenu = (V_Menu**)Use();	for(i=0;i<length;i++,pMenu++)		(*pMenu)->manager=NULL;	Unuse();	dArray();	}int V_MenuMgr::Append(void * vM)	{	V_Menu *vMenu;	int ret;		vMenu=(V_Menu *)vM;	if(vMenu->manager)		vMenu->manager->Delete(&vM);	vMenu->manager=this;	ret=V_Array::Append(&vM);	if(ret>=0)	if(Visible())VSendMessage(CLEAN_MENUS);	return ret;	}int V_MenuMgr::Insert(long loc,void * vM)	{	V_Menu *vMenu;	int ret;		vMenu=(V_Menu *)vM;	if(vMenu->manager)		vMenu->manager->Delete(&vM);	vMenu->manager=this;	ret=V_Array::Insert(loc,&vM);		if(ret>=0)if(Visible())VSendMessage(CLEAN_MENUS);	return ret;		}int V_MenuMgr::Replace(void *oldvM,void * vM)	{	V_Menu *vMenu;	int ret,loc;		vMenu=(V_Menu *)vM;	vMenu->manager = this;	loc=Find(&oldvM);	ret=V_Array::Remove(loc);	ret=V_Array::Insert(loc,&vM);		if(ret>=0)if(Visible())VSendMessage(CLEAN_MENUS);	return ret;		}int V_MenuMgr::Put(long loc,void * vM)	{	V_Menu *vMenu;	int ret;		vMenu=(V_Menu *)vM;	vMenu->manager = this;	ret=V_Array::Put(loc,&vM);		if(ret>=0)if(Visible())VSendMessage(CLEAN_MENUS);	return ret;		}void V_MenuMgr::Delete(void *vM)	{	V_Menu *vMenu;	int loc;		vMenu=(V_Menu *)vM;	vMenu->manager=0;	loc=Find(&vM);	if(loc>=0)Remove(loc);		if(Visible())VSendMessage(CLEAN_MENUS);	}int V_MenuMgr::Visible(void)	{//JAM 9/21/94 WINDOWS should have no visible menu manager, since//each document has its own menu bar.  This hack seems to solve//the problems caused by still having the menu bar, but the menu//manager stuff needs to be examined.#if WINDOWS	return FALSE;#elif MACINTOSH	V_Menu *aM;	V_Menu **vM;	int i,j,result;	result = FALSE;	vM=(V_Menu **)Use();	for(i=0;i<visibleMMgr->ALength();i++) 		{		visibleMMgr->Get(i,&aM);   		for(j=0;j<length;j++)			{			result = (aM==vM[j]) ? TRUE : FALSE;		if(result)break;        			}		if(result)break;		}	Unuse();	return result;#endif	}void MenuArray::SetMenuDocument(V_Document *doc) { menuDocument = doc; }V_Document *MenuArray::GetMenuDocument(void) { return menuDocument; }intMenuArray::FindAccelerator(int k,long modifier)	{	V_Menu **vMenu;	int i,menuID;		menuID = 0;	vMenu = (V_Menu**)Use();	for(i=0;i<length;i++,vMenu++)		{		(*vMenu)->VPreempt();   // jca 4APR94 preempt the menu, so we won't select inactive items		if(menuID=(*vMenu)->FindAccelerator(k,modifier)) break;        }	Unuse();		return menuID;	}int MenuArray::Compare(void *data1, void *data2)	{	V_Menu *m1=*(V_Menu **)data1;	V_Menu *m2=*(V_Menu **)data2;		if(m1->priority < m2->priority)return -1;	if(m1->priority > m2->priority)return 1;	return 0;	}void CleanMenus(void)	{	V_Window *activeWindow;	V_Document *activeDocument;#if MACINTOSH	WindowPeek	whichWindow;#endif //MACINTOSH		VSetCursor(vCursorArrow);#if WINDOWS	activeWindow = TopWindow(NULL);		if(activeWindow)		{		if(activeWindow->theDocument)			activeWindow->theDocument->MenuDisplay();		else if(theSuper->ALength()>=1)			{			theSuper->Get(0,&activeDocument);			activeDocument->MenuDisplay();			}		}	else 		{#if VWT  // jca 3 Nov 93 {		if(NULL != stub) //DUDE PORT			{			stub->React(activeWindow,ACTIVATE);			stub->MenuDisplay();			}#elif VR		activeDocument = ActiveDocument();	 // get the active doc (or the stub, if it's active)		if(NULL != activeDocument) 			{			activeDocument->React(NULL,ACTIVATE); 	// we know activeWindow is NULL			activeDocument->MenuDisplay();			}#endif // VWT	// jca 3 Nov 93 }		}#elif MACINTOSHwhichWindow = (WindowPeek)MyFrontWindow();if (whichWindow)	{	activeWindow=(V_Window*)GetWRefCon((WindowPtr)whichWindow);	if (activeWindow->theDocument)		activeWindow->theDocument->MenuDisplay();	else if (theSuper->ALength()>=1)		{		theSuper->Get(0,&activeDocument);		activeDocument->MenuDisplay();		}	}else	{	stub->React(NULL,ACTIVATE);	stub->MenuDisplay();	}#endif //WINDOWS	}void V_WindowMenu::ctheMenu(V_Document *doc)	{	theDocument=doc;	cMenu(TXTM_WINDOWS,doc);    SetMenuEuroKey(menuWindowEuroKey);	}void V_WindowMenu::Action(int iNum,long mask)	{	V_Window *win;	int loc=0,i,len;	V_Document *doc=theDocument;	/*how many window items?*/	len=0;#if VWT	for(i=0;i<doc->windows->ALength();i++)		{		doc->windows->Get(i,&win);		if(	win->Visible() && IN_MENU(win->wType))len++;		}	if(len==1)len=0;/*only one window, so don't bother here*/	iNum--;         /*this uses a base of 1 and I want a base of zero*/	if(state)iNum--;/*the true index into the V_Array, state says there is a line seperator*/	if(len>1 && iNum<len)		{		for(i=0;i<doc->windows->ALength();i++)			{			doc->windows->Get(i,&win);			if(win->Visible() && IN_MENU(win->wType))					{					if(loc==iNum)						{						if(win!=TopWindow(doc))							doc->Activate(win);						return;						}					loc++;					}			}		}	else 		{		if(len)iNum-=(len+1);/*drop off the window items and the bar between*/				if(theSuper->ALength()>1)			{			theSuper->Get(iNum,&doc);			if(doc!=theDocument)doc->Activate(NULL);			}		return;			}#endif //VWT	}