/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				 *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Platform: 	MACINTOSH 	X *				WINDOWS		 * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VDisplay.h"#include "VGUtil.h"#include "VGraphic.h"#include "VDisplay.h"#include "VArray.h"#include "VMemUtil.h"#include "VMain.h"#include "VPane.h"#if MACINTOSH#include <QDOffscreen.h>#include <Picker.h>#endif //MACINTOSHvoid C2Pstr(strPtr str)	{	strPtr	data;	int i,length;		length = strlen(str);	data = str;		i = length;	while(i)		{		str[i]=data[i-1];		i--;		}	str[0]=length;	}void P2Cstr(strPtr str)	{	strPtr	data;	int i,length;		length = (unsigned char)str[0];	data = str;	for(i=0; i<length;i++)		str[i]=data[i+1];		str[length] = 0;	}int VCancel()	{	int cancel=FALSE;	char ch;#if MACINTOSH	EventRecord event;#ifndef __powerc	if(GetEvQHdr()->qHead != NULL)// DAS-VWINDOWS-LIZARD KING 10/2/93#endif //__powerc	if(EventAvail(keyDownMask, &event))		{		ch = (event.message & charCodeMask);		/* <ESC> or Command-. */		cancel = (ch == V_ESCAPE || (ch == V_PERIOD && (event.modifiers & V_COMMAND))) ? TRUE : FALSE;		VFlushEvents(keyDownMask|keyUpMask|autoKeyMask);		}	else		cancel = FALSE;#endif //MACINTOSH	return cancel;	}intVEventWaiting(int flags)	{	int waiting;	#if MACINTOSH	EventRecord event;	waiting = EventAvail(flags,&event);#elif WINDOWS	DWORD result;	int types;/*  Danger: GetQueueStatus does not always return correct info.	It may return info on events that get processed by the	message retrievers, not the application.  You must use	GetMessage or PeekMessage to get the true state */	result = GetQueueStatus(flags);	waiting = LOWORD(result);	types = HIWORD(result);//	return waiting|types;/* 	Thank you for playing.	This routine needs reworking	in a major way, but now is not the time (29 April 93 -- 7 days	before shipping -- jca).  What it should have is something	like:	MSG msg;	int messageCode;	if (flags & mDownMask)		messageCode = WM_LBUTTONDOWN;	if (!PeekMessage(&msg, messageCode, messageCode, PM_NOYIELD|PM_NOREMOVE))	   waiting = 0;	but much more comprehensive.  For example, it should loop	over all the possible mouse down events, no just the left	button.	*/ #endif //WINDOWS	return waiting;	}void VFlushEvents(int flags)	{#if MACINTOSH	FlushEvents(flags,0);#elif WINDOWS	MSG msg;	int waiting;	waiting = TRUE;	while(waiting)    	{		waiting = PeekMessage(&msg,NULL,WM_KEYFIRST,WM_KEYLAST,PM_REMOVE);		waiting = waiting && PeekMessage(&msg,NULL,WM_MOUSEFIRST,WM_MOUSELAST,PM_REMOVE);		}#endif //WINDOWS	}#if WINDOWSintVButton()	{	int result;	result = FALSE;	return result;    }int VPtInRect(Point p,Rect *r)	{	POINT pt;	int result;	pt.x = p.h;	pt.y = p.v;	result = PtInRect(r,pt);    return result;	}voidLocalToGlobal(Point *p)	{	HWND hwnd;	hwnd = (currentPane)?currentPane->paneWindow:NULL;	ClientToScreen(hwnd,(LPPOINT)p);	}voidGlobalToLocal(Point *p)	{	HWND hwnd;	hwnd = (currentPane)?currentPane->paneWindow:NULL;	ScreenToClient(hwnd,(LPPOINT)p);	}void VLocalToGlobalRect(Rect *r)   // jca 28 Sept 93	{	Point pmin, pmax;	HWND hwnd;	hwnd = (currentPane)?currentPane->paneWindow:NULL;	pmin.h = r->left;	pmin.v = r->top;	pmax.h = r->right;	pmax.v = r->bottom;	ClientToScreen(hwnd,(LPPOINT)&pmin);	ClientToScreen(hwnd,(LPPOINT)&pmax);	r->left = pmin.h;	r->top = pmin.v;	r->right = pmax.h;    r->bottom = pmax.v;    }long GetMSGModifiers(void)		   // BG 11/4/93	{	long	modifier = 0L;	if (GetKeyState(VK_LBUTTON)& 0x8000)		modifier |= buttonDown;	if ((GetKeyState(VK_RBUTTON)& 0x8000)||(GetKeyState(VK_CONTROL)& 0x8000))		modifier |= V_OPTION;	if (GetKeyState(VK_SHIFT)& 0x8000)		modifier |= V_SHIFT;	if (GetKeyState(VK_MENU)& 0x8000)		modifier |= V_COMMAND;   	return(modifier);	// jca 10JAN93 wasn't returning anything...	}#endif //WINDOWSint VScrollWidth(void){#if MACINTOSH	return 16;#elif WINDOWS	return 1+GetSystemMetrics(SM_CYVTHUMB);#endif}int VTitleBarHeight(void)	{#if MACINTOSH	return 16;#elif WINDOWS	return GetSystemMetrics(SM_CYCAPTION);#endif //WINDOWS	}voidGetScreen(Rect *r)	{	VGrafDevice aDevice;#if MACINTOSH	if(colorQD)		{		aDevice=GetMainDevice();		*r = (**aDevice).gdRect;		}	else		*r=screenBits.bounds;#endif //MACINTOSH#if WINDOWS	aDevice = VGetDC(NULL);	r->left=0;	r->top=0;	r->right=GetDeviceCaps(aDevice,HORZRES);	r->bottom=GetDeviceCaps(aDevice,VERTRES);	ReleaseDC(NULL,aDevice);#endif //WINDOWS	}voidGetLimitedScreen(Rect *r)	{	GetScreen(r);	if(r->right-r->left>640)r->right=r->left+640;	if(r->bottom-r->top>480)r->bottom=r->top+480;	}/*------------------------------------------------------------------------------ * int MainDepth() * This function determines the pixel depth of the main screen.  If we do * not have Color Quickdraw the function returns 0. * * int FindDepth() * This function determines the pixel depth of thePort. *------------------------------------------------------------------------------*/int MainDepth()	{	VGrafDevice GDH;	int depth;		if(!colorQD)return(0);#if MACINTOSH	GDH=GetMainDevice();	depth = (int)(*(*GDH)->gdPMap)->pixelSize;	#elif WINDOWS	depth=currentDepth;#endif //WINDOWS		return depth;	}intFindDepth()	{#if MACINTOSH		if(!colorQD)return(0);	if(thePort->portBits.rowBytes & 0xC000)		{		CGrafPtr CGP;		/*we have a CGrafPort*/		CGP= (CGrafPtr)thePort;		return((*CGP->portPixMap)->pixelSize);		}	else return 0;#elif WINDOWS	return currentDepth;#endif //WINDOWS	}/*------------------------------------------------------------------------------ * void ZoomToRect(Rect *rFrom,Rect *rTo) *------------------------------------------------------------------------------*/void ZoomToRect(int zNum, Rect *rFrom, Rect *rTo)	{	V_Offscreen *scrn;	Rect r,oldR;	long i;#if WINDOWS	HDC hdc;#endif //WINDOWS	scrn=new(V_Offscreen);#if WINDOWS	hdc = VGetDC(NULL);	scrn->cScreen(hdc);    ReleaseDC(NULL,hdc);#endif //WINDOWS	scrn->SetMetaPort();	VPenMode(vPatXor);	VSetPattern(vPatGray);	oldR=*rFrom;	VFrameRect(&oldR);		for(i=0;i<zNum;i++)		{		r.top=rFrom->top+(i*(rTo->top-rFrom->top))/zNum;		r.left=rFrom->left+(i*(rTo->left-rFrom->left))/zNum;		r.right=rFrom->right+(i*(rTo->right-rFrom->right))/zNum;		r.bottom=rFrom->bottom+(i*(rTo->bottom-rFrom->bottom))/zNum;		VFrameRect(&oldR);		oldR=r;		VFrameRect(&r);		}	VFrameRect(&oldR);	VPenMode(vPatCopy);	VSetPattern(vPatBlack);	scrn->dOffscreen();}/*------------------------------------------------------------------------------ * DAS-VFIX-COMMENT 9/3/93 * void DrawMarquee(int move) * First call DrawMarquee(TRUE) * draw the object * start: * If the object has not moved  *		DrawMarquee(FALSE) *		Draw the old object * else if the object has moved *		DrawMarquee(TRUE); *		Draw the old object to erase *		Draw the new object to draw * goto start * to complete *		DrawMarquee TRUE *		draw the object to erase *------------------------------------------------------------------------------*/unsigned char grayPat[]={0x0F,0x1E,0x3C,0x78,0xF0,0xE1,0xC3,0x87,						 0x0F,0x1E,0x3C,0x78,0xF0,0xE1,0xC3,0x87};unsigned char movePat[]={0x11,0x22,0x44,0x88,0x11,0x22,0x44,0x88,						 0x11,0x22,0x44,0x88,0x11,0x22,0x44,0x88};int counter=0;int grayNum=0;#if WINDOWStypedef struct { unsigned char pat[8]; }Pattern;#endifextern void VSetPenStyle(int);void DrawMarquee(int move)	{	Pattern pattern;	int i;	#if MACINTOSH	if(!move)		{		for(i=0;i<8;i++)pattern.pat[i]=movePat[grayNum+i];		grayNum++;		if(grayNum==8)grayNum=0;		}	else  for(i=0;i<8;i++)pattern.pat[i]=grayPat[grayNum+i];	PenPat(&pattern);	VPenMode(vPatXor);#elif WINDOWS	VForeColor(&vBlack);	// DAS 11/10/93 set the forecolor in case someone else hasn't. (jca does this need to be mac'd?)	if(!move)grayNum=!grayNum;	VPenMode(move?vMarqueeMove:vMarqueeStay);#endif //WINDOWS	}void DrawMarquee2(int move)	{	Pattern pattern;	int i;		if(!move)		{		for(i=0;i<8;i++)pattern.pat[i]=grayPat[grayNum+i];		grayNum++;		if(grayNum==8)grayNum=0;		}	else  for(i=0;i<8;i++)pattern.pat[i]=movePat[grayNum+i];#if MACINTOSH	PenPat(&pattern);#endif //MACINTOSH	VPenMode(vPatXor);	}#if WINDOWS//On Windows, Dotted lines and solid lines draw on slightly different//pixels, so this hack is necessary to avoid pixel dribbleintMarqueeIsOdd(){	return(grayNum);}#endif/*------------------------------------------------------------------------------ * void BuildScreens() *------------------------------------------------------------------------------*/void BuildScreens()	{	V_Offscreen 	*scrn;	VGrafDevice	aDevice;	int iCountScreens = 0;	screen=new(V_Array);	screen->cArray(0,sizeof(V_Offscreen *),1);/*blocksize of one, that might be all there is*/	if(!MainDepth())/* color quickdraw not available? */		{		scrn=new(V_Offscreen);		scrn->cScreen(NULL);		scrn->InitColor();		screen->Append(&scrn);        iCountScreens++;		}	else		{		VGetPort(&mainPort,&mainDevice);#if WINDOWS		mainDevice=VGetDC(NULL);#elif MACINTOSH		mainDevice=GetMainDevice();#endif //WINDOWS		scrn=new(V_Offscreen);		scrn->cScreen(mainDevice);        scrn->InitColor();#if WINDOWS		ReleaseDC(NULL,mainDevice);#endif //WINDOWS		screen->Append(&scrn);		iCountScreens++;		/* Loop through all of the devices, seeing if we intersect each one.*/#if MACINTOSH		aDevice = GetDeviceList();		while (aDevice)			{			if (aDevice != mainDevice)				{				scrn=new(V_Offscreen);				scrn->cScreen(aDevice);//#if WINDOWS				scrn->InitColor();//#endif //WINDOWS				screen->Append(&scrn);				iCountScreens++;				}	   	 	aDevice = GetNextDevice(aDevice);			}#endif //MACINTOSH		}//BILBIL -  screen->SetLength(iCountScreens);	}/*------------------------------------------------------------------------------ * void RebuildScreens() * This is to reset the screens if the color depth is changed. *------------------------------------------------------------------------------*/void RebuildScreens()	{	V_Offscreen 	*scrn;	int i;		for(i=0;i<screen->ALength();i++)		{		screen->Get(i,&scrn);		if(scrn->bitDepth!=scrn->GetDepth() || scrn->ColorsRemapped())			{			scrn->bitDepth=scrn->GetDepth();			scrn->InitColor();			}		}	}/*------------------------------------------------------------------------------ * V_Offscreen * * VGetFirstScreen() * * Find the first screen.  *------------------------------------------------------------------------------*/V_Offscreen *VGetFirstScreen()	{	V_Offscreen **scrn;	V_Offscreen *hFirstScreen;	int nScreens, i,num=-1;	hFirstScreen = NULL;	if (!screen) return (hFirstScreen);		// BUG! let it exit gracefully.	nScreens = screen->ALength();	if (nScreens > 0)		{		scrn=(V_Offscreen **)screen->Use();		hFirstScreen = scrn[0];		screen->Unuse();		}	return(hFirstScreen);	}	/*------------------------------------------------------------------------------ * V_Offscreen * * VGetNextScreen(V_Offscreen * hThisScreen) * * Find the next available screen.  *------------------------------------------------------------------------------*/V_Offscreen *VGetNextScreen(V_Offscreen * hThisScreen)	{	V_Offscreen **scrn;	int nScreens, i,num=-1;	nScreens = screen->ALength();		scrn=(V_Offscreen **)screen->Use();	for(i=nScreens-1;i>= 0;i--)		// search backwards forces a finish despite bad duplicates		{		if(hThisScreen == scrn[i])			{			num=i;			break;			}		}	screen->Unuse();	if(num==-1)return NULL;					// BUG! let it exit gracefully.    if(num+1 >= nScreens) return NULL;		// if no more left, say so	else return(scrn[num+1]);	}	/*------------------------------------------------------------------------------ * int RectDepth(Rect *globalRect) * * Find the color depth of the globalRect rectangle. If it is overlapping * multiple screens it takes the maximum depth value.  * DAS-CHANGE TO BE CONSISTENT 9/13/93 *------------------------------------------------------------------------------*/int RectDepth(Rect *globalRect)	{	int				depth=-1;	Rect	      	aRect;	Rect	      	workRect;	VGrafDevice		aDevice;	if(!colorQD)return(FALSE);/* color quickdraw not available? */	/* Loop through all of the devices, seeing if we intersect each one.*/#if MACINTOSH	aDevice = GetDeviceList();	while (aDevice)		{		aRect = (**aDevice).gdRect;		if (aDevice == GetMainDevice())	/* Exclude menu bar from drawable area*/			aRect.top += GetMBarHeight();		/* Adjust size of working rectangle*/		if (SectRect(&aRect, globalRect, &workRect)) 			if(depth<(**(**aDevice).gdPMap).pixelSize)	   				depth=(**(**aDevice).gdPMap).pixelSize;	    aDevice = GetNextDevice(aDevice);		}#elif WINDOWS	depth = currentDepth;#endif //WINDOWS	return depth;	}/*------------------------------------------------------------------------------ * V_Offscreen * * FindScreen(Point p) * * Find the screen that this point is in.  *------------------------------------------------------------------------------*/V_Offscreen *FindScreen(Point p)	{	V_Offscreen **scrn;	int nScreens, i,num=-1;	Rect r;		/* Loop through all of the devices, seeing if we intersect each one.*/	nScreens = screen->ALength();		scrn=(V_Offscreen **)screen->Use();	for(i=0;i<nScreens;i++)		{		scrn[i]->GetRect(&r);		if(VPtInRect(p,&r))			{			num=i;			break;			}		}	screen->Unuse();	if(num==-1)return 0;	else return(scrn[num]);	}	/*------------------------------------------------------------------------------ * V_Offscreen * * FindScreenR(Rect *rect) * * Find the screen that this rectangle overlaps that has the greatest depth.  * DAS-VWINDOWS-BUGFIX /13/93 *------------------------------------------------------------------------------*/V_Offscreen *FindScreenR(Rect *rect)	{	V_Offscreen *s;	V_Offscreen *bigScreen = NULL;		// Prepare for no screens yet	long area, bigArea = -1;	int nScreens, i;	int depth=-1;	Rect r;		// MERGE-GOURAUD-PRO-7 HACK!!!!	// we need to fix up this rect if it is empty	if (rect->top == rect->bottom)		rect->bottom++;	else if (rect->left == rect->right)		rect->right++;	if (screen){	nScreens = screen->ALength();	for (i = 0; i < nScreens; i++)		{		screen->Get(i, &s);		s->GetRect(&r);#if MACINTOSH		if(SectRect(rect, &r, &r))			if(depth<s->GetDepth())				{				bigScreen=s;				depth=s->GetDepth();				}#elif WINDOWS		area = (long)(r.right-r.left) * (r.bottom-r.top);		if (area > bigArea)			{			bigArea = area;			bigScreen = s;			}#endif		}}	return(bigScreen);	}/*------------------------------------------------------------------------------ * int * OverlapScreenR(Rect *rect) * * Determine if this rectangle overlaps more than one screen.  * DAS-VWINDOWS-NEW 9/13/93 *------------------------------------------------------------------------------*/intOverlapScreenR(Rect *rect)	{	V_Offscreen *s;	int nScreens=0,i;	Rect r;		if (screen)	{	nScreens = screen->ALength();	for (i = 0; i < nScreens; i++)		{		screen->Get(i, &s);		s->GetRect(&r);#if MACINTOSH		if(SectRect(rect, &r, &r))nScreens++;#endif		}	}	return(nScreens);	}	/*------------------------------------------------------------------------------ * void FitRect(Rect *in,Rect *out); * * Force Rect in to be completely inside of Rect out. *------------------------------------------------------------------------------*/void FitRect(Rect *in,Rect *out)	{	int offset;		if(in->top<out->top)		{		offset=(out->top-in->top);		in->bottom+=offset;		in->top += 	offset;		}	if(in->bottom>out->bottom)		{		offset=(in->bottom-out->bottom);			in->top-=	offset;		in->bottom-=offset;		}	if(in->left<out->left)		{		offset=(out->left-in->left);		in->left+=offset;		in->right+=offset;		}	if(in->right>out->right)		{		offset=(in->right-out->right);		in->left-=offset;		in->right-=offset;		}	}/*------------------------------------------------------------------------------ * void FitAvoidRect(Rect *in,Rect *out, Rect *avoid); * * Force Rect in to be completely inside of Rect out, without * intersecting Rect avoid.  jca *------------------------------------------------------------------------------*/void FitAvoidRect(Rect *in,Rect *out,Rect *avoid)	{	int offset, h,v;    Rect  effRect;	h = in->right - in->left;	v = out->right - out->left;	if (out->right - avoid->right+1 > h)		{  // this is the desired case.  stick it off to the right		effRect = *out;		effRect.left = avoid->right+1;        FitRect(in, &effRect);		}	else if (avoid->left-1 - out->left > h)		{  // this is the almost desired case.  stick it off to the left		effRect = *out;		effRect.right = avoid->left-1;        FitRect(in, &effRect);		}	else if (out->bottom - avoid->bottom+1 > v)		{  // this is the next-to-almost-desired case.  stick it off to the bottom		effRect = *out;		effRect.top = avoid->bottom+1;        FitRect(in, &effRect);		}	else if (avoid->top-1 - out->top > v)		{  // this is the next-to-least desired case.  stick it off to the top		effRect = *out;		effRect.bottom = avoid->top-1;        FitRect(in, &effRect);		}	else		{   // least desired case        FitRect(in, out);        }	}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/#define COLOR_WIDTH 410#define COLOR_HEIGHT 290#if WINDOWSBOOL CALLBACK _exportEnumWindowsProc(HWND,LPARAM);#endif// { DAS-VWINDOWS-FIX 9/29/93 fix the color palette problem#if MACINTOSH#include <Palettes.h>#endif// } DAS-VWINDOWS-FIX 9/29/93 fix the color palette problemint VColorWheel(strPtr str,RGBColor *color)	{ 	V_Offscreen *scrn;	Rect r;	Point pt;	char title[256];	int i,mx,mx1,val;		/*first find the maximum depth screen*/	if(!colorQD)return FALSE;		mx=mx1=0;	for(i=0;i<screen->ALength();i++)		{		screen->Get(i,&scrn);		if(scrn->GetDepth()>mx){mx=scrn->GetDepth();mx1=i;}		}	screen->Get(mx1,&scrn);	scrn->GetRect(&r);	pt.h=(r.right+r.left-COLOR_WIDTH)>>1;	pt.v=(r.bottom+r.top-COLOR_HEIGHT)>>1;	/*do we have color quickdraw here?*/	if(scrn->GetDepth()==0)return 0;/*no we do not*/	/*yes we do*/	strcpy(title,str);#if MACINTOSH	C2Pstr(title);	val= GetColor(pt,(ConstStr255Param)title,color,color);// { DAS-VWINDOWS-FIX 9/29/93 fix the color palette problem	RestoreDeviceClut(NULL );	PaintBehind( nil, GetGrayRgn() );//	CleanMenus();// } DAS-VWINDOWS-FIX 9/29/93 fix the color palette problem#elif WINDOWS	{	CHOOSECOLOR cc;	COLORREF	clr,clrCust[16];	int i;	for(i=0;i<16;i++)		clrCust[i]=RGB(255,255,255);	clr = RGB(color->red>>8,color->green>>8,color->blue>>8);	memset(&cc,0,sizeof(CHOOSECOLOR));	cc.lStructSize=sizeof(CHOOSECOLOR);	cc.hwndOwner = GetMainFrameWindow(); // this may be slightly naughty...  But otherwise we must include VDocumnt.h	cc.rgbResult = clr;	cc.lpCustColors=clrCust;	cc.Flags=CC_RGBINIT|CC_FULLOPEN;		{		FARPROC proc;		proc = MakeProcInstance((FARPROC)EnumWindowsProc,GetAppInstance());		EnumTaskWindows(GetCurrentTask(),proc,MAKELPARAM(0x0,FALSE));		FreeProcInstance(proc);        }	val = ChooseColor(&cc);   		{		FARPROC proc;		proc = MakeProcInstance((FARPROC)EnumWindowsProc,GetAppInstance());		EnumTaskWindows(GetCurrentTask(),proc,MAKELPARAM(0x0,TRUE));		FreeProcInstance(proc);        }	if(val)		{		color->red=GetRValue(cc.rgbResult)<<8;		color->green=GetGValue(cc.rgbResult)<<8;		color->blue=GetBValue(cc.rgbResult)<<8;		}    }#endif //WINDOWS	return val;		}