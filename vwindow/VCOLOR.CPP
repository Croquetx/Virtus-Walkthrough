/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File: Color.c * Platform: 	MACINTOSH 		 *				WINDOWS		X	GJR	(extracted from vgraphic and vdisplay) * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VColor.h"#include "VDisplay.h"#include "VGraphic.h"#include "VGUtil.h"#include "VArray.h"#if WINDOWS               		// MERGE-VSHA#include "TextSrvr.h"         // MERGE-VSHA#endif                        // MERGE-VSHA#include <math.h>V_Array *gColorTable = NULL;//#define PALETTE_SIZE	(6*6*6+16) // rgb plus 16 monochromes#if MACINTOSH#define ColorizedByMicrosoft 0#define ColorizedByApple 1#elif WINDOWS#define ColorizedByMicrosoft 1#define ColorizedByApple 0#endif	// MACINTOSH#define GRAY_INC 0x1111#define COLOR_INC 0x3333int gray_vals[16]=	{       0x1010,0x2020,0x3030,					 0x4040,0x5050,0x6060,0x7070,					 0x8080,0x9090,0xa0a0,0xb0b0,					 0xc0c0,0xd0d0,0xe0e0,0xf0f0,					 0xffff};int color_vals[6]=	{0x0000,0x4000,0x8000,0xc000,0xe000,0xffffff};void ReleasePalette(void);#if WINDOWS/*------------------------------------------------------------------------------ *  InitPalette(HINSTANCE hInst) *------------------------------------------------------------------------------*/intInitPalette(HINSTANCE hInst)	{	HPALETTE oldPal;	NPLOGPALETTE pPal;	HDC hDC,cDC;	HBITMAP hBitmap,oldBitmap;    BYTE red,green,blue;	int depth,numColors,i,j,sat,satIncrease;	int count,size;	int iNumChanges = 0;	RGBColor *colors;RGBColor col,c;int gray,val,entry,g,r,b;#if 0	currentPalette = NULL;	return;#endif	if (!gColorTable) MakeStandardColorTable();	colors=(RGBColor *)gColorTable->Abuse();	numColors = gColorTable->ALength();	depth=MainDepth();	/* numColors = 1<<depth; *///    numColors=PALETTE_SIZE;		// restrict to declared vertices of color 'cube'	pPal = (NPLOGPALETTE)LocalAlloc(LMEM_FIXED,sizeof(LOGPALETTE)+    	(numColors*sizeof(PALETTEENTRY)));	pPal->palNumEntries=numColors;	pPal->palVersion=0x300;	for(i=0;i<numColors;i++)    	{		pPal->palPalEntry[i].peFlags=0;		pPal->palPalEntry[i].peRed=0;		pPal->palPalEntry[i].peGreen=0;		pPal->palPalEntry[i].peBlue=0;		}#if ColorizedByApple	gray = 0;	for (entry=0; entry<10; entry++)		{  // match system colors		pPal->palPalEntry[entry].peRed = LOBYTE(entry);		pPal->palPalEntry[entry].peGreen = HIBYTE(entry);		pPal->palPalEntry[entry].peBlue = 0;		pPal->palPalEntry[entry].peFlags = PC_EXPLICIT;        }	for( ; entry<22;entry++)		{		gray += GRAY_INC;        val = (unsigned)gray>>8;		pPal->palPalEntry[entry].peRed = val;		pPal->palPalEntry[entry].peGreen = val;		pPal->palPalEntry[entry].peBlue = val;		}	col.green = c.green = 0;	for(g=0;g<6;g++)    	{		col.red = c.red = 0;		for(r=0;r<6;r++)			{			col.blue = c.blue = 0;			for(b=0;b<6;b++,entry++)				{				pPal->palPalEntry[entry].peRed = c.red;				pPal->palPalEntry[entry].peGreen = c.green;				pPal->palPalEntry[entry].peBlue = c.blue;				col.blue+=COLOR_INC;                c.blue=col.blue;//>>8;				}			col.red+=COLOR_INC;            c.red=col.red>>8;			}		col.green+=COLOR_INC;		c.green=col.green>>8;		}#endif //ColorizedByApple#if ColorizedByMicrosoft	entry = 0;	for (entry = 0; entry < numColors; entry++)		{		col.green = colors[entry].green;        c.green = (unsigned)col.green>>8;		col.red = colors[entry].red;        c.red = (unsigned)col.red>>8;		col.blue = colors[entry].blue;        c.blue = (unsigned)col.blue>>8;		pPal->palPalEntry[entry].peRed = c.red;		pPal->palPalEntry[entry].peGreen = c.green;		pPal->palPalEntry[entry].peBlue = c.blue;        }#if 0	for( entry=0; entry<16;entry++)		{		gray = gray_vals[entry];        val = (unsigned)gray>>8;		pPal->palPalEntry[entry].peRed = val;		pPal->palPalEntry[entry].peGreen = val;		pPal->palPalEntry[entry].peBlue = val;		}	for(g=0;g<6;g++)    	{		col.green = color_vals[g];        c.green = (unsigned)col.green>>8;		for(r=0;r<6;r++)			{			col.red = color_vals[r];            c.red = (unsigned)col.red>>8;			for(b=0;b<6;b++,entry++)				{				col.blue = color_vals[b];                c.blue = (unsigned)col.blue>>8;				pPal->palPalEntry[entry].peRed = c.red;				pPal->palPalEntry[entry].peGreen = c.green;				pPal->palPalEntry[entry].peBlue = c.blue;				}			}		}#endif  //0#endif  // ColorizedByMicrosoft	currentPalette = CreatePalette(pPal);	LocalFree((HANDLE)pPal);	if (currentPalette)    	{ // then we got a palette to work with		hDC = VGetDC(NULL);		oldPal = SelectPalette(hDC,currentPalette,FALSE);		iNumChanges = RealizePalette(hDC);		SelectPalette(hDC,oldPal,TRUE);  // release our new palette		ReleaseDC(NULL,hDC);		}    gColorTable->Unuse();	return (iNumChanges);	}/*------------------------------------------------------------------------------ *  ReInitPalette(HWND hwnd) *					returns 0 if no changes occurred *					returns !0 if changes occurred *------------------------------------------------------------------------------*/intReInitPalette(HWND hwnd)	{	HPALETTE oldPal;	HDC hDC;	int iNumChanges = 0;	if (currentPalette)    	{		hDC = VGetDC(hwnd);		oldPal = SelectPalette(hDC,currentPalette,FALSE);		iNumChanges = RealizePalette(hDC);//	Can't redo dither yet, cuz palette isn't really updated yet//  Must wait for wm_palettechanged message.//		if (iNumChanges)//			{		// then color locations may have changed also//			ReInitDither();//			}		SelectPalette(hDC,oldPal,TRUE);  // release our new palette		ReleaseDC(hwnd,hDC);		}	return (iNumChanges);	}#endif //WINDOWS/*------------------------------------------------------------------------------ *  void ReleasePalette() *------------------------------------------------------------------------------*/voidReleasePalette()	{#if WINDOWS	if (currentPalette)    	{ // then we have a palette to remove		DeleteObject(currentPalette);		}	if (gColorTable)	gColorTable->dArray();   // jca 17 Dec 93#endif //WINDOWS	}/*------------------------------------------------------------------------------ *  int ColorsRemapped() *------------------------------------------------------------------------------*/intV_Offscreen::ColorsRemapped()	{	int			ret = FALSE;#if MACINTOSH	CTabPtr		ourCTable;	if (bitType == COLOR_QD)		{		ourCTable = UseColorTable();		if (ourCTable)			{			if (ctSeed != ourCTable->ctSeed)				ret = TRUE;			UnuseColorTable();			}		}#endif //MACINTOSH	return ret;	}/*------------------------------------------------------------------------------ * void V_Offscreen::InitColor(void) *------------------------------------------------------------------------------*/voidV_Offscreen::InitColor(void){// Init all to Not Working Yet	ditherTable = NULL;	colorTable  = NULL;	vaFRedColor    = NULL;	vaFGreenColor  = NULL;	vaFBlueColor   = NULL;// Now try to get something useful in here	BuildDither();}#ifdef gjrTryLuv/*------------------------------------------------------------------------------ * int V_Offscreen::RGB2Luv(void) *------------------------------------------------------------------------------*/float faRGB2X[3] = { .4,.4,.2};float faRGB2Y[3] = { .2,.7,.1};float faRGB2Z[3] = { .0,.1,.9};// formula for converting xyz to u' and v'// add an epsilon to the denominator to avoid div by 0#define XYZ2UP(x,y,z) ( 4*(x) / ((x)+15*(y)+3*(z)+1e-6) )#define XYZ2VP(x,y,z) ( 9*(y) / ((x)+15*(y)+3*(z)+1e-6) )#define RGB2X(r,g,b) ( (r)*faRGB2X[0] + (g)*faRGB2X[1] + (b)*faRGB2X[2] )#define RGB2Y(r,g,b) ( (r)*faRGB2Y[0] + (g)*faRGB2Y[1] + (b)*faRGB2Y[2] )#define RGB2Z(r,g,b) ( (r)*faRGB2Z[0] + (g)*faRGB2Z[1] + (b)*faRGB2Z[2] )float fLStar, fUStar, fVStar;voidRGB2LUV(float fINRed, float fINGreen, float fINBlue){float fXWhite, fYWhite, fZWhite;float fUWhite, fVWhite;float fX,fY,fZ;float fUPrime, fVPrime;// Calc the reference whitefXWhite = RGB2X(1.,1.,1.);fYWhite = RGB2Y(1.,1.,1.);fZWhite = RGB2Z(1.,1.,1.);fUWhite = XYZ2UP(fXWhite, fYWhite, fZWhite);fVWhite = XYZ2VP(fXWhite, fYWhite, fZWhite);// Change input to xyz spacefX = RGB2X(fINRed, fINGreen, fINBlue);fY = RGB2Y(fINRed, fINGreen, fINBlue);fZ = RGB2Z(fINRed, fINGreen, fINBlue);// Caution: the input RGB may be outside the 0..1 range// (due to dither error correcting terms)// So clamp XYZ at zero to keep equations sane.// High values appear to be ok for comparisons.fX = max(fX, 0.);fY = max(fY, 0.);fZ = max(fZ, 0.);fUPrime = XYZ2UP(fX, fY, fZ);fVPrime = XYZ2VP(fX,fY, fZ);fLStar = max(0.,116. * pow(fY/fYWhite, 1./3.) - 16.);fUStar = 13.*fLStar*(fUPrime-fUWhite);fVStar = 13.*fLStar*(fVPrime-fVWhite);}#endif //gjrTryLuv/*============================================================================ * int FBuildTrueColor(void) *----------------------------------------------------------------------------*/int V_Offscreen::FBuildTrueColor(void){#if WINDOWSint i;LONG *plFRedColor   = NULL;		// holds the translated color bitsLONG *plFGreenColor = NULL;     // Init to null for error handlingLONG *plFBlueColor  = NULL;LONG lAlphaRed;			// possible alpha channel bitsLONG lAlphaGreen;LONG lAlphaBlue;LONG lUsageRed;			// OR'd set of used bitsLONG lUsageGreen;LONG lUsageBlue;int iPixelsPerClump;int iRed, iBlue, iGreen;COLORREF crIn;LONG lColorOut;if (wBmPlanes != 1) goto Error_Return;  // planar true color don't exist yetif (!fBmOk) goto Error_Return;  // we need access to a readable bitmap// Get number of pixels per clump,//  where clump is the largest series of pixels Flash stores at a time.// Currently, clumps are either LONG (32bits), or 3bytes(24bit).switch(wBmBitsPixel)  // depth of this bitmap	{	case 4:    	iPixelsPerClump = 8;		break;	case 8:    	iPixelsPerClump = 4;		break;	case 16:    	iPixelsPerClump = 2;		break;	case 24:		iPixelsPerClump = 1; //Only One, using 3 bytes. Fourth must be zeroed.		break;	case 32:		iPixelsPerClump = 1;		break;    default:  goto Error_Return;  // can't handle this yet	}// make sure the bitmap is large enough for us to readif ((wBmWidthBytes*8 < wBmBitsPixel*iPixelsPerClump)  ||(wBmWidthBytes < 8) )	{  // then this bitmap is too small to test against	goto Error_Return;	}// Zero out the bitmap being tested.((LONG *)lpbBmBits)[0] = 0;     // start off fresh, needed for 24 bit tests((LONG *)lpbBmBits)[1] = 0;		// checked later for staying at zero// Allocate arrays to hold the translated color bitsif (!vaFRedColor)	{	vaFRedColor=new(V_Array);	vaFRedColor->cArray(256,sizeof(LONG),32);    }if (!vaFGreenColor)	{	vaFGreenColor=new(V_Array);	vaFGreenColor->cArray(256,sizeof(LONG),32);    }if (!vaFBlueColor)	{	vaFBlueColor=new(V_Array);	vaFBlueColor->cArray(256,sizeof(LONG),32);    }plFRedColor  =(LONG *)vaFRedColor->Use();plFGreenColor=(LONG *)vaFGreenColor->Use();plFBlueColor =(LONG *)vaFBlueColor->Use();iRed   = 0;iGreen = 0;iBlue  = 0;for (iRed = 0; iRed < 256; iRed++)	{  // get the translations for red	int iCountPixels;    crIn = RGB(iRed, iGreen, iBlue);	for (iCountPixels = 0; iCountPixels < iPixelsPerClump; iCountPixels++)		{  // Set enough pixels to fill the clump		SetPixel(metaPort,iCountPixels,0, crIn);		}	lColorOut = *(LONG *)lpbBmBits;  // get the effect in the first clump	plFRedColor[iRed]=lColorOut;	}iRed = 0;for (iGreen = 0; iGreen < 256; iGreen++)	{  // get the translations for Green	int iCountPixels;    crIn = RGB(iRed, iGreen, iBlue);	for (iCountPixels = 0; iCountPixels < iPixelsPerClump; iCountPixels++)		{  // Set enough pixels to fill the clump		SetPixel(metaPort,iCountPixels,0, crIn);		}	lColorOut = *(LONG *)lpbBmBits;  // get the effect in the first clump	plFGreenColor[iGreen]=lColorOut;	}iGreen = 0;for (iBlue = 0; iBlue < 256; iBlue++)	{  // get the translations for blue	int iCountPixels;    crIn = RGB(iRed, iGreen, iBlue);	for (iCountPixels = 0; iCountPixels < iPixelsPerClump; iCountPixels++)		{  // Set enough pixels to fill the clump		SetPixel(metaPort,iCountPixels,0, crIn);		}	lColorOut = *(LONG *)lpbBmBits;  // get the effect in the first clump	plFBlueColor[iBlue]=lColorOut;	}iBlue = 0;// Verify that the second longword was left alone by the prior testingif (((LONG *)lpbBmBits)[1] != 0) goto Error_Return;//------------------------------------------------------------------------------//  Reasonableness Checks//  Some boards use true color even for their 4 and 8 bit systems.//  Verify that the bits used by the three channels are bitwise separate.//  Also, some have alpha channels, so allow bits that are always on.//------------------------------------------------------------------------------lAlphaRed   = plFRedColor[0];		// These bits are always on, maybe alpha channellAlphaGreen = plFGreenColor[0];     // Determine these by AND'inglAlphaBlue  = plFBlueColor[0];      // Must init them firstlUsageRed   = 0;		// These bits were used at some pointlUsageGreen = 0;        // Gather them together by OR'inglUsageBlue  = 0;for (i = 0; i < 256; i++)	{	lAlphaRed   &= plFRedColor[i];	lAlphaGreen &= plFGreenColor[i];	lAlphaBlue  &= plFBlueColor[i];	lUsageRed   |= plFRedColor[i];	lUsageGreen |= plFGreenColor[i];	lUsageBlue  |= plFBlueColor[i];	}//------------------------------------------------------------------------------// Make sure the alpha channel is the same for all colors//------------------------------------------------------------------------------if ((lAlphaRed != lAlphaGreen)  ||(lAlphaRed != lAlphaBlue)  ||(lAlphaGreen != lAlphaBlue) )	{  // then this is not a known rgb format    goto Error_Return;	}//------------------------------------------------------------------------------// Make sure that, other than the always asserted alpha channel,// each of the 'r,g,b' use separate bits, not overlapping.//------------------------------------------------------------------------------if (((lUsageRed & lUsageGreen) &~lAlphaRed)  ||((lUsageRed & lUsageBlue) &~lAlphaRed)  ||((lUsageGreen & lUsageBlue) &~lAlphaRed) )	{  // then colors overlap, so not truecolor format	goto Error_Return;    }//------------------------------------------------------------------------------// 24 bit special handling// 24 bits is 3 bytes.  A fourth byte must have stayed zero.// Also, byte ordering may be strange.//------------------------------------------------------------------------------// For now, check just for intel orderingif (wBmBitsPixel == 24)  // depth of this bitmap	{	if ((lUsageRed | lUsageGreen | lUsageBlue) & 0xFF000000) goto Error_Return;    }vaFRedColor->Unuse();vaFGreenColor->Unuse();vaFBlueColor->Unuse();return(TRUE);//-------------------------------------------------------------------Error_Return:// Clean out the Flash Arrays. We use their existance to imply ok to useif (plFRedColor) vaFRedColor->Unuse();if (vaFRedColor) vaFRedColor->dArray();vaFRedColor = NULL;if (plFGreenColor) vaFGreenColor->Unuse();if (vaFGreenColor) vaFGreenColor->dArray();vaFGreenColor = NULL;if (plFBlueColor) vaFBlueColor->Unuse();if (vaFBlueColor) vaFBlueColor->dArray();vaFBlueColor = NULL;#endif //WINDOWSreturn(FALSE);}//==============================================================================/*------------------------------------------------------------------------------ * int V_Offscreen::BuildDither(void) *------------------------------------------------------------------------------*/ struct clt{	RGBColor color;#ifdef gjrTryLuv	float fL, fU, fV; // Luv coords#endif //gjrTryLuv 	Short index; 	};int V_Offscreen::BuildDither(void){int ok;ULong entry;RGBColor rgbColor;int colorDepth=GetDepth();int colorNum;int iColorsFound;long *dithers;struct clt *colors;int i,j,d1,d2,d3,d4,d,dr,dg,db,ir,ig,ib;unsigned int c1,c2,c3,c4;static int iNumChanged = 0;#if MACINTOSHCTabPtr		ourCTable;ctSeed = 0;					// Initialize the ctSeed for no color table#endifok = FBuildTrueColor();		// Try TrueColor first.if (ok) return (ok);if (colorDepth > 8) return(FALSE); // Bigger depths SHOULD be true color.                                 // MAX COLORS IS 256#if MACINTOSH// this checks if we've gone to or from grayscaleourCTable = UseColorTable();if (ourCTable)	{	ctSeed = ourCTable->ctSeed;	UnuseColorTable();	}#endifcolorNum=1<<colorDepth;if (!ditherTable)	{	ditherTable=new(V_Array);	ditherTable->cArray(17*17*17,4,32);	}if (!colorTable)	{	colorTable=new(V_Array);	colorTable->cArray(256,sizeof(struct clt),16);  // allocate max size	}colorTable->SetLength(256);		// force to full length in case of reinitSetMetaPort();colors=(struct clt*)colorTable->Abuse();#if MACINTOSHfor(i=0;i<colorNum;i++)	{	Index2Color(i,&rgbColor); // fill in the table	rgbColor.red>>=8;	rgbColor.green>>=8;	rgbColor.blue>>=8;	colors[i].color=rgbColor;	colors[i].index=i;	}iColorsFound = colorNum;	#elif WINDOWS //MERGE-PRO-JAM-1	{	HDC hDC;	HPALETTE hPal;	HPALETTE hOldPal;#if 0There are three kinds of color palettes under Windows:  logical, system, and hardware.Here, we extract the system palette from Windows, in case we need it.#endif		//---------------------------------------------------------------------------//	// Allocate and fill an Explicit paletteindex pallete	// This may be needed no matter what (palettes degrade on task switching)	//---------------------------------------------------------------------------//		{	HANDLE hlgpl;	LOGPALETTE FAR *lplgpl;			hlgpl = GlobalAlloc(GPTR, sizeof(LOGPALETTE)+colorNum*sizeof(PALETTEENTRY));	    lplgpl = (LOGPALETTE FAR *)GlobalLock(hlgpl);		lplgpl->palNumEntries = colorNum;	    lplgpl->palVersion = 0x300;		for (i=0; i<colorNum; i++)			{  // nothing like explicitly knowing the structure ...			lplgpl->palPalEntry[i].peFlags=PC_EXPLICIT;	        lplgpl->palPalEntry[i].peRed=LOBYTE(i);			lplgpl->palPalEntry[i].peGreen=HIBYTE(i);			lplgpl->palPalEntry[i].peBlue=0;			}		hPal = CreatePalette(lplgpl);		GlobalUnlock(hlgpl);		GlobalFree(hlgpl);	}#if 0There are three kinds of color palettes under Windows:  logical, system, and hardware.We will try to get the logical palette (we set it up back in InitPalette()).  It onlyhas less than 236 values, because Windows sets 20 colors automatically.    Here we check to seehow different the palette entries are from the colors we requested.  We don't want tobother with the byte ordering, so we write 4 bytes (into a long) and read back one.#endif		//---------------------------------------------------------------------------//	// 8 bit 256 color lookup table mode	// Only use the portion that we use defined ourselves	// But this only works if we can read the bitmap ourselves	//---------------------------------------------------------------------------//		if ( (fBmOk)					// if flash bitmap is accessible	  && (wBmBitsPixel == 8)		// and working with tricky 8 bits	  && (wBmWidthBytes > 4) 		// and enough bitmap width to work with//	  && (colorNum == 256) )			// and really working with 256-bit color     && (gwVgrNumColors != 16) )    // revisit due to viper card // gjr 12/15/93		{                           // THEN use original palette and read it ourselves		COLORREF crIn,crOut;	    colorNum = gColorTable->ALength();	// reset to only used pre-defined color vertices		for(i=0;i<colorNum;i++)			{							// THEN write and sample			crIn = PALETTEINDEX(i);			crOut = GetNearestColor(metaPort,crIn);			SetPixel(metaPort, 0, 0, crIn);		// write 4 bytes, read one; avoid msb hassles			SetPixel(metaPort, 1, 0, crIn);			SetPixel(metaPort, 2, 0, crIn);			SetPixel(metaPort, 3, 0, crIn);			rgbColor.red=GetRValue(crOut);			rgbColor.green=GetGValue(crOut);			rgbColor.blue=GetBValue(crOut);	#ifdef gjrTryLuv			RGB2LUV(rgbColor.red/255., rgbColor.green/255., rgbColor.blue/255.);			colors[i].fL = fLStar;			colors[i].fU = fUStar;			colors[i].fV = fVStar;	#endif //gjrTryLuv			colors[i].color=rgbColor;			colors[i].index = *(int *)lpbBmBits & 0xFF;	// get the possibly funky 8-bit value.	        }		iColorsFound = colorNum;	    goto DoneFindingColors;		}	#if 0There are three kinds of color palettes under Windows:  logical, system, and hardware.all else has failed.  We must get the hardware palette, which may have different indices than the windows system or the logical palette.  However, we can get the indices by pretending to stuff things in.#endif		//---------------------------------------------------------------------------//	// Read System Palette via PaletteIndex palette	// Note: two different methods need the palette_index palette	// Allocate a Explicit Palette to read the actual system colormap	// This will read the whole current map.	// To work, this needs to REALIZE a palette. That has possible side effects.	// Unknown what happens with animated or private entries.	//---------------------------------------------------------------------------//		//---------------------------------------------------------------------------//	//  ATI GRUNGY MODE	//  Some 8-bit machines use a modified True-Color even for 4 bit.	//  They actually use 8 bits, and only allow some values to be used.	//  As a result, although they claim to be PaletteSensitive, they only are Logically,	//  not physically.  So, for 4-bit, instead of index=2, we may see index=0xa5 (the rgb triplet)	//  We attempt to handle this by writing the color, then reading the physical value back in.	//	//  gjr 12/15/93 Viper caught us. Have currentDepth(colorNum)be physical size.	//		use gwVgrNumColors for exact count for special ati card.	//---------------------------------------------------------------------------//		if ( (fBmOk)					// if flash bitmap is accessible	  && (wBmBitsPixel == 8)		// and working with tricky 8 bits	  && (wBmWidthBytes > 4) 		// and enough bitmap width to work with//	  && (colorNum == 16) )			// and really working with 4bit 16 color	  && (gwVgrNumColors == 16) )			// and really working with 4bit 16 color		{                           // THEN use real palette and read it ourselves		COLORREF crIn,crOut;      colorNum = gwVgrNumColors;		hOldPal = SelectPalette(metaPort, hPal, TRUE); // get explicit into current port		iNumChanged = RealizePalette(metaPort);		for(i=0;i<colorNum;i++)        // only 16 colors for this strange mode.			{							// THEN write and sample			crIn = PALETTEINDEX(i);			crOut = GetNearestColor(metaPort,crIn);			SetPixel(metaPort, 0, 0, crIn);		// write 4 bytes, read one; avoid msb hassles			SetPixel(metaPort, 1, 0, crIn);			SetPixel(metaPort, 2, 0, crIn);			SetPixel(metaPort, 3, 0, crIn);			rgbColor.red=GetRValue(crOut);			rgbColor.green=GetGValue(crOut);			rgbColor.blue=GetBValue(crOut);	#ifdef gjrTryLuv			RGB2LUV(rgbColor.red/255., rgbColor.green/255., rgbColor.blue/255.);			colors[i].fL = fLStar;			colors[i].fU = fUStar;			colors[i].fV = fVStar;	#endif //gjrTryLuv			colors[i].color=rgbColor;			colors[i].index = *(int *)lpbBmBits & 0xFF;	// get the possibly funky 8-bit value.	        }		iColorsFound = colorNum;			SelectPalette(metaPort, hOldPal, TRUE); // get explicit into current port		goto DoneFindingColors;		}		//------------------------------------	// Need a way to avoid animated colors	// So far, GetNearestPaletteIndex doesn't like system colors.	// Oh, well.	//------------------------------------		hDC = VGetDC(NULL); // get default system palette	hOldPal = SelectPalette(hDC,hPal,TRUE); // get explicit into DC	iNumChanged = RealizePalette(hDC);		#ifdef gjrTryNearestPalette	if (gwVgrHasPalette)		{		// then use palette routines to compress table	    		// Also, this may avoid animated entries		j=0;		for(i=0;i<colorNum;i++)			{			COLORREF crIn,crOut, crOut2;			WORD wPaletteIndex;				crIn = PALETTEINDEX(i);			crOut = GetNearestColor(hDC,crIn);			wPaletteIndex = GetNearestPaletteIndex(hPal, crOut);			crOut2 = GetNearestColor(hDC, PALETTEINDEX(wPaletteIndex));			if ( (crOut == crOut2)		 	  && (wPaletteIndex == i) )	      	    {		// then this is a self-consistent color, use it				rgbColor.red=GetRValue(crOut);				rgbColor.green=GetGValue(crOut);				rgbColor.blue=GetBValue(crOut);	#ifdef gjrTryLuv				RGB2LUV(rgbColor.red/255., rgbColor.green/255., rgbColor.blue/255.);				colors[j].fL = fLStar;				colors[j].fU = fUStar;				colors[j].fV = fVStar;	#endif //gjrTryLuv				colors[j].color=rgbColor;				colors[j].index=i;	    		j++;	    		}			}	    	iColorsFound = j;		}	else	#endif //gjrTryNearestPalette		{		// no palette, so grab the colors straightaway		j=0;		for(i=0;i<colorNum;i++)			{			COLORREF crIn,crOut, crOut2;			crIn = PALETTEINDEX(i);			crOut = GetNearestColor(hDC,crIn);			rgbColor.red=GetRValue(crOut);			rgbColor.green=GetGValue(crOut);			rgbColor.blue=GetBValue(crOut);	#ifdef gjrTryLuv			RGB2LUV(rgbColor.red/255., rgbColor.green/255., rgbColor.blue/255.);			colors[j].fL = fLStar;			colors[j].fU = fUStar;			colors[j].fV = fVStar;	#endif //gjrTryLuv			colors[j].color=rgbColor;			colors[j].index=i;	    	j++;			}		iColorsFound = j;		}		SelectPalette(hDC,hOldPal,TRUE);	// Unhook prior hPal		ReleaseDC(NULL,hDC);		goto DoneFindingColors;			DoneFindingColors:		DeleteObject(hPal);                 // and delete our hPal.			}#endif //WINDOWScolorTable->SetLength(iColorsFound);	// record the actual used values.dithers=(long *)ditherTable->Abuse();for(i=0;i<ditherTable->ALength();i++,dithers++)*dithers=0xFF00FF00;UnsetMetaPort();// reset the global texture shading table to reflect the new colors#if WINDOWS 				// MERGE-Z1// ResetShadingTable();		// MERGE-VSHA    only do AFTER shading table exists#endif 						// MERGE-Z1return 0; // no errors}/*------------------------------------------------------------------------------ * int V_Offscreen::ReInitDither() *------------------------------------------------------------------------------*/int V_Offscreen::ReInitDither(void){#if WINDOWS	if (!ditherTable) return (0);		// can't reinit what ain't here	if (!gwVgrHasPalette) return (0);	// don't reinit what isn't supported	if (gwVgrSizePalette < 256-20) return (0);	// Only playing this for where palettes are important	 //palettes less than 20 are fixed, and we can't use our palette.	 //palettes at 256 or above are variable, and we have to set it up     // so pick some value between the two.#endif //WINDOWS	BuildDither();#if WINDOWS	ResetShadingTable();         // correct the shading table#endif WINDOWS    return (0);}/*------------------------------------------------------------------------------ * ReInitDither() *------------------------------------------------------------------------------*/int ReInitDither(void){	V_Offscreen * lpvoScreen;	lpvoScreen = VGetFirstScreen();	while (lpvoScreen)		{		lpvoScreen->ReInitDither();		lpvoScreen = VGetNextScreen(lpvoScreen);        }	return (0);}//==============================================================================/*------------------------------------------------------------------------------ * long V_Offscreen::GetDither(RGBColor *rgb) *------------------------------------------------------------------------------*/#ifdef gjrUseLuvint bGJRUseLUV = FALSE;ULong dvalRGB = 0;ULong dvalLUV = 0;#endif //gjrUseLuvULongV_Offscreen::GetDither(RGBColor *rgb){ULong dval=0;int i,luminance;RGBColor srgb;int colorNum,colorDepth; // color range/palette sizeint bitmapDepth;		// bitmap storage size// long gray,dGray;// Convert the input parameters to easier formssrgb=*rgb;srgb.red>>=8;srgb.green>>=8;srgb.blue>>=8;// Now check if we can do the lookups ...colorDepth=bitDepth; // GetDepth();	// DAS-LIZARD KING2 10/9/93#if MACINTOSHif (colorDepth > 8)	{	/* 	It seems like it would be a lot of work to make all those tables and then		access them whenever we want to get a true color value.  It seems like it would		be no end faster to just shift and mask the rgbcolor, which always has the same 		bit patterns on a mac, no matter what card.  Thus....    jca 18 aug 93 */	if (colorDepth == 32)		return(((LONG)srgb.red << 16) & 0x00FF0000 | (srgb.green << 8) & 0x00000FF00 | srgb.blue & 0x000000FF);	else if (colorDepth == 16)		{		dval = (srgb.red << 7) & 0x7C00 | (srgb.green << 2) & 0x03E0 | (srgb.blue >> 3) & 0x001F;		return((dval & 0x0000FFFF) | (dval << 16) & 0xFFFF0000);		}	// else  ...major problems?		}else	{	if (!ditherTable)		BuildDither();	}#elif WINDOWSif (!ditherTable)	{	if (!gplFRedColor)		{		return(0);		// Oops, neither pseudo nor true color		}	else		// Yep, we have a true color converter here.		{		dval = gplFRedColor[srgb.red]			 | gplFGreenColor[srgb.green]			 | gplFBlueColor[srgb.blue];        return(dval);		}	}#endif// Otherwise, do a real dither lookup	// get bitmapDepth defined now for later use	// Get the depth of the pallete ELSE number of colors supported//	colorDepth=GetDepth();		// jca.  done above for mac	colorNum=1<<colorDepth;#if WINDOWS	// Get the actual storage cell size from the bitmap	if (fBmOk)		{ 		bitmapDepth = wBmBitsPixel*wBmPlanes;  // depth of this bitmap		}    else  // no bitmap to learn from, so use colorDepth		{		bitmapDepth = colorDepth;        }#elif MACINTOSH	bitmapDepth = colorDepth;#endif	// WINDOWS	dval = GetDither4Bytes(rgb);// Ought to combine these better.// Ought to let flash do its own combo stuff// Ought to have colors set in poly so no getcolor is needed.	switch(bitmapDepth)		{		case 1:// may have problems here.        				dval=(((dval&0x01000000)>>21)|((dval&0x00010000)>>14))|((dval&0x00000100)>>7)|((dval&0x00000001));			dval=(((dval&0x00000008)<<13)|((dval&0x00000004)<<15))|(dval&0x00000003); //?huh? //gjr12/15/93//			dval=(((dval&0x00000080)<<28)|((dval&0x00000040)<<20))|(dval&0x00000003); //?huh? //gjr12/15/93			dval=dval|(dval<<2);			dval=dval|(dval<<4);			dval=dval|(dval<<8);			break;		case 2:			dval=(((dval&0x03000000)>>18)|((dval&0x00030000)>>12))|((dval&0x00000300)>>6)|((dval&0x00000003));			dval=(((dval&0x00000030)<<14)|((dval&0x000000C0)<<10))|(dval&0x0000000F);			dval=dval|(dval<<4);			dval=dval|(dval<<8);			break;		case 4: //21213434			dval=(((dval&0x0F000000)>>8)|((dval&0x000F0000)<<4))|((dval&0x00000F00)>>4)|((dval&0x0000000F));//			dval=(((dval&0x0000F000)<<4)|((dval&0x00000F00)<<12))|(dval&0x000000FF);  //old when packed4-4-4-4			dval=dval|(dval<<8);			break;		case 8:  //2134			dval=((dval&0xFF000000)>>8)|((dval&0x00FF0000)<<8)|(dval&0x0000FFFF);			break;		}return dval;}//==============================================================================/*------------------------------------------------------------------------------ * long V_Offscreen::GetDither4Bytes(RGBColor *rgb) *		get 4 dithers, into a long, spaced a byte apart (8 bits per dither value) *------------------------------------------------------------------------------*/#ifdef gjrUseLuvint bGJRUseLUV = FALSE;ULong dvalRGB = 0;ULong dvalLUV = 0;#endif //gjrUseLuvULongV_Offscreen::GetDither4Bytes(RGBColor *rgb){int cval;ULong dval=0;int i,luminance;RGBColor srgb;int colorNum,colorDepth; // color range/palette sizeint bitmapDepth;		// bitmap storage size// long gray,dGray;// Convert the input parameters to easier formssrgb=*rgb;srgb.red  =srgb.red  >>8 & 0xFF;srgb.green=srgb.green>>8 & 0xFF;srgb.blue =srgb.blue >>8 & 0xFF;;// Now check if we can do the lookups ...colorDepth=bitDepth; // GetDepth();	// DAS-LIZARD KING2 10/9/93#if MACINTOSHif (colorDepth > 8)	{	/* 	It seems like it would be a lot of work to make all those tables and then		access them whenever we want to get a true color value.  It seems like it would		be no end faster to just shift and mask the rgbcolor, which always has the same 		bit patterns on a mac, no matter what card.  Thus....    jca 18 aug 93 */	if (colorDepth == 32)		return(((LONG)srgb.red << 16) & 0x00FF0000 | (srgb.green << 8) & 0x00000FF00 | srgb.blue & 0x000000FF);	else if (colorDepth == 16)		{		dval = (srgb.red << 7) & 0x7C00 | (srgb.green << 2) & 0x03E0 | (srgb.blue >> 3) & 0x001F;		return((dval & 0x0000FFFF) | (dval << 16) & 0xFFFF0000);		}	// else  ...major problems?		}else	{	if (!ditherTable)		BuildDither();	}#elif WINDOWSif (!ditherTable)	{	if (!gplFRedColor)		{		return(0);		// Oops, neither pseudo nor true color		}	else		// Yep, we have a true color converter here.		{		dval = gplFRedColor[srgb.red]			 | gplFGreenColor[srgb.green]			 | gplFBlueColor[srgb.blue];        return(dval);		}    }#endif// Otherwise, do a real dither lookupcval=( (((srgb.red  +8)>>4) *17*17) +	   (((srgb.green+8)>>4) *17) +	   (((srgb.blue +8)>>4) *1) );ditherTable->Get(cval,&dval);if(dval==0xFF00FF00)	{	int index,index2,start,end;	struct clt *colors;	int baseRed;	int baseGreen;	int baseBlue, findr, findg, findb;	// Since we are limiting colors to 4k+ (17^3) choices, have each	// color choice represent the "middle" of its color region.	// Round it up.  Then clear out the low bits.    // This gives us 0x00,0x10,0x20...0xE0,0xF0,0x100(for 0xFF)	srgb.red += 0x08;	srgb.green += 0x08;	srgb.blue += 0x08;	srgb.red &= ~0x0F;	srgb.green &= ~0x0F;    srgb.blue &= ~0x0F;	// srgb is the current color to search for.	// It includes accumulated errors.	// base* is the overall base color we are striving towards.	baseRed   = srgb.red;	baseGreen = srgb.green;	baseBlue  = srgb.blue;	findr = baseRed;	findg = baseGreen;	findb = baseBlue;		    // Get the depth of the pallete ELSE number of colors supported//	colorDepth=GetDepth();	// jca 19 aug 93.  Moved the call up before the "if (!dithertable)" test	colorNum=1<<colorDepth;	colors=(struct clt *)colorTable->Abuse();	bitmapDepth = 8;      // Force storing into separate bytes	start=0;	end=colorTable->ALength();			// only search defined section of colors	dval=0;	for(i=0;i<4;i++)		{		long distance,distance2,colorIndex;		int dr,dg,db;		/*find the four closest colors*/		distance=66000*3;//clearly big enough		for(index=start;index<end;index++)			{			dr=(int)colors[index].color.red-findr;			dg=(int)colors[index].color.green-findg;			db=(int)colors[index].color.blue-findb;						distance2=(dr>0?dr:-dr)+(dg>0?dg:-dg)+(db>0?db:-db); // Manhatten distance//			dr >>= 1;   // avoid later overflow cuz of (0x100 - 0)**2//			dg >>= 1;//			db >>= 1;//			distance2= (long)(dr*dr) + (long)(dg*dg) + (long)(db*db);  // squared distance			if(distance2<distance)				{distance=distance2;colorIndex=index;}			}		/*now that we have our index, calc the error terms and loop*/		dr=((int)colors[colorIndex].color.red-findr);		dg=((int)colors[colorIndex].color.green-findg);		db=((int)colors[colorIndex].color.blue-findb);		// d* indicates how far we have drifted.        // So aim for the base color minus the drift to get the next search color.		findr   = baseRed-dr;	// 16 bits		findg	= baseGreen-dg;	// 16 bits		findb	= baseBlue-db;	// 16 bits		dval=(long)colors[colorIndex].index | (dval<<(bitmapDepth));		}#ifdef gjrTryLuv    dvalRGB = dval;	dval=0;	srgb.red = baseRed;	srgb.green = baseGreen;    srgb.blue = baseBlue;	for(i=0;i<4*0;i++)               //TURNED OFF BY *0		{		float distance,distance2;		int colorIndex;		int dr,dg,db;        float fL,fU,fV;		// Luv of the preferred color		float fDL,fDU,fDV;	// Delta error difference        float fDL2, fDU2, fDV2;	// Delta squared (don't need square root for compares)		/*find the four closest colors*/		distance=1e20;  //clearly big enough		for(index=start;index<end;index++)			{			RGB2LUV((int)srgb.red/255., (int)srgb.green/255., (int)srgb.blue/255.);			fL = fLStar;			fU = fUStar;		    fV = fVStar;			fDL=(int)colors[index].fL-fL;			fDU=(int)colors[index].fU-fU;			fDV=(int)colors[index].fV-fV;			            distance2 = fDL*fDL + fDU*fDU + fDV*fDV;			if(distance2<distance)				{distance=distance2;colorIndex=index;}			}		/*now that we have our index, calc the error terms and loop*/		dr=((int)colors[colorIndex].color.red-(int)srgb.red);		dg=((int)colors[colorIndex].color.green-(int)srgb.green);		db=((int)colors[colorIndex].color.blue-(int)srgb.blue);		// d* indicates how far we have drifted.        // So aim for the base color minus the drift to get the next search color.		// Caution: this target color may be outside 0..1 due to the error values.		(int)srgb.red   = baseRed-dr;		(int)srgb.green = baseGreen-dg;		(int)srgb.blue  = baseBlue-db;		dval=(long)colors[colorIndex].index | (dvalLUV<<(bitmapDepth));		}	dvalLUV = dval;	/*now that we have a dval, lets put it away*/    dval = dvalRGB;	if (bGJRUseLUV)		{		dval = dvalLUV;.		}#endif //gjrTryLuv	ditherTable->Put(cval,&dval);	}return dval;}//==============================================================================/*------------------------------------------------------------------------------ * long V_Offscreen::GetNoDither(RGBColor *rgb) *------------------------------------------------------------------------------*/ULong V_Offscreen::GetNoDither(RGBColor *rgb){ULong dval=0;ULong lNoDval = 0;int i,luminance;RGBColor srgb;int colorNum,colorDepth; // color range/palette sizeint bitmapDepth;		// bitmap storage size// long gray,dGray;// Convert the input parameters to easier formssrgb=*rgb;srgb.red>>=8;srgb.green>>=8;srgb.blue>>=8;// Now check if we can do the lookups ...colorDepth=bitDepth; // GetDepth();	// DAS-LIZARD KING2 10/9/93#if MACINTOSHif (colorDepth > 8)	{	/* 	It seems like it would be a lot of work to make all those tables and then		access them whenever we want to get a true color value.  It seems like it would		be no end faster to just shift and mask the rgbcolor, which always has the same 		bit patterns on a mac, no matter what card.  Thus....    jca 18 aug 93 */	if (colorDepth == 32)		return(((LONG)srgb.red << 16) & 0x00FF0000 | (srgb.green << 8) & 0x00000FF00 | srgb.blue & 0x000000FF);	else if (colorDepth == 16)		{		dval = (srgb.red << 7) & 0x7C00 | (srgb.green << 2) & 0x03E0 | (srgb.blue >> 3) & 0x001F;		return((dval & 0x0000FFFF) | (dval << 16) & 0xFFFF0000);		}	// else  ...major problems?		}else	{	if (!ditherTable)		BuildDither();	}#elif WINDOWSif (!ditherTable)	{	if (!gplFRedColor)		{		return(0);		// Oops, neither pseudo nor true color		}	else		// Yep, we have a true color converter here.		{		dval = gplFRedColor[srgb.red]			 | gplFGreenColor[srgb.green]			 | gplFBlueColor[srgb.blue];        return(dval);		}	}#endif// Otherwise, do a real dither lookup	// get bitmapDepth defined now for later use	// Get the depth of the pallete ELSE number of colors supported//	colorDepth=GetDepth();		// jca.  done above for mac	colorNum=1<<colorDepth;#if WINDOWS	// Get the actual storage cell size from the bitmap	if (fBmOk)		{ 		bitmapDepth = wBmBitsPixel*wBmPlanes;  // depth of this bitmap		}    else  // no bitmap to learn from, so use colorDepth		{		bitmapDepth = colorDepth;        }#elif MACINTOSH	bitmapDepth = colorDepth;#endif	// WINDOWS	dval = GetDither4Bytes(rgb);//-----------------------------------------------------------------------------// OK, now get the non-dither color//-----------------------------------------------------------------------------	lNoDval = dval;			// start with something for default	switch(bitmapDepth)		{		case 1:			lNoDval>>=16;			lNoDval &=0x01;			lNoDval |=lNoDval<<1;			lNoDval |=lNoDval<<2;			lNoDval |=lNoDval<<4;			lNoDval |=lNoDval<<8;			lNoDval |=lNoDval<<16;			break;		case 2:			lNoDval>>=24; //2*(4-1); huh? jca 24 aug 93			lNoDval &=0x03;			lNoDval |=lNoDval<<2;			lNoDval |=lNoDval<<4;			lNoDval |=lNoDval<<8;			lNoDval |=lNoDval<<16;			break;		case 4:         	lNoDval>>=24;			lNoDval &=0x0F;			lNoDval |=lNoDval<<4;			lNoDval |=lNoDval<<8;			lNoDval |=lNoDval<<16;			break;		case 8: 			lNoDval>>=24;			lNoDval &=0xFF;			lNoDval |=lNoDval<<8;			lNoDval |=lNoDval<<16;			break;		}return lNoDval;}//==============================================================================// MERGE-Z1 [[[#if WINDOWS// Data Tables//		Start with WHITE for Decals (entry 0 is decal)//		Maybe later have a separate slot for decal.UShort red_vals[]=	{0xffff, 0xe000, 0xc000, 0x8000, 0x4000, 0x0000};UShort green_vals[]=	{0xffff, 0xe000, 0xc000, 0x8000, 0x4000, 0x0000};UShort blue_vals[]=	{0xffff, 0xe000, 0xc000, 0x8000, 0x4000, 0x0000};#define MAXINDEX(x) ((sizeof(x)/sizeof(x[0])) - 1)#define red_maxindex (MAXINDEX(red_vals))#define green_maxindex (MAXINDEX(green_vals))#define blue_maxindex (MAXINDEX(blue_vals))#define iRedValsNum (MAXINDEX(red_vals) + 1)#define iGreenValsNum (MAXINDEX(green_vals) + 1)#define iBlueValsNum (MAXINDEX(blue_vals) + 1)long alStandardRed[256];long alStandardGreen[256];long alStandardBlue[256];#define iStandardRedNum (MAXINDEX(alStandardRed)+1)#define iStandardGreenNum (MAXINDEX(alStandardGreen)+1)#define iStandardBlueNum (MAXINDEX(alStandardBlue)+1)long alStandardDitherRed[256];   		// ABD 12/14/93 long alStandardDitherGreen[256];       // ABD 12/14/93long alStandardDitherBlue[256];        // ABD 12/14/93voidMakeStandardColorTable(){int gray,val,entry,g,r,b;RGBColor *colors;RGBColor col,c;int iColorTableNum = iRedValsNum * iGreenValsNum * iBlueValsNum;int i;int next_peak;	gColorTable = new(V_Array);	gColorTable->cArray(iColorTableNum, sizeof(RGBColor), 1);	colors=(RGBColor *)gColorTable->Abuse();//	// build the standard color table which we use to get the good dither//	for( entry=0; entry<16;entry++)//		{//		gray = gray_vals[entry];//        val = (unsigned)gray>>8;//		colors[entry].red = val;//		colors[entry].green = val;//		colors[entry].blue = val;//		}	entry = 0;	for(r=0;r<=MAXINDEX(red_vals);r++)		{		c.red = red_vals[r];		for(g=0;g<=MAXINDEX(green_vals);g++)	    	{			c.green = green_vals[g];			for(b=0;b<=MAXINDEX(blue_vals);b++,entry++)				{				c.blue = blue_vals[b];				ASSERT(entry < gColorTable->ALength());				colors[entry].red = c.red;				colors[entry].green = c.green;				colors[entry].blue = c.blue;				}			}		}	ASSERT(iColorTableNum == entry);	//Make sure we used entire table	ASSERT(gColorTable->ALength() == entry);// Make a true color converter to 8-bit index.// Using the 8-bits of each color axis, create a lookup table// for that axis's contribution to the color index.// Note that the "color cube" has independent (orthogonal) axis. So the// 3D array offset for red (for example) is independent of the 3D array// offset for blue. This allows us to just add their contributions together.// To create the table, go through the values, and bump the index half way// between each index.	for(r=0;r<=MAXINDEX(red_vals) - 1;r++)		{		int iIndexedColor;		int iRedIndex;// Start with matching color value// Go from that color to halfway to next color        iIndexedColor = red_vals[r]>>8;		for ( ;			 iIndexedColor > (int)((red_vals[r]>>8) + (red_vals[r+1]>>8)) >> 1;			 iIndexedColor--)			{            iRedIndex = r;			alStandardRed[iIndexedColor] = iRedIndex * iGreenValsNum * iBlueValsNum;			alStandardGreen[iIndexedColor] = iRedIndex * iBlueValsNum;			alStandardBlue[iIndexedColor] = iRedIndex;			}// Now go from halfway between to the second color		for ( ;			 iIndexedColor >= (int)(red_vals[r+1]>>8);			 iIndexedColor--)			{			iRedIndex = r+1;			alStandardRed[iIndexedColor] = iRedIndex * iGreenValsNum * iBlueValsNum;			alStandardGreen[iIndexedColor] = iRedIndex * iBlueValsNum;			alStandardBlue[iIndexedColor] = iRedIndex;			}		}	return;// ********************************************************** DEBUG// ABD 12/14/93 [[[// Make a true color converter to 8-bit index.// Using the 8-bits of each color axis, create a lookup table// for that axis's contribution to the color index.// Note that the "color cube" has independent (orthogonal) axis. So the// 3D array offset for red (for example) is independent of the 3D array// offset for blue. This allows us to just add their contributions together.// To create the table, go through the values, and bump the index half way// between each index.	for(r=0;r<256;r++)	{   	alStandardDitherRed[r] = (long)0;		alStandardDitherGreen[r] = (long)0;		alStandardDitherBlue[r] = (long)0;	}	for(r=0;r<=MAXINDEX(red_vals) - 1;r++)		{		int iIndexedColor;		int iRedIndex;      // instead of going from matching color value to halfway, and then halfway to 		// the second color, we want to go in five stages --		// 0:		1/8     0000		// 1: 	1/4     0001		// 2: 	1/4     0011		// 3: 	1/4     0111		// 4:		1/8     1111// Start with matching color value// Go from that color to halfway to next color// Make a few macros to help us set the alStandardDither values -- for use only in this routine#define D_RED_0(a) 	alStandardDitherRed[iIndexedColor] |= ((a) << 0) & 0x000000ff;#define D_RED_1(a) 	alStandardDitherRed[iIndexedColor] |= ((a) << 8) & 0x0000ff00;#define D_RED_2(a) 	alStandardDitherRed[iIndexedColor] |= ((a) << 16) & 0x00ff0000;#define D_RED_3(a) 	alStandardDitherRed[iIndexedColor] |= ((a) << 24) & 0xff000000;#define D_GREEN_0(a) alStandardDitherGreen[iIndexedColor] |= ((a) << 0) & 0x000000ff;#define D_GREEN_1(a) alStandardDitherGreen[iIndexedColor] |= ((a) << 8) & 0x0000ff00;#define D_GREEN_2(a) alStandardDitherGreen[iIndexedColor] |= ((a) << 16) & 0x00ff0000;#define D_GREEN_3(a) alStandardDitherGreen[iIndexedColor] |= ((a) << 24) & 0xff000000;#define D_BLUE_0(a) 	alStandardDitherBlue[iIndexedColor] |= ((a) << 0) & 0x000000ff;#define D_BLUE_1(a) 	alStandardDitherBlue[iIndexedColor] |= ((a) << 8) & 0x0000ff00;#define D_BLUE_2(a) 	alStandardDitherBlue[iIndexedColor] |= ((a) << 16) & 0x00ff0000;#define D_BLUE_3(a) 	alStandardDitherBlue[iIndexedColor] |= ((a) << 24) & 0xff000000;		// INITIAL VALUE		iIndexedColor = red_vals[r]>>8;		next_peak = (int)((red_vals[r]>>8) - (((red_vals[r]>>8) - (red_vals[r+1]>>8)) >> 3));		// STAGE 0:		1/8     0000  	total so far: 1/8		for ( ; iIndexedColor > next_peak ; iIndexedColor--)			{				// this stage uses 0000 as color indices				D_RED_0(r * iGreenValsNum * iBlueValsNum);				D_GREEN_0(r * iBlueValsNum);				D_BLUE_0(r);				D_RED_1(r * iGreenValsNum * iBlueValsNum);				D_GREEN_1(r * iBlueValsNum);				D_BLUE_1(r);				D_RED_2(r * iGreenValsNum * iBlueValsNum);				D_GREEN_2(r * iBlueValsNum);				D_BLUE_2(r);				D_RED_3(r * iGreenValsNum * iBlueValsNum);				D_GREEN_3(r * iBlueValsNum);				D_BLUE_3(r);			}		// subtract 1/4 of difference to next peak to find the next threshold		next_peak -= (int)((red_vals[r]>>8) - (red_vals[r+1]>>8)) >> 2;		// STAGE 1: 	1/4     0001   total so far: 3/8		for ( ; iIndexedColor > next_peak ; iIndexedColor--)			{         	// this stage uses 0001 as color values, so increment the 3 red indices				D_RED_0(r * iGreenValsNum * iBlueValsNum);				D_GREEN_0(r * iBlueValsNum);				D_BLUE_0(r);				D_RED_1(r * iGreenValsNum * iBlueValsNum);				D_GREEN_1(r * iBlueValsNum);				D_BLUE_1(r);				D_RED_2(r * iGreenValsNum * iBlueValsNum);				D_GREEN_2(r * iBlueValsNum);				D_BLUE_2(r);				D_RED_3(r+1 * iGreenValsNum * iBlueValsNum);				D_GREEN_3(r+1 * iBlueValsNum);				D_BLUE_3(r+1);			}		// subtract 1/4 of difference to next peak to find the next threshold		next_peak -= (int)((red_vals[r]>>8) - (red_vals[r+1]>>8)) >> 2;		// STAGE 2: 	1/4     0011		for ( ; iIndexedColor > next_peak ; iIndexedColor--)			{				// this stage uses 0001 as color values, so increment the 3 red indices				D_RED_0(r * iGreenValsNum * iBlueValsNum);				D_GREEN_0(r * iBlueValsNum);				D_BLUE_0(r);				D_RED_1(r * iGreenValsNum * iBlueValsNum);				D_GREEN_1(r * iBlueValsNum);				D_BLUE_1(r);				D_RED_2(r+1 * iGreenValsNum * iBlueValsNum);				D_GREEN_2(r+1 * iBlueValsNum);				D_BLUE_2(r+1);				D_RED_3(r+1 * iGreenValsNum * iBlueValsNum);				D_GREEN_3(r+1 * iBlueValsNum);				D_BLUE_3(r+1);			}		// subtract 1/4 of difference to next peak to find the next threshold		next_peak -= (int)((red_vals[r]>>8) - (red_vals[r+1]>>8)) >> 2;		// STAGE 3: 	1/4     0111		for ( ; iIndexedColor > next_peak ; iIndexedColor--)			{				// this stage uses 0111 as color values				D_RED_0(r * iGreenValsNum * iBlueValsNum);				D_GREEN_0(r * iBlueValsNum);				D_BLUE_0(r);				D_RED_1(r+1 * iGreenValsNum * iBlueValsNum);				D_GREEN_1(r+1 * iBlueValsNum);				D_BLUE_1(r+1);				D_RED_2(r+1 * iGreenValsNum * iBlueValsNum);				D_GREEN_2(r+1 * iBlueValsNum);				D_BLUE_2(r+1);				D_RED_3(r+1 * iGreenValsNum * iBlueValsNum);				D_GREEN_3(r+1 * iBlueValsNum);				D_BLUE_3(r+1);			}		next_peak = (int)(red_vals[r+1]>>8);		// STAGE 4:		1/8     1111		for ( ; iIndexedColor >= next_peak ; iIndexedColor--)			{				// this stage uses 1111 as color values, so increment all indicies				D_RED_0(r+1 * iGreenValsNum * iBlueValsNum);				D_GREEN_0(r+1 * iBlueValsNum);				D_BLUE_0(r+1);				D_RED_1(r+1 * iGreenValsNum * iBlueValsNum);				D_GREEN_1(r+1 * iBlueValsNum);				D_BLUE_1(r+1);				D_RED_2(r+1 * iGreenValsNum * iBlueValsNum);				D_GREEN_2(r+1 * iBlueValsNum);				D_BLUE_2(r+1);				D_RED_3(r+1 * iGreenValsNum * iBlueValsNum);				D_GREEN_3(r+1 * iBlueValsNum);				D_BLUE_3(r+1);			}		}// ABD 12/14/93 ]]]}//==============================================================================/* compute a good dither value using the standard color table */voidGetStandardDither(RGBColor *rgb, unsigned char *a, unsigned char *b, unsigned char *c, unsigned char *d){int cval;ULong dval=0;int i,luminance;RGBColor srgb;//int colorNum; // color range/palette sizeint index,index2,start,end;RGBColor *colors;Long baseRed;      // base color we are trying to achieveLong baseGreen;Long baseBlue;Long dr,dg,db;     // accumulating error deltasASSERT(rgb && a && b && c && d);	// verify reasonable pointers// Convert the input parameters to easier formssrgb=*rgb;	// srgb is the current color to search for.	// It includes accumulated errors.	// base* is the overall base color we are striving towards.	baseRed   = srgb.red;	baseGreen = srgb.green;	baseBlue  = srgb.blue;    // Get the depth of the pallete ELSE number of colors supported//	colorDepth=GetDepth();	// jca 19 aug 93.  Moved the call up before the "if (!dithertable)" test//	colorNum=1<<8;         // 8-bit only	if (!gColorTable) MakeStandardColorTable();	dval=0;   colors = (RGBColor *)gColorTable->Use();   dr = 0;		// start with no error   dg = 0;   db = 0;	for(i=0;i<4;i++)		{		int colorIndex;		colorIndex = GetClosestColor(&srgb);		/*now that we have our index, calc the error terms and loop*/        // Desired minus Actual gives distance still left to go: add it.		dr = (Long)(baseRed+dr)  - (Long)colors[colorIndex].red;		dg = (Long)(baseGreen+dg)- (Long)colors[colorIndex].green;		db = (Long)(baseBlue+db) - (Long)colors[colorIndex].blue;		// d* indicates how far we still have to go.        // So aim for the base color plus the drift to get the next search color.        // Clamp it for safety.		srgb.red   = max(0, min(0xffff, (Long)(baseRed+dr) ));	// 16 bits		srgb.green = max(0, min(0xffff, (Long)(baseGreen+dg) ));	// 16 bits		srgb.blue  = max(0, min(0xffff, (Long)(baseBlue+db) ));	// 16 bits      // store this dither value in the appropriate index (a, b, c, or d)		switch (i)			{				case 0:*a = colorIndex; break;				case 1:*b = colorIndex; break;				case 2:*c = colorIndex; break;				case 3:*d = colorIndex; break;				default:					DEBUGGER();					break;			}		}   gColorTable->Unuse();}//==============================================================================/*	This routine translates the shading table of all screens (currently one).*/voidResetShadingTable(){int i, j, k;V_Array *trans;short *translate;V_Offscreen *main_screen;extern V_Array *screen;struct clt *colors;int iNumTextureShadingIndices;int d;extern TextureShader gMasterTextureShader;extern TextureShader gTextureShader;	if (!gColorTable) MakeStandardColorTable();	iNumTextureShadingIndices = gColorTable->ALength();    main_screen = NULL;	// init for existence test	screen->Get(0, &main_screen);   if (!main_screen) {DEBUGGER(); return;}   if (main_screen->bitDepth != 8) {return;}  // shading table only changes for 8-bit stuff.   if (main_screen->colorTable == NULL) {return;} // only when color table available.	colors = (struct clt *)main_screen->colorTable->Use();	for ( i = 0 ; i < NUM_TEXTURE_SHADING_LEVELS ; i++ )		 for ( j = 0 ; j < iNumTextureShadingIndices ; j++ )		 {			// 8-bit translation ( dith[3] is 8-bit (on mac, dith[0..2] is 1/2/4 bit))			for ( d = 0 ; d < 4 ; d++ )      // loop through each dither array (a/b/c/d arrays)			{			int old_index;				// get the old index from the master texture shader (dith[3] is 8-bit)				old_index = gMasterTextureShader[i].dith[3][d][j];				// store the translated index in the texture shader (dith[3] is 8-bit)				gTextureShader[i].dith[3][d][j] = colors[old_index].index;         }	   }  main_screen->colorTable->Unuse();}/* this routine returns the index of the color that is closest to the specified color in the globalcolor table, gColorTable */intGetClosestColor(RGBColor *rgb){int i;int index;long distance,distance2;int colorIndex;long dr,dg,db;RGBColor *colors;	if (!gColorTable) MakeStandardColorTable();    colorIndex = alStandardRed[rgb->red>>8] + alStandardGreen[rgb->green>>8] + alStandardBlue[rgb->blue>>8];#if 0	/*find the four closest colors*/	distance = 66000*3;//clearly big enough	colors = (RGBColor *)gColorTable->Use();	for (index = 0 ; index < gColorTable->ALength() ; index++)	{		dr = ((long)(colors[index].red)) - ((long)(rgb->red));		dg = ((long)(colors[index].green)) - ((long)(rgb->green));		db = ((long)(colors[index].blue)) - ((long)(rgb->blue));		distance2=(dr>0?dr:-dr)+(dg>0?dg:-dg)+(db>0?db:-db); // Manhattan distance		if (distance2 < distance)		{			distance = distance2;			colorIndex = index;		}	}	gColorTable->Unuse();#endif   return colorIndex;}//==============================================================================// ABD 12/14/93 [[[/* this routine returns a long that contains the 4 indices of the dithered color */longGetClosestColorDither(RGBColor *rgb){long colorIndex;	if (!gColorTable) MakeStandardColorTable();	 colorIndex = alStandardDitherRed[rgb->red>>8] +						alStandardDitherGreen[rgb->green>>8] +						alStandardDitherBlue[rgb->blue>>8];   return colorIndex;}//==============================================================================// ABD 12/14/93 ]]]/* this routine returns the RGB color that is matched to the index in the globalcolor table, gColorTable */voidGetStandardColor(RGBColor *rgb, int index)				// ABD MERGE-VSHA{RGBColor *colors;	if (!gColorTable) MakeStandardColorTable();	colors = (RGBColor *)gColorTable->Use();    *rgb = colors[index];	gColorTable->Unuse();}#elif MACINTOSH// BILBIL - 01/15/94 - Mac support added for these two functions.../* this routine returns the index of the color that is closest to the specified color inthe current color table (current CGrafPort/GDevice) */intGetClosestColor(RGBColor *rgb)	{    return Color2Index(rgb);    }/* this routine returns the RGB color that is matched to the specified color inthe current color table (current CGrafPort/GDevice) */voidGetStandardColor(RGBColor *rgb, int index)	{	Index2Color(index, rgb);    }#endif //WINDOWS//==============================================================================// MERGE-Z1 ]]]intV_Offscreen::ColorToIndex(RGBColor *rgb){int i;int index;long distance,distance2;int colorIndex;long dr,dg,db;struct clt *colors;	if (!colorTable) DEBUGGER();	/*find the four closest colors*/	distance=66000*3;//clearly big enough	colors = (struct clt *)colorTable->Use();	for(index = 0 ; index < colorTable->ALength() ; index++)	{		dr = ((long)(colors[index].color.red)) - ((long)(rgb->red));		dg = ((long)(colors[index].color.green)) - ((long)(rgb->green));		db = ((long)(colors[index].color.blue)) - ((long)(rgb->blue));		distance2=(dr>0?dr:-dr)+(dg>0?dg:-dg)+(db>0?db:-db); // Manhattan distance		if(distance2<distance)		{distance=distance2;colorIndex=index;}	}	colorTable->Unuse();   return colorIndex;}//==============================================================================// MERGE-VSHA ]]]// MERGE-GOURAUD [[[// convert a RGB color into the closest 0..255 index value for this offscreenshortV_Offscreen::ColorTo256(RGBColor *rgb){VCGrafPort savePort;VGrafDevice saveDevice;short colorIndex;	VGetPort(&savePort, &saveDevice);	SetMetaPort();    colorIndex = GetClosestColor(rgb);	//JAM-HACK MERGE-GOURAUD-PRO//	colorIndex = Color2Index(rgb);		//JAM-HACK MERGE-GOURAUD-PRO	UnsetMetaPort();	VSetPort(savePort, saveDevice);	ASSERT((colorIndex >= 0) && (colorIndex <= 255));	//JAM-HACK MERGE-GOURAUD-PRO   return colorIndex;}// MERGE-GOURAUD ]]]// PRO-19 [[[voidV_Offscreen::IndexToColorNew(RGBColor *rgb, long index){#if MACINTOSHVCGrafPort savePort;VGrafDevice saveDevice;	VGetPort(&savePort, &saveDevice);	SetMetaPort();	SetGWorld(metaPort, NULL);	// PRO-23    Index2Color(index, rgb);	UnsetMetaPort();	VSetPort(savePort, saveDevice);#endif}// MERGE-GOURAUD ]]]// PRO-19 ]]]