/*------------------------------------------------------------------------------ * Virtus WalkThroughÂ                * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				David W. Easter *				Tim Kingsbury * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Platform: 	MACINTOSH 	X              *				WINDOWS		X * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VIO.h"#include "VArray.h"#include "VMemUtil.h"#include "VSound.h"#include "VGraphic.h"/*------------------------------------------------------------------------------ * void V_Buffer::cBuffer(int dir) * Constructor for the V_Buffer class.  Sets the direction of IO. *------------------------------------------------------------------------------*/void V_Buffer::cBuffer(int dir){position=0;direction=dir;buffer=NULL;cryptOn=FALSE;chunkData.size=-1;chunkData.position=0;chunkStack=NULL;}/*------------------------------------------------------------------------------ * void V_Buffer::dBuffer() * Destructor for the V_Buffer class. *------------------------------------------------------------------------------*/void V_Buffer::dBuffer(void){if(buffer)buffer->dArray();if(chunkStack!=NULL)chunkStack->dArray();delete(this);}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/void V_Buffer::Verify(void){if(buffer==0)	{	buffer=new(V_Array);//	buffer->cArray(0,1,256);	buffer->cArray(0,1,4096);	}}/*------------------------------------------------------------------------------ * int V_Buffer::IO(void *data,long length) * int V_Buffer::IOType(void * data,int type) * int V_Buffer::IOPosition(void *data,long length,long position) * int V_Buffer::IOTypePosition(void *data,int type, long position) *------------------------------------------------------------------------------*/int V_Buffer::IOData(void *data,long length){//jam 12-15-93 alter to handle segment crossing [[[#if WINDOWSchar huge *dataTo;char huge *dataFrom;char *writepos, *readpos;long posKey;long i;long lenXferd;long endPosition=position+length;int err = FALSE;VSetCursor(vCursorEarth);Verify();if(direction==DATA_OUT)	{	//need to alter setlength?	if(buffer->ALength()<endPosition)err=buffer->SetLength(endPosition);	lenXferd = length;    // Setup the vars for ENcrypting To the buffer. See VIO and VFILEWIN	//gjr Oct24,94 	dataFrom=(char huge *)data;	dataTo  =(char huge *)buffer->Use();	dataTo +=position;	posKey  =position;	     // The following copy/xxcrypt code is mostly direction independent. See VIO and VFILEWIN.	writepos = (char *)dataTo;	readpos = (char *)dataFrom;	if((OFFSETOF(writepos) < OFFSETOF(writepos + lenXferd)) &&	  (OFFSETOF(readpos) < OFFSETOF(readpos + lenXferd)) &&	  (lenXferd < 0x00010000L))		{		if(cryptOn){EnCrypt(writepos,readpos,lenXferd,posKey);}		else			{			if(lenXferd>8){Vmemcpy(writepos,readpos,lenXferd);}			else {for(i=0; i<lenXferd; i++, readpos++, writepos++){*writepos = *readpos;}}            }		}	else		{  // use huge ptrs byte by byte to avoid seg crossing problems		if(cryptOn)			{			for (i=0;i<lenXferd;i++)				{				EnCrypt(&dataTo[i], &dataFrom[i], 1, posKey+i);                }			}		else        	{			for(i=0;i<lenXferd;i++)dataTo[i] = dataFrom[i];            }		}	position += lenXferd;	buffer->Unuse();	}else if(direction==DATA_IN)	{	long end;		if(chunkData.size==-1)end=buffer->ALength();	else end=chunkData.position+chunkData.size;	if(end<endPosition)		{		length-=(endPosition-end);		if(length<0)			return -1;		else if(length==0)			return TRUE;		else			err = TRUE;		}	lenXferd = length;	// Setup the vars for DEcrypting From the buffer. See VIO and VFILEWIN	//gjr Oct24,94	dataTo   =(char huge *)data;	dataFrom =(char huge *)buffer->Use();	dataFrom+=position;    posKey   =position;	// The following copy/xxcrypt code is mostly direction independent. See VIO and VFILEWIN.	//jam	writepos = (char *)dataTo;	readpos = (char *)dataFrom;	if((OFFSETOF(writepos) < OFFSETOF(writepos + lenXferd)) &&	  (OFFSETOF(readpos) < OFFSETOF(readpos + lenXferd)) &&	  (lenXferd < 0x00010000L))		{		if(cryptOn){DeCrypt(writepos,readpos,lenXferd,posKey);}		else			{			if(lenXferd>8){Vmemcpy(writepos,readpos,lenXferd);}			else {for(i=0; i<lenXferd; i++, readpos++, writepos++){*writepos = *readpos;}}            }		}	else		{		if(cryptOn)			{			for (i=0;i<lenXferd; i++)				{				DeCrypt(&dataTo[i], &dataFrom[i], 1, posKey+i);        		}			}		else        	{			for(i=0;i<lenXferd;i++)dataTo[i] = dataFrom[i];        	}		}	position += lenXferd;	buffer->Unuse();	}return err;#else	//macintosh or power pcchar *dataTo;char *dataFrom;long i;long endPosition=position+length;int err = FALSE;VSetCursor(vCursorEarth);Verify();if(direction==DATA_OUT)	{	dataFrom=(char *)data;    //need to alter setlength?	if(buffer->ALength()<endPosition)err=buffer->SetLength(endPosition);	dataTo=(char *)buffer->Use();	if (cryptOn){EnCrypt(&dataTo[position],dataFrom,length,position);position+=length;}	else if(length>8){Vmemcpy(&(dataTo[position]),dataFrom,length);position+=length;} 	else for(i=0; i<length;i++,position++)dataTo[position]=dataFrom[i];	buffer->Unuse();	}else if(direction==DATA_IN)	{	long end;		dataTo=(char *)data;	if(chunkData.size==-1)end=buffer->ALength();	else end=chunkData.position+chunkData.size;	if(end<endPosition)		{		length-=(endPosition-end);		if(length<0)			return -1;		else if(length==0)			return TRUE;		else			err = TRUE;		}	dataFrom=(char *)buffer->Use();	if(cryptOn){DeCrypt(dataTo,&dataFrom[position],length,position);position+=length;}	else if(length>8){Vmemcpy(dataTo,&dataFrom[position],length);position+=length;}	else for(i=0; i<length;i++,position++)dataTo[i]=dataFrom[position];	buffer->Unuse();	}return err;#endif //WINDOWS//jam 12-15-93 alter to handle segment crossing ]]]}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/int V_Buffer::IOType(void * data,int type){IEEE_DOUBLE  dIn;IEEE_DOUBLE *dblPtr;double dOut;long length;int err;char c;char *cdata;switch(type)	{	case IO_CHAR:				err=IOData(data,1L);	break;	case IO_SHORT:		#if WINDOWS		cdata=(char *)data;		c=cdata[0];		cdata[0]=cdata[1];		cdata[1]=c;#endif //WINDOWS		err=IOData(data,2L);#if WINDOWS		cdata=(char *)data;		c=cdata[0];		cdata[0]=cdata[1];		cdata[1]=c;#endif //WINDOWS		break;	case IO_LONG:		#if WINDOWS		cdata=(char *)data;		c=cdata[0];		cdata[0]=cdata[3];		cdata[3]=c;		c=cdata[1];		cdata[1]=cdata[2];		cdata[2]=c;#endif //WINDOWS		err=IOData(data,4L);#if WINDOWS		cdata=(char *)data;		c=cdata[0];		cdata[0]=cdata[3];		cdata[3]=c;		c=cdata[1];		cdata[1]=cdata[2];		cdata[2]=c;#endif		break;	case IO_DOUBLE:		dblPtr = (IEEE_DOUBLE*)data;		dIn = (IEEE_DOUBLE)*dblPtr;		*dblPtr=dIn;		data=dblPtr;#if WINDOWS		cdata=(char *)data;		c=cdata[0];		cdata[0]=cdata[7];		cdata[7]=c;		c=cdata[1];		cdata[1]=cdata[6];		cdata[6]=c;		c=cdata[2];		cdata[2]=cdata[5];		cdata[5]=c;		c=cdata[3];		cdata[3]=cdata[4];		cdata[4]=c;#endif //WINDOWS		err=IOData(data,8L);#if WINDOWS		cdata=(char *)data;		c=cdata[0];		cdata[0]=cdata[7];		cdata[7]=c;		c=cdata[1];		cdata[1]=cdata[6];		cdata[6]=c;		c=cdata[2];		cdata[2]=cdata[5];		cdata[5]=c;		c=cdata[3];		cdata[3]=cdata[4];		cdata[4]=c;#endif //WINDOWS		dblPtr = (IEEE_DOUBLE*)data;		dOut = (double)*dblPtr;		*dblPtr=dOut;        data=dblPtr;		break;	case IO_PSTRING:		cdata=(char *)data;		if(direction==DATA_OUT)			err=IOData(data,cdata[0]+1); 		else 			{			err=IOData(data,1L);			if(!err)err=IOData(&cdata[1],cdata[0]);			}		break;	case IO_SHORT_I:#if MACINTOSH		cdata=(char *)data;		c=cdata[0];		cdata[0]=cdata[1];		cdata[1]=c;#endif //MACINTOSH		err=IOData(data,2L);#if MACINTOSH		cdata=(char *)data;		c=cdata[0];		cdata[0]=cdata[1];		cdata[1]=c;#endif //MACINTOSH		break;	case IO_LONG_I:		#if MACINTOSH		cdata=(char *)data;		c=cdata[0];		cdata[0]=cdata[3];		cdata[3]=c;		c=cdata[1];		cdata[1]=cdata[2];		cdata[2]=c;#endif //MAINTOSH		err=IOData(data,4L);#if MACINTOSH		cdata=(char *)data;		c=cdata[0];		cdata[0]=cdata[3];		cdata[3]=c;		c=cdata[1];		cdata[1]=cdata[2];		cdata[2]=c;#endif		break;	case IO_DOUBLE_I:		dblPtr = (IEEE_DOUBLE*)data;		dIn = (IEEE_DOUBLE)*dblPtr;		*dblPtr=dIn;		data=dblPtr;#if MACINTOSH		cdata=(char *)data;		c=cdata[0];		cdata[0]=cdata[7];		cdata[7]=c;		c=cdata[1];		cdata[1]=cdata[6];		cdata[6]=c;		c=cdata[2];		cdata[2]=cdata[5];		cdata[5]=c;		c=cdata[3];		cdata[3]=cdata[4];		cdata[4]=c;#endif //WINDOWS		err=IOData(data,8L);#if MACINTOSH		cdata=(char *)data;		c=cdata[0];		cdata[0]=cdata[7];		cdata[7]=c;		c=cdata[1];		cdata[1]=cdata[6];		cdata[6]=c;		c=cdata[2];		cdata[2]=cdata[5];		cdata[5]=c;		c=cdata[3];		cdata[3]=cdata[4];		cdata[4]=c;#endif //WINDOWS		dblPtr = (IEEE_DOUBLE*)data;		dOut = (double)*dblPtr;		*dblPtr=dOut;        data=dblPtr;		break;	default:		err=-1111;		break;	}//if(err)//	VPlaySound(beepSound);return err;}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/int V_Buffer::IOPosition(void *data,long length,long pos){int err;err=IOSetPosition(pos);if(!err)err=IOData(data,length);return err;}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/int V_Buffer::IOTypePosition(void *data,int type, long pos){int err;err=IOSetPosition(pos);if(!err)err = IOType(data,type);return err;}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/int V_Buffer::IODirection(void){return direction;}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/int V_Buffer::IOSetPosition(long pos){position=pos;return 0;}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/long V_Buffer::IOGetPosition(){return(position);}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/int V_Buffer::IOSetDirection(int dir){direction=dir;return 0;}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/int V_Buffer::IOLength(long* l){if(buffer)	*l=buffer->ALength();else *l=0;return 0;}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/int V_Buffer::IO(V_Buffer *theBuffer){int err;char *data;Verify();data=(char *)buffer->Use();err=theBuffer->IOData(data,buffer->ALength());buffer->Unuse();return(err);}intV_Buffer::GetBufferType(void){	return(V_BUFFERTYPE);}/*------------------------------------------------------------------------------EnCrypt/DeCrypt	Prevent Voyager databases from easily being installed into other's Walkthroughs.	Prevent users from replacing Voyager database portion with their own.		(i.e., keep those receiving database from mix and matching their own)	Prevent further export.	Simple encrypted form.(KISS)	Should still be compressible (==> dissallows excessive randomization)									(==> short keylengths only )	Immune to big-endian/little-endian concerns (==> just do chars)		Method:		Use a small (prime) number of different substitution ciphers.  Drive each		substitution keypad with a easy-change, easy-to-verify algorithm rather than		full tables.		For each series of bytes (mod key length)		add a different key value per byte (add causes internal carries)		then eor yet a different key value per byte.		This is equivalent to MAX_KEYSTRIDE different 256 long substitution ciphers.		Use a non-power of 2 for keyStride to prevent easy hexdump analysis. *------------------------------------------------------------------------------*/ #define MAX_KEYSTRIDE (5)int  keyStride = MAX_KEYSTRIDE;typedef struct keyPads_s keyPads_t ;struct keyPads_s{ char add; char eor; };keyPads_t keyPads[MAX_KEYSTRIDE] =							{  /* add, eor  */								{0xAE, 0xAE},								{0xB6, 0xB6},								{0x3A, 0x3A},								{0x6C, 0x6C},								{0xDA, 0xDA},							};					 /*------------------------------------------------------------------------------ *	void	SetCryptOn(void); *	Enable encryption for this buffer. *------------------------------------------------------------------------------*/void	V_Buffer::SetCryptOn(void){	cryptOn = TRUE;}	/*------------------------------------------------------------------------------ *	void	SetCryptOff(void); *	Disable encryption for this buffer. *------------------------------------------------------------------------------*/void	V_Buffer::SetCryptOff(void){	cryptOn = FALSE;}/*------------------------------------------------------------------------------ 	void	EnCrypt(char *to_ptr, char *from_ptr, long length, long keypad_idx);*------------------------------------------------------------------------------*/void	V_Buffer::EnCrypt(char *OUTto_ptr, char *INfrom_ptr, long INlength, long INkeypad_idx){char	*to_ptr;	/* output bytes after encryption */char	*from_ptr;	/* input bytes for encryption */long	 length;	/* number of bytes to encrypt */long	 keypad_idx;	/* which keypad to start with (usually use position) */int j;			/* temp loop counter */char ichar;		/* temp char holder */keyPads_t	*keyPads_ptr;	/* pointer into encryption keypads array */to_ptr		= OUTto_ptr;from_ptr	= INfrom_ptr;length		= INlength;keypad_idx	= INkeypad_idx;keypad_idx  = (keypad_idx % keyStride);		/* keep starting keypad in range */keyPads_ptr = &keyPads[keypad_idx];for (j=0; j<length; j++)	{	ichar  = from_ptr[j];		ichar += keyPads_ptr->add;		/* encode is in add.eor order */	ichar ^= keyPads_ptr->eor;	to_ptr[j] = ichar;								keyPads_ptr += 1;	/* cycle through the pads */	if (keyPads_ptr >= &keyPads[keyStride]) keyPads_ptr = &keyPads[0];	}}/*------------------------------------------------------------------------------	void	DeCrypt(char *to_ptr, char *from_ptr, long length, long keypad_idx); *------------------------------------------------------------------------------*/void	V_Buffer::DeCrypt(char *OUTto_ptr, char *INfrom_ptr, long INlength, long INkeypad_idx){char	*to_ptr;	/* output bytes after decryption */char	*from_ptr;	/* input bytes for decryption */long	 length;	/* number of bytes to decrypt */long	 keypad_idx;	/* which keypad to start with (usually use position) */int j;			/* temp loop counter */char ichar;		/* temp char holder */keyPads_t	*keyPads_ptr;	/* pointer into encryption keypads array */to_ptr		= OUTto_ptr;from_ptr	= INfrom_ptr;length		= INlength;keypad_idx	= INkeypad_idx;keypad_idx  = (keypad_idx % keyStride);		/* keep starting keypad in range */keyPads_ptr = &keyPads[keypad_idx];for (j=0; j<length; j++)	{	ichar  = from_ptr[j];		ichar ^= keyPads_ptr->eor;	ichar -= keyPads_ptr->add;	/* sub since we're decrypting an add */	to_ptr[j] = ichar;								keyPads_ptr += 1;	/* cycle through the pads */	if (keyPads_ptr >= &keyPads[keyStride]) keyPads_ptr = &keyPads[0];	}}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/long V_Buffer::OpenChunkR(){long id, size;int err=0;PushChunk();err=IOType(&id,IO_LONG);if(!err)err=IOType(&size,IO_LONG);chunkData.size=size;chunkData.position=position;if(err)PopChunk();if(!err)return(id);else return(0);}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/int V_Buffer::OpenChunkW(long id){long size;int err=0;PushChunk();chunkData.size=size=0;err=IOType(&id,IO_LONG);if(!err)IOType(&size,IO_LONG);chunkData.position=position;if(err)PopChunk();return(err);}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/void V_Buffer::CloseChunk(){if(direction==DATA_IN)IOSetPosition(chunkData.position+(chunkData.size+1&~1));else	{	long endPosition=position,size;	char zero=0;	chunkData.size=size=endPosition-chunkData.position;	IOTypePosition(&size,IO_LONG,chunkData.position-4);	IOSetPosition(endPosition);	if(chunkData.size&1)IOData(&zero,1);	}PopChunk();}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/void V_Buffer::PushChunk(){struct ChunkData data;if (chunkStack==NULL)	{	chunkStack=new(V_Array);	chunkStack->cArray(0,sizeof(struct ChunkData),4);	}if (chunkData.size!=-1)	{	data=chunkData;	chunkStack->Append(&data);	}}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/void V_Buffer::PopChunk(){int len=chunkStack->ALength();struct ChunkData data;if (len==0)chunkData.size=-1;else	{	chunkStack->Get(len-1,&data);	chunkStack->Remove(len-1);	chunkData=data;	}}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/long V_Buffer::ChunkSize(){return(chunkData.size-(position-chunkData.position));}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/void V_Buffer::SetRefCon(long rval){refCon=rval;}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/long V_Buffer::GetRefCon(void){return refCon;}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/int V_Buffer::IOInsert(long position,long size){long i,length=buffer->ALength();char *data;Verify();buffer->SetLength(length+size);data=(char *)buffer->Use();for(i=length-1;i>=position;i--)data[i+size]=data[i];buffer->Unuse();return 0;}int V_Buffer::IODelete(long position,long size){long i,length=buffer->ALength();char *data;Verify();data=(char *)buffer->Use();for(i=position+size;i<length;i++)	data[i-size]=data[i];buffer->Unuse();buffer->SetLength(length-size);return 0;}int V_Buffer::IOSetLength(long length){Verify();buffer->SetLength(length);return 0;}/*------------------------------------------------------------------------------ * V_IO * int V_IO::IO(V_Buffer *buffer) * Any class that uses V_IO as its base class can be treated as a vanilla IO * object and can therefore be manipulated directly via the IO method.  This * of course implies that this method MUST be rederived for it to be at all useful. *------------------------------------------------------------------------------*/int V_IO::IO(V_Buffer *buffer){return FALSE; }