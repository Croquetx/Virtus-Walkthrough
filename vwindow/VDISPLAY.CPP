 /*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				 *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VDisplay.h"#include "VWindow.h"#include "VPane.h"#include "VArray.h"#include "VFile.h"#include "VMemUtil.h"#include "VDialog.h"#include "VGUtil.h"#include "VGraphic.h"#include "VMain.h"#include <math.h>			// ABD MERGE-DITHER made this a system file#include "Clip.h"#include "WalkBuff.h"		// ABD MERGE6 WILLIAMS 8/27/93#include "vdebug.h"#include "verror.h"#include "VColor.h"#include "apptext.h"		//PRO-JAP#include "vmdl.h"	// jca 14 Sept 93#if WINDOWS#include "DOS.h"		// DOS segment handlers		GJR 10/20/93						// Note: huge can't store across seg boundaries with single op#define SPANNEDHUGE(farptr, hifarptr) ((unsigned) FP_OFF(farptr) > (unsigned) FP_OFF(hifarptr))#include <mmsystem.h>    // jca. to do the BlitMask stuffvoid C2Pstr(strPtr str);	//temporary for testing JAMWORD	gwBmWidth;WORD	gwBmHeight;WORD	gwBmWidthBytes;LPBYTE	glpbBmBits;WORD	gwBmPlanes;WORD   	gwBmBitsPixel;WORD	gwBmSegmentIndex;WORD	gwBmScanSegment;WORD	gwBmFillBytes;BOOL gfBmOk;/* now used on mac, too.  jca.  see belowextern LONG *gplFRedColor = NULL;extern LONG *gplFGreenColor = NULL;extern LONG *gplFBlueColor = NULL;*/struct V_Array *gvaBmRowAddresses;LPBYTE *glpbBmRowAddresses;#ifdef gjrTryDibsHBITMAPINFO		hbmiDibBmiPal  = NULL;LPBITMAPINFO	lpbmiDibBmiPal = NULL;#endif  // gjrTryDibs#elif MACINTOSHextern int useQDFlag;#include <QDOffscreen.h>#endif //WINDOWSextern LONG *gplFRedColor = NULL;extern LONG *gplFGreenColor = NULL;extern LONG *gplFBlueColor = NULL;int usePlatformDrawFlag=FALSE;int gwUserFlash = FALSE;int gwSampleMethodInit = 0;int inOffScreen=FALSE;V_Offscreen *nilPort = NULL;int theDepth = 0;int colorQD = 0;V_Offscreen *currentscreen=NULL;V_Offscreen *offscreen=NULL;V_Array *screen=NULL;VCGrafPort mainPort=NULL;VGrafDevice mainDevice=NULL;VGrafDevice dummyDevice = NULL;RGBColor	*dummyColorPtr=NULL;#define IFF_PICT MakeID('P','I','C','T')int UsePlatformDraw(int tf)	{	int sQD=usePlatformDrawFlag;	usePlatformDrawFlag=tf;	return sQD;	}//-----------------------------------------------------------------------------// int VSetUserFlash(int wINSetBool)//			Set user request for flash (True for flash).//-----------------------------------------------------------------------------intVSetUserFlash(int wINSetBool){   	int oldFlashSetting = gwUserFlash;	gwUserFlash = wINSetBool;       		return(oldFlashSetting);    // jca 10JAN93}//-----------------------------------------------------------------------------// int vGetUserFlash()//			Get user request for flash (True for flash).//-----------------------------------------------------------------------------intVGetUserFlash(void){	return(gwUserFlash);}//-----------------------------------------------------------------------------// int vGetFlashAble()//			Get if our hardware/system supports flash.//			See ANewBitmap for setting it true if flashable.//			This is a sticky setting --- any flash at all sets it.//-----------------------------------------------------------------------------intVGetFlashAble(){	return (gwSampleMethodInit);}#if MACINTOSHpascal void GetPICTData(Ptr dataPtr,int byteCount);int UseQD(int tf){int sQD=useQDFlag;useQDFlag=tf;return sQD;}#elif WINDOWSextern LONG gjrOldPolyFillMode;extern LONG gjrOldROP2;HDC VGetDC(HWND hwnd)	{	HDC hdc;	hdc = GetDC(hwnd);    // ALTERNATE is faster, but the Diamond Stealth can't deal. jca.	gjrOldPolyFillMode = SetPolyFillMode(hdc, WINDING);	gjrOldROP2 = SetROP2(hdc, R2_COPYPEN);	return hdc;	}HDC	VCreateCompatibleDC(HDC hdc)	{	HDC hdcNew;	hdcNew = CreateCompatibleDC(hdc);	// ALTERNATE is faster, but the Diamond Stealth can't deal. jca.	gjrOldPolyFillMode = SetPolyFillMode(hdc, WINDING);	gjrOldROP2 = SetROP2(hdc, R2_COPYPEN);	return hdcNew;	}void VReleaseDC(HWND hwnd,HDC hdc)	{	ReleaseDC(hwnd,hdc);	}#endif //MACINTOSHvoid V_Display::SetDisplayType(int tp) { displayType=tp; }// DAS-VWINDOWS 10/9/93int V_Display::GetDisplayType()  { return displayType; }// DAS-VWINDOWS 10/9/93// ?? if we don't use the return values, make it void??int V_Display::Begin() {return 0; }int V_Display::End() {return 0; }int V_Display::GetDepth() { return FindDepth(); }int V_Display::ColorsRemapped() {return FALSE; }void V_Display::SetDepth(int depth)	{	if(colorQD) bitDepth=depth;	else bitDepth=0;	}voidV_Display::SetDisplayPort()	{#if WINDOWS	HFONT 	hFont;	HPEN 	hPen;	HBRUSH 	hBrush;	hBrush = GetStockObject(BLACK_BRUSH);	oldBrush = SelectObject(metaPort,hBrush);	hPen = GetStockObject(BLACK_PEN);	oldPen = SelectObject(metaPort,hPen);	hFont = GetStockObject(SYSTEM_FONT);	oldFont = SelectObject(metaPort,hFont);	if (currentPalette)    	{		oldPalette = SelectPalette(metaPort, currentPalette, FALSE);        }	oldDevice = currentDevice;#endif //WINDOWS	}void V_Display::UnsetDisplayPort()	{#if WINDOWS	HFONT 	hFont;	HPEN 	hPen;	HBRUSH 	hBrush;	HPALETTE hPalette;	hBrush = SelectObject(metaPort,oldBrush);	DeleteObject(hBrush);	hPen = SelectObject(metaPort,oldPen);	DeleteObject(hPen);	hFont = SelectObject(metaPort,oldFont);	// DeleteObject(hFont);  Fonts are cached and all deleted when the program exits	if (currentPalette)		{	// then deselect it		hPalette = SelectPalette(metaPort, oldPalette, FALSE);        }	// DeleteObject(hPalette); Palettes are deleted in ReleaseGraphics	oldBrush = NULL;	oldPen = NULL;	oldFont = NULL;	oldPalette = NULL;	SetGraphicContext(oldDevice);#endif //WINDOWS	}void V_Display::GetRect(Rect *r) { *r=rect; }void V_Display::PutRect(Rect *r) { rect=*r; }VGrafData V_Display::GetMetaPort(Rect *r) { return NULL; }void V_Display::ReleaseMetaPort(VGrafData data) { }int BlitRepeat = 1;voidV_Display::Blit(VGrafData fromPort,VGrafData toPort,Rect *from,Rect *to,long mode)	{#if MACINTOSH	CopyBits(fromPort,toPort,from,to,mode,NULL);#elif WINDOWS	int i;	for (i=0; i<BlitRepeat; i++)    	{		// Test if StretchBlt is needed				//GJR 10/01/93 [[[		//  (Windows only detects scaling if bitmap's internal scaling differs)    	if ( (from->right-from->left == to->right-to->left)    	  && (from->bottom-from->top == to->bottom-to->top) )    	  	{			BitBlt(toPort,to->left,to->top,(from->right-from->left),(from->bottom-from->top),				fromPort,from->left,from->top,mode);			}		else			{  // Need stretch blt			Int	oldStretchBltMode;						// Want the nicest color compress Windows offers.			oldStretchBltMode = SetStretchBltMode(toPort, STRETCH_DELETESCANS);			StretchBlt(toPort,   to->left,  to->top,   (to->right-to->left),     (to->bottom-to->top),					   fromPort, from->left,from->top, (from->right-from->left), (from->bottom-from->top),					   mode);			SetStretchBltMode(toPort, oldStretchBltMode);			}													//GJR 10/01/93 ]]]				}#endif //WINDOWS	}	voidV_Display::BlitMask(VGrafData fromPort,VGrafData toPort,VGrafData maskPort,Rect *from,Rect *to,Rect *maskR,long mode)	{#if MACINTOSH	CopyMask(fromPort,maskPort,toPort,from,maskR,to);#elif WINDOWS/* the concepts for the windows routines come from the _Programmer's__Introduction_to_Windows_3.1_ by Myers and Doner, (c) 1992.  It hasbeen substantially rewritten. */	HBITMAP	localFromDib, oldDib, tempDib;	HDC		nullDC, localDC, tempDC;	Rect	r;	r.top = r.left = 0;	r.right = to->right - to->left;	r.bottom = to->bottom - to->top;    /* we need a dc equivalent to the screen to handle the image depth */	nullDC = GetDC(NULL);	localFromDib = CreateCompatibleBitmap(nullDC, r.right, r.bottom);    ReleaseDC(NULL, nullDC);	/* copy the image to mask in into this new bitmap */	localDC = CreateCompatibleDC(fromPort);	oldDib = SelectObject(localDC, localFromDib);	Blit(fromPort, localDC, from, &r, SRCCOPY);    /* create a temporary bitmap and dc to composite into */	tempDC = CreateCompatibleDC(toPort);	tempDib = CreateCompatibleBitmap(toPort,r.right, r.bottom );	SelectObject(tempDC, tempDib);    /* did we get them all ? */	if ((localFromDib == NULL) || (tempDib == NULL))		return;     /* !!!!!!!!! this probably should be better */	/* copy the dest to the temp (to get the background)	Note that we are buffering the compositing, so only	the final image is displayed */    Blit(toPort, tempDC, to, &r, SRCCOPY);    /* now black out the forground */	Blit(maskPort, tempDC, maskR, &r, SRCAND);	/* black out the background from the copy of the image.	Just NOT the mask and AND it to the destination */	Blit(maskPort, localDC, maskR, &r, 0x00220326);	/* XOR the temp and the copied images */	Blit(localDC, tempDC, &r, &r, SRCPAINT);	/* copy the composited image to the output bitmap,	which will get displayed somewhere */	Blit(tempDC, toPort, &r, to, SRCCOPY);	/* delete temporary bitmaps and DC's */    DeleteObject(SelectObject(localDC, oldDib));	DeleteObject(SelectObject(tempDC, oldDib));    DeleteDC(localDC);	DeleteDC(tempDC);#endif //WINDOWS	}voidV_Display::GetResolution(Point *p)	{    *p = resolution;	}voidV_Display::PutResolution(Point *p)	{	*p = resolution;	}// { DAS-VWIN 9/17/93int V_Display::SetMetaPort(void)	{	return 0;	}	void V_Display::UnsetMetaPort(void)	{	}// } DAS-VWIN 9/17/93/*------------------------------------------------------------------------------ *  V_Offscreen *  The V_Offscreen is an offscreen buffer that is used to draw an image which *  can then be transferred into a V_Pane.  On the Macintosh it may be implemented *  in any one of three ways depending upon the machine and the available  *  software release, either as a standard bitmap (see inside Mac Volume 1) or *  a PixMap (see Inside Mac Volume 5) or as a GWorld (see 32bit Quickdraw *  release notes).  The programmer typically does not need to worry about which *  environment he is operating in because the V_Offscreen will perform  *  correctly. *------------------------------------------------------------------------------ * void V_Offscreen::cOffscreen(Rect *size,int depth,RGBColor *rgb) * Rect *size;  Rectangle that indicates the size of the offscreen buffer. * int theDepth; this indicates the number of bits/pixel used. * RGBColor *rgb; if this is nonNULL the offscreen buffer is erase in this color. * * cOffscreen is a constructor of off screen bitmaps(if black and white) * and pixmaps(if color).  It also creates the supporting metaport.  For more * information about what this is doing, consult Inside Macintosh Volume 1- * Quickdraw, Inside Macintosh Volume 5-Color Quickdraw, and the 32-bit Quickdraw * programmer's manual. *------------------------------------------------------------------------------*/int V_Offscreen::cOffscreen(Rect *size,int depth,RGBColor *rgb, V_Array *ctab)	{	VCGrafPort savePort;	VGrafDevice saveDevice;	Rect r;	int err,result;    wMethodInit = 0;  // Don't use flash until told its ok...		resolution.h = resolution.v = 72; /* 72 pixels/inch */	err=FALSE;	lock = 0;	bitType = 0;	refCon = 0L;	screen = FALSE;		// NOT a main, physical screen	raster=NULL;	baseAddr=NULL;	bitmap=NULL;	SetDisplayType(DISPLAY_OFFSCREEN);	// DAS-VWINDOWS 10/9/93	bitDepth=depth;    // jca 16 Nov 93  depth may == -1, to ask for screen depth.  At the end we set bitDepth to be what we got.//	GrowMemory(FALSE);					// too general. Only encompass the big access.	ditherTable = NULL;	colorTable  = NULL;	vaFRedColor    = NULL;	vaFGreenColor  = NULL;	vaFBlueColor   = NULL;	#if MACINTOSH	MoveObjHi((Handle)this);#elif WINDOWS	oldBrush = NULL;	oldPen = NULL;	oldFont = NULL;	oldPalette = NULL;#endif //WINDOWS	rsize= *size;	rect = rsize;	clipRect=rsize;	rect.right-=rect.left;	rect.bottom-=rect.top;	rect.left=rect.top=0;	r=rect;		VGetPort(&savePort,&saveDevice);	#if MACINTOSH	if(!colorQD)/* color quickdraw is not present */		{		bitType=MONO_QD;		GrowMemory(FALSE);					//Only encompass the big access.	// GJR 10/26/93		 		metaPort=(CGrafPort *)NewPtr(sizeof(GrafPort));		GrowMemory(TRUE);														// GJR 10/26/93		/*-------Macintosh Bug Alert!!!------------------------------------		 * For some stupid reason the old color Quickdraw needs size to be		 * a word boundary.  It has been fixed in 32-bit quickdraw		 *------------------------------------------------------------------*/	/*	width=rect.right;		width=(1+(width>>4))<<4;*/		err = metaPort ? FALSE : -1;		if(!err)			{			err = ANewBitMap(&r) ? -1 : FALSE;			if(!err)				{				OpenPort((GrafPtr)metaPort);				RectRgn(((GrafPtr)metaPort)->visRgn,&r);				VSetPort(metaPort,NULL);				}			}					}	else		{		GWorldPtr gWorld;		CTabHandle	cTabH = NULL;        RGBColor	*rgbC;		int	i;		if (ctab) 	/* allocate the colortable */			{			rgbC = (RGBColor*)ctab->Use();			cTabH = (CTabHandle)NewHandle(sizeof(ColorTable) + VA_Length(ctab)*sizeof(ColorSpec));			HLock((Handle)cTabH);			(*cTabH)->ctSeed = GetCTSeed();			(*cTabH)->ctFlags = 0;			(*cTabH)->ctSize = VA_Length(ctab);			for (i = 0; i < VA_Length(ctab); i++)				{				(*cTabH)->ctTable[i].value = i;				(*cTabH)->ctTable[i].rgb = rgbC[i];				}            HUnlock((Handle)cTabH);            ctab->Unuse();            }		bitType=COLOR_QD;		if (depth == -1) depth = 0;		GrowMemory(FALSE);					//Only encompass the big access.	// GJR 10/26/93		 		result=NewGWorld(&gWorld, depth, size, cTabH, NULL,0);		GrowMemory(TRUE);					//Only encompass the big access.	// GJR 10/26/93		 		// ABD MERGE-TEXTURE removed line here 9/14/93 (moved below error check)		err = (result&gwFlagErr) ? -1 : FALSE;		if (!err)							// ABD MERGE-TEXTURE 9/14/93			metaPort=(VCGrafPort)gWorld;	// ABD MERGE-TEXTURE 9/14/93		if (!useQDFlag)		// ABD use flash 8/11/93			wMethodInit = 1;		if (!err)			// JCA make a table of offsets into bitmap 20 aug 93			GetGdiBitmapInfo();					if (cTabH)   /* free the colortable */			{			DisposHandle((Handle)cTabH);            }		}#elif WINDOWS#ifdef gjrTryDibs	cDib();#endif  // gjrTryDibs	mainDevice = VGetDC(NULL);	metaPort = VCreateCompatibleDC(mainDevice);	bitmap = CreateCompatibleBitmap(mainDevice,32,32);	ReleaseDC(NULL,mainDevice);	oldBitmap = SelectObject(metaPort,bitmap);	err = metaPort ? FALSE : -1;	if(!err) err = Resize(&r, RESIZE_STANDARD);#endif //WINDOWS	if(!err && rgb)		{		SetMetaPort();		VSetPattern(vPatBlack);		VForeColor(rgb);		VPaintRect(&rect);		VForeColor(&vBlack);		UnsetMetaPort();		}			VSetPort(savePort,saveDevice);		if (!err && (bitDepth == -1))   //  jca 16 Nov 93 -- Set the bitDepth value to be the right depth		bitDepth = GetDepth();      // (it may have been set to -1 to make this the depth of the screen) 	return err;	}// ABD MERGE-TEXTURE 9/13/93 [[[/*------------------------------------------------------------------------------ * RGBColor V_Offscreen::GetPixelColor(int h, int v) * Returns the color of the specified pixel * You need not call SetMetaPort() for this to work.  You used to have to, but not * any more.		// MERGE-DITHER *------------------------------------------------------------------------------*/RGBColor V_Offscreen::GetPixelColor(int h, int v){RGBColor c;int val;#if MACINTOSHVCGrafPort savePort;			// MERGE-DITHERVGrafDevice saveDevice;			// MERGE-DITHER		VGetPort(&savePort, &saveDevice);		// MERGE-DITHER	VSetPort(metaPort, gDevice);			// MERGE-DITHER	switch(bitType)	{	case MONO_QD:		if (GetPixel(h,v))		{c.red=c.green=c.blue=0x0000;}		else 		{c.red=c.green=c.blue=0xFFFF;}		break;	case COLOR_QD:		GetCPixel(h,v,&c);		break;	}	VSetPort(savePort, saveDevice);			// MERGE-DITHER	return c;#elif WINDOWS	{	COLORREF crOut;	crOut   = GetPixel(metaPort, h, v);			// GJR 11/22/93	c.red   = GetRValue(crOut);	c.blue  = GetBValue(crOut);	c.green = GetGValue(crOut);// shift into 16 bits   ?? straight shift or repeating decimal?	c.red   |= c.red<<8;    c.blue  |= c.blue<<8;	c.green |= c.green<<8;	return (c);	}#endif //MACINTOSH}// ABD MERGE-TEXTURE 9/13/93 ]]]// ABD MERGE-DITHER [[[/*------------------------------------------------------------------------------ * void V_Offscreen::SetPixelColor(int h, int v, RGBColor c) * Sets the specified pixel to the color which most closely matches the specified color. * You need not call SetMetaPort() for this to work.  You used to have to, but not * any more.		// MERGE-DITHER *------------------------------------------------------------------------------*/void V_Offscreen::SetPixelColor(int h, int v, RGBColor *c){#if MACINTOSHPenState pen;VCGrafPort savePort;			// MERGE-DITHERVGrafDevice saveDevice;			// MERGE-DITHER		VGetPort(&savePort, &saveDevice);		// MERGE-DITHER	VSetPort(metaPort, gDevice);			// MERGE-DITHER	switch(bitType)	{	case MONO_QD:		GetPenState(&pen);		PenNormal();		if ((c->red == 0xFFFF) && (c->green == 0xFFFF) && (c->blue == 0xFFFF))			PenPat(&white);		else			PenPat(&black);		MoveTo(h,v); 		Line(0,0);		SetPenState(&pen);		break;	case COLOR_QD:		SetCPixel(h, v, c);		break;	}	VSetPort(savePort, saveDevice);			// MERGE-DITHER#elif WINDOWS	{	// PALETTERGB tries to use the palette, then reverts back to RGB handling.	// RGB handling uses 20 system colors only.	// What happens with true color (8bit or greater) that have/have not palettes?    // Is true color used, or the scrawny pallete, or the system colors?	COLORREF crOut;	crOut = PALETTERGB(c->red>>8, c->green>>8, c->blue>>8);	// get byte versions	// GJR 11/22/93	SetPixel(metaPort, h, v, crOut);	}#endif //MACINTOSH}// ABD MERGE-DITHER ]]]int V_Offscreen::GetXOffset(void)#if MACINTOSH{return colorQD?(*metaPort->portPixMap)->bounds.left:metaPort->portRect.left;}#else //WINDOWS{return (0); }#endif //WINDOWSint V_Offscreen::GetYOffset(void)#if MACINTOSH{return colorQD?(*metaPort->portPixMap)->bounds.top:metaPort->portRect.top;}#else //WINDOWS{return (0); }#endif //WINDOWSint V_Offscreen::GetRowWidth(void)#if MACINTOSH{return colorQD?0x1FFF&(*metaPort->portPixMap)->rowBytes:(*bitmap)->rowBytes;}#else //WINDOWS{return (wBmWidthBytes * wBmPlanes); }	//NOT ACCURATE!!!	//GJR 10/11/93#endif //WINDOWSvoidV_Offscreen::SetGBmInfo(void){#if WINDOWS	gwBmWidth          = wBmWidth;	gwBmHeight         = wBmHeight;	gwBmWidthBytes     = wBmWidthBytes;	glpbBmBits         = lpbBmBits;	gwBmPlanes         = wBmPlanes;	gwBmBitsPixel      = wBmBitsPixel;	gwBmSegmentIndex   = wBmSegmentIndex;	gwBmScanSegment    = wBmScanSegment;	gwBmFillBytes      = wBmFillBytes;	gfBmOk             = fBmOk;	gvaBmRowAddresses  = vaBmRowAddresses;    glpbBmRowAddresses = lpbBmRowAddresses;#endif // WINDOWS}/*------------------------------------------------------------------------------ * int V_Offscreen::SetCurrent(void) *------------------------------------------------------------------------------*/#if WINDOWS#endif //WINDOWS#include "Flash.h"int (*FlashFill)(V_Offscreen *to,V_Array *points,	RGBColor *rgb,RGBColor *lineColor,int mode,int pattern);int (*FlashClip)(V_Offscreen *to,V_Array *points,	RGBColor *rgb,RGBColor *lineColor,Clip *clip,int mode,int pattern);	// MERGE-GOURAUD [[[int (*FlashGouraud)(V_Offscreen *to,V_Array *points,V_Array *intensities,	unsigned char rgb_index,RGBColor *lineColor,int mode,int pattern);int (*FlashGouraudClip)(V_Offscreen *to,V_Array *points,V_Array *intensities,	unsigned char rgb_index,RGBColor *lineColor,Clip *clip,int mode,int pattern);// MERGE-GOURAUD ]]]void V_Offscreen::SetCurrent(void){currentscreen=this;/*set up some local globals*/xOffset=GetXOffset();yOffset=GetYOffset();rowBytes=GetRowWidth();baseAddress=GetBaseAddr(); // jca 18 Sept 93.  is this necessary or desirable?  Tell if it // is.  It does muck with things a bit under Windows... //ELVIS bitDepth=GetDepth();SetGBmInfo();SetGFlashRoutines();}void V_Offscreen::UnSetCurrent(void){UnSetGFlashRoutines();}BOOLV_Offscreen::SetGFlashRoutines(void){BOOL bOk = FALSE;  // not ok till found a flash methodV_Offscreen 	*scrn;// Get Color Info// the color info is stable per screen, so access the parent physical screen.// First, see if the current bitmap is flashable (reachable memory)// Then, find our matching parent.  ?? Should match ANewBitMap depth method??// Finally, get color data from the parent.	if (screen)		{  // physical screen. At least get the color info going.		if (vaFRedColor != NULL)			{			gplFRedColor  =(LONG *)vaFRedColor->Use();			gplFGreenColor=(LONG *)vaFGreenColor->Use(); 			gplFBlueColor =(LONG *)vaFBlueColor->Use();	    	}		return (FALSE);		// Sorry, no flash routines for physical screens		}// Normal Offscreens. Find their parent and get the flash/color info.	ditherTable = NULL;	colorTable  = NULL;             // Prepare non-screens for no flash	vaFRedColor    = NULL;	vaFGreenColor  = NULL;	vaFBlueColor   = NULL;#if WINDOWS	if (!fBmOk) return (FALSE);     // Don't check further if non-flashable bitmap#endif //WINDOWS			scrn = FindScreenR(&rsize); // ?? Use This For Now ...??								// CAUTION: Gets called BEFORE BuildScreens	if (!scrn) return (FALSE);	//          So leave if no parent physical screen#if WINDOWS	if (!scrn->fBmOk) return (FALSE);	// Fail if parent couldn't get its flash bitmap info#endif //WINDOWS	ditherTable = scrn->ditherTable;	colorTable  = scrn->colorTable;	vaFRedColor   = scrn->vaFRedColor;	vaFGreenColor = scrn->vaFGreenColor;	vaFBlueColor  = scrn->vaFBlueColor;	if (vaFRedColor != NULL)	{		  gplFRedColor  =(LONG *)vaFRedColor->Use();		  gplFGreenColor=(LONG *)vaFGreenColor->Use(); 		  gplFBlueColor =(LONG *)vaFBlueColor->Use();    }#if WINDOWSswitch(wBmPlanes*wBmBitsPixel)  // depth of this bitmap#elif MACINTOSHswitch(GetDepth())#endif  //WINDOWS	{#if MACINTOSH	case 0:/*should never happen*/	case 1:		FlashClip= FlashClip1;		FlashFill= FlashFill1;		FlashGouraudClip= FlashGouraudClip1;		// MERGE-GOURAUD		FlashGouraud= FlashGouraud1;				// MERGE-GOURAUD		bOk = TRUE;		break;	case 2:		FlashClip= FlashClip2;		FlashFill= FlashFill2;		FlashGouraudClip= FlashGouraudClip2;		// MERGE-GOURAUD		FlashGouraud= FlashGouraud2;				// MERGE-GOURAUD		bOk = TRUE;		break;#endif	case 4:#if WINDOWS		if (wBmPlanes == 4)       		{			FlashClip= FlashClip4x1;			FlashFill= FlashFill4x1;			FlashGouraudClip= FlashGouraudClip4x1;		// MERGE-GOURAUD			FlashGouraud= FlashGouraud4x1;				// MERGE-GOURAUD			bOk = TRUE;			}		else#endif  //WINDOWS			{			FlashClip= FlashClip4;			FlashFill= FlashFill4;			FlashGouraudClip= FlashGouraudClip4;		// MERGE-GOURAUD			FlashGouraud= FlashGouraud4;				// MERGE-GOURAUD			bOk = TRUE;			}		break;	case 8:		FlashClip= FlashClip8;		FlashFill= FlashFill8;		FlashGouraudClip= FlashGouraudClip8;		// MERGE-GOURAUD		FlashGouraud= FlashGouraud8;				// MERGE-GOURAUD		bOk = TRUE;		break;	case 16:		FlashClip= FlashClip16;		FlashFill= FlashFill16;		FlashGouraudClip= FlashGouraudClip16;		// MERGE-GOURAUD		FlashGouraud= FlashGouraud16;				// MERGE-GOURAUD		bOk = TRUE;		break;#if WINDOWS	case 24:		FlashClip= FlashClip24;		FlashFill= FlashFill24;		FlashGouraudClip= FlashGouraudClip24;		// MERGE-GOURAUD		FlashGouraud= FlashGouraud24;				// MERGE-GOURAUD		bOk = TRUE;		break;#endif //WINDOWS	case 32:		FlashClip= FlashClip32; 		FlashFill= FlashFill32;		FlashGouraudClip= FlashGouraudClip32;		// MERGE-GOURAUD		FlashGouraud= FlashGouraud32;				// MERGE-GOURAUD		bOk = TRUE;		break;	}	return (bOk);}voidV_Offscreen::UnSetGFlashRoutines(void){	if (vaFRedColor != NULL)	{		  vaFRedColor->Unuse();		  vaFGreenColor->Unuse(); 		  vaFBlueColor->Unuse();    }			gplFRedColor  = NULL;  // Catch bad users//			gplFGreenColor= NULL;  // One is enough, leave others for debugging//			gplFBlueColor = NULL;}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/void V_Offscreen::cScreen(VGrafDevice aDevice)	{	VCGrafPort savePort;	VGrafDevice saveDevice;	Rect r;	resolution.h = resolution.v = 72; /* 72 pixels/inch */	lock = 0;	bitType = 0;	refCon = 0L;	raster=NULL;	baseAddr=NULL;	bitmap=NULL;    wMethodInit = 0;		// No flash for physical screens		SetDisplayType(DISPLAY_OFFSCREEN);	// DAS-VWINDOWS 10/9/93	VGetPort(&savePort,&saveDevice);	ditherTable = NULL;	colorTable  = NULL;	vaFRedColor    = NULL;	vaFGreenColor  = NULL;	vaFBlueColor   = NULL;	#if MACINTOSH	if(aDevice)/*color quickdraw is present*/		{		gDevice=aDevice;		SetGDevice(GetMainDevice());		metaPort=(CGrafPort *)NewPtr(sizeof(CGrafPort));		OpenCPort(metaPort);		rect=(**aDevice).gdRect;		bitType=COLOR_QD;		RectRgn(((GrafPtr)metaPort)->visRgn,&rect);		}	else		{		metaPort=(CGrafPort *)NewPtr(sizeof(GrafPort));		OpenPort((GrafPtr)metaPort);		rect=screenBits.bounds;		bitType=MONO_QD;		}	rsize    = rect;		// setup other rect info    clipRect = rect;	GetGdiBitmapInfo();		// jca.  do this to set up the strip offsets.	#elif WINDOWS	oldBrush = NULL;	oldPen = NULL;	oldFont = NULL;	oldPalette = NULL;	metaPort = VCreateCompatibleDC(aDevice);	bitmap = CreateCompatibleBitmap(aDevice,32,32);  // at least longword minimal flash testing size	oldBitmap = SelectObject(metaPort,bitmap);	rect.left=0;	rect.top=0;	rect.right=GetDeviceCaps(metaPort,HORZRES);	rect.bottom=GetDeviceCaps(metaPort,VERTRES);	rsize = rect;			// setup other rect info    clipRect = rect;	bitType=COLOR_QD;    bitDepth = GetDeviceCaps(metaPort,BITSPIXEL)*GetDeviceCaps(metaPort,PLANES);	GetGdiBitmapInfo(metaPort, bitmap);	ASSERT(bitDepth == wBmPlanes*wBmBitsPixel);#ifdef gjrTryDibs	cDib();#endif  // gjrTryDibs#endif //WINDOWS	screen=TRUE;		// Yes, i am a physical screen	VSetPort(savePort,saveDevice);	}/*------------------------------------------------------------------------------ * void V_Offscreen::cMask(V_Offscreen *source) * This is yet another V_Offscreen constructor that uses a source V_Offscreen to * create a mask BITMAP (note the caps).  Masks are always bitmaps instead of * pixmaps.  Even in color quickdraw. *------------------------------------------------------------------------------*/int V_Offscreen::cMask(V_Offscreen *source)	{	Rect r,rx;	int words;	int err;		resolution.h = resolution.v = 72; /* 72 pixels/inch */	source->GetRect(&r);	err=cOffscreen(&r,0,0,NULL);	if(!err)		{		source->SetMetaPort();		SetMetaPort();		switch(source->bitType)			{			case MONO_QD:				words=(15+r.right-r.left)>>4;	#if MACINTOSH				CalcMask ((*source->bitmap)->baseAddr,(*bitmap)->baseAddr,0,0,r.bottom-r.top,words);	#endif //MACINTOSH				break;			case COLOR_QD:				VEraseRect(&r);				source->MetaTo(this,&r,&r);		/*		CalcCMask(*source->metaPort->portPixMap,*bitmap,&r,&r,&vWhite,0L,0L);				VInvertRect(&r);*/				break;			}		source->UnsetMetaPort();		UnsetMetaPort();		}			return err;	}void V_Offscreen::dOffscreen()	{	VHBitmap hBitmap;		if(lock)	{#if DEBUG		AlertMessage((strPtr)"V_Offscreen is locked in dOffscreen.");		DEBUGGER();		// ABD#endif	}#if MACINTOSH	switch(bitType)		{		case MONO_QD:			if(!screen)				{				if(baseAddr)DisposHandle((Handle)baseAddr);				if(bitmap)DisposHandle((Handle)bitmap);				}			if(metaPort)				{				ClosePort((GrafPtr)metaPort);				DisposPtr((Ptr)metaPort);				}			break;		case COLOR_QD:			if(!screen && metaPort) DisposeGWorld(metaPort);			else 				{				if(screen!=2)ClosePort((GrafPtr)metaPort);				if(metaPort)DisposPtr((Ptr)metaPort);				}			break;		}	if (raster)	raster->dArray();    // jca 9 Oct 93#elif WINDOWS	hBitmap = SelectObject(metaPort,oldBitmap);	if(hBitmap != oldBitmap) DeleteObject(hBitmap);	DeleteDC(metaPort);	// this may cause weird problems, but it solves a memory leak.	if (vaBmRowAddresses)	vaBmRowAddresses->dArray();       // jca 1 Nov 93#ifdef gjrTryDibs	dDib();#endif  // gjrTryDibs#endif //WINDOWS	if (screen)		// only physical screens know about colors		{		if(ditherTable)ditherTable->dArray();		if(colorTable)colorTable->dArray();		if(vaFRedColor)vaFRedColor->dArray();		if(vaFGreenColor)vaFGreenColor->dArray();		if(vaFBlueColor)vaFBlueColor->dArray();        }	delete(this);	}int V_Offscreen::ANewBitMap(Rect *cr)	{	VHBitmap hBitmap;	long rowBytes;	/*number of bytes in one row*/	long sizeOfOff;		/*size in bytes of the off screen bit map*/	Rect brect;	int err;		brect.top=0;	brect.left=0;	brect.bottom=max(1, cr->bottom-cr->top);	brect.right=max(1, cr->right-cr->left);    brect.right = brect.right + 8;				// allow at least window alignment by 8 bits    brect.right = (brect.right+31)&~31;		// force at least longword (or longer) align		rowBytes = ((brect.right+15)>>4)<<1;		// BUG- only works for 8bit textures	sizeOfOff = rowBytes*brect.bottom;	#if MACINTOSH	if(baseAddr)DisposHandle((Handle)baseAddr);	if(bitmap)DisposHandle((Handle)bitmap);	GrowMemory(FALSE);					//Only encompass the big access.	// GJR 10/26/93		 	err = (bitmap=(BitMap**)NewHandle(sizeof(BitMap))) ? FALSE : -1;	if(!err) err = (baseAddr=NewHandle(sizeof(sizeOfOff))) ? FALSE : -1;	GrowMemory(TRUE);					//Only encompass the big access.	// GJR 10/26/93		 	if(!err)		{		(*bitmap)->rowBytes = rowBytes;		(*bitmap)->bounds = brect;		}	GetGdiBitmapInfo();		// jca.  do this to set up the strip offsets.	if (!useQDFlag)				// ABD 8/11/93 make us use flash unless QD flag is set		wMethodInit = 1;#elif WINDOWS#ifdef gjrTryDibs	ResizeDib(brect.right, brect.bottom);#endif  // gjrTryDibs	err = (bitmap=CreateCompatibleBitmap(metaPort,brect.right,brect.bottom)) ? FALSE : -1;	hBitmap = SelectObject(metaPort,bitmap);	DeleteObject(hBitmap);	wMethodInit = 0;  // presume the worst -- no flash	GetGdiBitmapInfo(metaPort, bitmap);	if (fBmOk)		{		BOOL bOk = SetGFlashRoutines();		if (bOk)			{			wMethodInit = 1;			}        UnSetGFlashRoutines();		}	if (wMethodInit != 0)    	{	// then stick sample on if EVER able to flash		gwSampleMethodInit = wMethodInit;				}    SetCurrent();   // done here for good luck.	UnSetCurrent();#endif //WINDOWS			return err;	}int  V_Offscreen::IsFlashOn(void) { int yes; yes = wMethodInit;  return(yes); }void V_Offscreen::GetRect(Rect *r) { *r=rect; }void V_Offscreen::SetClip(Rect *r) { clipRect=*r; }void V_Offscreen::GetClip(Rect *r) { *r=clipRect; }int V_Offscreen::GetDepth(void)	{	int dpth;	if(screen)		dpth = RectDepth(&rect);	else#if MACINTOSH	switch(bitType)		{		case MONO_QD: dpth = 0; break;		case COLOR_QD:dpth = (*metaPort->portPixMap)->pixelSize; break;		}#elif WINDOWS		dpth = FindDepth();#endif //WINDOWS		return dpth;	}RGBColorV_Offscreen::IndexToColor(int index)	{	RGBColor color;#if MACINTOSH	switch(bitType)		{		case MONO_QD: color = (index==0) ? vWhite : vBlack; break;		case COLOR_QD: color = (*(*metaPort->portPixMap)->pmTable)->ctTable[index].rgb; break;		}#elif WINDOWS	color = (index==0) ? vWhite : vBlack;#endif //WINDOWS	return color;	}// Moved to VColor//int //V_Offscreen::ColorToIndex(RGBColor c)//	{//		DEBUGGER();//		return 0;//	}/*------------------------------------------------------------------------------ * void V_Offscreen::MetaTo(V_Display * theObject,Rect *rfrom,Rect *rto) * void V_Offscreen::ToMeta(V_Display * theObject,Rect *rfrom,Rect *rto) * void V_Offscreen::MetaToMode(V_Display *theObject,Rect *rfrom,Rect *rto,long mode) * void V_Offscreen::ToMetaMode(V_Display *theObject,Rect *rfrom,Rect *rto,long mode) * void V_Offscreen::MaskMetaTo(V_Display *theObject,V_Offscreen *mask,Rect *rfrom,Rect *rto) * V_Display *theObject;  where we are transferring to or from, this is either another *					V_Offscreen or a V_Window. * Rect *rfrom;  what part are we transferring and where are we transferring it to? * Rect *rto; * int mode; 	 what is the transfer mode? (OR,XOR,AND...) * V_Offscreen *mask; this is used to force the V_Offscreen to copy only where the *					mask is nonzero. * These are the various V_Offscreen transfer functions.  You are either transferring * a V_Offscreen to a V_Window or V_Offscreen or you are transferring the image back the * other way. *-------Macintosh Bug Alert!!!----------------------------------------- *	  The Macintosh complains when you attempt to do a copybits with the *	  destination rectangle overhanging the destination bitmap only on *	  top!  It has been fixed in 32-bit quickdraw. *----------------------------------------------------------------------- *------------------------------------------------------------------------------*/void V_Offscreen::MetaTo(V_Display * theObject,Rect *rfrom,Rect *rto)	{	Rect 		from,to;	Rect 		cFrom,cTo;	VGrafData 	fromPort;	VGrafData	toPort;	toPort = theObject->GetMetaPort(&cTo);	fromPort = GetMetaPort(&cFrom);	if (toPort && fromPort)    	{		from=*rfrom;		to=*rto;		Blit(fromPort,toPort,&from,&to,vSrcCopy);		}	else		{         PixelTo(theObject, rfrom, rto);        }	theObject->ReleaseMetaPort(toPort);	ReleaseMetaPort(fromPort);	}void V_Offscreen::ToMeta(V_Display * theObject,Rect *rfrom,Rect *rto)	{	Rect 		from,to;	Rect 		cFrom,cTo;	VGrafData 	fromPort;	VGrafData	toPort;	fromPort = theObject->GetMetaPort(&cFrom);	toPort = GetMetaPort(&cTo);	if (toPort && fromPort)    	{		from=*rfrom;		to=*rto;		Blit(fromPort,toPort,&from,&to,vSrcCopy);		}	else		{		 ToPixel(theObject, rfrom, rto);        }	theObject->ReleaseMetaPort(fromPort);	ReleaseMetaPort(toPort);	}void V_Offscreen::MetaToMode(V_Display *theObject,Rect *rfrom,Rect *rto,long mode)	{	Rect 		from,to;	Rect 		cFrom,cTo;	VGrafData 	fromPort;	VGrafData	toPort;	// ABD MERGE-DITHER [[[#if WINDOWS	if (0) // BUGBUG - really (mode == vSrcDither)		MetaToDither(theObject, rfrom, rto);	else#endif //WINDOWS	{		toPort = theObject->GetMetaPort(&cTo);		fromPort = GetMetaPort(&cFrom);	if (toPort && fromPort)    	{		from=*rfrom;		to=*rto;		Blit(fromPort,toPort,&from,&to,mode);		}	else		{         PixelTo(theObject, rfrom, rto);        }		theObject->ReleaseMetaPort(toPort);		ReleaseMetaPort(fromPort);	}/* BILBIL - don't do this! {{{#else	toPort = theObject->GetMetaPort(&cTo);	fromPort = GetMetaPort(&cFrom);	from=*rfrom;	to=*rto;	Blit(fromPort,toPort,&from,&to,mode);	theObject->ReleaseMetaPort(toPort);	ReleaseMetaPort(fromPort);#endif*/ // BILBIL - don't do this! }}}// ABD MERGE-DITHER ]]]	}void V_Offscreen::ToMetaMode(V_Display *theObject,Rect *rfrom,Rect *rto,long mode)	{	Rect 		from,to;	Rect 		cFrom,cTo;	VGrafData 	fromPort;	VGrafData	toPort;// ABD MERGE-DITHER [[[#if WINDOWS	if (0) // BUGBUG - really (mode == vSrcDither)		ToMetaDither(theObject, rfrom, rto);	else#endif //WINDOWS	{		fromPort = theObject->GetMetaPort(&cFrom);		toPort = GetMetaPort(&cTo);	if (toPort && fromPort)    	{		from=*rfrom;		to=*rto;		Blit(fromPort,toPort,&from,&to,mode);		}	else		{		 ToPixel(theObject, rfrom, rto);        }		theObject->ReleaseMetaPort(fromPort);		ReleaseMetaPort(toPort);	}/* BILBIL - don't do this!  #else	fromPort = theObject->GetMetaPort(&cFrom);	toPort = GetMetaPort(&cTo);	from=*rfrom;	to=*rto;	Blit(fromPort,toPort,&from,&to,mode);	theObject->ReleaseMetaPort(fromPort);	ReleaseMetaPort(toPort);#endif*/ // BILBIL - don't do this! // ABD MERGE-DITHER ]]]	}void V_Offscreen::MaskMetaTo(V_Display *theObject,V_Offscreen *mask,Rect *rfrom,Rect *rto)	{	MaskMetaToMain(theObject,mask,rfrom,rfrom,rto);	}void V_Offscreen::MaskMetaToMain(V_Display *theObject,V_Offscreen *mask,Rect *rfrom,Rect *rmask,Rect *rto)	{	Rect 		from,to,rrmask;	Rect 		cFrom,cTo;	VGrafData 	fromPort;	VGrafData	toPort;	VGrafData	maskPort;	maskPort = mask->GetMetaPort(&rrmask);	toPort = theObject->GetMetaPort(&cTo);	fromPort = GetMetaPort(&cFrom);	from=*rfrom;	to=*rto;	BlitMask(fromPort,toPort,maskPort,&from,&to,rmask,0);	mask->ReleaseMetaPort(maskPort);	theObject->ReleaseMetaPort(toPort);	ReleaseMetaPort(fromPort);	}VGrafDataV_Offscreen::GetMetaPort(Rect *r)	{	VGrafData data;	VCGrafPort cdata;		#if MACINTOSH//	SetMetaPort();#endif //MACINTOSH	GetRect(r);#if MACINTOSH				switch(bitType)		{		case MONO_QD: data=&((GrafPtr)metaPort)->portBits; break;		case COLOR_QD: data=(VGrafData) *metaPort->portPixMap; break;		}#elif WINDOWS	data=metaPort;#endif //WINDOWS	return data;	}voidV_Offscreen::ReleaseMetaPort(VGrafData data)	{#if MACINTOSH//	UnsetMetaPort();#endif //MACINTOSH	}int V_Offscreen::SetMetaPort()	{	long flags;	int depth;	int err;		err = FALSE;		lock++;	if (lock <= 0) DEBUGGER();		// ABD DEBUG#if MACINTOSH	if(screen)		VSetPort(metaPort,gDevice);	else		{		if(lock==1)			{			ObjLock((ObjectHandle)this);			switch(bitType)				{				case MONO_QD:					HLock((Handle)bitmap);					(*bitmap)->bounds=rect;					HLock(baseAddr);					(*bitmap)->baseAddr=*baseAddr;					VSetPort(metaPort,NULL);					SetOrigin(0,0);					SetPortBits(*bitmap);					break;				case COLOR_QD:									if(! LockPixels(metaPort->portPixMap ))						{						GrowMemory(FALSE);			// Only freeze around large memory accesses 	//GJR 10/26/93						flags=UpdateGWorld(&metaPort, 0, &rsize, NULL, NULL, 0);						GrowMemory(TRUE);			// Only freeze around large memory accesses 	//GJR 10/26/93						err = (gwFlagErr&flags) ? -1 : FALSE;						if(!err)err = LockPixels(metaPort->portPixMap ) ? FALSE : -1;						}					break;				}			if(!err)				VSetPort(metaPort,NULL);			}		}#elif WINDOWS	if (lock==1)    	{		ObjLock((ObjectHandle)this);		V_Display::SetDisplayPort();  // can only be done once, (saves status)		SetGraphicContext(metaPort);        }#endif //WINDOWS	if(lock==1)    	{		SetCurrent();  // locks some color arrays        }	VForeColor(&vBlack);	VBackColor(&vWhite);		return err;	}	// ABD WILLIAMS MERGE6 8/30/93 vint V_Offscreen::Lock()				// ABD MERGE6 WILLIAMS	{	long flags;	int depth;	int err;		err = FALSE;		lock++;	if (lock <= 0) DEBUGGER();		// ABD DEBUG;#if MACINTOSH	if(!screen)		{		if(lock==1)			{			ObjLock((ObjectHandle)this);			switch(bitType)				{				case MONO_QD:					HLock((Handle)bitmap);					HLock(baseAddr);					break;				case COLOR_QD:									if(! LockPixels(metaPort->portPixMap ))						{						GrowMemory(FALSE);			// Only freeze around large memory accesses 	//GJR 10/26/93						flags=UpdateGWorld(&metaPort, 0, &rsize, NULL, NULL, 0);						GrowMemory(TRUE);			// Only freeze around large memory accesses 	//GJR 10/26/93						err = (gwFlagErr&flags) ? -1 : FALSE;						if(!err)err = LockPixels(metaPort->portPixMap ) ? FALSE : -1;						}					break;				}			}		}#elif WINDOWS	ObjLock((ObjectHandle)this);#endif //WINDOWS		return err;	}	void V_Offscreen::Unlock()				// ABD MERGE6 WILLIAMS	{	lock--;	if (lock < 0) 		DEBUGGER();				if (lock) return;	#if MACINTOSH	if(!screen)		{		switch(bitType)			{			case MONO_QD:				HUnlock((Handle)baseAddr);				HUnlock((Handle)bitmap);				break;			case COLOR_QD:				UnlockPixels(metaPort->portPixMap );				break;			}		ObjUnlock((ObjectHandle)this);		}		#elif WINDOWS	ObjUnlock((ObjectHandle)this);#endif //WINDOWS	}// jca 30 Sept 93 {/*------------------------------------------------------------------------------ * void V_Offscreen::IO_BMAP(V_Buffer *buf)		// ABD MERGE6 WILLIAMS * Read or write a V_Offscreen as part of a file.  * If we are reading in, then this routine calls cOffscreen() * This routine should eventually take a void * param for extra * compression info.	// jca 15 Sept 93 *------------------------------------------------------------------------------*/int V_Offscreen::IO_BMAP(V_Buffer *buf, V_Array *defcmap, int compress)				// ABD MERGE6 WILLIAMS{int err = noErr;	if (buf->IODirection() == DATA_OUT)    	// call the striping routine, with the whole bitmap as the stripe		err = err?err:IO_BMAP_STRIPE(buf, defcmap, rsize.top, (rsize.bottom - rsize.top),			FALSE, compress);	else		// call the striping routine, with the whole bitmap as the stripe		err = err?err:IO_BMAP_STRIPE(buf, defcmap, rsize.top, (rsize.bottom - rsize.top),			TRUE, compress);#if (MACINTOSH && DEBUG)	if(err) 	{		char s[500];		sprintf(s,"error loading bitmap.  error code %d",err);		C2Pstr(s);		DEBUGSTR((unsigned char *)s);	// MERGE-GOURAUD-PRO-8	}#endif //MACINTOSH && DEBUG	return err;}intV_Offscreen::IO_CMAP(V_Buffer *buf, V_Array *map, int depth){	ULong	color;	RGBColor rgb;	long nColors;	int i;	int err = noErr;	if (depth <= 8)  // only for palette color images		{		if (buf->IODirection() == DATA_OUT)			{#if MACINTOSH			SetMetaPort();#elif WINDOWS			HBITMAP	tempBits;			LPBITMAPINFO	lpbmi;			Handle	bmpinfo;			Handle	tempBuf;            char	*rowPtr;			bmpinfo = NewHandle(sizeof(BITMAPINFOHEADER) + 256*sizeof(RGBQUAD));			HLock(bmpinfo);			lpbmi = (LPBITMAPINFO) HDeref(bmpinfo);			memset(lpbmi, 0, sizeof(BITMAPINFOHEADER) + 256*sizeof(RGBQUAD));		    // do the obvious initing			lpbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);			lpbmi->bmiHeader.biPlanes = 1;			lpbmi->bmiHeader.biCompression = BI_RGB;			lpbmi->bmiHeader.biHeight = rsize.bottom - rsize.top;			lpbmi->bmiHeader.biWidth = rsize.right - rsize.left;			lpbmi->bmiHeader.biBitCount = depth;			tempBuf = NewHandle(((rsize.right - rsize.left)*depth + 31)/8);			HLock(tempBuf);			rowPtr = (char *)HDeref(tempBuf);			// get the color map.  Now.			SetMetaPort();			tempBits = SelectObject(metaPort, oldBitmap);			ASSERT(tempBits == bitmap);			GetDIBits(metaPort, bitmap, 0, 1, rowPtr, lpbmi, DIB_RGB_COLORS);			SelectObject(metaPort, tempBits);			UnsetMetaPort();			HUnlock(tempBuf);			DisposHandle(tempBuf);#endif // MACINTOSH			nColors = 1<<depth;			// write the colormap			for (i = 0; i < nColors && !err; i++)				{#if MACINTOSH				Index2Color(i, &rgb);				color =((Long)rgb.red << 8)&0x00FF0000 | (Long)rgb.green & 0x0000FF00 | (rgb.blue >> 8) & 0x000000FF;#elif WINDOWS				color = (((ULong)(lpbmi->bmiColors[i].rgbRed)) << 16) & 0x00FF0000 |					(((ULong)(lpbmi->bmiColors[i].rgbGreen)) << 8) & 0x0000FF00 |					((ULong)(lpbmi->bmiColors[i].rgbBlue)) & 0x000000FF;#endif // MACINTOSH				err = buf->IOType((void *)&color, IO_LONG);				if (!(i & 0x0F))		VSetCursor(vCursorEarth);				}#if MACINTOSH			UnsetMetaPort();#elif WINDOWS			HUnlock(bmpinfo);			DisposHandle(bmpinfo);#endif // MACINTOSH			}		else			{			// read the color count			nColors = buf->ChunkSize()/sizeof(ULong);            // read in nColors colors			for (i = 0; i < nColors && !err; i++)				{				err = buf->IOType((void *)&color, IO_LONG);				rgb.red = (color >> 8) & 0xFF00;				rgb.green = (color) & 0xFF00;				rgb.blue = (color<<8) & 0xFF00;                map->Append(&rgb);				if (!(i & 0x0F))		VSetCursor(vCursorEarth);				}			}		}	return(err);}/*------------------------------------------------------------------------------ * Windows (tm), our favorite operating system , likes to be spoon fed * bitmap info through DIBs and DIBtoDDB routines.  "Brain-dead" is * the phrase that comes to mind.  Anyway, to circumvent it, we're stuffing * the bitmap bits into (or out of) some space in our global bmap.  This * routine handles that.		4am 27 Sept 93 * I might also add that these routines are potentially dangerous, since they  * assume that you, the programmer, are loading a bitmap of similar dimensions * to the one that already exists.  Writing isn't as much of a hassle, since * we know the bitmap's size. *------------------------------------------------------------------------------*/int V_Offscreen::IO_BMAP_STRIPE(V_Buffer *buf, V_Array *defcmap, long start, long nLinesToDo, int init, int compress)				// ABD MERGE6 WILLIAMS{int err = noErr;short depth, height, width, compression;long size, rowSize;	if (buf->IODirection() == DATA_OUT)	{		// -- write the offscreen		VSetCursor(vCursorEarth);		// write the rect		width = rsize.right - rsize.left;		height = (short)(nLinesToDo);		err = err?err:buf->IOType((void *)&width, IO_SHORT);		err = err?err:buf->IOType((void *)&height, IO_SHORT);		// write the depth		depth = bitDepth;		err = err?err:buf->IOType((void *)&depth, IO_SHORT);		// write the compression mode        compression = compress;		err = err?err:buf->IOType((void *)&compression, IO_SHORT);		// write the length of the scan line (including padding)#if WINDOWS		rowSize = ((wBmWidth*depth)+7)/8;	// jca 28APR94 should write out the right row size.  This is the DIB row size#elif MACINTOSH		rowSize = GetRowWidth();#endif		err = err?err:buf->IOType((void *)&rowSize, IO_LONG);		// write the size of the pixel array		size = rowSize*(nLinesToDo);		err = err?err:buf->IOType((void *)&size, IO_LONG);		VSetCursor(vCursorEarth);		// if there is no default cmap, write out this color map		if (!defcmap)        	{			buf->OpenChunkW(IFF_CMAP);			err = err?err:IO_CMAP(buf, NULL, depth);			buf->CloseChunk();			}		VSetCursor(vCursorEarth);		// write the offscreen		buf->OpenChunkW(IFF_DATA);		err = err?err:IO_BITMAP_STRIPE(buf, NULL, size, rowSize, start, nLinesToDo, compression, depth);        buf->CloseChunk();		VSetCursor(vCursorEarth);	}	else	{	ULong id;	int done = FALSE;    V_Array *cmap = NULL;			// -- read the offscreen		VSetCursor(vCursorEarth);		// read the rect		err = err?err:buf->IOType((void *)&width, IO_SHORT);		err = err?err:buf->IOType((void *)&height, IO_SHORT); // what if height != nRowsToRead?   ELVIS!!!		// read the depth		err = err?err:buf->IOType((void *)&depth, IO_SHORT);		if (!err)			bitDepth = depth; 		// read the compression mode		err = err?err:buf->IOType((void *)&compression, IO_SHORT);		// read the length of the row within the pixel array (pixels + padding)		err = err?err:buf->IOType((void *)&rowSize, IO_LONG);		// read the size of the pixel array		err = err?err:buf->IOType((void *)&size, IO_LONG);		VSetCursor(vCursorEarth);		while (done != TRUE)			{			id = buf->OpenChunkR();			if (id == 0)            	done = TRUE;			VSetCursor(vCursorEarth);			switch (id)				{				case IFF_CMAP:					cmap = new(V_Array);					cmap->cArray(0, sizeof(RGBColor), 16);					err = err?err:IO_CMAP(buf, cmap, depth);					break;				case IFF_DATA:					{					V_Array *bCmap= NULL;					if (cmap)	bCmap = cmap;					else if (defcmap)	bCmap = defcmap;					else						{   // must have a color map						err = -1;                        done = TRUE;						}					if (init)	// then we should init the offscreen                    	{						Rect rect;						VSetRect(&rect, 0, 0, width, height);						err = err?err:IO_INIT_READER(&rect, depth, bCmap);						if (!err)	nLinesToDo = rect.bottom - rect.top;   	// jca 7 Oct 93  must init the number of lines, since we couldn't have done it earlier if there were no offscreen						}					err = err?err:IO_BITMAP_STRIPE(buf, bCmap, size, rowSize, start, nLinesToDo, compression, depth);					}					break;				}			if (!done)	buf->CloseChunk();	// do not close the chunk if we're done            }        if (cmap) cmap->dArray();		VSetCursor(vCursorEarth);	}	return err;}intV_Offscreen::IO_INIT_READER(Rect *r, int depth, V_Array *cmap)  // jca 15 Dec 93{	return(cOffscreen(r, depth, NULL, cmap));}intV_Offscreen::IO_BITMAP_STRIPE(V_Buffer *buf, V_Array *clrmap, long size, long rowSize, long start, long nLinesToDo, int compression, int bDepth){Short	depth;int err = noErr;ULong localRowSize, toRead, fPos;int 	i;#if MACINTOSHUChar	*data;#elif WINDOWSLPBITMAPINFO	lpbmi;char	*bits;Handle	bitbuf, bmpinfo;RGBColor *rgb;ULong nLinesMax, nLinesLeft, nLinesThisTime, extraToWrite;int  nLinesProcessed;HBITMAP	tempBits;		// jca 11 Dec 93	bmpinfo = NewHandle(sizeof(BITMAPINFOHEADER) + 256*sizeof(RGBQUAD));	HLock(bmpinfo);	lpbmi = (LPBITMAPINFO) HDeref(bmpinfo);	memset(lpbmi, 0, sizeof(BITMAPINFOHEADER) + 256*sizeof(RGBQUAD));	// do the obvious initing	lpbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);	lpbmi->bmiHeader.biPlanes = 1;	lpbmi->bmiHeader.biCompression = BI_RGB;	lpbmi->bmiHeader.biHeight = wBmHeight;   // jca 11 Dec 93.  This is how to do it.	lpbmi->bmiHeader.biWidth = wBmWidth;	lpbmi->bmiHeader.biBitCount = bDepth;#endif // MACINTOSH	depth = bDepth;	if (buf->IODirection() == DATA_OUT)		{		VSetCursor(vCursorEarth);		// write the offscreen data with our processor's native scan line padding.#if MACINTOSH		if (!err)        	{			Lock();			localRowSize = GetRowWidth();			data = start * localRowSize + GetBaseAddr();			// perhaps we should do this in chunks so we can do cursor updates....  jca 20Sept 93			err = buf->IOData((void *)data, size);			Unlock();        	}#elif WINDOWS		// do the evil Windows(tm) things.		localRowSize = ((lpbmi->bmiHeader.biWidth*depth)+7)/8;	// Bad Drivers Need matching widths													//  tween DIB and DDB   //GJR 11/22/93		// localRowSize is the size of the actual rows in the		// DIB.  rowSize should be the same thing, since that's how		// I set it.  But let's be safe.  jca 28APR94        extraToWrite = rowSize - localRowSize;		if (rowSize < localRowSize) // error!			err = -1;  // rowSize should be >= localRowSize		// try to allocate the largest possible buffer for the data.		nLinesMax = nLinesToDo;		// Avoid the 64K edge.		while ((localRowSize*nLinesMax >= 65000L) && (nLinesMax > 0))        	nLinesMax /= 2;		bitbuf = NewHandle(localRowSize*nLinesMax);		// Keep trying to get a big buffer.  Halve the requested buffer		// size each time until either we get a buffer or the size is        // less than a single scan line.		while ((bitbuf == NULL) && (nLinesMax > 0))			{			nLinesMax /= 2;			bitbuf = NewHandle(localRowSize*nLinesMax);			}		if ((bitbuf == NULL) || (nLinesMax <= 0))	err = err?err:-1;		nLinesLeft = nLinesToDo;		// now get the bits, and stuff them into the bitmap.		if (!err)			{			HLock(bitbuf);			bits = (char *) HDeref(bitbuf);			memset(bits, 0, localRowSize*nLinesMax);  // clear the buffer			SetMetaPort();			tempBits = SelectObject(metaPort, oldBitmap);            ASSERT(tempBits == bitmap);			/* Get the scans, in clumps, and then write them.  Note that			   the scans are retrieved and written from bottom to top.            */			while (nLinesLeft > 0 && !err)				{                // figure out how many lines to get				if (nLinesLeft >= nLinesMax)					{					nLinesThisTime = nLinesMax;					nLinesLeft -= nLinesMax;					}				else					{					nLinesThisTime = nLinesLeft;					nLinesLeft = 0;                    }            	// get the scans				nLinesProcessed = GetDIBits(metaPort, tempBits, nLinesLeft+start,					nLinesThisTime, bits, lpbmi, DIB_RGB_COLORS);				ASSERT(nLinesProcessed == nLinesThisTime);				if (nLinesProcessed <= 0)					err = -1;                // write the scans, one at a time				for (i = nLinesThisTime-1; i >= 0 && !err; i--)					{					int j;					char zero = '\0';					err = err?err:buf->IOData((void *)(&bits[i*localRowSize]), localRowSize);					if (!(i & 0x0F))		VSetCursor(vCursorEarth);					// add any extra padding needed					if (extraToWrite) // is rowSize > localRowSize						for (j = 0; j < extraToWrite; j++)							err = err?err:buf->IOData((void *)&zero, 1);                    }				}			SelectObject(metaPort, tempBits);			UnsetMetaPort();			HUnlock(bitbuf);			DisposHandle(bitbuf);			}#endif // MACINTOSH		}	else		{		VSetCursor(vCursorEarth);		// read the offscreen data#if MACINTOSH		if (!err)        	{			Lock();			localRowSize = GetRowWidth();			data = start*localRowSize + GetBaseAddr();			// if the rowLength in the mac bitmap is the same as            // in the BMAP, then just load the entire chunk.			if (localRowSize == rowSize)				err = buf->IOData((void *)data, size);			/* otherwise, we've a lot of work to do.  There are			   two cases.  If the mac bitmap length is longer, then			   then reading that many pixels will cause us to read			   a scan line, the padding, and part of another scan.			   If the BMAP length is longer, then reading in that			   many pixels will cause us to write extra pad bytes			   where we should write pixels, and we'll have a memory			   fault.  We must read the shorter of the two, and then			   update the file and scan positions.            */			else				{				toRead = min(localRowSize, rowSize);				fPos = buf->IOGetPosition();				for (i = 0; (i < nLinesToDo) && !err; i++)					{            		err = buf->IOData((void *)data, toRead);					data += localRowSize;					fPos += rowSize;					buf->IOSetPosition(fPos);					if (i&0x0F)	VSetCursor(vCursorEarth);					}				}							Unlock();        	}#elif WINDOWS		// first, set up the colortable		if (!clrmap)	err = -1;		else        	{			rgb = (RGBColor *)clrmap->Use();			for (i = 0; i < clrmap->ALength() && !err; i++)				{				lpbmi->bmiColors[i].rgbRed = (rgb[i].red >> 8) & 0xFF;				lpbmi->bmiColors[i].rgbGreen = (rgb[i].green >> 8) & 0xFF;				lpbmi->bmiColors[i].rgbBlue = (rgb[i].blue >> 8) & 0xFF;				}			clrmap->Unuse();        	}		// do the evil Windows(tm) things.		localRowSize = ((lpbmi->bmiHeader.biWidth*depth)+7)/8;	// Bad Drivers Need matching widths													//  tween DIB and DDB   //GJR 11/22/93		// try to allocate the largest possible buffer for the data.		nLinesMax = nLinesToDo;        // Avoid the 64K edge.		while ((localRowSize*nLinesMax >= 65000L) && (nLinesMax > 0))			nLinesMax /= 2;		bitbuf = NewHandle(localRowSize*nLinesMax);		// Keep trying to get a big buffer.  Halve the requested buffer		// size each time until either we get a buffer or the size is		// less than a single scan line.		while ((bitbuf == NULL) && (nLinesMax > 0))			{			nLinesMax /= 2;			bitbuf = NewHandle(localRowSize*nLinesMax);			}		if ((bitbuf == NULL) || (nLinesMax <= 0))	err = err?err:-1;		nLinesLeft = nLinesToDo;		// now get the bits, and stuff them into the bitmap.		if (!err)			{			HLock(bitbuf);			bits = (char *) HDeref(bitbuf);			memset(bits, 0, localRowSize*nLinesMax);  // clear the buffer			toRead = min(localRowSize, rowSize);            fPos = buf->IOGetPosition();			SetMetaPort();			tempBits = SelectObject(metaPort, oldBitmap);			ASSERT(tempBits == bitmap);			/* Get the scans, in clumps, and then write them.  Note that			   the scans are retrieved and written from bottom to top.            */			while (nLinesLeft > 0 && !err)				{                // figure out how many lines to get				if (nLinesLeft >= nLinesMax)					{					nLinesThisTime = nLinesMax;					nLinesLeft -= nLinesMax;					}				else					{					nLinesThisTime = nLinesLeft;					nLinesLeft = 0;                    }            	// get the scans				for (i = nLinesThisTime-1; i >= 0 && !err; i--)                	{ 					err = err?err:buf->IOData((void *)(&bits[i*localRowSize]), toRead);					fPos += rowSize;					buf->IOSetPosition(fPos);					if (!(i & 0x0F))		VSetCursor(vCursorEarth);					}				// stuff the scans into the bitmap, one scan at a time,				// from bottom to top in a good Windows(tm) manner.				nLinesProcessed = SetDIBits(metaPort, tempBits, nLinesLeft+start,					nLinesThisTime, bits, lpbmi, DIB_RGB_COLORS);				ASSERT(nLinesProcessed == nLinesThisTime);				if (nLinesProcessed <= 0)					err = -1;				}			SelectObject(metaPort, tempBits);			UnsetMetaPort();			HUnlock(bitbuf);			DisposHandle(bitbuf);            }#endif // MACINTOSH		}#if WINDOWS	HUnlock(bmpinfo);	DisposHandle(bmpinfo);#endif	return(err);}// jca 30 Sept 93 }// ABD WILLIAMS MERGE6 8/30/93 ^void V_Offscreen::UnsetMetaPort()	{	lock--;		if (lock < 0) DEBUGGER();		// ABD DEBUG	if(lock)return;// lock == 0, so finish unlocking everything.#if MACINTOSH	if(!screen)		{		switch(bitType)			{			case MONO_QD:				HUnlock((Handle)baseAddr);				HUnlock((Handle)bitmap);				break;			case COLOR_QD:				UnlockPixels(metaPort->portPixMap );				break;			}//		ObjUnlock((ObjectHandle)this);     //move further down, after other work is done. //GJR 12/14/93		}#elif WINDOWS	V_Display::UnsetDisplayPort();//	ObjUnlock((ObjectHandle)this);         //ditto (actually, just guessing)#endif //WINDOWS	UnSetCurrent();	ObjUnlock((ObjectHandle)this);	VSetPort(mainPort,mainDevice);	}int V_Offscreen::Resize(Rect * size, int options)	{	VCGrafPort meta;	int err;	int theNewDepth;					   // jca 28 Sept 93 {	switch (options)              		{		case RESIZE_PRESERVE_DEPTH:			theNewDepth = bitDepth;            break;		case RESIZE_STANDARD:		default:			theNewDepth = 0;            break;                      // jca 28 Sept 93  }		}	if(lock)		AlertMessage(TXT_OFFSCREEN_LOCKED);		// PRO-JAP	err = (screen)?-1:FALSE;	if(!err)		{		ObjLock((ObjectHandle)this);#if MACINTOSH		switch(bitType)			{			case MONO_QD:				DisposHandle((Handle)baseAddr);				DisposHandle((Handle)bitmap);				err = ANewBitMap(size);				if(!err)					{					VSetPort(metaPort,0L);					RectRgn(((GrafPtr)metaPort)->visRgn,size);					}				break;						case COLOR_QD:				rsize=*size;				rect=rsize;				rect.right-=rect.left;				rect.bottom-=rect.top;				rect.left=rect.top=0;				meta=metaPort;				{				GWorldFlags flagResult;				GrowMemory(FALSE);			// Only freeze around large memory accesses 	//GJR 10/26/93				flagResult=UpdateGWorld(&meta,theNewDepth,size,NULL,NULL,0);     // jca 28 Sept 93				GrowMemory(TRUE);			// Only freeze around large memory accesses 	//GJR 10/26/93				metaPort=meta;				err = (flagResult&gwFlagErr) ? -2 : FALSE;                }				break;			}#elif WINDOWS		bitType=COLOR_QD;		rsize=*size;		rect=rsize;		rect.right-=rect.left;		rect.bottom-=rect.top;		rect.left=rect.top=0;		err = (ANewBitMap(size)) ? -1 : FALSE;#endif //WINDOWS		ObjUnlock((ObjectHandle)this);		}	return err;	}void V_Offscreen::SetRefCon(long rc) { refCon=rc; }long V_Offscreen::GetRefCon() { return refCon; }int V_Offscreen::IOPictFile(V_Buffer*buf,int depth)	{	OSErr err=0;	long i,zero=0,length;	for(i=0;i<512/4 && !err;i++)		err=buf->IOType(&zero,IO_LONG);	if(buf->IODirection()==DATA_IN)		{		err=buf->IOLength(&length);		if(!err)err=IOPict(buf,length-512,depth);		}	return(err);	}/*------------------------------------------------------------------------------ * void V_Offscreen::IOPict(V_Buffer *buf,long length, int depth) * Load a Macintosh 'PICT' file.  This is also a V_Offscreen constructor that is * initialized with this image. *------------------------------------------------------------------------------*/int V_Offscreen::IOPict(V_Buffer *buf, long length, int depth)	{	V_Picture *pField;	Rect r;	OSErr err=-1;	short pictDepth,direct;		if(buf->IODirection()==DATA_IN)		{		pField=new(V_Picture);		err=pField->IOPict(buf,length);		// MERGE-GOURAUD-PRO-2 DPI HACK [[[		// MERGE-GOURAUD-PRO-6 added new stuff to this section#if MACINTOSH		{		Rect r;		Rect oldFrame = (*pField->picture)->picFrame;					// make sure this pict is of the appropriate version before we start mucking about			// with the fields			if (((short *)(*pField->picture))[5] != 0x0011)				goto bad_pict;			if (((short *)(*pField->picture))[6] != 0x02FF)				goto bad_pict;			if (((short *)(*pField->picture))[7] != 0x0C00)				goto bad_pict;			if (((short *)(*pField->picture))[8] != -2)				goto bad_pict;					if ((((short *)(*pField->picture))[10] != 72) ||				(((short *)(*pField->picture))[12] != 72))				//(((short *)(*pField->picture))[36] != 72) ||	// ignore these MERGE-GOURAUD-PRO-11				//(((short *)(*pField->picture))[38] != 72))	// ignore these MERGE-GOURAUD-PRO-11			{				// THIS IS A MAJOR HACK!!!  force picture to be 72 dots per inch THIS IS A MAJOR HACK!!! 				// ABD hack hack blah elvis hack				// This WILL break.  This relies on absolute offsets for the resolution of pictures.				// If the picture is the wrong version, then this will break.  We could check the				// version numbers here or something, but IT SURE WOULD BE NICE IF A ROUTINE EXISTED				// TO DO THIS TO PICTURES!!!!  HELLO, APPLE, YOU STUPID MORONS!!!! 				((short *)(*pField->picture))[10] = 72;				((short *)(*pField->picture))[11] = 0;				((short *)(*pField->picture))[12] = 72;				((short *)(*pField->picture))[13] = 0;				((short *)(*pField->picture))[36] = 72;				((short *)(*pField->picture))[37] = 0;				((short *)(*pField->picture))[38] = 72;				((short *)(*pField->picture))[39] = 0;								// OK THE ABOVE FIXED UP THE RESOLUTION FIELDS, BUT WE STILL NEED TO FIX UP THE				// RECT, so we copy the "native" rect into the "72 dpi" rect.				((short *)(*pField->picture))[1] = ((short *)(*pField->picture))[14];				((short *)(*pField->picture))[2] = ((short *)(*pField->picture))[15];				((short *)(*pField->picture))[3] = ((short *)(*pField->picture))[16];				((short *)(*pField->picture))[4] = ((short *)(*pField->picture))[17];								// we need to do some sanity checks because some programs might write out bogus				// picts				r.left = ((short *)(*pField->picture))[1];				r.top = ((short *)(*pField->picture))[2];				r.right = ((short *)(*pField->picture))[3];				r.bottom = ((short *)(*pField->picture))[4];				if ((r.left >= r.right) || (r.bottom <= r.top))				{					// this picture is bogus -- what to do about it?  let's put the					// old rect back in.  This really sucks.					((short *)(*pField->picture))[1] = oldFrame.left;					((short *)(*pField->picture))[2] = oldFrame.top;					((short *)(*pField->picture))[3] = oldFrame.right;					((short *)(*pField->picture))[4] = oldFrame.bottom;				}			}		bad_pict:			// somehow this pict is of the wrong version or something, so just grin and swallow			;		}#endif		// MERGE-GOURAUD-PRO-2 DPI HACK ]]]		if(!err)			{			pField->GetRect(&r);#if PICTCLUT			{			CTabHandle ctab;			ctab=CollectColors(pField->picture, &pictDepth, &direct);			if(direct)				err=cOffscreen(&r,depth,&vWhite,NULL);			else				err=cOffscreen(&r,depth,&vWhite, NULL/*,ctab*/);			/* !!!!! this needs correcting to deal with			the new ctab parameter to the cOffscreen routine            JCA 21 Jan 93 */			DisposCTable(ctab);			}#else			err=cOffscreen(&r,depth,&vWhite,NULL);#endif //PICTCLUT			if(!err)				{				SetMetaPort();				pField->Draw(&r);				UnsetMetaPort();				}			}		pField->dPicture();		}			return err;	}/*------------------------------------------------------------------------------ * void V_Offscreen::LoadPNum(int num,int depth) * Load a Macintosh 'PICT' resource. This is also a V_Offscreen constructor that is * initialized with this image. *------------------------------------------------------------------------------*/int V_Offscreen::LoadPNum(int num,int depth)	{	V_Picture *pField;	Rect r;	int err;		pField=new(V_Picture);	VSetCursor(vCursorEarth);	err=pField->GetPictNum(num);	if(!err)		{		VSetCursor(vCursorEarth);		pField->GetRect(&r);		VSetCursor(vCursorEarth);		if (depth == 0)			depth = 1;		err=cOffscreen(&r,depth,NULL,NULL);		if(!err)			{			VSetCursor(vCursorEarth);			SetMetaPort();			VClipRect(&r);			VSetCursor(vCursorEarth);			pField->Draw(&r);			VSetCursor(vCursorEarth);			UnsetMetaPort();			}		}	pField->dPicture();	return err;	}unsigned char **V_Offscreen::UseRaster(VGrafPort *savePort, VGrafDevice *saveDevice)		// MERGE23	{	int height,rowBytes,i;	unsigned char **rdata,*base;#if MACINTOSH	if (savePort && saveDevice)				// MERGE23		VGetPort(savePort, saveDevice);		// MERGE23	SetMetaPort();	height=rect.bottom-rect.top;	if(!raster)		{		raster=new(V_Array);		raster->cArray(height+1,sizeof(char *),4);		rdata=(unsigned char **)raster->Use();		rdata[0]=0;/*guarantee that this is unique*/		}	else		rdata=(unsigned char **)raster->Use();	base=(unsigned char *)StripAddress(GetPixBaseAddr(metaPort->portPixMap));	rowBytes=0x1FFF&(*metaPort->portPixMap)->rowBytes;	if(rdata[0]!=base)		{		rdata[0]=base;		for(i=1;i<=height;i++)			rdata[i]=rdata[i-1]+rowBytes;		}	return rdata;#elif WINDOWS	return lpbBmRowAddresses;#endif //MACINTOSH	}void V_Offscreen::UnuseRaster(VGrafPort *savePort, VGrafDevice *saveDevice)		// MERGE23	{#if MACINTOSH //!ELVIS	UnsetMetaPort();	if (savePort && saveDevice)					// MERGE23		VSetPort(*savePort, *saveDevice);		// MERGE23	if(raster)raster->Unuse();#endif	}#if MACINTOSHCTabPtr V_Offscreen::UseColorTable()	{	int theDepth;	CTabPtr theTable;		theDepth=GetDepth();	if(theDepth==0 || theDepth>8)return NULL;	SetMetaPort();	HLock((Handle)(*metaPort->portPixMap)->pmTable);	return *(*metaPort->portPixMap)->pmTable;	}void V_Offscreen::UnuseColorTable(void)	{	theDepth=GetDepth();	if(theDepth==0 || theDepth>8)return;	HUnlock((Handle)(*metaPort->portPixMap)->pmTable);	UnsetMetaPort();	}#endif //MACINTOSHunsigned char* V_Offscreen::GetBaseAddr(void)	{	unsigned char *ba = NULL;    		//GJR 10/07/93#if MACINTOSH	ba = (bitType==MONO_QD)?(unsigned char *)*baseAddr:(unsigned char *)GetPixBaseAddr(metaPort->portPixMap);#elif WINDOWS	ba = lpbBmBits;						//GJR 10/11/93#endif //MACINTOSH	return ba;	}int V_Offscreen::Begin(void)	{	if(offscreen)		offscreen->dOffscreen();	offscreen=this;	SetMetaPort();	return FALSE;	}int V_Offscreen::End()	{	offscreen=NULL;	UnsetMetaPort();	return(FALSE);	}voidV_Offscreen::Antialias()	{#if MACINTOSH	CTabPtr theTable;	ColorSpec *ctTable;	unsigned char **raster;	int theDepth;	int width,height;	int i,j,index;	Rect r;	ULong red,green,blue;	RGBColor rgb;	VGrafPort savePort;	// ABD MERGE23	VGrafDevice saveDevice;	// ABD MERGE23	theDepth=GetDepth();	raster=UseRaster(&savePort, &saveDevice);	theTable=UseColorTable();	GetRect(&r);	width=r.right-r.left-1;	height=r.bottom-r.top-1;		switch(theDepth)		{		case 0:		case 1:		case 2:		case 4:			break;		case 8:			ctTable=theTable->ctTable;			for(i=0;i<height;i++)				for(j=0;j<width;j++)					{					red=ctTable[raster[i][j]].rgb.red;					red+=ctTable[raster[i+1][j]].rgb.red;					red+=ctTable[raster[i][j+1]].rgb.red;					red+=ctTable[raster[i+1][j+1]].rgb.red;					rgb.red=red>>2;					green=ctTable[raster[i][j]].rgb.green;					green+=ctTable[raster[i+1][j]].rgb.green;					green+=ctTable[raster[i][j+1]].rgb.green;					green+=ctTable[raster[i+1][j+1]].rgb.green;					rgb.green=green>>2;					blue=ctTable[raster[i][j]].rgb.blue;					blue+=ctTable[raster[i+1][j]].rgb.blue;					blue+=ctTable[raster[i][j+1]].rgb.blue;					blue+=ctTable[raster[i+1][j+1]].rgb.blue;					rgb.blue=blue>>2;					index=Color2Index(&rgb);					raster[i][j]=index;					}			break;		case 16:			break;		case 32:			break;		}	UnuseColorTable();	UnuseRaster(&savePort, &saveDevice);#endif //WINDOWS	}/*------------------------------------------------------------------------------ * V_Picture * V_Pictures handle images stored in the Macintosh 'PICT' format.  They are * loaded drawn, or used to create a V_Offscreen object.  Since the V_Picture  * needs to handle files it uses a derived V_File class, P_File, for this * specific purpose. *------------------------------------------------------------------------------ * int V_Picture::IOResource(int pictNum) *------------------------------------------------------------------------------*/int V_Picture::GetPictNum(int pID)	{	int err;	ptype=0;#if MACINTOSH	picture=GetPicture(pID);#elif WINDOWS	pID = (0>pID)?-pID:pID;/* BITMAPS CAN ONLY HAVE POSITIVE ID's */	picture = LoadBitmap(GetAppInstance(),MAKEINTRESOURCE(pID));#endif //WINDOWS	err = (picture)?0:-1;	return err;	}/*------------------------------------------------------------------------------ * void V_Picture::Draw(Rect *r) * This routine draws the picture into the current port.  A spooled V_Picture * does not really exist so should never be drawn. *------------------------------------------------------------------------------*/void V_Picture::Draw(Rect *r)	{	if(picture)		{		Rect pR;#if MACINTOSH		HLock((Handle)picture);		DrawPicture(picture,r);		HUnlock((Handle)picture);#elif WINDOWS		HDC hdc;		HBITMAP hBitmap;		hdc = VCreateCompatibleDC(currentDevice);		hBitmap = SelectObject(hdc,picture);		GetRect(&pR);		Blit(hdc,currentDevice,&pR,r,SRCCOPY);			SelectObject(hdc,hBitmap);		DeleteDC(hdc);#endif //WINDOWS		}		}void V_Picture::cPicture(int bitsFlag)	{	resolution.h = resolution.v = 72; /* 72 pixels/inch */	bitType=FindDepth()?bitType=COLOR_QD:MONO_QD;	makeBits=bitsFlag;	ptype=3;	SetDisplayType(DISPLAY_PICT);	// DAS-VWINDOWS 10/9/93	}void V_Picture::dPicture()	{#if MACINTOSH	switch(ptype)		{		case 0:ReleaseResource((Handle)picture);break;		case 1: if(picture)DisposHandle((Handle)picture); break;		case 2:/*do nothing*/ break;		case 3: if(picture)KillPicture(picture);		}#elif WINDOWS	DeleteObject(picture);#endif //WINDOWS	delete(this);	}void V_Picture::GetRect(Rect *r)	{	/* DUDE */	if(picture)		{	#if MACINTOSH		*r=(**picture).picFrame;		r->right-=r->left;		r->bottom-=r->top;	#elif WINDOWS		BITMAP bm;		GetObject(picture,sizeof(BITMAP),&bm);		r->right = bm.bmWidth;		r->bottom = bm.bmHeight;	#endif //WINDOWS		r->top=0;		r->left=0;		}	else		*r=rect;	}int saveTheQDFlag;int V_Picture::Begin(void)	{	Rect r,oR;	OSErr err;		err = FALSE;	r=rect;	ObjLock((ObjectHandle)this);	if(makeBits)		{		if(offscreen)offscreen->dOffscreen();		offscreen=new(V_Offscreen);		if(offscreen)			{			err=offscreen->cOffscreen(&r,bitDepth,&vWhite,NULL);			if(!err) offscreen->SetMetaPort();			}		}	else		{		saveTheQDFlag=UsePlatformDraw(TRUE);		nilPort->SetMetaPort();#if MACINTOSH		picture=OpenPicture(&r);#endif //MACINTOSH		err = (picture) ? FALSE : -1;		}	return err;		}int V_Picture::End(void)	{	VGrafData	fromPort;	VGrafData	toPort;	Rect r,from,to;	int err;		err = FALSE;	if(offscreen && (makeBits&PICT_OFFSCREEN))		{		r = rect;		if(makeBits&PICT_ANTIALIAS)offscreen->Antialias();		fromPort = offscreen->GetMetaPort(&from);		toPort = nilPort->GetMetaPort(&to);		nilPort->SetMetaPort();#if MACINTOSH		if (picture)			KillPicture(picture);		picture=OpenPicture(&r);		err = (picture) ? FALSE : -1;		if(!err)			{			Blit(fromPort,toPort,&r,&r,srcCopy);			ClosePicture();			}#endif //MACINTOSH		nilPort->ReleaseMetaPort(toPort);		nilPort->UnsetMetaPort();		offscreen->ReleaseMetaPort(fromPort);		offscreen->UnsetMetaPort();		}	else 		{#if MACINTOSH		if(picture)ClosePicture();#endif //MACINTOSH		nilPort->UnsetMetaPort();		}			UsePlatformDraw(saveTheQDFlag);	ObjUnlock((ObjectHandle)this);	return err;	}int V_Picture::IOPictFile(V_Buffer*buf)	{	OSErr err = noErr;	long i,zero=0,length;		for(i=0;i<512/4;i++)		buf->IOType(&zero,IO_LONG);	if(buf->IODirection()==DATA_IN)		{		buf->IOLength(&length);		IOPict(buf,length-512);		}	else IOPict(buf,0);/*length is ignored in this case*/ 		return(err);	// jca 10Jan94 return any errors	}int V_Picture::IOPict(V_Buffer*buf,long length)	{	int  err;	long i,zero;		zero=0;#if MACINTOSH	if(buf->IODirection()==DATA_IN)		{		err = (picture)?-1:FALSE;		if(!err)			{			ptype=1;			picture=(PicHandle)NewHandle(length);			HLock((Handle)picture);			err=buf->IOData((char *)(*picture),length);			if(err)				{				DisposHandle((Handle)picture);				picture=NULL;				return err;				}			}		}	else		{		HLock((Handle)picture);		err=buf->IOData((char *)(*picture),GetHandleSize((Handle)picture));		}			HUnlock((Handle)picture);#endif //MACINTOSH	return err;	}int V_Picture::IOChunk(V_Buffer*buf)	{	long i,zero,length;	int err;		zero=0;	HLock((Handle)picture);	err = -1;		if(buf->IODirection()==DATA_IN)		{		buf->OpenChunkR();		length=buf->ChunkSize();#if MACINTOSH		picture=(PicHandle)NewHandle(length);		err = (picture) ? FALSE : -1;		if(!err) 			{			HLock((Handle)picture);			err=buf->IOData((char *)(*picture),length);			HUnlock((Handle)picture);			}#endif //MACINTOSH		}	else		{		buf->OpenChunkW(IFF_PICT);#if MACINTOSH		HLock((Handle)picture);		err=buf->IOData(*picture,GetHandleSize((Handle)picture));		HUnlock((Handle)picture);#endif //MACINTOSH		}			buf->CloseChunk();	return err;	}int V_Picture::IOResource(V_File *buf, int pID, strPtr pName)	{	int err;	err = (picture) ? FALSE : -1;	if(!err)		{#if MACINTOSH//		ObjLock((ObjectHandle)this); // BILBIL - done inside IOResource()		err=buf->IOResource((Handle *)&picture,'PICT',pID,pName);//		ObjUnlock((ObjectHandle)this);#endif //MACINTOSH		}	return err;	}/********************************************************************/#if WINDOWS#ifdef gjrTryDibsint DibRepeat = 0;int DibBitCount = 4;int DibPlanes = 1;voidV_Offscreen::DibBlit(VGrafData toPort,Rect *from,Rect *to,long mode)	{	int i;	HDC		hdc;	int		xDest;	int		yDest;	int		cx;	int		cy;	int		xSrc;	int		ySrc;	UINT	uStartScan;	UINT	cScanLines;	void FAR* lpvBits;	BITMAPINFO FAR* lpbmi;	UINT	fuColorUse;	BITMAPINFOHEADER *pbi;	WORD 	*pw;		/* setup args */	hdc = toPort;	xDest = to->left;	yDest = to->top;	cx    = min(to->right - to->left, from->right - from->left);	cy    = min(to->bottom - to->top, from->bottom - from->top);	xSrc  = from->left;	ySrc  = from->top;	uStartScan = 0;	cScanLines = cy;	lpvBits  = lpDibBits;	lpbmi	 = lpbmiDibBmiPal;	pbi = &lpbmi->bmiHeader;	pbi->biWidth = cx; // ?? change to this->width, etc.	pbi->biHeight = cy;	pbi->biPlanes = DibPlanes;	pbi->biBitCount = DibBitCount;    fuColorUse = DIB_RGB_COLORS;    fuColorUse = DIB_PAL_COLORS;	for (i=0; i<DibRepeat; i++)		{		SetDIBitsToDevice(			hdc,			xDest,			yDest,			cx,			cy,			xSrc,			ySrc,			uStartScan,			cScanLines,			lpvBits,			lpbmi,			fuColorUse);        }//		BitBlt(toPort,to->left,to->top,(from->right-from->left),(from->bottom-from->top),//		fromPort,from->left,from->top,mode);	}voidMakeDibBmiPal();voidMakeDibBmiPal(){	BITMAPINFOHEADER *pbi;	HANDLE hdl;    WORD  *pw;	int		i;	if (!lpbmiDibBmiPal)		{		hbmiDibBmiPal = GlobalAlloc(GHND,			sizeof(BITMAPINFOHEADER) + 256*4);		lpbmiDibBmiPal =(LPBITMAPINFO) GlobalLock(hbmiDibBmiPal);		pbi = &lpbmiDibBmiPal->bmiHeader;    	memset(pbi, 0, sizeof(BITMAPINFOHEADER));    	pbi->biSize = sizeof(BITMAPINFOHEADER);		pbi->biPlanes = 1;		pbi->biBitCount = 4;		pbi->biCompression = BI_RGB;		/* check speed for these to be inited */		pbi->biSizeImage = 0;        pbi->biClrUsed = 0;		pw = (WORD *) &lpbmiDibBmiPal->bmiColors;		for (i=0; i<256; i++)			{			*pw++ = (WORD) i;			}        }}voidV_Offscreen::cDib(){	int wWidth = 1;    int wHeight = 1;/* MUST DEFINE THE PALETTE SOMEHOW */	BITMAPINFOHEADER *pbi;	DWORD	memWidth;	DWORD	memHeight;	DWORD	memSize;    int		memDepth;	int		i;	MakeDibBmiPal();    memDepth = 8;    memWidth = ((wWidth * memDepth + 31) & ~31) / 8;	memHeight = wHeight;	memSize = memWidth * memHeight;	hbmiDibBmi = GlobalAlloc(GHND,		sizeof(BITMAPINFOHEADER) + 256*sizeof(RGBQUAD) + memSize);	lpbmiDibBmi =(LPBITMAPINFO) GlobalLock(hbmiDibBmi);    lpDibBits = (LPSTR)lpbmiDibBmi + sizeof(BITMAPINFOHEADER) + 256*sizeof(RGBQUAD);	pbi = &lpbmiDibBmi->bmiHeader;    memset(pbi, 0, sizeof(BITMAPINFOHEADER));    pbi->biSize = sizeof(BITMAPINFOHEADER);	pbi->biPlanes = 1;	pbi->biBitCount = memDepth;	pbi->biCompression = BI_RGB;	pbi->biWidth = wWidth;    pbi->biHeight = wHeight;	pbi->biSizeImage = 0;	pbi->biClrUsed = 0;}voidV_Offscreen::dDib(){	GlobalUnlock(hbmiDibBmi);    GlobalFree(hbmiDibBmi);}voidV_Offscreen::ResizeDib(int wWidth, int wHeight){/* MUST DEFINE THE PALETTE SOMEHOW */	BITMAPINFOHEADER *pbi;	DWORD	memWidth;	DWORD	memHeight;	DWORD	memSize;    int		memDepth;	int		i;    memDepth = 8;	// ?? must be more flexible ...    memWidth = ((wWidth * memDepth + 31) & ~31) / 8;	memHeight = wHeight;	memSize = memWidth * memHeight;    /* Remove Prior Block (could do realloc instead...) */	GlobalUnlock(hbmiDibBmi);    GlobalFree(hbmiDibBmi);	hbmiDibBmi = GlobalAlloc(GHND,		sizeof(BITMAPINFOHEADER) + 256*sizeof(RGBQUAD) + memSize);	lpbmiDibBmi =(LPBITMAPINFO) GlobalLock(hbmiDibBmi);    lpDibBits = (LPSTR)lpbmiDibBmi + sizeof(BITMAPINFOHEADER) + 256*sizeof(RGBQUAD);	pbi = &lpbmiDibBmi->bmiHeader;    memset(pbi, 0, sizeof(BITMAPINFOHEADER));    pbi->biSize = sizeof(BITMAPINFOHEADER);	pbi->biPlanes = 1;	pbi->biBitCount = memDepth;	pbi->biCompression = BI_RGB;	pbi->biWidth = wWidth;    pbi->biHeight = wHeight;	pbi->biSizeImage = 0;	pbi->biClrUsed = 0;}#endif // gjrTryDibs#endif // WINDOWS// MERGE-DITHER [[[/*------------------------------------------------------------------------------*/// theObject is the "to" offscreen// this is the "from" offscreenvoid V_Offscreen::MetaToDither(V_Display *theObject,Rect *rfrom,Rect *rto){VGrafData 	fromPort;VGrafData	toPort;Rect 		from_rect,to_rect;Rect 		cFrom,cTo;V_Offscreen *from_off = this;V_Offscreen *to_off = (V_Offscreen *)theObject;int from_cols, from_rows, to_cols, to_rows;FFixed ff_from, ff_to;FFixed h_ratio, v_ratio;int h, v;long error_red, error_green, error_blue;	from_off->Lock();	to_off->Lock();		toPort = theObject->GetMetaPort(&cTo);	fromPort = GetMetaPort(&cFrom);	from_rect = *rfrom; 	to_rect = *rto;	from_cols = from_rect.right - from_rect.left;	from_rows = from_rect.bottom - from_rect.top;	to_cols = to_rect.right - to_rect.left;	to_rows = to_rect.bottom - to_rect.top;		ff_from.intg = from_cols;	ff_to.intg = to_cols;	ff_from.frac = ff_to.frac = 0;	h_ratio = FFDiv(ff_from, ff_to);		ff_from.intg = from_rows;	ff_to.intg = to_rows;	ff_from.frac = ff_to.frac = 0;	v_ratio = FFDiv(ff_from, ff_to);	for ( v = to_rect.top ; v < to_rect.bottom ; v++ )	{		// reset error color for this scan line		error_red = error_green = error_blue = 0;				for ( h = to_rect.left ; h < to_rect.right ; h++ )		{		RGBColor c, stored_c, want_c;		FFixed fh, fv, ffh1, ffv1, ffh2, ffv2;		int h0, v0;		unsigned long num_pixels;		long avg_red, avg_green, avg_blue, c_long;		long v_avg_red, v_avg_green, v_avg_blue;      long num_cols;			fh.intg = h - to_rect.left;			fv.intg = v - to_rect.top;			fh.frac = fv.frac = 0;			ffh1 = FFMult(fh, h_ratio);			ffv1 = FFMult(fv, v_ratio);			fh.intg = (h+1) - to_rect.left;			fv.intg = (v+1) - to_rect.top;			fh.frac = fv.frac = 0;			ffh2 = FFMult(fh, h_ratio);			ffv2 = FFMult(fv, v_ratio);			ffh1.intg += from_rect.left;			ffv1.intg += from_rect.top;			ffh2.intg += from_rect.left;			ffv2.intg += from_rect.top;						// compute the area-sampled color			h0 = ffh1.intg;			num_cols = 0;			v_avg_red = v_avg_green = v_avg_blue = 0;			do			{				num_pixels = 0;				avg_red = avg_green = avg_blue = 0;				v0 = ffv1.intg;				do				{					c = GetPixelColor(h0, v0);					avg_red += c.red;					avg_green += c.green;					avg_blue += c.blue;					num_pixels++;					v0++;				}				while (v0 < ffv2.intg);				v_avg_red += avg_red / num_pixels;				v_avg_green += avg_green / num_pixels;				v_avg_blue += avg_blue / num_pixels;				h0++;            num_cols++;			}			while (h0 < ffh2.intg);							// compute the average			want_c.red = v_avg_red / num_cols;			want_c.green = v_avg_green / num_cols;			want_c.blue = v_avg_blue / num_cols;			// add in the error term and clamp so that we don't get weird colors#if 0			c_long = want_c.red + error_red;			if (c_long < 0) c_long = 0;			else if (c_long > 0xFFFF) c_long = 0xFFFF;			c.red = c_long;						c_long = want_c.green + error_green;			if (c_long < 0) c_long = 0;			else if (c_long > 0xFFFF) c_long = 0xFFFF;			c.green = c_long;						c_long = want_c.blue + error_blue;			if (c_long < 0) c_long = 0;			else if (c_long > 0xFFFF) c_long = 0xFFFF;			c.blue = c_long;#endif			c = want_c;						// set the pixel to our computed colro			to_off->SetPixelColor(h, v, &c);			stored_c = to_off->GetPixelColor(h, v);						// compute the error -- note that we compute it with the color we wanted to store,			// not the value actually stored (which included the error term and was clamped)			// Note that the color we wanted was WITH the full error correction.			error_red = want_c.red + error_red - stored_c.red;			error_green = want_c.green + error_green - stored_c.green;			error_blue = want_c.blue + error_blue - stored_c.blue;		}	}	theObject->ReleaseMetaPort(toPort);	ReleaseMetaPort(fromPort);	to_off->Unlock();	from_off->Unlock();}// theObject is the "from" offscreen// this is the "to" offscreenvoid V_Offscreen::ToMetaDither(V_Display *theObject,Rect *rfrom,Rect *rto){	this->SetMetaPort();	((V_Offscreen*)theObject)->MetaToDither(this, rfrom, rto);	this->UnsetMetaPort();}// MERGE-DITHER ]]]// PixelTo and ToPixel [[[/*------------------------------------------------------------------------------*/// theObject is the "to" offscreen// this is the "from" offscreenvoid V_Offscreen::PixelTo(V_Display *theObject,Rect *rfrom,Rect *rto){VGrafData 	fromPort;VGrafData	toPort;Rect 		from_rect,to_rect;Rect 		cFrom,cTo;V_Offscreen *from_off = this;V_Offscreen *to_off = (V_Offscreen *)theObject;int from_cols, from_rows, to_cols, to_rows;FFixed ff_from, ff_to;FFixed h_ratio, v_ratio;int h, v;long error_red, error_green, error_blue;//JAM 11OCT94 for hack to get meters operating nice when loading textures [[[extern gLoadingTexture;	//global from textarray.cpp//JAM 11OCT94 for hack to get meters operating nice when loading textures ]]]// PRO-23 [[[#if MACINTOSHVCGrafPort savePort;VGrafDevice saveDevice;extern V_Offscreen *gOff8;#endif// PRO-23 ]]]	from_off->Lock();	to_off->Lock();		toPort = theObject->GetMetaPort(&cTo);	fromPort = GetMetaPort(&cFrom);    // PRO-23 [[[	#if MACINTOSH	VGetPort(&savePort, &saveDevice);	if (GetDepth() == 8)	{		gOff8->SetMetaPort();		SetGWorld(gOff8->metaPort, NULL);	// NULL is ignored    }	#endif    // PRO-23 ]]]	from_rect = *rfrom; 	to_rect = *rto;	from_cols = from_rect.right - from_rect.left;	from_rows = from_rect.bottom - from_rect.top;	to_cols = to_rect.right - to_rect.left;	to_rows = to_rect.bottom - to_rect.top;		ff_from.intg = from_cols;	ff_to.intg = to_cols;	ff_from.frac = ff_to.frac = 0;	h_ratio = FFDiv(ff_from, ff_to);		ff_from.intg = from_rows;	ff_to.intg = to_rows;	ff_from.frac = ff_to.frac = 0;	v_ratio = FFDiv(ff_from, ff_to);//JAM Jun94 When blitting to larger rectange, just repeat bits [[[	if((h_ratio.l <= FFOne.l) && (v_ratio.l <= FFOne.l))	{	FFixed ffh1, ffv1;	ffv1.intg = -to_rect.top;	ffv1.frac = 0;    ffv1 = FFMult(ffv1, v_ratio);	for ( v = to_rect.top ; v < to_rect.bottom ; v++ )	{		// reset error color for this scan line		ffh1.intg = -to_rect.left;		ffh1.frac = 0;        ffh1 = FFMult(ffh1, h_ratio);		for ( h = to_rect.left ; h < to_rect.right ; h++ )		{		RGBColor c, stored_c, want_c;//		FFixed fh, fv, ffh1, ffv1, ffh2, ffv2;//		int h0, v0;//		unsigned long num_pixels;//		long avg_red, avg_green, avg_blue, c_long;//		long v_avg_red, v_avg_green, v_avg_blue;// 	    long num_cols;//			fh.intg = h - to_rect.left;//			fv.intg = v - to_rect.top;//			fh.frac = fv.frac = 0;//			ffh1 = FFMult(fh, h_ratio);//			ffv1 = FFMult(fv, v_ratio);//			ffh1.intg += from_rect.left;//			ffv1.intg += from_rect.top;			c = GetPixelColor(ffh1.intg, ffv1.intg);			to_off->SetPixelColor(h, v, &c);			ffh1.l += h_ratio.l;		}		ffv1.l += v_ratio.l;	//JAM 11OCT94 for hack to get meters operating nice when loading textures [[[	if(gLoadingTexture)	{		long var1,var2,var3;		var1 = (TEXTUREMETERLOADLENGTH-1)*(v-to_rect.top);		var2 = to_rect.bottom-to_rect.top;		var3 = var1/var2;		if((var3 >= 0) && (var3 <= (TEXTUREMETERLOADLENGTH-1)))        {			MeterSetCount(var3);			MeterUpdate(0);        }	}	//JAM 11OCT94 for hack to get meters operating nice when loading textures ]]]	VSetCursor(vCursorEarth);    // jca 28 Dec 93.  This takes so durn long we need to handle the cursor.	}	}	else    {	for ( v = to_rect.top ; v < to_rect.bottom ; v++ )	{		// reset error color for this scan line		error_red = error_green = error_blue = 0;				for ( h = to_rect.left ; h < to_rect.right ; h++ )		{		RGBColor c, stored_c, want_c;		FFixed fh, fv, ffh1, ffv1, ffh2, ffv2;		int h0, v0;		unsigned long num_pixels;		long avg_red, avg_green, avg_blue, c_long;		long v_avg_red, v_avg_green, v_avg_blue;      long num_cols;			fh.intg = h - to_rect.left;			fv.intg = v - to_rect.top;			fh.frac = fv.frac = 0;			ffh1 = FFMult(fh, h_ratio);			ffv1 = FFMult(fv, v_ratio);			fh.intg = (h+1) - to_rect.left;			fv.intg = (v+1) - to_rect.top;			fh.frac = fv.frac = 0;			ffh2 = FFMult(fh, h_ratio);			ffv2 = FFMult(fv, v_ratio);			ffh1.intg += from_rect.left;			ffv1.intg += from_rect.top;			ffh2.intg += from_rect.left;			ffv2.intg += from_rect.top;						// compute the area-sampled color			h0 = ffh1.intg;			num_cols = 0;			v_avg_red = v_avg_green = v_avg_blue = 0;			do			{				num_pixels = 0;				avg_red = avg_green = avg_blue = 0;				v0 = ffv1.intg;				do				{					c = GetPixelColor(h0, v0);					avg_red += c.red;					avg_green += c.green;					avg_blue += c.blue;					num_pixels++;					v0++;				}				while (v0 < ffv2.intg);				v_avg_red += avg_red / num_pixels;				v_avg_green += avg_green / num_pixels;				v_avg_blue += avg_blue / num_pixels;				h0++;            num_cols++;			}			while (h0 < ffh2.intg);							// compute the average			want_c.red = v_avg_red / num_cols;			want_c.green = v_avg_green / num_cols;			want_c.blue = v_avg_blue / num_cols;			// add in the error term and clamp so that we don't get weird colors#if 0			c_long = want_c.red + error_red;			if (c_long < 0) c_long = 0;			else if (c_long > 0xFFFF) c_long = 0xFFFF;			c.red = c_long;						c_long = want_c.green + error_green;			if (c_long < 0) c_long = 0;			else if (c_long > 0xFFFF) c_long = 0xFFFF;			c.green = c_long;						c_long = want_c.blue + error_blue;			if (c_long < 0) c_long = 0;			else if (c_long > 0xFFFF) c_long = 0xFFFF;			c.blue = c_long;#endif			c = want_c;						// set the pixel to our computed colro			to_off->SetPixelColor(h, v, &c);			stored_c = to_off->GetPixelColor(h, v);						// compute the error -- note that we compute it with the color we wanted to store,			// not the value actually stored (which included the error term and was clamped)			// Note that the color we wanted was WITH the full error correction.			error_red = want_c.red + error_red - stored_c.red;			error_green = want_c.green + error_green - stored_c.green;			error_blue = want_c.blue + error_blue - stored_c.blue;		}	//JAM 11OCT94 for hack to get meters operating nice when loading textures [[[	if(gLoadingTexture)	{		long var1,var2,var3;		var1 = (TEXTUREMETERLOADLENGTH-1)*(v-to_rect.top);		var2 = to_rect.bottom-to_rect.top;		var3 = var1/var2;		if((var3 >= 0) && (var3 <= (TEXTUREMETERLOADLENGTH-1)))        {		VCGrafPort savePort;		VGrafDevice saveDevice;				VGetPort(&savePort,&saveDevice);        			MeterSetCount(var3);			MeterUpdate(0);		VSetPort(savePort,saveDevice);        }	}	//JAM 11OCT94 for hack to get meters operating nice when loading textures ]]]	VSetCursor(vCursorEarth);    // jca 28 Dec 93.  This takes so durn long we need to handle the cursor.	}	}//JAM Jun94 When blitting to larger rectange, just repeat bits ]]]	theObject->ReleaseMetaPort(toPort);	ReleaseMetaPort(fromPort);    // PRO-23 [[[	#if MACINTOSH	if (GetDepth() == 8)		gOff8->UnsetMetaPort();    VSetPort(savePort, saveDevice);	#endif    // PRO-23 ]]]	to_off->Unlock();	from_off->Unlock();}// theObject is the "from" offscreen// this is the "to" offscreenvoid V_Offscreen::ToPixel(V_Display *theObject,Rect *rfrom,Rect *rto){	this->SetMetaPort();	((V_Offscreen*)theObject)->PixelTo(this, rfrom, rto);	this->UnsetMetaPort();}// PixelTo and ToPixel ]]]/*==============================================================================*/int V_Pixel8::cPixel8(Rect *size,int depth,RGBColor *rgb, V_Array *ctab)	{	VCGrafPort savePort;	VGrafDevice saveDevice;	Rect r;	int err,result;	long sizeOfOff;		/*size in bytes of the off screen bit map*/	Rect brect;	ASSERT(depth == 8);	metaPort = 0;	// NOT A VALID METAPORT. FORCE DIRECT BITBLT    wMethodInit = 0;  // Don't use flash until told its ok...		resolution.h = resolution.v = 72; /* 72 pixels/inch */	err=FALSE;	lock = 0;	bitType = 0;	refCon = 0L;	screen = FALSE;		// NOT a main, physical screen	raster=NULL;	baseAddr=NULL;	bitmap=NULL;	SetDisplayType(DISPLAY_OFFSCREEN);	// DAS-VWINDOWS 10/9/93	bitDepth=depth;	colorTable  = NULL;#if MACINTOSH	MoveObjHi((Handle)this);#elif WINDOWS#endif //WINDOWS	rsize= *size;	rect = rsize;	clipRect=rsize;	rect.right-=rect.left;	rect.bottom-=rect.top;	rect.left=rect.top=0;	r=rect;		brect.top=0;	brect.left=0;	brect.bottom=max(1, rect.bottom);	brect.right=max(1, rect.right);	brect.right = (brect.right+3)&~3;		// force at least longword (or longer) align		rowBytes = ((brect.right));		// BUG- only works for 8bit textures	sizeOfOff = (long)rowBytes*(long)brect.bottom;#if WINDOWS	// Handle segment boundaries properly	wBmWidth = brect.right;	wBmHeight = brect.bottom;	wBmWidthBytes = rowBytes;	wBmPlanes = 1;	wBmBitsPixel = depth;	wBmSegmentIndex = FP_SEG(((char huge*)0xFFFF)+1);    // Calc segment specific stuff	wBmScanSegment = 0x10000L / rowBytes;	wBmFillBytes = 0x10000L - ((Long)wBmScanSegment*rowBytes);	// Change size of array to handle skipping seg boundaries    // Add a FillBytes each time we run out of scans per segment    // This assumes we start allocation at zero within a segment.    sizeOfOff += (ULong(wBmHeight-1)/wBmScanSegment) * wBmFillBytes;	// YECHH. We have no control over where our memory starts. So	// plan on having at least one Width lost due to not starting at the	// beginning of the segment.	sizeOfOff += rowBytes; #endif //WINDOWS	if(baseAddr)DisposHandle((Handle)baseAddr);	GrowMemory(FALSE);					//Only encompass the big access.	// GJR 10/26/93	err = (baseAddr=NewHandle(sizeOfOff)) ? FALSE : -1;	GrowMemory(TRUE);					//Only encompass the big access.	// GJR 10/26/93		 #if WINDOWS	// then get raster array set up now.	if (!err)		{		ASSERT(baseAddr != NULL);		baseAddress = (unsigned char *)HDeref(baseAddr);		} 	if (!err)			// JCA make a table of offsets into bitmap 20 aug 93		{			Long iRow, iHeight;			UChar *base;			// Create the array, make it the right size			iHeight = rect.bottom - rect.top;			if (!vaBmRowAddresses)				{ // create it fresh				vaBmRowAddresses = new(V_Array);				vaBmRowAddresses->cArray(iHeight,sizeof(LPBYTE),1);				}			lpbBmRowAddresses = (LPBYTE *)vaBmRowAddresses->Abuse();			// calc the starting base address (a number of lines)			base = (unsigned char *)baseAddress;             			for (iRow=0; iRow<iHeight; iRow++)				{                // First, verify that the line can fit into just this segment				if ( SPANNEDHUGE(base, (base + (rowBytes-1))) )                	{  // then move this line up one segment					UChar huge *hugeBase;					hugeBase = base;					hugeBase += (rowBytes-1);	// get to next segment					base = (UChar *)hugeBase;                    base -= FP_OFF(base);		// start us at zero in new segment                    }				lpbBmRowAddresses[iRow] = base;                					// update huge base. Could skip to next segment.				(UChar huge*)base += rowBytes;  // points to beginning of NEXT line				}			// DEBUG: verify we are still within our allocation            // base points to byte FOLLOWING current last line.			ASSERT( ((UChar huge*)base - (UChar huge*)baseAddress) <= sizeOfOff)		 }#endif //WINDOWS	return err;	}// ABD MERGE-TEXTURE 9/13/93 [[[/*------------------------------------------------------------------------------ * RGBColor V_Offscreen::GetPixelColor(int h, int v) * Returns the color of the specified pixel * * NOTE: for speed reasons a scan line in pixel8 does not span a segment boundary *       so no huge handling is needed within a row. *------------------------------------------------------------------------------*/RGBColor V_Pixel8::GetPixelColor(int h, int v){RGBColor c;UChar bIndex;	ASSERT(lock > 0);	// Must be locked prior to entry.	bIndex = ((UChar *)(lpbBmRowAddresses[v]))[h];	GetStandardColor(&c, bIndex);	return (c);}/*------------------------------------------------------------------------------ * void V_Offscreen::SetPixelColor(int h, int v, RGBColor *c) * Sets the specified pixel to the color which most closely matches the specified color. * * NOTE: for speed reasons a scan line in pixel8 does not span a segment boundary *       so no huge handling is needed within a row. *------------------------------------------------------------------------------*/void V_Pixel8::SetPixelColor(int h, int v, RGBColor *color){UChar bIndex;VCGrafPort savePort;		// PRO-19VGrafDevice saveDevice;		// PRO-19int no_color_map = FALSE;	// PRO-19	// PRO-19 [[[	#if MACINTOSH	VGetPort(&savePort, &saveDevice);	if (saveDevice)		if ((*saveDevice)->gdPMap)			if ((*((*saveDevice)->gdPMap))->pmTable)				if ((*((*((*saveDevice)->gdPMap))->pmTable))->ctSize == 0)				{					no_color_map = TRUE;				}	#endif	// PRO-19 ]]]	ASSERT(lock > 0);	// Must be locked prior to entry.	//get closest from color table, then store it.    #if 0 // PRO-23	if (no_color_map)// PRO-19	{	extern V_Offscreen *gOff8;// PRO-19		bIndex = gOff8->ColorTo256(color);// PRO-19	}	else// PRO-19	#endif // PRO-23		bIndex = GetClosestColor(color);	((UChar *)(lpbBmRowAddresses[v]))[h] = bIndex;}int V_Pixel8::GetRowWidth(void){return rowBytes;}void V_Pixel8::GetRect(Rect *r){ *r=rect; }voidV_Pixel8::dPixel8()	{	VHBitmap hBitmap;		if(lock)	{#if DEBUG		AlertMessage((strPtr)"V_Pixel8 is locked in dPixel8.");		DEBUGGER();		// ABD#endif	}	if(baseAddr)DisposHandle((Handle)baseAddr);	if (raster)	raster->dArray();    // jca 9 Oct 93#if WINDOWS	if (vaBmRowAddresses)	vaBmRowAddresses->dArray();       // jca 1 Nov 93#endif //WINDOWS	delete(this);	}V_Pixel8::GetDepth(void)	{	return bitDepth;	}VGrafDataV_Pixel8::GetMetaPort(Rect *r)	{	return NULL;  // no metaport for pixel8	}voidV_Pixel8::ReleaseMetaPort(VGrafData data)	{	}intV_Pixel8::SetMetaPort()	{	int err;	err = Lock();    return err;	}voidV_Pixel8::UnsetMetaPort()	{	Unlock();	}V_Pixel8::Lock()				// ABD MERGE6 WILLIAMS	{	int err;		err = FALSE;	ASSERT(lock >= 0);	lock++;	  if(lock==1)	  	{		ObjLock((ObjectHandle)this);		HLock(baseAddr);        UseRaster(NULL, NULL);	// Pixel8 needs easy direct access        }	return err;	}	void V_Pixel8::Unlock()				// ABD MERGE6 WILLIAMS	{	ASSERT(lock > 0);		// must be locked prior to unlocking.	lock--;	if (lock) return;    UnuseRaster(NULL, NULL);	// Pixel8 needs easy direct access	HUnlock((Handle)baseAddr);	ObjUnlock((ObjectHandle)this);	}unsigned char **V_Pixel8::UseRaster(VGrafPort *savePort, VGrafDevice *saveDevice)		// MERGE23	{	int height,i;	unsigned char **rdata,*base;    ASSERT(lock >= 1);	// verify things are locked before use.#if MACINTOSH	height=rect.bottom-rect.top;	if(!raster)		{		raster=new(V_Array);		raster->cArray(height+1,sizeof(char *),4);		rdata=(unsigned char **)raster->Use();		rdata[0]=0;/*guarantee that this is unique*/		}	else		rdata=(unsigned char **)raster->Use();	base=(unsigned char *)HDeref(baseAddr);	if(rdata[0]!=base)		{		rdata[0]=base;		for(i=1;i<=height;i++)			{			base += rowBytes;			rdata[i]=base;			}		}	lpbBmRowAddresses = rdata;#endif //MACINTOSH	return lpbBmRowAddresses;	}void V_Pixel8::UnuseRaster(VGrafPort *savePort, VGrafDevice *saveDevice)		// MERGE23	{#if MACINTOSH //!ELVIS	if(raster)raster->Unuse();#endif	}unsigned char* V_Pixel8::GetBaseAddr(void)	{	unsigned char *ba = NULL;    		//GJR 10/07/93	ba = (unsigned char *)HDeref(baseAddr);  		return(ba);	}/* cCreateCopy creates a Pixel8 and copies theObject to it   (thereby creating a copy) the "c" in cCreateCopy is to   signify that it is a creator routine.  routine by GJR,   comment and mods jca 22MAR94*/int V_Pixel8::cCreateCopy(struct V_Offscreen * theObject){Rect 		from_rect,to_rect;Rect 		cFrom,cTo;V_Offscreen *from = (V_Offscreen *)theObject;V_Pixel8    *to = this;int from_cols, from_rows, to_cols, to_rows;FFixed ff_from, ff_to;FFixed h_ratio, v_ratio;UChar **to_raster, **from_raster;int h, v;int ier = 0;int pixel8Depth;	pixel8Depth = 8;  // jca 23MAR94 default depth of the pixel8 we're creating	from_rect = from->rect;	ier = cPixel8(&from_rect, pixel8Depth, NULL, NULL);	if (ier) return(ier);	from->Lock();	to->Lock();		to_rect = to->rect;	from_cols = from_rect.right - from_rect.left;	from_rows = from_rect.bottom - from_rect.top;	to_cols = to_rect.right - to_rect.left;	to_rows = to_rect.bottom - to_rect.top;	ASSERT(from_rows == to_rows);	ASSERT(from_cols == to_cols);#if MACINTOSH	if (from->GetDepth() == pixel8Depth)    	{  // jca 23MAR94 this should always be the case		from_raster = (unsigned char **)from->UseRaster(NULL,NULL);		to_raster = (unsigned char **)to->UseRaster(NULL,NULL);		for ( v = 0 ; v < to_rows ; v++ )		{			/*			for ( h = 0 ; h < to_cols ; h++ )			{				to_raster[v][h] = from_raster[v][h];			}			*/			memcpy(to_raster[v], from_raster[v], to_cols);		}		to->UnuseRaster(NULL,NULL);		from->UnuseRaster(NULL,NULL);		}	// jca 23MAR94 somebody has screwed up and given us an offscreen	// of a weird depth (we expect to get an offscreen of depth 8)    // So we have to do this copy on a pixel-by-pixel basis.	else#endif // MACINTOSH		{		for ( v = 0 ; v < to_rows ; v++ )			{			for ( h = 0 ; h < to_cols ; h++ )				{				RGBColor color;				color = from->GetPixelColor(h, v);				to->SetPixelColor(h, v, &color);				}			}		}	to->Unlock();	from->Unlock(); 		return(ier);}// jca 15 Nov 93intV_Pixel8::IO_INIT_READER(Rect *r, int depth, V_Array *cmap)  // jca 15 Dec 93{	return(cPixel8(r, 8, NULL, cmap));}intV_Pixel8::IO_BITMAP_STRIPE(V_Buffer *buf, V_Array *clrmap, long size, long rowSize, long start, long nLinesToDo, int compression, int bDepth){Short	depth;int err = noErr, it;ULong localRowSize, toRead;long 	i,j,k;#if WINDOWSchar	*bits;char 	translation[256];Handle	bitbuf;RGBColor *prgb, rgb;#endif // MACINTOSH	depth = bDepth;	if (buf->IODirection() == DATA_OUT)		{		VSetCursor(vCursorEarth);		// write the offscreen data with our processor's native scan line padding.//#if WINDOWS		// ABD 3/11/94 made this thing actually write some data		SetMetaPort();		for  (i = 0; i < nLinesToDo && !err; i++)			{            // write the scans, one at a time			err = err?err:buf->IOData(lpbBmRowAddresses[i], rowSize);			if (!(i & 0x0F))		VSetCursor(vCursorEarth);			}		UnsetMetaPort();//#endif // WINDOWS// ABD 3/11/94 made this thing actually write some data		}	else		{		VSetCursor(vCursorEarth);		// read the offscreen data#if WINDOWS		// first, set up the colortable		if (clrmap)			{			prgb = (RGBColor*)clrmap->Use();			if (depth == 1)				{				translation[0] = GetClosestColor(&(prgb[0]));				translation[1] = GetClosestColor(&(prgb[1]));                // set up these for speed, so we won't have to shift				translation[4] = translation[2] = translation[1];				translation[16] = translation[8] = translation[1];				translation[64] = translation[32] = translation[1];				translation[128] = translation[1];				}			else if (depth == 4)				{				for (i = 0; i < clrmap->ALength(); i++)					{  // again, to avoid shifting					translation[i*16] = translation[i] = GetClosestColor(&(prgb[i]));                    }				}			else if (depth == 8)            	{				for (i = 0; i < clrmap->ALength(); i++)					{                	translation[i] = GetClosestColor(&(prgb[i]));					}				}			else				{                clrmap->Unuse();				return(-1);  // bad!                }			clrmap->Unuse();			}		else        	{			if (bDepth <= 8)	err = -1;  // needs a colormap            }		// do the evil Windows(tm) things.		localRowSize = (rowSize*bDepth + 7)/8;															if (localRowSize < 65536L)			 bitbuf = NewHandle(localRowSize);		else        	err = -1;		// Keep trying to get a big buffer.  Halve the requested buffer		// size each time until either we get a buffer or the size is		// less than a single scan line.		if (bitbuf == NULL)	err = err?err:-1;		// now get the bits, and stuff them into the bitmap.		if (!err)			{			HLock(bitbuf);			bits = (char *) HDeref(bitbuf);			memset(bits, 0, localRowSize);  // clear the buffer			toRead = rect.right - rect.left; // exact size of bitmap data			SetMetaPort();			for (i = 0; i < nLinesToDo && !err; i++)				{				err = err?err:buf->IOData(bits, localRowSize);				if (!(i & 0x0F))		VSetCursor(vCursorEarth);				switch (bDepth)					{					case 1:						for (j = 0, it = 0, k = 0; j < toRead; j++, it++)							{  // translation values are all pre-shifted							if (it == 0)		lpbBmRowAddresses[i][j] = translation[bits[k]&0x01];							else if (it == 1)	lpbBmRowAddresses[i][j] = translation[bits[k]&0x02];							else if (it == 2)	lpbBmRowAddresses[i][j] = translation[bits[k]&0x04];							else if (it == 3)	lpbBmRowAddresses[i][j] = translation[bits[k]&0x08];							else if (it == 4)	lpbBmRowAddresses[i][j] = translation[bits[k]&0x010];							else if (it == 5)	lpbBmRowAddresses[i][j] = translation[bits[k]&0x020];							else if (it == 6)	lpbBmRowAddresses[i][j] = translation[bits[k]&0x040];							else {				lpbBmRowAddresses[i][j] = translation[bits[k]&0x080]; k++; it = -1;}							}						break;					case 4:						for (j = 0, k = 0; j < toRead; j++)							{							if (j&0x01)								{								lpbBmRowAddresses[i][j] = translation[bits[k]&0x0F0];								k++;                                }							else								lpbBmRowAddresses[i][j] = translation[bits[k]&0x00F];							}						break;					case 8:						for (j = 0; j < toRead; j++)							lpbBmRowAddresses[i][j] = translation[bits[j]];						break;					case 16:						for (j = 0, k = 0; j < toRead; j++, k += 2)							{							rgb.red = (bits[k] >> 2) & 0x1F;							rgb.green = ((bits[k+1] << 3) & 0x18) | ((bits[k+2] >> 5) & 0x03);                            rgb.blue = (bits[k+2] & 0x1F);							lpbBmRowAddresses[i][j] = GetClosestColor(&rgb);                            }						break;					case 24:						for (j = 0, k= 0; j < toRead; j++, k += 3)							{							rgb.red = bits[k];							rgb.green = bits[k+1];                            rgb.blue = bits[k+2];							lpbBmRowAddresses[i][j] = GetClosestColor(&rgb);;                            }						break;					case 32:						for (j = 0, k = 0; j < toRead; j++, k += 4)                        	{							rgb.red = bits[k];							rgb.green = bits[k+1]; 						    rgb.blue = bits[k+2];							lpbBmRowAddresses[i][j] = GetClosestColor(&rgb);                            }						break;					default:						err = -1;                        break;					}				}			UnsetMetaPort();			HUnlock(bitbuf);			DisposHandle(bitbuf);            }#endif // WINDOWS		}	return(err);}intV_Pixel8::IO_CMAP(V_Buffer *buf, V_Array *map, int depth){	ULong	color;	RGBColor rgb;	long nColors;	int i;	int err = noErr;	VCGrafPort savePort;	VGrafDevice saveDevice;	int no_color_map = FALSE;	if (depth <= 8)  // only for palette color images		{		if (buf->IODirection() == DATA_OUT)			{            SetMetaPort();			nColors = 1<<depth;			// PRO-19 [[[			#if MACINTOSH			// this lame fix is for thousands of colors, which for some reason does not			// have a color map.  This tests to make sure a 256-entry color map is there,			// and then it 			VGetPort(&savePort, &saveDevice);            #if 0 // PRO-23 don't do this			if (saveDevice)				if ((*saveDevice)->gdPMap)					if ((*((*saveDevice)->gdPMap))->pmTable)						if ((*((*((*saveDevice)->gdPMap))->pmTable))->ctSize == 0)						{							no_color_map = TRUE;						}            #endif // 0			#endif // MACINTOSH			// PRO-19 ]]]			// write the colormap			for (i = 0; i < nColors && !err; i++)				{				#if MACINTOSH 	// PRO-23				extern V_Offscreen *gOff8;// PRO-19				// PRO-19 get a standard color from our guaranteed 8-bit colormap					gOff8->IndexToColorNew(&rgb, (long)i);	// PRO-19				#else                	GetStandardColor(&rgb, (long)i);	// PRO-18// PRO-19                #endif				color = (((ULong)(rgb.red)) << 8) & 0x00FF0000 |					((ULong)(rgb.green))  & 0x0000FF00 |					(((ULong)(rgb.blue)) >> 8) & 0x000000FF;				err = buf->IOType((void *)&color, IO_LONG);				if (!(i & 0x0F))		VSetCursor(vCursorEarth);				}			UnsetMetaPort();			}		else			{			// read the color count			nColors = buf->ChunkSize()/sizeof(ULong);            // read in nColors colors			for (i = 0; i < nColors && !err; i++)				{				err = buf->IOType((void *)&color, IO_LONG);				rgb.red = (color >> 8) & 0xFF00;				rgb.green = (color) & 0xFF00;				rgb.blue = (color<<8) & 0xFF00;                map->Append(&rgb);				if (!(i & 0x0F))		VSetCursor(vCursorEarth);				}			}		}	return(err);}/*==============================================================================*/