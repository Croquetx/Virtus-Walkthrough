/*------------------------------------------------------------------------------ * Virtus WalkThroughÂ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				 *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *	DAS-VWIN 9/17/93 - this had a large rewrite to support printing bitmapped images. *						This now consistently prints at 72-DPI. *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VPrint.h"#include "VDocumnt.h"#include "VGraphic.h"#include "VGUtil.h"#include "VPane.h"#include "VDialog.h"#include <string.h>#include "VMemUtil.h"#include "VTextDef.h"#include "AppText.h"	//PRO-JAP#if WINDOWS#include <stdio.h>#include <print.h>#include "VError.h"#endif#if MACINTOSH#include <QDOffscreen.h>WindowPtr aWindow=NULL;VGrafPort 	psavePort;VGrafDevice 	psaveDevice;#define MAXPRESERVE 62536L// Application-defined error codes used by resources and AlertUser:#define unknownErr		    0		/* OK to use 0, since it's noErr.		*/#define no32BQDErr			31		/* OK to use 31, it's obsolete.			*/#define noPrinterChosenErr	42		/* OK to use 42, it's obsolete.			*/OSErr CommandPeriod(void);pascal void IdleProc(void);#elif WINDOWSstatic PRINTDLG	printDialog;#endif //MACINTOSHOSErrV_Print::OpenPrinter(void)	{	OSErr err = FALSE;	V_Document *activeDocument=ActiveDocument();	ObjLock((ObjectHandle)this);#if MACINTOSH	openFlag++;	if(openFlag==1)		{		if(activeDocument)			{			char str[256];			Rect r = { 0,0,1,1 };						VGetPort(&psavePort,&psaveDevice);			activeDocument->GetTitle(str);			C2Pstr(str);			aWindow = NewWindow(NULL ,&r, (StringPtr)str, TRUE, 1, (WindowPtr)-1L, FALSE, 0L);			}		PrOpen();		}	err= PrError();	if(!err)    	{		if(prRec==NULL)			{ 			// { DAS-VPRINT 9/24/93			prRec = (TPrint **) NewHandle( sizeof( TPrint ));			if(prRec)				{				PrintDefault(prRec);				err=PrError();            	PrValidate(prRec);			/* Force internal consistency too */            	}            else             	{            	err = iMemFullErr;             	PrSetError(err);            	}            // } DAS-VPRINT 9/24/93			}		}#elif WINDOWS	if(activeDocument)		{		activeDocument->GetTitle(docName);		}	if (printDC)    	{		SetDisplayPort();		SetGraphicContext(printDC);		}	else		{        prErr = -1;		err = -1;        }#endif //MACINTOSH	return err;	}	OSErr V_Print::ClosePrinter(void)	{#if MACINTOSH	openFlag--;	if(openFlag==0)		{		PrClose();		if(aWindow)			{			CloseWindow(aWindow);			aWindow=0;			VSetPort(psavePort,psaveDevice);			}		}#elif WINDOWS	if (printDC)		UnsetDisplayPort();#endif //MACINTOSH	ObjUnlock((ObjectHandle)this);	return PrError();	}	voidV_Print::cPrint()	{	int flag;	openFlag=0;	SetDisplayType(DISPLAY_PRINT);// DAS VWINDOWS 10/9/93// DAS-VPRINT 9/24/93#if MACINTOSH	prRec = NULL;#elif WINDOWS/* fill in non-variant fields of PRINTDLG struct. */	memset((char *) &printDialog, 0, sizeof(PRINTDLG));	printDialog.lStructSize    = sizeof(PRINTDLG);	printDialog.hDevMode       = NULL;	printDialog.hDevNames      = NULL;	printDialog.Flags          = PD_RETURNDC | PD_NOSELECTION | PD_NOPAGENUMS | PD_USEDEVMODECOPIES;	printDialog.nCopies        = 1;	prErr = 0;	// no errors	UpdatePrinterStatus();    rect.top = rect.left = 0; rect.bottom = rect.right = 1;#endif // windows	resolution.h = resolution.v = 72; /* 72 pixels/inch */	}voidV_Print::dPrint(void)	{#if MACINTOSH	if(prRec)DisposHandle((Handle)prRec);#elif WINDOWS	if (printDialog.hDevMode != NULL)    	{		GlobalFree(printDialog.hDevMode);        printDialog.hDevMode = NULL;		}	if (printDialog.hDevNames != NULL)		{		GlobalFree(printDialog.hDevNames);		printDialog.hDevNames = NULL;		}#endif //MACINTOSH	delete(this);	}OSErrV_Print::StyleDialog(void)	{	OSErr		err=noErr;#if MACINTOSH	Boolean		doIt;	short		resetThedpi;// Make sure we're working with a default resolution print record, and open// the printer driver.  Since (in this sample) we don't know what resolution// we'll be setting the printer port to until after the dialogs, it's best to// use a default dpi handle now so that options (which may be ignored when we// print at high resolutions) are at least available in case they *can* be used.//// What makes things tricky is that different printer drivers support// different ways of resetting the printer port resolution to 72 dpi.  You // always use PrGeneral, but the ImageWriter driver, for example, goes to "true"// default resolution mode only when you try to set an invalid resolution such// as 0x0 dpi, and the LaserWriter makes you pass 72x72 to get to 72 dpi.// Neither respects the other's way of doing things.  (For an example, try setting// the ImageWriter's print handle to 72x72 dpi with PrGeneral, and then doing a// style dialog with that.)// // One solution which I've found to work well is to first try to set the port to// 72x72 dpi, and then try to set it to 0x0 dpi.  Drivers which reset when passed// 72x72 ignore the 0x0 setting, and drivers that need to be passed 0x0, are happy// as well.  Remember that the order is important here.  If you tell the IW driver// that you want 72x72 dpi, it will disable options in the print dialog that// shouldn't be.  Only when it tries to set the bogus 0x0 dpi will it clean house.//// Unfortunately, this is one of the design short-comings of the current// printing architecture, or more specifically, the current printer drivers.// If drivers don't disable options at different resolutions, we have no// problem at all.	resetThedpi = 72;				// Pass 72x72 dpi to force the defaults.	SetResolution(resetThedpi, resetThedpi);	resetThedpi = 0;				// Pass a bogus pair to force the defaults.	SetResolution(resetThedpi, resetThedpi);									// One of those should work.// Handle the style dialog, close the driver and clean up any windows that// need updating.	PrOpen();	err = PrError();		if (err == fnfErr)	// Here, "file not found" really means "no printer chosen."		err = noPrinterChosenErr;		if (!err)	{		doIt = PrStlDialog(prRec);		err = PrError();		if (!err && !doIt) err = iPrAbort;	}	PrClose();#elif WINDOWS	int	saveFlags;	V_Pane *ourPane;	V_Document	*theDoc;    HWND	theOwner;	theDoc = ActiveDocument();	if (theDoc)	theOwner = theDoc->GetFrame();	else		theOwner = NULL;	saveFlags = printDialog.Flags; 	printDialog.Flags &= ~PD_RETURNDC;	printDialog.Flags |= (PD_PRINTSETUP | PD_RETURNIC); // jca get an info context	printDialog.hwndOwner = theOwner;	/* the PrintDlg() call uses our callbacks to operate,	and in the process sets itself to be the current pane	(and then unsets itself).  This wipes the pane we want	to be current from the face of the Earth.  Blech.  So,    we must save ourPane and then restore it after the call */    ourPane = GetCurrentPane();	SetCurrentPane(NULL);	// jca 4Feb94 if the currentpane is set, it tries to refresh the printer.  Let the refreash happen quietly.	err = DoPrinterDialog();    SetCurrentPane(ourPane);	if (printDialog.hDC)		DeleteDC(printDialog.hDC);    printDialog.hDC = NULL;	printDialog.Flags = saveFlags;#endif //MACINTOSH	return(err);	}OSErrV_Print::JobDialog(void)	{	OSErr err = FALSE;#if MACINTOSH	if(!(err=OpenPrinter()))		{		PrValidate(prRec); // DAS-BUGFIX 10/16/93		err = !PrJobDialog(prRec);		}	ClosePrinter();#elif WINDOWS	V_Pane	*ourPane;	V_Document	*theDoc;	HWND	theOwner;	theDoc = ActiveDocument();	if (theDoc)	theOwner = theDoc->GetFrame();	else		theOwner = NULL;	printDialog.hwndOwner = theOwner;	prErr = 0;	/* reset the error flag */	/* the PrintDlg() call uses our callbacks to operate,	and in the process sets itself to be the current pane	(and then unsets itself).  This wipes the pane we want	to be current from the face of the Earth.  Blech.  So,    we must save ourPane and then restore it after the call */	ourPane = GetCurrentPane();    SetCurrentPane(NULL);	// jca 4Feb94 if the currentpane is set, it tries to refresh the printer.  Let the refreash happen quietly.	err = DoPrinterDialog();	// do the dialog	SetCurrentPane(ourPane);	printDC = printDialog.hDC;#endif //MACINTOSH	return err;	}voidV_Print::OpenDoc(void)	{#if MACINTOSH	(**prRec).prJob.iLstPage = 1;	(**prRec).prJob.iFstPage = 1;	PrValidate(prRec);	(**prRec).prJob.iLstPage = 1;	(**prRec).prJob.iFstPage = 1;	prPort = PrOpenDoc(prRec,NULL,NULL);#elif WINDOWS	DOCINFO	docInfo;    char	str[128];	docInfo.cbSize = sizeof(docInfo);	docInfo.lpszDocName = docName;	docInfo.lpszOutput = NULL;	if (printDC)		{        V_Pane *ourPane;		/* as you may recall, the PrintDlg() call uses our callbacks to operate,		and in the process sets itself to be the current pane		(and then unsets itself).  This wipes the pane we want		to be current from the face of the Earth.  Blech.  So,    	we must save ourPane and then restore it after the call */    	ourPane = GetCurrentPane();		SetCurrentPane(NULL);	// jca 4Feb94 if the currentpane is set, it tries to refresh the printer.  Let the refreash happen quietly.		StartDoc(printDC, &docInfo);		SetCurrentPane(ourPane);		/* we should put a meter in here		so they can cancel the printing.		sprintf(str,TXT_PRINTING, docName);	// PRO-JAP		MeterSetTotal(-1);		MeterSetText(str);        */		}	else    	prErr = -1;#endif //MACINTOSH	}voidV_Print::CloseDoc(void)	{#if MACINTOSH	PrCloseDoc(prPort);	prPort = NULL;#elif WINDOWS		V_Pane *ourPane;	if (PrError())		{		/* save the pane, then restore */		ourPane = GetCurrentPane();		SetCurrentPane(NULL);	// jca 4Feb94 if the currentpane is set, it tries to refresh the printer.  Let the refreash happen quietly.		AbortDoc(printDC);		SetCurrentPane(ourPane);		if (prErr < 0)			AlertMessage(TXT_PRINTERR);		}	else    	EndDoc(printDC);#endif //MACINTOSH	}voidV_Print::OpenPage(void)	{#if MACINTOSH	PrOpenPage(prPort,NULL);//	SetPort((GrafPtr)prPort); DAS-BUGFIX 10/16/93 this is already set	GetGWorld(&prtGWorld, &prtGDH);//DAS-BUGFIX 10/16/93 moved this to here#elif WINDOWS	int result;	V_Pane *ourPane = GetCurrentPane();     // ABD MERGE-PRINT	// ABD MERGE-PRINT don't do StartPage for banded printing	if (ourPane->bandPrint != TRUE)	{		result = StartPage(printDC);		if (result <= 0)			prErr = -1;   }#endif //MACINTOSH	}voidV_Print::ClosePage(void)	{#if MACINTOSH	SetGWorld(prtGWorld, prtGDH); // DAS-BUGFIX 10/16/93 just to be sure	PrClosePage(prPort);#elif WINDOWS	int result;	V_Pane *ourPane = GetCurrentPane();   	  // ABD MERGE-PRINT   // ABD MERGE-PRINT don't do EndPage for banded printing	if (ourPane->bandPrint != TRUE)	{		result = EndPage(printDC);		if (result < 0)			prErr = result;	}#endif //MACINTOSH	}intV_Print::PageSetup(void)	{	int		flag = TRUE;	/* presume style changed */#if MACINTOSH	if(!OpenPrinter())		{		flag = StyleDialog();		}	ClosePrinter();#elif WINDOWS	flag = StyleDialog();#endif //MACINTOSH	return flag;	}int savePQDFlag;// In case we don't have the universal headers...#if MACINTOSH	#ifndef NewPrIdleProc		#define NewPrIdleProc(x) (ProcPtr)x	#endif#endifintV_Print::Begin(void)	{	OSErr err;	if (err=JobDialog())		return err;	if(err=SetResolution(72,72))		return err;	if(!(err=OpenPrinter()))		{#if MACINTOSH              // jca 27 Sept 93     {		(*prRec)->prJob.pIdleProc = NewPrIdleProc(IdleProc);#endif                     // jca 27 Sept 93     }		savePQDFlag=UsePlatformDraw(TRUE);		OpenDoc();		if (PrError()) goto errDoc;		OpenPage();		if (PrError()) goto errPage;//#if MACINTOSH               // jca 27 Sept 93    {	//	GetGWorld(&prtGWorld, &prtGDH);//DAS-BUGFIX 10/16/93 moved this somewhere else;//#endif                      // jca 27 Sept 93    }		return FALSE;	errPage:		ClosePage();	errDoc:		CloseDoc();		ClosePrinter();		UsePlatformDraw(savePQDFlag);		}	else		{		ClosePrinter();		/* keep it matched up */		}	return err;	}intV_Print::NextPage(void)	{	ClosePage();	OpenPage(); 		return(0);	// jca 10JAN93	}intV_Print::End(void)	{	OSErr err = FALSE;#if MACINTOSH	ClosePage();	CloseDoc();	if ((*prRec)->prJob.bJDocLoop == bSpoolLoop && PrError() == noErr)		{		PrPicFile(prRec,NULL,NULL,NULL,&prStatus);		(*prRec)->prJob.pIdleProc = nil;		}#elif WINDOWS	ClosePage();	CloseDoc();     #endif //MACINTOSH	err=PrError();	ClosePrinter();	UsePlatformDraw(savePQDFlag);	/* should we delete the device context? */#if WINDOWS    if (printDC)			DeleteDC(printDC);#endif //WINDOWS	return err;	}		voidV_Print::GetRect(Rect *r)	{#if MACINTOSH	*r=(*prRec)->prInfo.rPage;#elif WINDOWS 	int	x, y;	rect.top = rect.left = 0;	x = GetDeviceCaps(printDC, HORZRES);	y = GetDeviceCaps(printDC, VERTRES);	if ((x <= 0) || (y <=0))		{        prErr = 1;		}	rect.right = x;	rect.bottom = y;	*r = rect;#endif //MACINTOSH	}OSErrV_Print::SetResolution(int hRes, int vRes)	{	OSErr err=FALSE;        // jca 27 Sept 93#if MACINTOSH	TGetRslBlk get;	TSetRslBlk set;	if(!(err=OpenPrinter()))		{		memset(&get,0,sizeof(TGetRslBlk));		memset(&set,0,sizeof(TSetRslBlk));		get.iOpCode=4;		set.iOpCode=5;		get.iError=set.iError=0;		get.lReserved=set.lReserved=0;				set.hPrint=prRec;		PrGeneral((Ptr)&get);		if(PrError() || get.iError)        	{  /* then either interface or driver isn't happy */			ClosePrinter();  /* keep open/close balanced */            return -1; /* this print driver does not support this command */			}		if(get.xRslRg.iMax)			{			set.iXRsl=min(hRes,get.xRslRg.iMax);			set.iYRsl=min(vRes,get.yRslRg.iMax);			set.iXRsl=max(set.iXRsl,get.xRslRg.iMin);			set.iYRsl=max(set.iYRsl,get.yRslRg.iMin);			}		else			{			set.iXRsl=min(hRes,get.rgRslRec[get.iRslRecCnt-1].iXRsl);			set.iYRsl=min(vRes,get.rgRslRec[get.iRslRecCnt-1].iYRsl);			set.iXRsl=max(set.iXRsl,get.rgRslRec[0].iXRsl);			set.iYRsl=max(set.iYRsl,get.rgRslRec[0].iYRsl);			}		PrGeneral((Ptr)&set);		err=PrError();		}	ClosePrinter();#elif WINDOWS/* nothing happens fur windows */#endif //MACINTOSH	return err;	}	int V_Print::GetDepth(void)	{#if MACINTOSH	int i;	CGrafPtr CGP;		if(prPort->gPort.portBits.rowBytes & 0xC000)		{		/*we have a CGrafPort*/		CGP=(CGrafPtr)&prPort->gPort;		return((*CGP->portPixMap)->pixelSize);		}	else return 0;#elif WINDOWS	return(1);  /* doesn't currently matter */#endif //MACINTOSH	}// { DAS-VWIN 9/17/93VGrafDataV_Print::GetMetaPort(Rect *r)	{	VGrafData data;	VCGrafPort cdata;			GetRect(r);#if MACINTOSH				if(GetDepth())		data=(VGrafData) *((CGrafPtr)prPort)->portPixMap;	else 	// DAS-BUGFIX 10/14/93		data=(VGrafData)&(prPort->gPort.portBits);#elif WINDOWS	// ELVIS data=prPort;#endif //WINDOWS	return data;	}int V_Print::SetMetaPort(void)	{	lock++;#if MACINTOSH	SetGWorld(prtGWorld, prtGDH);#elif WINDOWS	// ELVIS#endif // MACINTOSH  	return(0);	// jca 10JAN93 make it return _something_.	}	void V_Print::UnsetMetaPort(void)	{	lock--;	}// } DAS-VWIN 9/17/93void V_Print::ToMeta(V_Display*from,Rect *fR, Rect *tR)	{			Rect dummy;// { DAS-VWINDOWS-FIX 10/1/93#if MACINTOSH	if(GetDepth()==0)// this is not a color QuickDraw printer		{		V_Offscreen *oneBit;		Rect r;		from->GetRect(&r);		oneBit=new(V_Offscreen);		oneBit->cOffscreen(&r,0,NULL,NULL);		from->SetMetaPort();		oneBit->SetMetaPort();		oneBit->Blit(from->GetMetaPort(&dummy),oneBit->GetMetaPort(&dummy),&r,&r,ditherCopy);		from->UnsetMetaPort();		oneBit->UnsetMetaPort();		oneBit->SetMetaPort();		SetMetaPort();		Blit(from->GetMetaPort(&dummy),GetMetaPort(&dummy),fR,tR,vSrcCopy);    // jca 27 Sept 93		oneBit->UnsetMetaPort();		oneBit->dOffscreen();		UnsetMetaPort();		}	else#endif		{		from->SetMetaPort();		SetMetaPort();		Blit(from->GetMetaPort(&dummy),GetMetaPort(&dummy),fR,tR,vSrcCopy);    // jca 27 Sept 93		from->UnsetMetaPort();		UnsetMetaPort();		}// } DAS-VWINDOWS-FIX 10/1/93	}#if WINDOWSvoidV_Print::UpdatePrinterStatus(void){	char	string[128];    memset(string, 0, 128);	GetProfileString("windows","device","",(LPSTR)string, 128);	if (strlen(string))		defPrinter = TRUE;	else		defPrinter = FALSE;}#if 0   // test rroutine for finding out all about a printerintV_Print::GetRealDimensions(void){	if (printDialog.hDevMode)		{		DEVMODE *dmode;		int landscape, paperSize, paperWidth;		int paperLength, xRes, yRes, scale, color;		int vector, rasterp, horzsize, vertsize, horzres, vertres;		int logpixelsx, logpixelsy;		int scaling;		Point scalePt;        Rect clipRect;		dmode = (DEVMODE*)GlobalLock(printDialog.hDevMode);		if (dmode)			{            if (dmode->dmFields & DM_ORIENTATION)				landscape = (dmode->dmOrientation==DMORIENT_LANDSCAPE)?1:0;			else landscape = -1;			if (dmode->dmFields & DM_COLOR)				color = (dmode->dmColor==DMCOLOR_COLOR)?1:0;			else				color = -1; 			if (dmode->dmFields & DM_SCALE)				scale = dmode->dmScale;			else				scale = -1;			if (dmode->dmFields & DM_PAPERSIZE)				paperSize = dmode->dmPaperSize;			else            	paperSize = -1;			if (dmode->dmFields & DM_PAPERLENGTH)				paperLength = dmode->dmPaperLength;			else            	paperLength = -1;			if (dmode->dmFields & DM_PAPERWIDTH)				paperWidth = dmode->dmPaperWidth;			else            	paperWidth = -1;			if (dmode->dmFields & DM_PRINTQUALITY)				xRes = dmode->dmPrintQuality;			else            	xRes = -1;			if (dmode->dmFields & DM_YRESOLUTION)				yRes = dmode->dmYResolution;			else            	yRes = -1;			horzsize = GetDeviceCaps(printDC, HORZSIZE);			vertsize = GetDeviceCaps(printDC, VERTSIZE);			horzres = GetDeviceCaps(printDC, HORZRES);			vertres = GetDeviceCaps(printDC, VERTRES);			logpixelsx = GetDeviceCaps(printDC, LOGPIXELSX);			logpixelsy = GetDeviceCaps(printDC, LOGPIXELSY);			vector = (GetDeviceCaps(printDC, TECHNOLOGY))&DT_PLOTTER?1:0;			rasterp = (GetDeviceCaps(printDC, TECHNOLOGY))&DT_RASPRINTER?1:0;			scaling = Escape(printDC, GETSCALINGFACTOR, NULL,NULL, &scalePt);			GetClipBox(printDC, &clipRect);			}        GlobalUnlock(printDialog.hDevMode);		}}#endifvoidV_Print::ScalePrinterRect(Rect *printerRect){	Point scaleFactor;	int scaling, xScale, yScale;	scaling = Escape(printDC, GETSCALINGFACTOR, NULL, NULL, &scaleFactor);	if (scaling > 0)		{		// then we scale.		xScale = 1 << scaleFactor.h;		yScale = 1 << scaleFactor.v;		printerRect->left /= xScale;		printerRect->right /= xScale;		printerRect->top /= yScale;		printerRect->bottom /= yScale;        }}// Windows uses the same call to do both the style and job dialogs (just with// different flags).  So we can isolate the code.intV_Print::DoPrinterDialog(void){	HDC 	tempDC;    int 	notOk, technology, err;	// jca 11FEB94 Do not allow the user to choose a plotter or text printer	// (we don't support them)    err = noErr;	notOk = 1;	while (notOk)    	{		err = !(PrintDlg(&printDialog));		if (!err)			{			tempDC = printDialog.hDC;            if (!tempDC)				{ // no DC -- bad error.  !!!!ELVIS				// try to create one....				if (printDialog.hDevNames)					{					char *driver, *device, *port, *names;                    DEVNAMES *devNames;					if (printDialog.hDevNames)						{						devNames = (DEVNAMES *)GlobalLock(printDialog.hDevNames);                        names = (char*)devNames;						driver = &names[devNames->wDriverOffset];						device = &names[devNames->wDeviceOffset];						port = &names[devNames->wOutputOffset];						tempDC = CreateDC(driver, device, port, NULL);						if (tempDC)							printDialog.hDC = tempDC;						GlobalUnlock(printDialog.hDevNames);						}                    }				}			if (tempDC) // check again				{				technology = GetDeviceCaps(tempDC, TECHNOLOGY);				if (technology == DT_PLOTTER)					AlertMessage(TXTERR_PLOTTER);				else if (technology == DT_CHARSTREAM)					AlertMessage(TXTERR_TEXTPRINTER);				else                	notOk = 0;  // ok!				}			else				{				err = -1;                notOk = 0;				}			}		else        	notOk = 0;		}    return(err);}#elif MACINTOSH/************************************************************  IdleProc - This routine is a PrIdleProcPtr that spins our  cursor and looks for command-period presses during  printing.*************************************************************/pascal void IdleProc(void){	OSErr		err;		VSetCursor(vCursorEarth);	if (err = CommandPeriod()) PrSetError(err);}/************************************************************  CommandPeriod - This routine checks to see if the user has  pressed command-period.  The Printing Manager does this  for us, but a routine like this is helpful to allow users  to cancel in the middle of a rendering routine, rather  than only Printing Manager operations.    If there's a command-period in the event queue, the  routine returns iPrAbort just like the Printing Manager.  Otherwise, it returns noErr.*************************************************************/OSErr CommandPeriod(void){	Boolean		cancel = false;	EventRecord	evtRec;		while (!cancel && (WaitNextEvent(keyDownMask | autoKeyMask, &evtRec, 0, nil)))		cancel = (evtRec.modifiers & cmdKey) &&				 ((evtRec.message & charCodeMask) == '.');	return ((cancel)? iPrAbort: noErr);}#endif //WINDOWS