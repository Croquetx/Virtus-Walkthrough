/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				 *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VDocumnt.h"#include "VWindow.h"#include "VMenu.h"#include "VFile.h"#include "VArray.h"#include "VPrint.h"#include "VDialog.h"#include "VMain.h"#include "VAbout.h"#include "VGraphic.h"#include "VGUtil.h"#include "VColor.h"#include "VTextDef.h"#include "ToolDef.h"#include "VWI.h"		// jca 29 aug 93.#include <stdio.h>#include <string.h>/*------------------------------------------------------------------------------ * theSuper is a global array of V_Documents.  This is how we keep track of * how many V_Documents there are in the system and it also allows the  * V_Documents a method of communicating with each other.  The sMenu object is * a V_Menu that has all of the names of the documents.  When more then one * V_Document is running in the system, this menu is displayed on the menubar. *------------------------------------------------------------------------------*/#if VRint VRLibFlag = 1;     // JCA 3 Sept 93#endifV_Array *theSuper=NULL;V_Document *stub=NULL;int docCount=1;#if MACINTOSHstruct V_WindowMenu *theWindowMenu;#endif //MACINTOSH#if WINDOWS#include "ShellAPI.h"char *documentClassName = "Virtus:DocProc";V_Document *currentDocument = NULL;// WARNING: changing the current document can cause a crash if there is a stub.void SetCurrentDocument(V_Document *doc) { currentDocument = doc; } V_Document *GetCurrentDocument() { return currentDocument; }// jca 30MAR94 really sticky code to do nasty stuff, like look at a// windows(tm) command parameter to see if it is going to make the document// minimized or not.  Ick-o.  The params are stripped from windows.hint	IsWindowVisible(int code)	{	int	visible;	switch(code)		{		case SW_HIDE:				case SW_SHOWMINIMIZED:		case SW_MINIMIZE:				case SW_SHOWMINNOACTIVE:		case SW_SHOWNA:			case SW_RESTORE:		visible = 0; break;		case SW_NORMAL:					case SW_MAXIMIZE:		case SW_SHOWNOACTIVATE:			case SW_SHOW:		default:				visible = 1; break;		}    return(visible);	}long FAR PASCAL _export DocumentWndProc (HWND hwnd,  UINT msg, WPARAM wParam, LPARAM lParam )	{	HWND hwndClient;	CLIENTCREATESTRUCT ccs;	V_Document *doc;	V_Print		*vprint;	Point p;	int result;	char filePath[256];	int length;	int drgNDrpFCount;	result = 0; 	doc=(V_Document *)GetWindowLong(hwnd,0); 	   	switch (msg)   		{		case WM_CREATE:			doc = GetCurrentDocument();			SetWindowLong(hwnd,0,(long)doc);			ccs.hWindowMenu = NULL;//doc->winMenu->menu;		    ccs.idFirstChild = 0;//CHILDWINDOW_IDSTART;  //MJU unsure of this			doc->hwndMDIClient = CreateWindow (				"MDICLIENT", NULL, MDIS_ALLCHILDSTYLES|WS_CHILD|				WS_CLIPCHILDREN|WS_VSCROLL|WS_HSCROLL|WS_MAXIMIZE,				0, 0, 0, 0, hwnd, NULL,				GetAppInstance(), &ccs);			SetMainDocument(doc);			ShowWindow (doc->GetMDIClient(),SW_SHOW);			break;		case WM_DESTROY:			/* jca 19OCT94 for PRO.  Actually, this doesn't seem to work			properly. The help file should be destroyed using the same			parameters we used to create it over in Menus.cpp.			length = GetModuleFileName(GetAppInstance(), filePath, 256);			while((length>0)&&(filePath[length] != '\\'))				{				filePath[length] = 0x00;				length --;				}			strcat(filePath, HELP_FILE_NAME);			WinHelp(doc->GetMDIClient(),filePath,HELP_QUIT,NULL);  */			WinHelp(doc->GetFrame(),HELP_FILE_NAME,HELP_QUIT,NULL);			break;		    		case WM_ACTIVATE:			if(wParam!=WA_INACTIVE)				{				SetMainDocument(doc);				SetCurrentDocument(doc);				doc->MenuDisplay();				}			goto defProc;			break;		case WM_INITMENU:			doc->MenuPreempt();//	goto defProc;    //MJU Don't think it gets passed on			break;		case WM_DROPFILES:			drgNDrpFCount = DragQueryFile((HDROP)wParam, -1, NULL, 0);			if (drgNDrpFCount > 0)				{				char 	drgNDrpFName[256];				int 	i;				for (i = 0; i < drgNDrpFCount; i++)					{					V_File	*newFile;					if (NULL == DragQueryFile((HDROP)wParam, i, drgNDrpFName, 256))						continue;       // if the filename isn't long enough, skip it                	// do the file open					newFile = new(V_File);                	newFile->sWFile(drgNDrpFName);					NewDocument(newFile,LOADSTART);					}                }			DragFinish((HDROP)wParam);			break;		case WM_NCHITTEST:			if(lastPane)				{                p.h=p.v=-1;				lastPane->TrackCursor(p,NULL);				lastPane = NULL;				}			goto defProc;			break;		case WM_COMMAND:			if(!lParam)				if(doc->MenuDispatch(HIMENUID(wParam),LOMENUID(wParam),NULL))                	break;		    goto defProc;			break;		case WM_QUERYNEWPALETTE:			// About to become active, so redo palette			if (ReInitPalette(hwnd))				{	// if changes occurred, redraw this document				result = TRUE;	// tell Windows that sys palette changed				ReInitDither(); // jca 31MAR94  update the dither stuff; we're active				}			break;		case WM_PALETTECHANGED:			// The palette has finally been actually changed (by somebody else)			// So go and fix up the dithering, if any.			ReInitDither();            InvalidateRect(hwnd,NULL, FALSE); 	/// jca 31MAR94 force an update			break;		case WM_QUERYENDSESSION:			result = doc->Quit()?TRUE:FALSE;   // jca 23 Nov 93.  Return TRUE if we are going to quit, false if not.			break;		case WM_CLOSE:			doc->Quit();			break;#if VR   // ELVIS		case WM_SIZE:		case WM_MOVE:			{			Rect cliR, infoR, libR;			VInfoWindow	*info;            V_Window	*infoWin, *libWin;			HWND		infoHwnd, vrlibHwnd;			infoR = doc->GetInfoWinRect();			GetClientRect(doc->GetFrame(), &cliR);   // get the MDI client size			cliR.bottom -= (infoR.bottom - infoR.top);  // whack out the info win height			MoveWindow(doc->GetMDIClient(), cliR.left, cliR.top, cliR.right-cliR.left, cliR.bottom-cliR.top, TRUE);	#if VPLAYER			doc->MoveWalkWin();	#else			// do the lib resizing here			doc->MoveVRLib(FALSE);	#endif //VPLAYER			info = doc->GetInfoWin();			if (info)				{				infoWin = info->GetWindow();				infoHwnd = infoWin->GetParentWindow();				MoveWindow(infoHwnd, infoR.left, infoR.top, infoR.right-infoR.left, infoR.bottom-infoR.top, TRUE);				}			}			break;#endif#if (!VPLAYER)		case WM_WININICHANGE:			vprint = doc->GetVPrint();			if (vprint != NULL)				vprint->UpdatePrinterStatus();			break;#endif //!VPLAYER		case VIRTUS_MESSAGE:			doc->MessageDispatch(lParam,NULL);break;		default:		defProc:			hwndClient = (doc!=NULL) ? doc->GetMDIClient() : NULL;		    result =  DefFrameProc (hwnd,hwndClient,msg,wParam,lParam);			break;	    }	    	return result;	}HWND V_Document::GetMDIClient() { return hwndMDIClient; }HWND V_Document::GetFrame() { return hwndFrame; }#endif //WINDOWS/*------------------------------------------------------------------------------ * V_Document * This is the global data area for the V_Windows system. It handles the creation, * deletion, loading and saving of documents. It is, in a sense, the binding * of the V_Windows object system.  The proper way to think of the V_Windows * system is in fact as a system of intelligent documents.  Documents that  * know what to do with themselves, what resources they need and how to handle * these resources. *------------------------------------------------------------------------------ * void V_Document::OpenDocument(int flag) * int flag; this indicates how the document is to be opened. *  * OpenDocument is used to create the document using the derived function * cDocument and also keep track of all of the documents by appending them * to the theSuper V_Array.  It checks to see if this document has been opened * before and if it has it sends this information to the cDisplay method so * that the programmer can act accordingly.  In particular, if this method  * is being re-inited, then in all likelyhood the V_Menu theMenu still exists * and should not be reinitialized. * MS Windows note: * The MDI Document window is created here. If all is successful, this * window will be displayed. *------------------------------------------------------------------------------*/void V_Document::OpenDocument(int flag,V_File *file, int makeMDI)	{	V_Document * doc=this;	char str[256];	subDocs=NULL;	// DAS-VWINDOWS 9/2/93	superDoc=NULL;	// DAS-VWINDOWS 9/2/93#if VR	vwi = NULL;     // jca 10 Sept 93#endif	closing=FALSE;	if(!theMenu)/* DUDE - this is never inited. */		{		theMenu=new(V_MenuMgr);		theMenu->cMenuMgr();		}// { DAS-VR-VDOCUMENT 9/29/93 - don't increase the document number	if(docCount==-1)		SetTitle(TXT_UNTITLED);	else if(docCount==1)		{		SetTitle(TXT_UNTITLED);/*this also calls MenuDisplay()*/		docCount++;		}	else 		{		sprintf(str,"%s %d",TXT_UNTITLED,docCount);		SetTitle(str);		docCount++;		}// } DAS-VR-VDOCUMENT 9/29/93 - don't increase the document number		untitled=TRUE;		/*make sure that it is still untitled */	if(!windows)		{		windows=new(V_Array);		windows->cArray(0,sizeof(V_Window *),16);		/* added MJU 12/11/89 */		}		/*  These are the changes.  OpenDocument now comes all the way up before		calling the application constructor cDocument().  OpenDocument now		installs this document into the super first, creates vprint and all		that stuff.  Then he calls the cDocument().  If cDocument() returns		FALSE, then I CloseDocument(). The problem is that CloseDocument shuts		down Windows first and then the Document.  This is something WalkThrough		expects.  Previously, if I returned FALSE from cDocument() then I would		close down the Document first, then the Windows.  Anyway, this is also		simpler although a little slower in the case of cDocument() returning		FALSE.	*/#if (!VPLAYER)	if(!vprint)		{		vprint = new(V_Print); /* added GBA 8/13/90 */		vprint->cPrint(); /* added GBA 8/13/90 */		}#endif //!VPLAYER	// 	theSuper->Append(&doc);      // jca 31 Oct 93.  Moved down a line	if (makeMDI == NewMDI)    // jca 10 Oct 93		SetupDocumentInternals(flag);       	// jca 20 sept 93 do the violent windows things offstage, as it were.	theSuper->Append(&doc);      // jca 31 Oct 93 keep the stub active until we transfer control#if VR	if (!vwi)		InitInfoWindow();#endif // VR	if(!cDocument(flag,file))		{		CloseDocument();		// this should call a		// delete(this);		// which could be very deadly.  This should be thoroughly tested		// later.  ELVIS  21APR94 jca		VSendMessage(CLEAN_MENUS);		}	}/* setup the mdi, the menus, and all those windows-specific maindocument things. jca 10 sept 93 */voidV_Document::SetupDocumentInternals(int flag){#if WINDOWS	// if there is a stub && it is the active document && the stub	// has something to transfer, then transfer.  Otherwise, create	// a new one. jca 31 Oct 93	if ((stub && (stub == ActiveDocument())) && (stub->GetFrame()))  	// jca 31 Oct 93		{        stub->TransferDocumentControl(this);		}	else		{		Rect	sR;// BILBIL this code positions the mdi to look more like the mac. 9/14/94 [[[#if VPLAYER		int		middle, offset;		GetScreen(&sR);		middle = (sR.right - sR.left) >> 1;		offset =  (sR.right - sR.left) / 2.5; 		sR.left = middle - offset; 		sR.right = offset + middle;		middle = (sR.bottom - sR.top) >> 1;		offset =  (sR.bottom - sR.top) / 2.5;		sR.top =  middle - offset; 		sR.bottom = offset + middle;			// BILBIL this code positions the mdi to look more like the mac. 9/14/94 ]]]#else		// MDI window position hack so the MDI always comes up big. - BILBIL - 12/16/93        // jca 21MAR94 made it work for walkthrough, too		GetScreen(&sR);		if ((sR.right-sR.left) < 800)			{			sR.right -= 3;			sR.left += 3;			sR.top += 3;            sR.bottom -= 3;			}		else if ((sR.right-sR.left) == 800)			{			sR.right -= 20;			sR.left += 20;			sR.top += 20;			sR.bottom -= 20;			}		else			{			int w = sR.right-sR.left, h = sR.bottom - sR.top;			sR.right = (w - 800)/2 + 800;			sR.left = (w - 800)/2;			sR.top = 20;			sR.bottom = 620;			}#endif //VPLAYER		if (docCount >= 0) // jca 21MAR94 if this isn't VR, stagger the docs.			{			int factor = docCount - 2; // fudge factor.  We only start doing this for the second doc			if (factor > 0)	factor %= WIN_MULTIPLE_DOC_STACKING_MAX;            else			factor = 0;			sR.top += factor * GetSystemMetrics(SM_CYCAPTION);			}		MakeWinMenu();		/* VWindows running under MS Windows uses an MDI Client window for	 	* holding the grouped document windows. Create the client frame here. */		hwndMDIClient = NULL;		SetCurrentDocument(this);		hwndFrame = CreateWindow (			documentClassName, title,			WS_OVERLAPPEDWINDOW|WS_CLIPCHILDREN,			sR.left, sR.top, sR.right - sR.left, sR.bottom - sR.top,			NULL, NULL, GetAppInstance(), NULL);	//	DragAcceptFiles(hwndFrame, TRUE);		SetMainDocument(this);		if(-1!=flag)			{			if (IsWindowVisible(GetCommandShow())) // don't conceal if minimized jca 4APR94				ConcealFrame();			ShowWindow(hwndFrame,GetCommandShow());			UpdateWindow(hwndFrame);			}		// Install a dummy menu to reserve space in the frame window until the real		// menus are installed. This is needed to keep the contained windows from		// jumping down as the menus are installed and to allow the initial window		// positions to take the menu bar into account.		HMENU menu, oldMenu;		menu = CreateMenu();		AppendMenu(menu, MF_STRING|MF_ENABLED, 0, "");		oldMenu = SendMessage(hwndMDIClient,WM_MDISETMENU,0,MAKELPARAM(menu,0));		DrawMenuBar(hwndFrame);		if (oldMenu) DestroyMenu(oldMenu);    }#endif //WINDOWS}/* only do this if it is a real doc, not a library or something.jca 11 sept 93 */voidV_Document::InitInfoWindow(){#if VR	Rect	screenRect;#if MACINTOSH	GetScreen(&screenRect);	vwi = VWIInit(&screenRect);#elif WINDOWS	screenRect = GetFrameRect();	if (hwndFrame)   // only create if there's a place to put it.    	{		vwi = VWIInit(&screenRect);		}#endif // MACINTOSH#endif // VR}#if VRvoidV_Document::MoveVRLib(int swap) { }   // Gallery window positioning hack - BILBIL#endif#if VPLAYERvoidV_Document::MoveWalkWin(void) { } // Walk window positioning for "maximized" look - BILBIL#endif //VPLAYERvoid V_Document::CloseDocument(void)	{#if WINDOWS	HMENU frameMenu;#endif //WINDOWS	V_Document * doc;	V_Window *aWindow;	int i,ln,err;	doc=this;	closing=TRUE;	React(0,CLOSE);#if MACINTOSH	/* Since the menu bar is part of the document window, there is no need	 * to call these here under MSWindows.	 */	ClearMenuBar();	DrawMenuBar();#endif //MACINTOSH	while(windows->ALength())		{		windows->Get(0,&aWindow);			aWindow->dWindow(); 				}	windows->dArray();	// jca 20APR94 now that we have destroyed the document's windows,	// (but before we remove the doc from the super) we must decide	// whether this doc's MDI is to be passed on to another document.	// TransferControl() is a virtual function that determines if the	// MDI should be passed to another doc (like the stub).  On the	// Mac side, the code does nothing.	TransferControl();  		theSuper->Remove(theSuper->Find(&doc));	theMenu->dMenuMgr();	theMenu = NULL; //DUDE PORT#if MACINTOSH	/*there isn't even a place to draw the menu bar now under MSWIN*/	ClearMenuBar();#endif //MACINTOSH	VSendMessage(CLEAN_MENUS);#if (!VPLAYER)	vprint->dPrint();#endif //!VPLAYER// { DAS-VWINDOWS-FLATTEN 9/2/93// DAS-VWINDOWS-FIX 9/7/93	if(superDoc) // first, remove this reference from the superDoc		UninstallSuperDoc();	if(subDocs)		{		while(subDocs->ALength())			{			V_Document *sDoc;			subDocs->Get(0,&sDoc);			subDocs->Remove(0);			sDoc->superDoc=0;			}		subDocs->dArray();		}// } DAS-VWINDOWS-FLATTEN 9/2/93	dDocument();	// ABD HMD MAR95 removed HMD stuff here#if VR	if (vwi)	VWIEnd(vwi);       // jca 11 Oct 93#endif // VR#if WINDOWS	if(theWindowMenu)		{		theWindowMenu->dMenu();		theWindowMenu = NULL;		}	if (hwndFrame)		{		frameMenu = GetMenu(hwndFrame);		if(NULL != frameMenu)    		{			ln = GetMenuItemCount(frameMenu);			for(i=0;i<ln;i++)				err=RemoveMenu(frameMenu,0,MF_BYPOSITION);			}		DestroyMenu(frameMenu);		hwndMDIClient=NULL; // DAS-BUGFIX 10/23/93 this will get killed in the next line anyway.		DestroyWindow(hwndFrame);    	}#endif //WINDOWS	}void V_Document::Install(V_Window * theWindow)	{	windows->Append(&theWindow);	theWindow->SetDocument(this);	}	void V_Document::UnInstall(V_Window *theWindow)	{	Rect r;	long position;			position=windows->Find(&theWindow);	if(position>=0)		{		windows->Remove(position);		theWindow->SetDocument(NULL);		}	}void V_Document::Activate(V_Window * theWindow)	{	V_Window *whichV;		whichV=NULL;		if(!theWindow)		{		if(!(whichV=TopWindow(RealDoc())))return;#if WINDOWS		else BringWindowToTop(hwndFrame);#endif //WINDOWS		}	else 		{		if(theWindow->theDocument->RealDoc()!=RealDoc())			{			theWindow->theDocument->RealDoc()->Activate(theWindow);			return;			}		/*this is the window selected by the user*///		MakeWinMenu();		whichV=theWindow;		}	whichV->Select(); 	}int V_Document::cDocument(int flag,V_File *file) { return(TRUE); }void V_Document::dDocument()	{	}int V_Document::Save(int query){return FALSE;}int V_Document::Load(int query){return FALSE;}int V_Document::Changed(void) { return FALSE; }void V_Document::LoadNew(int query) { NewDocument(0L,query); }void V_Document::New() { NewDocument(0L,NEW); }/* *  Did we close the document successfully?  Return TRUE or FALSE. * jca 18FEB94 */int V_Document::CloseQuery()	{    int result;	switch(QSave())		{		case QCANCEL: result = FALSE; break;		case QYES:			if(Untitled())                {                  // JAM 15 Nov 93.  Whoops! {				result = (0!=Save(SAVEAS)) ? FALSE : TRUE;				if(!result)break;				}			else				{				result = (0!=Save(SAVE)) ? FALSE : TRUE;				if(!result)break;				}                  // JAM 15 Nov 93 else was with wrong if }		case QNO:			result = TRUE;			break;		}	return(result);	}voidV_Document::Close()	{	// if CloseQuery() is TRUE, then the user is ready to close this model.	// if it is FALSE, then they cancelled.	if (CloseQuery() == TRUE)		{    		CloseDocument();		delete(this);        }	}void V_Document::Revert()	{	switch(QSave())		{		case QCANCEL:break;		case QYES:			if(0==Save(SAVECOPYAS))break;		case QNO:			Load(LOAD);			break;		}	}/* * jca 23 Nov 93  I think V_Doc::Quit() is returning TRUE if we're * able to quit (we save ok or don't save) or FALSE if we're not * going to quit.  This gets interpreted later. */int V_Document::Quit()	{	V_Document *doc;	int result,len, i;	#if MACINTOSH // jca.  At some point, this should be made to use CloseQuery().	switch(QSave())		{		case QCANCEL: result = FALSE; break;		case QYES:			result = (0!=Save(SAVE)) ? FALSE : TRUE;			if(!result) break;		case QNO:			CloseDocument();			len = theSuper->ALength();			delete(this);			if(len)				{				theSuper->Get(0,&doc);				return doc->Quit();				}			else mainNotDone = FALSE;			result = TRUE;			break;		}#elif WINDOWS // jca	result = CloseQuery();	if (result != FALSE)  // keep on shutting things down		{		int whichCancelled=-1;		int locationFactor=0;        int destroyDoc = TRUE, destroyStub = TRUE;		/* jca 18FEB94 		This is a very peculiar problem.  We can get into Quit() two ways:			a) File->Exit			b) Windows shutdown		We can handle a) quite easily; b), on the other hand, has caused us to		hang after the first doc shuts down.  My theory is that Windows(tm)		is not happy about us changing the active document during the shutdown.		Thus, we will do the shutdown in several steps:			1)	ask about the current document.  If the user doesn't cancel, then				ask about all the other documents that have their own MDIs.  If				there is a cancel, we keep track of where it happened and break.			2)	shutdown the affected documents.  If there was no cancel, kill				everything.  If there was a cancel, kill everything up to that point.			3)	if there was no cancel, kill any non-MDI documents (VR Galleries).		We *MUST* recalc the length of theSuper each pass; it changes		whenever we remove a document! (the "i < theSuper->ALength()"		call)		Step 1, part b:  we've already asked about this document; now ask about all the        others.		*/		for (i = 0; (result!= FALSE) && (i < theSuper->ALength()); i++)			{			theSuper->Get(i, &doc);			if (doc == this)				{				locationFactor = 1;				}			else            	{				if (doc->GetMDIClient())					{                    // this document has an MDI.  Do we kill it?					if (!doc->CloseQuery())						{						// the user cancelled the quit for this doc.  Preserve this doc, and get out.						whichCancelled = i;  // this is where we stopped.						result = FALSE;						}					}				}			}        /* step 2:  shut down the affected documents, starting with the current one. */		if (stub && (stub != this)) // if this is the stub, then it will get killed later.			CloseDocument();  		// close the current doc		if (result != FALSE)			whichCancelled = theSuper->ALength();		else        	{			whichCancelled -= locationFactor;            destroyStub = FALSE;	// do not destroy the stub            }		for (i = 0; i < whichCancelled; /* no increment */)			{			theSuper->Get(i, &doc);			if (doc == this)				i++;			else            	{				if (doc->GetMDIClient())					{                    // this document has an MDI.  Kill it.					doc->CloseDocument();					delete(doc);					doc = NULL;					whichCancelled--; 					}				else                	i++;                }			}		// step 3:  if there were no cancels when saving the mdi documents,        // then trash the stub, this doc, and any non-mdi docs (VR galleries)	  	if (result != FALSE)			{			// remove the non-mdi docs (VR galleries)			// we _*MUST*_ recalc the length of theSuper each pass;			// it changes whenever we remove a document!			for (i = 0; i < theSuper->ALength();  )				{				theSuper->Get(i, &doc);				if (doc == this)					i++;				else                	{					if (!doc->GetMDIClient())    // does this doc have an mdi?  if not, then kill it manually.						{						// remove the doc from theSuper.  This shuffles everything after this in the super down one slot.						// since we check theSuper's length each loop, we won't go beyond the bounds of the array						// because we don't increment the iterator except for docs we don't delete						theSuper->Remove(i);     // remove this doc from the super						doc->CloseDocument();    // close the doc						delete(doc);						doc = NULL;              // NULL the doc.						}					else						{						i++;                        DEBUGGER();                        }					}				}				// do the final clean up.  Post the QUIT, set the death flag.				len = theSuper->ALength();				if(!len)  // otherwise, bye!					{					PostQuitMessage(0);					mainNotDone = FALSE;					}				else					DEBUGGER();      // this should NEVER happen			// step two:  trash the stub (if it is not the active doc)			if (stub && ((stub != ActiveDocument()) || stub != this))            	{				stub->CloseDocument();      // we must exit after this.  No second chance after we wipe out the stub.				delete(stub);				stub = NULL;                destroyStub = FALSE;	// the stub is already destroyed				}                   // at this point either the stub is dead, or this is the stub 			}		if ((stub && (stub == this)) && destroyStub)        	{			stub->CloseDocument();      // we must exit after this.  No second chance after we wipe out the stub.			delete(this);  // kill this thing.			stub = NULL;			destroyDoc = FALSE;	// the stub is the document            }        if (destroyDoc)			delete(this);  // kill this thing.		}#endif // MACINTOSH jca	return result;	}	void V_Document::LoadOver(int query)	{	switch(QSave())		{		case QCANCEL:break;		case QYES: if(0!=Save(SAVEAS))break;		case QNO: Load(query); break;		}	}void V_Document::LoadAppend(int query) { Load(query); }int V_Document::QSave()	{	StdCloseDialog *theDialog;	int itemhit;		itemhit = (!Changed()) ? QNO : -1;	if(itemhit!=QNO)		{		theDialog=new(StdCloseDialog);		itemhit = theDialog->cStdCloseDialog(title);		}	return(itemhit);	}	void V_Document::SetTitle(strPtr str)	{#if WINDOWS	HWND hwnd=GetFrame();	char winTitle[256];	if(hwnd)		{        winTitle[0]=0;		if(strlen(titlePrefix)>0)			{			strcat(winTitle,titlePrefix);			strcat(winTitle," - ");			}		strcat(winTitle,str);		SetWindowText(hwnd,winTitle);		}#endif //WINDOWS	strcpy(title,str);	if(theMenu->Visible())		MenuDisplay();	untitled=FALSE;	}void V_Document::GetTitle(strPtr str) { strcpy(str,title); }void V_Document::SetTitlePrefix(strPtr str) { strcpy(titlePrefix,str); }void V_Document::GetTitlePrefix(strPtr str) { strcpy(str,titlePrefix); }voidV_Document::Cleanup()	{	V_Window *theWindow;	int i,wnum;		wnum=windows->ALength();	for(i=0;i<wnum;i++)		{		windows->Get(i,&theWindow);		if(theWindow->Visible())theWindow->Cleanup();		}	}void V_Document::React(V_Window *w,int type) { }int V_Document::ActiveWindows(void)	{	V_Window **pWindow;	int i,numVis,length;		numVis=0;	length = windows->ALength();	pWindow = (V_Window **)windows->Use();	for(i=0;i<length;i++,pWindow++)		if((*pWindow)->Visible() && IN_MENU((*pWindow)->wType))			numVis++;	windows->Unuse();	return numVis;	}voidV_Document::MessageDispatch(long message,long modifier)	{	V_Window **pWindow;	V_Window  *topWin;	// jca	int i,length;	if(superDoc)superDoc->MessageDispatch(message,modifier);	else	switch(message)		{#if WINDOWS		case DieWindowEvent:			PostQuitMessage(DieWindowEvent);			break;#endif //WINDOWS		case CLEAN_MENUS: CleanMenus(); break;#if (!VPLAYER)		case PRINT_SETUP:			#if !SAVE_DISABLED 	// ABD-SAVE-DISABLED			PageSetup(); 			#endif // SAVE_DISABLED 	// ABD-SAVE-DISABLED#endif //!VPLAYER		default:			/* jca.  Test the top window first */			topWin = TopWindow(this);	// jca			if (topWin) 	// jca 31 Oct 93 always check that there is a topWindow				if (topWin->DoEvent(message, modifier))	break;			/* jca.  Ok, now do the other windows */			length = windows->ALength();    		pWindow = (V_Window**)windows->Use();			for(i=0;i<length;i++,pWindow++)				if (*pWindow != topWin)  // jca.  Don't do it again!				if((*pWindow)->DoEvent(message,modifier))break;			windows->Unuse();			break;        }	}void V_Document::MenuDisplay()	{	V_Window *win;	V_Pane **thePane;	V_Menu *vMenu;	V_MenuMgr *gMenu;	VMenuHandle	hMenu,menu;	string str[256];	int i,j,length,numPanes,keyPos,euroKey;	int err;	if(superDoc) { superDoc->MenuDisplay(); return; }#if MACINTOSH	hiMenu=255;	loMenu=1;		ClearMenuBar();#elif WINDOWS	hiMenu=1;	loMenu=1;		menu = GetMenu(hwndFrame);	if(NULL != menu)		{		length = GetMenuItemCount(menu);		for(i=0;i<length;i++)			err=RemoveMenu(menu,0,MF_BYPOSITION);		}#endif //WINDOWS		length = visibleMMgr->ALength();	for(i=0;i<length;i++)		{		visibleMMgr->Get(i,&vMenu);		vMenu->UnmakeMenu();		}	visibleMMgr->SetLength(0);/* jca 16FEB94 REMOVE!!!!#if WINDOWS && VWT// Mark apparently thought this was an odd idea; I'm inclined to agree jca 11/20/93// This is probably not even desirable in WalkThrough, but . . .// Something to look out for when loading files (note that it conflicts w/ the stub)// jca 15FEB94 -- removed.  It conflicts with the stub, setting the stub to be current at the wrong times//	SetCurrentDocument(this);		//DUDE PORT#endif //WINDOWS*/	MakeWinMenu();	if(NULL != theMenu) //DUDE PORT    	{		length = theMenu->ALength();		for(i=0;i<length;i++)			{			theMenu->Get(i,&vMenu);			visibleMMgr->Append(&vMenu);			}        }	win = TopWindow(NULL);	/*install the frontmost windows menu*/	if(win)		{		gMenu=win->GetMenuMgr();		length = gMenu->ALength();		for(j=0;j<length;j++)			{			gMenu->Get(j,&vMenu);			visibleMMgr->Append(&vMenu);			}		/* install each of the windows' panes' menus */		if(win->panes)			{			thePane=(V_Pane **)win->panes->Use();			numPanes = win->panes->ALength();			for(i=0;i<numPanes;i++,thePane++)				{				gMenu=(*thePane)->GetMenuMgr();				length = gMenu->ALength();				for(j=0;j<length;j++)					{					gMenu->Get(j,&vMenu);					visibleMMgr->Append(&vMenu);					}				}			win->panes->Unuse();			}		}#if MACINTOSH	visibleMMgr->QuickSort();#elif WINDOWS	visibleMMgr->QuickSort();	visibleMMgr->SetMenuDocument(this);	menu = CreateMenu();#endif //WINDOWS			length = visibleMMgr->ALength();	for(i=0;i<length;i++)		{		visibleMMgr->Get(i,&vMenu);#if MACINTOSH		vMenu->MakeMenu(0);#elif WINDOWS		hMenu = vMenu->MakeMenu(0);#if JAPANESE		if(vMenu->GetMnemonics()&&(euroKey=vMenu->GetMenuEuroKey())!=0)			{			strcpy(str,vMenu->menuName);			sprintf(str+strlen(str),"(&%c)",euroKey);			}		else if(vMenu->GetMnemonics()&&(keyPos=vMenu->GetMenuKeyPos())>=0)#else		if(vMenu->GetMnemonics()&&(keyPos=vMenu->GetMenuKeyPos())>=0)#endif //JAPANESE			{			strncpy(str,vMenu->menuName,keyPos);			str[keyPos]=0;	        strcat(str,"&");			strcat(str,&vMenu->menuName[keyPos]);			}		else strcpy(str,vMenu->menuName);		AppendMenu(menu,MF_ENABLED|MF_POPUP|MF_STRING,hMenu,str);#endif //WINDOWS		}			/* if by this point no one has used the window menu,	 * we will use it now*/	if((!theWindowMenu->onOff) && (theWindowMenu->ALength()>2))		{        int position;		theWindowMenu->Remove(1);		theWindowMenu->state=FALSE;		visibleMMgr->Append(&theWindowMenu);#if MACINTOSH		theWindowMenu->MakeMenu(0);#elif WINDOWS		// jca 22MAR94 let's actually put the menuitem in the menu bar!		hMenu = theWindowMenu->MakeMenu(0);#if JAPANESE		if(vMenu->GetMnemonics()&&(euroKey=theWindowMenu->GetMenuEuroKey())!=0)			{			strcpy(str,theWindowMenu->menuName);			sprintf(str+strlen(str),"(&%c)",euroKey);			}		else if(vMenu->GetMnemonics()&&(keyPos=theWindowMenu->GetMenuKeyPos())>=0)#else		if(vMenu->GetMnemonics()&&(keyPos=theWindowMenu->GetMenuKeyPos())>=0)#endif //JAPANESE			{			strncpy(str,theWindowMenu->menuName,keyPos);			str[keyPos]=0;	        strcat(str,"&");			strcat(str,&theWindowMenu->menuName[keyPos]);			}		else strcpy(str,theWindowMenu->menuName);		// jca 22MAR94 yes, this sucks.  I'm getting the length of the		// menu bar so I can inset the Window menu (which we know is		// the next-to-last item on the menu bar (under Windows), the		// last item being the Help item.  We really should figure all		// this crud out before we build the menu bar, do the QuickSort,		// and be home free.  But MakeMenu() is the routine that identifies		// which sub-menus are used (like theWindowMenu) and sets the		// onoff flag.  So we can't know until we've built the menubar		// which menus are to be used.  Bleah.  So we graft the Window		// menu back on here, like on the mac (which doesn't have this problem,		// since the Window menu item is the last thing on the mac window bar).		position = GetMenuItemCount(menu);		InsertMenu(menu,position - 1,MF_BYPOSITION|MF_ENABLED|MF_POPUP|MF_STRING,hMenu,str);#endif //WINDOWS		}#if MACINTOSH	DrawMenuBar();#elif WINDOWS	if ((theWindowMenu->linkFrom==NULL) &&		((!theWindowMenu->onOff) && (theWindowMenu->ALength()>2))) /* jca don't do the append twice */		visibleMMgr->Append(&theWindowMenu);	hMenu = SendMessage(hwndMDIClient,WM_MDISETMENU,0,MAKELPARAM(menu,0));	if(hMenu)DestroyMenu(hMenu);	DrawMenuBar(hwndFrame);#endif //WINDOWS	}	void V_Document::MakeWinMenu(void)	{	V_Document *doc;	V_Window *win,*twin;	char str[256];	int i,len,loc,length;		if(superDoc){ superDoc->MakeWinMenu(); return;}	doc=this;	/*create the window menu, if useful*/	if(theWindowMenu)theWindowMenu->dMenu();	theWindowMenu=new(V_WindowMenu);	theWindowMenu->ctheMenu(this);		len=0;#if VWT	length = windows->ALength();	for(i=0;i<length;i++)		{		windows->Get(i,&win);		if(IN_MENU(win->wType))len++;		}	theWindowMenu->AppendSeparator();		// ABD MERGE11 WILLIAMS 9/10/93 - this will be removed if it isn't used	theWindowMenu->state=TRUE;		if(len>1)		{		twin = TopWindow(doc);			for(i=0;i<windows->ALength();i++)			{			windows->Get(i,&win);			if(IN_MENU(win->wType))				{				win->GetTitle(str);				theWindowMenu->Append(str);				if(theWindowMenu->ALength()<10)					theWindowMenu->SetKey(theWindowMenu->ALength(),'0'+theWindowMenu->ALength()-1);				if(win==twin)theWindowMenu->Select(theWindowMenu->ALength(),TRUE);#if WINDOWS				theWindowMenu->SetKeyPos(theWindowMenu->ALength(),-1);#endif //WINDOWS				}			}		}	if((1<(loc=theWindowMenu->ALength())) && theSuper->ALength()>1)		{		theWindowMenu->AppendSeparator();			// ABD MERGE11 WILLIAMS 9/10/93		loc+=2;		}	else loc=2;	if(theSuper->ALength()>1)		{		for(i=0;i<theSuper->ALength();i++)			{			theSuper->Get(i,&doc);#if WINDOWS			if(i+1<10)				{				str[0]='1'+i;				str[1]=' ';				doc->GetTitle(str+2);				}			else doc->GetTitle(str);#elif MACINTOSH			doc->GetTitle(str);#endif //WINDOWS			theWindowMenu->Append(str);			if(doc==this)theWindowMenu->Select(loc+i,TRUE);#if WINDOWS			if(i+1>=10)theWindowMenu->SetKeyPos(loc+i,-1);#endif //WINDOWS			}		}#endif //VWT	if(1==theWindowMenu->ALength() && 1==theSuper->ALength())		theWindowMenu->Remove(1);/*there is no  window menu*/	}void V_Document::MenuPreempt(void)	{	V_Menu	*vMenu;	int i,length;		if(superDoc){superDoc->MenuPreempt(); return;}	length = visibleMMgr->ALength();	for(i=0;i<length;i++)		{		visibleMMgr->Get(i,&vMenu);		while(vMenu && vMenu!=DA_MENU && vMenu!=WINDOW_MENU)			{			vMenu->VPreempt();			vMenu=vMenu->linkTo;			}		}	}int V_Document::MenuDispatch(int mNum,int iNum,long modifiers)	{	V_Menu *vMenu,*hm;	V_MenuItem *menuItem;	int i,j,length,result;		if(superDoc) return superDoc->MenuDispatch(mNum,iNum,modifiers); 	if(mNum==0||iNum==0)return FALSE;	result = FALSE;		length = visibleMMgr->ALength();	for(i=0;i<length;i++)		{		visibleMMgr->Get(i,&vMenu);		if(vMenu->mNum==mNum)			result = DoMenuAction(vMenu,iNum,modifiers);	    else 	    	{  			for(j=0;j<vMenu->ALength();j++)				{								vMenu->Get(j,&menuItem);				hm = menuItem->GetHeir();				if(hm && hm->mNum==mNum)					{					result = DoMenuAction(hm,iNum,modifiers);					if(!result)vMenu=hm;					}				}			}		if(result) break;		}	return result;	}	int V_Document::DoMenuAction(V_Menu *vMenu,int iNum,long modifiers)	{	int result,vLength,baseNum;		if(superDoc) return DoMenuAction(vMenu,iNum,modifiers);#if MACINTOSH	HiliteMenu(0);#endif //MACINTOSH	result = FALSE;	baseNum=iNum;	while(vMenu && !result && iNum>(vLength=vMenu->ALength()))		{		iNum-=vLength;		result = (vMenu->linkTo==DA_MENU) ? TRUE :FALSE;		if(result) vMenu->DoDA(baseNum);		else			{			result = (vMenu->linkTo==WINDOW_MENU) ? TRUE : FALSE;			if(result)theWindowMenu->Action(iNum,modifiers);			else vMenu=vMenu->linkTo;			}			}	if(!result)		{		result = (vMenu) ? TRUE : FALSE;		if(result)vMenu->Action(iNum,modifiers);		}			return result;	}	#if VRRectV_Document::GetInfoWinRect()	{	Rect	r;	if (VWIflag)    	{#if MACINTOSH		GetScreen(&r);		r.top = r.bottom - VWI_DEF_HEIGHT; #elif WINDOWS  		// jca 3 Oct 93 {/* this is the way we should do it, but the currentDevice is NULL during start up.		ULong textMet;		int	textHeight;		HDC theDevice;      */		r = GetFrameRect();/* continue the above comment...		theDevice = GetDC();		if (GetGraphicContext())        	{			TextSetUp(vAppFont,vAppFontSize,vNormal);			textMet = GetTextExtent(GetGraphicContext(), "Agl", strlen("Agl"));			textHeight = HIWORD(textMet);			r.top = r.bottom - (2*GetSystemMetrics(SM_CYFRAME) + textHeight);  // CYFRAME, not CYBORDER.  We want the size for a real window frame, since the button has a thick frame			TextSetUp(vSystemFont,vSystemFontSize,vNormal);			}		else  */		// JAM 16 Nov 93.  The height should be less than the height of the mdi.  jca		r.top = max(r.top, r.bottom - VWI_DEF_HEIGHT);#endif           	// jca 3 Oct 93 }		}	else		{		r.top = r.bottom = r.left = r.right = 0;		}	return(r);	}VInfoWindow*V_Document::GetInfoWin()	{    return(vwi);	}V_Window*V_Document::GetVRLib()	{	return NULL;	}V_Window*V_Document::GetVRWalk()	{	return NULL;	}V_Window*V_Document::GetVRDesign()	{	return NULL;	}	RectV_Document::GetVRLibRect()	{	Rect	r, r2;	if (VRLibFlag) // && (GetVRLib() != NULL) && (GetVRLib()->Visible()))    	{#if MACINTOSH		GetScreen(&r);#elif WINDOWS		r = GetFrameRect();#endif // MACINTOSH		// if we have an info window, then it will take up		// the bottom of the screen.  Account for it.		if (VWIflag)        	{            r2 = GetInfoWinRect();			r.bottom -= (r2.bottom-r2.top);      // jca 3 Oct 93			}		// JAM 23 Nov 93.  this has a static width, so it should not be larger than		// the width of the mdi.  jca		r.right = min(r.right, r.left + VRLIB_DEFWIDTH);#if WINDOWS  		// jca 3 Oct 93		// whack off the frame size		r.left += GetSystemMetrics(SM_CXBORDER);		r.top += GetSystemMetrics(SM_CYBORDER);		r.right -= GetSystemMetrics(SM_CXBORDER);		r.bottom -= GetSystemMetrics(SM_CYBORDER);#endif            // jca 3 Oct 93 }        }	else		{		r.top = r.bottom = r.left = r.right = 0;		}	return(r);	}#endif // VR// jca 20APR94 routine to tell the CloseDocument() routine whether// it should move control of the mdi to the stub.  Really only// important under Windows(tm), since the mac handles the stub// differently.voidV_Document::TransferControl(void) 	{ /* do nothing */ }voidV_Document::TransferDocumentControl(V_Document *to){#if MACINTOSH	/* do nothing, since the mac handles the stub for us?  anyway,	we don't have to mess with the stub here.  jca 20APR94 */#elif WINDOWS	char name[256];	if (!to)	return;	to->hwndMDIClient = hwndMDIClient;	to->hwndFrame = hwndFrame;	to->hwndActive = NULL;	to->frameRect = frameRect;	to->frameConcealed = frameConcealed;	if (to->theWindowMenu)   // jca 12APR94 clean up		{		(to->theWindowMenu)->dMenu();		to->theWindowMenu = NULL;		}	to->theWindowMenu = theWindowMenu;	SetWindowLong(to->hwndFrame, 0, (LONG)to);#if VR  // jca 28JAN94 vwi only in vr, for now	to->vwi = vwi;	if (to->vwi)		((to->vwi)->GetWindow())->SetDocument(to);	vwi = NULL;#endif // VR	hwndMDIClient = NULL;	hwndFrame = NULL;	theWindowMenu = NULL;	SetCurrentDocument(to);	SetMainDocument(to);	to->GetTitle(name);    to->SetTitle(name);#endif // MACINTOSH}V_MenuMgr *V_Document::GetMenuMgr(void) 	{ 	if(superDoc) 		return superDoc->theMenu; 		else return theMenu; 	}#if (!VPLAYER)void V_Document::PageSetup() 	{	if(superDoc)		superDoc->vprint->PageSetup();	else vprint->PageSetup(); 	}V_Print *V_Document::GetVPrint() 	{ 	if(superDoc) 		return superDoc->vprint; 	else return vprint; 	}#endif //!VPLAYERint V_Document::Untitled() { return untitled; }//	This is funkiness. We're trying to keep the document window hidden//	until it has something to show. It's confusing and ugly for it to show//	before the application puts up the Open File Dialog. We can't simply//	hide it with HideWindow() though because the window activation message is//	used to keep track of the active document. If the document window is hidden,//	then any V_Windows created will go in the wrong document window.//	//	So, here's what we do. As soon as the document window is created, but before//	it's shown, call ConcealFrame() to move it off screen (but leave it active).//	GetFrameRect() and SetFrameRect() will pretend it's still on screen. When the//	first V_Window is created for this document, call RevealFrame() in V_Window::cWindow()//	to move the document window back on screen.#if WINDOWSvoidV_Document::ConcealFrame()	{	HWND frame = GetFrame();	Rect r;	if (frame && !frameConcealed)		{		GetWindowRect(frame, &r);		frameRect = r;		MoveWindow(frame, 16384, 16384, 100, 100, TRUE);        frameConcealed = TRUE;        }	}voidV_Document::RevealFrame()	{	HWND frame = GetFrame();	if (frame && frameConcealed)		{		int width = frameRect.right - frameRect.left;		int height = frameRect.bottom - frameRect.top;		MoveWindow(frame, frameRect.left, frameRect.top,			width, height, TRUE);		frameConcealed = FALSE;		}	}RectV_Document::GetFrameRect()	{    HWND frame = GetFrame();    Rect r = { 0, 0, 0, 0 };	if (frame)		{		if (!frameConcealed)			GetWindowRect(frame, &r);		else        	r = frameRect;		r.left += GetSystemMetrics(SM_CXFRAME);		r.right -= GetSystemMetrics(SM_CXFRAME);		r.top += GetSystemMetrics(SM_CYFRAME)+			GetSystemMetrics(SM_CYCAPTION)+GetSystemMetrics(SM_CYMENU);		r.bottom -= GetSystemMetrics(SM_CYFRAME);		}    return r;	}voidV_Document::SetFrameRect(Rect r)	{	HWND frame = GetFrame();	if (frame)    	{		r.left -= GetSystemMetrics(SM_CXFRAME);		r.right += GetSystemMetrics(SM_CXFRAME);		r.top -= GetSystemMetrics(SM_CYFRAME)+			GetSystemMetrics(SM_CYCAPTION)+GetSystemMetrics(SM_CYMENU);	    r.bottom += GetSystemMetrics(SM_CYFRAME);        if (!frameConcealed)			MoveWindow(frame,r.left,r.top,				r.right-r.left,r.bottom-r.top,TRUE);		else        	frameRect = r;		}	}#elif MACINTOSHRect V_Document::GetFrameRect() { Rect z = { 0, 0, 0, 0 }; return z; }void V_Document::SetFrameRect(Rect r) { }#endif //WINDOWS// { DAS-VWINDOWS-FLATTEN 9/2/93 this is to allow sub-documents/* This allows this document to be treated as if it is actually part of another * "Super" document. This means that it will use the other documents menus, and  * the windows will be treated in exactly the same way. */void V_Document::InstallSuperDoc(struct V_Document *doc)	{	V_Document *thisDoc;		superDoc=doc;	if(!superDoc->subDocs)		{		superDoc->subDocs=new(V_Array);		superDoc->subDocs->cArray(0,sizeof(struct V_Document *), 1);		}	thisDoc=this;	superDoc->subDocs->Append(&thisDoc);	superDoc->Activate(NULL);	}	// DAS-VWINDOWS-FIX 9/7/93void V_Document::UninstallSuperDoc(void)	{	long loc;	V_Document *doc;	doc=this;	if(superDoc)		{		loc=superDoc->subDocs->Find(&doc);		if(loc>=0)			superDoc->subDocs->Remove(loc);		superDoc=NULL;		}	}V_Document *V_Document::RealDoc(void)	{	if(superDoc) return superDoc;	else return this;	}// } DAS-VWINDOWS-FLATTEN 9/2/93 this is to allow sub-documentsstruct StubMenuAbout:V_Menu	{	void ctheMenu(V_Document *);	void Action(int, long);	};struct StubMenuFile:V_Menu	{	void ctheMenu(V_Document *);	void Action(int, long);	};	struct StubMenuEdit:V_Menu	{	void ctheMenu(V_Document *);	};	void MakeStub(void)	{#if MACINTOSH	V_Document *stb;	V_MenuMgr	*gmenu;	StubMenuAbout *aboutMenu;	StubMenuFile *fileMenu;	StubMenuEdit *editMenu;	stb=new(V_Document);	stb->OpenDocument(-1,0,NoMDI);		gmenu = stb->GetMenuMgr();	aboutMenu = new(StubMenuAbout);	aboutMenu->ctheMenu(stb);	gmenu->Append(aboutMenu);	fileMenu = new(StubMenuFile);	fileMenu->ctheMenu(stb);	gmenu->Append(fileMenu);	editMenu = new(StubMenuEdit);	editMenu->ctheMenu(stb);	gmenu->Append(editMenu);	SetStub(stb);#endif //MACINTOSH	}void StubMenuAbout::ctheMenu(V_Document *doc)	{	cMenu(APPLE_CHAR,doc);	Append((strPtr)"About Virtus " PRODUCTNAME "...");		//GJR 09/24/93	LinkMenu(DA_MENU);	}	voidStubMenuAbout::Action(int num, long modifier)	{	switch (num)		{		case 1:			if (modifier & V_OPTION)				AboutThisApplication(-1);			else				AboutThisApplication(1);			break;		default: DoDA(num); break;		}	}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/void StubMenuFile::ctheMenu(V_Document *doc)	{	cMenu(TXTM_FILE,doc);	Append(TXTM_QUIT);	SetKey(1,'Q');	}	voidStubMenuFile::Action(int num, long modifier)	{	if(num==1)Exit();	}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/void StubMenuEdit::ctheMenu(V_Document *doc)	{	cMenu(TXTM_EDIT,doc);	Append(TXTM_CUT);	Append(TXTM_COPY);	Append(TXTM_PASTE);		SetKey(1, 'X');	SetKey(2, 'C');	SetKey(3, 'V');	}void SetStub(V_Document *doc)	{	stub=doc;	if (!(theSuper->Remove(theSuper->Find(&doc))))		if(docCount!=-1)docCount--; // DAS-VR-VDOCUMENT 9/29/93 - don't increase the document number	}	V_Document *ActiveDocument(void)	{	V_Window *activeWindow;	V_Document *activeDocument;	activeDocument = NULL;	// jca 16FEB94 init the return value.#if VWT	activeWindow=TopWindow(NULL);	if(activeWindow)		{		if(activeWindow->theDocument)			activeDocument = activeWindow->theDocument;		else if(theSuper->ALength()>=1)			theSuper->Get(0,&activeDocument);		}	else  		{		if(theSuper->ALength()>=1)			theSuper->Get(0,&activeDocument);		}	if(!activeDocument)		activeDocument = stub;#elif VR	if (theSuper->ALength()>=1)		{		theSuper->Get(0,&activeDocument);		while (activeDocument->superDoc)			activeDocument=activeDocument->superDoc;		}	else		activeDocument = stub;#endif //VWT	return activeDocument;	}