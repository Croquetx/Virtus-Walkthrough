/*------------------------------------------------------------------------------ * Virtus V_Windows * Version 2.0 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				 *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  *		The following declaration-- GrafPtr theWindow=this->theWindow; * means that theWindow declared on the stack is set to the value in the object. * Further it overrides the objects definition in the method. * History: *		Modified		7/30/92		Added support for MSWindows * Most of what the VWindow object was designed to do is already supported * in MSWindows. Therefore, many of the methods defined here * are obsolete under MSWindows. A major change is that, because of the MDI * interface, the document window really owns this window, so the window is not * actually created until it is installed in the document. *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VWindow.h"#include "VDocumnt.h"#include "VPane.h"#include "VMenu.h"#include "VItem.h"#include "VPrint.h"#include "VMain.h"#include "VGraphic.h"#include "VGUtil.h"#include "VWI.H" // DAS-VWI 10/15/93#include <string.h>#include <stdio.h>#include "VWndUtls.h"	// ABD MERGE10 WILLIAMS#if MACINTOSH#include <QDOffscreen.h>#endif //MACINTOSHPoint maxPoint={32000,32000};#define FLOAT_WIN	128*16#if WINDOWSchar *windowClassName  = "Virtus:WindowProc";char *windoidClassName = "Virtus:WindoidProc"; V_Window *curWindow = NULL;void SetCurrentWindow(V_Window *w) { curWindow = w; };V_Window *GetCurrentWindow() { return curWindow; }#define CALLDEFPROC	-1#define MSG_DEACTIVATEWINDOID WM_USER+2001long HandleCommonThings(HWND , UINT , WPARAM , LPARAM );long FAR PASCAL _exportWndProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )	{	long result;	result = HandleCommonThings(hwnd,msg,wParam,lParam);	if(CALLDEFPROC == result)		result =  DefMDIChildProc(hwnd,msg,wParam,lParam);	return result;	}int dontMoveDialog=FALSE;long FAR PASCAL _exportWindoidProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )	{	long result;	if(dontMoveDialog && msg==WM_WINDOWPOSCHANGING)		{		tagWINDOWPOS *wPos = (tagWINDOWPOS *)lParam;		wPos->flags|=(SWP_NOMOVE|SWP_NOSIZE|SWP_NOOWNERZORDER|SWP_NOZORDER);        }	result = HandleCommonThings(hwnd,msg,wParam,lParam);	if(CALLDEFPROC == result)		result =  DefWindowProc(hwnd,msg,wParam,lParam);	return result;	}BOOL CALLBACK _exportEnumWindowsProc(HWND hwnd,LPARAM lParam)	{	HWND ignoreHwnd;	int state;	ignoreHwnd = LOWORD(lParam);	state = HIWORD(lParam);	if(ignoreHwnd!=hwnd)		EnableWindow(hwnd,state?TRUE:FALSE);    return TRUE;	}long HandleCommonThings(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )	{	FARPROC proc;	HWND	hwndAct;//	V_Document *doc; DAS 9/2/93	V_Window *win,*actWin;	MINMAXINFO FAR * lpmmi;	Rect 	r;	Point 	p;	int result;	win=(V_Window *)GetWindowLong(hwnd,0);	if(win==NULL)		win=curWindow;	if(win==NULL)return CALLDEFPROC; //get out of here, right now	result = CALLDEFPROC;	switch (msg)		{		case WM_CREATE:			win = GetCurrentWindow();			SetWindowLong(hwnd,0,(long)win);			if(win->wType&(WINDOID|ONTOP))		  					// jca 3 Oct 93				PostMessage(hwnd,MSG_DEACTIVATEWINDOID,0,0);			result = 0;			break;		case WM_ACTIVATE:			if((win->wType&(WINDOID|ONTOP)) && wParam!=WA_INACTIVE)   // jca 3 Oct 93				PostMessage(hwnd,MSG_DEACTIVATEWINDOID,0,0);			break;		case WM_QUERYDRAGICON://			icon = window->GetIcon();//			result = (NULL==icon)?NULL:(long)icon->GetIcon();			break;		case WM_NCHITTEST:			if(lastPane)				{				p.h=p.v=-1;				lastPane->TrackCursor(p,NULL);				lastPane = NULL;				}			break;		case WM_MOUSEMOVE:    	// DAS 6 Nov 93 {			VSetCursor(vCursorArrow);       // Windows can change the cursor on us without warning.			result = 0;			break;               // DAS 6 Nov 93 }		case WM_MDIACTIVATE:			if(!wParam) win->Deactivate();			else win->Activate();			result = 0;    			break;		case WM_SIZE:			win->Grow(p);			break;					case WM_CLOSE:			SendMessage(hwnd,WM_SYSCOMMAND,SC_RESTORE,0);    // jca 2MAR94 ELVIS????  good idea?			win->Delete();            result = 0;			break;		case WM_PARENTNOTIFY:			result=0;            break;		case WM_ERASEBKGND:			result=0;            break;		case WM_ACTIVATEAPP:			win->AppActivate(wParam);			break;		case MSG_DEACTIVATEWINDOID:			extern  HWND hwndFrame;			if(win->wType&(WINDOID|ONTOP)) 		// jca 3 Oct 93				{				V_Pane * pane;				V_Control *dropBox;				GetCursorPos((LPPOINT)&p);				ScreenToClient(hwnd,(LPPOINT)&p); //				pt.h = 5; //               pt.v = 5;#if VR				if (pane = win->FindPane(p))					if (dropBox = pane->FindControlType(CBS_DROPDOWNLIST))						if (((V_PopMenu*)dropBox)->DroppedDown())							{							result = 0;							break;							}#endif // VR#if VPRO// ABDWINQQQ so we don't deactivate when choosing the pro textures menu				{				extern int gWindowsSucks;					if (gWindowsSucks)					{						result = 0;                        break;                    }                }#endif // VPRO				if(hwnd==GetActiveWindow())                	{					if(hwndFrame)SetActiveWindow(hwndFrame);                	else#if VWT                 // jca 3 Oct 93 {					SetActiveWindow(win->theDocument->GetFrame());#elif VR					SetActiveWindow((GetCurrentDocument())->GetFrame());#endif // VWT			// jca 3 Oct 93					}                }			result = 0;			break;		case WM_GETMINMAXINFO:			lpmmi=(MINMAXINFO FAR *)lParam;			/*modal dialogs usually don't pay attention to max and min sizing*/			if(!(win->wType&MODALDIALOG))				{				lpmmi->ptMinTrackSize.x= win->mnSize.h;				lpmmi->ptMinTrackSize.y= win->mnSize.v;				lpmmi->ptMaxTrackSize.x= win->mxSize.h;				lpmmi->ptMaxTrackSize.y= win->mxSize.v;				}			break;		case WM_KEYDOWN:			result = win->KeyAction(wParam,GetMSGModifiers());			break;		#if WINKEYBOARDVAVIGATION	//17OCT94 JAM-WINDOWS-KEYBOARD-NAVIGATION [[[		case WM_KEYUP:			result = win->KeyUpAction(wParam,GetMSGModifiers());		#endif //WINKEYBOARDVAVIGATION	//17OCT94 JAM-WINDOWS-KEYBOARD-NAVIGATION ]]]/*		case WM_SHOWWINDOW:			if (wParam && ((lParam&0x0000FFFF) == SW_PARENTOPENING))				if (win == ActiveDocument()->GetVRLib())					{					HWND	hwnd = ActiveDocument()->GetMDIClient();					Rect	mdiR;					GetWindowRect(hwnd, &mdiR);					MoveWindow(hwnd, 204, 0, (mdiR.right-mdiR.left)-204, mdiR.bottom-mdiR.top, TRUE);					}			break;*/		}	return result;	}#endif //WINDOWS#if MACINTOSHWindowPeek GetRealWindow(WindowPeek pwin);#endif //MACINTOSHvoidV_Window::AppActivate(int state)	{	int showType;#if WINDOWS	if(wType&WINDOID)    	{		if(state)			showType = SW_RESTORE;		else			{			appActivateState = Visible(); 			showType = SW_HIDE;			}		if(appActivateState)			ShowWindow(theWindow,showType);		}#endif //WINDOWS	}#if WINDOWS/*------------------------------------------------------------------------------ * void V_Window::KeyAction(char key,long modifier) * * Handles KeyPress events with appropriate modifiers * char key; the key value pressed * int modifier; the value of the modifiers sent *------------------------------------------------------------------------------*/int V_Window::KeyAction(char key,long modifier){long i,length;V_Pane *thePane;Rect bounds;int width;VGrafPort theWindow=this->theWindow;int rval=FALSE;if(icon)return FALSE;VSetPort(theWindow,0L);if(panes)	{		length=panes->ALength();	for(i=0;i<length;i++)		{		panes->Get(i,&thePane);		if(thePane->KeyAction(key,modifier))			{			rval=TRUE;            break;			}		}	}return rval;}#if WINKEYBOARDVAVIGATION	//17OCT94 JAM-WINDOWS-KEYBOARD-NAVIGATION [[[/*------------------------------------------------------------------------------ * void V_Window::KeyUpAction(char key,long modifier) * * Handles KeyUp events with appropriate modifiers * char key; the key value pressed * int modifier; the value of the modifiers sent *------------------------------------------------------------------------------*/int V_Window::KeyUpAction(char key,long modifier){long i,length;V_Pane *thePane;Rect bounds;int width;VGrafPort theWindow=this->theWindow;int rval=FALSE;if(icon)return FALSE;VSetPort(theWindow,0L);if(panes)	{		length=panes->ALength();	for(i=0;i<length;i++)		{		panes->Get(i,&thePane);		if(thePane->KeyUpAction(key,modifier))			{			rval=TRUE;            break;			}		}	}return rval;}#endif //WINKEYBOARDVAVIGATION //17OCT94 JAM-WINDOWS-KEYBOARD-NAVIGATION ]]]#endif //WINDOWSVGrafPort V_Window::GetParentWindow() { return theWindow; }void V_Window::cWindow(Rect *pr,strPtr strName,Point mnSze,Point mxSze,							Point wnSize,int flag,int importance)	{	string name[256];	int makeType=0;	wType = flag;	SetDisplayType(DISPLAY_WINDOW); // DAS-VWINDOWS 10/9/93	panes = NULL;		resolution.h = resolution.v = 72; /* 72 pixels/inch */	strcpy(name,strName);	mnSize=mnSze;			/*minimum window size*/	mxSize=mxSze;			/*maximum window size*/	warnSize=wnSize;		/*warning size*/	if(flag&GROWBOX)		grow=TRUE;			/*grow-box in lower right*/	else		grow=FALSE;// ABD MERGE12 WILLIAMS 9/12/93 [[[	if(flag&ZOOMBOX)		zoom=TRUE;			/*zoom-box in upper right*/	else		zoom=FALSE;// ABD MERGE12 WILLIAMS 9/12/93 ]]]	icon=FALSE;	priority=importance;	activeText = NULL; 	dragable=TRUE;	if(flag&OFFSCREEN)		offFlag=TRUE;	else		offFlag=FALSE;#if WINDOWS	if(flag&GROWBOX) //Add width of window frame that CAN be sized		{		mnSize.h+=GetSystemMetrics(SM_CXFRAME)<<1;        mnSize.v+=GetSystemMetrics(SM_CYFRAME)<<1;		mxSize.h+=GetSystemMetrics(SM_CXFRAME)<<1;		mxSize.v+=GetSystemMetrics(SM_CYFRAME)<<1;		warnSize.h+=GetSystemMetrics(SM_CXFRAME)<<1;		warnSize.v+=GetSystemMetrics(SM_CYFRAME)<<1;		}    else       //Add width of window frame that CANNOT be sized		{		mnSize.h+=GetSystemMetrics(SM_CXBORDER)<<1;        mnSize.v+=GetSystemMetrics(SM_CYBORDER)<<1;		mxSize.h+=GetSystemMetrics(SM_CXBORDER)<<1;		mxSize.v+=GetSystemMetrics(SM_CYBORDER)<<1;		warnSize.h+=GetSystemMetrics(SM_CXBORDER)<<1;		warnSize.v+=GetSystemMetrics(SM_CYBORDER)<<1;		}	if(flag&DRAGBAR)		{		mnSize.v+=GetSystemMetrics(SM_CYCAPTION);		mxSize.v+=GetSystemMetrics(SM_CYCAPTION);		warnSize.v+=GetSystemMetrics(SM_CYCAPTION);		}#elif MACINTOSH	C2Pstr(name);#endif //WINDOWS		if (flag&ONTOP)		// DAS-VWI this is for the message window		{		dragable=FALSE; //		wType|=DRAGBAR;     // DO NOT HAVE DRAGBAR ON WINDOWS!!!!!!!		makeType = 2;		}	else if(flag&BORDERLESS)		{		dragable=FALSE;		makeType=2;		}	else if(flag&MODALWINDOW)		{		makeType=1;		}	else if(flag&DRAGBAR)		{		if(zoom) makeType=8;	// ABD WILLIAMS MERGE12 9/12/93		else makeType=0;#if MACINTOSH		wType |= DRAGBAR;#endif //MACINTOSH		}	else 		{		makeType=1;#if MACINTOSH		wType |= DRAGBAR;#endif //MACINTOSH		}	if(flag & WINDOID)		{		makeType+=FLOAT_WIN;		dragable = TRUE;//		wType |= DRAGBAR;		}#if MACINTOSH	if(MainDepth())		{		theWindow = (GrafPtr)NewCWindow( NULL , pr, (StringPtr)name, 0, makeType, (WindowPtr)-1L, (flag&GOAWAY) ? TRUE : FALSE, 0L);		bitType=COLOR_QD;		}	else		{		theWindow = (GrafPtr)NewWindow( NULL , pr, (StringPtr)name, 0, makeType, (WindowPtr)-1L, (flag&GOAWAY) ? TRUE : FALSE, 0L);		bitType=MONO_QD;		}	if(flag & WINDOID && flag & ZOOMBOX)/* ABD MERGE12 WILLIAMS 9/12/93 set the zoom rects */		{		WStateData **zoomState;			zoomState=(WStateData **)((WindowPeek)theWindow)->dataHandle;		(*zoomState)->userState.right=(*zoomState)->userState.left+mnSze.h;		(*zoomState)->userState.bottom=(*zoomState)->userState.top+mnSze.v;		}	SetWRefCon(theWindow,(long)this);#elif WINDOWS	{	V_Document *doc;    HWND parentWindow;	MDICREATESTRUCT mcs;	Rect r;	DWORD wStyle,wStyleEx;	r=*pr;	AddFrameSize(&r);	wStyle = WS_CLIPCHILDREN;	wStyleEx = 0;	if(wType&MODALWINDOW || wType&ONTOP) // DAS-VWINDOWS-FIX 9/13/93		{		if(wType&MODALDIALOG)			{			if(wType&DRAGBAR)	wStyleEx|=WS_EX_DLGMODALFRAME;			else wStyle|=(WS_DLGFRAME|WS_POPUP);			}		if(wType&POPUPDIALOG) wStyle|=WS_POPUP;		}	else		{		if(wType&DRAGBAR)wStyle|=WS_CAPTION;		if(wType&GOAWAY)wStyle|=WS_SYSMENU;		if(!(wType&WINDOID))			{			wStyle|=WS_OVERLAPPED;			if(wType&GROWBOX)wStyle|=(WS_THICKFRAME|WS_MAXIMIZEBOX|WS_MINIMIZEBOX);			}		else        	if(wType&GROWBOX)wStyle|=WS_THICKFRAME;		}	SetCurrentWindow(this);	doc =GetCurrentDocument();    if(doc)doc->RevealFrame();	if (wType&FULLSCREEN)		{		HWND owner=HWND_DESKTOP;		FARPROC proc;		if(doc)owner=doc->GetFrame();		theWindow = CreateWindowEx(wStyleEx,windoidClassName,			name,WS_POPUPWINDOW,r.left,r.top,r.right-r.left,			r.bottom-r.top,owner,NULL,			GetAppInstance(),NULL);		proc = MakeProcInstance((FARPROC)EnumWindowsProc,GetAppInstance());		EnumTaskWindows(GetCurrentTask(),proc,MAKELPARAM(theWindow,FALSE));		FreeProcInstance(proc);		}	else if(wType&MODALWINDOW)		{		HWND owner=HWND_DESKTOP;		FARPROC proc;		if(doc)owner=doc->GetFrame();		theWindow = CreateWindowEx(wStyleEx,windoidClassName,			name,wStyle,r.left,r.top,r.right-r.left,			r.bottom-r.top,owner,NULL,			GetAppInstance(),NULL);		proc = MakeProcInstance((FARPROC)EnumWindowsProc,GetAppInstance());		EnumTaskWindows(GetCurrentTask(),proc,MAKELPARAM(theWindow,FALSE));		FreeProcInstance(proc);		}	else if(wType&WINDOID)		{		theWindow = CreateWindowEx(wStyleEx,windoidClassName,			name,wStyle,r.left,r.top,r.right-r.left,			r.bottom-r.top,doc->GetFrame(),NULL,			GetAppInstance(),NULL);		}	else if(wType&ONTOP)		{		wStyle &= WS_EX_TOPMOST/*&WS_CHILD*/;        wStyle |= WS_POPUP;   // ELVIS		theWindow = CreateWindowEx(wStyleEx,windoidClassName,			name,wStyle,r.left,r.top,r.right-r.left,			r.bottom-r.top,doc->GetFrame(),NULL,			GetAppInstance(),NULL);		}	else		{		mcs.szTitle=name;		mcs.szClass=windowClassName;		mcs.x=r.left;		mcs.y=r.top;		mcs.cx=r.right-r.left;		mcs.cy=r.bottom-r.top;		mcs.style=wStyle;		mcs.hOwner=GetAppInstance();		mcs.lParam=NULL;		theWindow = SendMessage(doc->GetMDIClient(),WM_MDICREATE,0,(long)&mcs);        }	}#endif //MACINTOSH		theMenu=new(V_MenuMgr);	theMenu->cMenuMgr();	}void V_Window::SetDocument(V_Document *doc) { theDocument = doc; }voidV_Window::dWindow()	{	V_Pane *aPane;	V_Window *vwin;#if WINDOWS	if(wType&MODALWINDOW)		{		FARPROC proc;		proc = MakeProcInstance((FARPROC)EnumWindowsProc,GetAppInstance());		EnumTaskWindows(GetCurrentTask(),proc,MAKELPARAM(theWindow,TRUE));		FreeProcInstance(proc);		}	if(wType&FULLSCREEN)		{		FARPROC proc;		proc = MakeProcInstance((FARPROC)EnumWindowsProc,GetAppInstance());		EnumTaskWindows(GetCurrentTask(),proc,MAKELPARAM(theWindow,TRUE));		FreeProcInstance(proc);		DestroyWindow(theWindow);		theDocument->UnInstall(this);		delete(this);		return;        }#endif //WINDOWS	if(theDocument)		theDocument->React(this,CLOSE);	if(panes)		{		while(panes->ALength())			{			panes->Get(0,&aPane);			UnInstall(aPane);			aPane->dPane();			}		panes->dArray();		}	theMenu->dMenuMgr();// DAS-VWI - slight change of order for ONTOP windows#if MACINTOSH		DisposeWindow(theWindow);	// DAS-VWI changed to insure hilites of not ONTOP windows	// make sure that this document is not in the process of going away.	vwin=TopWindow(0);	if(	vwin &&  							// is there another window to select?		vwin->theWindow!=FrontWindow() && 	// is it not already the front window?		vwin!=this &&						// is it NOT this window?											// are we closing the document anyway?		((!theDocument) || (!theDocument->closing) || theDocument!=vwin->theDocument))		vwin->Select();	// { DAS-BUGFIX 10/23/93 this gets done later.	//#elif WINDOWS	//if(NULL != theWindow)DestroyWindow(theWindow);#endif //MACINTOSH#if WINDOWS	if(theDocument)		{		if(wType&(ONTOP|WINDOID|MODALWINDOW)) DestroyWindow(theWindow);		else			{			HWND client=theDocument->GetMDIClient();			if(client)     // DAS-BUGFIX 10/23/93				{				SendMessage(client, WM_MDIDESTROY, theWindow, 0);                }            else DestroyWindow(theWindow);			}		theDocument->UnInstall(this);		}	else DestroyWindow(theWindow);	theWindow=NULL;	if (this == GetCurrentWindow())		SetCurrentWindow(NULL);		// jca 7MAR94 the current window should not point to a destroyed window. // } DAS-BUGFIX 10/23/93#elif MACINTOSH	if(theDocument)theDocument->UnInstall(this);  // DAS-BUGFIX 10/23/93		{		extern WindowPeek  lastWindow;		if(lastWindow==(WindowPeek)theWindow)lastWindow=0;	    }#endif //WINDOWS		theWindow=NULL;	theDocument=NULL;			delete(this);	}void V_Window::Install(V_Pane *aPane)	{	if(!panes)		{		panes=new(V_Array);		panes->cArray(0,sizeof(V_Pane *),8);		}	aPane->SetUp(this);	panes->Append(&aPane);	// DAS-VWINDOWS-FIX 9/9/93	aPane->active=Active()?TRUE:FALSE;#if MACINTOSH	InvalRect(&theWindow->portRect);#elif WINDOWS	InvalidateRect(theWindow,NULL,FALSE);#endif //WINDOWS	aPane->RestoreScrollValues();	//reload any scrollbar values saved								//by UnInstall JAM 11/3/93	}	void V_Window::UnInstall(V_Pane *aPane)	{	long position;	if(!panes)return;	position=panes->Find(&aPane);	if(position>=0)		{		aPane->StashScrollValues();	//save any scrollbar values for reload        						//by Install JAM 11/3/93 		aPane->UnSetUp();		panes->Remove(position);		if(aPane==savePane)savePane=NULL;/*DAS 9/26/90 No need to clean up something that ain't there*/		if(aPane==lastPane)lastPane=NULL;#if MACINTOSH		InvalRect(&theWindow->portRect);#elif WINDOWS		InvalidateRect(theWindow,NULL,FALSE);#endif //WINDOWS		}	}void V_Window::GetRect(Rect *pr)	{#if MACINTOSH	/* *pr=theWindow->portRect; */	pr->left = theWindow->portRect.left;	pr->right = theWindow->portRect.right;	pr->top = theWindow->portRect.top;	pr->bottom = theWindow->portRect.bottom;		pr->right-=pr->left;	pr->bottom-=pr->top;	pr->left=pr->top=0;#elif WINDOWS	if(theWindow)GetClientRect(theWindow,pr);	else pr->left=pr->top=pr->right=pr->bottom=0;#endif //WINDOWS	}void V_Window::AddFrameSize(Rect *pr){#if WINDOWSif(wType&GROWBOX) //Add width of window frame that CAN be sized	{	pr->left-=	GetSystemMetrics(SM_CXFRAME);	pr->right+=	GetSystemMetrics(SM_CXFRAME);	pr->top-=	GetSystemMetrics(SM_CYFRAME);    pr->bottom+=GetSystemMetrics(SM_CYFRAME);	}else       //Add width of window frame that CANNOT be sized	{	pr->left-=	GetSystemMetrics(SM_CXBORDER);	pr->right+=	GetSystemMetrics(SM_CXBORDER);	pr->top-=	GetSystemMetrics(SM_CYBORDER);    pr->bottom+=GetSystemMetrics(SM_CYBORDER);	}if(wType&DRAGBAR)	pr->top-=GetSystemMetrics(SM_CYCAPTION);#endif //WINDOWS//This is to match the MAC Dialog frame around dialogs//DAS NOTE: Looks like a Mark Thing, I don't know why he is doing this.if(wType&MODALDIALOG)	{	pr->top-=3;	pr->bottom+=3;	pr->left-=3;	pr->right+=3;    }}void V_Window::RemoveFrameSize(Rect *pr){#if WINDOWSif(wType&GROWBOX) //Add width of window frame that CAN be sized	{	pr->left+=	GetSystemMetrics(SM_CXFRAME);	pr->right-=	GetSystemMetrics(SM_CXFRAME);	pr->top+=	GetSystemMetrics(SM_CYFRAME);    pr->bottom-=GetSystemMetrics(SM_CYFRAME);	}else       //Add width of window frame that CANNOT be sized	{	pr->left+=	GetSystemMetrics(SM_CXBORDER);	pr->right-=	GetSystemMetrics(SM_CXBORDER);	pr->top+=	GetSystemMetrics(SM_CYBORDER);    pr->bottom-=GetSystemMetrics(SM_CYBORDER);	}if(wType&DRAGBAR)	pr->top+=GetSystemMetrics(SM_CYCAPTION);#endif //WINDOWS//This is to match the MAC Dialog frame around dialogs//DAS NOTE: Looks like a Mark Thing, I don't know why he is doing this.if(wType&MODALDIALOG)	{	pr->top+=3;	pr->bottom-=3;	pr->left+=3;	pr->right-=3;    }}void V_Window::Locate(Rect *pr)	{#if MACINTOSH	Point p;	VGrafPort	savePort;	VGrafDevice saveDevice;			VGetPort( &savePort,&saveDevice );	VSetPort(theWindow,0L);		*pr=theWindow->portRect;	p.h=pr->left;	p.v=pr->top;	LocalToGlobal(&p);	pr->right=p.h+(pr->right-pr->left);	pr->left=p.h;	pr->bottom=p.v+(pr->bottom-pr->top);	pr->top=p.v;	VSetPort( savePort,saveDevice );#elif WINDOWS	if(theWindow){		GetWindowRect(theWindow,pr);		RemoveFrameSize(pr);        }	else pr->left=pr->top=pr->right=pr->bottom=0;#endif //WINDOWS	}/*------------------------------------------------------------------------------ * V_Pane *V_Window::FindPane(Point); *  * Given a point in window coordinates this routine returns the pane object. *------------------------------------------------------------------------------*/V_Pane *V_Window::FindPane(Point pt){long i,length;V_Pane **thePane;V_Pane *thisPane;Rect r;Point pt2;GetRect(&r);if(VPtInRect(pt,&r))	{	if(panes)		{		length=panes->ALength();		thePane=(V_Pane **)panes->Use();		for(i=0;i<length;i++)			{			if(VPtInRect(pt,&thePane[i]->paneRect))				{				pt2.h=pt.h-thePane[i]->paneRect.left;				pt2.v=pt.v-thePane[i]->paneRect.top;				if(VPtInRect(pt2,&thePane[i]->dataRect))					{					thisPane=thePane[i];					break;					}				}			}		panes->Unuse();		}	else return 0;	if(i==length)return 0;	else return thisPane;	}else return 0;}voidV_Window::Delete()	{	int front,lastWindow=FALSE;	V_Window *vwin=0;	V_Document *doc;		front = (this==TopWindow(NULL)) ? TRUE : FALSE;	if(front)		{#if MACINTOSH		ClearMenuBar();#endif //MACINTOSH		doc=theDocument;//		visibleMMgr->SetLength(0);   DAS 2 Nov 93  we're losing resources		}		VSendMessage(CLEAN_MENUS);#if VWT || VPLAYER			// MERGE-1/28	if(!(wType&MODALWINDOW) && (!(wType&WINDOID)) && theDocument && theDocument->ActiveWindows()==1)/*this is the last window!*/	// MERGE-GOURAUD-PRO-6		theDocument->Close();	else#endif //VWT || VPLAYER		// MERGE-1/28	switch(priority)		{		case WINDOW_CLOSE:			if(theDocument)theDocument->Close();			front = FALSE; 			break;		case WINDOW_HIDE: Hide(); break;		case WINDOW_DESTROY:#if WINDOWS			// This should only have to be in dWindow(), but it has to be			// before the Hide() or Windows will switch to another application			// trying to find a window to activate. This stuff is in dWindow too            // to handle all the cases that call dWindow() directly.			if(wType&MODALWINDOW)				{				FARPROC proc;				proc = MakeProcInstance((FARPROC)EnumWindowsProc,GetAppInstance());				EnumTaskWindows(GetCurrentTask(),proc,MAKELPARAM(theWindow,TRUE));				FreeProcInstance(proc);  		     	}#endif //WINDOWS			Hide();			dWindow(); 			break;		}	if(front)		{		vwin=TopWindow(doc);#if WINDOWS		if (vwin == this)			{			SendMessage(theDocument->GetMDIClient(),WM_MDINEXT,theWindow,0);			vwin = NULL;            }#endif //WINDOWS		if(vwin) vwin->Select();		}	}void V_Window::Freeze(int freeze) { dragable=freeze; }void V_Window::SetTitle(strPtr ttl)	{#if MACINTOSH	string str[256];	strcpy(str,ttl);	C2Pstr(str);	SetWTitle(theWindow,(StringPtr)str);		/*update the menus!*/#elif WINDOWS	if(theWindow)		SetWindowText(theWindow,ttl);#endif //WINDOWS	if(!(wType&MODALWINDOW) && Visible())		VSendMessage(CLEAN_MENUS);	}void V_Window::GetTitle(strPtr str)	{#if MACINTOSH	GetWTitle(theWindow,(unsigned char *)str);	P2Cstr(str);#elif WINDOWS	GetWindowText(theWindow,str,256);#endif //WINDOWS	}void V_Window::Move(Rect *mRect)	{	Rect        tempRect,OldRect,bounds,r;	Point		tPt;	int 		xSize,ySize;	long i,length;	V_Pane **thePane;	int sizeWarn;	int showit=FALSE;	int front;#if MACINTOSH	front=ActiveWindow((WindowPeek)theWindow);	if(icon)return;	VSetPort(theWindow,0L);	OldRect = theWindow->portRect;	VSetRect(&tempRect,-32000,-32000,32000,32000);	/* XYZZY	if(Visible())		{		Hide();		showit=TRUE;		}    	*/	xSize=mRect->right-mRect->left;	ySize=mRect->bottom-mRect->top;	if(xSize<mnSize.h)xSize=mnSize.h;	if(ySize<mnSize.v)ySize=mnSize.v;	if(xSize>mxSize.h)xSize=mxSize.h;	if(ySize>mxSize.v)ySize=mxSize.v;	sizeWarn=ySize<warnSize.v || xSize<warnSize.h;	SizeWindow(theWindow, xSize, ySize, TRUE);	MoveWindow(theWindow,mRect->left,mRect->top,FALSE); // DAS-VWINDOWS-FIX 9/28/93	/* XYZZY	if(showit)Show();	*/	ClipRect(&theWindow->portRect);	InvalRect(&theWindow->portRect); // DAS-VWINDOWS-FIX 9/28/93	offFlag=TRUE;	tempRect=theWindow->portRect;	Resize(sizeWarn);	if(grow)DrawGrow();	VSetPort(theWindow,0L);#elif WINDOWS	HWND parent;	Rect parentR;	r = *mRect;	AddFrameSize(&r);	xSize=r.right-r.left;	ySize=r.bottom-r.top;	if(xSize<mnSize.h)xSize=mnSize.h;	if(ySize<mnSize.v)ySize=mnSize.v;	if(xSize>mxSize.h)xSize=mxSize.h;	if(ySize>mxSize.v)ySize=mxSize.v;	sizeWarn=ySize<warnSize.v || xSize<warnSize.h;	if((parent=GetParent(theWindow))!=NULL)		{		GetWindowRect(parent,&parentR);		r.left-=parentR.left;		r.right-=parentR.left;		r.top-=parentR.top;        r.bottom-=parentR.top;		}	MoveWindow(theWindow,r.left,r.top,xSize,ySize,TRUE);	offFlag=TRUE;#endif //WINDOWS	}voidV_Window::Resize(int sizeWarn)	{	VGrafPort aWindow;	V_Pane **thePane;	int i,length;		#if MACINTOSH		aWindow=theWindow;	{	RgnHandle 	gatherRgn,windowRgn;	gatherRgn=NewRgn();	windowRgn=NewRgn();	if(panes)		{		length=panes->ALength();		thePane=(V_Pane **)panes->Use();		for(i=0;i<length;i++,thePane++)			(*thePane)->Resize(gatherRgn,sizeWarn);		panes->Unuse();		}	RectRgn(windowRgn,&aWindow->portRect);	DiffRgn(windowRgn,gatherRgn,gatherRgn);	if(!EmptyRgn(gatherRgn))	 	{	 	SetClip(gatherRgn);	 	EraseRect(&aWindow->portRect);	 	ClipRect(&aWindow->portRect);	 	}	DisposeRgn(gatherRgn);	DisposeRgn(windowRgn);	}#elif WINDOWS	if(panes)		{		length=panes->ALength();		thePane=(V_Pane **)panes->Use();		for(i=0;i<length;i++,thePane++)			(*thePane)->Resize(sizeWarn);		panes->Unuse();		UpdateWindow(theWindow);		}#endif //WINDOWS	}		void V_Window::Show()	{	V_Window *twin;// DAS-VWINDOWS-FIX 9/9/93	if(Visible())return;	if(theDocument)theDocument->React(this,SHOW);#if MACINTOSH	twin=TopWindow(theDocument);	//DAS-VWINDOWS-FLATTEN 9/2/93	if(twin && (REALDOC(twin->theDocument)!=REALDOC(theDocument)) && !(wType&ONTOP)) // DAS-VWI on top windows do not effect anyone else.		{		WindowPeek topWindow;		if(topWindow = (WindowPeek)twin->theWindow)/*unhilite all of the existing windows*/			{			while(topWindow)				{				HiliteWindow((WindowPtr)topWindow,FALSE);				topWindow=topWindow->nextWindow;				}			}		}			if(wType&MODALWINDOW)		{		twin=TopWindow(theDocument);		Behind(0);		ShowWindow(theWindow);		// DAS-BUGFIX 9/5/93		if(twin && REALDOC(twin->theDocument)==REALDOC(theDocument))// DAS-VWINDOWS-FLATTEN 9/2/93			HiliteWindow((WindowPtr)twin->theWindow,TRUE);		}	else		{		twin=TopWindow(theDocument);		Behind(BottomWindoid(theDocument));		ShowWindow(theWindow);		HiliteWindow((WindowPtr)theWindow,TRUE);		if(twin)			{			HiliteWindow((WindowPtr)twin->theWindow,FALSE);			twin->Deactivate();			}		}#elif WINDOWS	if(theWindow)		{		// jca 30MAR94 why:  If this is a modal-sort of window (or windoid or ontop)		// then we want to show it only if the document is shown.  If		// the user has minimized or hidden the document (say, by selecting		// Run Minimized under the Properties dialog), then we do not		// want to show the window, nor do we want to match the document's        // state.  Just hide the thing.		if(theDocument && (wType&(MODALWINDOW|WINDOID|ONTOP)))			{			int showState;			// so if the document frame is a valid window, and it is			// not visible or iconisized, then Hide this window.			if (IsWindow(theDocument->GetFrame()) && 				((!IsWindowVisible(theDocument->GetFrame())) ||				 (IsIconic(theDocument->GetFrame()))))                {				ShowWindow(theWindow,SW_HIDE);				return;	// if we continue and call theDocument->Activate(), we'll go into an infinite loop.                }			else				ShowWindow(theWindow,SW_SHOW);			} 		else        	{			ShowWindow(theWindow,SW_SHOW); 			}		InvalidateRect(theWindow,NULL,FALSE);		if(theDocument && !(wType&(MODALWINDOW|WINDOID|ONTOP))) // DAS BUGFIX 10/7/93			SendMessage(theDocument->GetMDIClient(),WM_MDIACTIVATE,(WPARAM)theWindow,0);		}#endif //WINDOWS	Activate();	if(theDocument)theDocument->Activate(this);	offFlag=TRUE;	}	void V_Window::Hide()	{	if(theDocument)theDocument->React(this,HIDE);	if(theWindow)#if MACINTOSH		HideWindow(theWindow);#elif WINDOWS		ShowWindow(theWindow,SW_HIDE);#endif //WINDOWS	}int V_Window::Visible()	{	int result;#if MACINTOSH	result = (((WindowPeek)theWindow)->visible) ? TRUE : FALSE;#elif WINDOWS	result = (theWindow) ? IsWindowVisible(theWindow) : FALSE;#endif //WINDOWS	return result;	}V_MenuMgr *V_Window::GetMenuMgr() { return theMenu; }int V_Window::Active()	{	int result;#if MACINTOSH	result = ((WindowPeek)theWindow)->hilited && ActiveWindow((WindowPeek)theWindow) ? TRUE : FALSE;#elif WINDOWS	result = (theWindow) ? IsWindowEnabled(theWindow) : FALSE;#endif //WINDOWS	return result;	}void V_Window::Grow(Point myPt)	{	Rect sizeRect;	int sizeWarn;	Rect        tempRect,OldRect,bounds;	long		mResult;	Point		tPt;	int 		xSize,ySize;	long i,length;	VGrafPort aWindow;	V_Pane **thePane;		aWindow=theWindow;	#if MACINTOSH	if(icon)return;	if(grow)		{		VSetPort(aWindow,0L);		tPt=myPt;		GlobalToLocal(&tPt);	 		OldRect = aWindow->portRect;		VSetRect(&tempRect,-32000,-32000,32000,32000);		sizeRect.top=mnSize.v;		sizeRect.left=mnSize.h;		sizeRect.bottom=mxSize.v;		sizeRect.right=mxSize.h;				mResult = GrowWindow(aWindow, myPt, &sizeRect);		if(mResult)			{			xSize=LoWord(mResult);			ySize=HiWord(mResult);			sizeWarn=ySize<warnSize.v || xSize<warnSize.h;			SizeWindow(aWindow, xSize, ySize, TRUE);			ClipRect(&aWindow->portRect);			offFlag=TRUE;			Resize(sizeWarn);			if(grow)DrawGrow();	 		VSetPort(aWindow,0L);	 		InvalRect(&aWindow->portRect);			}		}#elif WINDOWS	GetRect(&sizeRect);	sizeWarn=(sizeRect.bottom-sizeRect.top)<warnSize.v || (sizeRect.right-sizeRect.left)<warnSize.h;	Resize(sizeWarn);#endif //WINDOWS	}		void  V_Window::Activate()	{	V_Pane **thePanes;	VGrafPort aWindow;	long length,i;		aWindow=theWindow;		if(!Visible())return;	VSetPort(aWindow,0L);#if MACINTOSH	HiliteWindow(aWindow,TRUE);#endif //MACINTOSH	offFlag=TRUE;	if(panes && !icon)		{		length=panes->ALength();		thePanes=(V_Pane **)panes->Use();		for(i=0;i<length;i++,thePanes++)			(*thePanes)->Activate(); 		panes->Unuse();		}	if(theDocument)	   if(!theDocument->closing)        //the buck ends here (or else we crash)	   		theDocument->React(this,ACTIVATE);#if MACINTOSH	if(grow)DrawGrow(); /* Draw the Grow box */#elif WINDOWS//	SetFocus(theWindow);	VSendMessage(CLEAN_MENUS);#endif //WINDOWS	}	void V_Window::Deactivate(void)	{	V_Pane **thePanes;	VGrafPort aWindow;	long length,i;		if(!Visible())return;	aWindow=theWindow;	VSetPort(aWindow,0L);#if MACINTOSH	HiliteWindow(aWindow,FALSE);#endif //MACINTOSH	if(panes && !icon)		{		length=panes->ALength();		thePanes=(V_Pane **)panes->Use();		for(i=0;i<length;i++,thePanes++)			(*thePanes)->Deactivate();		panes->Unuse();		}	if(theDocument)		theDocument->React(this,DEACTIVATE);#if MACINTOSH	ClipRect(&theWindow->portRect);#endif //MACINTOSH	VSendMessage(CLEAN_MENUS);	}V_Window *TopWindow(V_Document *theDocument)	{	V_Window *vwin;#if MACINTOSH	WindowPeek pwin;		theDocument=REALDOC(theDocument); // DAS-VWINDOWS-FLATTEN 9/2/93	pwin=(WindowPeek)FrontWindow();	/*ignore the DA's and invisible windows*/	pwin=GetRealWindow(pwin);		if(!theDocument)/*then choose the top document*/		{		if(pwin)theDocument=((V_Window *)GetWRefCon((WindowPtr)pwin))->theDocument;		theDocument=REALDOC(theDocument);// DAS-VWINDOWS-FLATTEN 9/2/93		}	vwin = NULL;	while(pwin)		{		vwin=(V_Window *)GetWRefCon((WindowPtr)pwin);/*the top one*/		// DAS-VWINDOWS-FLATTEN 9/2/93		if(!(vwin->wType&WINDOID) && REALDOC(vwin->theDocument)==REALDOC(theDocument) && vwin->Visible())			break;		pwin=GetRealWindow(pwin->nextWindow);		}#elif WINDOWS	HWND whichWindow;	LRESULT result;	if(!theDocument) theDocument=GetCurrentDocument();	if(!theDocument)		whichWindow = NULL;    else    	{// jca 30 Oct 93 {		HWND  theMDI;	/* 	jca 30 Oct 93.  The Postmaster General has determined that use of		this code to find the active, on-top window can lead to ulcers,		indigestion, and GP faults.  It has the unfortunate tendency to		return the "Network..." button on the OpenFile dialog as the		topmost window, even though that dialog has been taken down.		So, we check that the window is a child of the MDI.		result=SendMessage(theDocument->GetMDIClient(),WM_MDIGETACTIVE,0,0);		whichWindow=LOWORD(result);	*/		theMDI = theDocument->GetMDIClient();		if (theMDI)	// it is sometimes NULL			{            char className[256];			result=SendMessage(theMDI,WM_MDIGETACTIVE,0,0);  	// this should be okay, but ya never know...			whichWindow=LOWORD(result);			if (whichWindow)				{				if (!(IsChild(theMDI, whichWindow)))					whichWindow = NULL;                }			}		else        // if no MDI, then no window on top of it.        	whichWindow = NULL;// jca 30 Oct 93 }		}		vwin = (whichWindow) ? (V_Window*)GetWindowLong(whichWindow,0):NULL;#endif //WINDOWS	return vwin;	}void V_Window::Select()	{	V_Window *vwin,*twin;	V_Window *oldtwin;	V_Window *bwindow=NULL,*bwindoid=NULL;#if MACINTOSH	WindowPeek nextWindow,tWindow,mWindow;#endif //MACINTOSH		if(!Visible())		{		Show();		return;		}	oldtwin=TopWindow(NULL);#if MACINTOSH		tWindow=GetRealWindow((WindowPeek)FrontWindow());		mWindow=(WindowPeek)MyFrontWindow();	if( tWindow==(WindowPeek)theWindow ||		mWindow==(WindowPeek)theWindow)		goto endSelect;/*trivially selected*/			/*at least this document may be in front*/	vwin=(V_Window *)GetWRefCon((WindowPtr)tWindow);	if(REALDOC(vwin->theDocument)==REALDOC(theDocument))// DAS-VWINDOWS-FLATTEN 9/2/93		{		if(wType&MODALWINDOW)			{			Behind(0);			goto endSelect;			}		else			{			vwin=TopWindow(theDocument);			if(vwin==this)				goto endSelect;			Behind(BottomWindoid(theDocument));			goto endSelect;			}		}	/*this is not the front document, thus it needs to become it*/	Behind(0);#if MACINTOSH	if (wType & WINDOID) bwindoid = this;	else bwindow=this;#elif WINDOWS	bwindow=this;#endif //MACINTOSH		tWindow=((WindowPeek)theWindow)->nextWindow;	while(tWindow)		{		nextWindow=GetRealWindow(tWindow->nextWindow);			vwin=(V_Window *)GetWRefCon((WindowPtr)tWindow);		// DAS-VWINDOWS-FLATTEN 9/2/93		if(vwin->Visible() && REALDOC(vwin->theDocument)==REALDOC(theDocument))			{			if(vwin->wType&WINDOID)				{				vwin->Behind(bwindoid);				if(bwindow==bwindoid)bwindow=vwin;				bwindoid=vwin;				}			else				{				vwin->Behind(bwindow);				bwindow=vwin;				}			}		tWindow=nextWindow;		}			endSelect:	/*force a complete rehiliting of all of the windows*/	tWindow=GetRealWindow((WindowPeek)FrontWindow());		vwin=TopWindow(theDocument);		if(vwin)		while(tWindow)			{			twin=(V_Window *)GetWRefCon((WindowPtr)tWindow);			// DAS-VWINDOWS-FLATTEN 9/2/93			if(REALDOC(twin->theDocument)==REALDOC(theDocument))				{				if(twin->wType&WINDOID)twin->Activate();				else if(twin==vwin)					{					vwin->Activate(); 					if(vwin->theDocument)VSendMessage(CLEAN_MENUS);					}				else twin->Deactivate(); 				}			else twin->Deactivate(); 			tWindow=GetRealWindow(tWindow->nextWindow);			}	else theDocument->Activate(0);	if(oldtwin&&oldtwin!=vwin)oldtwin->Deactivate();#elif WINDOWS	// jca 20APR94 we should send the message to the client, not the actual window.	if(theDocument && !(wType&(MODALWINDOW|WINDOID|ONTOP))) 		SendMessage(theDocument->GetMDIClient(),WM_MDIACTIVATE,(WPARAM)theWindow,0);//	SendMessage(theWindow,WM_MDIACTIVATE,TRUE,0);   // ELVIS!!!! jca 1MAR94 this was commented out.  It fixes a bug, though. 	BringWindowToTop(theWindow);	VSendMessage(CLEAN_MENUS);#endif //WINDOWS	offFlag=TRUE;	}	VGrafDataV_Window::GetMetaPort(Rect *r)	{	VGrafData data;	VCGrafPort 	theCPort,cdata;	VGrafPort 	theMPort;#if MACINTOSH	switch(bitType)		{		case MONO_QD:			theMPort=(GrafPtr)theWindow;			*r=theMPort->portRect;			data=&theMPort->portBits;			break;		case COLOR_QD:			theCPort=(CGrafPtr)theWindow;			*r=(*theCPort->portPixMap)->bounds;			data=(VGrafData)*theCPort->portPixMap;			break;		}#elif WINDOWS	GetRect(r);	data=VGetDC(theWindow);#endif //WINDOWS	return data;	}voidV_Window::ReleaseMetaPort(VGrafData data)	{#if WINDOWS	VReleaseDC(theWindow,data);#endif //WINDOWS	}voidV_Window::Cleanup()	{	Rect r ;	GetRect(&r);#if MACINTOSH	SetWPort();	InvalRect(&r);#endif //MACINTOSH	}#if (!VPLAYER)voidV_Window::SetPrint() /* added DAS 9/26/90 */	{	long i,length;	V_Pane **thePane;	V_Print *vprint;		if(!theDocument)return;	vprint=theDocument->GetVPrint();	vprint->PageSetup();	}V_Print *V_Window::GetVPrint() 	{	V_Print *vprint;	if(!theDocument)return NULL;	vprint=theDocument->GetVPrint();	return vprint;	}#endif //!VPLAYERintV_Window::DoEvent(long code,long modifiers)	{	V_Pane *thePane;	int i,length,result=FALSE; // DAS 9/6/93	result = (DieWindowEvent == code) ? TRUE : FALSE;	if(result)		Delete();	else		{		if(!icon)        	{			VSetPort(theWindow,0L);			if(code==PRINT_WINDOW)code=PRINT_DRAW;			if(panes)				{				length=panes->ALength();				for(i=0;i<length;i++)					{					panes->Get(i,&thePane);					if(result = thePane->GetAction(code,modifiers))break;                    }				}			}        }	return result;	}#if MACINTOSH/*Everything from this point on is not needed under MSWindows*/void V_Window::DrawGrow()	{	Rect gRect;	VGrafPort theWindow=this->theWindow;		VSetPort(theWindow,0L);	gRect=theWindow->portRect;	gRect.left=gRect.right-15;	gRect.top=gRect.bottom-15;	ClipRect(&gRect);	DrawGrowIcon(theWindow);	ClipRect(&theWindow->portRect);	}void V_Window::Update(){VGrafPort		savePort;VGrafDevice 	saveDevice;ControlHandle control;VGrafPort theWindow=this->theWindow;if(icon)	{	BeginUpdate(theWindow);	EndUpdate(theWindow);	return;	}VGetPort(&savePort,&saveDevice);VSetPort(theWindow,0L);offFlag=TRUE;BeginUpdate(theWindow);DrawPanes();EndUpdate(theWindow);if(grow)DrawGrow();VSetPort(savePort,saveDevice);}/*------------------------------------------------------------------------------ * void V_Window::DrawPanes(void) * * Redraws all of the panes. *------------------------------------------------------------------------------*/void V_Window::DrawPanes(void){long length,i;V_Pane **thePanes;VSetPort(theWindow,0L);ClipRect(&theWindow->portRect);if(panes)	{	length=panes->ALength();	thePanes=(V_Pane **)panes->Use();	for(i=0;i<length;i++)		thePanes[i]->Draw();	panes->Unuse();	}}/*------------------------------------------------------------------------------ * void V_Window::Dispatch(int code,Point myPt,long modifier) * * Handles mouseDown events in the window.  If this is a window action (drag, * resize,...) it is handled here, otherwise, it is passed to the Action method. *------------------------------------------------------------------------------*/void V_Window::Dispatch(int code,Point myPt,long modifier){Rect        tempRect,OldRect;long		mResult;Point		tPt;int 		xSize,ySize;long 		i,length;V_Pane 		**thePane;int			sizeWarn;VGrafPort theWindow=this->theWindow;VSetPort(theWindow,0L);switch(code)	{	case inDrag:/*iconify and deiconify window		*/		if(modifier & V_OPTION)			{			if(icon)				{				xSize=wSize.h;				ySize=wSize.v;				}			else				{				wSize.h=theWindow->portRect.right-theWindow->portRect.left;				wSize.v=theWindow->portRect.bottom-theWindow->portRect.top;				xSize=wSize.h;				ySize=0;				}			icon=!icon;			SizeWindow(theWindow, xSize, ySize, TRUE);			offFlag=TRUE;			}		else			{			Drag(myPt);			offFlag=TRUE;			}		break;	case inGrow:		Grow(myPt);		break; 	case inGoAway:		if (TrackGoAway(theWindow,myPt))			Delete();		break;	case inZoomIn:	case inZoomOut:		tPt=myPt;		GlobalToLocal(&tPt);#if MACINTOSH		if (TrackBox(theWindow, myPt, code) == TRUE)			{  			if(icon)				{				xSize=wSize.h;				ySize=wSize.v;				icon=!icon;				SizeWindow(theWindow, xSize, ySize, TRUE);				offFlag=TRUE;				}			else				{				RgnHandle gatherRgn;				RgnHandle windowRgn;								// use smarter zoom window (that knows about multiple monitors)				// ABD this should work better. 17MAR94				if (wType & WINDOID)					ZoomWindow(theWindow, code, FALSE);				else					SmartZoomWindow(theWindow, code);			// ABD WILLIAMS MERGE10 9/9/93				offFlag=TRUE;				sizeWarn=((theWindow->portRect.bottom-theWindow->portRect.top)<warnSize.v)||						 ((theWindow->portRect.right-theWindow->portRect.left)<warnSize.h);			 				Resize(sizeWarn);				if(grow)DrawGrow();				} 			}#endif // MACINTOSH		break; 	}}/*------------------------------------------------------------------------------ * void V_Window::Drag(Point myPt,long modifier) * * Handles Mousedown events with appropriate modifiers * Point myPt; the location of the Mousedown event * int modifier; the value of the modifiers sent *------------------------------------------------------------------------------*/void V_Window::Drag(Point startPt){GrafPort	grayPort;VGrafPort		savePort;VGrafDevice 	saveDevice;Rect		portRect,boundsRect;VGrafPort		wPort, curPort;RgnHandle	dragRgn, saveRgn, grayRgn;Point		windowPt;V_Window 	*twin;WindowPeek	fwin=(WindowPeek)FrontWindow();fwin = GetRealWindow(fwin);if(!dragable)return;twin=(V_Window*)GetWRefCon((WindowPtr)fwin);if(!ActiveWindow((WindowPeek)theWindow))Select();// DAS-VWINDOWS-FLATTEN 9/2/93if(REALDOC(twin->theDocument)!=REALDOC(theDocument))return;/*don't drag if we are switching documents*/if(!VButton())return;boundsRect=screenBits.bounds;VGetPort(&savePort,&saveDevice);windowPt.h=theWindow->portRect.left;windowPt.v=theWindow->portRect.top;VSetPort(theWindow,0L);LocalToGlobal(&windowPt);saveRgn=NewRgn();grayRgn=GetGrayRgn();/*Get WMgrPort, and set the clipRgn to whole desktop*/GetWMgrPort(&wPort);SetPort(wPort);if(saveRgn)GetClip(saveRgn);SetClip(grayRgn);if(!(wType&MODALWINDOW))	{	if(wType&WINDOID)		{#ifdef __powerc		ClipAbove(theWindow);#else		ClipAbove(theWindow);#endif //__powerc		}	else		{		twin=TopWindow(theDocument);		if(twin)	#ifdef __powerc			ClipAbove(twin->theWindow);	#else			ClipAbove(twin->theWindow);	#endif //__powerc		}	}/*make a copy of the WMgrPort for us to work with*/OpenPort(&grayPort);grayPort.portRect=wPort->portRect;grayPort.portBits=wPort->portBits;CopyRgn(wPort->visRgn,grayPort.visRgn);CopyRgn(wPort->clipRgn,grayPort.clipRgn);SetPort(&grayPort);/*Drag Region is the gray region of the window to drag*/if(dragRgn = NewRgn())	{	long newPt;		/*Make dragRgn a copy of the window's strucRgn */	CopyRgn(((WindowPeek)theWindow)->strucRgn,dragRgn);		/*Drag the grayRgn around then dispose of it*/	newPt=DragGrayRgn(dragRgn,startPt,&boundsRect,&boundsRect,noConstraint,NULL);	DisposeRgn(dragRgn);		if((newPt & 0xFFFF)!=0x8000)		{		int hGlobal=newPt&0xFFFF;		int vGlobal=newPt>>16;				MoveWindow(theWindow,windowPt.h+hGlobal,windowPt.v+vGlobal,FALSE);		}	}ClosePort(&grayPort);SetPort(wPort);if(saveRgn)SetClip(saveRgn);DisposeRgn(saveRgn);VSetPort(savePort,saveDevice);Cleanup(); // DAS-VWINDOWS-FIX 9/13/93}/*------------------------------------------------------------------------------ * void V_Window::MouseDown(Point myPt,long modifier) * * Handles Mousedown events with appropriate modifiers * Point myPt; the location of the Mousedown event * int modifier; the value of the modifiers sent *------------------------------------------------------------------------------*/void V_Window::MouseDown(Point myPt,long modifier){long i=-1,length;V_Pane **thePane;VGrafPort theWindow=this->theWindow;int result;if(icon)return;VSetPort(theWindow,0L);SetOrigin(0,0);GlobalToLocal(&myPt);	if(panes)	{	length=panes->ALength();	thePane=(V_Pane **)panes->Use();	for(i=length-1;i>=0;i--)		{		if(result=thePane[i]->MouseClick(myPt,modifier))			{			if(1==result)				savePane=thePane[i];			break;			}		}	panes->Unuse();	}if(i==-1)	{	LocalToGlobal(&myPt);	Drag(myPt);	}}/*------------------------------------------------------------------------------ * void V_Window::MouseUp(Point myPt,long modifier) * * Handles Mouseup events with appropriate modifiers * Point myPt; the location of the Mousedown event * int modifier; the value of the modifiers sent *------------------------------------------------------------------------------*/void V_Window::MouseUp(Point myPt,long modifier){long i,length;VGrafPort theWindow=this->theWindow;if(icon)return;VSetPort(theWindow,0L);GlobalToLocal(&myPt);if(savePane)savePane->MouseUnclick(myPt,modifier);lastPane=savePane;savePane=0;}/*------------------------------------------------------------------------------ * void V_Window::KeyAction(char key,long modifier) * * Handles KeyPress events with appropriate modifiers * char key; the key value pressed * int modifier; the value of the modifiers sent *------------------------------------------------------------------------------*/int V_Window::KeyAction(char key,long modifier){long i,length;V_Pane **thePane;Rect bounds;int width;VGrafPort theWindow=this->theWindow;int rval=FALSE;if(icon)return FALSE;VSetPort(theWindow,0L);if(activeText)	/* MJU - 6/20/90 if there is editable text edit it */	{ activeText->Edit(key,modifier); return TRUE; }if(panes)	{		length=panes->ALength();	thePane=(V_Pane **)panes->Use();	for(i=0;i<length;i++)		if(thePane[i]->KeyAction(key,modifier))			{			rval=TRUE;			break;			}	panes->Unuse();	}return rval;}/*------------------------------------------------------------------------------ * void V_Window::TrackWindow(Point myPt,long modifier) * * Handles Mouse tracking when there are no other events happening. * Point myPt; 	the location of the mouse * int modifier;the value of the modifiers sent *------------------------------------------------------------------------------*/void V_Window::TrackWindow(Point myPt,long modifier){long i,length;V_Pane **thePane;int pnum=-1;VGrafPort theWindow=this->theWindow;if(icon)return;VSetPort(theWindow,0L);GlobalToLocal(&myPt);if(activeText)	/* MJU - 6/20/90 if there is editable activeText idle the cursor */	activeText->Idle();/*if the mouse is down (no matter where) track here*/if(((modifier&buttonDown)) && savePane)	savePane->TrackCursor(myPt,modifier);else if(VPtInRect(myPt,&theWindow->portRect))/*are we in this window?*/	{	if(!panes)		{		VSetCursor(vCursorArrow);		return;		}	if((length=panes->ALength())==0)return;	thePane=(V_Pane **)panes->Use();	for(i=length-1;i>=0;i--)		if(VPtInRect(myPt,&thePane[i]->paneRect))			{			pnum=i;			if(lastPane && lastPane!=thePane[pnum])				lastPane->TrackCursor(myPt,modifier);			thePane[pnum]->TrackCursor(myPt,modifier);			lastPane=thePane[pnum];				i=-1;			}		/*lastPane gives the V_Pane an opportunity to cleanup after itself*/		if(lastPane && pnum==-1)		{		lastPane->TrackCursor(myPt,modifier);		VSetCursor(vCursorArrow);		lastPane=0;		}	panes->Unuse();	}else 	{	if(lastPane)		lastPane->TrackCursor(myPt,modifier);	lastPane=0;#if VR	VWIMessage(""); //DAS 10/15/93#endif //VR	VSetCursor(vCursorArrow);	}}/*------------------------------------------------------------------------------ * void V_Window::SetWPort() *  * Sets the port of the window so that all drawing occurs here. *------------------------------------------------------------------------------*/void V_Window::SetWPort(){VGrafPort theWindow=this->theWindow;VSetPort(theWindow,0L);}/*------------------------------------------------------------------------------ * void V_Window::Paint(RGBColor *color) *  * Paint the entire window the specified color. *------------------------------------------------------------------------------*/void V_Window::Paint(RGBColor *color){RGBColor bColor;VGrafPort theWindow=this->theWindow;SetWPort();ClipRect(&theWindow->portRect);VSetPattern(vPatBlack);VForeColor(color);VPaintRect(&theWindow->portRect);bColor.red=bColor.green=bColor.blue=0;VForeColor(&bColor);}/*------------------------------------------------------------------------------ * WindowPeek GetRealWindow(WindowPeek pwin); * Finds the real window if this isn't it * V_Window *BottomWindoid(V_Document *theDocument) * Find the bottom windoid in the document (if any). * V_Window *TopWindow(V_Document *theDocument) * Find the top window for this document (if any). *------------------------------------------------------------------------------*/WindowPeek GetRealWindow(WindowPeek pwin)	{	V_Window *vwin;// DAS-VWINDOW-BUGFIX 8/25/93	while(pwin && 			(pwin->windowKind < userKind || 			 !pwin->visible || 			 0==GetWRefCon((WindowPtr)pwin) ||			 (((V_Window *)GetWRefCon((WindowPtr)pwin))->wType&ONTOP)))		pwin=pwin->nextWindow;	return pwin;	}V_Window *BottomWindoid(V_Document *theDocument)	{	V_Window *vwin,*lastWin=0;	WindowPeek pwin;		theDocument=REALDOC(theDocument);// DAS-VWINDOWS-FLATTEN 9/2/93	pwin=(WindowPeek)FrontWindow();	pwin=GetRealWindow(pwin);	if(!theDocument)/*then choose the top document*/		{		if(pwin)theDocument=((V_Window *)GetWRefCon((WindowPtr)pwin))->theDocument;		theDocument=REALDOC(theDocument);// DAS-VWINDOWS-FLATTEN 9/2/93		}	if(pwin)		{		vwin=(V_Window *)GetWRefCon((WindowPtr)pwin);/*the top one*/		// DAS-VWINDOWS-FLATTEN 9/2/93		while(pwin && REALDOC(vwin->theDocument)!=REALDOC(theDocument))			{			pwin=GetRealWindow(pwin->nextWindow);			if(pwin)vwin=(V_Window *)GetWRefCon((WindowPtr)pwin);			}		while(pwin)			{			// DAS-VWINDOWS-FLATTEN 9/2/93			if(vwin->Visible() && (vwin->wType&WINDOID) &&			REALDOC(vwin->theDocument)==REALDOC(theDocument))lastWin=vwin;			if(REALDOC(vwin->theDocument)!=REALDOC(theDocument))pwin=0;			else				{				pwin=GetRealWindow(pwin->nextWindow);				}			if(pwin)vwin=(V_Window *)GetWRefCon((WindowPtr)pwin);			}		return lastWin;		}	else return 0;	}/*------------------------------------------------------------------------------ * DAS-VWI  * V_Window *OnTopWindow(void) * This routine returns the bottom-most ONTOP window so that other windows may know * who they are supposed to go under. *------------------------------------------------------------------------------*/V_Window *OnTopWindow(void){WindowPeek pwin;V_Window *vwin,*bvwin=0;pwin=(WindowPeek)FrontWindow();while(pwin)	{	vwin=(V_Window *)GetWRefCon((WindowPtr)pwin);/* the top window*/	if((long)vwin<2) // DAS-VWINDOWS-FIX 9/22/93 this is for printer windows		{		pwin=pwin->nextWindow;		bvwin=0;		}	else if(!(vwin->wType&ONTOP))pwin=0;     /* is this NOT an on top window? */	else 		{							  /* yes it is, save this window and keep on truckin'*/		pwin=pwin->nextWindow;		bvwin=vwin;		}	}return bvwin;}/*------------------------------------------------------------------------------ * void V_Window::Behind(V_Window *) *  * Put this window behind the specified window. *------------------------------------------------------------------------------*/voidV_Window::Behind(V_Window *frontWindow)	{	WindowPeek tW;	RgnHandle updateRgn;		VSetPort(theWindow,0L);	tW=(WindowPeek)theWindow;	CopyRgn(theWindow->visRgn,updateRgn=NewRgn());	OffsetRgn(updateRgn,(*(tW->contRgn))->rgnBBox.left,(*(tW->contRgn))->rgnBBox.top);	DiffRgn(tW->strucRgn,updateRgn,updateRgn);	if(frontWindow)		{		if (theWindow != frontWindow->theWindow)			SendBehind(theWindow,frontWindow->theWindow);		}	else 		{		// DAS-VWI check for the ONTOP window		V_Window *twin=OnTopWindow();			if(twin && twin!=this)			SendBehind(theWindow,twin->theWindow);		else			BringToFront(theWindow);		}#ifdef __powerc	CalcVisBehind(theWindow,updateRgn);	PaintOne(theWindow,updateRgn);#else	CalcVisBehind(theWindow,updateRgn);	PaintOne(theWindow,updateRgn);#endif //__powerc	DisposeRgn(updateRgn);	}/*------------------------------------------------------------------------------ * void V_Window::SendEvent(int) *  * Send an event to yourself to be executed in the event loop. *------------------------------------------------------------------------------*/void V_Window::SendEvent(long message) { VSendMessage(message); }/*------------------------------------------------------------------------------ * void V_Window::SetOffScreen() *  * Reset the size of the offscreen V_Offscreen. *------------------------------------------------------------------------------*/voidV_Window::SetOffScreen(int h,int v)	{	Rect wBounds;	Rect bounds;	Point p;	VGrafPort theWindow=this->theWindow;		VSetPort(theWindow,0L);	SetOrigin(0,0);	p.h=p.v=0;	LocalToGlobal(&p);	SetOrigin(p.h,p.v);	bounds=theWindow->portRect;	if(offscreen)offscreen->dOffscreen();	offscreen=new(V_Offscreen);	if(offscreen->cOffscreen(&bounds,-1,NULL,NULL)) 		{		delete(offscreen);		offscreen=0;		}	else		{		offscreen->SetRefCon((long)this);		}//	if(offscreen==0)VSetPort(theWindow,0L); ??   DAS/gjr	VSetPort(theWindow,0L);	SetOrigin(h,v);	offFlag=FALSE;	}// { DAS-VWIN 9/17/93 had to rename because of a conflict w/ VDisplayvoid V_Window::SetMetaWin(int h,int v, Rect *r){V_Window *aWin=0;if(offscreen)aWin=(V_Window *)offscreen->GetRefCon();if(offscreen==0||offFlag||aWin!=this)SetOffScreen(h,v);                                                                                                                                                          (h,v);if(offscreen)	{	offscreen->SetMetaPort();#if MACINTOSH	currentscreen = offscreen;#endif //MACINTOSH	offscreen->SetClip(r);	}else	{	SetWPort();	}SetOrigin(h,v);if (offscreen)	offscreen->SetCurrent();}void V_Window::UnsetMetaWin(){if(offscreen)	offscreen->UnsetMetaPort();currentscreen=0;}// } DAS-VWIN 9/17/93void V_Window::MetaCopy(Rect *r){V_Window *aWin;if(offscreen)	{	Rect winLoc;	#if MACINTOSH	VSetPort(theWindow, NULL);#endif //MACINTOSH	aWin=(V_Window *)offscreen->GetRefCon();	if(aWin==this) offscreen->MetaTo(this,r,r);	}}/*------------------------------------------------------------------------------ * void V_Window::SetPrint(void) * Allows the user to set the page up for printing. *------------------------------------------------------------------------------*/WindowPeek MyFrontWindow()	{	V_Window *vwin;	WindowPeek win;	vwin=TopWindow(NULL);	win = (vwin) ? (WindowPeek)vwin->theWindow : NULL;	return win;	}int ActiveWindow(WindowPeek fwin)	{	WindowPeek tWindow=(WindowPeek)GetRealWindow((WindowPeek)FrontWindow());	V_Window *vWindow;		if(tWindow==0)return FALSE;/*there is no front window*/	if(fwin->windowKind < userKind)return FALSE;/*ignore the DA's*/	if(fwin==tWindow)return TRUE;	vWindow=(V_Window *)(tWindow->refCon);	if(!vWindow)return FALSE;	if(vWindow->wType&MODALWINDOW)return FALSE;/*the front window is a dialog box!*/	if(fwin->hilited)return TRUE;	else return FALSE;	}#endif //MACINTOSH