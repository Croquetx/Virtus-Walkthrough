/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				 *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Platform: 	MACINTOSH 	X *				WINDOWS		 * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VButton.h"#include "VWindow.h"#include "VSound.h"#include "VGUtil.h"#include "VGraphic.h"#include "VItem.h"#include <string.h>#include "CVDefs.h"			// MERGE-GOURAUD-PRO-4#if MACINTOSH#include "VGestalt.h"#include <QDOffscreen.h>#endif //MACINTOSH// { DAS-VBUTTON 9/26/93#define LARGE_BUTTON 23#define SMALL_BUTTON 18#define BAR_BUTTON 4// } DAS-VBUTTON 9/26/93#if MACINTOSH            // jca 2 Oct 93  {RGBColor offColor[] = { {0xB800,0xB800,0xB800}, //base color						{0xF800,0xF800,0xF800}, //top frame						{0x7800,0x7800,0x7800}, //right frame						{0x7800,0x7800,0x7800}, //bottom frame						{0xF800,0xF800,0xF800}, //left frame						{0x0000,0x0000,0x0000}, //surrounding frame                        {0x0000,0x0000,0x0000}};//button textRGBColor onColor[]  = {	{0x9800,0x9800,0x9800},						{0x5800,0x5800,0x5800},						{0xF800,0xF800,0xF800},						{0xF800,0xF800,0xF800},						{0x5800,0x5800,0x5800},                        {0x0000,0x0000,0x0000},						{0x0000,0x0000,0x0000}};#elif WINDOWSRGBColor offColor[] = { {0xC000,0xC000,0xC000}, //	BaseColor						{0xFF00,0xFF00,0xFF00}, //	TopFrame						{0x8000,0x8000,0x8000}, //	RightFrame						{0x8000,0x8000,0x8000}, //	BottomFrame						{0xFF00,0xFF00,0xFF00}, //	LeftFrame						{0x0000,0x0000,0x0000}, //	OuterFrame                        {0x0000,0x0000,0x0000}};//	ButtonTextColorRGBColor onColor[]  = {	{0xB000,0xB000,0xB000}, //	BaseColor						{0x8000,0x8000,0x8000}, //	TopColor						{0xB000,0xB000,0xB000}, //	RightColor						{0xB000,0xB000,0xB000}, //	BottomFrame						{0x8000,0x8000,0x8000}, //	LeftFrame						{0x0000,0x0000,0x0000}, //	OuterFrame						{0x0000,0x0000,0x0000}};//	ButtonTextColor#endif              // jca 2 Oct 93 }int colorButton = TRUE;#define TOGGLE -1000//#define btnNotFound -1 DAS-VBUTTON 8/13/93 moved to VButton.h#define heirBorder 3void V_BItem::cBItem(unsigned char icn)  // DAS-VBUTTON 8/22/93 unsigned char	{	icon=icn;	location.top=location.left=location.bottom=location.right=0;	state=OFFSTATE;	heirButton=NULL;	}#define AVColor(c0,c1,c2) {c0.red=((long)c1.red+c2.red)>>1;c0.green=((long)c1.green+c2.green)>>1;c0.blue=((long)c1.blue+c2.blue)>>1;}void V_BItem::dBItem() { delete(this); }void V_BItem::CDraw(void)	{	Rect r,txtR;	RGBColor col,fcol,bcol;	RGBColor *colorArray;	int tall=location.bottom-location.top>10;	int start,middle,h,v,width,height;#if MACINTOSH	CCTabHandle	theCntlCTab;		theCntlCTab = (CCTabHandle)GetResource('cctb', 0);	// DAS-VWINDOWS-FIX 9/17/93 fixed color buttons in System 6.	if(gIsSystemSeven)		{		bcol=(**theCntlCTab).ctTable[13].rgb;		fcol=(**theCntlCTab).ctTable[14].rgb;		}	else		{		VSetColor(bcol,0xFFFF,0xFFFF,0x4000);		fcol.red=fcol.green=fcol.blue=0;		}#elif WINDOWS	VSetColor(fcol,0xFFFF,0xFFFF,0x4000);	bcol.red=fcol.red>>1;	bcol.green=fcol.green>>1;	bcol.blue=fcol.blue>>1;#endif	if(state==OFFSTATE)colorArray=offColor;	else colorArray=onColor;	r=location;	if(icon>2) // DAS-VBUTTON 8/13/93 this is to create blank buttons		{			if(tall)TallColorButton(&r,colorArray);		else ShortColorButton(&r,colorArray);		width=vButtonFontSize;			if(tall)			{			width=r.left+((r.right-1-r.left-width)>>1);			height=(r.bottom+r.top-11)>>1;			}		else 			{			width=r.left+((r.right-1-r.left-width)>>1);			height=(r.bottom+r.top-8)>>1;			}		switch(state)			{			case OFFSTATE:				col=vBlack;				h = width;				v = height;				break;			case ONSTATE:				VSetColor(col,0xFFFF,0xFFFF,0x4000);				if(tall&&colorButton) 					{ // DAS-VR-3D Buttons 8/14/93					h = width+1; 					v = height+1; 					} 				else { h = width; v = height; }				break;			case LOCKSTATE:				VSetColor(col,0xFFFF,0x4000,0x4000);				if(tall&&colorButton)					{ // DAS-VR-3D Buttons 8/14/93					h = width+1; 					v = height+1; 					} 				else { h = width; v = height; }				break;			}		VForeColor(&col);		txtR.left = h;#if MACINTOSH		VTextMode(vSrcOr); //BILBIL - 8/3/93		if(colorButton && icon>=150)//DAS-DRAW NEW BUTTONS			{			txtR.left = h;			txtR.bottom = v;			txtR.top = v-vButtonFontSize;			VForeColor(&bcol);			VDrawChar(icon+1,&txtR);			}			// MERGE-GOURAUD-PRO-6 added some hacks to center the icons better		txtR.left = h + (((16 - VCharWidth(icon)) >> 1) < 0 ? 0 : ((16 - VCharWidth(icon)) >> 1));		// MERGE-GOURAUD-PRO-6		txtR.bottom = v+1;	// MERGE-GOURAUD-PRO-6		txtR.top = (v-vButtonFontSize) + 1;	// MERGE-GOURAUD-PRO-6		VForeColor(&fcol);		if(icon!=' ' && icon>2)VDrawChar(icon,&txtR);#elif WINDOWS		txtR.bottom = v+vButtonFontSize-3;		txtR.top = v-3;		VTextMode(vSrcXor);                 // the diamond stealth card gets confused if the buttons are done in XOR		if(icon!=' ' && icon>2)VDrawChar(icon,&txtR);		VTextMode(vSrcOr);#endif //WINDOWS		if(tall){start=4;middle=r.bottom-6;}		else {start=3;middle=r.bottom-5;}		if(heirButton)			{			VMoveTo(r.right-start,middle);	VLineTo(r.right-start,middle);	start++;			VMoveTo(r.right-start,middle-1);	VLineTo(r.right-start,middle+1);	start++;			VMoveTo(r.right-start,middle-2);	VLineTo(r.right-start,middle+2);	start++;			}		changed=FALSE;		}	else // DAS-VBUTTON 8/13/93 this is to create blank buttons		{		ShortColorButton(&r,offColor); // MERGE-GOURAUD-PRO-2 DAS-VBUTTON 8/21/93		}	}void V_BItem::MDraw(void)	{	Rect r,txtR;	int start,middle,tall=location.bottom-location.top>10;	int width,height;		r=location;	if(icon>2) // DAS-VBUTTON 8/13/93 this is to create blank buttons		{		MonoButton(&r,state);		width=vButtonFontSize;		if(tall)			{			width=r.left+((r.right-1-r.left-width)>>1);			height=(r.bottom+r.top-11)>>1;			}		else 			{			width=r.left+((r.right-1-r.left-width)>>1);			height=(r.bottom+r.top-8)>>1;			}		txtR.left = width + (((16 - VCharWidth(icon)) >> 1) < 0 ? 0 : ((16 - VCharWidth(icon)) >> 1));		// MERGE-GOURAUD-PRO-12#if MACINTOSH		txtR.bottom = height+1;		// MERGE-GOURAUD-PRO-12		txtR.top = height-vButtonFontSize;// DAS-VWINDOWS-FIX 9/11/93		VTextMode(vSrcXor);		VDrawChar(icon,&txtR);		VTextMode(vSrcOr); #elif WINDOWS		txtR.bottom = height+vButtonFontSize-3;		txtR.top = height-3;		    VTextMode(vSrcXor);		VDrawChar(icon,&txtR);		VTextMode(vSrcOr);#endif //WINDOWS	//	VDrawChar(icon,&txtR); DAS-XYZZY 8/13/93 this was drawn twice for some reason.		}	else // DAS-VBUTTON 8/13/93 this is to create blank buttons		{		VEraseRect(&r);		VFrameRect(&r);		}	if(state==OFFSTATE)VSetPattern(vPatBlack);	else VSetPattern(vPatWhite);	if(tall){start=4;middle=r.bottom-6;}	else {start=3;middle=r.bottom-5;}	if(heirButton)/*this draws the little arrow*/		{		VMoveTo(r.right-start,middle);	VLineTo(r.right-start,middle);	start++;		VMoveTo(r.right-start,middle-1);	VLineTo(r.right-start,middle+1);	start++;		VMoveTo(r.right-start,middle-2);	VLineTo(r.right-start,middle+2);	start++;		}	VSetPattern(vPatBlack);	changed=FALSE;	}void V_BItem::NextHeir()	{	heirButton->SetState(heirIndex,OFFSTATE);	heirIndex++;	if(heirIndex>=heirButton->ALength())heirIndex=0;	SetChar(heirButton->GetChar(heirIndex));	heirButton->SetState(heirIndex,ONSTATE);	}int V_BItem::DoHeir(int tl,Point pt)	{	VGrafPort 	savePort;	VGrafDevice 	saveDevice;	V_Offscreen	*mainScrn,*scrn;	V_Offscreen *BG;	V_BItem 	*bItem;	Rect 		r,rloc,rpad,scrnRect,myRect;	Point 		loc,newloc;	long 		timeCount;	int			snum;	/*screen number (see V_Array* screen)*/	int 		initnum,bnum,lastbnum,length,i;	int			depth;	RGBColor	*col;		snum = TRUE;		initnum=btnNotFound;	lastbnum=btnNotFound;	timeCount=VGetTime();		VGetPort(&savePort,&saveDevice);	heirButton->SetButtonSize(tl);	heirButton->CalcSize(&r, NULL);	length=heirButton->ALength();/*how many buttons in the heirarchical V_Button?*/	heirButton->GetRect(&r); /*how big is it?*/		loc.h=location.left;	loc.v=location.top;	LocalToGlobal(&loc);		/*where is this button in screen coordinates?*/	/*calc size of the base of the heirarchical button pad*/	r.right+=7;				r.bottom+=6;	rloc.top=r.top+loc.v-3;	rloc.left=r.left+loc.h-3;	rloc.bottom=r.bottom+loc.v-3;	rloc.right=r.right+loc.h-3;	myRect = rloc;#if WINDOWS	{	V_Console *hC;	Rect avoidButton;	Point	ptLoc;	// jca, to match Smith's changes	ptLoc.h = location.left;	ptLoc.v = location.top+1;     // jca 1MAR94 there's an off by one error.	avoidButton.left = avoidButton.top = 0;	avoidButton.bottom = heirButton->bHeight;	avoidButton.right = heirButton->bWidth;	VOffsetRect(&avoidButton, loc.h, loc.v);	hC = new(V_Console);    hC->cPane(0);	hC->SetButton(heirButton);	hC->SetPosition(NULL,topRightConsole+1);	for(initnum=0;initnum<length;initnum++)		if(heirButton->GetState(initnum))break;	if (initnum == length)	// jca 2MAR94 evil things may happen if this is unset		{		heirButton->SetState(0, ONSTATE);  // make sure something is set        initnum = 0;		}	hC->PopUp(ptLoc,heirBorder,&avoidButton);    // do the popup	for(i=0;i<length;i++)      //  make sure something is set. if not, then set it.		if(heirButton->GetState(i))break;	if (i == length)	// jca 2MAR94 evil things may happen if this is unset		heirButton->SetState(initnum, ONSTATE);  // make sure something is set	hC->SetButton(NULL);	// jca 26Jan94 let's not delete the buttons.  (heirButton still points to the deleted console, though.  But it's always been this way.  I'm confused.	heirButton->thePane = NULL; // jca 26JAN94.  There should be a better way to do this...	hC->dPane();	for(bnum=0;bnum<length;bnum++)		if(heirButton->GetState(bnum))break;	if(bnum!=length)    	{		SetChar(heirButton->GetChar(bnum));		SetHelp(heirButton->GetHelp(bnum));		heirIndex=bnum;		}	return(heirIndex!=initnum?TRUE:FALSE);    }#elif MACINTOSH	LocalToGlobal(&pt);	screen->Get(0,&mainScrn);	scrn=FindScreen(pt);	if (scrn == NULL)           // ABD stopgap bug fix    	scrn = mainScrn;		// ABD stopgap bug fix	scrn->GetRect(&scrnRect);	FitRect(&rloc,&scrnRect);	loc.h=rloc.left+3;	loc.v=rloc.top+3;	depth=scrn->GetDepth();		/*save the background*/	BG=new(V_Offscreen);	col = NULL;	if(BG->cOffscreen(&rloc,-1,col,NULL))		{		delete(BG);		VPlaySound(beepSound);		return FALSE;		}	if(snum)VHideCursor();	BG->ToMeta(scrn,&rloc,&r);	if(snum)VShowCursor();		/*draw the buttons*/	scrn->SetMetaPort();	SetOrigin(-loc.h,-loc.v);	rpad.top=r.top-2;	rpad.left=r.left-2;	rpad.bottom=r.bottom-4;	rpad.right=r.right-5;	/*first draw the base of the h pad*/	if(snum)VHideCursor();	if(depth>2&&colorButton)TallColorButton(&rpad,offColor);	else 		{		MonoButton(&rpad,OFFSTATE);		VMoveTo(rpad.left,rpad.bottom);		VLineTo(rpad.right,rpad.bottom);		VLineTo(rpad.right,rpad.top);		}	/*the display the buttons*/	heirButton->HDisplay(depth);	if(snum)VShowCursor();	scrn->UnsetMetaPort();	/*while the button is down and we are still on a button*/	for(i=0;i<length;i++)		{		if(heirButton->GetState(i))			{			initnum=i;			break;			}		}	do	{		mainScrn->SetMetaPort();		SetOrigin(0,0);		VGetMouse(&newloc);		mainScrn->UnsetMetaPort();		scrn->SetMetaPort();		SetOrigin(-loc.h,-loc.v);		newloc.v-=loc.v;		newloc.h-=loc.h;		bnum=heirButton->FindButton(newloc);		if(bnum!=btnNotFound)heirButton->Get(bnum,&bItem);		if(bnum!=lastbnum)			{			for(i=0;i<length;i++)				{				if(i==bnum)heirButton->SetState(i,ONSTATE);				else heirButton->SetState(i,OFFSTATE);				}			VPlaySound(clickSound);			if(snum)VHideCursor();			heirButton->DisplayChanged(depth);			if(snum)VShowCursor();			timeCount=VGetTime();			}		else if(bnum!=btnNotFound)		if(bItem->heirButton && (VGetTime()-timeCount)>VGetDblTime())			{			if(bItem->DoHeir(tl,newloc))			SetOrigin(-loc.h,-loc.v);			for(i=0;i<length;i++)				{				if(i==bnum)heirButton->SetState(i,ONSTATE);				else heirButton->SetState(i,OFFSTATE);				}			}		lastbnum=bnum;		scrn->UnsetMetaPort();		}while(VButton() /*&& VPtInRect(newloc,&rpad)*/);			scrn->SetMetaPort();	SetOrigin(0,0);	/*remove the heirarchical button pad and the V_Offscreen objects*/	if(snum)VHideCursor();	BG->MetaTo(scrn,&r,&rloc);	if(snum)VShowCursor();	BG->dOffscreen();	scrn->UnsetMetaPort();	scrn->SetMetaPort();	SetOrigin(0,0);	scrn->UnsetMetaPort();	mainScrn->SetMetaPort();	SetOrigin(0,0);	mainScrn->UnsetMetaPort();	screen->Unuse();	VSetPort(savePort,saveDevice);	/*set the heirarchical button to be the same as the	 one chosen from the hpad, (if any).*/	if(bnum!= btnNotFound)		{		SetChar(heirButton->GetChar(bnum));		SetHelp(heirButton->GetHelp(bnum));		heirIndex=bnum;		return(TRUE);		}	else		{		for(i=0;i<length;i++)			{			if(i==initnum)heirButton->SetState(i,ONSTATE);			else heirButton->SetState(i,OFFSTATE);			}		return(FALSE);		}#endif //MACINTOSH	}void BHelp::Track(Point p, long m, int i) { 	// jca 24 Oct 93 {#if !VR			// no button help in VRVSetCursor(vCursorQuestion); #endif // !VR}	// jca 24 Oct 93 }void BHelp::cBHelp(V_BItem *item,int ht)	{	height=ht;	V_Pane::cPane(FALSE);	button=item;	}void BHelp::Display(int s,int x,int y)	{#if !VR			// no button help in VR	// jca 24 Oct 93 {#if !WINDOWS  //PRO-94.10.21 DAS	Rect loc;	int bHeight;	Rect r;	strPtr str=button->help;		r=dataRect;	r.left+=28;	VForeColor(&vWhite);	VPaintRect(&r);	VForeColor(&vBlack);	VFrameRect(&r);	VSetFont(vAppFont,vAppFontSize,vNormal);  //PRO-94.10.21 DAS	r.top+=4;	r.left+=4;	r.right-=4;	r.bottom-=4;	TextBox(str, strlen((char *)str), &r, teJustLeft);  //PRO-94.10.21 DAS	loc=button->location; // save the current location of the button	if(height)bHeight=LARGE_BUTTON;// DAS-VBUTTON 9/26/93	else bHeight=SMALL_BUTTON;// DAS-VBUTTON 9/26/93		button->location.right-=button->location.left;	button->location.left=0;	button->location.bottom-=button->location.top;	button->location.top=0;		VSetFont(vButtonFont,vButtonFontSize,vNormal);    VTextMode(vSrcXor);	if(depth>=4)button->CDraw();	else button->MDraw();    VTextMode(vSrcOr);	button->location=loc;#endif // !WINDOWS  //PRO-94.10.21 DAS#endif // !VR 		// jca 24 Oct 93 }	}voidBHelp::CalcSize(Rect *r,Point *p,int type,int warning)	{ VSetRect(r,0,0,250,136); }int V_BItem::DoHelp(int tl,Point pt)	{#if !VR			// no button help in VR	// jca 24 Oct 93 {	Rect r;	BHelp *bHelp;		LocalToGlobal(&pt);	bHelp=new(BHelp);	bHelp->cBHelp(this,tl);	bHelp->PopUp(pt,TRUE, NULL);	bHelp->dPane();#endif // !VR 		// jca 24 Oct 93 }	return FALSE;	}	void V_BItem::SetHelp(strPtr string) { help=string; }strPtr V_BItem::GetHelp() { return help; }void V_BItem::SetState(int stte)	{	if(state!=stte)		{ state=stte; changed=TRUE; }	}int V_BItem::GetState() { return(state); }void V_BItem::SetHeir(V_Button * hButton)	{	int i,loc=0;	heirButton=hButton;	for(i=0; i<heirButton->ALength();i++)		if(heirButton->GetState(i))loc=i;			SetChar(heirButton->GetChar(loc));	SetHelp(heirButton->GetHelp(loc));	changed=TRUE;	}void V_BItem::SetChar(unsigned char icn) // DAS-VBUTTON 8/22/93 unsigned char	{	icon=icn; 	changed=TRUE;	}unsigned char V_BItem::GetChar() { return(icon); }// DAS-VBUTTON 8/22/93 unsigned charvoid V_BItem::MoveButton(Rect *loc)	{	location=*loc; 	changed=TRUE;	}void V_BItem::OnState()	{	if(state>0)		state=-state;	}void V_BItem::OffState()	{	if(state<0)		state=-state;	}	int V_BItem::PtInButton(Point p)	{	return 	location.top<=p.v && 			location.bottom>=p.v && 			location.left <=p.h &&			location.right >= p.h;	}void V_Button::cButton(int col)	{	columns=col;	cArray(0,sizeof(V_BItem *),16);	SetButtonSize(TRUE);/*button size is tall to start*/	}	void V_Button::dButton()	{	int i;	V_BItem * bItem;	for(i=0;i<length;i++)		{		Get(i,&bItem);		bItem->dBItem();		}	dArray();	}/* CalcSize(Rect *pRect) has been significantly rewritten. The intent was to  * continue to have the existing V_Windows applications work as normal, yet have * enhanced functionality for buttons, in particular, allow them to have a  * variable width and have horizontal and vertical seperation bars. This has been * accomplished. * Note that CalcSize plays two very different roles depending upon how it is used. * First, in the old normal case, the buttons determine the rectangle size of the  * V_Console using the columns and the bWidth and bHeight variables. * The second case is the complete opposite, where the V_Console determines the * width of the buttons contained in the V_Button array. This means that when * using the variable width buttons YOU MUST OVERRIDE THE CALCSIZE METHOD FOR * V_CONSOLE! Otherwise, you will create an infinite recursion. You will of course, * figure this out immediatly. * Notes: * - Currently, we can not have variable width heirarchical buttons. * // DAS-VBUTTON 8/22/93 * - CalcSize will ALWAYS calculate the bottom location of the pane no matter what. * // jca 27JAN94 * WalkThrough's hierarchical buttons are centered on a V_Console, but have a * border.  CalcSize must be able to handle an optional button offset on the * V_Console pad.  NOTE THAT offset IS NOT USED FOR THE SECOND CASE!!! ('cause I'm not * sure it's desirable or necessary) */voidV_Button::CalcSize(Rect *pRect, Point *offset)	{	V_BItem **bItem;	Rect tl;	int top,left,i;		if(!thePane && columns<=0)return; // if there is no pane, why bother?				location.top=location.left=location.right=location.bottom=0;	bItem = (V_BItem **)Use();	/* in the first case, *pRect is undefined and is being set here.*/	if(columns>0)		{		rows=length/columns;		if(length%columns)rows++;			for( i=0 ; i<length ; i++ )		// MERGE-GOURAUD-PRO-4 removed increment of bItem			{			left=i%columns;			top=i/columns;			tl.left=left*bWidth;			tl.top=top*bHeight;	        tl.right=tl.left+bWidth;			tl.bottom=tl.top+bHeight;			// jca 1MAR94 move these up before we do the offset, so the offset isn't added in to the location			if(location.right<tl.right)location.right=tl.right;			if(location.bottom<tl.bottom)location.bottom=tl.bottom;			if (offset)      // jca 27Jan94.  handle an offset to center the heir buttons.				VOffsetRect(&tl, offset->h, offset->v);							// ABD MERGE-GOURAUD-PRO-4 this is a horrible hack for the tumble buttons to be			// double wide.  Since whatever moron originally coded up this V_Button crap			// decided that all the buttons in a V_Console will be the same width, this			// is a majorly stupid hack but there's nothing else that can be done because			// all of this code sucks.  			// What our scheme is is that if we find a NULL button as the last button in			// a row, we make the other buttons in this row wide enough so that the NULL			// button is not seen.  Ugly.			if ((i % columns) == (columns-1))			{			int extra_space;			int k;							// this button is the last in a row -- is it a NULL button?				if (bItem[i]->icon == bNULL)				{										// it's a NULL button and the last in a row, so make the other buttons					// in this row wider										extra_space = (tl.right - tl.left) / (columns-1);										for( k=0 ; k<columns; k++ )					{					Rect r;												r = bItem[i-(columns-1)+k]->location;						r.right += extra_space;						r.left += (k * extra_space);						r.right += (k * extra_space);						(bItem[i-(columns-1)+k])->MoveButton(&r);					}										tl.left = tl.right = tl.top = tl.bottom = 0;				}			}			// MERGE-GOURAUD-PRO-4 ]]]			(bItem[i])->MoveButton(&tl);	// MERGE-GOURAUD-PRO-4 added subscript to bItem			}		*pRect=location;		}/* in the second case, *pRect is defined and sets the values of everything else */// jca 27JAN94 offset param is not handled here!!!! ELVIS	else 		{		int current=0,end,top=0, col, bAcross, width, bw, remain;		Rect br,pr;		unsigned char icon;				col= -columns;		pr=*pRect;		width=pr.right-pr.left;		location=pr;		location.bottom=location.top;		/* although we ignore bWidth here, we still use bHeight.		 * we need to move forward just col at a time.		 */		while(current<length)			{			// find the horizontal bar breaks 			end=current+col; // this is the default			if(end>length)end=length;			for(i=current;i<end;i++)				{				icon=bItem[i]->icon;				// are there any horizontal bars here?				if(icon==bVBAR)					{					end=i;					break;					}				}						bAcross=end-current;			/*let's just see if there might not be a better split*//* { DAS-VR 8/23/93 I turned this off only for VR			if(bAcross==col)				{				for(i=end;i<end+col && i<length;i++)					{					icon=bItem[i]->icon;					if(icon==bVBAR)						{						if(i!=end)// if we are already there, don't bother							{							end=(i+current)>>1;							bAcross=end-current;							}						break;						}					}				} } DAS-VR 8/23/93 */			if(bAcross)				{				bw=width/bAcross;				remain=width-(bAcross*bw);				br.right=0; 				br.top=top;				br.bottom=top+bHeight;				for(i=current;i<end;i++)					{					br.left=br.right;					br.right=br.left+bw;					if(bItem[i]->icon==bHBAR || i==end-1)// give the access to the vertical bar						{						br.right+=remain;						remain=0;						}					bItem[i]->MoveButton(&br);					// DAS-VBUTTON 8/21/93					if(location.bottom<br.bottom)location.bottom=br.bottom;					}				top+=bHeight;				current=end;				}			else				{				br.top=top;				br.bottom=br.top+BAR_BUTTON; // (bHeight>>2); // DAS-VBUTTON 9/26/93				top=br.bottom;				br.left=0;				br.right=width;				bItem[current]->MoveButton(&br);				// DAS-VBUTTON 8/21/93				if(location.bottom<br.bottom)location.bottom=br.bottom;				current++;				}			}		*pRect=location;		}	Unuse();	}void V_Button::AppendButton(unsigned char icn) // DAS-VBUTTON 8/22/93 unsigned char	{	V_BItem * bItem;		bItem=new(V_BItem);	bItem->cBItem(icn);	Append(&bItem);	}void V_Button::InsertButton(int item,unsigned char icn) // DAS-VBUTTON 8/22/93 unsigned char	{	V_BItem * bItem;	bItem=new(V_BItem);	bItem->cBItem(icn);	Insert(item,&bItem);	}int V_Button::Remove(long item)	{	V_BItem *bItem;	int ret, i;		Get(item,&bItem);	ret=V_Array::Remove(item);	if(ret==VARY_SUCCESS)		bItem->dBItem();	return ret;	}void V_Button::SetHeir(int item,V_Button * hButton)	{	V_BItem *bItem;	Get(item,&bItem);	bItem->SetHeir(hButton);	}	voidV_Button::Display(Rect *pr,int depth)	{	V_BItem **bItem;	int i;		VSetFont(vButtonFont,vButtonFontSize,vNormal);#if MACINTOSH	VTextMode(vSrcOr);#endif// { DAS-VBUTTON 8/17/93	bItem=(V_BItem**)Use();	if(depth>2&&colorButton)		for(i=0;i<length;i++,bItem++)			(*bItem)->CDraw();	else		for(i=0;i<length;i++,bItem++)			(*bItem)->MDraw();	Unuse();// } DAS-VBUTTON 8/15/93    VTextMode(vSrcOr);	VForeColor(&vBlack);	}void V_Button::HDisplay(int depth)	{	V_BItem **bItem;	int i;		VSetFont(vButtonFont,vButtonFontSize,vNormal);#if MACINTOSH	VTextMode(vSrcOr);#endif// { DAS-VBUTTON 8/17/93	bItem=(V_BItem**)Use();	if(depth>2&&colorButton)		for(i=0;i<length;i++,bItem++)			(*bItem)->CDraw();	else		for(i=0;i<length;i++)			(*bItem)->MDraw();	Unuse();// } DAS-VBUTTON 8/15/93    VTextMode(vSrcOr);	VForeColor(&vBlack);	}	void V_Button::DisplayChanged(int depth)	{	V_BItem *bItem;	int i,remain,wdth;	Point p;	Rect r;		VSetFont(vButtonFont,vButtonFontSize,vNormal);#if MACINTOSH    VTextMode(vSrcXor);#endif	if(depth>2 && colorButton)	for(i=0;i<length;i++)		{		Get(i,&bItem);	    if(bItem->changed)	    	bItem->CDraw();		}	else	for(i=0;i<length;i++)		{		Get(i,&bItem);	    if(bItem->changed)	    	bItem->MDraw();		}	VTextMode(vSrcOr);	VForeColor(&vBlack);	}void V_Button::SetState(int item,int state)	{	V_BItem *bItem;		Get(item,&bItem);	bItem->SetState(state);	}int V_Button::GetState(int item)	{	V_BItem *bItem;		Get(item,&bItem);	return(bItem->GetState());	}void V_Button::GetRect(Rect *pr)	{	*pr=location;	/*	pr->top=pr->left=0;	pr->bottom=rows*bHeight-1;	pr->right=columns*bWidth;	*/	}	int V_Button::FindButton(Point pt)	{	int item=btnNotFound,i;	V_BItem **bItem;		if(pt.v<0 || pt.h<0)return(btnNotFound);		bItem = (V_BItem **)Use();		for(i=0;i<length;i++, bItem++)		{		if((*bItem)->PtInButton(pt))			{			if((*bItem)->icon<3)item=btnNotFound;			else  item=i;			break;			}		}	Unuse();	return(item);	}void V_Button::GetButtonRect(int item,Rect *r)	{	V_BItem *bitem;		Get(item,&bitem);	*r=bitem->location;/*	r->left=(item%columns)*bWidth;	r->right=r->left+bWidth;	r->top=(item/columns)*bHeight;	r->bottom=r->top+bHeight;*/	}int V_Button::OnButton(int bNum)	{	Point pt;	if(VButton())		{		VGetMouse(&pt);		if(bNum==FindButton(pt))return(TRUE);		else return(FALSE);		}	else return(FALSE);	}static long timeCount=-1;voidV_Button::VMouseDown(int item,int olditem,long modifiers,int depth)	{	V_BItem *bItem;	Point pt;	int state;	timeCount = -1;	if (item == btnNotFound)		{ // invalid item; toss it away (jca 30 Apr 93)		return;        }#if MACINTOSH && !VR	// jca 24 Oct 93	if(modifiers&V_SHIFT)  /*is this a help button?*/		{		Get(item,&bItem);		pt.h=bItem->location.left;		pt.v=bItem->location.top;		if(bItem->help)			bItem->DoHelp(tall,pt);		}	else#endif		{		VPlaySound(clickSound);		state = GetState(item);		SetState(item,(state==OFFSTATE)?ONSTATE:OFFSTATE);	   	MouseDown(item,modifiers);		DisplayChanged(depth); 		}	}voidV_Button::VMouseTrack(int item,int olditem,int *inited, long modifiers,int depth)	{	V_BItem *bItem;	Point pt;	int state,hFlag=FALSE;	if(olditem!=item)    	{		VPlaySound(clickSound);#if MACINTOSH		if (olditem != btnNotFound)	SetState(olditem, OFFSTATE);		if (item != btnNotFound)	SetState(item, ONSTATE); // DAS-VWINDOWS-FIX 9/3/93 possible bus error#elif WINDOWS		if ((*inited) && (olditem != btnNotFound))	SetState(olditem, OFFSTATE);		if (item != btnNotFound)			{			int i;			*inited = TRUE;			for (i = 0; i < ALength(); i++)				SetState(i, OFFSTATE); 			SetState(item, ONSTATE); // DAS-VWINDOWS-FIX 9/3/93 possible bus error			}#endif		DisplayChanged(depth);        timeCount = -1;		}	if(item!=btnNotFound) // DAS-VBUTTON 8/21/93 I want a btnNotFound flag		{		Get(item,&bItem);		if(bItem->heirButton)			{			pt.h = bItem->location.left; // BILBIL - check this for windows!!!!!			pt.v = bItem->location.top;			if(timeCount==-1)timeCount=VGetTime();			if((VGetTime()-timeCount)>WAITTIME(500))				if(bItem->DoHeir(tall,pt))					{					DisplayChanged(depth);					MouseDown(item,modifiers);					hFlag=TRUE;	                }	        }		}    // DAS-VBUTTON 8/21/93 I need "a better MouseTrack" for VR    if(!hFlag)MouseTrack(item, olditem, modifiers);	}// < DAS-VBUTTON 8/13/93 I need the mouse up event for VR.voidV_Button::VMouseUp(int item,int olditem,long modifiers,int depth)	{	MouseUp(item,olditem,modifiers);	DisplayChanged(depth);	}voidV_Button::MouseUp(int item,int olditem,long modifiers)	{	}// > DAS-VBUTTON 8/13/93void V_Button::SetChar(int item,unsigned char icon) // DAS-VBUTTON 8/22/93 unsigned char	{	V_BItem *bItem;			Get(item,&bItem);	bItem->SetChar(icon);	}unsigned char V_Button::GetChar(int item)	{	V_BItem *bItem;			Get(item,&bItem);	return(bItem->GetChar());	}void V_Button::SetHelp(int item,strPtr help)	{	V_BItem *bItem;			Get(item,&bItem);	bItem->SetHelp(help);	}strPtr V_Button::GetHelp(int item)	{	V_BItem *bItem;			Get(item,&bItem);	return(bItem->GetHelp());	}void V_Button::SetButtonSize(int t)	{		Rect r;	if(tall!=t)		{		tall=t;			bWidth=25;		if(tall)bHeight=LARGE_BUTTON;// DAS-VBUTTON 9/26/93		else bHeight=SMALL_BUTTON;// DAS-VBUTTON 9/26/93		if(columns>0)r.top=r.left=r.bottom=r.right=0;		}	}// MERGE-GOURAUD [[[void V_Button::SetButtonWidth(int w)	{			bWidth=w;	}// MERGE-GOURAUD ]]]void V_Button::MouseDown(int item,long modifiers) 	{	}// DAS-VBUTTON 8/21/93voidV_Button::MouseTrack(int item,int olditem,long modifiers)	{	}int V_Button::Toggle(int item)	{	int i,st,inum=btnNotFound;		for(i=0;i<length;i++)		{		st=GetState(i);		if(st==ONSTATE)			{			inum=i;			SetState(inum,OFFSTATE);			break;			}		}	if(item>=0)SetState(item,ONSTATE);	VPlaySound(clickSound);	thePane->VDisplay(TOGGLE);	return FALSE;	}	void V_Console::cPane(int flag)	{	V_Pane::cPane(flag);	SetBorder(0);	SetFullHeight(FALSE);	SetPosition(NULL,positionConsole);	}// { DAS-VWINDOWS 10/23/93voidV_Console::dPane(void)	{    if(vButton)vButton->dButton();	V_Pane::dPane();	}// } DAS-VWINDOWS 10/23/93	void V_Console::Display(int scroll,int h,int v)	{	Rect r;		r = dataRect;	VPenMode(vPatCopy);	if(vButton)		{		if(popup&MODALWINDOW/*jca:MODALDIALOG*/)			TallColorButton(&r,offColor);		if(scroll==TOGGLE) vButton->DisplayChanged(depth);		else vButton->Display(&r,depth);		}    else		{		VSetPattern(vPatGray);		VFillRect(&r);		VMoveTo(dataRect.right,dataRect.top);		VLineTo(dataRect.right,dataRect.bottom);		}	}	void V_Console::CalcSize(Rect *r,Point *p, int flag,int sizeWarn)	{	Rect rButton,hR;	Point offset;  // jca 27JAN94	if(vButton)		{		if(popup&MODALWINDOW)offset.h=offset.v=heirBorder;   // jca 27JAN94		else offset.h=offset.v=0;		vButton->SetButtonSize(TRUE); //sizeWarn ? FALSE : TRUE);		if(vButton->columns<0)			rButton=dataRect;		vButton->CalcSize(&rButton, &offset);  // jca 27JAN94 allow heir buttons to be centered		}		if(NULL != hangPane)		{		hangPane->GetRect(&hR);		switch(corner)			{			case leftConsole:				r->top=rButton.top+hR.top;				r->left=rButton.left+hR.right;				r->right=rButton.right+hR.right;				r->bottom=rButton.bottom+hR.top;				break;			case topConsole:				r->top=rButton.top+hR.bottom;				r->left=rButton.left+hR.left;				r->right=rButton.right+hR.left;				r->bottom=rButton.bottom+hR.bottom;				break;			case rightConsole:				break;			case bottomConsole:				r->bottom=hR.top;				r->top=r->bottom - (rButton.bottom-rButton.top);				r->left=rButton.left+hR.left;				r->right=rButton.right+hR.left;				break;			}	// WHAT IS THIS????? this line taken out because it screws up MERGE-GOURAUD-PRO-6	// spacing of tool panes	r->bottom+=border+BUTTON_EXTRA;		}	else		{		switch(corner)			{			case positionConsole:				r->top=rButton.top+location.v;				r->left=rButton.left+location.h;				r->right=rButton.right+location.h;				r->bottom=rButton.bottom+location.v;				r->bottom+=border+BUTTON_EXTRA;				break;							case topLeftConsole:				/*we are there, do nothing*/				*r=rButton;				r->bottom+=border+BUTTON_EXTRA;				break;							case bottomLeftConsole:				r->right=rButton.right;				r->top=r->bottom-rButton.bottom;				break;							case bottomRightConsole:					r->top=r->bottom-rButton.bottom;				r->left=r->right-rButton.right;				break;							case topRightConsole:				r->left=r->right-rButton.right;				r->bottom=rButton.bottom+border+BUTTON_EXTRA;				break;			default:				if(flag==POPUP)					{					*r=rButton;					r->bottom+=(border+BUTTON_EXTRA);					r->bottom-=3;					r->right-=3;                    }            	break;				}			}	}voidV_Console::MouseDown(Point pt,long modifiers)	{	if(vButton)		{		item=vButton->FindButton(pt);		initItem=item;		vButton->VMouseDown(item,initItem,modifiers,depth);#if WINDOWS                                         		buttonSelect = FALSE; // jca 1MAR94#endif // WINDOWS		}	}voidV_Console::Track(Point p,long modifiers,int inside)	{	int newItem;#if MACINTOSH && !VR	// jca 24 Oct 93	if(modifiers&V_SHIFT)		{		if (!inside) return;		VSetCursor(vCursorQuestion);		}	else#endif		VSetCursor(vCursorArrow);	if(vButton&&(modifiers&buttonDown))		{		int init=FALSE;        // jca 1MAR94		newItem=vButton->FindButton(p);	// jca 1MAR94.  Apparently, this messes up the VWIstuff.  If there's	// a vwi, then we always want to track.	//	if(newItem!=btnNotFound)  // DAS-VBUTTON 8/21/93 need to always do this#if WINDOWS		// jca 1MAR94  why:  Under windows, the hierarchical button		// popups reset the state of the button that popped up the		// hierarchical buton popup.  We must not turn off any button		// until we have another to turn on (at least, for the first		// time)		// --and don't pass a class member as a parameter.		init = buttonSelect;#endif // WINDOWS		vButton->VMouseTrack(newItem,item,&init,modifiers,depth);		item = newItem;#if WINDOWS		buttonSelect = init;    // jca 1MAR94#endif // WINDOWS		}	}voidV_Console::MouseUp(Point pt,long modifiers)	{	if(vButton)		{		item=vButton->FindButton(pt);		vButton->VMouseUp(item,initItem,modifiers,depth); // DAS-VBUTTON 8/17/93 always need the mouseup#if WINDOWS		buttonSelect = FALSE; // jca 1MAR94#endif // WINDOWS		}	}void V_Console::SetButton(V_Button * vB)	{	vButton=vB;	if (vB)       // jca 26JAN94 check that vB exists...		vButton->thePane=this;   	}void V_Console::SetFullHeight(int tf) { fullHeight=tf; }void V_Console::SetBorder(int b) { border=b; }void V_Console::SetLocation(Point pt) { location=pt; }void V_Console::SetPosition(V_Pane *pane,int where)	{	hangPane = pane;	corner = where;	}voidV_Console::TrackHelp(Point pt,long modifier)// DAS-VWINDOWS 9/30/93	{	Rect r;	int item;		item=vButton->FindButton(pt);	if(item!=btnNotFound)		{		vButton->GetButtonRect(item,&r);		pt.v=r.top+3;		pt.h=r.right-3;		Bubble(pt,&r,vButton->GetHelp(item));		}	else Bubble(pt,&r, ""); // DAS-VWINDOWS-HELP 9/30/93	}void TallColorButton(Rect *pr,RGBColor colorArray[])	{	RGBColor col;	Rect r;		r=*pr;	r.left--;	r.top--;	VForeColor(&vBlack);	VFrameRect(&r);	VInsetRect(&r,2,2);	col=colorArray[BaseColor];   // jca 2 Oct 93	VForeColor(&col);	VPaintRect(&r);	col=colorArray[TopFrame];    // jca 2 Oct 93	VForeColor(&col);#if MACINTOSH	VMoveTo(r.left-1,r.top-1); VLineTo(r.right,r.top-1);	col=colorArray[RightFrame];  // jca 2 Oct 93	VForeColor(&col);	VMoveTo(r.right,r.top); VLineTo(r.right,r.bottom-1);	col=colorArray[BottomFrame];  // jca 2 Oct 93	VForeColor(&col);	VMoveTo(r.right,r.bottom); VLineTo(r.left-1,r.bottom);	col=colorArray[LeftFrame];    // jca 2 Oct 93	VForeColor(&col);	VMoveTo(r.left-1,r.bottom-1); VLineTo(r.left-1,r.top);#elif WINDOWS	VMoveTo(r.left-1,r.top-1); VLineTo(r.right+1,r.top-1);	col=colorArray[RightFrame];      // jca 2 Oct 93	VForeColor(&col);	VMoveTo(r.right,r.top); VLineTo(r.right,r.bottom);	col=colorArray[BottomFrame];      // jca 2 Oct 93	VForeColor(&col);	VMoveTo(r.right,r.bottom); VLineTo(r.left-2,r.bottom);	col=colorArray[LeftFrame];      // jca 2 Oct 93	VForeColor(&col);	VMoveTo(r.left-1,r.bottom-1); VLineTo(r.left-1,r.top-1);#endif //WINDOWS	}void ShortColorButton(Rect *pr,RGBColor colorArray[])	{	RGBColor col;	Rect r;		r=*pr;	r.left--;	r.top--;		VForeColor(&vBlack);	VFrameRect(&r);	r.left	+=1;	r.top	+=1;	r.bottom-=1;	r.right	-=1;	col=colorArray[BaseColor];		// jca 2 Oct 93	VForeColor(&col);	VPaintRect(&r);	}void MonoButton(Rect *pr,int hilite)	{	Rect r;		r=*pr;	r.left--;	r.top--;	VSetPattern(vPatBlack);	if(hilite==OFFSTATE)VEraseRect(&r);	else VPaintRect(&r);	VFrameRect(&r);	}// jca 2 Oct 93 {#if WINDOWS#if 0// we may want to do this, but perhaps not now.... jca 2 Oct 93// this would be called in the inits.#define WININI_COLORS_SECTION	"colors"#define BUTTON_BASE_COLOR 		"ButtonFace"#define BUTTON_SHADOW_COLOR 	"ButtonShadow"#define BUTTON_HILIGHT_COLOR 	"ButtonHilight"#define BUTTON_TEXT_COLOR 		"ButtonText"intInitButtonColors(void){	UShort 	r,g,b;	char	str[256];	int 	ret, err = noErr;    RGBColor base, text, hilight, shadow;	// Get the button face color	ret = GetProfileStr(WININI_COLORS_SECTION, BUTTON_BASE_COLOR, "", str, 256);    if (ret)    	// get the values, then save them		sscanf(def, "%d %d %d", &r, &g, &b);		base.red = r; 	base.green = g;	base.blue = b;		}    else	err = -1;	// Get the button shadow color	if (ret)	ret = GetProfileStr(WININI_COLORS_SECTION, BUTTON_SHADOW_COLOR, "", str, 256);    if (ret)    	// get the values, then save them		sscanf(def, "%d %d %d", &r, &g, &b);		shadow.red = r; 	shadow.green = g;	shadow.blue = b;		}    else	err = -1;    // Get the button hilight color	if (ret) 	ret = GetProfileStr(WININI_COLORS_SECTION, BUTTON_HILIGHT_COLOR, "", str, 256);    if (ret)    	// get the values, then save them		sscanf(def, "%d %d %d", &r, &g, &b);		hilight.red = r; 	hilight.green = g;	hilight.blue = b;		}    else	err = -1;	// Get the button text color	if (ret)	ret = GetProfileStr(WININI_COLORS_SECTION, BUTTON_TEXT_COLOR, "", str, 256);    if (ret)    	// get the values, then save them		sscanf(def, "%d %d %d", &r, &g, &b);		text.red = r; 	text.green = g;	text.blue = b;		}    else	err = -1;	if (!err)   // assign the values		{		offColor[BaseColor] = base;		offColor[TopFrame] = offColor[LeftFrame] = hilight;		offColor[RightFrame] = offColor[BottomFrame] = shadow;		offColor[ButtonTextColor] = text;		onColor[BaseColor] = shadow; // ??? base?		onColor[TopFrame] = onColor[LeftFrame] = shadow;		onColor[RightFrame] = onColor[BottomFrame] = onColor[BaseColor]; // perhaps it should be hilight?		onColor[ButtonTextColor] = text;		}    return(err);}#endif#endif // WINDOWS// jca 2 Oct 93 }