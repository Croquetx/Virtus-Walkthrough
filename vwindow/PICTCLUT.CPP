/*------------------------------------------------------------------------------ * *	Apple Macintosh Developer Technical Support * *	KnowsPICT * *	CLUTBuilder.c	-	C Source *    *	Copyright c 1989 Apple Computer, Inc. *	All rights reserved. * * * this file contains functions used to pull colors from a PICT.  You activate it by * calling CollectColors(PicHandle) with PicHandle set to a PICT that you have already * loaded into memory.  It will almost invariably return a (handle to a) color table * (that contains at least black and white) however the color table is not at all clean * in the current implementation.  It is probably ok if you run it through NewPalette. * If it runs across a direct pixmap it won't bomb but it won't add any colors to the * color table. * * WARNING: This code has been tested but it has not been tested thoroughly; * USE AT YOUR OWN RISK! *----------------------------------------------------------------------------- * Reworked by DAS 8/15/91 to be more ANSII consistent and more in line with * Virtus coding styles. *-----------------------------------------------------------------------------*/#include "VTYPES.H"#include "VDISPLAY.H"#include "VGRAPHIC.H"#include "PICTCLUT.h"OSErr	gColorError;	/* to report errors from bottlenecks. */CTabHandle gCTab;		/* to collect colors from bottlenecks. */	// ABD MERGE-Z1 -- renamed gColorTable to gCTab in this file onlyshort gNextCSpec;		/* next CSpec entry in color table */short foundDirect;		/* set to true if we uncover a direct pixmap */short maxPixDepth;      /* depth of deepest pixmap found *//* Add a color to the color table. */void AddRGBColor(RGBColor *rgb);void AddRGBColor(RGBColor *rgb){	long numSpecs,sizeInBytes;	int 	i,ctSize;	CTabPtr TablePtr;	RGBColor rgbx;		if (gColorError)		return;		TablePtr = (*gCTab);				// ABD MERGE-Z1 -- renamed gColorTable	ctSize = TablePtr -> ctSize;	for (i = 0; i <= ctSize; i++) {		rgbx = TablePtr->ctTable[i].rgb;	    if (rgbx.red==(*rgb).red &&	    	rgbx.green==(*rgb).green &&	    	rgbx.blue==(*rgb).blue) 	    	return;		/* if already there, done */	}	numSpecs = (long) (++(**gCTab).ctSize);	/* add a colorspec to table */		// ABD MERGE-Z1 -- renamed gColorTable	sizeInBytes = (numSpecs * sizeof(ColorSpec)) + sizeof(ColorTable);	SetHandleSize((Handle)gCTab, sizeInBytes);			// ABD MERGE-Z1 -- renamed gColorTable	if ((gColorError = MemError()) == noErr) {		(**gCTab).ctTable[numSpecs].rgb = *rgb;			// ABD MERGE-Z1 -- renamed gColorTable	    (**gCTab).ctTable[numSpecs].value = 0;			// ABD MERGE-Z1 -- renamed gColorTable	}}/* Add the contents of another color table to our color table.*/void AddColorTable(CTabHandle cTab);void AddColorTable(CTabHandle cTab){	short index,size;	RGBColor color;	size = (**cTab).ctSize;	for (index= 0; index <= size; index++) {		color = (**cTab).ctTable[index].rgb;		AddRGBColor(&color);	}}/* Add the foreground color of the current port to the color table. */void AddRGBForeColor(void);void AddRGBForeColor(void){	AddRGBColor(&((*(CGrafPtr)thePort).rgbFgColor));}/* Add the background color of the current port to the color table. */void AddRGBBackColor(void);void AddRGBBackColor(void){	AddRGBColor(&((*(CGrafPtr)thePort).rgbBkColor));}/* Add colors from a PixPat to a color table. */void AddPixPat(PixPatHandle pPat);void AddPixPat(PixPatHandle pPat){	switch ((**pPat).patType) {		case 0:		/* one-bit patterns are drawn in the foreground and background color. */		AddRGBForeColor();		AddRGBBackColor();		break;	case 1:		/* Type 1 PixPats have a color table. */		AddColorTable((**(**pPat).patMap).pmTable);		break;	}}/* Add colors from the pen PixPat to the color table. */void AddPenPixPat(void);void AddPenPixPat(void){	AddPixPat((*(CGrafPtr)thePort).pnPixPat);}/* Add colors from the fill PixPat to the color table. */void AddFillPixPat(void);void AddFillPixPat(void){	AddPixPat((*(CGrafPtr)thePort).fillPixPat);}/* Add colors because we are about to draw an object. */void AddVerb(GrafVerb verb);void AddVerb(GrafVerb verb){	switch (verb) {		case frame:	case paint: /* Framed and painted objects are drawn in the pen PixPat. */			AddPenPixPat();			break;	case erase: /* Erased objects are drawn in the background color. */			AddRGBBackColor();			break;	case fill:			/* Filled objects are drawn in the fill PixPat.  The fillPixPat is				a pattern used to record fill commands for pictures.  First, a				command to set the fillPixPat is recorded, then the fill command				is recorded. */			AddFillPixPat();	}}/* bottleneck routines follow . . . */pascal void ColorTextProc(short byteCount, Ptr textBuf, Point numer, Point denom);pascal void ColorTextProc(short byteCount, Ptr textBuf, Point numer, Point denom){	/* Text is drawn with the foreground and background colors.*/	AddRGBForeColor();	AddRGBBackColor();}pascal void ColorLineProc(Point newPt);pascal void ColorLineProc(Point newPt){ /* Lines are drawn with the pen PixPat. */	AddPenPixPat();}pascal void ColorRectProc(GrafVerb verb, Rect *r);pascal void ColorRectProc(GrafVerb verb, Rect *r){	AddVerb(verb);}pascal void ColorRRectProc(GrafVerb verb, Rect *r, short ovalWidth, short ovalHeight);pascal void ColorRRectProc(GrafVerb verb, Rect *r, short ovalWidth, short ovalHeight){	AddVerb(verb);}pascal void ColorOvalProc(GrafVerb verb, Rect *r);pascal void ColorOvalProc(GrafVerb verb, Rect *r){	AddVerb(verb);}pascal void ColorArcProc(GrafVerb verb, Rect *r, short startAngle, short arcAngle);pascal void ColorArcProc(GrafVerb verb, Rect *r, short startAngle, short arcAngle){	AddVerb(verb);}pascal void ColorPolyProc(GrafVerb verb, PolyHandle poly);pascal void ColorPolyProc(GrafVerb verb, PolyHandle poly){	AddVerb(verb);}pascal void ColorRgnProc(GrafVerb verb, RgnHandle rgn);pascal void ColorRgnProc(GrafVerb verb, RgnHandle rgn){	AddVerb(verb);}pascal void ColorBitsProc(BitMap *bitPtr, Rect *srcRect, Rect *dstRect, short mode, RgnHandle maskRgn);pascal void ColorBitsProc(BitMap *bitPtr, Rect *srcRect, Rect *dstRect, short mode, RgnHandle maskRgn){	PixMapPtr aPixMap;	short tempRB;	/* Get the PixMap that we are about to draw.  SrcBits might be a BitMap, or		one of two different kinds of PixMap pointers.  */	tempRB = (*bitPtr).rowBytes;			/* local copy of rowBytes */	if (tempRB < 0) {						/* high bit set? */		if ((tempRB<<1) < 0)				/* next to high bit set? */			aPixMap = (** ( (PixMapHandle *)bitPtr ));	/* ptr to PixMap handle */		else			aPixMap = (PixMapPtr) bitPtr;		/* pointer to a PixMap */		if ((*aPixMap).pixelSize > maxPixDepth)	/* deepest pixmap so far? */			maxPixDepth = (*aPixMap).pixelSize;		if ((*aPixMap).pixelType==16) {			foundDirect = true;			return;								/* direct pixmap?  eek! */		}		AddColorTable((*aPixMap).pmTable);		/* it has its own color table. */	}	else {		/* It's just a BitMap; it will use the background and foreground colors. */		AddRGBBackColor();		AddRGBForeColor();	}}RGBColor whiteRGB = { 0xFFFF,0xFFFF,0xFFFF };RGBColor blackRGB = { 0,0,0 };// In case we don't have the universal headers... BILBIL - 11/16/93#ifndef NewQDTextProc	#define NewQDTextProc(userRoutine) (char*)userRoutine#endif#ifndef NewQDLineProc	#define NewQDLineProc(userRoutine) (char*)userRoutine#endif#ifndef NewQDRectProc	#define NewQDRectProc(userRoutine) (char*)userRoutine#endif#ifndef NewQDRRectProc	#define NewQDRRectProc(userRoutine) (char*)userRoutine#endif#ifndef NewQDOvalProc	#define NewQDOvalProc(userRoutine) (char*)userRoutine#endif#ifndef NewQDArcProc	#define NewQDArcProc(userRoutine) (char*)userRoutine#endif#ifndef NewQDPolyProc	#define NewQDPolyProc(userRoutine) (char*)userRoutine#endif#ifndef NewQDRgnProc	#define NewQDRgnProc(userRoutine) (char*)userRoutine#endif#ifndef NewQDBitsProc	#define NewQDBitsProc(userRoutine) (char*)userRoutine#endifCTabHandle CollectColors(PicHandle fromPicture, short *depthPtr, short *directFlagPtr);CTabHandle CollectColors(PicHandle fromPicture, short *depthPtr, short *directFlagPtr){	extern V_Offscreen *nilPort;	CTabHandle colors;	CQDProcs bottlenecks;	/* Set the bottlenecks.  These bottlenecks will figure out what colors are in		a picture, but won't draw anything.	Note: the bottlenecks are installed in thePort, which must be a color port.	*/	SetStdCProcs(&bottlenecks);// BILBIL - no procDPtr [[[	bottlenecks.textProc = NewQDTextProc(ColorTextProc);	bottlenecks.lineProc = NewQDLineProc(ColorLineProc);	bottlenecks.rectProc = NewQDRectProc(ColorRectProc);	bottlenecks.rRectProc = NewQDRRectProc(ColorRRectProc);	bottlenecks.ovalProc = NewQDOvalProc(ColorOvalProc);	bottlenecks.arcProc = NewQDArcProc(ColorArcProc);	bottlenecks.polyProc = NewQDPolyProc(ColorPolyProc);	bottlenecks.rgnProc = NewQDRgnProc(ColorRgnProc);	bottlenecks.bitsProc = NewQDBitsProc(ColorBitsProc);// BILBIL - no procDPtr ]]]	/* Create a color table containing black and white. */	foundDirect = false;	/* haven't found a direct pixmap yet */	maxPixDepth = 1;		/* assume we will find a bitmap */	colors = (CTabHandle) NewHandle( sizeof(ColorTable) + sizeof(ColorSpec) );	if (colors) {		(**colors).ctSize = 1; /* 2 entries */		(**colors).ctFlags = 0x8000;		(**colors).ctSeed = GetCTSeed();		(**colors).ctTable[0].value=0;		(**colors).ctTable[0].rgb = whiteRGB; /*first entry is white*/		(**colors).ctTable[1].value=0;		(**colors).ctTable[1].rgb = blackRGB; /*second entry is black*/		/* Now play back the picture to get the colors.  The dstRect doesn't			matter since our bottlenecks will never actually draw. We use global			variables (gColorError and gCTab) to communicate with the			// ABD MERGE-Z1 -- renamed gColorTable			bottlenecks. */		nilPort->SetMetaPort();		(*thePort).grafProcs = (QDProcs *) &bottlenecks;		gColorError = noErr;		gCTab = colors;			// ABD MERGE-Z1 -- renamed gColorTable		DrawPicture(fromPicture, &((**fromPicture).picFrame));		(*thePort).grafProcs = 0L;		*depthPtr = maxPixDepth;		*directFlagPtr = foundDirect;		nilPort->UnsetMetaPort();		/* Fail if error occurred while within the color bottlenecks. */		if (gColorError != noErr) {			DisposHandle((Handle)colors);			colors = 0L;		}	}	return colors;}