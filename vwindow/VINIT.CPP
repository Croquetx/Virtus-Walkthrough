/*------------------------------------------------------------------------------ * Virtus  * V_Windows * Version 2.0 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				 *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File: VInit.c * Notes:  * History:  *		Created		7/20/92		DAS * 		Modified	7/25/92		DAS		Added MS Windows support. *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VMain.h"#include "VGestalt.h"#include "VDocumnt.h"#include "VWindow.h"#include "VPane.h"#include "VGraphic.h"#include "VGUtil.h"#include "VSound.h"#include "VMemUtil.h"#include "VMenu.h"#include "VArray.h"#include "VFile.h"#include "VDialog.h"#include "VAbout.h"#include "Clip.h"#include "VAsm.h"#include "VTextDef.h"#define PROFILE FALSE/* profiling */#if PROFILE#include <stdio.h>#include "profile.h"#include "VMath.h"#endifint gAppleEvents=0;int gQuickTime=0;#if MACINTOSH#include <GestaltEqu.h>#include <Balloons.h>#include <Movies.h>#define gestaltQuickTime 'qtim'#define GestaltTrap 0xA1AD#define QD32Trap 	0xAB03#define UnImplTrap 	0xA89Fint gGestaltAvailable;int gFSSpecCalls;int gIsBalloon;int gHaveAUX;int gAliasMgrPresent;int gComponentMgrPresent = FALSE;		// ABD TEXTURE-MERGE 9/14/93int gIsSystemSeven;void SetUpHighLevelEvents(void);/*------------------------------------------------------------------------------ * int TrapAvailable(long tnum) * Returns the availability of a trap. *------------------------------------------------------------------------------*/int TrapAvailable(long tnum);int TrapAvailable(long tnum)	{ return(NGetTrapAddress(tnum,ToolTrap)!=NGetTrapAddress(UnImplTrap,ToolTrap)); }		// MERGE-Z1#elif WINDOWS/*this routine is used to determine if any files should be open*/void CountAppFiles(long *message,long *count);void CountAppFiles(long *message,long *count){*message=*count=0;}/*------------------------------------------------------------------------------ *                                       *  FUNCTION   : InitializeApplication ()  *                                     *  PURPOSE    : Sets up the class data structures and does a one-time       *       initialization of the app by registering the window classes *                                      *  RETURNS    : TRUE  - If RegisterClass() was successful for both classes. *       FALSE - otherwise.                     *                               * This function was taken from the Windows demo program sources for MULTIPAD.        *------------------------------------------------------------------------------*/#define IDDOCUMENT  ID(1)#define IDWINDOW	ID(4)#define CBWNDEXTRA	8BOOL FAR PASCAL InitializeApplication(HANDLE hInst);BOOL FAR PASCALInitializeApplication(HANDLE hInst){WNDCLASS    wc;wc.style         = CS_DBLCLKS;wc.lpfnWndProc   = DocumentWndProc;wc.cbClsExtra    = 0;wc.cbWndExtra    = sizeof(V_Document *); //The document object will go herewc.hInstance     = hInst;wc.hIcon         = LoadIcon(hInst,IDDOCUMENT);wc.hCursor       = NULL;//LoadCursor(NULL,IDC_ARROW);wc.hbrBackground = COLOR_APPWORKSPACE+1;wc.lpszMenuName  = NULL;wc.lpszClassName = documentClassName;if (!RegisterClass (&wc) )    return FALSE;	/* Register the MDI child class which corresponds to the	V_Window class*/wc.style		 = CS_BYTEALIGNCLIENT|CS_DBLCLKS;wc.lpfnWndProc   = WndProc;wc.hIcon         = LoadIcon(hInst,IDWINDOW);wc.lpszMenuName  = NULL;wc.cbWndExtra    = sizeof(V_Window *);wc.lpszClassName = windowClassName;if (!RegisterClass(&wc))    return FALSE;	/* Register the MDI child class which corresponds to the	V_Window class*/wc.style		 = CS_DBLCLKS|CS_SAVEBITS;wc.lpfnWndProc   = WindoidProc;wc.hIcon         = LoadIcon(hInst,IDWINDOW);wc.lpszMenuName  = NULL;wc.cbWndExtra    = sizeof(V_Window *);wc.lpszClassName = windoidClassName;/* fill in non-variant fields of PRINTDLG struct. *//*	memset((char *) &printDialog, 0, sizeof(PRINTDLG));	pd.lStructSize    = sizeof(PRINTDLG);    pd.hDevMode       = NULL;	pd.hDevNames      = NULL;	pd.Flags          = PD_RETURNDC | PD_NOSELECTION | PD_NOPAGENUMS;	pd.nCopies        = 1;*/   if (!RegisterClass(&wc))    return FALSE;	/* Register the window child class which corresponds to the	V_Pane class*/wc.style		 = CS_DBLCLKS;wc.lpfnWndProc   = PaneWndProc;wc.hIcon         = NULL;wc.lpszMenuName  = NULL;wc.cbWndExtra    = sizeof(V_Pane *);wc.lpszClassName = paneClassName;if (!RegisterClass(&wc))    return FALSE;return TRUE;}#endif // MACINTOSHextern int frontApp;int FrontApp(void) { return frontApp; }/*------------------------------------------------------------------------------ * void Init(void) * Initialize the Macintosh drivers. Determine what Mac environment we are * working in. Create theSuper V_Array .   *------------------------------------------------------------------------------*/long availableMem; // DAS-VWI 10/2/93#if MACINTOSH#define STACKSIZEINCREASE 32768#define FREE_BYTES_PER_MASTER 6400void IncreaseStackSize(long NumBytes);void IncreaseStackSize(long NumBytes){	char *p1, *p2;			p2 = GetApplLimit();	p2 -= NumBytes;	SetApplLimit(p2);	#if DEBUG	p1 = GetApplLimit();	if(p1 != p2) DEBUGGER();	#endif}void Init(void);void Init(void)	{	Rect r;	OSErr err;		//increase stack size since our program is fairly recursive	IncreaseStackSize(STACKSIZEINCREASE);	MaxApplZone();	{	long i;	for(i=FreeMem()/FREE_BYTES_PER_MASTER;i>0;i--)MoreMasters();	}	InitGraf(&thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(0L);	appResFile=CurResFile();	//DAS-VWI 10/2/93	availableMem=FreeMem(); // this is as good a measure of available memory as any.	InitArrays(); //DAS-VARRAY 10/2/93#if PROFILE	/* profiling */	InitProfile(1000,500);	_profile = FALSE;	freopen("Profile", "w", stdout);/**/#endif	if(gGestaltAvailable=TrapAvailable(GestaltTrap))		{		long rval;				/*----Apple Events?----------------------------------------*/		if(err=Gestalt(gestaltAppleEventsAttr,&rval))			gAppleEvents=FALSE;/* no Gestalt ==> no Apple Events   */		else			{			gAppleEvents=(rval & 0x01);			if(gAppleEvents)SetUpHighLevelEvents();			}		/*----32 bit QuickDraw?------------------------------------*/		if(err=Gestalt(gestaltQuickdrawVersion,&rval))			{			AlertMessage(TXT_GESTALTERR);			ExitToShell();			}		colorQD=rval>gestalt8BitQD;#if VWT		if(!colorQD)			{			if(MainDepth()>1)/*if the depth is 1 or 0, then who cares*/				AlertMessage(TXT_QD32FORCOLOR);			}#elif VR		if (rval<=gestalt8BitQD)			{			AlertMessage(TXT_QD32TORUN);			VExitToShell();			}#endif //VR		/*----System Seven?-----------------------------------------*/		if(err=Gestalt(gestaltSystemVersion,&rval))			gIsSystemSeven=FALSE;/* no Gestalt ==> not System Seven   */		else			{			gIsSystemSeven=((rval & 0x0000FFFF) >= 0x0700);			}		/*----Balloon Help?-------------------------------------------*/		if(err=Gestalt(gestaltHelpMgrAttr,&rval))			gIsBalloon=FALSE;		else gIsBalloon=(rval & 0x0001);		/*----File System Attribute?----------------------------------*/		if(err=Gestalt(gestaltFSAttr,&rval))			gFSSpecCalls=FALSE;		else gFSSpecCalls=(rval & (0x0001<<gestaltHasFSSpecCalls))?TRUE:FALSE;		/*----AUX Version (if any)?-----------------------------------*/		if(err=Gestalt(gestaltAUXVersion,&rval))			gHaveAUX=0;		else gHaveAUX=0x0FFFF&rval;		/*----Alias Manager?-----------------------------------*/		if(err=Gestalt(gestaltAliasMgrAttr,&rval))			gAliasMgrPresent=0;		else gAliasMgrPresent=rval;	// ABD MERGE-TEXTURE 9/14/93 [[[		/*----Component Manager? ABD-------------------------------------*/		if(err=Gestalt(gestaltComponentMgr,&rval))	// ABD			gComponentMgrPresent=0;		else gComponentMgrPresent=rval;	// ABD MERGE-TEXTURE 9/14/93 ]]]		/*----QuickTime?----------------------------------------------*/		if(err=Gestalt(gestaltQuickTime,&rval))			gQuickTime=FALSE;#ifdef __powerc		else if(err=Gestalt(gestaltQuickTimeFeatures, &rval))			gQuickTime=FALSE;		else if((rval & 1) == 0)			gQuickTime=FALSE;#endif //__powerc		else{			if(err=EnterMovies()) gQuickTime=FALSE;			else gQuickTime=TRUE; 			}		}	else		{		SysEnvRec theWorld;		err=SysEnvirons(2,&theWorld);		colorQD=theWorld.hasColorQD;#if VWT		if(colorQD)			{			if(!TrapAvailable(QD32Trap))				{				VPlaySound(beepSound);				colorQD=FALSE;				if(MainDepth()>1)/*if the depth is 1 or 0, then who cares*/					AlertMessage(TXT_QD32FORCOLOR);				}			}#elif VR		if (colorQD)			{			AlertMessage(TXT_QD32TORUN);			VExitToShell();			}#endif //VR		gAppleEvents=0;		gFSSpecCalls=0;		gIsBalloon=0;		gQuickTime=0;		gHaveAUX=0;		gAliasMgrPresent=0;		}	InitAsm();			// Setup up faster asm routines (gjr081993)   // jca 3 Oct 93	InitCurs();	InitClipper();	//BuildScreens();		// jca 17 aug 93.  We'd rather do this sometwhere else.  See windows version.	/*force us to use QuickDraw*/		{		EventRecord	myEvent;		RgnHandle mouseRgn;				mouseRgn = NULL;		WaitNextEvent(0, &myEvent,0,mouseRgn);		if(myEvent.modifiers&shiftKey &&			myEvent.modifiers&cmdKey &&			myEvent.modifiers&optionKey)				UseQD(TRUE);		}#elif WINDOWSvoid Init(	HANDLE hInst,			HANDLE hPrevInstance,			LPSTR lpszCmdLine,			int nCmdShow);void Init(	HANDLE hInst,			HANDLE hPrevInstance,			LPSTR lpszCmdLine,			int nCmdShow)	{	Rect r;	OSErr err;		if (!hPrevInstance)		{		if (!InitializeApplication (hInst))			return ;		}		InitGraphics(hInst);	availableMem=TotalMem(); // this is as good a measure of available memory as any.  // jca 10 Nov 93  Smith's change#endif		r.top=r.left=0;	r.bottom=r.right=32;	nilPort=new(V_Offscreen);	if(nilPort->cOffscreen(&r,MainDepth(),NULL,NULL))		{		delete(nilPort);		AlertMessage(TXT_NOMEM);		VExitToShell();		}	offscreen=new(V_Offscreen);	if(offscreen->cOffscreen(&r,MainDepth(),NULL,NULL))		{		delete(offscreen);		AlertMessage(TXT_NOMEM);		VExitToShell();		}	SoundInit(); 		#if MACINTOSH && VRML_ANCHOR // ABD PRO25 AUG95	// this is required to be able to cut-n-paste between apps --	// make sure previously cut/copied info is moved to TE scrap when we start up	// so we can paste it into some dialog or whatnot	TEFromScrap();	#endif	#if MACINTOSH	ReserveMemoryBlock(50000L);// jca 1FEB94 no longer necessary with SmartHeap 2.0// #elif WINDOWS//	MemPoolSetFreestoreThreshold(MEM_DEFAULT_POOL, 1048576L); // just for laughs.  jca#endif	BuildScreens();/*get all of the screens into an array of V_Offscreens*/				theSuper=new(V_Array);	theSuper->cArray(0,sizeof(V_Document *),4);		visibleMMgr=new(MenuArray);	visibleMMgr->cArray(0,sizeof(V_Array *),4);		StartUp();	if(!stub)/*no stub document has been created*/		MakeStub();	#if WINDOWS	//Give the user a message if the font were not found	if (! FontsLoaded())		{		char	eStr[256], mStr[128];		GetModuleFileName(hInst, mStr, sizeof(mStr));		sprintf(eStr, TXT_FONTERR, FONT_FILE_NAME);		AlertMessage(eStr);		VExitToShell();  // jca 5 Dec 93. this used to be Exit(), which caused a crash.  We may lose resources this way, though...		}#endif		#ifndef __powerc#if MACINTOSH	if(!gAppleEvents)/* set up the old fashioned way */		{		V_File *file;		short message,count;		CountAppFiles(&message,&count);		if(count)			{			while(count-- > 0)				{				file=new(V_File);				file->sFile();				if(message==0)NewDocument(file,LOADSTART);				else if(message==1)NewDocument(file,PRINT);				else {EndIt();  Exit();}				}			}#elif WINDOWS		{		V_File *file;			if (strlen(lpszCmdLine))			{			char *nextFile;			int 	i, count = 0;			for (i=0; i<strlen(lpszCmdLine);i++)				if (lpszCmdLine[i] == ' ')	count++;			nextFile=strtok(lpszCmdLine, " ");			while (count-- >= 0)				{				char	e1,x,e2;				int		fnameLen, exe=FALSE;				// the executable is left on the command line.  Don't load it.				fnameLen = strlen(nextFile);				if (fnameLen > 3)					{					e1 = nextFile[fnameLen-3];					x = nextFile[fnameLen-2];					e2 = nextFile[fnameLen-1];					if ((((e1 == 'e') || (e1 == 'E')) &&						((x == 'x') || (x == 'X'))) &&						((e2 == 'e') || (e2 == 'E')))						exe = TRUE;					}				if (!exe)					{     // jca 21OCT94 pro/player only create the file if it's not an exe					file=new(V_File);					file->sWFile(nextFile);					NewDocument(file,LOADSTART);#if VPLAYER					count = -1;	// get out if we've opened one. jca 21OCT94 Player#endif                    }				nextFile=strtok(NULL, " ");				}			}#endif //MACINTOSH	else			{			NewDocument(NULL,INIT);						/*no files to load at startup*/			}		}#if VR && WINDOWS	if (ActiveDocument()->GetVRLib())		{		ActiveDocument()->MoveVRLib(-1);        }#endif //VR && WINDOWS#endif //__powerc	}/*------------------------------------------------------------------------------ * void Exit() * This is the only way to exit the program. *------------------------------------------------------------------------------*/void Exit(void){V_Offscreen *scrn;extern long objects;#if MACINTOSHif(gIsBalloon && HMGetBalloons() && HMIsBalloon())/*there is a balloon, get rid of it*/	HMRemoveBalloon();if(gQuickTime)ExitMovies();#endifif(offscreen)offscreen->dOffscreen();if(nilPort)nilPort->dOffscreen();while(screen->ALength())	{	screen->Get(0,&scrn);	screen->Remove(0);	scrn->dOffscreen();	}screen->dArray();visibleMMgr->dArray();theSuper->dArray();#if MACINTOSH && VRML_ANCHOR // ABD PRO25 AUG95// this is required to be able to cut-n-paste between apps --// make sure cut/copied info is saved to desktop scrap when we quitZeroScrap();TEToScrap();#endifSoundEnd();       // jca 31 Oct 93 we should do this fer Windows(tm), too.#if MACINTOSH#if PROFILEDumpProfile();#endifVExitToShell();#else //MACINTOSHReleaseGraphics();PostQuitMessage(WM_QUIT);#endif}