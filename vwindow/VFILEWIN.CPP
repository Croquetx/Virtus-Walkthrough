/*------------------------------------------------------------------------------ * Virtus VWindows * Version 2.0 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				 * * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History: *			Modified	7/29/92    Support for MSWindows *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VFile.h"#include "VArray.h"#include "VIO.h"#include "VMemUtil.h"#include "VGraphic.h"#include "VGUtil.h"#include "VGestalt.h"#include "VDialog.h"#include "VMain.h"#include "VSound.h"#include "VError.h"#include "VTextDef.h"#include "appfiles.h" //JAM added 23July94#include "apptext.h" //JAM added 25July94#include <stdio.h>#include <string.h>#if __BORLANDC__  // borland calls its dos dir command wrapper header file something weird.#include <ctype.h>#include <dir.h>	/* use a borland-wrapped DOS command until NT comes out */#include <dos.h>#elif _MSC_VER || __SC__#include <direct.h>     /* use somebody else's DOS command wrapper */#endif // __BORLANDC__ dos hacklong theCreator;strPtr uname=TXT_UNTITLED; /*the default name for the file object*/int _fileCount_ = 1;V_Array *PathName(char *);int ParsePathName(V_Array *pathN, char *newPath, char *fName, char *fExt);int ParseRelativePath(V_Array *path1,V_Array *path2,int index,char *newPath, char *fName, char *fExt);typedef char pathMember[32];static OPENFILENAME of;   	/* for windows */#define BUFF_SIZE 512/*------------------------------------------------------------------------------ * int FileCount() * Returns the number of files that the user is requesting to load into the * the system. *------------------------------------------------------------------------------*/int FileCount(){short message,count=0;return(count);}/*------------------------------------------------------------------------------ * V_File * The V_File system allows the programmer easy access to the file system.  It * handles such conveniences as GetFile and PutFile dialogs and performs all * of the overhead required in remembering the last loaded or saved file so * that the file will default back to this when required.  Files are always defined * as derived classes with the loadfile() and savefile() methods being redefined. * None of the other methods should ever be touched. *------------------------------------------------------------------------------ * void V_File::cFile(int q,long tp,long crt,strPtr qstr) * long tp;  the file type * long crt; the file creator * strPtr filts; filter strings for use with Windows    (JCA) * strPtr qstr; query string of this file * * This creates the file object and prepares it for the Get and Put dialogs. *------------------------------------------------------------------------------*/voidV_File::cFile(int q,long tp,long crt,strPtr filts,strPtr qstr)	{	short currentVol;    char *tmp;	hFile = NULL;	file = NULL;#if VPRO && !SPECIAL_EDITION // VwtVRML 		// GJR 07/12/95	//JAM 14JULY94 added to handle embed/notembed textures [[[    EmbedTexturesFlag = FALSE;	//JAM 14JULY94 added to handle embed/notembed textures ]]]#elif SPECIAL_EDITION	EmbedTexturesFlag = TRUE;#endif	query=q&0x0F;	newflag=q&NEWFLAG;	openFlag=FALSE;	strcpy(qStr,qstr);	minDiskSpace=33000L;	VSetCursor(vCursorEarth);	strcpy(filname,uname);	create=crt;	type=tp;	used=FALSE;	relativeFile=0;	refCon=0;	path[0]=0;	position = 0;    validated = 0x0;	use_radio_button_save = FALSE;	// MERGE-GOURAUD-PRO    /* copy out the file extension */	tmp = (char *) &tp;	fileExt[0] = tmp[3];     // byte swap a la Intel	fileExt[1] = tmp[2];	fileExt[2] = tmp[1];	fileExt[3] = tmp[0];	strncpy(defFileExt, fileExt, 4);	if (tp) validated |= USE_EXTENSION;	filters = new(V_Array);	filters->cArray(0, sizeof(char), 32);    /* make length = to length of the filter and a NULL */	if (filters->SetLength(strlen(filts) + 1))		{		filters->dArray();		filters = NULL;        defFilterLen = 0;       // jca 21Jan94		}	else    	{		tmp = (char *) filters->Use();		strcpy(tmp, filts);		filters->Unuse();		defFilterLen = strlen(tmp);   // jca 21Jan94 keep track of the default filter, for saving.    	}	if(query==SAVE || query==SAVEAS || query==SAVECOPYAS)		cBuffer(DATA_OUT);	else cBuffer(DATA_IN);	}voidV_File::dFile()	{	if(openFlag)Close();	if (filters)	filters->dArray();		// DAS 1 Nov 93 -- weren't getting deallocated	dBuffer();	}/*	Aaaagh!!!! the mac version gets the file name from the	operating system ("Excuse me, what were my arguments again?")	and seems to use these really gross globals to iterate the files.	This is evil.  Whatever object wants the file should tell the	V_File what to load; the V_File shouldn't have to interrogate	the operating system.	--jca */void V_File::sFile() { }void V_File::sWFile(strPtr str){	// Windows apps get a modified command line string (if there	// were any arguments.  Otherwise they get an empty string).	// The application will pass sWFile() a filename from the	// command line, which sWFile() will init in the way sFile()	// does on the mac.	char	thePath[256], theName[256], theExt[256];	int i, pathLength, ok, last, isExt, isName;	memset(thePath, 0, 256);	memset(theName, 0, 256);	memset(theExt, 0, 256);	hFile = NULL;	file = NULL;	query=LOADSTART;	newflag=NEWFLAG;	openFlag=FALSE;	minDiskSpace=33000L;	VSetCursor(vCursorEarth);	_fileCount_++;	// parse the string	pathLength = strlen(str);	for (i = last = pathLength-1, isName = isExt = 0; i >= 0 && ok; i--)		{		if (str[i] == '\\')			{			if (i < last)            	{				strncpy(theName, &str[i+1], last-i);				theName[last-i] = 0;				last = i+1;				isName = 1;				}            ok = 0;			}		else if (str[i] == '.')			{			// if last == i, then the '.' is the last char in the str, and there is no            // file extension.  if last < i, there's an error.			if ((last-i) > 0)        		{				strncpy(theExt, &str[i+1], last-i);				theExt[last-i]=0;				validated |= USE_EXTENSION;                isExt = 1;				}			else				validated &= ~USE_EXTENSION;			last = i-1;            if (last < 0) last = 0;			}		}	if (isName)    	{		strncpy(thePath, str, last+1);		thePath[last] = 0;		}	else		{		strncpy(theName, str, last+1);		theName[last+1] = 0;		}	if ((strlen(theExt) <= MAX_LENGTH_EXTENSION) &&		(strlen(theName) <= MAX_LENGTH_FILENAME))		validated |= USE_FILENAME;	SetLocation(thePath, theName, theExt);	create=theCreator;	type = (long)theExt;	used=FALSE;	relativeFile=0;	refCon=0;	position = 0;	filters = new(V_Array);	filters->cArray(0, sizeof(char), 32);	defFilterLen = 0;	// jca 21Jan94	cBuffer(DATA_IN);	Verify();	buffer->SetLength(BUFF_SIZE);}long V_File::GetFType(){	return(type);}void V_File::GetFName(strPtr str)	{	if (!(validated&USE_FILENAME))		{        str[0] = 0;		return;        }	if (validated&USE_EXTENSION)		sprintf(str,"%s.%s", filname, fileExt);	else		sprintf(str,"%s", filname);	}void V_File::AddFType(long tp, strPtr filt){	int 	where;	char	*tmp;	if (!(validated & USE_EXTENSION))      // shouldn't we only do this if we haven't done it yet?  jca 9 Nov 93		{	/* copy out the file extension */		tmp = (char *) &tp;		fileExt[0] = tmp[3];     // byte swap a la Intel		fileExt[1] = tmp[2];		fileExt[2] = tmp[1];		fileExt[3] = tmp[0];		strncpy(defFileExt, fileExt, 4);		if (tp) validated |= USE_EXTENSION;		type = tp;        }	if (!filters)		{		filters = new(V_Array);		filters->cArray(0, sizeof(char), 32);		where = 0;        }	else		where = max(VA_Length(filters)-1, 0);    /* make length = to length of the filter plus the new filter */	if (filters->SetLength(strlen(filt) + VA_Length(filters)))		{		filters->dArray();		filters = NULL;        defFilterLen = 0;        }	else    	{		tmp = (char *) filters->Use();		strcpy(&tmp[where], filt);		filters->Unuse();		if (!defFilterLen)  // if there is no def filter... jca 21Jan94			defFilterLen = strlen(filt);		}}void V_File::SetFType(long tp){	strncpy(fileExt, (char *) &tp, 4);	strncpy(defFileExt, (char *) &tp, 4);    type = tp;	if (type)	validated |= USE_EXTENSION;}voidV_File::SetName(strPtr nfname)	{	int i;	for (i = 0; i < strlen(nfname); i++)    	{		if (nfname[i] == '.')			break;        }	strncpy(filname,nfname, min(i, MAX_LENGTH_FILENAME));	filname[min(i, MAX_LENGTH_FILENAME)] = '\0'; // null terminate    validated |= USE_FILENAME;	used=TRUE;	}voidV_File::GetName(strPtr nfname)	{	if (!(validated&USE_FILENAME))		{        nfname[0] = 0;		return;        }	strcpy(nfname,filname);	}voidV_File::AppendFName(strPtr ext)	{	if (!(validated&USE_FILENAME))	return;	if ((strlen(ext) <= MAX_LENGTH_APPENDAGE) && (strlen(ext) != 0))		{		if (strlen(filname) + strlen(ext) < MAX_LENGTH_FILENAME)			{            strcat(filname, ext);			}		else			{            strcpy(&filname[MAX_LENGTH_FILENAME - strlen(ext)], ext);            }		}	/* else ack!  the appendage is too long! */	}intV_File::GetBufferType(void){	return(V_FILETYPE);}int V_File::FVerify()	{	FILE	*f;	char	tempFName[256];    if (!(validated&USE_FILENAME))	return(fileNotFoundErr);	if (validated&USE_EXTENSION)		sprintf(tempFName, "%s%s.%s", path, filname, fileExt);    else		sprintf(tempFName, "%s%s", path, filname);	f = fopen(tempFName, "r");	if (f)		{		fclose(f);		return FALSE;		}	else		return fileNotFoundErr;	}int V_File::FindSystem(){int	ccount;ccount = GetWindowsDirectory(path,256);    /* windows call */if (ccount)  /* if we got a name.  ccount is the path length in chars */	{	if (path[ccount-1] != '\\')		strcat(path, "\\");    }return(((ccount)?0:-1));}void V_File::SetMinDiskSpace(long mds) { minDiskSpace=mds; }voidV_File::SetQuery(int q,strPtr qstr)	{	query=q;	strcpy(qStr,qstr);	switch(query)		{		case SAVE:		case SAVEAS:		case SAVECOPYAS:			direction = DATA_OUT;			break;				case LOAD:		case LOADAS:		case LOADSTART:		case PRINT:			direction = DATA_IN; 			break;		}	}#if VPRO && !SPECIAL_EDITION // VwtVRML 		// GJR 07/12/95VirtusFileTypeGetWindowsFileType(char *textstr);VirtusFileTypeGetWindowsFileType(char *textstr)	{	VirtusFileType type;	long length = strlen(textstr);	char extension[256];	long i;	strcpy(extension, textstr);	for(i=0;i<length;i++)	{		if((extension[i] >= 'A') && (extension[i] <= 'Z'))		{        	extension[i] = 'a' + (extension[i] - 'A');        }    }    type = VirtusProFile;	if(strstr(extension,TYPEPROEXT) != NULL)		{       	type = VirtusProFile;		}	else if(strstr(extension,TYPEVVREXT) != NULL)		{       	type = VirtusVRFile;		}	else if(strstr(extension,TYPEWLKEXT) != NULL)		{		type = VirtusVWTFile;		}	return(type);	}V_File *CurrentFile;	//so the options dialog will know about the current file// Kinda picked at random. The other child window IDs in the Open File dialog// are around 1000 to 1500, so pick a number outside that range.#define IDSaveOptions	588#define IDEmbedTextures	589#define IDFileRefTextures	590#define IDSaveOptGroup		591int oldEmbedTexturesFlag;int SaveOptionsFlag = 0; // Global flag for New button in LOADAS dialogHWND optionsButton, rEmbedTextures, rFileRefTextures, SaveOptGroup;UINT CALLBACK _exportOFNHookProcSaveOptions(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)	{	HWND child, OKButton, cancelButton;	int result = 0;	int length;	char textstr[256];    int i;	VirtusFileType type;	switch (msg)		{		case WM_INITDIALOG:			//Window positioning stuff			RECT r;			int x,y,cx,cy;			int itemheight;			GetWindowRect(hwnd, &r);			cx = r.right - r.left;			cy = r.bottom - r.top;			GetScreen(&r);			itemheight = SendDlgItemMessage(hwnd, cmb1, CB_GETITEMHEIGHT, -1, 0L);			cy += itemheight*3;	//JAM room for radio buttons			x = ((r.right-r.left)-cx)>>1 + r.left;			y = ((r.bottom-r.top)-cy)>>1 + r.top;//			SetWindowPos(hwnd,HWND_TOP,x,y,cx,cy,SWP_NOSIZE);			SetWindowPos(hwnd,HWND_TOP,x,y,cx,cy,0);			OKButton = NULL;			cancelButton = NULL;			// Set the save file type drop down menu to appropriate value			SendDlgItemMessage(hwnd, edt1, WM_GETTEXT, sizeof(textstr), (long)textstr);			type = GetWindowsFileType(textstr);			if(type == VirtusVRFile)            {				SendDlgItemMessage(hwnd, cmb1, CB_SETCURSEL, 1, 0L);			}			// Find the OK and Cancel buttons			child = GetWindow(hwnd, GW_CHILD);			while (child != NULL)				{				int id;				id = GetWindowWord(child, GWW_ID);				if (id == IDOK) OKButton = child;                else if (id == IDCANCEL) cancelButton = child;				child = GetWindow(child, GW_HWNDNEXT);                }			// If they're found, create the New button			if (OKButton != NULL && cancelButton != NULL)				{				RECT OKRect, cancelRect;                POINT newPoint;				HFONT font;				int height, width;				long style, exStyle;				RECT r;                GetWindowRect(hwnd, &r);				oldEmbedTexturesFlag = CurrentFile->GetEmbedTextures();				// Same font as file type drop down list				font = SendDlgItemMessage(hwnd, edt1, WM_GETFONT, 0, 0);				newPoint.x = r.left+20;				newPoint.y = r.bottom-itemheight*3-((3*itemheight)/4);				ScreenToClient(hwnd,&newPoint);				style = BS_GROUPBOX|WS_CHILD|WS_VISIBLE|MDIS_ALLCHILDSTYLES;				SaveOptGroup = CreateWindowEx(WS_EX_TRANSPARENT,"BUTTON",					TXTPF_TXTRSAVE,					style,newPoint.x,newPoint.y,					r.right-r.left-40,itemheight*3,hwnd,					IDSaveOptGroup, GetAppInstance(),NULL);				// Put it after Cancel in the TAB order				SetWindowPos(SaveOptGroup, cancelButton, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE);				style = WS_CHILD|WS_VISIBLE|BS_AUTORADIOBUTTON;				exStyle = 0;				newPoint.x = r.left+30;				newPoint.y = r.bottom-itemheight*3;				ScreenToClient(hwnd,&newPoint);				rFileRefTextures = CreateWindow("BUTTON",					TXTPF_LINK,					style|WS_GROUP,newPoint.x,newPoint.y,					r.right-r.left-100,itemheight,hwnd,					IDFileRefTextures, GetAppInstance(),NULL);				newPoint.x = r.left+30;				newPoint.y = r.bottom-itemheight*2;				ScreenToClient(hwnd,&newPoint);				rEmbedTextures = CreateWindow("BUTTON",					TXTPF_EMBED,					style,newPoint.x,newPoint.y,					r.right-r.left-100,itemheight,hwnd,					IDEmbedTextures, GetAppInstance(),NULL);				if(oldEmbedTexturesFlag)				{					SendMessage(rEmbedTextures, BM_SETCHECK, 1, 0L);                    SendMessage(rFileRefTextures, BM_SETCHECK, 0, 0L);				}				else				{					SendMessage(rEmbedTextures, BM_SETCHECK, 0, 0L);					SendMessage(rFileRefTextures, BM_SETCHECK, 1, 0L);				}				SendMessage(rEmbedTextures, WM_SETFONT, font, 0);				SendMessage(rFileRefTextures, WM_SETFONT, font, 0);				SendMessage(SaveOptGroup, WM_SETFONT, font, 0);				if(GetWindowsFileType(CurrentFile->fileExt) == VirtusVRFile)					{					EnableWindow(SaveOptGroup, FALSE);					EnableWindow(rEmbedTextures, FALSE);					EnableWindow(rFileRefTextures, FALSE);					}				}			SaveOptionsFlag = FALSE; // Clear the global flag			break;		case WM_COMMAND:			if (wParam == cmb1)			{				if (HIWORD(lParam) == CBN_CLOSEUP)					{					HWND child;					int length;					child = LOWORD(lParam);					length = GetWindowText(child, textstr, sizeof(textstr));					textstr[length] = '\0';					type = GetWindowsFileType(textstr);					if(type == VirtusVRFile)						{						EnableWindow(SaveOptGroup, FALSE);						EnableWindow(rEmbedTextures, FALSE);						EnableWindow(rFileRefTextures, FALSE);						SendMessage(rEmbedTextures, BM_SETCHECK, 1, 0L);                        SendMessage(rFileRefTextures, BM_SETCHECK, 0, 0L);						}					else						{						int radiostate;						EnableWindow(SaveOptGroup, TRUE);						EnableWindow(rEmbedTextures, TRUE);						EnableWindow(rFileRefTextures, TRUE);						if(CurrentFile->GetEmbedTextures()) radiostate = 1;						else radiostate = 0;						SendMessage(rEmbedTextures, BM_SETCHECK, radiostate, 0L);						SendMessage(rFileRefTextures, BM_SETCHECK, 1-radiostate, 0L);						}					*(WORD*)textstr = sizeof(textstr)-1;					length = SendDlgItemMessage(hwnd, edt1, EM_GETLINE, 0, (DWORD)(LPSTR)textstr);                    textstr[length] = '\0';					for(i=0;(textstr[i] != '.') && (textstr[i] != '\0');i++);					textstr[i++] = '.';					if(type == VirtusVRFile) {sprintf(&(textstr[i]),"%s",TYPEVVREXT);}					else if(type == VirtusProFile) {sprintf(&(textstr[i]),"%s",TYPEPROEXT);}					else if(type == VirtusVWTFile) {sprintf(&(textstr[i]),"%s",TYPEWLKEXT);}					else {sprintf(&(textstr[i]),"%s",TYPEPROEXT);}					SendDlgItemMessage(hwnd, edt1, WM_SETTEXT, 0, (DWORD)textstr);					}		}			if (wParam == IDEmbedTextures)				{				char text[256];				// Make sure it's the embed textures radio button				child = LOWORD(lParam);				GetWindowText(child, text, sizeof(text));				if (strcmp(text, TXTPF_EMBED) == 0)					{					HWND temphwnd;					CurrentFile->SetEmbedTextures(TRUE);//					SendMessage(rFileRefTextures, BM_SETCHECK, 0, 0L);//					SendMessage(rEmbedTextures, BM_SETCHECK, 1, 0L);					}                }			if (wParam == IDFileRefTextures)				{				char text[256];				// Make sure it's the reference textures radio button				child = LOWORD(lParam);				GetWindowText(child, text, sizeof(text));				if (strcmp(text, TXTPF_LINK) == 0)					{					HWND temphwnd;					CurrentFile->SetEmbedTextures(FALSE);//					SendMessage(rFileRefTextures, BM_SETCHECK, 1, 0L);//					SendMessage(rEmbedTextures, BM_SETCHECK, 0, 0L);					}				}			if (wParam == IDCANCEL)				{                	CurrentFile->SetEmbedTextures(oldEmbedTexturesFlag);                }			break;		}	return result;	}#endif	//VPRO// Kinda picked at random. The other child window IDs in the Open File dialog// are around 1000 to 1500, so pick a number outside that range.#define IDNEW	587int newFlag = 0; // Global flag for New button in LOADAS dialogUINT CALLBACK _exportOFNHookProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)	{	HWND child, OKButton, cancelButton;	int result = 0;	switch (msg)		{		case WM_INITDIALOG:			OKButton = NULL;			cancelButton = NULL;			// Find the OK and Cancel buttons			child = GetWindow(hwnd, GW_CHILD);			while (child != NULL)				{				int id;				id = GetWindowWord(child, GWW_ID);				if (id == IDOK) OKButton = child;                else if (id == IDCANCEL) cancelButton = child;				child = GetWindow(child, GW_HWNDNEXT);                }			// If they're found, create the New button			if (OKButton != NULL && cancelButton != NULL)				{				RECT OKRect, cancelRect;                POINT newPoint;				HWND newButton;                HFONT font;				int height, width;				long style, exStyle;                // Same style as Cancel				style = GetWindowLong(cancelButton, GWL_STYLE);                exStyle = GetWindowLong(cancelButton, GWL_EXSTYLE);				GetWindowRect(OKButton, &OKRect);				GetWindowRect(cancelButton, &cancelRect);                // Same size as Cancel				height = cancelRect.bottom - cancelRect.top;                width = cancelRect.right - cancelRect.left;            	// Position it below Cancel				newPoint.x = OKRect.left;				newPoint.y = cancelRect.top + (cancelRect.top - OKRect.top);				ScreenToClient(hwnd, &newPoint);                // Create the button				newButton = CreateWindowEx(exStyle, "BUTTON", TXTC_NEW, style,					newPoint.x, newPoint.y, width, height,					hwnd, IDNEW, GetAppInstance(), NULL);                // Put it after Cancel in the TAB order				SetWindowPos(newButton, cancelButton, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE);                // Same font as Cancel				font = SendMessage(cancelButton, WM_GETFONT, 0, 0);				SendMessage(newButton, WM_SETFONT, font, 0);				}			newFlag = FALSE; // Clear the global flag			//Window positioning stuff			RECT r;    		int x,y,cx,cy;			GetWindowRect(hwnd, &r);			cx = r.right - r.left;			cy = r.bottom - r.top;			GetScreen(&r);			x = ((r.right-r.left)-cx)>>1 + r.left;			y = ((r.bottom-r.top)-cy)>>1 + r.top;			SetWindowPos(hwnd,HWND_TOP,x,y,cx,cy,SWP_NOSIZE);			break;		case WM_COMMAND:			if (wParam == IDNEW)				{				char text[32];				// Make sure it's the New button				child = LOWORD(lParam);				GetWindowText(child, text, sizeof(text));				if (strcmp(text, TXTC_NEW) == 0)					{					// If New clicked, set the global flag and post					// a Cancel message to the dialog					if (HIWORD(lParam) == BN_CLICKED)                    	{						newFlag = TRUE; // Set the global flag						PostMessage(hwnd, WM_COMMAND, IDCANCEL, 1);						}                    result = 1; // Mark message as handled by hook function					}                }			break;        }	return result;	}UINT CALLBACK _exportOFPositionHookProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)	{	RECT r;    int x,y,cx,cy;	int result = 0;	switch (msg)		{		case WM_INITDIALOG:			GetWindowRect(hwnd, &r);			cx = r.right - r.left;			cy = r.bottom - r.top;			GetScreen(&r);			x = ((r.right-r.left)-cx)>>1 + r.left;			y = ((r.bottom-r.top)-cy)>>1 + r.top;			SetWindowPos(hwnd,HWND_TOP,x,y,cx,cy,SWP_NOSIZE);			break;		}	return result;	}intV_File::Find(void)	{	OSErr err = 0;   // initialize err to NULL  jca 29 jan 93	long *theList;	int i,numtypes=1;	Point loc;	char filterDescriptions[256];	char fullPath[256];	char	*filtPatDes;	V_Document	*theDoc;	HWND		theOwner;    long ParentWindowLong;	//JAM Jun94 to make parent window be reselected after find	if(openFlag)    	{    	AlertMessage(TXT_FILEPROB);    	return(TRUE);		}	HLock((ObjectHandle)this);    if (validated&USE_EXTENSION)		sprintf(fname, "%s.%s", filname, fileExt);	if(!used)		{		if(query==SAVE)query=SAVEAS;		else if(query==LOAD)query=LOADAS;		}	retry:		switch(query)			{			case SAVE:				break;			case SAVEAS:			case SAVECOPYAS:				VSetCursor(vCursorArrow);				filtPatDes = (char *) filters->Use();//JAM 15JULY94 Pro lets more than one filter be used [[[#if VPRO && !SPECIAL_EDITION // VwtVRML 		// GJR 07/12/95				for (i = 0; i < VA_Length(filters); i++)                	{					if (filtPatDes[i] == '|')	filterDescriptions[i] = '\0';					else						filterDescriptions[i] = filtPatDes[i];					}#else				/*				   jca 21JAN94 -- changed to only let the first filter be used for				   saving files.  The first filter is the default file type.				   The structure of a filter is "file type (*.xyz)|(*.xyz)|"				   The first is the text description, the second is the				   real filter used.				for (i = 0; i < VA_Length(filters); i++)                	{					if (filtPatDes[i] == '|')	filterDescriptions[i] = '\0';					else						filterDescriptions[i] = filtPatDes[i];					}				*/				for (i = 0; i < defFilterLen; i++)                	{					if (filtPatDes[i] == '|')	filterDescriptions[i] = '\0';					else						filterDescriptions[i] = filtPatDes[i];					}#endif //VPRO//JAM 15JULY94 Pro lets more than one filter be used ]]]				filterDescriptions[i] = '\0';				filters->Unuse();				memset(fullPath, 0, 256);				if (validated&USE_FILENAME)					strcpy(fullPath, fname);				else					sprintf(fullPath, "*.%s", defFileExt);				memset(&of,0,sizeof(OPENFILENAME));				of.lStructSize=sizeof(OPENFILENAME);				of.hwndOwner=GetMainFrameWindow(); //This probably needs to be the doc window				of.lpstrFilter=filterDescriptions;				of.nFilterIndex=1;				of.lpstrFile=(LPSTR)fullPath;				of.nMaxFile=256;				of.lpstrFileTitle=fname;				of.nMaxFileTitle=sizeof(fname);				if (strlen(path))					of.lpstrInitialDir= path;				of.lpstrTitle= qStr; 				of.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST|OFN_OVERWRITEPROMPT|						OFN_NOREADONLYRETURN;				of.lpstrDefExt= defFileExt;#if VPRO && !SPECIAL_EDITION // VwtVRML 		// GJR 07/12/95				if(use_radio_button_save)                {					of.Flags |= OFN_ENABLEHOOK;					of.lpfnHook = OFNHookProcSaveOptions;					SaveOptionsFlag = TRUE;					CurrentFile = this;				}#endif //VPRO				err = GetSaveFileName(&of) ? FALSE : TRUE;				if(err) break;				/* get the path */				strncpy(path, fullPath, of.nFileOffset);				path[of.nFileOffset] = '\0';	/* null terminate */				if (of.nFileExtension < strlen(fullPath))					{                    int namLength;					validated |= USE_EXTENSION;					/* get filename */					namLength = min(MAX_LENGTH_FILENAME, of.nFileExtension-of.nFileOffset-1);					strncpy(filname, &fullPath[of.nFileOffset], namLength);					filname[namLength] = '\0';  	/* null terminate */					validated |= USE_FILENAME;					memset(fileExt, 0, MAX_LENGTH_EXTENSION+1);					/* get the extension */					if (of.nFileExtension > 0)						{						namLength = min(MAX_LENGTH_EXTENSION, strlen(fullPath)-of.nFileExtension);						strncpy(fileExt, &fullPath[of.nFileExtension],  namLength);                        fileExt[namLength] = '\0';	/* null terminate */                     	}                    }				else                	{					int namLength;					/* get filename */					namLength = min(MAX_LENGTH_FILENAME, of.nFileExtension-of.nFileOffset-1);					strncpy(filname, &fullPath[of.nFileOffset], namLength);					filname[namLength] = '\0';  	/* null terminate */					validated |= USE_FILENAME;					/* set the extension */					memset(fileExt, 0, MAX_LENGTH_EXTENSION+1);					validated &= ~USE_EXTENSION;					}				break;			case LOADAS:				VSetCursor(vCursorArrow);				// BILBIL - added "All Appropiate Files" file filter stuff - 9/17/94 [[[				{				int		j, k = 0, extCount = 0;				int		onExt = FALSE, firstExt = TRUE;				filtPatDes = (char *) filters->Use();				j = sprintf(filterDescriptions, TXT_ALLSUPPORTED);				for (i = 0; i < VA_Length(filters) - 1; i++)					{					if (filtPatDes[i] == '|')						{						onExt = !onExt;						if (onExt)							{							extCount ++;							if (firstExt)								{								filterDescriptions[j ++] = '\0';								firstExt = FALSE;								}							else								{								filterDescriptions[j ++] = ';';								fullPath[k++] = ';';								}							}						}					else if (onExt)						{						filterDescriptions[j++] = filtPatDes[i];						fullPath[k++] = filtPatDes[i];						}					}				if (extCount < 2)					{					memset(fullPath, 0, 256);					k = sprintf(fullPath, "*.%s", defFileExt);					j = 0;					}                else					filterDescriptions[j ++] = '\0';				for (i = 0; i < VA_Length(filters); i++, j++)					{					if (filtPatDes[i] == '|')						filterDescriptions[j] = '\0';					else						filterDescriptions[j] = filtPatDes[i];					}				filterDescriptions[j] = '\0';				fullPath[k] = '\0';				filters->Unuse();				}				// BILBIL - added "All Appropiate Files" file filter stuff - 9/17/94 ]]]// BILBIL - this is the code that "All Appropiate Files" replaces - just in case - 9/17/94#if 0				filtPatDes = (char *) filters->Use();				for (i = 0; i < VA_Length(filters); i++)					{					if (filtPatDes[i] == '|')	filterDescriptions[i] = '\0';					else						filterDescriptions[i] = filtPatDes[i];                    }				filterDescriptions[i] = '\0';				filters->Unuse();				memset(fullPath, 0, 256);				sprintf(fullPath, "*.%s", defFileExt);#endif //0				memset(&of,0,sizeof(OPENFILENAME));				of.lStructSize=sizeof(OPENFILENAME);//JAM Jun94 to make parent window be reselected after find [[[				of.hwndOwner=GetMainFrameWindow(); //This probably needs to be the doc window//				ParentWindowLong = SendMessage(0,WM_MDIGETACTIVE,0,0);// 				of.hwndOwner = LOWORD(ParentWindowLong);//JAM Jun94 to make parent window be reselected after find ]]]				of.lpstrFilter=filterDescriptions;				of.nFilterIndex=1;				of.lpstrFile=(LPSTR)fullPath; //path;				of.nMaxFile=256;				of.lpstrFileTitle=fname;				of.nMaxFileTitle=sizeof(fname);				if (strlen(path))					of.lpstrInitialDir= path;				of.lpstrTitle= qStr; //"Open WalkThrough Model";				of.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST/*|OFN_CREATEPROMPT*/;				of.lpfnHook = OFPositionHookProc;				of.Flags |= OFN_ENABLEHOOK;				if(newflag)					{					of.Flags |= OFN_ENABLEHOOK;					of.lpfnHook = OFNHookProc;                    newFlag = TRUE;					}				of.lpstrDefExt= defFileExt;#if VPLAYER// BILBIL - don't do the window positioning hook for player, it crashes - don't know why.of.lpfnHook = NULL;of.Flags ^= OFN_ENABLEHOOK;#endif //VPLAYER				err = GetOpenFileName(&of) ? FALSE : TRUE;				if(newflag && newFlag)err=TRUE;                else newflag=FALSE;				if(err) break;				/* get the path */				strncpy(path, fullPath, of.nFileOffset);				path[of.nFileOffset] = '\0';	/* null terminate */				if (of.nFileExtension < strlen(fullPath))					{                    int namLength;					validated |= USE_EXTENSION;					/* get filename */					namLength = min(MAX_LENGTH_FILENAME, of.nFileExtension-of.nFileOffset-1);					strncpy(filname, &fullPath[of.nFileOffset], namLength);					filname[namLength] = '\0';  	/* null terminate */					validated |= USE_FILENAME;					memset(fileExt, 0, MAX_LENGTH_EXTENSION+1);					/* get the extension */					if (of.nFileExtension > 0)						{						namLength = min(MAX_LENGTH_EXTENSION, strlen(fullPath)-of.nFileExtension);						strncpy(fileExt, &fullPath[of.nFileExtension],  namLength);                        fileExt[namLength] = '\0';	/* null terminate */                     	}                    }				else                	{					int namLength;					/* get filename */					namLength = min(MAX_LENGTH_FILENAME, of.nFileExtension-of.nFileOffset-1);					strncpy(filname, &fullPath[of.nFileOffset], namLength);					filname[namLength] = '\0';  	/* null terminate */					validated |= USE_FILENAME;					/* set the extension */					memset(fileExt, 0, MAX_LENGTH_EXTENSION+1);					validated &= ~USE_EXTENSION;					}				stationery=FALSE;					case LOAD:			case REFERENCE:			case LOADSTART:			case PRINT:				// Mac expected the type to be set here		//GJR 10/06/93			    if (validated&USE_EXTENSION)			    	{					if (!type)						{						/* this is the best guess about the file type */						/* or is it 	type = (long)fileExt; */				        type = MakeID(fileExt[0],fileExt[1],fileExt[2],fileExt[3]);						}					}															//GJR 10/06/93				// the mac also gets info on the file, verifying its existence.  We				// should also check that the file is there (jca 19APR95) [[[				if (!(GetFullPathStr(fullPath)))					{					OFSTRUCT	ofstuff;   // let's be windows-y					// try to open the file using the "exist" flag.  It will open and then close					// the file, so there's nothing to clean up.  Tidy, eh?					if (HFILE_ERROR == OpenFile(fullPath, &ofstuff, OF_EXIST)) // does the file exist?						err = fileNotFoundErr;                    // else, we're okay!					}				else					err = fileNotFoundErr;				 /// jca 19APR95 ]]]				break;			}	HUnlock((ObjectHandle)this);	return err;	}int V_File::MakeDirectory(){/* use a DOS command (and note that we have to be in theparent directory of the one we want to create!) */char	oldWorkingDir[256], tempPath[256];V_Array	*newDir;int		i, err= noErr;pathMember	*pData;int		oldDriveId, desiredDriveId;getcwd(oldWorkingDir, 256);	/* dos command; get the current directory */oldDriveId = getdisk();	/* dos command, get current drive */strcpy(tempPath, path);if ((strlen(tempPath)) && (tempPath[strlen(tempPath)-1]))	tempPath[strlen(tempPath)-1] = '\0';	if (chdir(tempPath))  /* does the directory exist? if not, make it */	{	newDir = PathName(path); 	/* parse the directories */	pData = (pathMember*)newDir->Use();	if (VA_Length(newDir) > 0) 	/* change the drive */		{		int		pathDriveId;		P2Cstr((char *)pData[VA_Length(newDir)-1]);		pathDriveId = pData[VA_Length(newDir)-1][0];		desiredDriveId = (toupper(pathDriveId)) - 'A';		if ((desiredDriveId >= 0) && (desiredDriveId < 26))			{			if (oldDriveId != desiredDriveId)				{				setdisk(desiredDriveId);				if (getdisk() != desiredDriveId)					err = fileNotFoundErr;				}				}		else			err = fileNotFoundErr;		// if all has gone well, this will put us in the root directory        // of the desired drive.  Otherwise, it doesn't do anything for us.		strcat((char *)pData[VA_Length(newDir)-1], ":\\");		chdir((const char *)pData[VA_Length(newDir)-1]);      /* what about the error? */		}	for (i = VA_Length(newDir)-2; err == noErr, i >= 0 ; i--)		{		P2Cstr((char *)pData[i]);		if (chdir((const char *)pData[i]))    // dos			{			if (mkdir((const char *)pData[i]))   // dos				{				err = fileNotFoundErr;                i = -1;				}	        }		}	newDir->Unuse();	newDir->dArray();	}setdisk(oldDriveId);chdir(oldWorkingDir);return(err);}int V_File::SetDirectory(){/* this simulates the behavior on the mac.  We have set thedirectory name in the filname member of the V_File; SetDirectory()sends us there (or returns an error) */char oldWorkingDir[256], tmep[256];int		err;getcwd(oldWorkingDir, 256);	/* dos command; get the current directory */if (strlen(filname))	{	strcat(path, filname);    	/* add the directory to the path name */	filname[0] = '\0';			/* splat out the filname */	strcat(path, "\\");	}strcpy(tmep, path);if ((strlen(tmep)) && (tmep[strlen(tmep)-1] == '\\'))	tmep[strlen(tmep)-1] = '\0';err = chdir(tmep);        	/* can we get to the directory? */chdir(oldWorkingDir);       /* go home */if (err)	return(fileNotFoundErr);else		return(noErr);}int V_File::FindApplication()	{	char exePath[256];	char	thePath[256], theName[256], theExt[256];	int i, pathLength, ok, last;	memset(thePath, 0, 256);	memset(theName, 0, 256);	memset(theExt, 0, 256);	pathLength = GetModuleFileName(GetAppInstance(), exePath, sizeof(exePath));	if (pathLength > 0)	// otherwise, there's a problem		{		for (i = pathLength-1, last = pathLength-1, ok = 1; i >= 0 && ok; i--)			{			if (exePath[i] == '\\')				{				strncpy(theName, &exePath[i+1], last-i);				theName[last-i] = 0;				last = i+1;	            ok = 0;				}			else if (exePath[i] == '.')				{				if ((last-i) > 0)	        		{					strncpy(theExt, &exePath[i+1], last-i);					theExt[last-i]=0;					validated |= USE_EXTENSION;					}				else					validated &= ~USE_EXTENSION;				last = i-1;				}			}		strncpy(thePath, exePath, last+1);		thePath[last] = 0;		if ((strlen(theExt) <= MAX_LENGTH_EXTENSION) &&			(strlen(theName) <= MAX_LENGTH_FILENAME))			validated |= USE_FILENAME;		SetLocation(thePath, theName, theExt);		}	return Find();	}intV_File::Open(int createFlag)	{    string	fullPath[256];	OSErr err;	if(openFlag)AlertMessage(TXT_FILEOPEN);	HLock((ObjectHandle)this);	if (strlen(fileExt))		sprintf(fullPath, "%s%s.%s", path, filname, fileExt);    else		sprintf(fullPath, "%s%s", path, filname);	if(direction==DATA_OUT) file = fopen(fullPath,"wb+");	else		{		file = fopen(fullPath,"rb+");		// BILBIL - open the file read-only if we can't open it read/write		if (!file)			{			file = fopen(fullPath,"rb");			if (file)				read_only = TRUE;			}		}	err = (file==0) ? 1 : 0;	if(!err)		{		position=0;		openFlag = TRUE;        }	HUnlock((ObjectHandle)this);	return(err);	}intV_File::Close()	{	OSErr err;	HFILE resFile;	used=TRUE;    openFlag = FALSE;	HLock((ObjectHandle)this);	err = fclose(file);	HUnlock((ObjectHandle)this);	return(err);	}int V_File::OpenResource(int createFlag) { return 1; }int V_File::CloseResource() { return 1; }int V_File::IOResource(Handle *buf,long type,int rID,strPtr rName) { return 1; }int V_File::VRemoveResource(long type, int rID) { return 1; }intV_File::IOSetDirection(int dir)	{	OSErr err=0;	if(dir==direction)return(0);	direction=dir;	return err;	}intV_File::IOData(void * buf,long length)	{	OSErr err;	char huge *dataTo;	char huge *dataFrom;	char *writepos, *readpos;	long posKey;	long i;	char workBuf[256];	int sizeWorkBuf = sizeof(workBuf);	long lenFiled;	long lenRemain;    int lenXferd;	err = 0;	lenFiled = 0;	lenRemain = length;	if(direction==DATA_OUT)		{		// Setup the vars for ENcrypting To the buffer. See VIO and VFILEWIN	//gjr Oct24,94		dataFrom=(char huge *)buf;		dataTo  =(char huge *)workBuf;		posKey  =position;	 		while (lenRemain > 0)			{			lenXferd = min(lenRemain, sizeWorkBuf);			// The following copy/xxcrypt code is mostly direction independent. See VIO and VFILEWIN.			writepos = (char *)dataTo;			readpos = (char *)dataFrom;			if((OFFSETOF(writepos) < OFFSETOF(writepos + lenXferd)) &&			  (OFFSETOF(readpos) < OFFSETOF(readpos + lenXferd)) &&			  (lenXferd < 0x00010000L))				{				if(cryptOn){EnCrypt(writepos,readpos,lenXferd,posKey);}				else					{					if(lenXferd>8){Vmemcpy(writepos,readpos,lenXferd);}					else {for(i=0; i<lenXferd; i++, readpos++, writepos++){*writepos = *readpos;}}	       	     	}				}			else				{  // use huge ptrs byte by byte to avoid seg crossing problems				if(cryptOn)					{					for (i=0;i<lenXferd;i++)						{						EnCrypt(&dataTo[i], &dataFrom[i], 1, posKey+i);		                }					}				else		        	{					for(i=0;i<lenXferd;i++)dataTo[i] = dataFrom[i];		            }				}			dataFrom  += lenXferd;			posKey    += lenXferd;			lenRemain -= lenXferd;			lenFiled += fwrite(workBuf,1,lenXferd,file);			}  //while (lenRemain > 0)		}	else		{		long end;		int readIt;        readIt = TRUE;		if(chunkData.size!=-1)			{			end = chunkData.position+chunkData.size;			if(end<position+length)				{				length=end-position;				err = (length<0) ? -1 : (length==0) ?  1 : 0;				readIt = err ? FALSE : TRUE;				if(err)					;//VPlaySound(beepSound);				}			}		if(readIt)		{//if readit		// Setup the vars for DEcrypting From the buffer. See VIO and VFILEWIN	//gjr Oct24,94		dataFrom=(char huge *)workBuf;		dataTo  =(char huge *)buf;		posKey  =position;	 		while (lenRemain > 0)			{			lenXferd  = min(lenRemain, sizeWorkBuf);			lenFiled += fread(workBuf,1,lenXferd,file);			// The following copy/xxcrypt code is mostly direction independent. See VIO and VFILEWIN.			writepos = (char *)dataTo;			readpos = (char *)dataFrom;			if((OFFSETOF(writepos) < OFFSETOF(writepos + lenXferd)) &&			  (OFFSETOF(readpos) < OFFSETOF(readpos + lenXferd)) &&			  (lenXferd < 0x00010000L))				{				if(cryptOn){DeCrypt(writepos,readpos,lenXferd,posKey);}				else					{					if(lenXferd>8){Vmemcpy(writepos,readpos,lenXferd);}					else {for(i=0; i<lenXferd; i++, readpos++, writepos++){*writepos = *readpos;}}	       	     	}				}			else				{  // use huge ptrs byte by byte to avoid seg crossing problems				if(cryptOn)					{					for (i=0;i<lenXferd;i++)						{						DeCrypt(&dataTo[i], &dataFrom[i], 1, posKey+i);		                }					}				else		        	{					for(i=0;i<lenXferd;i++)dataTo[i] = dataFrom[i];		            }				}			dataTo    += lenXferd;			posKey    += lenXferd;			lenRemain -= lenXferd;			}		}//if readit		}	if(!err) err = (lenFiled!=length) ? 1 : 0;	if(!err) position+=length;	return err;	}intV_File::IOPosition(void *buf,long length,long mark)	{	OSErr err;	err =IOSetPosition(mark);	if(!err)err=IOData(buf, length);	return err;	}intV_File::IOLength(long *length)	{	OSErr err;	long current;	current = ftell(file);	err = fseek(file,0,SEEK_END);	*length = ftell(file);    err = fseek(file,current,SEEK_SET);	return err;	}intV_File::IOSetPosition(long loc)	{	OSErr	err;	err = fseek(file,loc,SEEK_SET);    position=loc;	return err;	}int V_File::IOSetLength(long loc) { return 1; }intV_File::Delete()	{	OSErr err;	string	tName[256];	if (strlen(fileExt))		sprintf(tName, "%s.%s", filname, fileExt);	else		sprintf(tName, "%s",filname);	err = remove(tName);	return err;	}intV_File::Rename(strPtr str)	{	OSErr err;	string	oldName[256], newName[256];		int i;		// jca 8 aug 93        if (strlen(fileExt))        {                sprintf(oldName, "%s.%s", filname, fileExt);                sprintf(newName, "%s", str);               // jca 8 aug 93                }        else        {                sprintf(oldName, "%s",filname);                sprintf(newName, "%s",str);                }        err = rename(oldName, newName);	/* set the proper name for the file */            // jca 8 aug 93	SetName(newName);    // set the file name	// set the file extension, if weird	for (i = 0; i < strlen(newName); i++)    	{		if (newName[i] == '.')			{			if (++i < strlen(newName))            	{				strcpy(fileExt, &newName[i]);				validated |= USE_EXTENSION;                }            } 		}		return err;    }#define COPYBLOCK 1024LintV_File::Copy(V_File *fromFile)	{	OSErr err = 0;	long length,clength;	Handle hBuffer;	char *buffer;	int olddir;	HLock((ObjectHandle)this);	olddir=fromFile->direction;	/* get the current file information */	memcpy(fname,filname,64);	IOSetDirection(DATA_OUT);	err=Open(TRUE);/*create the new file name*/	fromFile->IOSetDirection(DATA_IN);	if(!err)err=fromFile->Open(FALSE);	if(!err)err=fromFile->IOLength(&length);	if(!err)		hBuffer=NewHandle(COPYBLOCK);	if(!hBuffer)err=-1;	if(!err)		{  	  	HLock(hBuffer);    	buffer = HDeref(hBuffer);		while(err==noErr && length>0)			{			clength=min(COPYBLOCK,length);			err=fromFile->IOData(buffer,clength);			if(!err)err=IOData(buffer,clength);			length-=COPYBLOCK;			}		HUnlock(hBuffer);    	}	Close();	fromFile->Close();	if(err)Delete();	if(hBuffer)DisposHandle(hBuffer);	fromFile->direction=olddir;	HUnlock((ObjectHandle)this);	return err;	}int V_File::Used() {return used; }int V_File::ReadOnly() { return read_only; }int V_File::Stationery() { return stationery; }void V_File::SetNewFlag(int flag) { newflag=flag; }int V_File::GetNewFlag() { return newflag; }int V_File::GetVolume() { return(0); }void V_File::SetVolume(int vnum) { }void V_File::SetRelative(V_File *relative) { relativeFile=relative; }void V_File::SetFork(int fork) { }void V_File::FinderFlags(int bundle) { }intV_File::IOInsert(long loc,long size)	{	int oldDirection=IODirection();	V_Array *inOut;	long location,length,stub;	if(size==0)return 0;   // what does this MEAN??? V_IO::IOInsert always returns 0 jca 10JAN93	IOLength(&length); /*how long is this sucker?*/	IOSetLength(length+size);	if(loc==length)return 0; // what does this MEAN??? V_IO::IOInsert always returns 0 jca 10JAN93	inOut=new(V_Array);	inOut->cArray(size,1,size);/*create our temporary buffer*/	location=length-size;	while(location>loc)		{		/*read the data in*/		IOSetPosition(location);		IOSetDirection(DATA_IN);		inOut->IO(this);			/*write the data back out at the new location*/		IOSetPosition(location+size);		IOSetDirection(DATA_OUT);		inOut->IO(this);		location-=size;		}	stub=location+size-loc;/*this is all that is left to move*/	if(stub)/*anything there?*/		{		inOut->SetLength(stub);/*this is all we need*/		IOSetPosition(loc);/*set at the beginning of the last bit*/		IOSetDirection(DATA_IN);		inOut->IO(this);			IOSetPosition(loc+size);		IOSetDirection(DATA_OUT);		inOut->IO(this);		}	/*clean up after we are done*/	IOSetDirection(oldDirection);	inOut->dArray(); 		return(0);	// V_IO::IOInsert always returns 0, so we'll do it here, too.  jca 10JAN93	}intV_File::IODelete(long loc,long size)	{	int oldDirection=IODirection();	V_Array *inOut;	long location,length,stub;	if(size==0)return 0;  // what does this MEAN??? V_IO::IODelete always returns 0 jca 10JAN93	IOLength(&length); /*how long is this sucker?*/	if(loc+size==length)		{		IOSetLength(length-size);		return 0;      // what does this MEAN??? V_IO::IODelete always returns 0 jca 10JAN93		}	inOut=new(V_Array);	inOut->cArray(size,1,size);/*create our temporary buffer*/	location=loc+size;	while(location+size<length)		{		/*read the data in*/		IOSetPosition(location);		IOSetDirection(DATA_IN);		inOut->IO(this);		/*send the data back out in the new location*/		IOSetPosition(location-size);		IOSetDirection(DATA_OUT);		inOut->IO(this);		location+=size;		}	/*clean up after we are done*/	stub=length-location;	if(stub)/*anything left to transfer?*/		{		IOSetPosition(location);		inOut->SetLength(stub);		IOSetDirection(DATA_IN);		inOut->IO(this);			/*send the data back out to the new location*/		IOSetPosition(location-size);		IOSetDirection(DATA_OUT);		inOut->IO(this);		}	IOSetLength(length-size);	IOSetDirection(oldDirection);	inOut->dArray();		return(0);	// V_IO::IODelete always returns 0, so we'll do it here, too.  jca 10JAN93	}/*------------------------------------------------------------------------------// GetFullPath has been rehacked to match the new GetFullPathStr method// on the mac. *------------------------------------------------------------------------------*/int	V_File::GetFullPathStr(char *str)				//GJR 10/07/93{	int	anyErr = noErr;	if (validated&USE_EXTENSION)		sprintf(str, "%s%s.%s", path, filname, fileExt);	else		sprintf(str, "%s%s", path, filname);	if (!strlen(filname))	anyErr = -1;	// must have a filname	return(anyErr);}/*------------------------------------------------------------------------------ * int V_File::GetLocation(VfsLocation *vfsLocation_ptr) * private int V_File::GetLocation(char *directory, char *name, char *fExt) * This finds the actual location of the file for other applications. This * assumes that the location of the file is well understood. *		added Vfs structure				//GJR 10/06/93 *------------------------------------------------------------------------------*/int V_File::VGetLocation(VfsLocation *vfsLocation_ptr){OSErr err;	err = GetLocation((vfsLocation_ptr->path),	                  (vfsLocation_ptr->name),	                  (vfsLocation_ptr->extension) );	return (err);}int V_File::GetLocation(char *directory, char *name, char *fExt){strcpy(name, filname);strcpy(directory, path);strcpy(fExt, fileExt);return(0);}/*------------------------------------------------------------------------------ * int V_File::VSetLocation(VfsLocation *vfsLocation) * int V_File::SetLocation(char *directory, char *name, char *fExt) * This indicates the actual location of the file and will find the file.  It uses  * whatever data you pass it and assumes the rest is already set somehow. * If it returns 0, then the file was found. * * Contents of VfsLocation Structure							//GJR 10/06/93 * NOTE: The Innards of VfsLocation are ONLY to be touched by VFILE routines. * char *name; *		the name of the file. * char *directory;  *		path to this file  * char *fExt;   *		file extension *	modded to use VfsLocation; Platform independent.			//GJR 10/06/93 *------------------------------------------------------------------------------*/int V_File::VSetLocation(VfsLocation *vfsLocation){OSErr err = 0;	err = SetLocation(vfsLocation->path,	                  vfsLocation->name,					  vfsLocation->extension);	return (err);} int V_File::SetLocation(char *directory, char *name, char *fExt){int len;	// jca 6 Oct 93strcpy(filname, name);SetName(name);strcpy(path, directory);strcpy(fileExt, fExt);if ((fExt) && (fExt[0] != NULL))	validated |= USE_EXTENSION;          // validatelen = strlen(path);if ((len > 1) && (path[len - 1] != '\\'))    // there must be a '\' at the end of the path	strcat(path, "\\");return(0);}/*------------------------------------------------------------------------------ * int V_File::VIsSameLocation(VfsLocation *vfsLocation_ptr) * Says if the provided location matches the current files location. *		added 			//GJR 10/06/93 *------------------------------------------------------------------------------*/int V_File::VIsSameLocation(VfsLocation *testLocation){int matches = FALSE;VfsLocation *myVfsLocation;	myVfsLocation = new(VfsLocation);	myVfsLocation->cVfsLocation();	VGetLocation(myVfsLocation);	if ( (strcmp(myVfsLocation->path,testLocation->path)==0)	  && (strcmp(myVfsLocation->name,testLocation->name)==0)	  && (strcmp(myVfsLocation->extension, testLocation->extension)==0) )		{		matches = TRUE;		}    myVfsLocation->dVfsLocation();	return (matches);}/*------------------------------------------------------------------------------ * int VfsGetLocationFType(VfsLocation *vfsLocation, LongPtr type_ptr) * Finds the FileType of the provided VfsLocation. *		added 			//GJR 10/06/93 *------------------------------------------------------------------------------*/int VfsGetLocationFType(VfsLocation *vfsLocation, LongPtr type_ptr){OSErr err = noErr;#if 0		*type_ptr = '??';		//init to ?what? in case nothing found.		if (validated&USE_EXTENSION)			{			if (!type)				{				/* this is the best guess about the file type */				/* or is it 	type = (long)vfsLocation.extension; */				type = MakeID(vfsLocation->extension[0],vfsLocation->extension[1],				              vfsLocation->extension[2],vfsLocation->extension[3]);				}			}#endif			if (vfsLocation->extension[0])				{  // if a non-null extension, then try it. else null				*type_ptr = MakeID(vfsLocation->extension[0],vfsLocation->extension[1],				              vfsLocation->extension[2],vfsLocation->extension[3]);				}		return (err);}/*------------------------------------------------------------------------------ * int VfsGetLocationFName(VfsLocation *vfsLocation, CharPtr name) * Finds the FName of the provided VfsLocation. *		added 			//GJR 10/06/93 *------------------------------------------------------------------------------*/int VfsGetLocationFName(VfsLocation *vfsLocation, CharPtr name){OSErr err = noErr;	strcpy(name, vfsLocation->name);	strcat(name, vfsLocation->extension);	return (err);}/*------------------------------------------------------------------------------ * int VfsIsSameLocation(VfsLocation *, VfsLocation_t *) * Says if the provided location matches the current files location. *		added 			//GJR 10/06/93 *------------------------------------------------------------------------------*/int VfsIsSameLocation(VfsLocation *oneLocation, VfsLocation *twoLocation){int matches = FALSE;	if ( (strcmp(oneLocation->path,twoLocation->path)==0)	  && (strcmp(oneLocation->name,twoLocation->name)==0)	  && (strcmp(oneLocation->extension, twoLocation->extension)==0) )		{		matches = TRUE;		}	return (matches);}/*------------------------------------------------------------------------------ * int VfsGetBogusLocation(VfsLocation *) * Put out a bogus location *		added 			//GJR 10/06/93 *------------------------------------------------------------------------------*/int VfsGetBogusLocation(VfsLocation *vfsLocation_ptr){OSErr err = noErr;	vfsLocation_ptr->name[0]      = 0;	vfsLocation_ptr->extension[0] = '..';	vfsLocation_ptr->extension[4] = 0;	vfsLocation_ptr->path[0]      = 0;	return (err);}//JAM 23July94 [[[/*------------------------------------------------------------------------------ * int VfsIsVirtusModel(VfsLocation) * See if file is virtus type, i.e. .vvr, .wlk, or .wtp *		added 			//JAM 4/23/94 *------------------------------------------------------------------------------*/int VfsIsVirtusModel(VfsLocation *location){	long FType;	VfsGetLocationFType(location, &FType);	if(FType == appFileTypeProModel) return(TRUE);	if(FType == appFileTypeVWTModel) return(TRUE);	if(FType == appFileTypeVRModel) return(TRUE);		return (FALSE);}/*------------------------------------------------------------------------------ * int VfsFindAllFilesInDir(VfsLocation, ULong, V_Array *) * finds all files of a certain type in a directory, puts in varray *		added 			//JAM 4/23/94 *------------------------------------------------------------------------------*/int VfsFindAllFilesInDir(VfsLocation *directory, ULong fileType,						 V_Array *fileList){int i;int err = noErr;char str[256], str2[256];#if MACINTOSH// no code yet.  Mac me, Drew!!!#elif WINDOWSchar searchStr[256], winFileType[4], *ft;struct ffblk	ickyDosBlk;       // icky DOS thingVfsLocation *vfsLocation;	ft = (char*) &fileType;	winFileType[0] = ft[3];	winFileType[1] = ft[2];	winFileType[2] = ft[1];	winFileType[3] = ft[0];	if (!fileList)	{		// ELVIS		// Do the Error handling thing, baby.  One, two, three.. kick!		return(-1);    }	// find the gallery dir.  Error if it isn't there.    // icky DOS thing  {	memset(&ickyDosBlk, 0, sizeof(struct ffblk));	err = findfirst(directory->path, &ickyDosBlk, FA_DIREC);    if (err)	{		// ELVIS  (error processing)	}	// icky DOS thing  {	sprintf(searchStr, "%s\\*.%s", directory->path, winFileType);	// find the first file in the directory	err = findfirst(searchStr, &ickyDosBlk, NULL);  // icky DOS call	while (err == noErr)	{	V_File *vf;    char  anFName[64];						strcpy(str, &(ickyDosBlk.ff_name[0]));		strcpy(str2, str);					// strip the file ext		i = strlen(str2)-1;		while(i > 0 && str2[i] != '.')			str2[i--] = 0x0;		if (i > 0) str2[i] = 0x0;		else strcpy(str2, str);		vf = new(V_File);		vf->cFile(REFERENCE, 0L, 0L, "", "");		vf->SetName(str2);   	// this will validate the name//		vf->SetLocation(directory->path, str2, winFileType);		vfsLocation = new(VfsLocation);        vfsLocation->cVfsLocation();		strcpy(vfsLocation->path, directory->path);		strcpy(vfsLocation->name, str2);		strcpy(vfsLocation->extension, winFileType);		vf->VSetLocation(vfsLocation);        vfsLocation->dVfsLocation();		err = vf->Find();							fileList->Append(&vf);		if (!err)   // get next file name		{  // icky DOS call            err = findnext(&ickyDosBlk);        }	}	// } end icky DOS thing	return(VA_Length(fileList));#endif // MACINTOSH}/*------------------------------------------------------------------------------ * int VfsGetListOfTextures(V_Array *) * gets a list of texture files from the user *		added 			//JAM 4/23/94 *------------------------------------------------------------------------------*/#define FILELISTSTRINGLENGTH 8192int VfsGetListOfTextures(V_Array *filelist){	OSErr err = 0;   // initialize err to NULL  jca 29 jan 93	long *theList;	int numtypes=1;	Point loc;	char filterDescriptions[256];    V_Array *fullPathVA;	char *fullPath;	//list is returned here.  how big?	char	*filtPatDes;	V_Document	*theDoc;	HWND		theOwner;    long ParentWindowLong;	//JAM Jun94 to make parent window be reselected after find	char fname[256];	VfsLocation *vfsLocation, *vfsLocation2;	long i,j;	fullPathVA = new(V_Array);	fullPathVA->cArray(FILELISTSTRINGLENGTH, sizeof(char), 8);	fullPath = (char *)fullPathVA->Use();	VSetCursor(vCursorArrow);/*	filtPatDes = (char *) filters->Use();	for (i = 0; i < VA_Length(filters); i++)		{		if (filtPatDes[i] == '|')	filterDescriptions[i] = '\0';		else						filterDescriptions[i] = filtPatDes[i];        }	filterDescriptions[i] = '\0';	filters->Unuse();*/	filterDescriptions[0] = '\0';/*	memset(fullPath, 0, 256);	sprintf(fullPath, "*.%s", defFileExt);*/	fullPath[0] = '\0';	fname[0] = '\0';//	strcpy(fullPath, "*.bmp;*.vvr;*.wtp;*.wlk");	strcpy(filterDescriptions,TEXTUREFILTERSTRING);	j=strlen(filterDescriptions);	for(i=0;i<j;i++)	{		if(filterDescriptions[i] == '|') filterDescriptions[i] = '\0';    }	memset(&of,0,sizeof(OPENFILENAME));	of.lStructSize=sizeof(OPENFILENAME);//JAM Jun94 to make parent window be reselected after find [[[				of.hwndOwner=GetMainFrameWindow(); //This probably needs to be the doc window//	ParentWindowLong = SendMessage(0,WM_MDIGETACTIVE,0,0);// 	of.hwndOwner = LOWORD(ParentWindowLong);//JAM Jun94 to make parent window be reselected after find ]]]	of.lpstrFilter=filterDescriptions;	of.nFilterIndex=1;	of.lpstrFile=(LPSTR)fullPath; //path;	of.nMaxFile=fullPathVA->ALength();	of.lpstrFileTitle=fname;	of.nMaxFileTitle=sizeof(fname);//	if (strlen(path))//		of.lpstrInitialDir= path;	of.lpstrInitialDir = NULL;//	of.lpstrTitle= qStr; //"Open WalkThrough Model";	of.lpstrTitle= TXTT_ADDTEXTURES; //"Open WalkThrough Model";//	of.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST/*|OFN_CREATEPROMPT*/;	of.Flags = OFN_ALLOWMULTISELECT | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST/*|OFN_CREATEPROMPT*/;/*	of.lpfnHook = OFPositionHookProc;	of.Flags |= OFN_ENABLEHOOK;	if(newflag)		{		of.Flags |= OFN_ENABLEHOOK;		of.lpfnHook = OFNHookProc;        newFlag = TRUE;		}*///	of.lpstrDefExt= defFileExt;	err = GetOpenFileName(&of) ? FALSE : TRUE;	if(err)	{		fullPathVA->Unuse();		fullPathVA->dArray();        return(err);	}	j = strlen(fullPath);	for(i=0;i<j;i++)    {		if((fullPath[i] >= 'a') && (fullPath[i] <= 'z'))		{			fullPath[i] -= 'a';			fullPath[i] += 'A';		}	}	vfsLocation = new(VfsLocation);    vfsLocation->cVfsLocation();	for(i=0;(fullPath[i] != ' ') && (fullPath[i] != '\0');i++)	{    	vfsLocation->path[i] = fullPath[i];	}	vfsLocation->path[i] = '\0';	//this section is to handle a Windows bug.  If the multiselect	//returns only one file, there still should be a space between	//the path and the filename, but there is not.	if(fullPath[i] == '\0')	{		for(i--;fullPath[i] != '\\';i--);		fullPath[i] = ' ';		vfsLocation->path[i] = '\0';	}	while(fullPath[i] != '\0')	{		i++;		for(j=0;fullPath[i] != '.';i++,j++)		{        	vfsLocation->name[j] = fullPath[i];		}        vfsLocation->name[j] = '\0';        i++;		for(j=0;(fullPath[i] != ' ') && (fullPath[i] != '\0');i++,j++)		{			vfsLocation->extension[j] = fullPath[i];		}		vfsLocation->extension[j] = '\0';		vfsLocation2 = new(VfsLocation);		vfsLocation2->cVfsLocation();        *vfsLocation2 = *vfsLocation;		filelist->Append(&vfsLocation2);    }//	if(newflag && newFlag)err=TRUE;//    else newflag=FALSE;//	if(err) break;	vfsLocation->dVfsLocation();	fullPathVA->Unuse();	fullPathVA->dArray();    return(err);}//JAM 23July94 ]]]/*------------------------------------------------------------------------------ * int V_File::IO(V_Buffer *buf) * This method is used to read and write this files reference data to or from * the V_Buffer *buf.  This allows us to find this file later if it contains  * data that another file may have use for.  For example, a 3D model might have * PICT images or QuickTime movies mapped to the surfaces.  Rather than saving * this information with the model, we only save a reference to it with the * model.  The order of importance of this information is as follows: * If System 7.0 was used and is being used now, use the alias manager.  Otherwise * use the realVRefNum and realDirID data.  If this fails as well, then we need * to resort to the full path name.  This might be necessary if there was a full * backup of the relevent files.  This also may fail if the folder containing the * files has been moved around, so the final method is to use a relative path, * assuming we know where the relevent related file is located!  The data is  * stored as follows: *  * 	file name *	chunk 'ALIS' *		file alias handle - requires system 7.0 to use, but it is the preferred method. *	chunk 'REFR' *		standard directory and volume reference numbers. * 	chunk 'FPTH' * 		file path name. *		index into file path name. *		reference path to index. * *------------------------------------------------------------------------------*/#define IFF_PATH 	MakeID('F','P','T','H')#define IFF_ALIAS 	MakeID('A','L','I','S')#define IFF_REFR	MakeID('R','E','F','R')int V_File::IO(V_Buffer *buf){OSErr err = 0;int aliasLength;	long directory;short volume;int i;char name[64], testPath[256], fExten[5];char relExten[5], relName[64];      // jca 20OCT94 for the relative path stuff, PROV_Array *path1,*path2;int plength;pathMember *pdata;short i1,i2;memset(name, 0, sizeof(name));memset(testPath, 0, sizeof(testPath));memset(fExten, 0, sizeof(fExten));if(buf->IODirection()==DATA_OUT)	{				 -	/*-----------------Get the needed information for the next sections*/	GetLocation(testPath, name, fExten);	if (strlen(fExten))		sprintf(fname, "%s.%s", name, fExten);	else    	strcpy(fname, name);	C2Pstr(fname);#if 0	/*-----------------first, is there System 7.0 alias reference information available?*/	if(alias)/*everything worked out just fine*/		{		/*save the alias handle here*/		buf->OpenChunkW(IFF_ALIAS);		aliasLength=GetHandleSize(alias);		buf->IOType(&aliasLength,IO_LONG);		HLock(alias);		buf->IOData(*alias,aliasLength);		HUnlock(alias);		buf->CloseChunk();		}	/*---------------------second, WRITE the dirID and the vRefNum*/		{		/*the vRefNum is a short and the file name is a pString*/		buf->OpenChunkW(IFF_REFR);		/*Save the file name*/		buf->IOType(name,IO_PSTRING);		buf->IOType(&directory,IO_LONG);		buf->IOType(&volume,IO_SHORT);		buf->CloseChunk();		}#endif	/*-----------------third, save the absolute file location*/	if(path1=PathName(testPath))		{		buf->OpenChunkW(IFF_PATH);		buf->IOType(fname,IO_PSTRING);		plength=path1->ALength();		buf->IOType(&plength,IO_SHORT);		pdata=(pathMember*)path1->Use();		for(i=0;i<plength;i++)			buf->IOType(pdata[i],IO_PSTRING);		path1->Unuse();		/*-----------------fourth, is there a related file? This is to generate a relative path.*/		plength=0;		if(relativeFile)			{			memset(name, 0, 64);			memset(testPath, 0, 256);			memset(fExten, 0, 5);			relativeFile->GetLocation(testPath, name, fExten);			if(path2=PathName(testPath))				{				pathMember pm1,pm2;				i1=path1->ALength();				i2=path2->ALength();								do	{					path1->Get(i1-1,&pm1);					path2->Get(i2-1,&pm2);					if(0==memcmp(pm1,pm2,max(pm1[0],pm2[0])))						{						i1--;						i2--;						}					else break;					}while(i1>0 && i2>0);				/*now i1 is the index into path1 where the relative file					trees off*/				buf->IOType(&i2,IO_SHORT);				buf->IOType(&i1,IO_SHORT);				pdata=(pathMember*)path1->Use();				for(i=0;i<i1;i++)					buf->IOType(pdata[i],IO_PSTRING);				path1->Unuse();				path2->dArray();				}			}		else buf->IOType(&plength,IO_SHORT);		path1->dArray();		buf->CloseChunk();		}			}else if(buf->IODirection()==DATA_IN)	{	int found=FALSE;	int notDone=TRUE;		query=REFERENCE;	while(notDone && !found)		{		long id=buf->OpenChunkR();		if(id==0)break;		switch(id)			{			case IFF_PATH:				if(!found)					{					buf->IOType(name,IO_PSTRING);					buf->IOType(&plength,IO_SHORT);					path1=new(V_Array);					path1->cArray(plength,sizeof(pathMember),4);					pdata=(pathMember*)path1->Use();					for(i=0;i<plength;i++)						buf->IOType(pdata[i],IO_PSTRING);					path1->Unuse();					/*first, let's check to see if the file is where it used to be*/					if(0==(err=ParsePathName(path1, testPath, name, fExten)))						if(0==(err=SetLocation(testPath, name, fExten)))							{							path1->dArray();							found=TRUE;							}					/*Our last hope is that there is a relative file and that					  our file is in the same location relative to this file*/					if(!found)						{						if(relativeFile)/*we know where the relative file is*/							{							buf->IOType(&i1,IO_SHORT);							buf->IOType(&i2,IO_SHORT);							path2=new(V_Array);							path2->cArray(i2,sizeof(pathMember),4);							pdata=(pathMember*)path2->Use();							for(i=0;i<i2;i++)								buf->IOType(pdata[i],IO_PSTRING);							path2->Unuse();							if (path1) path1->dArray();							memset(testPath, 0, 256);							memset(relName, 0, 64);     // jca 20OCT94 zap the relative name, not the real one							memset(relExten, 0, 5);     // jca 20OCT94 zap the relative exten, not the real one							relativeFile->GetLocation(testPath, relName, relExten);   // jca 20OCT94 we will be throwing the relative name and extension away							path1 = PathName(testPath);							memset(testPath, 0, 256);							C2Pstr(name);							if(0==(err=ParseRelativePath(path1,path2,i1, testPath, name, fExten)))								if(0==(err=SetLocation(testPath, name, fExten)))									{									found=TRUE;									}							path2->dArray();							}						path1->dArray();						}					}				notDone=FALSE;				break;			default: break;			}		buf->CloseChunk();		}	if(!found)		{		// jca 20OCT94 PRO if we have not found the file, then we should set the		// name and extension.  This is an artifact of the way we do it on the Mac;		// when we seek the file in the IFF_REFR chunk, we set the file name.  Because		// there can be no IFF_REFR chunks under Windows, we must set this manually.		// We can feel safe about it because -- although the path might change -- the        // filename should remain the same. [[[		memset(testPath, 0, sizeof(testPath));		SetLocation(testPath, name, fExten);		err=fileNotFoundErr;		// jca 20OCT94 PRO ]]]		}	/* got to set the file type */	if (!type)		{		/* this is the best guess about the file type */        type = MakeID(fileExt[0],fileExt[1],fileExt[2],fileExt[3]);		}	}else return err;return err;}// JAM 7-18-94 to help handle embedding/file refs for textures[[[#if VPROshortV_File::GetEmbedTextures(void){	return(EmbedTexturesFlag);}voidV_File::SetEmbedTextures(short newvalue){	EmbedTexturesFlag = newvalue;}#endif// JAM 7-18-94 to help handle embedding/file refs for textures]]]V_Array *PathName(char *path){V_Array *pathN;pathMember pm;int i, length, last;pathN=new(V_Array);pathN->cArray(0,sizeof(pathMember),4);memset(&pm, 0, sizeof(pathMember));length = strlen(path);/* two things to watch for under windows/dos:	-- path[length - 1] will be either < 0 or a '\'	-- a ":\" substring occurs after the drive letter*/	 for (i = length-2, last = length-1; i >= 0; i--)	{	if (path[i] == '\\')		{        strncpy(pm, &path[i+1], last - i-1); 		C2Pstr(pm);		pathN->Append(&pm);		memset(&pm[0], 0, sizeof(pathMember));        last = i;		}	else if (path[i] == ':')    	last = i; 	}if (length > 1) 	/* clean up */	{	strncpy(pm, &path[0], last);	C2Pstr((char *)&pm);	pathN->Append(&pm);    }return pathN;}int ParsePathName(V_Array *pathN, char *newPath, char *fName, char *fExt){OSErr err = 0;int i,len=pathN->ALength();pathMember pm;char	tempFName[256];FILE  	*f;if (len)	{	pathN->Get(len - 1, &pm);    P2Cstr((char *)&pm);	strcat(newPath, (char *)&pm);	strcat(newPath, ":\\");    }for (i = len-2; i >= 0; i--)	{	pathN->Get(i, &pm);	P2Cstr((char *)&pm);	strcat(newPath, (char *)&pm);	strcat(newPath, "\\");	}/* parse the name */P2Cstr(fName);for (i = 0; i < strlen(fName) && fName[i] != '.'; i++)	{	}if ((i+1 < strlen(fName)) && (fName[i] == '.'))	{	strcpy(fExt, &fName[i+1]);	fName[i] = '\0';    }if (strlen(fExt))	sprintf(tempFName, "%s%s.%s", newPath, fName, fExt);else	sprintf(tempFName, "%s%s", newPath, fName);if (!(f = fopen(tempFName, "rb")))	err = fileNotFoundErr;else	fclose(f);return err;}int ParseRelativePath(V_Array *path1,V_Array *path2,int index,char *newPath, char *name, char *fExt){OSErr err = 0;int i,len;pathMember pm,pm2;len=path1->ALength();for (i = index; i < len; i++)	{	path1->Get(i, &pm);    path2->Append(&pm);	}err = ParsePathName(path2, newPath, name, fExt);return err;}voidVfsLocation::cVfsLocation(){}voidVfsLocation::dVfsLocation(){	delete this;}voidVfsLocation::CopyVfsLocation(VfsLocation *newvfs){	*this = *newvfs;}