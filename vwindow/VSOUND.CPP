/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Platform: 	MACINTOSH 	X	DAS *				WINDOWS		X	MJU * Notes:  * This little package implements the sound manager routines via the * err=SndDoCommand(sndChan,&sndCmd,FALSE) function (see Sound Mgr docs). * * This system is used by first calling SoundInit() at the beginning of the * program.  This initializes the space required for the sound channel.  * * Next use LoadSound(sNum) (or an equivalent) to read in the sound resource * into a handle. * * To play the sound call SoundFX(soundHandle,0L).  This will simply play * the sound and then terminate. *  * If you wish to specify a completion routine you may call * SoundFX(soundHandle, CompletionRoutine).  After the sound has completed, * it will make a call to the user defined completion code.  Declare it as * pascal void CompletionRoutine(). * * To play continuous sounds is a little beyond the scope of this system.  To * extend it, you must have a second sound channel ready to go and make a  * call directly to the SndDoCommand() function via the user defined * CompletionRoutine(): * * You need to clean up the second sound channel yourself but NOT INSIDE THE * SOUND COMPLETION ROUTINE!  Set a flag that indicates the the completion routine * has terminated and then reset the sound channel by: *	SndDisposeChannel(sndChan,TRUE); *  err=SndNewChannel(&sndChan, 0 , initMono, SoundCallBack); * * Needless to say, do not allocate any memory or call any functions that move * memory around from inside the user defined CompletionRoutine().  This is  * guarenteed to cause days of bewilderment and aggravation. * * NOTE: This code currently only handles type 1 format sounds.  Need to do the math * for the type 2's. Note also that the algorithm in the Sound Manager docs for * computing the offsets of the beginning of the sound for format 1 is WRONG * (see bottom page 11).  It should read: * offset = 6 + (number of synth/mods *6) + (number of cmds * 8) * History:  *------------------------------------------------------------------------------ */ #include "VTypes.h"#include "VSound.h"int soundOn = TRUE;#if WINDOWS#define BEEP_SOUND -1#endif // WINDOWS#if MACINTOSH#include <Sound.h>// In case we don't have the universal headers...	#ifndef NewSndCallBackProc		#define NewSndCallBackProc(x) (ProcPtr)x	#endif#endif // MACINTOSH// jca 9 Oct 93			made these cross-platformHandle clickSoundRsrc = NULL;Handle bumpSoundRsrc = NULL;		// MERGE18Handle crashSoundRsrc = NULL;		// MERGE26#define CLICK_SOUND 128#define BUMP_SOUND 129		// MERGE18#define CRASH_SOUND 130		// MERGE26#if WINDOWS#include <mmsystem.h>void	*clickSnd = NULL;void    *bumpSnd = NULL;HINSTANCE GetAppInstance(void);intSoundInit(void)	{        // jca 9 Oct 93 { 	OSErr	err = 0;	HRSRC	rClick, rBump;    // find the sounds.  They are now in the resource area.  Isn't Windows(tm) wonderful?	rClick = FindResource(GetAppInstance(), (LPCSTR)MAKELONG(CLICK_SOUND, 0), (LPCSTR)"snd");	rBump = FindResource(GetAppInstance(), (LPCSTR)MAKELONG(BUMP_SOUND, 0), (LPCSTR)"snd");	if (rClick)		clickSoundRsrc = (Handle)LoadResource(GetAppInstance(), rClick);	if (rBump)		bumpSoundRsrc = (Handle)LoadResource(GetAppInstance(), rBump);	clickSnd = LockResource((HGLOBAL)clickSoundRsrc);	bumpSnd = LockResource((HGLOBAL)bumpSoundRsrc);    		return(err);	}   // jca 9 Oct 93 }voidVPlaySound(int soundType)	{	if(!soundOn)return;		switch(soundType)		{		case clickSound:			// the click ain't a beep, as DWE would say.			if (clickSnd)	sndPlaySound((LPSTR)clickSnd, SND_ASYNC | SND_MEMORY);			break;		case bumpSound:        // the bump ain't a beep, either.			if (bumpSnd)	sndPlaySound((LPSTR)bumpSnd, SND_ASYNC | SND_MEMORY);			break;		case beepSound: 		default: MessageBeep(BEEP_SOUND);  break;		}	}voidSoundEnd(void){int err1, err2;	UnlockResource((HGLOBAL)clickSoundRsrc);	UnlockResource((HGLOBAL)bumpSoundRsrc);	if (clickSoundRsrc)		err1 = FreeResource((HGLOBAL)clickSoundRsrc);	if (bumpSoundRsrc)		err2 = FreeResource((HGLOBAL)bumpSoundRsrc);	// if (err1 || err2)	// 	Be veryDisappointed;}#endif //WINDOWS#if MACINTOSHvoidVPlaySound(int soundType)	{	if(!soundOn)return;		switch(soundType)		{		case clickSound: if(clickSoundRsrc)SoundFX(clickSoundRsrc,NULL);  break;		case bumpSound: if(bumpSoundRsrc)SoundFX(bumpSoundRsrc,NULL);  break;		// MERGE18		case crashSound: if(crashSoundRsrc)SoundFX(crashSoundRsrc,NULL);  break;	// MERGE26		case beepSound: 		default: SysBeep(10);  break;		}	}pascal void SoundCallBack(SndChannelPtr theChan, SndCommand* theCmd);SndChannelPtr sndChan;	/*global sound channel*/Handle currentSound=0;	/*pointer to current sound handle*/void (*UserCallBack)(void);	/*user call back routine (if any)*/struct sModifier 		/*structs*/	{	int resID;	long init;	};	struct snd	{	int format;	int nSynthMod;	struct sModifier sMod[1];	int nSndCommand;	};/*------------------------------------------------------------------------------ * void pascal SoundCallBack() * * This is the 'real' call back function.  If the user specifies his own call back * it will actually be called from this function. *------------------------------------------------------------------------------ */	pascal void SoundCallBack(SndChannelPtr theChan, SndCommand* theCmd){long theA5;if(theCmd->param1==12345)	{	theA5=SetA5(theCmd->param2);/*restore the A5 to its original value*/	HUnlock((Handle)currentSound);		/*no longer needs to be a locked handle*/	currentSound=0;				/*clear the global for later use*/	if(UserCallBack)			/*any user callback routines to worry about?*/		(*UserCallBack)();			/*call the routine and then get outa here*/	SetA5(theA5);				/*clean up after ourselves*/	}}/*------------------------------------------------------------------------------ * int SoundInit() * * This function is called by the user to set up the sound channel.  It should  * only be called once at the beginning of the program. *------------------------------------------------------------------------------ */int SoundInit(void){OSErr err=0;Handle sndInit;#if 0 		// MERGE-SOUND/*create the sound channel pointer*/sndChan=(SndChannelPtr) NewPtrClear(sizeof(SndChannel));if(sndChan!=0)	{	sndChan->qLength=stdQLength; 	/* possible Sound Mgr bug fix */	sndChan->userInfo=0x7FFFFFFF;/*	err=SndNewChannel(&sndChan, 0 , initMono, SoundCallBack);*/	}#endif 		// MERGE-SOUNDclickSoundRsrc=LoadSound(CLICK_SOUND); bumpSoundRsrc=LoadSound(BUMP_SOUND); 		// MERGE18crashSoundRsrc=LoadSound(CRASH_SOUND); 		// MERGE26return err;}void SoundEnd(void){SndCommand sndCmd;return;/*this stuff is ignored now */if(sndChan)	{	sndCmd.cmd=quietCmd;	sndCmd.param1=sndCmd.param2=0;	SndDoImmediate(sndChan,&sndCmd);	SndDisposeChannel(sndChan,TRUE);	}}/*------------------------------------------------------------------------------ * int SoundFX(Handle sndH, void (*callback)()) * Handle sndH; 			<---a sound handle * void (*callback)();		<---user defined callback routine.  Pass NULL (0L) if *								you are not using a call back. * This function is called by the user to play the sound in the sound handle. * The call back function is called when the function terminates. *------------------------------------------------------------------------------ */int SoundFX(Handle sndH, void (*callback)()){OSErr err;long offset;int nSynthMod;struct sModifier *sMod;struct snd * sndData1;SndCommand sndCmd;ProcPtr	procPtr;int i;	// ABD MERGE-SOUND [[[	// Instead of doing the totally moronic sound playing method of setting up a sound	// channel with lots of math, computing offsets, weird hex constants, callbacks	// that are extremely fragile and can't move memory and god knows what else, plus	// it doesn't work on the AV Macs properly, only to STUPIDLY sit in a 	// "while(currentSound);" loop which effectively makes all the work we did to set	// up asynchronous sound play TOTALLY POINTLESS, we just make call SndPlay which will	// do exactly the same thing only much less likely to be buggy and requires 4 lines of	// code instead of 2 pages of code. 	// If NIL is passed in as the first parameter (as we do below), then the last parameter 	// (which specifies asynch/synch sound play) is ignored, and the sound is played synchronously	// (that is, the sound finishes playing before we continue execution; I know that this	// is a blatant contradiction with the normal definition of "synchronous", which means	// "at the same time", so one would think that a "synchronous" sound plays at the same	// time other code is executing or something, but those computer scientists are a weird	// bunch, and so "synchronous" really means that the sound will *NOT* play at the same	// time as other code is exectuting.)	// Note that we ignore the callback parameter that is passed in so we don't have to	// screw around with A5 hassles.  	if (sndH)	{		HLock((Handle)sndH);			/* lock sound; can't play unlocked sounds! */        #ifdef __powerc //JAM 13JAN94 HACK because wouldn't compile 68xxx		#ifdef __PPCC__		SndPlay(NULL, sndH, TRUE);		/* play it syncronously (last param ignored) */		#else		SndPlay(NULL, (SndListHandle)sndH, TRUE);		/* play it syncronously (last param ignored) */		#endif // applec		#else		SndPlay(NULL, (SndListHandle)sndH, TRUE);	// ABD for 68K macs		#endif //__powerc 13JAN94 HACK because wouldn't compile 68xxx		HUnlock((Handle)sndH);			/* unlock it */	}	return 0;	// ABD MERGE-SOUND ]]]/*KillSound();				/* just kill the sound channel and restart*/if(sndH)					/* is it real?*/			{	sndChan->qLength=stdQLength; 	/* possible Sound Mgr bug fix */	sndChan->userInfo=0x7FFFFFFF;	err=SndNewChannel(&sndChan, 0 , initMono, NewSndCallBackProc(SoundCallBack));	HLock((Handle)sndH);			/* lock it to make sure it is still there*/	if(((struct snd*)(*sndH))->format==1)/*only deals with format 1 now*/		{		sndData1=(struct snd*)(*sndH);		/*calculate offsets and start adding the synths*/		nSynthMod=((int *)(*sndH))[1];		sMod=(struct sModifier *)&((*sndH)[4]);		procPtr = NULL;		for(i=0;i<nSynthMod;i++)			err=SndAddModifier(sndChan,(char *)procPtr,sMod[i].resID,sMod[i].init);				/*calulate the offset to the beginning of the actual sound*/				offset= 6 + sndData1->nSynthMod * 6 + sndData1->nSndCommand * 8;		}	else if(((struct snd*)(*sndH))->format==2)		{		/*not done yet*/		}	else return -1;		UserCallBack=callback;	/*start to play*/	sndCmd.cmd=bufferCmd;	sndCmd.param1=-12345;	sndCmd.param2=(long)&(*sndH)[offset];	err=SndDoCommand(sndChan,&sndCmd,FALSE);		currentSound=sndH;	if(!err)/*when we are done, then call back*/		{		sndCmd.cmd=callBackCmd;		sndCmd.param1=12345;		sndCmd.param2=SetCurrentA5();		err=SndDoCommand(sndChan,&sndCmd, FALSE);		}		while(currentSound);	sndCmd.cmd=quietCmd;	sndCmd.param1=sndCmd.param2=0;	SndDoImmediate(sndChan,&sndCmd);		SndDisposeChannel(sndChan,TRUE);	}return(err);}/*------------------------------------------------------------------------------ * Handle LoadSound(sNum) *------------------------------------------------------------------------------ */Handle LoadSound(int sNum){return GetResource('snd ', sNum);}/*------------------------------------------------------------------------------ * int KillSound() *------------------------------------------------------------------------------ */int KillSound(){SndCommand sndCmd;OSErr err=0;// MERGE-SOUND [[[// This routine can never be called with the new MERGE-SOUND sound code -- since we play// sounds syncronously, by the time the routine can be called the sound is already done.return err;		// MERGE-SOUND ]]]/*reinitialize the sound channel*/if(sndChan)	{	sndCmd.cmd=quietCmd;	sndCmd.param1=sndCmd.param2=0;	SndDoImmediate(sndChan,&sndCmd);	SndDisposeChannel(sndChan,TRUE);	err=SndNewChannel(&sndChan, 0 , initMono, NewSndCallBackProc(SoundCallBack));	sndChan->qLength=stdQLength; 	/* possible Sound Mgr bug fix */	sndChan->userInfo=0x7FFFFFFF;	if(currentSound)		{		/*if there was a sound playing, there ain't anymore*/		HUnlock((Handle)currentSound);		currentSound=0;		}	}UserCallBack=0;/*no need to call back, won't get there anyway*/return err;}#endif // MACINTOSH