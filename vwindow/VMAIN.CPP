/*------------------------------------------------------------------------------ * Virtus  * V_Windows * Version 2.0 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				 *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File: VMain.c * Notes:  * History:  *		Modified 		7/20/92		DAS *		Split Init/Exit code to VInit.c *		Split ResError code to VError.c *		Modified		7/26/92		DAS *		Added support for MS Windows *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VMain.h"#include "VGestalt.h"#include "VDocumnt.h"#include "VWindow.h"#include "VGraphic.h"#include "VGUtil.h"#include "VSound.h"#include "VMemUtil.h"#include "VMenu.h"#include "VArray.h"#include "VFile.h"#include "VDialog.h"#include "VAbout.h"#include "VWI.h"		// DAS-VWI 8/9/93#include "vdebug.h"		// ABD 8/24/93 MERGE4 (not really necessary)#include "WalkThru.h"	// ABD TEMP#include "AppText.h"	// BILBIL - 13Dec94 - this is bad, rethink this later . . .#if DLLMOVESOBSERVER#include "worldDLL.h"#include "appmssgs.h"#endif DLLMOVESOBSERVER#if USE_HMD				// ABD MERGE-HMD HMD CRYSTAL EYES HACK DEBUG ONLY#include "HMD.h"		// ABD MERGE-HMD HMD CRYSTAL EYES HACK DEBUG ONLY#endif					// ABD MERGE-HMD HMD CRYSTAL EYES HACK DEBUG ONLY#include <stdlib.h>#include <stdio.h>#include <string.h>#if MACINTOSH// if HACK is TRUE one can copy and paste from dialog TEedit fields using the F3(copy)// and the F4(paste) keys. Drew's hack annotated by Bill// used for porting JAPANESE gallery item names (may be helpful for other localization)#define HACK FALSE#include <Palettes.h>// DAS-VWINDOWS-FIX 9/29/93 fix the color palette problem#ifndef __PPCC__#include <QuickTimeComponents.h>#elseQDGlobals	qd;#endif //__PPCC__#define typeMask 	0xFF000000#define suspResEvt	0x01000000#define suspResBit	0x00000001void DoHighLevelEvent(EventRecord *myEvent);#endif //MACINTOSH#if WINDOWS#include "ToolHelp.h"BOOL CALLBACK _exportNotifyRegisterCallback(WORD wID,DWORD dwData)	{	NFYLOGERROR *le;	NFYLOGPARAMERROR *lpe;	int errType, result;	void FAR *info;	FARPROC farProc;	switch(wID)		{		case NFY_LOGERROR: 			le = (NFYLOGERROR *)dwData;			errType =le->wErrCode;            info = le->lpInfo;//        	LogError(errType,info);			result = FALSE;			break;		case NFY_LOGPARAMERROR:			lpe = (NFYLOGPARAMERROR *)dwData;			errType =lpe->wErrCode;			farProc = (FARPROC)lpe->lpfnErrorAddr;            info = lpe->lpBadParam;//			LogParamError(errType,farProc,info);            result = FALSE;			break;		default:			result = FALSE;            break;		}    return result;	}HINSTANCE appInstance = NULL;HWND hwndMDIClient = NULL;HWND hwndFrame = NULL;HINSTANCE GetAppInstance() { return appInstance; }void SetAppInstance(HINSTANCE hInst) { appInstance = hInst; }int nCmdShow = 0;HANDLE hAccel = NULL;void SetCommandShow(int cmd) { nCmdShow = cmd; }int  GetCommandShow() { return nCmdShow; }void SetMainDocument(V_Document *doc)	{	hwndMDIClient = doc->GetMDIClient();    hwndFrame = doc->hwndFrame;	}HWND GetMainFrameWindow() { return hwndFrame; }HWND GetMainClientWindow() { return hwndMDIClient; }#if 0void Debugger(char *str){if(!inDebugger)	{	inDebugger=TRUE;	DebugOutput(DBF_ERROR,str);	inDebugger=FALSE;	}}#endif //0#endif //WINDOWSint inMain = FALSE;			// Force correct value before startup		// GJR 10/22/93int appResFile;int frontApp;int inDebugger=FALSE;/*------------------------------------------------------------------------------ * main() * Call the Init() * Check the number of files that are to be loaded and call StartUp with * the appropriate flag.  Finally call MainEvent() which is the main event * loop.  Everything that happens, happens here. *------------------------------------------------------------------------------*/#if MACINTOSHlong theCreator;	void TestShard(void);void Init(void);void main()	{	frontApp = TRUE;	inMain=FALSE;		Init();	TestShard();	GrowMemory(TRUE);#elif WINDOWSvoid Init(HANDLE hInst,HANDLE hPrevInstance,			LPSTR lpszCmdLine,			int nCShow);int  PASCAL WinMain(HANDLE hInst,						HANDLE hPrevInstance,						LPSTR lpszCmdLine,						int nCShow)	{    FARPROC proc;	frontApp = TRUE;	inMain=FALSE; 	InitMemoryPool();  // jca 7APR94 start memory pool and debugging help here	proc=MakeProcInstance((FARPROC)NotifyRegisterCallback,hInst);	NotifyRegister(NULL,(LPFNNOTIFYCALLBACK)proc,NF_NORMAL);	SetAppInstance(hInst);	SetCommandShow(nCShow);	Init(hInst,hPrevInstance,lpszCmdLine,GetCommandShow());	SetCommandShow(SW_SHOW);	// jca 31MAR94 set everything up to work normally.#endif		VSetCursor(vCursorArrow);	inMain=TRUE;	MainEvent(0);							/*go for it*/	EndIt();	Exit();#if WINDOWS	NotifyUnRegister(NULL);	FreeProcInstance(proc);	EndMemoryPool();	// jca 7APR94 clean up the smartheap memory stuff	return 0;#endif //WINDOWS	}	/*------------------------------------------------------------------------------ * void MainEvent() * This is where the user events trigger everything that happens.  This is in a * sense the main switchboard of the entire operation. It looks very much like * a standard Macintosh event loop, except for a few major differences. *  * The first is in the access to the menu manager.  A call is made via the current * activeDocument object.   *  * Second, rather than doing anything with a window directly, we instead deal * with the V_Window object that owns the window.  A pointer to this V_Window * object is stored in the window's refCon field.  All we do then is call * GetWRefCon, cast the result to (V_Window *) and then call the appropriate * V_Window message: * * ((V_Window *)(GetWRefCon(whichWindow)))-> *			MouseDown(myEvent.where,myEvent.modifiers); * * GBA 7/9/90 - flags parameter added.  Currently, there is only one flag defined, * MODAL.  If (flags & MODAL), then DieWindowEvents cause the routine to exit. * MainEvent(MODAL) is designed to be called from V_Dialog::Modal(). *------------------------------------------------------------------------------*/int mainNotDone;#if MACINTOSHPoint		bogus={0x8000,0x8000};WindowPeek  lastWindow=0,mouseWindow=0,tempWindow;#define MaxSize 0x800000void MainEvent(int flags){RgnHandle mouseRgn;char		ch;#if HACK || VRML_ANCHOR	// ABD PRO25 AUG95char key;	// 본본퇻ACK#endif //HACKshort		code;short		theMenu,theItem;long		mResult;WindowPeek	whichWindow,tWindow;EventRecord	myEvent;long		modifier;void		MemoryErr(int);V_Window   *activeWindow,*vwin;int count=0;Point lastPoint;long dblTime=GetDblTime();long lastClick;Boolean handled = FALSE;		// PRO25lastClick=0;mouseRgn = NULL;mainNotDone=TRUE;while(mainNotDone)	{	if(lowMemory)ReclaimMemory(); /*if we are low, try to rescue some*/#if VR	VWIMemory();#endif //VR/*	ShowMem(FALSE);/*this is for testing only*//*  PurgeMem(MaxSize);  CompactMem(MaxSize);/*these two routines move memory around a lot! Good for testing.*/	if (WaitNextEvent(everyEvent, &myEvent,0,mouseRgn))			{		whichWindow=0;		code = FindWindow(myEvent.where, (WindowPtr *)&whichWindow);			modifier=myEvent.modifiers^buttonDown;				switch (myEvent.what)				{				case mouseDown:					// MERGE-GOURAUD-PRO-6					// don't accept these events if we are not in front					if (!frontApp)	// MERGE-GOURAUD-PRO-6						break;		// MERGE-GOURAUD-PRO-6					if((dblTime>=(myEvent.when-lastClick)) && abs(myEvent.where.v-lastPoint.v)<=3 &&						abs(myEvent.where.h-lastPoint.h)<=3) 							modifier|=doubleClick;					lastClick= myEvent.when;					lastPoint = myEvent.where;										switch(code)						{						case inMenuBar:							VSetCursor(vCursorArrow);							tWindow=(WindowPeek)MyFrontWindow();							if(!tWindow)tWindow=(WindowPeek)GetRealWindow((WindowPeek)FrontWindow());/*maybe there is a windoid? DAS-VWI -8/8/93*/							if(tWindow)								{								if((((V_Window *)(GetWRefCon((GrafPtr)tWindow)))->wType&DRAGBAR) &&								   (((V_Window *)(GetWRefCon((GrafPtr)tWindow)))->theDocument != NULL))									{									((V_Window *)(GetWRefCon((GrafPtr)tWindow)))->theDocument->										MenuPreempt();									mResult = MenuSelect(myEvent.where);									theMenu = HiWord(mResult);									theItem = LoWord(mResult);									((V_Window *)(GetWRefCon((GrafPtr)tWindow)))->theDocument->										MenuDispatch(theMenu,theItem,modifier);									}								else VPlaySound(beepSound);								}							else								{								stub->MenuPreempt();								mResult = MenuSelect(myEvent.where);								theMenu = HiWord(mResult);								theItem = LoWord(mResult);								stub->MenuDispatch(theMenu,theItem,modifier);								}							break;						case inSysWindow:							SystemClick(&myEvent, (GrafPtr)whichWindow);							break;						case inContent:// { DAS-VWI BUGFIX	8/25/93							if(mouseWindow)								if((mouseWindow->windowKind >= userKind))									{									tempWindow=mouseWindow;									mouseWindow=NULL;									((V_Window *)(GetWRefCon((GrafPtr)tempWindow)))->MouseUp(myEvent.where,modifier);									}							vwin=(V_Window *)GetWRefCon((GrafPtr)whichWindow);							if(vwin && !(vwin->wType&ONTOP))								{								if (!ActiveWindow(whichWindow)) 									{									// if the top window is NOT a non-dragbar type									tWindow=(WindowPeek)GetRealWindow((WindowPeek)FrontWindow()); // DAS-VWI 8/8/93									if(((V_Window *)GetWRefCon((GrafPtr)tWindow))->wType&DRAGBAR)										((V_Window *)GetWRefCon((GrafPtr)whichWindow))->Select();									else VPlaySound(beepSound);									}								else 									{									((V_Window *)(GetWRefCon((GrafPtr)whichWindow)))->										MouseDown(myEvent.where,modifier);									((V_Window *)(GetWRefCon((GrafPtr)whichWindow)))->										TrackWindow(myEvent.where,myEvent.modifiers);									/*only save this as a mouse down if it is not a dialog box*/									if(((V_Window *)(GetWRefCon((GrafPtr)whichWindow)))->wType&DRAGBAR)										mouseWindow=whichWindow;									else										mouseWindow=NULL;									}								}// } DAS-VWI BUGFIX	8/25/93							break;						default:							tWindow=(WindowPeek)GetRealWindow((WindowPeek)FrontWindow()); // DAS-VWI 8/8/93							if (tWindow == NULL)		// MERGE-GOURAUD-PRO-5 								break;					// MERGE-GOURAUD-PRO-5 							if(tWindow->windowKind != dialogKind)							if(((V_Window *)GetWRefCon((GrafPtr)tWindow))->wType&DRAGBAR)								{								if(whichWindow != NULL &&									((whichWindow->windowKind >= userKind) ||									(whichWindow->windowKind == dialogKind) ))									((V_Window *)(GetWRefCon((GrafPtr)whichWindow)))->										Dispatch(code,myEvent.where,modifier);								mouseWindow=NULL;								}							else if (!((V_Window *)GetWRefCon((GrafPtr)whichWindow))->wType&ONTOP)								VPlaySound(beepSound);							break;						}					break;  				case keyDown: 				case autoKey: 					// MERGE-GOURAUD-PRO-6					// don't accept these events if we are not in front					if (!frontApp)	// MERGE-GOURAUD-PRO-6						break;		// MERGE-GOURAUD-PRO-6									whichWindow = (WindowPeek)GetRealWindow((WindowPeek)FrontWindow());/*need the front window/windoid DAS-VWI 8/8/93*/					tWindow=(WindowPeek)MyFrontWindow();	/*this is the top window*/					ch = myEvent.message &  charCodeMask;#if HACK || VRML_ANCHOR	// ABD PRO25 AUG95					key = 0;					key = (myEvent.message &  keyCodeMask) >> 8;	// 본본봙HACK#endif //VRML_ANCHOR					if(ch==1 && ((modifier & 0x1F00)==0x1F00))						AlertMessage(TXT_COPYRIGHT);	// PRO-JAP#if HACK || VRML_ANCHOR	// ABD PRO25 AUG95						// 본본봙HACK [[[										else if ((key == 0x78) || ((modifier & 256) && (key == 0x07)))					{					V_Window *win = (V_Window*)GetWRefCon((GrafPtr)tWindow);											if ((win) && (win->activeText) && (win->wType&MODALWINDOW))	// PRO25						{							TECut(win->activeText->textbox);							handled = TRUE;		// PRO25						}					}					else if ((key == 0x63) || ((modifier & 256) && (key == 0x08)))					{					V_Window *win = (V_Window*)GetWRefCon((GrafPtr)tWindow);											if ((win) && (win->activeText) && (win->wType&MODALWINDOW))	// PRO25						{							TECopy(win->activeText->textbox);							handled = TRUE;		// PRO25						}					}					else if ((key == 0x76) || ((modifier & 256) && (key == 0x09)))					{					V_Window *win = (V_Window*)GetWRefCon((GrafPtr)tWindow);											if ((win) && (win->activeText) && (win->wType&MODALWINDOW))	// PRO25						{							TEPaste(win->activeText->textbox);							handled = TRUE;		// PRO25						}					}						// 본본봙HACK ]]]			#endif //HACK || VRML_ANCHOR					// PRO25 else 					if (!handled) {	// PRO25 					if (modifier & cmdKey)						{						/*only windows with documents (not windoids or dialogs) get menu events*/						if(tWindow)							{							long refCon=GetWRefCon((GrafPtr)tWindow);													if(((V_Window *)refCon)->wType&DRAGBAR)								{								((V_Window *)refCon)->theDocument->MenuPreempt();								mResult = MenuKey(ch);								if(mResult)									{									theMenu = HiWord(mResult);									theItem = LoWord(mResult);									((V_Window *)refCon)->theDocument->										MenuDispatch(theMenu,theItem,modifier);									}								/*if the menu command did nothing, let a window get a crack*/								else while(whichWindow)									{									if(whichWindow->windowKind >= userKind)										if(((V_Window *)(GetWRefCon((GrafPtr)whichWindow)))->											KeyAction(ch,modifier))whichWindow=0;									if(whichWindow)									/*don't go beyond the front window*/									if(whichWindow==tWindow)whichWindow=0;									else if(tWindow)whichWindow=whichWindow->nextWindow;									else whichWindow=0;									}								}							else if(!whichWindow)/*absolutely no windows available*/								{								stub->MenuPreempt();								mResult = MenuKey(ch);								if(mResult)									{									theMenu = HiWord(mResult);									theItem = LoWord(mResult);										stub->MenuDispatch(theMenu,theItem,modifier);									}								}							}// VPLAYER - add this section of code [[[						else							{							stub->MenuPreempt();							if (visibleMMgr->ALength() != 0)  // ABD JAN95							{                                 // ABD JAN95							mResult = MenuKey(ch);							if(mResult)								{								theMenu = HiWord(mResult);								theItem = LoWord(mResult);									stub->MenuDispatch(theMenu,theItem,modifier);								}                            }	// ABD JAN95							}// VPLAYER - add this section of code ]]]						}					else while(whichWindow)						{						if(whichWindow->windowKind >= userKind)							if(((V_Window *)(GetWRefCon((GrafPtr)whichWindow)))->								KeyAction(ch,modifier))whichWindow=0;						if(whichWindow)						if(whichWindow==tWindow)whichWindow=0;						else if(tWindow)whichWindow=whichWindow->nextWindow;						else whichWindow=0;						}					}	// !handled PRO25					handled = FALSE;	// PRO25 					break; 				case diskEvt:					// MERGE-GOURAUD-PRO-6					// don't accept these events if we are not in front					if (!frontApp)	// MERGE-GOURAUD-PRO-6						break;		// MERGE-GOURAUD-PRO-6					if (HiWord(myEvent.message) != 0)						{						myEvent.where.h = 							((screenBits.bounds.right - 							screenBits.bounds.left) / 2) - (304 / 2);						myEvent.where.v = 							((screenBits.bounds.bottom - 							screenBits.bounds.top) / 3) - (104 / 2);						VSetCursor(vCursorArrow);						theItem = DIBadMount(myEvent.where, myEvent.message);						}					break; 				case updateEvt:  					RebuildScreens();	// DAS-VWINDOWS-BUGFIX 9/13/93 					whichWindow = (WindowPeek)myEvent.message;					if(whichWindow&&						((whichWindow->windowKind >= userKind) /* ||						(whichWindow->windowKind == dialogKind)*/ ))							((V_Window *)(GetWRefCon((GrafPtr)whichWindow)))->Update();					break;				case activateEvt: 					cursNum=-1;/*insure that the cursor is updated appropriatly*/					whichWindow = (WindowPeek)myEvent.message; /* Get the window to be activated */					if(whichWindow && whichWindow->windowKind >= userKind)						{						if ((modifier & activeFlag))							{//DAS-VWI					whichWindow=(WindowPeek)GetRealWindow((WindowPeek)FrontWindow()); // DAS-VWI 8/8/93 ONTOP							while(!whichWindow->visible)								whichWindow=whichWindow->nextWindow;							if(activeWindow=(V_Window *)GetWRefCon((GrafPtr)whichWindow))								{								if(!(activeWindow->wType&ONTOP))									{									if(activeWindow->theDocument)										activeWindow->theDocument->Activate(activeWindow);									else										activeWindow->Activate();									}								else									{									activeWindow->Deactivate(); // DAS-VWI ONTOP always inactive									whichWindow=whichWindow->nextWindow;									while(whichWindow && (!whichWindow->visible))										whichWindow=whichWindow->nextWindow;									if(whichWindow && (activeWindow=(V_Window *)GetWRefCon((GrafPtr)whichWindow)))										{										if(activeWindow->theDocument)											activeWindow->theDocument->Activate(activeWindow);										else											activeWindow->Activate();										}									}								}							}						else ((V_Window *)(GetWRefCon((GrafPtr)whichWindow)))->Deactivate();						}					break;				case mouseUp:					// MERGE-GOURAUD-PRO-6					// don't accept these events if we are not in front					if (!frontApp)	// MERGE-GOURAUD-PRO-6						break;		// MERGE-GOURAUD-PRO-6					if(mouseWindow)						{						// DAS-VWINDOWS-FIX 9/22/93 removed extra track, some guys don't like it.						tempWindow=mouseWindow;						mouseWindow=NULL;						if((tempWindow->windowKind >= userKind)||(tempWindow->windowKind == dialogKind))							((V_Window *)(GetWRefCon((GrafPtr)tempWindow)))->							MouseUp(myEvent.where,modifier);						}					break;								case app1Evt:/* possible low memory condition */					MemoryErr(myEvent.message);					break;				case app2Evt:					if (flags & MODAL)						if (myEvent.message == DieWindowEvent)							{							mouseWindow=NULL;							return; /* GBA 7/9/90 */							}// DAS-VWINDOWS-FIX 9/7/93//					FlushEvents(app2Mask,0);/* clear out all of the extra events */					switch(myEvent.message)						{						int removeMenuEvents;						case CLEAN_MENUS:// DAS-VWINDOWS-FIX 9/7/93							CleanMenus();							removeMenuEvents=TRUE;							while(removeMenuEvents)								if(EventAvail(app2Mask,&myEvent))									{									if(myEvent.message==CLEAN_MENUS)										WaitNextEvent(app2Mask, &myEvent,0,mouseRgn);									else removeMenuEvents=FALSE;									}								else removeMenuEvents=FALSE;							break;// ABD WILLIAMS MERGE8 9/5/93 [[[#if 0						case OPEN_VR_LIB:						{						extern int gNextVRLib3D;						V_Document *doc;							theSuper->Get(0, &doc);							((WalkDocument*)doc)->OpenVRLib(gNextVRLib3D);							break;						}						case OPEN_TEXTURE_LIB:	// MERGE14						{						extern int gNextTextureLib;						V_Document *doc;							theSuper->Get(0, &doc);							((WalkDocument*)doc)->OpenTextureLib(gNextTextureLib);							break;						}#endif// ABD WILLIAMS MERGE8 9/5/93 ]]]#if (!VPLAYER)						case PRINT_SETUP:							#if !SAVE_DISABLED 	// ABD-SAVE-DISABLED							VSetCursor(vCursorArrow);							tWindow=(WindowPeek)MyFrontWindow();/*need the front window*/							if(tWindow)								((V_Window *)GetWRefCon((GrafPtr)tWindow))->SetPrint();							#endif // SAVE_DISABLED 	// ABD-SAVE-DISABLED							break;#endif //!VPLAYER						default:							tWindow=(WindowPeek)GetRealWindow((WindowPeek)FrontWindow()); // DAS-VWI 8/8/93							whichWindow=(WindowPeek)MyFrontWindow();							// BILBIL - added V_Document::MessageDispatch() - 12/05/93 {{{							if (tWindow)								{								V_Window*	vwin;								vwin = ((V_Window*)GetWRefCon((GrafPtr)tWindow));								if (vwin && vwin->theDocument)									{									vwin->theDocument->MessageDispatch(myEvent.message,modifier);									tWindow = NULL;                                    }                                }							while(tWindow)								{								if(((V_Window *)GetWRefCon((GrafPtr)tWindow))->DoEvent(myEvent.message,modifier))tWindow=0;								else if(tWindow==whichWindow)tWindow=0;								else tWindow=tWindow->nextWindow;								while(tWindow&&!tWindow->visible)tWindow=tWindow->nextWindow;								}							break;						}					break;				case app4Evt:						if(suspResEvt==(typeMask&myEvent.message))							{						#if HACK || VRML_ANCHOR		// ABD PRO25 AUG95						// this is required to cut-n-paste between applications.						// convert the scrap from the TE scrap to the desktop scrap when						// we are activated/deactivated						if (myEvent.message&suspResBit)						{							// activate app							TEFromScrap();						}						else						{							// deactivate app							ZeroScrap();							TEToScrap();						}						#endif						whichWindow = (WindowPeek)MyFrontWindow();/*need the front window*/						if(whichWindow)							{							if (myEvent.message&suspResBit)								{								// { DAS-VWINDOWS-FIX 9/29/93 fix the color palette problem								RestoreDeviceClut(NULL);								PaintBehind( NULL, GetGrayRgn() );								// } DAS-VWINDOWS-FIX 9/29/93 fix the color palette problem#if VR								VWIShow(); // DAS-VWI 8/25/93 show the VWI if it exists #endif //VR								cursNum=-1; // DAS-VWI force this to be updated 8/8/93								VSetCursor(vCursorArrow); // DAS-VWI 								// DAS-VWI - ONTOP code								tWindow=(WindowPeek)FrontWindow();								while(tWindow)									{									vwin=(V_Window*)GetWRefCon((WindowPtr)tWindow);									if(vwin->wType&ONTOP && !vwin->Visible())										{										vwin->Show();										vwin->Behind(0);										}									tWindow=tWindow->nextWindow;									}																// ABD MERGE-HMD [[[								#if VR												#if USE_HMD												// This is a major hack to keep the VWI window hidden when								// we are in HMD CrystalEyes mode -- the above loop always shows								// it when we get switched into the foreground, but if we								// are in HMD CrystalEyes mode we want the damn thing to stay								// hidden when we are in full screen mode -- so we just hide 								// it again.  								if ((gUseHMDs) && (gHMD) && (gHMD->hmd_type == HMD_CRYSTALEYES))									VWIHide();								#endif // USE_HMD								#endif // VR								// ABD MERGE-HMD ]]]								frontApp=TRUE;								activeWindow=(V_Window *)GetWRefCon((GrafPtr)whichWindow);									if(activeWindow)									{																if(activeWindow->theDocument)										activeWindow->theDocument->Activate(activeWindow);									else activeWindow->Activate();									}								}							else 								{#if VR								VWIHide();// DAS-VWI 8/25/93 hide the VWI if it exists#endif //VR								frontApp=FALSE;								((V_Window *)(GetWRefCon((GrafPtr)whichWindow)))->Deactivate();								whichWindow=(WindowPeek)FrontWindow();								while(whichWindow)									{									HiliteWindow((GrafPtr)whichWindow,FALSE);									whichWindow=whichWindow->nextWindow;									}								}							}						else							{							if (!(flags & MODAL))VSendMessage(CLEAN_MENUS);#if VR							if (myEvent.message&suspResBit) // hide the VWI in the stub case								VWIShow();							else								VWIHide();#endif //VR							}						}					break;				case /*kHighLevelEvt*/ 23:					if(!personalize)DoHighLevelEvent(&myEvent);					break;				default:					break; 				}		}	else		{		modifier=myEvent.modifiers^buttonDown;		if(mouseWindow)			{			if(mouseWindow->windowKind >= userKind)				{				if(!ActiveWindow(mouseWindow))					{					tempWindow=mouseWindow;					mouseWindow=NULL;					((V_Window *)(GetWRefCon((GrafPtr)tempWindow)))->						MouseUp(myEvent.where,modifier);						}				else					((V_Window *)(GetWRefCon((GrafPtr)mouseWindow)))->						TrackWindow(myEvent.where,modifier);				}			}		else if(frontApp)			{			code = FindWindow(myEvent.where,(WindowPtr *) &whichWindow);				if(	lastWindow &&				lastWindow!=whichWindow &&				ActiveWindow(lastWindow)  &&				((whichWindow->windowKind >= userKind) ))/*clean up the lastWindow*/				((V_Window *)(GetWRefCon((GrafPtr)lastWindow)))->					TrackWindow(bogus,modifier);			lastWindow=0;/*lastWindow has been cleaned up*/// { DAS-VWI 10/2/93 JAM 1/20/94 added () pair to fix precedence bug in last section of && &&			if(whichWindow && !ActiveWindow(whichWindow) && !(((V_Window *)(GetWRefCon((GrafPtr)whichWindow)))->wType&ONTOP))					whichWindow=0;			if(	whichWindow &&//				ActiveWindow(whichWindow) &&  // } DAS-VWI 10/2/93				((whichWindow->windowKind >= userKind)))					{					((V_Window *)(GetWRefCon((GrafPtr)whichWindow)))->						TrackWindow(myEvent.where,modifier);					lastWindow=whichWindow;					}			else				{				VSetCursor(vCursorArrow);#if VR				VWIMessage("");//DAS-VWI-8/6/93#endif //VR				}			}		}	}}#elif WINDOWSint testBug=0;void TestIt();void TestIt(){if(testBug=2)	{	testBug++;	NewDocument(0L,INIT);						/*no files to load at startup*/	}}int VTranslateAccelerator(HWND,LPMSG);void MainEvent(int flags)	{	MSG msg;	HWND hwnd, hwndPane;    char wclass[32];	V_Window *win;    V_Pane *pane;	int doc = FALSE, dialog = FALSE;	int result = 0;    static const Point ptZero = { 0, 0 };	mainNotDone = TRUE;	while (GetMessage (&msg, NULL, 0, 0))		{		if(lowMemory)ReclaimMemory(); /*if we are low, try to rescue some*/		// VWIMemory();   DWE -- this may be too slow or knarly to go here//JOEBOB -- is this too slow for this loop?		hwnd = GetActiveWindow();		if (hwnd)			{			GetClassName (hwnd, wclass, sizeof(wclass));			if (strcmp (wclass, documentClassName) == 0)				doc = TRUE;			else if (strcmp (wclass, windoidClassName) == 0)				{				win = (V_Window *)GetWindowLong(hwnd, 0);				if ((win->wType & MODALDIALOG) &&					(pane = win->FindPane(ptZero)) != NULL)					{                    dialog = TRUE;					hwndPane = pane->paneWindow;                    }				}			}		if (doc)			{			result = VTranslateAccelerator (hwndFrame, &msg);			if ((!result) && msg.wParam)				result = TranslateMDISysAccel (hwndMDIClient, &msg);			}		else if (dialog)			{			if (flags & MODAL)			if (msg.message == VIRTUS_MESSAGE)				if(msg.lParam == DieWindowEvent)				return;			result = IsDialogMessage(hwndPane, &msg);            }		if (!result)			{#if DLLMOVESOBSERVER			DLLMainEventLoopEntry();#endif			TranslateMessage (&msg);			DispatchMessage (&msg);#if DLLMOVESOBSERVER			{				MSG testMsg;				if(!PeekMessage(&testMsg,NULL,0,0,PM_NOREMOVE))				{	    			VSendMessage(MSG_DONOTHING);	//make sure messages keep flowing				}            }#endif			}		}	}int VTranslateAccelerator(HWND hwnd,LPMSG msg)	{	HMENU menu;	int result,menuID;    long modifier;	char filePath[256];	int length;	result = 0;	if(msg->message == WM_KEYDOWN)	if(msg->message == WM_KEYDOWN && (msg->wParam==0x70 || msg->wParam==0x08 || msg->wParam==0x2E ||  (msg->wParam>0x20 && (GetKeyState(VK_CONTROL)&0x8000))))		{		switch(msg->wParam)			{			case 0x70:				length = GetModuleFileName(GetAppInstance(), filePath, 256);				while((length>0)&&(filePath[length] != '\\'))					{					filePath[length] = 0x00;					length --;					}        			strcat(filePath, HELP_FILE_NAME);				if(hwnd)WinHelp(hwnd,filePath,HELP_CONTENTS,0);				break;			case 0x2E:                                /*this is the del character*/			case 0x08: msg->wParam=menuDelKey; break; /*this is the BS character*/			case 0xBA: msg->wParam=0x3B; break;/* this is the ';' character*/			case 0xBB: msg->wParam=0x3D; break;/* this is the '=' character*/			case 0xBC: msg->wParam=0x2C; break;/* this is the '=' character*/			case 0xBD: msg->wParam=0x2D; break;/* this is the '-' character*/			case 0xBF: msg->wParam=0x2F; break;/* this is the '/' character*/			case 0xDB: msg->wParam=0x5B; break;/* this is the '[' character*/			case 0xDD: msg->wParam=0x5D; break;/* this is the ']' character*/			}		modifier=((GetKeyState(VK_CONTROL)&0x8000)?ctrlKeyPrefix:0)|				 ((GetKeyState(VK_MENU)&0x8000)?altKeyPrefix:0)|				 ((GetKeyState(VK_SHIFT)&0x8000)?shiftKeyPrefix:0);		menuID = visibleMMgr->FindAccelerator(msg->wParam,modifier);		if(menuID) 			{			menu = GetMenu(hwnd);			HiliteMenuItem(hwnd,menu,menuID,MF_BYCOMMAND|MF_HILITE);			PostMessage(hwnd,WM_COMMAND,menuID,NULL);			HiliteMenuItem(hwnd,menu,menuID,MF_BYCOMMAND|MF_UNHILITE);            result = TRUE;			}		}	return result;	}#endif //WINDOWS#include "ShowTest.h"voidVSendMessage(long message)	{#if MACINTOSH	PostEvent(app2Evt,message);#endif //MACINTOSH#if WINDOWS	if(hwndFrame)PostMessage(hwndFrame,VIRTUS_MESSAGE,0,message);#endif //WINDOWS	}