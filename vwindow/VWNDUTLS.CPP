#include "VTYPES.H"#if MACINTOSH#include "VWndUtls.h"#include "VWindow.h"#include "VGutil.h"#include "VWI.h"		// ABD MERGE10 9/9/93extern int colorQD;/*--------------------------------------------------------------------------------*//* 	Given a window, this will return the top left point of the windowÕs port in	global coordinates.  Something this doesnÕt include is the windowÕs drag	region (or title bar).  This returns the top left point of the windowÕs	content area only. */Point	GetGlobalTopLeft(WindowPtr window){	GrafPtr			oldPort;	Point			globalPt;		GetPort(&oldPort);	SetPort(window);	globalPt = TOP_LEFT(window->portRect);	LocalToGlobal(&globalPt);	SetPort(oldPort);	return(globalPt);}/*--------------------------------------------------------------------------------*/void	LocalToGlobalRect(Rect *aRect){	LocalToGlobal(&TOP_LEFT(*aRect));	LocalToGlobal(&BOT_RIGHT(*aRect));}/*--------------------------------------------------------------------------------*//*	Returns rect of main screen*/Rect	GetMainScreenRect(void){	GDHandle	mainDevice;	GrafPtr		mainPort;	if (colorQD) 	{		mainDevice = GetMainDevice();		return((*mainDevice)->gdRect);	} 	else 	{		GetWMgrPort(&mainPort);		return(mainPort->portRect);	}}/*--------------------------------------------------------------------------------*//* 	Find the greatest overlap device for the given global rectangle. */GDHandle GetRectDevice(Rect *globalRect){	long		area;	long		maxArea;	GDHandle	device;	GDHandle	deviceToReturn;	Rect		intersection;	deviceToReturn = GetMainDevice();			/* Use as default choice. */	maxArea = 0;	for (device = GetDeviceList(); device; device = GetNextDevice(device)) 	{		if (TestDeviceAttribute(device, screenDevice)		  && TestDeviceAttribute(device, screenActive)		  && SectRect(globalRect, &((*device)->gdRect), &intersection)) 		  {			area = (intersection.right - intersection.left) *				   (intersection.bottom - intersection.top);			if (area > maxArea) 			{				deviceToReturn = device;				maxArea = area;			}		}	}	return(deviceToReturn);}/*--------------------------------------------------------------------------------*//* 	Find the rect of the greatest overlap device for the given global rect. */Rect	GetRectDeviceRect(Rect *globalRect){	if (colorQD)		return((*GetRectDevice(globalRect))->gdRect);	else		return(GetMainScreenRect());}/*--------------------------------------------------------------------------------*//* 	Given a window pointer, return the global rectangle that encloses the	content area of the window. */Rect	GetWindowContentRect(WindowPtr window){	WindowPtr	oldPort;	Rect		contentRect;	GetPort(&oldPort);	SetPort(window);	contentRect = window->portRect;	LocalToGlobalRect(&contentRect);	SetPort(oldPort);	return(contentRect);}/*--------------------------------------------------------------------------------*//* 	Find the greatest overlap device for the given window. */GDHandle	GetWindowDevice(WindowPtr window){Rect r = GetWindowStructureRect(window);	return(GetRectDevice(&r));}/*--------------------------------------------------------------------------------*//* 	Given a window pointer, find the device that contains most of the window	and return the device's bounding rectangle. */Rect	GetWindowDeviceRect(WindowPtr window){	if (colorQD)		return((*GetWindowDevice(window))->gdRect);	else		return(GetMainScreenRect());}/*--------------------------------------------------------------------------------*//* 	Given a window pointer, find the device that contains most of the window	and return the device's bounding rectangle.  If this device is the main	device, then remove the menubar area from the rectangle. */Rect	GetWindowDeviceRectNMB(WindowPtr window){	Rect		deviceRect, tempRect;	deviceRect = GetWindowDeviceRect(window);	tempRect = GetMainScreenRect();	if (EqualRect(&deviceRect, &tempRect)) deviceRect.top += GetMBarHeight();	return(deviceRect);}/*--------------------------------------------------------------------------------*//* 	This procedure is used to get the rectangle that surrounds the entire	structure of a window.  This is true whether or not the window is visible.	If the window is visible, then it is a simple matter of using the bounding	rectangle of the structure region.  If the window is invisible, then the	strucRgn is not correct.  To make it correct, then window has to be moved	way off the screen and then made visible.  This generates a valid strucRgn,	although it is valid for the position that is way off the screen.  It still	needs to be offset back into the original position.  Once the bounding	rectangle for the strucRgn is obtained, the window can then be hidden again	and moved back to its correct location.  Note that ShowHide is used,	instead of ShowWindow and HideWindow.  HideWindow can change the plane of	the window.  Also, ShowHide does not affect the hiliting of windows. */Rect	GetWindowStructureRect(WindowPtr window){#define kOffscreenLoc 0x4000	GrafPtr		oldPort;	Rect		structureRect;	Point		windowLoc;		if (((WindowPeek)window)->visible)		structureRect = (*(((WindowPeek)window)->strucRgn))->rgnBBox;	else 	{		GetPort(&oldPort);		SetPort(window);		windowLoc = GetGlobalTopLeft(window);		MoveWindow(window, windowLoc.h, kOffscreenLoc, false);		ShowHide(window, true);		structureRect = (*(((WindowPeek)window)->strucRgn))->rgnBBox;		ShowHide(window, false);		MoveWindow(window, windowLoc.h, windowLoc.v, false);		SetPort(oldPort);		OffsetRect(&structureRect, 0, windowLoc.v - kOffscreenLoc);	}	return(structureRect);}/*--------------------------------------------------------------------------------*//* 	Zoom the window to the size appropriate for the device that contains the	most of the window.  An additional feature is that you can state the	maximum that a window should be zoomed, either horizontally or vertically.	If you pass in a maximum of 0 for the zoom for either direction, then that	direction will be zoomed to fit the device. */void	ZoomToWindowDevice(WindowPtr window, short maxWidth, short maxHeight,						   short zoomDir, Boolean front){ 	GrafPtr		oldPort;	Rect		contentRect, structureRect, deviceRect, newRect;	short		width, height, dx, dy;	GetPort(&oldPort);	SetPort(window);	EraseRect(&window->portRect); 		/* Recommended for cosmetic reasons. */	/* If there is the possibility of multiple gDevices, then we must check them to	** make sure we are zooming onto the right display device when zooming out. */	if ((zoomDir == inZoomOut) && (colorQD)) 	{		contentRect	  = GetWindowContentRect(window);		structureRect = GetWindowStructureRect(window);		deviceRect	  = GetWindowDeviceRectNMB(window);		deviceRect.left   += (contentRect.left - structureRect.left + 2);		deviceRect.top    += (contentRect.top - structureRect.top + 2);		deviceRect.right  -= (structureRect.right - contentRect.right + 2);		deviceRect.bottom -= (structureRect.bottom - contentRect.bottom + 2);		newRect = deviceRect;		if (maxWidth)			if ((width = deviceRect.right - deviceRect.left) > maxWidth)				newRect.right = (newRect.left = contentRect.left) + maxWidth;		if (maxHeight)			if ((height = deviceRect.bottom - deviceRect.top) > maxHeight)				newRect.bottom = (newRect.top = contentRect.top) + maxHeight;		if ((dx = deviceRect.left - newRect.left) < 0)			if ((dx = deviceRect.right - newRect.right) > 0)				dx = 0;		if ((dy = deviceRect.top - newRect.top) < 0)			if ((dy = deviceRect.bottom - newRect.bottom) > 0)				dy = 0;		OffsetRect(&newRect, dx, dy);		(*(WStateDataHandle)(((WindowPeek)window)->dataHandle))->stdState = newRect;			/* Set up the WStateData record for this window. */	}	ZoomWindow(window, zoomDir, front);	SetPort(oldPort);}/*--------------------------------------------------------------------------------*//* 	Zoom the window to the screen it is mostly on. */void	SmartZoomWindow2(WindowPtr window, short zoomDir, Boolean front){	ZoomToWindowDevice(window, 32000, 32000, zoomDir, front);}int MinWindowWidth(WindowPtr window);int MinWindowHeight(WindowPtr window);/*--------------------------------------------------------------------------------*//* 	asdf*/int MinWindowWidth(WindowPtr window){V_Window *vWindow=(V_Window *)GetWRefCon(window);	if (!vWindow) return 0;	return vWindow->mnSize.h;}/*--------------------------------------------------------------------------------*//* 	asdf*/int MinWindowHeight(WindowPtr window){V_Window *vWindow=(V_Window *)GetWRefCon(window);	if (!vWindow) return 0;	return vWindow->mnSize.v;}/* clamp the input to the specified range */#define pin(v,l,h)	((v)<(l) ? (l) : (v) > (h) ? (h) : v)/*--------------------------------------------------------------------------------*//* 	Zoom the window to the screen it is mostly on (alternate version)*/void DoZoomWindow (WindowPtr theWindow, short zoomDir, short hMax, short vMax){extern int		colorQD;Rect				*windRect, *zoomRect;Rect				globalPortRect, theSect, dGDRect;GDHandle			nthDevice, dominantGDevice;long				sectArea, greatestArea;GrafPtr				oldPort;	GetPort(&oldPort);	SetPort(theWindow);	EraseRect(&theWindow->portRect);	// recommended for cosmetic reasons	if (zoomDir == inZoomOut) 	{		/*		 *	ZoomWindow() is a good basic tool, but it doesn't do everything necessary to		 *	implement a good human interface when zooming. In fact it's not even close for		 *	more high-end hardware configurations. We must help it along by calculating an		 *	appropriate window size and location any time a window zooms out.		 */		windRect = &(**((WindowPeek) theWindow)->strucRgn).rgnBBox;		dominantGDevice = nil;		if (colorQD) 		{			/*			 *	Color QuickDraw implies the possibility of multiple monitors. This is where			 *	zooming becomes more interesting. One should zoom onto the monitor containing			 *	the greatest portion of the window. This requires walking the gDevice list.			 */			nthDevice = GetDeviceList();			greatestArea = 0;			while (nthDevice != nil) {				if (TestDeviceAttribute(nthDevice, screenDevice)) {					if (TestDeviceAttribute(nthDevice, screenActive)) {						SectRect(windRect, &(**nthDevice).gdRect, &theSect);						sectArea = (long) RECT_WIDTH(theSect) * (long) RECT_HEIGHT(theSect);						if (sectArea > greatestArea) {							greatestArea = sectArea;		// save the greatest intersection							dominantGDevice = nthDevice;	// and which device it belongs to						}					}				}				nthDevice = GetNextDevice(nthDevice);			}		}		/*		 *	At this point, we know the dimensions of the window we're zooming, and we know		 *	what screen we're going to put it on. To be more specific, however, we need a		 *	rectangle which defines the maximum dimensions of the resized window's contents.		 *	This rectangle accounts for the thickness of the window frame, the menu bar, and		 *	one or two pixels around the edges for cosmetic compatibility with ZoomWindow().		 */		if (dominantGDevice != nil) {			dGDRect = (**dominantGDevice).gdRect;			if (dominantGDevice == GetMainDevice())		// account for menu bar on main device			{				dGDRect.top += GetMBarHeight();#if VR				if (VWIflag) dGDRect.bottom -= (VWI_DEF_HEIGHT + 3);		// ABD MERGE10 9/9/93#endif //VR			}		}		else {			dGDRect = qd.screenBits.bounds;				// if no gDevice, use default monitor			dGDRect.top += GetMBarHeight();#if VR			if (VWIflag) dGDRect.bottom -= (VWI_DEF_HEIGHT + 3);		// ABD MERGE10 9/9/93#endif //VR		}		globalPortRect = theWindow->portRect;		LocalToGlobal(&TOP_LEFT(globalPortRect));		// calculate the window's portRect		LocalToGlobal(&BOT_RIGHT(globalPortRect));		// in global coordinates		// account for the window frame and inset it a few pixels		dGDRect.left	+= 2 + globalPortRect.left - windRect->left;		dGDRect.top		+= 2 + globalPortRect.top - windRect->top;		dGDRect.right	-= 1 + windRect->right - globalPortRect.right;		dGDRect.bottom	-= 1 + windRect->bottom - globalPortRect.bottom;		/*		 *	Now we know exactly what our limits are, and since there are input parameters		 *	specifying the dimensions we'd like to see, we can move and resize the zoom		 *	state rectangle for the best possible results. We have three goals in this:		 *	1. Display the window entirely visible on a single device.		 *	2. Resize the window to best represent the dimensions of the document itself.		 *	3. Move the window as short a distance as possible to achieve #1 and #2.		 */		zoomRect = &(**(WStateDataHandle) ((WindowPeek) theWindow)->dataHandle).stdState;		/*		 *	Initially set the zoom rectangle to the size requested by the input parameters,		 *	although not smaller than a minimum size. We do this without moving the origin.		 */		zoomRect->right = (zoomRect->left = globalPortRect.left) +								max(hMax, MinWindowWidth(theWindow));		zoomRect->bottom = (zoomRect->top = globalPortRect.top) +								max(vMax, MinWindowHeight(theWindow));		// Shift the entire rectangle if necessary to bring its origin inside dGDRect.		OffsetRect(zoomRect,					max(dGDRect.left - zoomRect->left, 0),					max(dGDRect.top - zoomRect->top, 0));		/*		 *	Shift the rectangle up and/or to the left if necessary to accomodate the view,		 *	and if it is possible to do so. The rectangle may not be moved such that its		 *	origin would fall outside of dGDRect.		 */		OffsetRect(zoomRect,					-pin(zoomRect->right - dGDRect.right, 0, zoomRect->left - dGDRect.left),					-pin(zoomRect->bottom - dGDRect.bottom, 0, zoomRect->top - dGDRect.top));		// Clip expansion to dGDRect, in case view is larger than dGDRect.		zoomRect->right = min(zoomRect->right, dGDRect.right);		zoomRect->bottom = min(zoomRect->bottom, dGDRect.bottom);	}	ZoomWindow(theWindow, zoomDir, false);		// all it needed was a brain transplant	SetPort(oldPort);}/*--------------------------------------------------------------------------------*//* 	Zoom the window to the screen it is mostly on. */void SmartZoomWindow(WindowPtr window, short zoomDir){	DoZoomWindow(window, zoomDir, 32000, 32000);}#endif // MACINTOSH