 /*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				 *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ *///#define TestingVplayer 1           // define true if testing vplayer from vr //GJR 02/23/94#define CLOUDS	0 		// PRO25#include "VTypes.h"#include "VAbout.h"#include "VGUtil.h"#include "VGraphic.h"#include "VDisplay.h"#include "VWindow.h"#include "VSound.h"#include "VTextDef.h"#include "Prsnlize.h"#include "Serial.h"#if VR#include "WTypes.h"#include "VMath.h"#include "Clip.h"#include "SinTable.h"#include "Flash.h"#include "TextItem.h"#include "TextSrvr.h"#include "AppDeflt.h"#include "BallHelp.h"#include "VWI.h"#endif //VR#include "AppText.h"#include <stdio.h>#include <string.h>#if WINDOWS#include <ver.h>extern HINSTANCE GetAppInstance();#endifstatic RGBColor blue={0x0000,0xAAAA,0xFFFF};int personalize; /*this indicates that the program is in the process of initializing					this is necessary because the personalization code makes a call					to the MainEvent loop.  Since AppleEvents are now handled there					they need to be ignored when we are initializing.				 */void VSplashScreen()	{	personalize=TRUE;	AboutThisApplication(FALSE);	personalize=FALSE;	}#if (!VPLAYER)int AppProtection()	{		int result;		Personalize();#if MACINTOSH && (!JAPANESE)	result = SerialNumber();#endif	if(!result) Damaged();	return result;	}#if MACINTOSHint SerialNumber()	{	AlertDialog *alert;	string str[RESOURCE_STR_SIZE];	time_t date;	int result;		result = GetSerial(str,4);		if(result)		{		date=*(time_t *)str;		if(date)			{			struct tm *ltime;			if(date==1)				sprintf((char *)str,TXT_NOTRESALEERR);			else				{				ltime=localtime(&date);				if(date<time(0))					{					sprintf(str,"%s %d/%d/%d. %s",TXT_EXPIRED,ltime->tm_mon+1,ltime->tm_mday,ltime->tm_year,TXT_VIRTUSHELP);					VPlaySound(beepSound);					alert=new(AlertDialog);					alert->cAlertDialog(str);					VExitToShell();					}				sprintf((char *)str,"%s %d/%d/%d %s",TXT_EXPDATE,ltime->tm_mon+1,ltime->tm_mday,ltime->tm_year,TXT_NOTRESALEERR);				}			}		}	return result;	}#endif //MACINTOSH#endif //!VPLAYER#if VWT //|| PERSONALIZEDvoidAboutThisApplication(int hflag)	{	V_Offscreen *disp;	V_Offscreen *cloud;	V_Offscreen *mask;	V_Offscreen *main;	V_Offscreen  *data;	V_Offscreen  *help;	V_Offscreen  *help2;	V_Window *win;	Rect r,wR,sR,mR,dR,hR,hR2,txtR;	int h,w,depth;	Point p;	int count,bcount=0;	long ticktock,cTime;	char codedStr[256], date[256];#if MACINTOSH	RgnHandle	mouseRgn = NULL;	EventRecord	myEvent;#elif WINDOWS	HDC hDC;	//MJU    int oldBkMode;#endif //WINDOWS	disp=NULL;	cloud=NULL;	mask=NULL;	main=NULL;	data=NULL;	help=NULL;	help2=NULL;	win = NULL;	VFlushEvents(-1);	depth = MainDepth();	date[0] = 0;#if !SAVE_DISABLED // jca 22Feb95 #if MACINTOSH || PERSONALIZED        	// merge SE, vrmadness		// GJR 7/4/95	Personalize(); #endif //MACINTOSH  || PERSONALIZED #if !PERSONALIZED			// merge SE, vrmadness		// GJR 7/4/95  was SPECIAL_EDITION	if ((GetSerial(codedStr,4)) && (DoExpirationDate(codedStr, date)))		{		AlertDialog *alert;		VPlaySound(beepSound);		alert=new(AlertDialog);		alert->cAlertDialog(date);		VExitToShell();		} #endif //!PERSONALIZED		// merge SE, vrmadness		// GJR 7/4/95#else // SAVE_DISABLED 	date[0] = '\0';#endif //!SAVE_DISABLED // jca 22Feb95#if HELPON	if(hflag)count=4;	else count=1;#else	count=1;#endif  //HELPON	#if CLOUDS 		// no clouds for VPRO		/*give the Mac time to do whatever it is it does*/	/*-----clouds-----*/	disp=new(V_Offscreen);	if(disp->LoadPNum(CLOUD_PICT,0)){disp=NULL; goto fine;}	disp->GetRect(&r);	sR=r;	r.right+=159-38;	cloud=new(V_Offscreen);		if(depth>2) {if(cloud->cOffscreen(&r,depth,&blue,NULL)){cloud=NULL; goto fine;}}	else{if(cloud->cOffscreen(&r,0,&vBlack,NULL)){cloud=NULL; goto fine;}}	#if MACINTOSH	VBackColor(&vWhite);	disp->MetaToMode(cloud,&sR,&sR,vNotSrcBic);	r.left=sR.right;	r.right=r.left+159-38;	sR.left=0;	sR.right=159-38;	disp->MetaToMode(cloud,&sR,&r,vNotSrcBic);	disp->dOffscreen();#elif WINDOWS	VBackColor(&vWhite);	disp->MetaToMode(cloud,&sR,&sR,SRCPAINT); //vNotSrcBic);	r.left=sR.right;	r.right=r.left+159-38;	sR.left=0;	sR.right=159-38;	disp->MetaToMode(cloud,&sR,&r,SRCPAINT);//vNotSrcBic);	disp->dOffscreen();#endif	/*-----mask-----*/	cloud->GetRect(&sR);	sR.left=0;	sR.right=159-38;	mask=new(V_Offscreen);	if(mask->cOffscreen(&sR,0,&vWhite,NULL)){mask=NULL; goto fine;}		disp=new(V_Offscreen);	if(disp->LoadPNum(MASK_PICT,0)){disp=NULL; goto fine;}	disp->GetRect(&mR);		mR.top-=34;#if MACINTOSH	mR.bottom=mR.top+(sR.bottom-sR.top);#elif WINDOWS	mR.bottom=mR.top+(sR.bottom-sR.top-1);#endif	mR.left=(mR.right+mR.left-sR.right-sR.left)>>1;	mR.right=mR.left+(sR.right-sR.left);	mR.top+=34;#if MACINTOSH	sR.top+=34;#elif WINDOWS	sR.top+=34;	sR.bottom-=1;#endif	disp->MetaTo(mask,&mR,&sR);	disp->dOffscreen();	disp=NULL;	#if CONFIDENTIAL	disp=new(V_Offscreen);	if(disp->LoadPNum(CONF_PICT,0)){disp=NULL; goto fine;}	disp->GetRect(&mR);	sR=mR;	sR.top+=39;	sR.left+=12;	sR.right+=12;	sR.bottom+=39;	disp->MetaToMode(mask,&mR,&sR,vPatOr);	disp->dOffscreen();	disp=NULL;#endif //CONFIDENTIAL		mask->SetMetaPort();	mask->GetRect(&mR);	VInvertRect(&mR);	mask->UnsetMetaPort();		#endif // !VPRO // no clouds for VPRO		/*-----main-----*/	main=new(V_Offscreen);#if VPRO#if WINDOWS	if (depth >= 4)		main->LoadPNum(MAIN2_PICT,0);	//WRONG!!!! need small-depth pro	else		main->LoadPNum(MAIN_PICT,8);#elif MACINTOSH	main->LoadPNum(MAIN_PICT,8);#endif // WINDOWS#else // VPRO#if WINDOWS	if (depth >= 4)		main->LoadPNum(MAIN2_PICT,0);	else		main->LoadPNum(MAIN_PICT,0);#elif MACINTOSH	main->LoadPNum(MAIN_PICT,0);#endif // WINDOWS#endif // VPRO	main->GetRect(&wR);	GetScreen(&sR);	h=wR.bottom-wR.top;	w=wR.right-wR.left;#if WINDOWS   	h++; w++; //more windows-only fiddling#endif	wR.top=(sR.bottom+sR.top-h)>>1;	wR.bottom=wR.top+h;	wR.left=(sR.right+sR.left-w)>>1;	wR.right=wR.left+w;#if HELPON	if(hflag)		{		/*-----data-----*/		data=new(V_Offscreen);		if(data->LoadPNum(DATA_PICT,0)){data=NULL; goto fine;}		data->GetRect(&dR);		dR.left+=182;		dR.right+=182;		dR.top+=4;		dR.bottom+=4;	/**/			/*-----help-----*/		help=new(V_Offscreen);		if(help->LoadPNum(HELP_PICT,0)){help=NULL; goto fine;}		help->GetRect(&hR);		hR.left+=182;		hR.right+=182;		hR.top+=2;		hR.bottom+=2;				/*-----help2-----*/		help2=new(V_Offscreen);		if(help2->LoadPNum(HELP2_PICT,0)){help2=NULL; goto fine;}		help2->GetRect(&hR2);		hR2.left+=182;		hR2.right+=182;		hR2.top+=2;		hR2.bottom+=2;		}		#endif  //HELPON#if MACINTOSH	{	int i;		mouseRgn = NULL;	for(i=0;i<100;i++)		WaitNextEvent(0L, &myEvent,0,mouseRgn);/*clear out any pauses*/	}#endif //MACINTOSH		/*-----window-----*/	win=new(V_Window);#if MACINTOSH	win->cWindow(&wR,TXT_VIRTUSCORP,p,p,p,MODALWINDOW,WINDOW_CLOSE);	// MERGE-GOURAUD-PRO-8#elif WINDOWS	win->cWindow(&wR,TXT_VIRTUSCORP,p,p,p,MODALDIALOG,WINDOW_CLOSE);#endif //MACINTOSH	win->Show();#if WINDOWS	SetGraphicContext(hDC=GetDC(win->theWindow));	//win->SetWPort(); why?#endif //WINDOWS 	main->GetRect(&wR);	main->MetaTo(win,&wR,&wR);	main->dOffscreen();	main=NULL;#if WINDOWS	oldBkMode = SetBkMode(hDC, TRANSPARENT);  // jca don't overwrite the background#endif#if !SPECIAL_EDITION         	// merge SE, vrmadness		// GJR 7/4/95	DrawSerial(wR.left+36,wR.bottom-72);#else	DrawSerial(wR.left+24,wR.bottom-78);#endif //!SPECIAL_EDITION         	// merge SE, vrmadness		// GJR 7/4/95#if MACINTOSH	txtR.left = 197;	txtR.bottom = 24;#elif WINDOWS	txtR.left = 177;	txtR.bottom = 18;#endif	txtR.top = txtR.bottom-12;	if(strlen(date)) VDrawText(date,0,strlen(date),&txtR);  // jca#if WINDOWS	SetBkMode(hDC, oldBkMode);#endif	#if CLOUDS	cloud->GetRect(&sR);		w=sR.right-sR.left-(159-38);	wR.left=38;	wR.right=159;	wR.top=1;#if MACINTOSH	wR.bottom=sR.bottom+1;#elif WINDOWS	wR.bottom=sR.bottom;#endif	sR.right=wR.right-wR.left;	#endif // !VPRO	#if CONFIDENTIAL	{	Rect r1,r2;	disp=new(V_Offscreen);	if(disp->LoadPNum(CONF_PICT,0)){disp=NULL; goto fine;}	disp->GetRect(&r1);	r2=r1;	r2.top+=40;	r2.left+=50;	r2.right+=50;	r2.bottom+=40;	ForeColor(redColor);	disp->MetaToMode(win,&r1,&r2,vPatOr);	disp->dOffscreen();	disp=NULL;	}#endif //CONFIDENTIAL	/*-----do it-----*/	VSetCursor(vCursorArrow);	/*FlushEvents(everyEvent,0);*/	while(count)		{		#if CLOUDS		while(VButton())			{			sR.left++;			sR.right++;			if(sR.left>w)				{				sR.left=0;				sR.right=wR.right-wR.left;				}			cloud->MaskMetaToMain(win,mask,&sR,&mR,&wR);			}		#endif // !VPRO		ticktock=VGetTime();		cTime=ticktock;		VFlushEvents(0);#if WINDOWS		SetFocus(win->theWindow);        SetCapture(win->theWindow);#endif //WINDOWS		while(hflag||(ticktock+WAITTIME(SIX_SECONDS))>cTime)			{			bcount++;#if WINDOWS				{				MSG msg;				if(PeekMessage(&msg,NULL,0,0,PM_NOYIELD|PM_REMOVE))					{					if((msg.message >=WM_KEYFIRST &&						msg.message <=WM_KEYLAST) ||						(msg.message >=(WM_MOUSEFIRST+1) &&						msg.message <=WM_MOUSELAST))						break;					if(msg.message!=WM_MOUSEMOVE)                    	{						TranslateMessage(&msg);						DispatchMessage(&msg);						}					}//				if(VEventWaiting(mDownMask|mUpMask|keyDownMask|autoKeyMask))//					break;				bcount=0;				}#elif MACINTOSH			if(bcount&8)				{				if(WaitNextEvent(keyDownMask|mDownMask, &myEvent,0,0L))					break;				bcount=0;				}//			if(count!=1)ticktock=VGetTime();#endif //WINDOWS			#if CLOUDS			sR.left++;			sR.right++;			if(sR.left>w)				{				sR.left=0;				sR.right=wR.right-wR.left;				}			cloud->MaskMetaToMain(win,mask,&sR,&mR,&wR);			#endif // !VPRO            cTime = VGetTime();			}#if WINDOWS	ReleaseCapture();#endif //WINDOWS#if HELPON		switch(count)			{			case 4:				data->GetRect(&r);				data->MetaTo(win,&r,&dR);				data->dOffscreen();				data=NULL;				break;			case 3:				help->GetRect(&r);				help->MetaTo(win,&r,&hR);				help->dOffscreen();				help=NULL;				break;			case 2:				help2->GetRect(&r);				help2->MetaTo(win,&r,&hR2);				help2->dOffscreen();				help2=NULL;				break;			}#endif //HELPON		count--;		}			fine:#if WINDOWS	ReleaseDC(win->theWindow, hDC);	SetGraphicContext(NULL);#endif //WINDOWS	VSetCursor(vCursorArrow);	if(win)win->dWindow();	if(disp)disp->dOffscreen();	if(cloud)cloud->dOffscreen();	if(data)data->dOffscreen();	if(help)help->dOffscreen();	if(help2)help2->dOffscreen();	if(mask)mask->dOffscreen();	VSetCursor(vCursorArrow);	VFlushEvents(mDownMask|mUpMask|keyDownMask|keyUpMask|autoKeyMask);	}#elif VR#if VPLAYER||TestingVplayer                    // !VPLAYER testervoidAboutThisApplication(int hflag){	extern TextureShader gTextureShader;	V_Offscreen 	*saveOff, *useOff, *rememberOff, *inLogo;    V_Pixel8		*logo[6];	int				 iAllowTexture;						// GJR 02/22/94	ConfigurePreference *configure;						// GJR 02/22/94    int				 iErr;								// GJR 02/23/94	V_Display		*mainScreen;	V_Array			*frontPts, *backPts, *outsidePts, *texturePts;	V_Pane			*winPane, *rememberPane;	Clip			*aboutClip;	short			cosAngle, sinAngle, angle = 0, cosAngleB, sinAngleB, angle2 = 0;	Point			*frontA, *backA, *outsideA;	PointFFixed		*textureA, tempFF;	RGBColor		polyColor, Cblack = {0x0000,0x0000,0x0000};    struct TextureRendSettings rset;	Rect			wR,sR,logoR;	int				h, w, i, i_next, count=1, bcount=0, dontStop=TRUE, offSet;	long			ticktock, cTime, normalTemp, colorTemp;	Point			p, staticP[4];	Point3D			temp3D, vex1, vex2, normals[6], nowNormals[6];	Point3D			light = {-60,110,-220};#if WINDOWS	HDC			hDC;    V_Window	* win;#elif MACINTOSH	EventRecord	myEvent;#endif //WINDOWS	#if FALSE	#define TESTING_ABOUTBOX TRUE	hflag = 1;#endif //DEBUG	if (FreeMem() < 486000)		{		AlertMessage(txt_notEnoughMemory);		return;		}#if VPLAYER							// help debug from within vr     // GJR 02/22/94	VWIMessage(TXTB_PLAYERABOUT);#endif		// Get clip/flash selection stuff in.		// GJR 02/22/94	configure = new(ConfigurePreference);	configure->cPreference();	configure->LoadConfigure();    configure->dPreference();	wR.top = 0;	wR.bottom = 228;	wR.left = 0;	wR.right = 308;	rememberOff = offscreen;	saveOff = new(V_Offscreen);    	if (!saveOff) {VPlaySound(beepSound); return;}	iErr = saveOff->cOffscreen(&wR,-1,NULL,NULL);		if (iErr) {VPlaySound(beepSound); return;}	useOff = new(V_Offscreen);		if (!useOff) {VPlaySound(beepSound); return;}	useOff->cOffscreen(&wR,MainDepth(),NULL,NULL);		if (iErr) {VPlaySound(beepSound); return;}// Replaced and moved up. Made better. Why test at all? Minimum memory already checked. // GJR 02/23/94//	if (!(saveOff && useOff))// 		{// 		VPlaySound(beepSound);// 		return;// 		}	//-------------------------------------// End of input checks.// End of quickie "return if error" methods.// FROM NOW ON, CLEAN UP IS HARDER. NO MORE "just return".//-------------------------------------	// Set up Clip with our new useOff offscreen							// GJR 02/22/94	if (offscreen) offscreen->UnSetCurrent();  //GJR 02/23/94	useOff->SetCurrent();	offscreen = useOff;	aboutClip = new(Clip);	aboutClip->cClip();    iAllowTexture = (aboutClip->method != 0);    // allow Texture only if method supports flash.	useOff->UnSetCurrent();	offscreen = rememberOff;	if (offscreen) offscreen->SetCurrent();  //GJR 02/23/94	logoR.left = 0;	logoR.top = 0;	logoR.right = 128;	logoR.bottom = 128;		for(i=0;i<6;i++)		{		logo[i] = NULL;		  			// Error Handling or NoTextures(please)		// GJR 02/23/94        inLogo  = NULL;					// prepare for error handling		// GJR 02/23/94		if (iAllowTexture)        	{			inLogo= new(V_Offscreen);            	if (inLogo == NULL) goto ErrorCreatingLogo;			iErr = inLogo->LoadPNum(500 + i,8);           		if (iErr) goto ErrorCreatingLogo;			logo[i] = new(V_Pixel8);            	if (logo[i] == NULL) goto ErrorCreatingLogo;			iErr = logo[i]->cCreateCopy(inLogo);            	if (iErr) goto ErrorCreatingLogo;			logo[i]->Lock();			goto DoneCreatingLogo;ErrorCreatingLogo:;			ASSERT(FALSE);	// Oops, couldn't read in logo for some reason			// GJR 02/23/94			if (logo[i])				{				logo[i]->dPixel8();				logo[i] = NULL;                }DoneCreatingLogo:;			if (inLogo)            	{				inLogo->dOffscreen();                }			}		}	frontPts = new(V_Array);	frontPts->cArray(0,sizeof(Point),4);	backPts = new(V_Array);                              	backPts->cArray(0,sizeof(Point),4);	outsidePts = new(V_Array);	outsidePts->cArray(4,sizeof(Point),4);	if (iAllowTexture)    	{		texturePts = new(V_Array);		texturePts->cArray(0,sizeof(PointFFixed),4);		}	else		{		texturePts = NULL;		}	vex2.x = 0;	vex2.y = 0;	vex2.z = 30;	staticP[0].v = -64; staticP[0].h = -64;	frontPts->Append(&staticP[0]);	backPts->Append(&staticP[0]);	staticP[1].v = -64; staticP[1].h = 64;	frontPts->Append(&staticP[1]);	backPts->Append(&staticP[1]);	staticP[2].v = 64; staticP[2].h = 64;	frontPts->Append(&staticP[2]);	backPts->Append(&staticP[2]);	staticP[3].v = 64; staticP[3].h = -64;	frontPts->Append(&staticP[3]);	backPts->Append(&staticP[3]);	frontA = (Point*)frontPts->Use();	backA = (Point*)backPts->Use();	outsideA = (Point*)outsidePts->Use();	if (iAllowTexture)    	{		textureA = (PointFFixed*)texturePts->Use();		for (i = 0; i < 4; i++)			{			tempFF.h.frac = 0;			tempFF.h.intg = frontA[i].h + ((logoR.right - logoR.left)>>1);			tempFF.v.frac = 0;			tempFF.v.intg = ((logoR.bottom - logoR.top)>>1) - frontA[i].v;			texturePts->Append(&tempFF);			}		rset.decal = FALSE;		rset.colorize = TRUE;		rset.hMirror = FALSE;		rset.vMirror = FALSE;		rset.hFlip = TRUE;		rset.vFlip = FALSE;		rset.textureShade = &(gTextureShader[0]);		rset.filtered_color = Cblack;		rset.mip_rect[0] = logoR;		}	else    	{		textureA = NULL;        }	normals[0].x = 0;	normals[0].y = -256;	normals[0].z = 0;	nowNormals[0] = normals[0];	normals[1].x = 256;	normals[1].y = 0;	normals[1].z = 0;	nowNormals[1] = normals[1];	normals[2].x = 0;	normals[2].y = 256;	normals[2].z = 0;	nowNormals[2] = normals[2];	normals[3].x = -256;	normals[3].y = 0;	normals[3].z = 0;	nowNormals[3] = normals[3];	normals[4].x = 0;	normals[4].y = 0;	normals[4].z = 256;	normals[5].x = 0;	normals[5].y = 0;	normals[5].z = -256;	nowNormals[4] = normals[4];	nowNormals[5] = normals[5];		outsideA = (Point*)outsidePts->Use();	GetScreen(&sR);	h=wR.bottom-wR.top;	w=wR.right-wR.left;	wR.top=(sR.bottom - sR.top -h + 40)>>1;	wR.top &= ~0x0003;	wR.bottom=wR.top+h;	wR.left=(sR.right - sR.left -w + 70)>>1;	wR.left &= ~0x0003;	wR.right=wR.left+w;		/*-----window-----*/	winPane = new(V_Pane);	winPane->cPane(0);	winPane->rect = wR;#if WINDOWS	// BILBIL - minimize on use bug fix - 11/30/93 {{{	VFlushEvents(mDownMask|mUpMask|keyDownMask|keyUpMask|autoKeyMask|			updateMask|diskMask|app2Mask);	MSG msg;	if(PeekMessage(&msg,NULL,0,0,PM_NOYIELD|PM_REMOVE))		if(msg.message!=WM_MOUSEMOVE)        	{			TranslateMessage(&msg);			DispatchMessage(&msg);			}	// BILBIL - minimize on use bug fix - 11/30/93 }}}	win = new(V_Window);	win->cWindow(&wR,TXT_VIRTUSCORP,p,p,p,POPUPDIALOG|BORDERLESS,WINDOW_CLOSE);	SetGraphicContext(hDC=GetDC(win->theWindow));	win->Show();	SetFocus(win->theWindow);	SetCapture(win->theWindow);	saveOff->ToMeta(win,&(saveOff->rect),&(saveOff->rect));#elif MACINTOSH	screen->Get(0, &mainScreen);	saveOff->ToMeta(mainScreen,&wR,&(saveOff->rect));		// BILBIL - 11/15/93#endif //WINDOWS	if (offscreen) offscreen->UnSetCurrent();  // ?? undo current state //GJR 02/23/94	useOff->SetCurrent();            // activate our new overriding offscreen	offscreen = useOff;	rememberPane = currentPane;	currentPane = winPane;	/*-----do it-----*/	VSetCursor(vCursorArrow);	VFlushEvents(0);	ticktock=VGetTime();	cTime=ticktock;#if MACINTOSH	SetEventMask(keyDownMask|mDownMask);#endif //MACINTOSH	while(dontStop||(ticktock+WAITTIME(SIX_SECONDS))>cTime)		{		bcount++;#if WINDOWS		currentPane = rememberPane;			// BILBIL restore drawing env		useOff->UnSetCurrent();				// BILBIL restore drawing env		offscreen = rememberOff;			// BILBIL restore drawing env        if (offscreen) offscreen->SetCurrent();  //GJR 02/23/94		MSG msg;		if(PeekMessage(&msg,NULL,0,0,PM_NOYIELD|PM_REMOVE))			{			if((msg.message >=WM_KEYFIRST &&					msg.message <=WM_KEYLAST) ||					(msg.message >=(WM_MOUSEFIRST+1) &&					msg.message <=WM_MOUSELAST))				break;			if(msg.message!=WM_MOUSEMOVE)				{				TranslateMessage(&msg);				DispatchMessage(&msg);				}			}		bcount=0;		currentPane = winPane;			// BILBIL get drawing env back		if (offscreen) offscreen->UnSetCurrent();  //GJR 02/23/94		useOff->SetCurrent();			// BILBIL get drawing env back		offscreen = useOff;				// BILBIL get drawing env back#elif MACINTOSH		if(bcount&8)			{#ifdef __powerc			if(LMGetEventQueue()->qHead != NULL)#else			if(GetEvQHdr()->qHead != NULL)#endif //__powerc				break;			bcount=0;			}#endif //WINDOWS		cTime = VGetTime();#if WINDOWS	ReleaseCapture();#endif //WINDOWS		saveOff->MetaTo(useOff,&(useOff->rect),&(saveOff->rect));		//draw the shadow		winPane->centerX = 193;		winPane->centerY = 133;		for (i=0; i< 4; i++)			{			i_next = (i+1) & 0x0003;			outsideA[0].h = frontA[i].h;			outsideA[0].v = frontA[i].v;			outsideA[1].h = frontA[i_next].h;			outsideA[1].v = frontA[i_next].v;			outsideA[2].h = backA[i_next].h;			outsideA[2].v = backA[i_next].v;			outsideA[3].h = backA[i].h;			outsideA[3].v = backA[i].v;			aboutClip->DrawPoly(outsidePts,CLIP_FILL,NULL,FEAT_TRANSLUCENT,vPatBlack,&Cblack,&Cblack,FALSE,NULL);				// MERGE-GOURAUD			}		aboutClip->DrawPoly(backPts,CLIP_FILL,NULL,FEAT_TRANSLUCENT,vPatBlack,&Cblack,&Cblack,FALSE,NULL);			// MERGE-GOURAUD		aboutClip->DrawPoly(frontPts,CLIP_FILL,NULL,FEAT_TRANSLUCENT,vPatBlack,&Cblack,&Cblack,TRUE,NULL);			// MERGE-GOURAUD		// now draw the sign		winPane->centerX = 118;		winPane->centerY = 93;		for (i=0; i< 4; i++)			{			i_next = (i+1) & 0x0003;			outsideA[0].h = frontA[i].h;			outsideA[0].v = frontA[i].v;			outsideA[1].h = frontA[i_next].h;			outsideA[1].v = frontA[i_next].v;			outsideA[2].h = backA[i_next].h;			outsideA[2].v = backA[i_next].v;			outsideA[3].h = backA[i].h;			outsideA[3].v = backA[i].v;			colorTemp = nowNormals[i].x*((Long)light.x);			colorTemp += nowNormals[i].y*((Long)light.y);			colorTemp += nowNormals[i].z*((Long)light.z);			if (logo[i])				{				if (colorTemp < 0) colorTemp = 0;				colorTemp = colorTemp >> 11;				colorTemp = 31 - colorTemp;	//presumes 0..31  (not so)  Correct it. //GJR 12/21/93				colorTemp -= 4;		// correction. Force 0..27. 0 for white, 27 for dark, not black.            	colorTemp = min(max(0,colorTemp),27);				rset.mip[0] = logo[i];				rset.textureShade = &(gTextureShader[colorTemp]);				ShadedLinearTexture8(&rset,offscreen,texturePts,Ident(outsidePts,FALSE),aboutClip);				}			else				{				if (colorTemp < 0)					colorTemp = 0;				polyColor.red = colorTemp;				polyColor.blue = colorTemp;				polyColor.green = colorTemp; 				aboutClip->DrawPoly(outsidePts,CLIP_FILL|CLIP_DITHER,NULL,0,vPatBlack,&polyColor,&Cblack,FALSE,NULL);					// MERGE-GOURAUD				}			}		colorTemp = nowNormals[4].x*((Long)light.x);		colorTemp += nowNormals[4].y*((Long)light.y);		colorTemp += nowNormals[4].z*((Long)light.z);		if (logo[4])			{			if (colorTemp < 0) colorTemp = 0;			colorTemp = colorTemp >> 11;			colorTemp = 31 - colorTemp;	//presumes 0..31  (not so)  Correct it. //GJR 12/21/93			colorTemp -= 4;		// correction. Force 0..27. 0 for white, 27 for dark, not black.            	colorTemp = min(max(0,colorTemp),27);			rset.mip[0] = logo[4];			rset.textureShade = &(gTextureShader[colorTemp]);			ShadedLinearTexture8(&rset,offscreen,texturePts,Ident(frontPts,TRUE),aboutClip);			}		else			{			if (colorTemp < 0)				colorTemp = 0;			polyColor.red = colorTemp;			polyColor.blue = colorTemp;			polyColor.green = colorTemp;			aboutClip->DrawPoly(backPts,CLIP_FILL|CLIP_DITHER,NULL,0,vPatBlack,&polyColor,&Cblack,FALSE,NULL);			// MERGE-GOURAUD			}		colorTemp = nowNormals[5].x*((Long)light.x);		colorTemp += nowNormals[5].y*((Long)light.y);		colorTemp += nowNormals[5].z*((Long)light.z);		if (logo[5])			{			if (colorTemp < 0) colorTemp = 0;			colorTemp = colorTemp >> 11;			colorTemp = 31 - colorTemp;	//presumes 0..31  (not so)  Correct it. //GJR 12/21/93			colorTemp -= 4;		// correction. Force 0..27. 0 for white, 27 for dark, not black.            	colorTemp = min(max(0,colorTemp),27);			rset.mip[0] = logo[5];			rset.textureShade = &(gTextureShader[colorTemp]);			ShadedLinearTexture8(&rset,offscreen,texturePts,Ident(backPts,FALSE),aboutClip);			}		else			{			if (colorTemp < 0)				colorTemp = 0;			polyColor.red = colorTemp;			polyColor.blue = colorTemp;			polyColor.green = colorTemp;			aboutClip->DrawPoly(backPts,CLIP_FILL|CLIP_DITHER,NULL,0,vPatBlack,&polyColor,&Cblack,FALSE,NULL);						}#if WINDOWS		useOff->GetRect(&wR);		useOff->MetaTo(win,&wR,&wR);#elif MACINTOSH		useOff->MetaTo(mainScreen,&(useOff->rect),&wR);#endif //WINDOWS//		useOff->SetCurrent();        //GJR 02/23/94		//transform old points to go to new ones		angle = (angle+2)&0x00ff;		if ((angle < 2) && (hflag == 0))			dontStop = FALSE;		angle2 = (angle2+1)&0x00ff;		cosAngle = cos256w(angle);		sinAngle = sin256w(angle);		cosAngleB = cos256w(angle2);		sinAngleB = sin256w(angle2);				for (i = 0; i < 4; i++)			{			short	z1,z2;			/* rot in Z */			frontA[i].h = ((cosAngle * (long)(staticP[i].h))>>15)					+ ((sinAngle * (long)staticP[i].v)>>15);			backA[i].h = ((cosAngle * (long)(staticP[i].h))>>15)					+ ((sinAngle * (long)staticP[i].v)>>15);			frontA[i].v = ((cosAngle * (long)(staticP[i].v))>>15)					- ((sinAngle * (long)staticP[i].h)>>15);			backA[i].v = ((cosAngle * (long)(staticP[i].v))>>15)					- ((sinAngle * (long)staticP[i].h)>>15);			/* rot in Y */			frontA[i].h = ((cosAngleB * (long)(frontA[i].h))>>15)					- ((sinAngleB * (long)64)>>15);			backA[i].h = ((cosAngleB * (long)(backA[i].h))>>15)					- ((sinAngleB * (long)(-64))>>15);//			z1 = ((sinAngleB * (long)(frontA[i].h))>>15)//					+ ((cosAngleB * (long)64)>>15);//			z2 = ((sinAngleB * (long)(backA[i].h))>>15)//					+ ((cosAngleB * (long)(-64))>>15);			/* rot in X *//*			frontA[i].v = ((cosAngle * (long)(frontA[i].v))>>15)					+ ((sinAngle * (long)z1)>>15);			backA[i].v = ((cosAngle * (long)(backA[i].v))>>15)					+ ((sinAngle * (long)z2)>>15);			z1 = ((cosAngle * (long)z1)>>15)					- ((sinAngle * (long)(frontA[i].v))>>15);			z2 = ((cosAngle * (long)z2)>>15)					- ((sinAngle * (long)(backA[i].v))>>15);*/			}		nowNormals[0].x = ((sinAngle * (long)normals[0].y)>>15);		nowNormals[0].y = ((cosAngle * (long)normals[0].y)>>15);		nowNormals[0].z = ((sinAngleB * (long)nowNormals[0].x)>>15);		nowNormals[0].x = ((cosAngleB * (long)nowNormals[0].x)>>15);		nowNormals[1].x = ((cosAngle * (long)normals[1].x)>>15);		nowNormals[1].y = -((sinAngle * (long)normals[1].x)>>15);		nowNormals[1].z = ((sinAngleB * (long)nowNormals[1].x)>>15);		nowNormals[1].x = ((cosAngleB * (long)nowNormals[1].x)>>15);		nowNormals[2].x = ((sinAngle * (long)normals[2].y)>>15);		nowNormals[2].y = ((cosAngle * (long)normals[2].y)>>15);		nowNormals[2].z = ((sinAngleB * (long)nowNormals[2].x)>>15);		nowNormals[2].x = ((cosAngleB * (long)nowNormals[2].x)>>15);		nowNormals[3].x = ((cosAngle * (long)normals[3].x)>>15);		nowNormals[3].y = -((sinAngle * (long)normals[3].x)>>15);		nowNormals[3].z = ((sinAngleB * (long)nowNormals[3].x)>>15);		nowNormals[3].x = ((cosAngleB * (long)nowNormals[3].x)>>15);		nowNormals[4].x = -((sinAngleB * (long)normals[4].z)>>15);		nowNormals[4].z = ((cosAngleB * (long)normals[4].z)>>15);		nowNormals[5].x = -((sinAngleB * (long)normals[5].z)>>15);		nowNormals[5].z = ((cosAngleB * (long)normals[5].z)>>15);		}			fine:#if WINDOWS	saveOff->MetaTo(win,&(saveOff->rect),&wR);#elif MACINTOSH	saveOff->MetaTo(mainScreen,&(saveOff->rect),&wR);#endif //WINDOWS	useOff->UnSetCurrent();	frontPts->Unuse();	frontPts->dArray();	backPts->Unuse();	backPts->dArray();	outsidePts->Unuse();	outsidePts->dArray();	if (texturePts)    	{		texturePts->Unuse();		texturePts->dArray();		}	if(saveOff) saveOff->dOffscreen();	if(useOff) useOff->dOffscreen();	for (i=0;i<6;i++)		if (logo[i])			{			logo[i]->Unlock();			logo[i]->dPixel8();			}	if(aboutClip) aboutClip->dClip();	if(winPane) winPane->dPane();	offscreen = rememberOff;	if (offscreen) offscreen->SetCurrent();  // ??Restore prior global (current) state //GJR 02/23/94	currentPane = rememberPane;#if MACINTOSH	SetEventMask(everyEvent&(~keyUpMask));#elif WINDOWS	ReleaseDC(win->theWindow, hDC);	SetGraphicContext(NULL);	win->dWindow();#endif //WINDOWS	VSetCursor(vCursorArrow);	VFlushEvents(mDownMask|mUpMask|keyDownMask|keyUpMask|autoKeyMask);#if TESTING_ABOUTBOX	VExitToShell();#endif //TESTING_ABOUTBOX}#else // VR, not VPLAYERvoidAboutThisApplication(int hflag){	extern TextureShader gTextureShader;	V_Offscreen 	*saveOff, *useOff, *rememberOff, *inLogo1, *inLogo2;	V_Pixel8		*logo1, *logo2;	int				 iAllowTexture;						// GJR 02/22/94	ConfigurePreference *configure;						// GJR 02/22/94    int				 iErr;								// GJR 02/22/94	V_Display		*mainScreen;	V_Array			*frontPts, *backPts, *outsidePts, *texturePts;	V_Pane			*winPane, *rememberPane;	Clip			*aboutClip;	short			cosAngle, sinAngle, angle = 0;	Point			*frontA, *backA, *outsideA;	PointFFixed		*textureA, tempFF;	RGBColor		red = {0xFFFF,0x0000,0x0000};	RGBColor		Cblack = {0x0000,0x0000,0x0000};    struct TextureRendSettings rset;	Rect			wR,sR, tempRect;	int				h, w, i, count=1, bcount=0, dontStop=TRUE, flip, offSet;	long			ticktock, cTime, normalTemp, colorTemp;	Point			p;	Point3D			temp3D, vex1, vex2, normals[30], nowNormals[30];	Point3D			light = {-60,110,220};	string serialString[RESOURCE_STR_SIZE * 3];         // jca 5 Dec 93 moved this up {	string serial[RESOURCE_STR_SIZE],verStr[RESOURCE_STR_SIZE];	string name[RESOURCE_STR_SIZE],organization[RESOURCE_STR_SIZE];	string dateStr[RESOURCE_STR_SIZE];                 // jca 5 Dec 93 moved this up }	char * lastinfo;	Point			signPoints[28] = {#if MACINTOSH		{ 93,  24}, { 87,  68}, { 75, 109}, { 58, 144}, { 29, 173}, { 15, 179}, {  6, 180},		{ -6, 180}, {-15, 179}, {-29, 173}, {-58, 144}, {-75, 109}, {-87,  68}, {-93,  24},		{-93, -24}, {-87, -68}, {-75,-109}, {-58,-144}, {-29,-173}, {-15,-179}, { -6,-180},		{  6,-180}, { 15,-179}, { 29,-173}, { 58,-144}, { 75,-109}, { 87, -68}, { 93, -24}#elif WINDOWS		{  24, 93}, {  68, 87}, { 109, 75}, { 144, 58}, { 173, 29}, { 179, 15}, { 180,  6},		{ 180, -6}, { 179,-15}, { 173,-29}, { 144,-58}, { 109,-75}, {  68,-87}, {  24,-93},		{ -24,-93}, { -68,-87}, {-109,-75}, {-144,-58}, {-173,-29}, {-179,-15}, {-180, -6},		{-180,  6}, {-179, 15}, {-173, 29}, {-144, 58}, {-109, 75}, { -68, 87}, { -24, 93}#endif //MACINTOSH	};#if WINDOWS	HDC			hDC;    V_Window	* win;#elif MACINTOSH	EventRecord	myEvent;#endif //WINDOWS	#if (MACINTOSH && (!JAPANESE)) || (WINDOWS && PERSONALIZED)	Personalize();#endif //MACINTOSH#if FALSE	hflag = 1;#endif //DEBUG#if !PERSONALIZED	if(!GetVersion(verStr)) Damaged();#if !SAVE_DISABLED // jca 22Feb95	if(!GetSerial(serial,1)) Damaged();	if(!GetSerial(name,2)) Damaged();	if(!GetSerial(organization,3)) Damaged();	lastinfo = organization; #if !BUNDLED	if(DoExpirationDate((char*)CheckDate(serial),dateStr)) lastinfo = dateStr; #endif // !BUNDLED#endif // !PERSONALIZED	if (hflag)    // don't display if we can't display		{		sprintf(serialString,"%s %s - %s: %s - %s - %s",TXT_VERSION,verStr,TXT_SERIAL,serial,				name,lastinfo);		VWIMessage(serialString);		}#else // SAVE_DISABLED	if (hflag)    // don't display if we can't display		{		sprintf(serialString,"%s %s",TXT_VERSION,verStr);		VWIMessage(serialString);		}#endif //!SAVE_DISABLED // jca 22Feb95	if (FreeMem() < 486000)		{		AlertMessage(txt_notEnoughMemory);		return;		}	// Get clip/flash selection stuff in.		// GJR 02/22/94	configure = new(ConfigurePreference);	configure->cPreference();	configure->LoadConfigure();    configure->dPreference();	wR.top = 0;	wR.bottom = 228;	wR.left = 0;	wR.right = 432;	rememberOff = offscreen;	saveOff = new(V_Offscreen);    	if (!saveOff) {VPlaySound(beepSound); return;}	iErr = saveOff->cOffscreen(&wR,-1,NULL,NULL);		if (iErr) {VPlaySound(beepSound); return;}	useOff = new(V_Offscreen);		if (!useOff) {VPlaySound(beepSound); return;}	useOff->cOffscreen(&wR,MainDepth(),NULL,NULL);		if (iErr) {VPlaySound(beepSound); return;}// Replaced and moved up. Made better. Why test at all? Minimum memory already checked. // GJR 02/23/94//	if (!(saveOff && useOff))// 		{// 		VPlaySound(beepSound);// 		return;// 		}    // Set up Clip with our new useOff offscreen							// GJR 02/22/94	useOff->SetCurrent();	offscreen = useOff;	aboutClip = new(Clip);	aboutClip->cClip();    iAllowTexture = (aboutClip->method != 0);    // allow Texture only if method supports flash.	useOff->UnSetCurrent();	offscreen = rememberOff;    logo1   = NULL;		// Prepare for no texture allowed. 		// GJR 02/22/94	logo2   = NULL;	inLogo1 = NULL;     // Prepare for error recovery.			// GJR 02/22/94	inLogo2 = NULL;	if (iAllowTexture)											// GJR 02/22/94    	{		inLogo1= new(V_Offscreen);				if (inLogo1 == NULL) goto ErrorCreatingLogo;		inLogo2= new(V_Offscreen);				if (inLogo2 == NULL) goto ErrorCreatingLogo;		if (hflag != -1)			{			iErr = inLogo1->LoadPNum(300,8); // VR PICT number = 300				if (iErr) goto ErrorCreatingLogo;			iErr = inLogo2->LoadPNum(301,8); // VR PICT number = 301				if (iErr) goto ErrorCreatingLogo;			}		else			{			iErr = inLogo1->LoadPNum(302,8); // VR "Easter egg" PICT number = 302				if (iErr) goto ErrorCreatingLogo;			iErr = inLogo2->LoadPNum(303,8); // VR "Easter egg" PICT number = 303				if (iErr) goto ErrorCreatingLogo;			}//#if WINDOWS//	logo1->SetMetaPort();//	logo2->SetMetaPort();//#endif //WINDOWS		logo1  = new(V_Pixel8);					// texture arrays				if (inLogo1 == NULL) goto ErrorCreatingLogo;		logo2  = new(V_Pixel8);				if (inLogo2 == NULL) goto ErrorCreatingLogo;		iErr = logo1->cCreateCopy(inLogo1);				if (iErr) goto ErrorCreatingLogo;		iErr = logo2->cCreateCopy(inLogo2); 				if (iErr) goto ErrorCreatingLogo;		logo1->Lock();		logo2->Lock();		goto DoneCreatingLogo;ErrorCreatingLogo:;		ASSERT(FALSE);	// Oops, couldn't read in logo for some reason			// GJR 02/23/94		if (logo1) {logo1->dPixel8(); logo1 = NULL;}		if (logo2) {logo2->dPixel8(); logo2 = NULL;}DoneCreatingLogo:;		if (inLogo1) {inLogo1->dOffscreen(); inLogo1 = NULL;}		if (inLogo2) {inLogo2->dOffscreen(); inLogo2 = NULL;}		}// move up	aboutClip = new(Clip); 							// GJR 02/22/94// move up	aboutClip->cClip();        						// GJR 02/22/94// DELETE	aboutClip->method = FLASH_METHOD;			 	// GJR 02/22/94	frontPts = new(V_Array);	frontPts->cArray(0,sizeof(Point),28);	backPts = new(V_Array);                              	backPts->cArray(0,sizeof(Point),28);	outsidePts = new(V_Array);	outsidePts->cArray(4,sizeof(Point),4);	if (iAllowTexture)										// GJR 02/22/94    	{		texturePts = new(V_Array);		texturePts->cArray(0,sizeof(PointFFixed),28);		}	else		{		texturePts = NULL;		}	vex2.x = 0;	vex2.y = 0;	vex2.z = 30;	for (i = 0; i<28; i++)		{		frontPts->Append(&(signPoints[i]));		backPts->Append(&(signPoints[i]));		if (iAllowTexture)									// GJR 02/22/94			{			ASSERT(texturePts != NULL);            ASSERT(logo1 != NULL);			tempFF.h.frac = 0;			tempFF.h.intg = signPoints[i].h + ((logo1->rect.right - logo1->rect.left)>>1);			tempFF.v.frac = 0;			tempFF.v.intg = ((logo1->rect.bottom - logo1->rect.top)>>1) - signPoints[i].v;			texturePts->Append(&tempFF);			}		vex1.x = signPoints[(i+1)%28].h - signPoints[i].h;		vex1.y = signPoints[(i+1)%28].v - signPoints[i].v;		vex1.z = 0;		temp3D.x = -(vex1.y * vex2.z);		temp3D.y = vex1.x * vex2.z;		temp3D.z = 0;		normalTemp = LSqrt(((long)temp3D.x) * temp3D.x + ((long)temp3D.y) * temp3D.y);		temp3D.x = (((long)temp3D.x) *256)/normalTemp;		temp3D.y = (((long)temp3D.y) *256)/normalTemp;		normals[i] = temp3D;		nowNormals[i] = temp3D;		}	normals[28].x = 0;	normals[28].y = 0;	normals[28].z = 256;	normals[29].x = 0;	normals[29].y = 0;	normals[29].z = -256;	nowNormals[28] = normals[28];	nowNormals[29] = normals[29];		GetScreen(&sR);	h=wR.bottom-wR.top;	w=wR.right-wR.left;	wR.top=(sR.bottom - sR.top -h + 40)>>1;	wR.top &= ~0x0003;	wR.bottom=wR.top+h;	wR.left=(sR.right - sR.left -w + 70)>>1;	wR.left &= ~0x0003;	wR.right=wR.left+w;		/*-----window-----*/	winPane = new(V_Pane);	winPane->cPane(0);	winPane->rect = wR;#if WINDOWS	// BILBIL - minimize on use bug fix - 11/30/93 {{{	VFlushEvents(mDownMask|mUpMask|keyDownMask|keyUpMask|autoKeyMask|			updateMask|diskMask|app2Mask);	MSG msg;	if(PeekMessage(&msg,NULL,0,0,PM_NOYIELD|PM_REMOVE))		if(msg.message!=WM_MOUSEMOVE)        	{			TranslateMessage(&msg);			DispatchMessage(&msg);			}	// BILBIL - minimize on use bug fix - 11/30/93 }}}	win = new(V_Window);	win->cWindow(&wR,TXT_VIRTUSCORP,p,p,p,POPUPDIALOG|BORDERLESS,WINDOW_CLOSE);	SetGraphicContext(hDC=GetDC(win->theWindow));	win->Show();	SetFocus(win->theWindow);	SetCapture(win->theWindow);	saveOff->ToMeta(win,&(saveOff->rect),&(saveOff->rect));#elif MACINTOSH	screen->Get(0, &mainScreen);	saveOff->ToMeta(mainScreen,&wR,&(saveOff->rect));		// BILBIL - 11/15/93#endif //WINDOWS	useOff->SetCurrent();	offscreen = useOff;	frontA = (Point*)frontPts->Use();	backA = (Point*)backPts->Use();	outsideA = (Point*)outsidePts->Use();	if (iAllowTexture)										// GJR 02/22/94		{        ASSERT(texturePts != NULL);		textureA = (PointFFixed*)texturePts->Use();		rset.decal = FALSE;		rset.colorize = TRUE;		rset.hMirror = FALSE;		rset.vMirror = FALSE;		rset.hFlip = FALSE;		rset.vFlip = FALSE;		rset.textureShade = &(gTextureShader[0]);		rset.filtered_color = red;		rset.mip_rect[0] = logo1->rect;		}	else		{		textureA = NULL;		}	rememberPane = currentPane;	currentPane = winPane;	/*-----do it-----*/	VSetCursor(vCursorArrow);	VFlushEvents(0);	ticktock=VGetTime();	cTime=ticktock;#if MACINTOSH	SetEventMask(keyDownMask|mDownMask);#endif //MACINTOSH	while(dontStop||(ticktock+WAITTIME(SIX_SECONDS))>cTime)		{		bcount++;#if WINDOWS		currentPane = rememberPane;			// BILBIL restore drawing env		useOff->UnSetCurrent();				// BILBIL restore drawing env		offscreen = rememberOff;			// BILBIL restore drawing env		MSG msg;		if(PeekMessage(&msg,NULL,0,0,PM_NOYIELD|PM_REMOVE))			{			if((msg.message >=WM_KEYFIRST &&					msg.message <=WM_KEYLAST) ||					(msg.message >=(WM_MOUSEFIRST+1) &&					msg.message <=WM_MOUSELAST))				break;			if(msg.message!=WM_MOUSEMOVE)				{				TranslateMessage(&msg);				DispatchMessage(&msg);				}			}		bcount=0;		currentPane = winPane;			// BILBIL get drawing env back		useOff->SetCurrent();			// BILBIL get drawing env back		offscreen = useOff;				// BILBIL get drawing env back#elif MACINTOSH		if(bcount&8)			{#ifdef __powerc			if(LMGetEventQueue()->qHead != NULL)#else			if(GetEvQHdr()->qHead != NULL)#endif //__powerc				break;			bcount=0;			}#endif //WINDOWS		cTime = VGetTime();#if WINDOWS	ReleaseCapture();#endif //WINDOWS		saveOff->MetaTo(useOff,&(useOff->rect),&(saveOff->rect));		//draw the shadow		if (hflag == -1)			{			offSet = ((angle %128)-64)/6.4;			if (offSet < 0) offSet = -offSet;			winPane->centerX = 180 + (offSet * 7);			winPane->centerY = 93 + (offSet * 4);			}		else			{			winPane->centerX = 250;			winPane->centerY = 133;			}		for (i=0; i< 27; i++)			{			outsideA[0].h = frontA[i].h;			outsideA[0].v = frontA[i].v;			outsideA[1].h = frontA[i+1].h;			outsideA[1].v = frontA[i+1].v;			outsideA[2].h = backA[i+1].h;			outsideA[2].v = backA[i+1].v;			outsideA[3].h = backA[i].h;			outsideA[3].v = backA[i].v;			// used to use vColorSlateD - BILBIL			aboutClip->DrawPoly(outsidePts,CLIP_FILL,NULL,FEAT_TRANSLUCENT,vPatBlack,&Cblack,&Cblack,FALSE,NULL);				// MERGE-GOURAUD			}		outsideA[0].h = frontA[27].h;		outsideA[0].v = frontA[27].v;		outsideA[1].h = frontA[0].h;		outsideA[1].v = frontA[0].v;		outsideA[2].h = backA[0].h;		outsideA[2].v = backA[0].v;		outsideA[3].h = backA[27].h;		outsideA[3].v = backA[27].v;		aboutClip->DrawPoly(outsidePts,CLIP_FILL,NULL,FEAT_TRANSLUCENT,vPatBlack,&Cblack,&Cblack,FALSE,NULL);				// MERGE-GOURAUD		aboutClip->DrawPoly(backPts,CLIP_FILL,NULL,FEAT_TRANSLUCENT,vPatBlack,&Cblack,&Cblack,FALSE,NULL);			// MERGE-GOURAUD		aboutClip->DrawPoly(frontPts,CLIP_FILL,NULL,FEAT_TRANSLUCENT,vPatBlack,&Cblack,&Cblack,TRUE,NULL);			// MERGE-GOURAUD		// now draw the sign		winPane->centerX = 180;		winPane->centerY = 93;		if (hflag == -1)			{			flip = !((angle < 64) || (angle > 192));			for (i=0; i< 27; i++)				{				outsideA[0].h = frontA[i].h;				outsideA[0].v = frontA[i].v;				outsideA[1].h = frontA[i+1].h;				outsideA[1].v = frontA[i+1].v;				outsideA[2].h = backA[i+1].h;				outsideA[2].v = backA[i+1].v;				outsideA[3].h = backA[i].h;				outsideA[3].v = backA[i].v;				colorTemp = nowNormals[i].x*((Long)light.x) + nowNormals[i].y*((Long)light.y) + nowNormals[i].z*((Long)light.z);				if (colorTemp > 0)					red.red = colorTemp + 128;				else red.red = 0;				aboutClip->DrawPoly(outsidePts,CLIP_FILL|CLIP_DITHER,NULL,0,vPatBlack,&red,&Cblack,flip,NULL);				// MERGE-GOURAUD				}			outsideA[0].h = frontA[27].h;			outsideA[0].v = frontA[27].v;			outsideA[1].h = frontA[0].h;			outsideA[1].v = frontA[0].v;			outsideA[2].h = backA[0].h;			outsideA[2].v = backA[0].v;			outsideA[3].h = backA[27].h;			outsideA[3].v = backA[27].v;			colorTemp = nowNormals[i].x*((Long)light.x) + nowNormals[i].y*((Long)light.y) + nowNormals[i].z*((Long)light.z);			if (colorTemp > 0)				red.red = colorTemp + 128;			else red.red = 0;			aboutClip->DrawPoly(outsidePts,CLIP_FILL|CLIP_DITHER,NULL,0,vPatBlack,&red,&Cblack,flip,NULL);				// MERGE-GOURAUD			if (flip)				{				colorTemp = nowNormals[29].x*((Long)light.x);				colorTemp += nowNormals[29].y*((Long)light.y);				colorTemp += nowNormals[29].z*((Long)light.z);				if (colorTemp < 0) colorTemp = 0;				colorTemp = colorTemp >> 11;				colorTemp = 31 - colorTemp;	//presumes 0..31  (not so)  Correct it. //GJR 12/21/93				colorTemp -= 3;		// correction. Force 0..27. 0 for white, 27 for dark, not black.            colorTemp = min(max(0,colorTemp),27);				if (logo2)                	{					rset.mip[0] = logo2;					rset.textureShade = &(gTextureShader[colorTemp]);					ShadedLinearTexture8(&rset,offscreen,texturePts,Ident(backPts,TRUE),aboutClip);                    }				else                	{					aboutClip->DrawPoly(backPts,CLIP_FILL|CLIP_DITHER,NULL,0,vPatBlack,&red,&Cblack,TRUE,NULL);				// MERGE-GOURAUD					}				}			else				{				colorTemp = nowNormals[28].x*((Long)light.x);				colorTemp += nowNormals[28].y*((Long)light.y);				colorTemp += nowNormals[28].z*((Long)light.z);				if (colorTemp < 0) colorTemp = 0;				colorTemp = colorTemp >> 11;				colorTemp = 31 - colorTemp;	//presumes 0..31  (not so)  Correct it. //GJR 12/21/93            colorTemp -= 3;		// correction. Force 0..27. 0 for white, 27 for dark, not black.            colorTemp = min(max(0,colorTemp),27);				if (logo1)                	{					rset.mip[0] = logo1;   					rset.textureShade = &(gTextureShader[colorTemp]);					ShadedLinearTexture8(&rset,offscreen,texturePts,Ident(frontPts,TRUE),aboutClip);                	}				else                	{					aboutClip->DrawPoly(frontPts,CLIP_FILL|CLIP_DITHER,NULL,0,vPatBlack,&red,&Cblack,TRUE,NULL);			// MERGE-GOURAUD					}				}			}		else			{			if (angle < 128)				{				for (i=0; i< 14; i++)					{					outsideA[0].h = frontA[i].h;					outsideA[0].v = frontA[i].v;					outsideA[1].h = frontA[i+1].h;					outsideA[1].v = frontA[i+1].v;					outsideA[2].h = backA[i+1].h;					outsideA[2].v = backA[i+1].v;					outsideA[3].h = backA[i].h;					outsideA[3].v = backA[i].v;					colorTemp = nowNormals[i].x*((Long)light.x) + nowNormals[i].y*((Long)light.y) + nowNormals[i].z*((Long)light.z);					if (colorTemp > 0)						red.red = colorTemp + 128;					else red.red = 0;					aboutClip->DrawPoly(outsidePts,CLIP_FILL|CLIP_DITHER,NULL,0,vPatBlack,&red,&Cblack,FALSE,NULL);				// MERGE-GOURAUD					}				}			else				{				for (i=14; i< 27; i++)					{					outsideA[0].h = frontA[i].h;					outsideA[0].v = frontA[i].v;					outsideA[1].h = frontA[i+1].h;					outsideA[1].v = frontA[i+1].v;					outsideA[2].h = backA[i+1].h;					outsideA[2].v = backA[i+1].v;					outsideA[3].h = backA[i].h;					outsideA[3].v = backA[i].v;					colorTemp = nowNormals[i].x*((Long)light.x) + nowNormals[i].y*((Long)light.y) + nowNormals[i].z*((Long)light.z);					if (colorTemp > 0)						red.red = colorTemp + 128;					else red.red = 0;					aboutClip->DrawPoly(outsidePts,CLIP_FILL|CLIP_DITHER,NULL,0,vPatBlack,&red,&Cblack,FALSE,NULL);					// MERGE-GOURAUD					}				outsideA[0].h = frontA[27].h;				outsideA[0].v = frontA[27].v;				outsideA[1].h = frontA[0].h;				outsideA[1].v = frontA[0].v;				outsideA[2].h = backA[0].h;				outsideA[2].v = backA[0].v;				outsideA[3].h = backA[27].h;				outsideA[3].v = backA[27].v;				colorTemp = nowNormals[i].x*((Long)light.x) + nowNormals[i].y*((Long)light.y) + nowNormals[i].z*((Long)light.z);				if (colorTemp > 0)					red.red = colorTemp + 128;				else red.red = 0;				aboutClip->DrawPoly(outsidePts,CLIP_FILL|CLIP_DITHER,NULL,0,vPatBlack,&red,&Cblack,FALSE,NULL);			// MERGE-GOURAUD				}				if ((angle < 64) || (angle > 192))				{				colorTemp = nowNormals[28].x*((Long)light.x);				colorTemp += nowNormals[28].y*((Long)light.y);				colorTemp += nowNormals[28].z*((Long)light.z);				if (colorTemp < 0) colorTemp = 0;				colorTemp = colorTemp >> 11;				colorTemp = 31 - colorTemp;	//presumes 0..31  (not so)  Correct it. //GJR 12/21/93	            colorTemp -= 3;		// correction. Force 0..27. 0 for white, 27 for dark, not black.	            colorTemp = min(max(0,colorTemp),27);				rset.textureShade = &(gTextureShader[colorTemp]);				if (logo1)                	{					rset.mip[0] = logo1;					rset.textureShade = &(gTextureShader[colorTemp]);					ShadedLinearTexture8(&rset,offscreen,texturePts,Ident(frontPts,TRUE),aboutClip);                    }				else                	{					aboutClip->DrawPoly(frontPts,CLIP_FILL|CLIP_DITHER,NULL,0,vPatBlack,&red,&Cblack,TRUE,NULL);			// MERGE-GOURAUD					}				}			else				{				colorTemp = nowNormals[29].x*((Long)light.x);				colorTemp += nowNormals[29].y*((Long)light.y);				colorTemp += nowNormals[29].z*((Long)light.z);				if (colorTemp < 0) colorTemp = 0;				colorTemp = colorTemp >> 11;				colorTemp = 31 - colorTemp;	//presumes 0..31  (not so)  Correct it. //GJR 12/21/93	            colorTemp -= 3;		// correction. Force 0..27. 0 for white, 27 for dark, not black.	            colorTemp = min(max(0,colorTemp),27);				if (logo2)                	{					rset.mip[0] = logo2;   					rset.textureShade = &(gTextureShader[colorTemp]);					ShadedLinearTexture8(&rset,offscreen,texturePts,Ident(backPts,FALSE),aboutClip);                    }				else                	{					aboutClip->DrawPoly(backPts,CLIP_FILL|CLIP_DITHER,NULL,0,vPatBlack,&red,&Cblack,FALSE,NULL);			// MERGE-GOURAUD					}				}			}#if WINDOWS		useOff->GetRect(&wR);		useOff->MetaTo(win,&wR,&wR);#elif MACINTOSH		useOff->MetaTo(mainScreen,&(useOff->rect),&wR);#endif //WINDOWS		useOff->SetCurrent();		//transform old points to go to new ones		angle = (angle + 6)&0xFF;		if ((angle < 6) && (hflag == 0))			dontStop = FALSE;		cosAngle = cos256w(angle);		sinAngle = sin256w(angle);		for (i = 0; i < 28; i++)			{			frontA[i].h = ((cosAngle * (long)(signPoints[i].h))>>15)					- ((sinAngle * (long)15)>>15);			backA[i].h = ((cosAngle * (long)(signPoints[i].h))>>15)					- ((sinAngle * (long)(-15))>>15);			nowNormals[i].x = ((cosAngle * (long)(normals[i].x))>>15);			nowNormals[i].z = ((sinAngle * (long)(normals[i].x))>>15);			}		nowNormals[28].x = -((sinAngle * (long)(normals[28].z))>>15);		nowNormals[28].z = ((cosAngle * (long)(normals[28].z))>>15);		nowNormals[29].x = -nowNormals[28].x;		nowNormals[29].z = -nowNormals[28].z;		if (hflag == -1)			{			for (i = 0; i < 28; i++)				{				frontA[i].v = ((cosAngle * (long)(signPoints[i].v))>>15)						- ((sinAngle * (long)15)>>15);				backA[i].v = ((cosAngle * (long)(signPoints[i].v))>>15)						- ((sinAngle * (long)(-15))>>15);				nowNormals[i].y = ((cosAngle * (long)(normals[i].y))>>15);				nowNormals[i].z = ((sinAngle * (long)(normals[i].y))>>15);				}			nowNormals[28].y = -((sinAngle * (long)(normals[28].z))>>15);			nowNormals[28].z = ((cosAngle * (long)(normals[28].z))>>15);			nowNormals[29].y = -nowNormals[28].y;			nowNormals[29].z = -nowNormals[28].z;			}		}			fine:#if WINDOWS	saveOff->MetaTo(win,&(saveOff->rect),&wR);#elif MACINTOSH	saveOff->MetaTo(mainScreen,&(saveOff->rect),&wR);#endif //WINDOWS	useOff->UnSetCurrent();	frontPts->Unuse();	frontPts->dArray();	backPts->Unuse();	backPts->dArray();	outsidePts->Unuse();	outsidePts->dArray();	if (texturePts)    	{		texturePts->Unuse();		texturePts->dArray();		}	if(saveOff) saveOff->dOffscreen();	if(useOff) useOff->dOffscreen();//#if WINDOWS//	logo1->UnsetMetaPort();//	logo2->UnsetMetaPort();//#endif //WINDOWS//	if(logo1) logo1->dOffscreen();//	if(logo2) logo2->dOffscreen();	if(logo1)		{		logo1->Unlock();		logo1->dPixel8();        }	if(logo2)		{		logo2->Unlock();		logo2->dPixel8();        }	if(aboutClip) aboutClip->dClip();	if(winPane) winPane->dPane();	offscreen = rememberOff;	currentPane = rememberPane;#if MACINTOSH	SetEventMask(everyEvent&(~keyUpMask));#elif WINDOWS	ReleaseDC(win->theWindow, hDC);	SetGraphicContext(NULL);	win->dWindow();#endif //WINDOWS	VSetCursor(vCursorArrow);	VFlushEvents(mDownMask|mUpMask|keyDownMask|keyUpMask|autoKeyMask);//VExitToShell();}#endif //VPLAYER#endif //VWT || PERSONALIZED#if (!VPLAYER)void DrawSerial(int xloc,int yloc)	{	string str[RESOURCE_STR_SIZE],verStr[RESOURCE_STR_SIZE];	Rect txtR;	txtR.left = xloc;	txtR.bottom = yloc;	txtR.top = txtR.bottom-10;	VSetFont(vAppFont,10,vNormal);#if !SAVE_DISABLED // jca 22Feb95	#if VPRO		// PRO25	#define SERIAL_NUM_IN_RESOURCES 1		// PRO25	#endif 		// PRO25	#if  SERIAL_NUM_IN_RESOURCES		if(GetSerial(str,1))			VDrawText(str,0,strlen(str),&txtR);		else Damaged();	#else		if(GetSerial(str,4))			VDrawText(str,0,strlen(str),&txtR);		else Damaged();	#endif // PERSONALIZED && (GERMAN || FRENCH || SPANISH)	txtR.bottom+=16;	txtR.top = txtR.bottom-10;	#if !SPECIAL_EDITION     // ABD-VRML5	VDrawText(TXT_LICENSEDTO,0,strlen(TXT_LICENSEDTO),&txtR);    #endif	txtR.bottom+=16;	txtR.top = txtR.bottom-10;	if(GetSerial(str,2))		VDrawText(str,0,strlen(str),&txtR);	else 	Damaged();	txtR.bottom+=16;	txtR.top = txtR.bottom-10;	if(GetSerial(str,3))		VDrawText(str,0,strlen(str),&txtR);	else Damaged();	txtR.bottom+=16;	txtR.top = txtR.bottom-10;#endif //!SAVE_DISABLED // jca 22Feb95	if(!GetVersion(verStr))		Damaged();	else		{		sprintf(str,"%s %s",TXT_VERSION,verStr);		VDrawText(str,0,strlen(str),&txtR);		}	}int GetVersion(strPtr str)	{	int i;	string **rstr;	#if MACINTOSH	rstr=(string **)GetResource('vers',1);	if(!rstr)return FALSE;	for(i=0;i<(*rstr)[6];i++)str[i]=(*rstr)[7+i];	str[i]=0;	ReleaseResource(rstr);	return TRUE;#endif //MACINTOSH#if WINDOWS	DWORD 	where=NULL;	char	string[RESOURCE_STR_SIZE];    unsigned int	size, err=FALSE;    GetModuleFileName(GetAppInstance(), string, RESOURCE_STR_SIZE);	size = GetFileVersionInfoSize(string, &where);	if (size)		{		void far *verBuf;        void far *verLoc;        HGLOBAL	verH;		verH = GlobalAlloc(GHND, size);		verBuf = GlobalLock(verH);		i = GetFileVersionInfo(string, where, size, verBuf);		if (i)			{#if JAPANESE			sprintf(string, "\\StringFileInfo\\041103A4\\ProductVersion");#elif SPANISH			sprintf(string, "\\StringFileInfo\\040A04E4\\ProductVersion");#elif GERMAN			sprintf(string, "\\StringFileInfo\\040704E4\\ProductVersion");#elif FRENCH			sprintf(string, "\\StringFileInfo\\040C04E4\\ProductVersion");#else //ENGLISH			sprintf(string, "\\StringFileInfo\\040904E4\\ProductVersion");#endif // JAPANESE			if (VerQueryValue(verBuf, string, &verLoc, &size))				{				memcpy(str,verLoc, size);                err = TRUE;				}			}		GlobalUnlock(verH);        GlobalFree(verH);		}     return(err);#endif //WINDOWS	}#if WINDOWSstatic int	DebuggingResources = -1;#endif#if JAPANESE_OLD_STYLE // jca we don't do this anymore 18APR95 pro 2.0.1J#if WINDOWS// only load the serial number once. jca 5MAY94static char 	sSerialNumber[64] = { 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,									  0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,									  0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,									  0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0 };// jca we should be able to use an import lib to link to scpverw.// But this is Borland. So we have to load the DLL explicitly. 4MAY94// extern int far pascal scpverw(LPSTR);typedef int (far pascal  *VERFARPROC)(LPSTR); // make an explicit type to avoid typing problems with using FARPROCtypedef int (far pascal  *PERSONALPROC)(LPSTR, int); // make an explicit type to avoid typing problems with using FARPROC#elsepascal void SCPVER(UChar*);#define ScpVer	SCPVER#endif // WINDOWS#ifdef __powercpascal voidSCPVER(UChar* myParams)	{	Handle		codeRes;	long		paramCode;	codeRes = Get1Resource('dave',5);	if (codeRes == NULL) 		Damaged();	HLock(codeRes);	paramCode = kThinkCStackBased | RESULT_SIZE(kNoByteCode) |			STACK_ROUTINE_PARAMETER(1, kFourByteCode);	CallUniversalProc((UniversalProcPtr)codeRes, paramCode, myParams);	HUnlock(codeRes);	ReleaseResource(codeRes);	}#endif //__powerc#include "VFile.h"#include "ctype.h"#define ERROR		-1#define NO_ERROR 	0int serial_parse(char *format_str, char *number_str, char *output_str);#endif //JAPANESE (OLD_STYLE) /// jca 18APR95#if !BUNDLED && !PERSONALIZED			// merge SE, vrmadness		// GJR 7/4/95intGetSerial(strPtr str,int num)	{	char **rstr;	int i,l,result=FALSE; #if WINDOWS	char	resrc[RESOURCE_STR_SIZE]; #endif // WINDOWS #if MACINTOSH  #if JAPANESE_OLD_STYLE // jca 18APR95 pro 2.0.1J don't do it this wat anymore	if (num == 1)		{		UChar	*paramArr = (UChar*)NewPtrClear(0x0200);		HVolumeParam	*myPBlk;		V_File	*appFile = new(V_File);		short	err;				paramArr[0x07] = 0;		sprintf((Char*)(&paramArr[0x20]),TXT_APPNAME);		C2Pstr((char*)(&paramArr[0x20]));		myPBlk = (HVolumeParam*)NewPtrClear(sizeof(HVolumeParam));		appFile->FindApplication();		myPBlk->ioVRefNum = appFile->pblk.ioVRefNum;		appFile->dFile();		err = PBHGetVInfo((HParmBlkPtr)myPBlk, FALSE);		if (!err) paramArr[0x10] = myPBlk->ioVDrvInfo;		DisposePtr((Ptr)myPBlk);		paramArr[0x40] = 0;		ScpVer(paramArr);		if ((paramArr[1] == 255)&&(paramArr[0x60] == 1))			{			char	format[64], serial[64];						memcpy(serial, &(paramArr[0x70]), paramArr[0x70]+1);	// count needs to include itself			memcpy(format, &(paramArr[0x80]), paramArr[0x80]+1);    // or last char gets garbage GJR 4MAY94			P2Cstr(serial);			P2Cstr(format);			serial_parse(format, serial, str);			result = TRUE;			}		else			result = FALSE;		DisposePtr((Ptr)paramArr);		}	else  #endif //JAPANESE_OLD_STYLE	{	rstr=GetResource('dave',num);	result = (rstr) ? TRUE : FALSE;	if(result)		{		l=SizeResource(rstr);		for(i=0;i<l;i++)str[i]=(*rstr)[i];		str[i]=0;		ReleaseResource(rstr);		result = Decode(str,l);		}	} #elif WINDOWS  #if JAPANESE_OLD_STYLE // jca 18APR95 pro 2.0.1J don't do it this wat anymore	if (num == 1)		{		// if we've already read the serial number once, then don't do		// it again -- don't repeat the ultra-secret get-the-serial-		// number code (too easy to trace the action)  jca 5MAY94		if (strlen(sSerialNumber))			{			result = TRUE;			strcpy(str, sSerialNumber);			}		else        	{			HANDLE	hMem;			UChar	*paramArr;        	VfsLocation *fileLoc;			V_File	*appFile = new(V_File);			int		err, drive;			HINSTANCE hLib;			VERFARPROC prot;			fileLoc = new(VfsLocation);            fileLoc->cVfsLocation();			hMem = GlobalAlloc(GMEM_FIXED, (ULong) 256);			paramArr = (UChar *) GlobalLock(hMem);       	 	memset(paramArr, 0, 256);			LockData(0);  // pass in a bogus value because windows wants it that way 			appFile->FindApplication();			appFile->VGetLocation(fileLoc);			if (fileLoc->path[1] != ':')				drive = 3;			else        		drive = ((int)(toupper(fileLoc->path[0])) - (int)'A') + 1;			paramArr[0] = 1;   // full check			paramArr[0x07] = 0;  //get inst count			paramArr[0x10] = (UChar) (drive & 0x00FF);  // drive			strcpy((Char*)(&paramArr[0x12]),"VIRTUSVR");  // appname			paramArr[0x2F] = 0;          // return serial number			appFile->dFile();			// jca 4MAY94 we want to do it with scpverw.  But That was			// compiled with MSC and this is Borland.  So we must load the      	  	// dll explicitly at runtime.			//	err = scpverw((LPSTR)paramArr);			hLib = LoadLibrary("VRTSCPW.DLL");			if (hLib >= 32)				{				prot = (VERFARPROC) GetProcAddress(hLib, "VERPROT");				if (prot != (VERFARPROC) NULL)					(*prot)((LPSTR) paramArr);      		  	FreeLibrary(hLib);				}			if (((unsigned)paramArr[0x01] == 255)&&(paramArr[0x02] == 1))				{				char	format[64], serial[64];       					memcpy(serial, &(paramArr[0x30]), 10);				serial[10] = '\0'; // null terminate the serial number string.				if ((unsigned)paramArr[0x40] > 32)	paramArr[0x40] = 32;	// clamp if invalid				memcpy(format, &(paramArr[0x40]), paramArr[0x40]+1);				P2Cstr(format);				serial_parse(format, serial, str);				strcpy(sSerialNumber, str);				result = TRUE;				}			else				result = FALSE;			UnlockData(0);  // pass in a bogus value because windows wants it that way			GlobalUnlock(hMem);			GlobalFree(hMem);			fileLoc->dVfsLocation();			}        }  #endif //JAPANESE_OLD_STYLE	/* for the windows stuff, we store a p-string:	a one-byte byte count, then the bytes of the string.	Windows does exactly the same thing in the resource,	only we can't see it.	EXCEPT (there's always an exception) for resources 17-32,	which are reserved for plain, unencoded C-strings.  These	unencoded resources are for development uses (so we don't	have to serialize the executables for debugging) */  #if DEBUG	// look for debugging resources	if (DebuggingResources == -1)    	{		l = LoadString(GetAppInstance(), 17, resrc, RESOURCE_STR_SIZE);		if (l)	DebuggingResources = 1;        else DebuggingResources = 0;	// don't keep checking.        }	else if (DebuggingResources == 1)		l = TRUE;	else		l = FALSE;	if (l)		{ // these are not encoded		l = LoadString(GetAppInstance(), num+16, resrc, RESOURCE_STR_SIZE);		str[l] = '\0';   // null terminate no matter what		if (l)    // if we got it, then check it...			{   // did we find it?  (we might not have an expiration date, for example)			memcpy(str, resrc, l);			if (num == 1)  // is this the serial number resource?				result = CheckNumber(str);   // check it out            else				result = TRUE;            }		}	else  #endif // DEBUG  #if ENGLISH || SPANISH || GERMAN || FRENCH || JAPANESE // jca 18APR95 added JAPANESE		{		l = LoadString(GetAppInstance(), num, resrc, RESOURCE_STR_SIZE);		if (--l == (((unsigned int) resrc[0]) & 0x00FF))			{			memcpy(str, &resrc[1], l);			result = Decode(str, l);			str[l] = '\0';			}		}  #elif JAPANESE_OLD_STYLE // jca 18APR95 pro 2.0.1J don't do it this way anymore		{		if (num == 2)			{			char	resrc[RESOURCE_STR_SIZE];			HINSTANCE hLib;			PERSONALPROC prot;			hLib = LoadLibrary("VRTSPERL.DLL");            l = 0;			if (hLib >= 32)				{				prot = (PERSONALPROC) GetProcAddress(hLib, (LPCSTR) "GetPersonalDataName");				if (prot != (PERSONALPROC) NULL)					l = (*prot)(resrc, RESOURCE_STR_SIZE);      		  	FreeLibrary(hLib);				}			if (l == (((unsigned int) resrc[0]) & 0x00FF))				{				memcpy(str, &resrc[1], l);				str[l] = '\0';				result = Decode(str, l);				}			}		else if (num == 3)			{			char	resrc[RESOURCE_STR_SIZE];			HINSTANCE hLib;			PERSONALPROC prot;			hLib = LoadLibrary("VRTSPERL.DLL");            l = 0;			if (hLib >= 32)				{				prot = (PERSONALPROC) GetProcAddress(hLib, "GetPersonalDataOrg");				if (prot != (PERSONALPROC) NULL)					l = (*prot)(resrc, RESOURCE_STR_SIZE);      		  	FreeLibrary(hLib);				}			if (l == (((unsigned int) resrc[0]) & 0x00FF))				{				memcpy(str, &resrc[1], l);				str[l] = '\0';				result = Decode(str, l);				}			}		else if (num = 4)    		result = TRUE; // jca 7MAY94 no expiration date in japanese stuff.  Ignore		}  #else // !(ENGLISH || SPANISH || JAPANESE), !(JAPANESE_OLD_STYLE)	 if ((num == 2) || (num == 3) || (num == 4))	 	{		str[0] = 0;		result = TRUE;        }  #endif //JAPANESE  (OLD_STYLE) #endif //WINDOWS		return result;	}#elif BUNDLEDtypedef int (far pascal  *PERSONALPROC)(LPSTR, int); // make an explicit type to avoid typing problems with using FARPROCintGetSerial(strPtr str,int num)	{	int i,l,result=FALSE;		if (num == 1)			{			char	resrc[RESOURCE_STR_SIZE];			l = LoadString(GetAppInstance(), num, resrc, RESOURCE_STR_SIZE);			memcpy(str, &resrc[0], l);			str[l] = '\0';			}		else if (num == 2)			{			char	resrc[RESOURCE_STR_SIZE];			HINSTANCE hLib;			PERSONALPROC prot;			hLib = LoadLibrary("VRTSPERL.DLL");            l = 0;			if (hLib >= 32)				{				prot = (PERSONALPROC) GetProcAddress(hLib, (LPCSTR) "GetPersonalDataName");				if (prot != (PERSONALPROC) NULL)					l = (*prot)(resrc, RESOURCE_STR_SIZE);      		  	FreeLibrary(hLib);				}			if ((l == (((unsigned int) resrc[0]) & 0x00FF)) && (l > 0))				{				memcpy(str, &resrc[1], l);				str[l] = '\0';				result = Decode(str, l);				}			else            	str[0] = '\0';			}		else if (num == 3)			{			char	resrc[RESOURCE_STR_SIZE];			HINSTANCE hLib;			PERSONALPROC prot;			hLib = LoadLibrary("VRTSPERL.DLL");            l = 0;			if (hLib >= 32)				{				prot = (PERSONALPROC) GetProcAddress(hLib, "GetPersonalDataOrg");				if (prot != (PERSONALPROC) NULL)					l = (*prot)(resrc, RESOURCE_STR_SIZE);      		  	FreeLibrary(hLib);				}			if (l == (((unsigned int) resrc[0]) & 0x00FF))				{				memcpy(str, &resrc[1], l);				str[l] = '\0';				result = Decode(str, l);				}			else            	str[0] = '\0';			}		else			{ 			result = TRUE; // jca 7MAY94 no expiration date in japanese stuff.  Ignore			str[0] = '\0';            }	}#elif PERSONALIZED			// merge SE, vrmadness		// GJR 7/4/95 #if MACINTOSHintGetSerial(strPtr str,int num)	{		return 1;		// ABD-BLURB BOGUS THING FOR SPECIAL EDITION	} #elif !MACINTOSH // MACINTOSHintGetSerial(strPtr str,int num)	{	int i,l,result=FALSE;		if (num == 1)			{			char	resrc[RESOURCE_STR_SIZE];			l = LoadString(GetAppInstance(), num, resrc, RESOURCE_STR_SIZE);			memcpy(str, &resrc[0], l);			str[l] = '\0';            result = TRUE;			}		else if (num == 2)			{			char	resrc[RESOURCE_STR_SIZE];			l = GetProfileString(TXT_APPNAME, TXT_WININI_VWT_SE_NAME, " ",				resrc, RESOURCE_STR_SIZE);			if (l > 0)				{				strcpy(str, resrc);				result = TRUE;                }			else str[0] = '\0';			}		else if (num == 3)			{			char	resrc[RESOURCE_STR_SIZE];			l = GetProfileString(TXT_APPNAME, TXT_WININI_VWT_SE_ORG, " ",				resrc, RESOURCE_STR_SIZE);			if (l > 0)				{				strcpy(str, resrc);				result = TRUE;                }			else if (l == 0)				{				str[0] = '\0';				result = TRUE;                }            else str[0] = '\0';			}		else if (num == 4)			{			char	resrc[RESOURCE_STR_SIZE];			l = GetProfileString(TXT_APPNAME, TXT_WININI_VWT_SE_SERIAL, " ",				resrc, RESOURCE_STR_SIZE);			if (l > 0)				{				strcpy(str, resrc);				result = TRUE;                }			else if (l == 0)				{				str[0] = '\0';				result = TRUE;                }			else str[0] = '\0';			}		else			{ 			result = TRUE; // jca 7MAY94 no expiration date in special edition stuff.  Ignore			str[0] = '\0';            }    return(result);	} #endif  // Macintosh#endif // not bundled nor special editionvoid Damaged()			{	AlertDialog *alert;	VPlaySound(beepSound);	alert=new(AlertDialog);	alert->cAlertDialog(TXT_DAMAGED);	VExitToShell();	} #endif //!VPLAYER// ---#if JAPANESE_OLD_STYLE // jca 18APR95 pro 2.0.1J don't do it this way anymore #if JAPANESE & (!VPLAYER)/*---------------------------------------------------------------------------*//*	This routine parses the given format_str according the the following rules, and stores	the result in output_str.  output_str *must* point to a buffer of appripriate size (or	larger).  This routine expects format_str and number_str to be C strings, and outputs a 	C string in output_str. 		If this routine is passed NULL in any of the parameters, it is an error and this	routine returns ERROR and output_str is not modified.  Otherwise it returns NO_ERROR, 	regardless of the actual contents of format_str and number_str.   	Formatting Rules:	-- replace occurances of "#" with sequential characters from number_str, from right to left.	   If there are not enough characters in number_str to account for all occurances of 	   "#", then the character '0' is used.  	-- replace "'<char>" (i.e. single-quote-char) with "<char>", regardless of what 	   <char> is (e.g. "'a" results in "a", "'#" results in "#", "''" results in "'")*/int serial_parse(	char *format_str, 		// C string describing the format	char *number_str,  		// C string contianing the characters to insert (the digits) 	char *output_str) 		// where resulting C string is stored 							// (output_str *must* point to a buffer of appropriate size){long i;long len = strlen(format_str);long num_len = strlen(number_str);long next_digit;long next_output = 0;long num_hashes = 0;int last_char_was_escape = FALSE;char output[256];	if (format_str == NULL)		return ERROR;	if (number_str == NULL)		return ERROR;	if (output_str == NULL)		return ERROR;	// first, we need to count how many digits we will need, and start at that place in	// number_str (e.g. if format is "abc###def" and number is "123456" we want to start	// with the digit "4" because we only need 3 digits and we want the last 3.	for ( i = 0 ; i < len ; i++ )	{		if (last_char_was_escape)		{			last_char_was_escape = FALSE;		}		else		{			if (format_str[i] == '#') 				num_hashes++;			else if (format_str[i] == '\'')		// this is the single quote char (')				last_char_was_escape = TRUE;		}	}			// set the starting digit to use based on num_hashes and length of number_str	next_digit = strlen(number_str) - num_hashes;		// reset last last_char_was_escape was esp	last_char_was_escape = FALSE; 		// construct the string	for ( i = 0 ; i < len ; i++ )	{		// if the last character was an escape character, then just write this		// character into the output string regardless of what char it is		// and then reset last_char_was_escape				if (last_char_was_escape)		{			output_str[next_output++] = format_str[i];			last_char_was_escape = FALSE;		}					// otherwise, if the last character *wasn't* an escape character, then		// see if it was a hash mark, and if so, write the next digit into the 		// output string.  Note that if next_digit is less than zero (i.e. we		// ran out of digits) then just put a zero.				else if (format_str[i] == '#') 		{			if (next_digit < 0)			{				output_str[next_output++] = '0';				next_digit++;			}			else				output_str[next_output++] = number_str[next_digit++];		}		// see if it is a escape char, and if so, *don't* write anything to the		// output string, but remember we saw an escape char for the next loop					else if (format_str[i] == '\'')		// this is the single quote char (')			last_char_was_escape = TRUE;					// it's not a special character, so just output it					else			output_str[next_output++] = format_str[i];	}		// terminate the output string	output_str[next_output] = '\0';		return NO_ERROR; }   #if 0// This routine is for testing the above functionmain(){char output[256];	printf("begin test\n");			serial_parse("abcde###ghij", "12345", output);	printf("answer should be:\n");	printf("   abcde543ghij\n");	printf("answer is:\n   ");	printf(output);	printf("\n");	if (strcmp(output, "abcde543ghij") != 0)		printf("ERROR!!!!!!!");	printf("\n\n");		serial_parse("abcde###ghij", "", output);	printf("answer should be:\n");	printf("   abcde000ghij\n");	printf("answer is:\n   ");	printf(output);	printf("\n");	if (strcmp(output, "abcde000ghij") != 0)		printf("ERROR!!!!!!!");	printf("\n\n");		serial_parse("abcde###ghij", "12", output);	printf("answer should be:\n");	printf("   abcde210ghij\n");	printf("answer is:\n   ");	printf(output);	printf("\n");	if (strcmp(output, "abcde210ghij") != 0)		printf("ERROR!!!!!!!");	printf("\n\n");		serial_parse("#", "12345", output);		printf("answer should be:\n");	printf("   5\n");	printf("answer is:\n   ");	printf(output);	printf("\n");	if (strcmp(output, "5") != 0)		printf("ERROR!!!!!!!");	printf("\n\n");		serial_parse("abcde-###-ghij", "12345", output);	printf("answer should be:\n");	printf("   abcde-543-ghij\n");	printf("answer is:\n   ");	printf(output);	printf("\n");	if (strcmp(output, "abcde-543-ghij") != 0)		printf("ERROR!!!!!!!");	printf("\n\n");		serial_parse("abcde-'###-ghij", "12345", output);	printf("answer should be:\n");	printf("   abcde-#54-ghij\n");	printf("answer is:\n   ");	printf(output);	printf("\n");	if (strcmp(output, "abcde-#54-ghij") != 0)		printf("ERROR!!!!!!!");	printf("\n\n");		serial_parse("abcde'#'#'#ghij", "12345", output);	printf("answer should be:\n");	printf("   abcde###ghij\n");	printf("answer is:\n   ");	printf(output);	printf("\n");	if (strcmp(output, "abcde###ghij") != 0)		printf("ERROR!!!!!!!");	printf("\n\n");		serial_parse("'a'bcde'###g'hi'j", "12345", output);	printf("answer should be:\n");	printf("   abcde#54ghij\n");	printf("answer is:\n   ");	printf(output);	printf("\n");	if (strcmp(output, "abcde#54ghij") != 0)		printf("ERROR!!!!!!!");	printf("\n\n");		serial_parse("abcde#'##ghij", "12345", output);	printf("answer should be:\n");	printf("   abcde5#4ghij\n");	printf("answer is:\n   ");	printf(output);	printf("\n");	if (strcmp(output, "abcde5#4ghij") != 0)		printf("ERROR!!!!!!!");	printf("\n\n");		serial_parse("############", "12345", output);	printf("answer should be:\n");	printf("   543210000000\n");	printf("answer is:\n   ");	printf(output);	printf("\n");	if (strcmp(output, "543210000000") != 0)		printf("ERROR!!!!!!!");	printf("\n\n");		serial_parse("#abcde###ghij#", "12345", output);	printf("answer should be:\n");	printf("   5abcde432ghij1\n");	printf("answer is:\n   ");	printf(output);	printf("\n");	if (strcmp(output, "5abcde432ghij1") != 0)		printf("ERROR!!!!!!!");	printf("\n\n");		serial_parse("###abcde###ghij####", "12345", output);	printf("answer should be:\n");	printf("   543abcde210ghij0000\n");	printf("answer is:\n   ");	printf(output);	printf("\n");	if (strcmp(output, "543abcde210ghij0000") != 0)		printf("ERROR!!!!!!!");	printf("\n\n");		serial_parse("#abc#de###gh#ij", "12345", output);	printf("answer should be:\n");	printf("   5abc4de321gh0ij\n");	printf("answer is:\n   ");	printf(output);	printf("\n");	if (strcmp(output, "5abc4de321gh0ij") != 0)		printf("ERROR!!!!!!!");	printf("\n\n");		serial_parse("abcd'e##'#gh'ij", "1234567890123", output);	printf("answer should be:\n");	printf("   abcde32#ghij\n");	printf("answer is:\n   ");	printf(output);	printf("\n");	if (strcmp(output, "abcde32#ghij") != 0)		printf("ERROR!!!!!!!");	printf("\n\n");		serial_parse("ab''cd'e'''##'#gh'ij", "1234567890123", output);	printf("answer should be:\n");	printf("   ab'cde'#3#ghij\n");	printf("answer is:\n   ");	printf(output);	printf("\n");	if (strcmp(output, "ab'cde'#3#ghij") != 0)		printf("ERROR!!!!!!!");	printf("\n\n");		serial_parse("", "", output);	printf("answer should be:\n");	printf("   \n");	printf("answer is:\n   ");	printf(output);	printf("\n");	if (strcmp(output, "") != 0)		printf("ERROR!!!!!!!");	printf("\n\n");	printf("testing error detection:\n");	printf("(this is an error if ERROR!!!!!!! does *NOT* appear)\n");		if (strcmp(output, "&&&&&&&") != 0)		printf("ERROR!!!!!!!");	printf("\n\n");	printf("end test\n");	}  #endif //0 #endif //JAPANESE#endif //JAPANESE_OLD_STYLE // jca 18APR95 pro 2.0.1J don't do it this way anymore