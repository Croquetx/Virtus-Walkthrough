/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Platform: 	MACINTOSH 	X	DAS *				WINDOWS		X	MJU * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VGraphic.h"#include "VDisplay.h"#include "VGUtil.h"#include "Clip.h"#include "VColor.h"#include "VDialog.h"#include <stdio.h>#include <string.h>RGBColor vBlack = { 0x0000, 0x0000, 0x0000 };RGBColor vWhite = { 0xFFFF, 0xFFFF, 0xFFFF };static long cccount;static long delayCount;int cursNum=vCursorArrow;typedef struct {	short numCurs;	short whichCurs;#if MACINTOSH	CursHandle Curs[12];	// made this one bigger - BILBIL#elif WINDOWS	HCURSOR Curs[12];		// made this one bigger - BILBIL#endif //WINDOWS	}acur,*acurPtr,**acurHandle;#if WINDOWSstatic acur CurList;// BILBIL - added support for VR spinning cursor - 12/13/93#if (VWT || VPLAYER)#define NUM_EARTH	7#elif VR#define NUM_EARTH	12#endif //VWT#define INIT_SELECT_PAT	0xFFstatic int selectBitmap[] = { 0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF };static int patWhite[]={0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};static int patDkGray[]={0x00,0x55,0x00,0x55,0x00,0x55,0x00,0x55};static int patGray[]={0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55};static int patLtGray[]={0xFF,0x55,0xFF,0x55,0xFF,0x55,0xFF,0x55};static int patBlack[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};typedef struct	{	short font;	short size;	short face;	HFONT hFont;    } CacheItem;static V_Array *fontCache = NULL;static short lastFont = 0;static short lastSize = 0;static short lastFace = 0;static HFONT lastHFont = NULL;int currentDepth = 0;HBRUSH currentBrush = NULL;HDC currentDevice = NULL;HPALETTE currentPalette = NULL;HBITMAP currentBitmap = NULL;static HPEN currentPen = NULL;static LOGPEN	thePen = { PS_SOLID , { 1 , 1 } , 0 };static int penId = 0;        // jcastatic int patId = 0;        // jcastatic int gFontsInstalled = 0;	// jca 20OCT94 for 32-bit/PRO. Otherwise we can't find the font file.void UpdatePen(void);void UpdateBrush(void);void VSetPenStyle(int);RGBColor vCurrentBackColor;RGBColor vCurrentForeColor;static long lastTime = 0;static int depth = 0;HCURSOR cross;HCURSOR lockArrow;HCURSOR hand;HCURSOR question;HCURSOR split;HCURSOR fCross;HCURSOR pencil;HCURSOR oRing;HCURSOR finger;HCURSOR dropper;HCURSOR hideArrow;HCURSOR tumbleHand;HCURSOR connectArrow;HCURSOR justSayNo; // DAS-VDRAG 9/3/93#if ((VR) || (VPRO))		// MERGE-GOURAUD-PRO-2HCURSOR zoomOutArrow;HCURSOR zoomInArrow;#endif // ((VR) || (VPRO))HCURSOR textBar;HCURSOR wait;HCURSOR arrow;#elif MACINTOSH	#define INIT_SELECT_PAT	0xFF/*#define white 	(qd.white)#define black 	(qd.black)#define gray 	(qd.gray)#define ltGray 	(qd.ltGray)#define dkGray 	(qd.dkGray)#define arrow 	(qd.arrow)#define randSeed (qd.randSeed)*/CursHandle cross;CursHandle lockArrow;CursHandle hand;CursHandle question;CursHandle split;CursHandle fCross;CursHandle textBar;CursHandle pencil;CursHandle oRing;CursHandle finger;CursHandle dropper;CursHandle hideArrow;CursHandle tumbleHand;CursHandle connectArrow;CursHandle justSayNo; // DAS-VDRAG 9/3/93#if ((VR) || (VPRO))		// MERGE-GOURAUD-PRO-2CursHandle	zoomOutArrow;CursHandle	zoomInArrow;#endif //((VR) || (VPRO))static acurHandle CurList;Pattern *currentPattern;static Pattern *hiResGray;static Pattern selectPattern;#endif //MACINTOSH#if WINDOWSvoid SetGraphicContext(HDC hdc) { currentDevice = hdc; }HDC  GetGraphicContext() { return currentDevice; }extern long gjrOldPolyFillMode = -1;extern long gjrOldROP2 = -1;extern WORD gwVgrRasterCaps = 0;extern WORD	gwVgrHasPalette = 0;extern WORD	gwVgrBitsPixel = 0;extern WORD	gwVgrPlanes = 0;extern WORD	gwVgrNumColors = 0;extern WORD	gwVgrSizePalette = 0;extern WORD	gwVgrNumReserved = 0;extern WORD	gwVgrColorRes = 0;#endif //WINDOWS/*JAM 11-17-93 for drawing text which needs to be clipped to  rect (e.g. in infopane).  The MAC portion is currently  incorrect, as it does not clip*/voidVClipDrawText(char *str,int start,int length,Rect *r)	{#if MACINTOSH	//jam 11-16-93 should clip text to rect.  FIX THIS. maybe ABD?	MoveTo(r->left,r->bottom);	if(length<2)		DrawChar(*str);	else		DrawText(str,start,length);#elif WINDOWS//	TextOut(currentDevice,r->left,r->top,&str[start],length);	ExtTextOut(currentDevice, r->left, r->top, ETO_CLIPPED, r,				&str[start], length, NULL);#endif //WINDOWS	}/*comment by jam 11-17-93  this routine writes text starting at a point indicated by  r->left, r->bottom on the MAC and r->left, r->top on Windows.  It really should be passed a POINT, not a rect.  If anyone  has time or energy this should perhaps be changed.  For  a routine that clips the text to a rect see VClipDrawText  or VClipDrawTextFast above*/voidTextSetUp(int font,int size, int face)	{	VSetFont(font,size,face);	}	voidVDrawText(char *str,int start,int length,Rect *r)	{#if MACINTOSH	MoveTo(r->left,r->bottom);	if(length<2)		DrawChar(*str);	else		DrawText(str,start,length);#elif WINDOWS	TextOut(currentDevice,r->left,r->top,&str[start],length);#endif //WINDOWS	}voidVDrawChar(char ch,Rect *r)	{#if MACINTOSH	MoveTo(r->left,r->bottom);	DrawChar(ch);#elif WINDOWS	TextOut(currentDevice,r->left,r->top,&ch,1);#endif //WINDOWS	}void	VGetPen(VPenState *p){#if MACINTOSH	GetPenState(p);#elif WINDOWS	*p = penId;		// PenState is an int under Windows#endif}void VSetPen(VPenState *p){#if MACINTOSH	SetPenState(p);#elif WINDOWS	VPenMode(*p);#endif}#if WINDOWSvoidVSetPattern(int patFlag)	{	int *pat; 	if (patFlag == patId)	return; //jca	else patId = patFlag;	// jca	switch(patFlag)		{		case vPatLtGray: pat = patLtGray; break;		case vPatGray: pat = patGray; break;		case vPatDkGray: pat = patDkGray; break;		case vPatWhite: pat = patWhite; break;		case vPatSelect: pat = selectBitmap; break;                case vPatBlack: pat = patBlack; break;		// jca 8 aug 93				case vPatDithered:                      	// jca 8 aug 93				default: pat = NULL; break;		}	if (currentBitmap)		DeleteObject(currentBitmap);	if (pat)		currentBitmap = CreateBitmap(8,8,1,1,pat);	else currentBitmap = NULL;	UpdateBrush();	}void InitGraphics(HINSTANCE hInst)	{	HBITMAP	bitmap;	HBRUSH oldBrush;	HPEN oldPen;	int	  iRasterCaps, hasPalette;	ULong	ulNumColors;	HDC hdc;	hdc = VGetDC(NULL);	gjrOldPolyFillMode = SetPolyFillMode(hdc, WINDING);	gjrOldROP2 = SetROP2(hdc, R2_COPYPEN);	iRasterCaps = GetDeviceCaps(hdc, RASTERCAPS);	colorQD = iRasterCaps&RC_BITBLT ? TRUE : FALSE;	hasPalette = (iRasterCaps & RC_PALETTE) ? TRUE : FALSE;	gwVgrRasterCaps = GetDeviceCaps(hdc, RASTERCAPS);	gwVgrHasPalette = (iRasterCaps & RC_PALETTE) ? TRUE : FALSE;	gwVgrBitsPixel  = GetDeviceCaps(hdc, BITSPIXEL);	gwVgrPlanes     = GetDeviceCaps(hdc, PLANES);	gwVgrNumColors  = GetDeviceCaps(hdc, NUMCOLORS);	gwVgrSizePalette = 0;	gwVgrNumReserved = 0;	gwVgrColorRes    = 0;	if (hasPalette)		{		gwVgrSizePalette = GetDeviceCaps(hdc, SIZEPALETTE);		gwVgrNumReserved = GetDeviceCaps(hdc, NUMRESERVED);		gwVgrColorRes    = GetDeviceCaps(hdc, COLORRES);		}//-------------------------------------------------------------------// Fun and Games// ATI//		Mach32 has 4 bit using 8bit pixels. Clue is NumColors=16//			although bitwidth is 8.//		Mach32 has both palette 8 bit and TRUE COLOR 8 bit.// Boca Boards//		for 16 and 24 bit, NumColors is NEGATIVE 1. Have to use//		bitwidth//// Viper//	for 16 bit board, NumColors is only 16, not 20.//// REVISIT (DEC. '93)//	why can't currentdepth be the physical size of each pixel?// For viper, numcolors is 16 even for 16-bit board. This messes up// the prior logic.// It seems the only person who cares about the NUMBER of colors is// vcolor during its color interrogation. So we will try having it// use gwVgrNumColors for detecting weird mach32 4bit boards.// Everyone else will use the physical size bits*planes.//// Windows 3.1//		NumColors is number of device colors or 20 for reserved colors.//		Palette numbers or actually arbitrary, since palettes don't have//			to be physical. Lots of 16/24 bit boards have 1k palettes.//		ColorRes refers to the total bits going out through the DAC's.//-------------------------------------------------------------------// Try having currentDepth refer to physical bit size. MAY NOT MATCH COLORS AVAIL!!! //gjr 12/15/93//	if ( (gwVgrNumColors <= 0)		// bad or >= 16 bit NumColors//	  || (gwVgrNumColors > 16) )    // > 4 bit//		{	// then we have more than 4bit pixels,//			// so presume depth matches pixel bit size. 		currentDepth = gwVgrBitsPixel * gwVgrPlanes;//		}//	else	// else extract depth from NumColors//		{//		currentDepth=0;//		ulNumColors = (unsigned)gwVgrNumColors & 0xffff;//	    ulNumColors += ulNumColors >> 1;		// round up for some boards//		while(ulNumColors>>=1) currentDepth++;//        }	ReleaseDC(NULL,hdc);#if DEBUG	{	char szOutput[1024] = "X";		wsprintf((LPSTR)&szOutput,			(LPSTR)"%s0x%x\n %s%d\n %s%d\n %s%d\n %s%d\n %s%d\n %s%d\n %s%d\n",			(LPSTR)"gwVgrRasterCaps =", gwVgrRasterCaps,			(LPSTR)"gwVgrHasPalette =", gwVgrHasPalette,			(LPSTR)"gwVgrBitsPixel =", gwVgrBitsPixel,			(LPSTR)"gwVgrPlanes =", gwVgrPlanes,			(LPSTR)"gwVgrNumColors =", gwVgrNumColors,			(LPSTR)"gwVgrSizePalette =", gwVgrSizePalette,			(LPSTR)"gwVgrNumReserved =", gwVgrNumReserved,			(LPSTR)"gwVgrColorRes =", gwVgrColorRes);		MessageBox(0, szOutput, "VWALK DEBUG", MB_OK);    }#endif	InitCurs(hInst);	InitFonts(hInst);	InitPalette(hInst);	InitClipper();	currentBitmap = CreateBitmap(8,8,1,1,patBlack);	VForeColor(&vBlack);	VBackColor(&vWhite);	}void ReleaseGraphics()	{	ReleaseCurs();	ReleaseFonts();	ReleasePalette();	ReleaseClipper();//	DeleteObject(currentPen);//	DeleteObject(currentBrush);	DeleteObject(currentBitmap);	}// { DAS-BUGFIX 10/23/93 voidInitCurs(HINSTANCE hInstance)	{	int i;	cross = LoadCursor(hInstance,MAKEINTRESOURCE(vCursorCross));#if (!VPLAYER)	lockArrow = LoadCursor(hInstance,MAKEINTRESOURCE(vCursorLock));	hand = LoadCursor(hInstance,MAKEINTRESOURCE(vCursorHand));	question = LoadCursor(hInstance,MAKEINTRESOURCE(vCursorQuestion));	split = LoadCursor(hInstance,MAKEINTRESOURCE(vCursorSplit));	pencil = LoadCursor(hInstance,MAKEINTRESOURCE(vCursorPencil));	oRing = LoadCursor(hInstance,MAKEINTRESOURCE(vCursorRing));	finger = LoadCursor(hInstance,MAKEINTRESOURCE(vCursorFinger));	dropper = LoadCursor(hInstance,MAKEINTRESOURCE(vCursorDropper));	hideArrow = LoadCursor(hInstance,MAKEINTRESOURCE(vCursorHide));	tumbleHand = LoadCursor(hInstance,MAKEINTRESOURCE(vCursorTumble)); 	connectArrow = LoadCursor(hInstance,MAKEINTRESOURCE(vCursorConnect));	justSayNo = LoadCursor(hInstance, MAKEINTRESOURCE(vCursorNO)); // DAS-VDRAG 9/3/93#if VR || VPRO		// MERGE-GOURAUD-PRO-2	zoomOutArrow = LoadCursor(hInstance,MAKEINTRESOURCE(vCursorZoomOut));	zoomInArrow = LoadCursor(hInstance,MAKEINTRESOURCE(vCursorZoomIn));#endif#endif //!VPLAYER	wait = LoadCursor(NULL,IDC_WAIT);	textBar = LoadCursor(NULL,IDC_IBEAM);	fCross = LoadCursor(NULL,IDC_CROSS);	arrow= LoadCursor(NULL,IDC_ARROW);	CurList.numCurs=NUM_EARTH;	for(i=0;i<CurList.numCurs;i++)		CurList.Curs[i]=LoadCursor(hInstance,MAKEINTRESOURCE(vCursorEarth+i));	CurList.whichCurs=0;	}voidReleaseCurs()	{	int i;	DestroyCursor(cross);#if (!VPLAYER)	DestroyCursor(lockArrow);    DestroyCursor(hand);    DestroyCursor(question);    DestroyCursor(split);    DestroyCursor(pencil);    DestroyCursor(oRing);    DestroyCursor(finger);    DestroyCursor(dropper);    DestroyCursor(hideArrow);    DestroyCursor(tumbleHand);	DestroyCursor(connectArrow);	DestroyCursor(justSayNo);#if VR || VPRO	// MERGE-GOURAUD-PRO-2	DestroyCursor(zoomOutArrow);	DestroyCursor(zoomInArrow);#endif // VR#endif //!VPLAYER// { DAS-BUGFIX 10/23/93 these cursors can't be destroyed//	DestroyCursor(wait);//	DestroyCursor(textBar);//	DestroyCursor(arrow);//  DestroyCursor(fCross);// } DAS-BUGFIX 10/23/93	for(i=0;i<CurList.numCurs;i++)		DestroyCursor(CurList.Curs[i]);	}// } DAS-BUGFIX 10/23/93voidInitFonts(HINSTANCE hInst)	{	char filePath[256];        int length;	length = GetModuleFileName(hInst, filePath, 256);	while((length>0)&&(filePath[length] != '\\'))		{		filePath[length] = 0x00;		length --;		}        strcat(filePath, FONT_FILE_NAME);	gFontsInstalled = AddFontResource(filePath);    // jca 20OCT94 for PRO to run okay-ish under NT	fontCache = new(V_Array);	fontCache->cArray(0, sizeof(CacheItem), 4);	}voidReleaseFonts()	{	int err,n,i;	CacheItem item;	n = fontCache->ALength();    for(i=0;i<n;i++)		{		fontCache->Get(i,&item);		DestroyFont(item.hFont);		}    fontCache->dArray();	err = RemoveFontResource(FONT_FILE_NAME);	}HFONTGetFont(int font,int size,int face)	{	int nItems, i;	CacheItem *item;    HFONT hFont;	if(font==vSystemFont)		return GetStockObject(SYSTEM_FONT);	if(font==lastFont&&size==lastSize&&face==lastFace)		return lastHFont;	nItems=fontCache->ALength();	item=(CacheItem*)fontCache->Use();    hFont=NULL;	for(i=0;i<nItems;i++)		{		if(font==item[i].font&&size==item[i].size&&face==item[i].face)	        {			hFont=item[i].hFont;			break;            }		}    fontCache->Unuse();	if(!hFont)    	{		CacheItem newItem;		if((hFont=LoadFont(font,size,face))!=NULL)			{			newItem.font=font;			newItem.size=size;			newItem.face=face;			newItem.hFont=hFont;			fontCache->Append(&newItem);            }		}	if(hFont)		{		lastFont=font;		lastSize=size;		lastFace=face;        lastHFont=hFont;        }    return hFont;	}intFontsLoaded()	{	// jca added these lines and replaced the below.  32-bit systems don't	// find the module anyway; perhaps it can only find DLLs or EXEs.	// see the Win32 programming manual, "GetModuleHandle".  20OCT94 for PRO [[[	if (gFontsInstalled)	return(1);	else					return(0);		/*	jca 5AUG94 commented out for NT	if (GetModuleHandle(name) == NULL)		return 0;	else		return 1;	]]] jca 20OCT94 */	}HFONTLoadFont(int font,int size,int face)	{	HFONT hFont;	char faceName[256];    int charSet;	switch(font)		{		case vAppFont:		case vGenevaFont:		case vDialogFont:#if ENGLISH			strcpy(faceName,"MS Sans Serif");			charSet=ANSI_CHARSET;#elif JAPANESE			strcpy(faceName,"\x82\x6C\x82\x72\x20\x96\xBE\x92\xA9"); //msmincho			charSet=SHIFTJIS_CHARSET;#elif SPANISH			strcpy(faceName,"MS Sans Serif");			charSet=ANSI_CHARSET;#elif GERMAN			strcpy(faceName,"MS Sans Serif");			charSet=ANSI_CHARSET;#elif FRENCH			strcpy(faceName,"MS Sans Serif");			charSet=ANSI_CHARSET;#endif //JAPANESE			break;		case vMonacoFont:			strcpy(faceName,"VMonaco");			charSet=OEM_CHARSET;			break;		case vCourierFont:			strcpy(faceName,"Courier");			charSet=OEM_CHARSET;			break;		case vChicagoFont:			strcpy(faceName,"Chicago");			charSet=OEM_CHARSET;			break;		case vTimesFont:			strcpy(faceName,"VTimes");			charSet=OEM_CHARSET;			break;		case vButtonFont:			strcpy(faceName,"BtnFnt");			charSet=OEM_CHARSET;			break;		case vVerticalFont:			strcpy(faceName,"VertFnt");			charSet=OEM_CHARSET;			break;		}	hFont = CreateFont(-size,0,0,0,		(face&vBold)?FW_BOLD:FW_DONTCARE,		(face&vItalic)?TRUE:FALSE,		(face&vUnderlined)?TRUE:FALSE,		0,charSet,		OUT_DEFAULT_PRECIS,		CLIP_DEFAULT_PRECIS,		DEFAULT_QUALITY,		FF_DONTCARE,		faceName);	return hFont;    }intDestroyFont(HFONT hFont)	{	int result;	/*This should be selected out of context first */	result = DeleteObject(hFont);	return result;	}voidVSetFont(int font,int size,int face)	{	HFONT hFont;	if(currentDevice)		{		hFont = GetFont(font,size,face);		SelectObject(currentDevice,hFont);		}	}voidVTextMode(int mode)	{	if(currentDevice)    	{		switch(mode)			{			case vSrcXor: SetBkMode(currentDevice,TRANSPARENT); break;			case vSrcOr:			default: SetBkMode(currentDevice,OPAQUE); break;			}    	}	}voidVPenMode(int mode)	{	LONG drawMode;	int penStyle;extern int grayNum;	if(NULL == currentDevice)		return;	penId = mode;			// save the pen state. jca 8 aug 93	switch(mode)		{		case vMarqueeMove:			if(grayNum) drawMode = R2_NOTXORPEN;			else drawMode = R2_XORPEN;			penStyle = PS_DOT;			break;		case vMarqueeStay:			drawMode = R2_NOTXORPEN;			penStyle = PS_SOLID;			break;		case vPatXor:			drawMode = R2_NOTXORPEN;            penStyle = PS_SOLID;			break;		case vPatOr:			drawMode = R2_MERGEPENNOT;//R2_MASKPENNOT;            penStyle = PS_SOLID;			break;	  		case vPatBic:		case vSrcOr:		case vSrcXor: 		case vPatCopy:		default:			drawMode = R2_COPYPEN;            penStyle = PS_SOLID;			break;		}	if(thePen.lopnStyle!=penStyle)		VSetPenStyle(penStyle);	SetROP2(currentDevice,drawMode);	}voidVSetPenStyle(int style)	{	thePen.lopnStyle = style;	UpdatePen();	}voidVSetPenSize(int h,int v)	{	thePen.lopnWidth.x = h;	thePen.lopnWidth.y = v;    UpdatePen();	}// utils.  jca 27 aug 93int VGetPattern(void)		{  return(patId); }voidVClipRect(Rect *r) {  }//#define AdjR(a,b) { a.top=b.top-1;a.bottom=b.bottom-1;a.left=b.left-1;a.right=b.right-1;}#define AdjR(a,b) { a.top=b.top;a.bottom=b.bottom;a.left=b.left;a.right=b.right;}voidVEraseRect(Rect *r)	{	Rect tr;    AdjR(tr,(*r));	FillRect(currentDevice,&tr,GetStockObject(WHITE_BRUSH));	}voidVFrameRect(Rect *r)	{	Rect tr;	AdjR(tr,(*r));	tr.right--;    tr.bottom--;	MoveTo(currentDevice,tr.left,tr.top);	LineTo(currentDevice,tr.right,tr.top);	LineTo(currentDevice,tr.right,tr.bottom);	LineTo(currentDevice,tr.left,tr.bottom);    LineTo(currentDevice,tr.left,tr.top);	}	voidVFrameOval(Rect *r)	{	Rect tr;    AdjR(tr,(*r));	Ellipse(currentDevice,r->left,r->top,r->right,r->bottom);	}	voidVPaintRect(Rect *r)	{	POINT p[4];	HPEN oldP, otherP;//    int fillmode;	int fillMode;	//jam changed to match variables below    				//12-14-93	p[0].x = r->left;    p[0].y = r->top;	p[1].x = r->right;    p[1].y = r->top;	p[2].x = r->right;    p[2].y = r->bottom;	p[3].x = r->left;    p[3].y = r->bottom;	otherP = GetStockObject(NULL_PEN);	oldP = SelectObject(currentDevice, otherP);	fillMode = GetPolyFillMode(currentDevice);	// diamond stealth hates the ALTERNATIVE fill mode.	SetPolyFillMode(currentDevice, WINDING);	Polygon(currentDevice, p, 4);	SetPolyFillMode(currentDevice, fillMode);     	// diamond stealth. jca 8 aug 93	otherP = SelectObject(currentDevice, oldP);	}	voidVFillRect(Rect *r)	{	POINT p[4];	HPEN oldP, otherP;//    int fillmode;	int fillMode;	//jam changed to match variables below    				//12-14-93	p[0].x = r->left;    p[0].y = r->top;	p[1].x = r->right;    p[1].y = r->top;	p[2].x = r->right;    p[2].y = r->bottom;	p[3].x = r->left;    p[3].y = r->bottom;	otherP = GetStockObject(NULL_PEN);	oldP = SelectObject(currentDevice, otherP);	fillMode = GetPolyFillMode(currentDevice);	// diamond stealth hates the ALTERNATIVE fill mode.	SetPolyFillMode(currentDevice, WINDING);	Polygon(currentDevice, p, 4);	SetPolyFillMode(currentDevice, fillMode);     	// diamond stealth. jca 8 aug 93	otherP = SelectObject(currentDevice, oldP);	}void VMoveTo(int h,int v)	{	MoveTo(currentDevice,h,v);//	gCurrentPt.h = h;//	gCurrentPt.v = v;	}	void VLineTo(int h,int v)	{	int hR,vR; //	hR = (h==gCurrentPt.h) ? h : ((h>gCurrentPt.h) ? h+1 : h-1); //	vR = (v==gCurrentPt.v) ? v : ((v>gCurrentPt.v) ? v+1 : v-1);//	hR = h; //	vR = v;	LineTo(currentDevice,h,v);//	gCurrentPt.h = h;//	gCurrentPt.v = v;	}static	COLORREF vForeColorRef = 0;static	COLORREF vBackColorRef = 0;voidVForeColor(RGBColor *col) 	{	unsigned char red,green,blue;	if(!currentDevice)return;    vCurrentForeColor = *col;    red = vCurrentForeColor.red>>8;    green = vCurrentForeColor.green>>8;    blue = vCurrentForeColor.blue>>8;//	vForeColorRef = RGB(red,green,blue);//	vForeColorRef = GetNearestColor(currentDevice,vForeColorRef);	vForeColorRef = PALETTERGB(red,green,blue);	thePen.lopnColor = vForeColorRef;    	SetTextColor(currentDevice,vForeColorRef);	UpdateBrush();	UpdatePen();	}voidUpdateBrush()	{	HBRUSH oldBrush;	if(currentDevice)		{		if (currentBitmap)			currentBrush = CreatePatternBrush(currentBitmap);		else			currentBrush = CreateSolidBrush(vForeColorRef);		oldBrush = SelectObject(currentDevice,currentBrush);		DeleteObject(oldBrush);		}	}voidUpdatePen()	{	HPEN oldPen;	if(currentDevice)    	{		currentPen = CreatePenIndirect(&thePen);		oldPen = SelectObject(currentDevice,currentPen);		DeleteObject(oldPen);        }	}void VBackColor(RGBColor *col) 	{ 	unsigned char red,green,blue;	if(!currentDevice)return;	vCurrentBackColor = *col;	red = vCurrentBackColor.red>>8;	green = vCurrentBackColor.green>>8;	blue = vCurrentBackColor.blue>>8;//	vBackColorRef = RGB(red,green,blue);//	vBackColorRef = GetNearestColor(currentDevice,vBackColorRef);	vBackColorRef = PALETTERGB(red,green,blue);	SetBkColor(currentDevice,vBackColorRef);	}	voidVSelectPatternOrigin(Point p)	{	HBITMAP oldPattern;	short i;// 	jca 13APR94 why do we do this?  Shouldn't we set the select bitmap origin// 	correctly even if there is no pane set? (we set the select origin before// 	we do much anyway; we have to for the mac)  So I've commented this line// 	out.//	if(!currentDevice)return;	for(i=0; i< 8;i++)		selectBitmap[i]=INIT_SELECT_PAT;	selectBitmap[7-(p.v&0x07L)] = 0xFF^(0x01<<(p.h&0x07L));	patId = -1;    	}	voidVSetCursor(int newCursor)	{	HCURSOR theCursor;	long currentTime;	int whichCurs;// DAS 6 Nov 93 -- Windows changes cursor on us without warning, so// we can't be sure that the cursor is the same as we think it is.//	if((cursNum == newCursor)&&(newCursor!=vCursorEarth)) return;   		switch(newCursor)		{		case vCursorCross: theCursor = cross; break;#if (!VPLAYER)		case vCursorText: theCursor = textBar; break;		case vCursorFCross: theCursor = fCross; break;		case vCursorPencil: theCursor = pencil; break;		case vCursorRing:   theCursor = oRing; break;		case vCursorFinger: theCursor = finger; break;		case vCursorDropper:theCursor = dropper; break;		case vCursorTumble: theCursor = tumbleHand; break;		case vCursorConnect:theCursor = connectArrow; break;		case vCursorHide:   theCursor = hideArrow; break;		case vCursorLock:   theCursor = lockArrow; break;		case vCursorHand:   theCursor = hand; break;		case vCursorQuestion:theCursor = question; break;		case vCursorSplit:  theCursor = split; break;		case vCursorNO:		theCursor = justSayNo; break; // DAS-VDRAG 9/3/93#if ((VR) || (VPRO))	// MERGE-GOURAUD-PRO-2		case vCursorZoomOut: theCursor = zoomOutArrow; break;		case vCursorZoomIn: theCursor = zoomInArrow; break;#endif //((VR) || (VPRO))#endif //!VPLAYER		case vCursorEarth:			if(cursNum!=vCursorEarth){cursNum=vCursorEarth;delayCount=(cccount=VGetTime())+30;}			currentTime=VGetTime();			if(delayCount<currentTime && currentTime-cccount>6)				{				whichCurs = CurList.whichCurs;				CurList.whichCurs = (whichCurs>=CurList.numCurs-1)?0:whichCurs+1;				theCursor=CurList.Curs[whichCurs];				cccount=currentTime;				}			else				return;			break;		case vCursorArrow:		default:			theCursor = arrow;			break;		}	cursNum = newCursor;	SetCursor(theCursor);	}intVTextWidth(char *str,int start,int length)	{    DWORD result;	int width,height;	result = GetTextExtent(currentDevice,&str[start],length);	width = LOWORD(result);    return width;    }voidVSetPenNormal()	{	VSetPattern(vPatBlack);	VPenMode(vPatCopy);	}#elif MACINTOSHvoid VForeColor(RGBColor * color)	{	int	theDepth;	ULong cnum;		theDepth=FindDepth();	if(colorQD&&theDepth>2)RGBForeColor(color);	else if(theDepth>=0)		{		cnum=((ULong)color->red+			(ULong)color->blue+			(ULong)color->green);		if(cnum<39321L)VSetPattern(vPatBlack);		else if(cnum<78642L)VSetPattern(vPatDkGray);		else if(cnum<117963L)VSetPattern(vPatGray);		else if(cnum<157284L)VSetPattern(vPatLtGray);		else VSetPattern(vPatWhite);		}	else if(theDepth==-1)/*use a finer dither pattern*/		{		cnum=((ULong)color->red+			(ULong)color->blue+			(ULong)color->green+			(ULong)color->green);		cnum>>=14;		cnum=15-cnum;		PenPat(&(hiResGray[cnum]));		}	else /*use no dither, black is black, otherwise white*/		{		cnum=((ULong)color->red+			(ULong)color->blue+			(ULong)color->green+			(ULong)color->green);		if(cnum) VSetPattern(vPatWhite);		else VSetPattern(vPatBlack);		}	}void VBackColor(RGBColor * color)	{	int	theDepth;	ULong cnum;		theDepth=FindDepth();	if(colorQD&&theDepth>2)RGBBackColor(color);	else if(theDepth>=0)		{		cnum=((ULong)color->red+			(ULong)color->blue+			(ULong)color->green);		if(cnum<39321L)BackPat(&black);		else if(cnum<78642L)BackPat(&dkGray);		else if(cnum<117963L)BackPat(&gray);		else if(cnum<157284L)BackPat(&ltGray);		else BackPat(&white);		}	else if(theDepth==-1)/*use a finer dither pattern*/		{		cnum=((ULong)color->red+			(ULong)color->blue+			(ULong)color->green+			(ULong)color->green);		cnum>>=14;		cnum=15-cnum;		PenPat(&(hiResGray[cnum]));		}	else /*use no dither, black is black, otherwise white*/		{		cnum=((ULong)color->red+			(ULong)color->blue+			(ULong)color->green+			(ULong)color->green);		if(cnum) VSetPattern(vPatWhite);		else VSetPattern(vPatBlack);		}	} void InitCurs()	{	Handle hPat;	short curCount;		InitCursor();		CurList=(acurHandle)GetResource('acur',128);	MoveHHi((Handle)CurList);	HLock((Handle)CurList);	for(curCount=0;curCount<(*CurList)->numCurs;curCount++)		{	 	(*CurList)->Curs[curCount]=GetCursor(HiWord((long)(*CurList)->Curs[curCount]));		MoveHHi((Handle)(*CurList)->Curs[curCount]);		HLock((Handle)(*CurList)->Curs[curCount]);		}	(*CurList)->whichCurs=0;	cross=GetCursor(vCursorCross);		MoveHHi((Handle)cross);	HLock((Handle)cross);#if (!VPLAYER)	textBar=GetCursor(vCursorText); 	MoveHHi((Handle)textBar); 	HLock((Handle)textBar);	fCross=GetCursor(vCursorFCross);	MoveHHi((Handle)fCross);HLock((Handle)fCross);	lockArrow=GetCursor(vCursorLock);	MoveHHi((Handle)lockArrow);HLock((Handle)lockArrow);	hand=GetCursor(vCursorHand);		MoveHHi((Handle)hand);	HLock((Handle)hand);	question=GetCursor(vCursorQuestion);MoveHHi((Handle)question);HLock((Handle)question);	split=GetCursor(vCursorSplit);		MoveHHi((Handle)split);HLock((Handle)split);	pencil=GetCursor(vCursorPencil);	MoveHHi((Handle)pencil);HLock((Handle)pencil);	oRing=GetCursor(vCursorRing);		MoveHHi((Handle)oRing);	HLock((Handle)oRing); 	finger=GetCursor(vCursorFinger);	MoveHHi((Handle)finger);HLock((Handle)finger); 	dropper=GetCursor(vCursorDropper);	MoveHHi((Handle)dropper);HLock((Handle)dropper); 	hideArrow=GetCursor(vCursorHide);MoveHHi((Handle)hideArrow);HLock((Handle)hideArrow);	tumbleHand=GetCursor(vCursorTumble);MoveHHi((Handle)tumbleHand);HLock((Handle)tumbleHand); 	connectArrow=GetCursor(vCursorConnect);MoveHHi((Handle)connectArrow); HLock((Handle)connectArrow); // DAS-VDRAG 9/3/93	justSayNo = GetCursor(vCursorNO); MoveHHi((Handle)justSayNo); HLock((Handle)justSayNo);#if ((VR) || (VPRO))	// MERGE-GOURAUD-PRO-2	zoomOutArrow=GetCursor(vCursorZoomOut);	MoveHHi((Handle)zoomOutArrow);HLock((Handle)zoomOutArrow);	zoomInArrow=GetCursor(vCursorZoomIn);	MoveHHi((Handle)zoomInArrow);HLock((Handle)zoomInArrow);#endif //((VR) || (VPRO))	#endif //!VPLAYER	hPat=GetResource('PAT#',128);	HLock((Handle)hPat);	hiResGray=(Pattern *)(2+*hPat);	HUnlock((Handle)hPat);	}voidVSelectPatternOrigin(Point p)	{	int i;	for(i=0; i< 8;i++)		selectPattern.pat[i]=0;	selectPattern.pat[7-(p.v&0x07L)] = 0x01<<(p.h&0x07L);	}	voidVSetPattern(int patFlag)	{	switch(patFlag)		{		case vPatLtGray: currentPattern = &ltGray; break;		case vPatGray: currentPattern = &gray; break;		case vPatDkGray: currentPattern = &dkGray; break;		case vPatWhite: currentPattern = &white; break;		case vPatSelect: currentPattern = &selectPattern; break;		case vPatBlack: 		default: currentPattern = &black; break;		}	PenPat(currentPattern);	}voidVSetCursor(int newCursor)	{	long thisCount;	if((cursNum == newCursor)&&(cursNum != vCursorEarth)) return;	switch(newCursor)		{		case vCursorCross: SetCursor(*cross); break;#if (!VPLAYER)		case vCursorHand: SetCursor(*hand); break;		case vCursorQuestion: SetCursor(*question); break;		case vCursorSplit: SetCursor(*split); break;		case vCursorText: SetCursor(*textBar); break;		case vCursorFCross: SetCursor(*fCross); break;		case vCursorPencil: SetCursor(*pencil); break;		case vCursorRing: SetCursor(*oRing); break;		case vCursorFinger: SetCursor(*finger); break;		case vCursorDropper: SetCursor(*dropper); break;		case vCursorTumble: SetCursor(*tumbleHand); break;		case vCursorConnect: SetCursor(*connectArrow); break;		case vCursorHide: SetCursor(*hideArrow); break;		case vCursorLock: SetCursor(*lockArrow); break;		case vCursorNO:	SetCursor(*justSayNo); break; // DAS-VDRAG 9/3/93#if ((VR) || (VPRO))	// MERGE-GOURAUD-PRO-2		case vCursorZoomOut: SetCursor(*zoomOutArrow); break;		case vCursorZoomIn: SetCursor(*zoomInArrow); break;#endif //((VR) || (VPRO))#endif //!VPLAYER		case vCursorEarth:			if(cursNum!=vCursorEarth){cursNum=vCursorEarth;delayCount=(cccount=VGetTime())+30;}			thisCount=VGetTime();			if(delayCount<thisCount && thisCount-cccount>6)				{				if((*CurList)->whichCurs>=(*CurList)->numCurs-1)(*CurList)->whichCurs=0;				else (*CurList)->whichCurs++;				SetCursor(*((*CurList)->Curs[(*CurList)->whichCurs]));				cccount=thisCount;				}			break;		case vCursorArrow: 		default: 			SetCursor(&arrow); 			break;		}	cursNum = newCursor;	}#endif //WINDOWS