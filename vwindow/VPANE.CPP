/*------------------------------------------------------------------------------ * Virtus V_Windows * Version 2.0 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:    WINDOWS NOTE!!!	On the Mac, life was simpler because there is only one drawing port at any one time	and so the application really was concerned with SETTING UP the drawing port properly	but breaking it down was sort of a non-issue. As long as the application guaranteed	that it set itself up right, everything was OK. In Windows, there are multiple drawing	ports floating around with very rigid opinions about how the memory is allocated and	deallocated. This means that UNSETTING the port is every bit as important as setting ity	up was. This means that V_Windows has to make sure that SetPane()/UnsetPane()'s are not	pushed and popped (as the offscreen stuff gets really confused and the Panes gobble up 	large amounts of memory in Windows (where there isn't a tremendous amount of space to	begin with.)) Thus, SetPane() now pays attention to the currentPane to see if it needs to	UnsetPane() a different Pane before it sets itself. Also UnsetPane has to make sure it only	Unsets itself if it really is the currentPane. Hind sight being 20/20, the application should	have had responsibility for this for clarity, but V_Windows can do it for convenience. We all	admit that the Pane/Window/Document relationships were a good first guess, but could stand	some work.			Signed -Mark Uland			MORONITY NOTE!!!	The above commetary reveals a complete and total cluelessness.  To say that "breaking	down" a port is a non-issue reaveals such utter and complete moronity, it staggers	the imagination that WalkThrough works at all.  Single ports and multiple ports have	*NOTHING* to do with anything, but apparently confused the tiny brain that was	responsible for this abomination.  As a "first guess", it was abysmal, obviously	created by someone who has no sense of good bug-free programming.  For example, if you 	think that "unsetting ports is a non-issue" take a look at this:				SetMetaPort			draw stuff here in proper port			SetMetaPort				draw stuff here in proper port			UnsetMetaPort -- this sets to *WINDOW MANAGER* port, i.e. the *SCREEN*			draw stuff here in the *TOTALLY WRONG* port		UnsetMetaPort			So a routine that calls another routine that calls SetMetaPort will invariably	break if it continues to draw.  Since there is no way to know what routines will	call SetMetaPort, how about making them save and restore the port???  Or is that	too simple a solution?  No, let's set it to the *WINDOW MANAGER* port.  This so-called	"hindsight" I prefer to call "ass vision".  			That the above is possible demonstrates that the person who wrote this code to begin	with had *NO CONCEPT* of saving and restoring state, and should go back to BASIC	PROGRAMMING 101 at BUTT-MUNCH COMMUNITY COLLEGE.  You can't nest SetMeta/UnsetMeta,	or anything else for that matter.  TOTAL CRAP!!!!!!!!!!  ONLY A COMPLETE IDIOT WOULD	THINK THAT "UNSETTING" IS NOT IMPORTANT.  ...and guess what -- the supposed "fix"	described above *STILL* doesn't save and restore the ports!!!!!!!!!!!!!!!!!!!!!!!	UTTER INCOMPETENCE!!!!!!   Now, in all fairness, perhaps Mark Uland didn't write	the code that caused the problems.  But the above comment demonstrates that he	was totally clueless with respect to saving and restoring the port.			Signed, 			Drew Davidson * History: *		Modified	DAS 7/30/92		Added support for MSWindows *		Modified	MJU	9/4/92		Added support for MSWindows *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VPane.h"#include "VMenu.h"#include "VWindow.h"#include "VDocumnt.h"#include "VItem.h"#include "VGraphic.h"#include "VGUtil.h"#include "VGestalt.h"#include "VButton.h"#include "VMain.h" #include "VSound.h"#include "VError.h"#include "VMemUtil.h"#include "VWI.h" //DAS-VWI 8/9/93#include "ShowTest.h"#include <stdio.h>#if MACINTOSH#include <Balloons.h>#include <QDOffscreen.h>#endif //MACINTOSH// int balloonOn=FALSE; // DAS-VWI - new flag // DAS 10/14/93 dump this variableV_Pane *currentPane = NULL;void SetCurrentPane(V_Pane *p) { currentPane = p; }V_Pane *GetCurrentPane() { return currentPane; }int dither = TRUE; /* DUDE_PORT this used to be set by Global stuff */#if WINDOWS#define MSG_DEACTIVATEWINDOID WM_USER+2001char *paneClassName     = "Virtus:PaneProc";V_Pane *lastPane=NULL;V_Pane *createPane = NULL;void SetCreatePane(V_Pane *p) { createPane = p; }V_Pane *GetCreatePane() { return createPane; }static int trapState = FALSE;//static int doingPaint = FALSE;  // jca 17FEB94 no longer used.static int popCapture = FALSE;      // jca.  Flag for the popups in capture modeint gWithoutButtonDown = FALSE;     // jca.  flag for whether we're not flying with the button downlong FAR PASCAL _exportPaneWndProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )	{	HWND oldFocus,cntrlHwnd;	MSG  testMsg;	HDC hDC;    Rect rect;	V_Pane *thePane;	Point p;	long modifier;	int result,val,whichScroll,dummy;   	PAINTSTRUCT ps;	thePane = (V_Pane *)GetWindowLong(hwnd,0);	result = 0;   	modifier = wParam;	switch (msg)		{		case WM_CREATE:			thePane = GetCreatePane();			SetWindowLong(hwnd,0,(long)thePane);// ??// Why select a palette into the dc, the delete the dc?// Why attach a palette, and never unhook it?// Yes, a window should have a pallete,// but it also needs colors, ROP's, etc. Who sets those?//			hDC=VGetDC(hwnd);//			if (currentPalette)//            	{//				SelectPalette(hDC,currentPalette,FALSE);//                }//			ReleaseDC(hwnd,hDC);			if (trapState)			// BILBIL - need to unset capture if it is set - 12/9/93				ReleaseCapture();			trapState=FALSE;			break;		case WM_DESTROY:			if (trapState)			// BILBIL - need to unset capture if it is set - 12/9/93				ReleaseCapture();			trapState=FALSE;			if(lastPane == thePane)            	lastPane = NULL;            break;		case WM_COMMAND:			val = HIWORD(lParam); /* 			if (val == BN_CLICKED)				{				if (wParam == ID_VIRTUS_REVERT) // the button id					{                    }				else if (wParam == ID_VIRTUS_DEFAULT)					{                    }				else					thePane->FindControl(LOWORD(lParam),val);				}			else if (val == EN_KILLFOCUS || val == CBN_SELENDOK)				thePane->FindControl(LOWORD(lParam),val);		  */  /* the previous way -- jca 10 june 93  		*/	if (val == EN_KILLFOCUS || val == BN_CLICKED || val == CBN_SELENDOK)				{				thePane->FindControl(LOWORD(lParam),val);				PostMessage(thePane->theWindow->theWindow,MSG_DEACTIVATEWINDOID,0,0);				}			break;		case WM_VSCROLL:		case WM_HSCROLL:			if(WM_VSCROLL==msg)thePane->VertScroll->DoScroll(wParam,lParam);			else thePane->HorzScroll->DoScroll(wParam,LOWORD(lParam));			break;					case WM_KEYDOWN:			{				long keynum;				keynum = wParam;				keynum++;            }			thePane->KeyAction(GetMSGModifiers(),NULL);	    	break;		case WM_PAINT:			Rect r;			thePane->doingPaint = TRUE;			if(GetUpdateRect(hwnd,&r,FALSE))				thePane->VDisplay(ACT_REDRAW);            else				thePane->VDisplay(DRAW);			thePane->doingPaint = FALSE;			break;		case WM_LBUTTONDBLCLK:		case WM_MBUTTONDBLCLK:		case WM_RBUTTONDBLCLK:        	modifier|=doubleClick;		case WM_LBUTTONDOWN:		case WM_MBUTTONDOWN:		case WM_RBUTTONDOWN://			SetFocus(hwnd);			if (popCapture != TRUE)  // don't set capture if this is a popup            	{ 				SetCapture(hwnd);				}			trapState = TRUE;			p.h = LOWORD(lParam);			p.v = HIWORD(lParam);			// jca begin			if ((thePane->popup&POPUPDIALOG)&&!(VPtInRect(p, &(thePane->paneRect))))				{				ReleaseCapture();				trapState = FALSE;                popCapture = FALSE;				VSendMessage(DieWindowEvent);				}			else            	{				if(msg==WM_MBUTTONDOWN)modifier|=V_SHIFT;                if(msg==WM_RBUTTONDOWN)modifier|=V_OPTION;				thePane->MouseClick(p,modifier);				PostMessage(hwnd,VWM_MOUSEMOVE,wParam,lParam);				}            //jca end			break;					case WM_LBUTTONUP:		case WM_MBUTTONUP:		case WM_RBUTTONUP:			if((trapState)&&(!popCapture))            	{				p.h = LOWORD(lParam);				p.v = HIWORD(lParam);				thePane->MouseUnclick(p,modifier);				trapState = 0;				ReleaseCapture();				if(thePane->popup&MODALDIALOG)					VSendMessage(DieWindowEvent);				PostMessage(hwnd,VWM_MOUSEMOVE,wParam,lParam);				}			else if (popCapture)				{				p.h = LOWORD(lParam);				p.v = HIWORD(lParam);				if(msg==WM_MBUTTONDOWN)modifier|=V_SHIFT;                if(msg==WM_RBUTTONDOWN)modifier|=V_OPTION;				thePane->MouseUnclick(p,modifier);				trapState = FALSE;				if((thePane->popup&POPUPDIALOG)&&(VPtInRect(p, &(thePane->paneRect))))					{					ReleaseCapture();					trapState = FALSE;                	popCapture = FALSE;					VSendMessage(DieWindowEvent);					}				}			break;		case WM_NCHITTEST:			result = DefWindowProc (hwnd,msg,wParam,lParam);			if(lastPane && (result==HTCLIENT)				&& (hwnd!=lastPane->paneWindow))				{                p.h=p.v=-32000;//DAS Force this point to be invalid				lastPane->TrackCursor(p,NULL);				lastPane = NULL;				}			break;		case VWM_MOUSEMOVE:		case WM_MOUSEMOVE:			modifier=(modifier&~0x01) | trapState;			if(lastPane && (lastPane!=thePane))            	lastPane->TrackCursor(p,modifier);			p.h = LOWORD(lParam);			p.v = HIWORD(lParam);			if(wParam & MK_MBUTTON)modifier|=V_SHIFT;			else if(wParam & MK_RBUTTON)modifier|=V_OPTION;			// jca 6APR94 paints have priority over moves			if (PeekMessage(&testMsg,NULL,WM_PAINT,WM_PAINT,PM_NOYIELD|PM_REMOVE))				SendMessage(testMsg.hwnd, testMsg.message, testMsg.wParam, testMsg.lParam);			thePane->TrackCursor(p, modifier);			//jam jca 20OCT94 for PRO if mouse is not down, we don't generate VWM_MOUSEMOVE messages.            //this caused an infinite loop when holding control key and clicking the magnifier button [[[			#if VPRO			if (!trapState)				{		  		lastPane = thePane;				break;				}			#endif //VPRO			//jam jca 20OCT94 for PRO if mouse is not down, we don't generate VWM_MOUSEMOVE messages.			//this caused an infinite loop when holding control key and clicking the magnifier button ]]]			if (((modifier &(V_SHIFT | V_OPTION)) || trapState) || thePane->ContinuousTrack())				{				MSG testMsg2, testMsg3;				if ((!(PeekMessage(&testMsg,NULL,WM_MOUSEFIRST,WM_MOUSELAST,PM_NOYIELD|PM_NOREMOVE)))					 && (!(PeekMessage(&testMsg2,NULL,VWM_MOUSEMOVE,VWM_MOUSEMOVE,PM_NOYIELD|PM_NOREMOVE))))					{					if (PeekMessage(&testMsg,NULL,WM_KEYDOWN,WM_KEYUP,PM_NOYIELD|PM_NOREMOVE))						{						if (testMsg.wParam == VK_SHIFT)							{							if (testMsg.message == WM_KEYDOWN)								wParam |= V_SHIFT;							else                            	wParam &= ~V_SHIFT;							}						else if(testMsg.wParam == VK_CONTROL)							{							if (testMsg.message == WM_KEYDOWN)								wParam |= V_OPTION;							else								wParam &= ~V_OPTION;                            }						}					PostMessage(hwnd,VWM_MOUSEMOVE,wParam,lParam);					}				}			lastPane = thePane;			break;		case WM_WINDOWPOSCHANGING:			if(!thePane->installed)            	{				tagWINDOWPOS *wPOS;				wPOS=(tagWINDOWPOS FAR*)lParam;				wPOS->flags&=~(SWP_HIDEWINDOW);				result=0;				}            else				result = DefWindowProc (hwnd,msg,wParam,lParam);			break;		case WM_ERASEBKGND:        	if(thePane->installed)				result = DefWindowProc (hwnd,msg,wParam,lParam);			break;		default:		defProc:			result = DefWindowProc (hwnd,msg,wParam,lParam);			break;	    }	    	return result;	}#endif //WINDOWS#if MACINTOSHVGrafPort V_Pane::GetParentWindow() { return theWindow->GetParentWindow(); }#elif WINDOWSVGrafPort V_Pane::GetParentWindow(){ return paneWindow; }#endif //WINDOWSvoid V_Pane::cPane(int flag)	{	SetDisplayType(DISPLAY_PANE);// DAS-VWINDOWS 10/9/93	barWidth=16;	active=FALSE;	resolution.h = resolution.v = 72; /* 72 pixels/inch */	frame=1;	popup=FALSE;	outputOn = FALSE;	itemList = new(V_ItemList);	itemList->cItemList();	scrollBarFlag = flag;	installed=FALSE;//	doingPaint=FALSE;	VertScroll = NULL;	HorzScroll = NULL;	if(scrollBarFlag & VERTSCROLLBAR) { VertScroll=new(V_VertScroll); VertScroll->cItem(); }	if(scrollBarFlag & HORZSCROLLBAR) { HorzScroll=new(V_HorzScroll); HorzScroll->cItem(); }#if WINDOWS	bandPrint = FALSE;		// ABD MERGE-PRINT -- don't do banded printing by default	paneWindow = NULL;	itemFont = NULL;	if (trapState)			// BILBIL - need to unset capture if it is set - 12/9/93		ReleaseCapture();	trapState=FALSE;#endif //WINDOWS	StashHScrollValue = 0;    StashVScrollValue = 0;	grayOut = (flag & GRAYOUT) ? TRUE : FALSE;	theMenu=new(V_MenuMgr);	theMenu->cMenuMgr();	}void V_Pane::dPane()	{	if(theWindow)theWindow->UnInstall(this);	itemList->dItemList();	itemList=NULL;	if(scrollBarFlag & VERTSCROLLBAR)VertScroll->dItem();	if(scrollBarFlag & HORZSCROLLBAR)HorzScroll->dItem();#if WINDOWS	if(itemFont)DestroyFont(itemFont);#endif //WINDOWS	theMenu->dMenuMgr();	delete(this);	}	void V_Pane::SetUp(V_Window *win)	{	Rect hbounds,vbounds,pR,wR;	Rect vRect;	Point p;	int warnSize,i,length;			theWindow=win;	WindowPane();	theWindow->GetRect(&wR);	pR=wR;	warnSize=(wR.right-wR.left)<win->warnSize.h || (wR.bottom-wR.top)<win->warnSize.v;#if WINDOWS    warnSize = FALSE;#endif //WINDOWS	p.h=0; p.v=0;	grow=GrowRectCalc(&pR,&p,INSTALL,warnSize);	contRect=pR;	paneRect=pR;	if(scrollBarFlag & VERTSCROLLBAR) CalcVert(&vbounds);	if(scrollBarFlag & HORZSCROLLBAR) CalcHorz(&hbounds);	CalcDataRect();	GetVirtual(&vRect);	virtRect=vRect;	CalcScroll();	#if WINDOWS	{	DWORD wStyle;	SetCreatePane(this);	wStyle = WS_CHILDWINDOW|WS_VISIBLE;	if(scrollBarFlag&VERTSCROLLBAR)wStyle|=WS_VSCROLL;	if(scrollBarFlag&HORZSCROLLBAR)wStyle|=WS_HSCROLL;	paneWindow = CreateWindow(paneClassName,NULL,wStyle,		paneRect.left,paneRect.top,		paneRect.right-paneRect.left,paneRect.bottom-paneRect.top,		theWindow->GetParentWindow(),NULL,GetAppInstance(),NULL);	}#endif //WINDOWS 		SetPane();	PaneDepth();	SizeNotify();		if(scrollBarFlag & VERTSCROLLBAR)		{		VertScroll->Install(this);		SetVScrollRange(scrollRect.top,scrollRect.bottom);		if(p.v)  SetVScrollValue(p.v);		VertScroll->Activate(TRUE);		SetVScroll();		}	if(scrollBarFlag & HORZSCROLLBAR)		{		HorzScroll->Install(this);		SetHScrollRange(scrollRect.left,scrollRect.right);		if(p.h)  SetHScrollValue(p.h);		HorzScroll->Activate(TRUE);		SetHScroll();		}	UnsetPane();		itemList->Install(this);    installed=TRUE;	}voidV_Pane::UnSetUp(void)	{	installed=FALSE;	WindowPane();	SetPane();	if(scrollBarFlag & VERTSCROLLBAR)VertScroll->Uninstall();	if(scrollBarFlag & HORZSCROLLBAR)HorzScroll->Uninstall();	UnsetPane();	itemList->Uninstall();#if WINDOWS	// If there's a pending update, the debug version of Windows will	// complain about destroying a system object. So, validate the entire	// window before destroying it.	ValidateRect(paneWindow,NULL);	DestroyWindow(paneWindow);	paneWindow = NULL;#endif //WINDOWS	theWindow=NULL;	if(theMenu->Visible())VSendMessage(CLEAN_MENUS);	}void V_Pane::PaneDepth()	{	Rect globalRect;#if MACINTOSH	WindowPane();	globalRect=contRect;	LocalToGlobal((Point *)&globalRect.top);	LocalToGlobal((Point *)&globalRect.bottom);#endif //MACINTOSH	depth=RectDepth(&globalRect);	}	#if MACINTOSHvoid  V_Pane::Resize(RgnHandle gather,int sizeWarn)#elif WINDOWSvoid  V_Pane::Resize(int sizeWarn)#endif //WINDOWS	{	Rect bounds,pR,wR;	Point p,sPt;	int gr;	WindowPane();	theWindow->GetRect(&wR);	pR=wR;	sPt.h=GetHScrollValue();	sPt.v=GetVScrollValue();	p = sPt;	gr=GrowRectCalc(&pR,&p,RESIZE,sizeWarn);	if(p.h!=sPt.h)SetHScrollValue(p.h);	if(p.v!=sPt.v)SetVScrollValue(p.v);	paneRect=pR;	contRect=pR;	if(scrollBarFlag & VERTSCROLLBAR)		CalcVert(&bounds);	if(scrollBarFlag & HORZSCROLLBAR)		CalcHorz(&bounds);	CalcDataRect();	CalcScroll();	SetScroll(FALSE);		/*das  1/30/90*/	#if MACINTOSH	{	RgnHandle thisRgn;	thisRgn=NewRgn();	pR=paneRect;	RectRgn(thisRgn,&pR);	UnionRgn(gather,thisRgn,gather);	DisposeRgn(thisRgn);	}#elif WINDOWS	MoveWindow(paneWindow,paneRect.left,paneRect.top,		(paneRect.right-paneRect.left),		(paneRect.bottom-paneRect.top), TRUE);	InvalidateRect(paneWindow,NULL,FALSE);#endif //WINDOWS	}void V_Pane::CalcVert(Rect *bounds)	{/*This only applies to the Mac because with  Windows, the data size includes the scroll  bars. This is because, when the window  becomes inactive, the scroll bars completely  disappear!*/#if MACINTOSH	Rect wR;		WindowPane();	theWindow->GetRect(&wR);	*bounds=paneRect;	bounds->top--;	bounds->left--;	if(wR.right==paneRect.right)bounds->right++;	if(wR.bottom==paneRect.bottom)bounds->bottom++;	bounds->left=bounds->right-barWidth;	if(grow){		bounds->bottom-=15;		}	else if(scrollBarFlag & HORZSCROLLBAR)		{		bounds->bottom-=(barWidth-1);		}	bounds->left-=paneRect.left;	bounds->right-=paneRect.left;	bounds->top-=paneRect.top;	bounds->bottom-=paneRect.top;	contRect.right-=(barWidth-1);	VertScroll->SetRect(bounds);#endif  //MACINTOSH	}void V_Pane::CalcHorz(Rect *bounds)	{	Rect wR;	#if MACINTOSH	WindowPane();	theWindow->GetRect(&wR);	*bounds=paneRect;	bounds->top--;	bounds->left--;	if(wR.right==paneRect.right)bounds->right++;	if(wR.bottom==paneRect.bottom)bounds->bottom++;	bounds->top=bounds->bottom-barWidth;	if(grow)		{		bounds->right-=15;		}	else if(scrollBarFlag & VERTSCROLLBAR)		{		bounds->right-=(barWidth-1);		}	bounds->left-=paneRect.left;	bounds->right-=paneRect.left;	bounds->top-=paneRect.top;	bounds->bottom-=paneRect.top;	contRect.bottom-=(barWidth-1);	HorzScroll->SetRect(bounds);#endif //MACINTOSH	}void V_Pane::VDisplay(int type)	{	Rect r;	int v,h;	if((!theWindow) || theWindow->icon ||!theWindow->Visible())return;		v = GetVScrollValue();	h = GetHScrollValue();	// jca 	all popups now done through panes, not to the screen#if MACINTOSH    	if(popup&POPUPDIALOG){Display(type,h,v);return;}#endif	SetPane();	Display(type,h,v);	if(grayOut && (type==DEACT_DRAW ||type==DEACT_REDRAW||type==DEACT_REBUILD_DRAW))		{		r = dataRect;		VPenMode(vPatBic);		VSetPattern(vPatGray);		VPaintRect(&r);		VSetPattern(vPatBlack);		VPenMode(vPatCopy);		}	UnsetPane();	#if MACINTOSH	if(scrollBarFlag & VERTSCROLLBAR)VertScroll->Display(); 	if(scrollBarFlag & HORZSCROLLBAR)HorzScroll->Display();#endif //MACINTOSH	}#if VPRO//JAM TXTRFIDDLE 06/14/94 [[[	/*this routine invalidates the panes rect and then calls VDisplay so the pane  is drawn fresh (this is to be used if the contents of the pane have changed but  a normal display will not draw because an area hasn't been invalidated)*/	void V_Pane::VForceRedraw(int type)	{#if MACINTOSH	Rect r;		r = dataRect;		InvalRect(&r);#elif WINDOWS	InvalidateRect(paneWindow,NULL,FALSE);#endif	VDisplay(type);	}//JAM TXTRFIDDLE 06/14/94 ]]]		#endif// ABD JAN95void V_Pane::VInvalidate()	{	Rect r;	UnsetPane();    SetPane();#if MACINTOSH	r = dataRect;		InvalRect(&r);#elif WINDOWS	InvalidateRect(paneWindow,NULL,FALSE);#endif	UnsetPane();	}//JAM TXTRFIDDLE 06/14/94 ]]]		void V_Pane::SetPane()	{	Rect data;	if(outputOn)return;	if(currentPane==this)			return; // This happens when (for some reason) the programmer calls SetPane() explicitly	if(currentPane!=NULL)		currentPane->UnsetPane();	SetCurrentPane(this);	data=dataRect;	ObjLock((ObjectHandle)this);	#if MACINTOSH	if(!outputOn)theWindow->SetWPort();	SetOrigin(-paneRect.left,-paneRect.top);	VForeColor(&vBlack);	VBackColor(&vWhite);#elif WINDOWS	if(paneWindow)		{		if(doingPaint)metaPort=BeginPaint(paneWindow,&ps);		else metaPort = VGetDC(paneWindow);		SetGraphicContext(metaPort);		SetDisplayPort();		}#endif //WINDOWS		VClipRect(&data);	xOrigin=0;	yOrigin=0;	}void V_Pane::UnsetPane()	{	if(currentPane!=this)return;#if WINDOWS	if(paneWindow&&metaPort)		{		UnsetDisplayPort();		if(doingPaint){EndPaint(paneWindow,&ps);/* doingPaint = FALSE;*/}		else VReleaseDC(paneWindow,metaPort);		metaPort = NULL;		SetGraphicContext(NULL);		}#endif //WINDOWS	SetCurrentPane(NULL);	ObjUnlock((ObjectHandle)this);#if MACINTOSH	WindowPane();#endif //MACINTOSH	}	void V_Pane::WindowPane()	{	Rect r;#if MACINTOSH	if(!theWindow)return;	if(!outputOn)		{		theWindow->SetWPort();		theWindow->GetRect(&r);		SetOrigin(0,0);		VClipRect(&r);		}#elif WINDOWS	if(NULL == currentDevice) return;#endif //WINDOWS	VSetPattern(vPatBlack);	VPenMode(vPatCopy);	VTextMode(vSrcOr);	VSetFont(vSystemFont,vSystemFontSize,vNormal);	VForeColor(&vBlack);	VBackColor(&vWhite);	}	void V_Pane::ClipPane(int inset)	{	Rect r;		r=paneRect;#if MACINTOSH	if(!outputOn)theWindow->SetWPort();	SetOrigin(0,0);#endif //MACINTOSH	VInsetRect(&r,inset,inset);	VClipRect(&r);	}	void V_Pane::Activate()	{	Rect r;	active=TRUE;	PaneDepth();	SetPane();	itemList->Activate(TRUE);	UnsetPane();	if(scrollBarFlag & VERTSCROLLBAR)VertScroll->Activate(TRUE);	if(scrollBarFlag & HORZSCROLLBAR)HorzScroll->Activate(TRUE);	if(grayOut)		{#if MACINTOSH		r=paneRect;		InvalRect(&r);#endif //MACINTOSH		}#if WINDOWS	EnableWindow(paneWindow,TRUE);#endif //WINDOWS	}void V_Pane::Deactivate()	{	Rect r;	active=FALSE;	PaneDepth();	SetPane();	itemList->Activate(FALSE);	UnsetPane();	if(scrollBarFlag & VERTSCROLLBAR)VertScroll->Activate(FALSE);	if(scrollBarFlag & HORZSCROLLBAR)HorzScroll->Activate(FALSE);	if(grayOut)		{		r=paneRect;#if MACINTOSH		InvalRect(&r);#endif //MACINTOSH		}#if WINDOWS	EnableWindow(paneWindow,FALSE);#endif //WINDOWS	}int V_Pane::MouseClick(Point p,long modifier)	{	short	ccode;  				/* Location of event in window or controls */	int		result;		WindowPane();	result = 0;#if MACINTOSH	if(VPtInRect(p,&paneRect))		{		if(scrollBarFlag & VERTSCROLLBAR) { if(VertScroll->MouseDown(p, modifier)) result = 2; }		if(!result&&(scrollBarFlag & HORZSCROLLBAR)) { if(HorzScroll->MouseDown(p, modifier)) result = 2; }#endif //MACINTOSH		if(!result)			{			SetPane();			lastPoint=p;		#if MACINTOSH			p.h-=contRect.left;			p.v-=contRect.top;#endif //MACINTOSH			result = 2;			if(!itemList->MouseDown(p, modifier))				{				MouseDown(p,modifier);				result = 1;				}			UnsetPane();			}#if MACINTOSH		}#endif //MACINTOSH	return result;	}void V_Pane::MouseUnclick(Point p,long modifier)	{#if WINDOWS	TrackCursor(p,modifier);#endif //WINDOWS	SetPane();#if MACINTOSH	p.h-=contRect.left;	p.v-=contRect.top;#endif //MACINTOSH	MouseUp(p,modifier);	UnsetPane();	}#if WINDOWSHWND V_Pane::FindControl(DWORD cntrl,int code)	{	return itemList->FindControl(cntrl,code);	}V_Control *V_Pane::FindControlType(int code)	{	return itemList->FindControlType(code);	}/* jca 5APR95 should we always track the cursor in this pane?Used for doing momentum and button up flying */intV_Pane::ContinuousTrack(void) { return(FALSE); }#endif //WINDOWS	void V_Pane::Draw()	{	if((!theWindow) || theWindow->icon ||!theWindow->Visible())return;	PaneDepth();	SizeNotify();	if(active)VDisplay(ACT_REDRAW);	else VDisplay(DEACT_REDRAW);	}	void V_Pane::SetScroll(int disp)	{	long vx,hx;	long height,width;	int hchanged=0,vchanged=0;	Rect r;		int tmn,tmx;		vx = GetVScrollValue();	hx = GetHScrollValue();	if(scrollBarFlag & VERTSCROLLBAR)		{		VertScroll->Activate(TRUE);		height=(long)scrollRect.bottom-scrollRect.top;		SetVScrollRange(scrollRect.top,scrollRect.top+height);		GetVScrollRange(&tmn,&tmx);		if(vx>height+scrollRect.top)			{			vx=height+scrollRect.top;			SetVScrollValue(vx);			vchanged=TRUE;			}		if(vx<scrollRect.top)			{			vx=scrollRect.top;			SetVScrollValue(vx);			vchanged=TRUE;			}		SetVScroll();		}	if(scrollBarFlag & HORZSCROLLBAR)		{		HorzScroll->Activate(TRUE);		width=(long)scrollRect.right-scrollRect.left;		SetHScrollRange(scrollRect.left,scrollRect.left+width);		if(hx>width+scrollRect.left)			{			hx=width+scrollRect.left;			SetHScrollValue(hx);			hchanged=TRUE;			}		if(hx<scrollRect.left)			{			hx=scrollRect.left;			SetHScrollValue(hx);			hchanged=TRUE;			}		SetHScroll();		}	PaneDepth();	SizeNotify();	if(disp)		{		if(active)VDisplay(ACT_REBUILD_DRAW);		else			{			VDisplay(DEACT_REBUILD_DRAW);#if MACINTOSH			if(grayOut)				{				r = dataRect;				PenMode(patBic);				PenPat(&gray);				PaintRect(&r);				PenPat(&black);				PenMode(patCopy);				}#endif //MACINTOSH			}		}	}	/*------------------------------------------------------------------------------ * void V_Pane::StashScrollValues(void); * void V_Pane::RestoreScrollValues(void); * These methods are used to save a panes scrollbar values when the * pane is uninstalled, and to restore them when a pane is installed * (if the pane had previously been uninstalled) * Added by JAM 11/3/93 *------------------------------------------------------------------------------*/voidV_Pane::StashScrollValues(void){	if(scrollBarFlag & VERTSCROLLBAR)	{    	StashVScrollValue = GetVScrollValue();	}	else	{    	StashVScrollValue = 0;    }	if(scrollBarFlag & HORZSCROLLBAR)	{    	StashHScrollValue = GetHScrollValue();	}	else	{    	StashHScrollValue = 0;    }}voidV_Pane::RestoreScrollValues(void){	if(scrollBarFlag & VERTSCROLLBAR)	{    	SetVScrollValue(StashVScrollValue);	}	if(scrollBarFlag & HORZSCROLLBAR)	{    	SetHScrollValue(StashHScrollValue);	}}/*------------------------------------------------------------------------------ * void V_Pane::SetVSpeed(int); * void V_Pane::SetVPage(int); * void V_Pane::SetVMove(int); * void V_Pane::SetVScrollValue(int); * void V_Pane::SetHSpeed(int); * void V_Pane::SetHPage(int); * void V_Pane::SetHMove(int); * void V_Pane::SetHScrollValue(int); * These methods are used to control the rate and amount of scrolling.  See the * V_Control manager for more info. *------------------------------------------------------------------------------*/void V_Pane::SetVSpeed(int speed)	{	if((scrollBarFlag & VERTSCROLLBAR)&&theWindow)		VertScroll->SetSpeed(speed);	}	void V_Pane::SetVPage(int pg)	{	if((scrollBarFlag & VERTSCROLLBAR)&&theWindow)		VertScroll->SetPage(pg);	}	void V_Pane::SetVMove(int mv)	{	if((scrollBarFlag & VERTSCROLLBAR)&&theWindow)		VertScroll->SetMove(mv);	}void V_Pane::SetVScrollValue(int val)	{	if((scrollBarFlag & VERTSCROLLBAR)&&theWindow)		VertScroll->SetValue(val);	}int V_Pane::GetVScrollValue()	{	int val;	val = ((scrollBarFlag & VERTSCROLLBAR)&&theWindow)?VertScroll->GetValue():0;	return val;	}voidV_Pane::SetVScrollRange(int hMin,int hMax)	{	if((scrollBarFlag & VERTSCROLLBAR)&&theWindow)		VertScroll->SetRange(hMin,hMax);	}void V_Pane::GetVScrollRange(int *hMin,int *hMax)	{	if((scrollBarFlag & VERTSCROLLBAR)&&theWindow)		VertScroll->GetRange(hMin,hMax);	else { *hMin = *hMax = 0; }	}	void V_Pane::SetHSpeed(int speed)	{	if((scrollBarFlag & HORZSCROLLBAR)&&theWindow)		HorzScroll->SetSpeed(speed);	}	void V_Pane::SetHPage(int pg)	{	if((scrollBarFlag & HORZSCROLLBAR)&&theWindow)		HorzScroll->SetPage(pg);	}void V_Pane::SetHMove(int mv)	{	if((scrollBarFlag & HORZSCROLLBAR)&&theWindow)		HorzScroll->SetMove(mv);	}	void V_Pane::SetHScrollValue(int val)	{	if((scrollBarFlag & HORZSCROLLBAR)&&theWindow)		HorzScroll->SetValue(val);	}int V_Pane::GetHScrollValue()	{	int val;	val = ((scrollBarFlag & HORZSCROLLBAR)&&theWindow) ? HorzScroll->GetValue():0;	return val;	}void V_Pane::SetHScrollRange(int hMin,int hMax)	{	if((scrollBarFlag & HORZSCROLLBAR)&&theWindow)		HorzScroll->SetRange(hMin,hMax);	}void V_Pane::GetHScrollRange(int *hMin,int *hMax)	{	if((scrollBarFlag & HORZSCROLLBAR)&&theWindow)		HorzScroll->GetRange(hMin,hMax);	else { *hMin = *hMax = 0; }	}	/*------------------------------------------------------------------------------ * void V_Pane::DoHand(Point pt) * * This method allows the user to move the virtual data around on the pane by * grabbing it with the mouse and dragging it.  The scroll bars move * appropriately. *------------------------------------------------------------------------------*/void V_Pane::DoHand(Point pt)	{	Point newPt;	int v=0,h=0;	int vmax=0,hmax=0;	int vmin=0,hmin=0;	Rect r;		r = dataRect;		if(scrollBarFlag & HORZSCROLLBAR)	GetVScrollRange(&vmin,&vmax);	GetHScrollRange(&hmin,&hmax);	while(VButton())		{		WindowPane();		VGetMouse(&newPt);		if(pt.h!=newPt.h || pt.v!=newPt.v)			{			if(VPtInRect(newPt,&r))				{				if(scrollBarFlag & VERTSCROLLBAR)					{					v=GetVScrollValue();					v-=newPt.v-pt.v;					if(v<vmin)v=vmin;					if(v>vmax)v=vmax;					SetVScrollValue(v);					}				if(scrollBarFlag & HORZSCROLLBAR)					{					h=GetHScrollValue();					h-=newPt.h-pt.h;					if(h<hmin)h=hmin;					if(h>hmax)h=hmax;					SetHScrollValue(h);					}				pt=newPt;				SetPane();				Display(SCROLL_DRAW,h,v);				UnsetPane();				}			}		}	UnsetPane();	}int V_Pane::Push(int dh,int dv)	{	int v=0,h=0,oldv=0,oldh=0;	int vmax=0,hmax=0;	int vmin=0,hmin=0;	int result=0;	Rect r;				CalcScroll();	SetScroll(FALSE);	if(scrollBarFlag & VERTSCROLLBAR)		{		v = GetVScrollValue();		if(dv)			{			oldv = v;			GetVScrollRange(&vmin,&vmax);/*MJU 6/25/92 */			v-=dv;			if(v<vmin)v=vmin;			if(v>vmax)v=vmax;			}		}	if(scrollBarFlag & HORZSCROLLBAR)		{		h = GetHScrollValue();		if(dh)			{			oldh=h;			GetHScrollRange(&hmin,&hmax);/*MJU 6/25/92 */			h-=dh;			if(h<hmin)h=hmin;			if(h>hmax)h=hmax;			}		}			if(dv && oldv==v)result|=1;	if(dh && oldh==h)result|=2;	if(!result)		{		if(dh && h!=oldh)SetHScrollValue(h);		if(dv && v!=oldv)SetVScrollValue(v);		VDisplay(SCROLL_DRAW);		}	return result;	}void V_Pane::MovePane(int hloc,int vloc,int scrollFlag)	{	Rect	r;	int v,h;	int vmax,hmax;	int vmin,hmin;		GetVScrollRange(&vmin,&vmax);/* MJU 6/25/92 */	GetHScrollRange(&hmin,&hmax);/* MJU 6/25/92 */		SetPane();	if(scrollBarFlag & VERTSCROLLBAR)		{		v=vloc;		if(v<vmin)v=vmin;		if(v>vmax)v=vmax;		SetVScrollValue(v);		}	if(scrollBarFlag & HORZSCROLLBAR)		{		h=hloc;		if(h<hmin)h=hmin;		if(h>hmax)h=hmax;		SetHScrollValue(h);		}	UnsetPane();	if(scrollFlag)  VDisplay(scrollFlag);	else VDisplay(SCROLL_DRAW);	}void V_Pane::TrackCursor(Point p, long modifier)	{	int insideCont;	if(!theWindow)return;// DAS-VWINDOW-FIX 9/7/93#if MACINTOSH	insideCont=VPtInRect(p,&contRect);	if((!insideCont) && VPtInRect(p,&paneRect))VSetCursor(vCursorArrow);	p.h-=contRect.left;	p.v-=contRect.top;#elif WINDOWS	insideCont=VPtInRect(p,&dataRect);#endif //WINDOWS	SetPane();	Track(p,modifier,insideCont);#if MACINTOSH	// DAS-VWI 8/9/93	if(!(modifier&buttonDown) && insideCont)	// DAS-VWINDOW-BABBOON HELP FIX 10/14/93		TrackHelp(p,modifier);// DAS-VWINDOW 9/30/93#elif WINDOWS	if (!(modifier&buttonDown))   // ELVIS		TrackHelp(p, modifier);// DAS-VWINDOW 9/30/93#endif //MACINTOSH#if VR	else		VWIMessage("");//DAS-VWI-10/15/93#endif // VR	UnsetPane();	}	int V_Pane::GrowRectCalc(Rect *r,Point *p,int flag,int sizeWarn)	{	Rect wRect;		wRect=*r;	CalcSize(r,p,flag,sizeWarn);	if(wRect.right==r->right&&wRect.bottom==r->bottom)return(TRUE);	else return(FALSE);	}void V_Pane::CalcDataRect()	{	Rect wR;		WindowPane();	dataRect.top=dataRect.left=0;	#if MACINTOSH	theWindow->GetRect(&wR);	if((scrollBarFlag & HORZSCROLLBAR) && wR.bottom!=paneRect.bottom)		dataRect.bottom=(contRect.bottom-contRect.top)-1;	else dataRect.bottom= contRect.bottom-contRect.top;		if((scrollBarFlag & VERTSCROLLBAR) && wR.right!=paneRect.right)		dataRect.right=(contRect.right-contRect.left)-1;	else dataRect.right= contRect.right-contRect.left;#elif WINDOWS	dataRect.right=paneRect.right-paneRect.left;	dataRect.bottom=paneRect.bottom-paneRect.top;#endif //WINDOWS		centerX=(dataRect.right+dataRect.left)>>1;	centerY=(dataRect.bottom+dataRect.top)>>1;	}void V_Pane::Reset()	{	Rect vRect,r;	int xSize,ySize,sizeWarn;		if (theWindow)		{		theWindow->GetRect(&r);		xSize=r.right-r.left;		ySize=r.bottom-r.top;		sizeWarn=ySize<theWindow->warnSize.v || xSize<theWindow->warnSize.h;		sizeWarn = FALSE;		vRect=virtRect;		GetVirtual(&vRect);		virtRect=vRect;		#if MACINTOSH		{		RgnHandle gatherRgn;	VGrafPort 		savePort;		// ABD MERGE-GOURAUD-PRO-4	VGrafDevice 	saveDevice;		// ABD MERGE-GOURAUD-PRO-4		gatherRgn=NewRgn();	VGetPort(&savePort,&saveDevice);		// ABD MERGE-GOURAUD-PRO-4		Resize(gatherRgn,sizeWarn);		InvalRgn(gatherRgn);	VSetPort(savePort,saveDevice);		// ABD MERGE-GOURAUD-PRO-4		DisposeRgn(gatherRgn);		}#elif WINDOWS		Resize(sizeWarn);		InvalidateRect(paneWindow,NULL,FALSE);#endif //WINDOWS		}	}void V_Pane::SetBarWidth(int wdth)	{	barWidth=wdth;	if(theWindow)Reset();	}/*------------------------------------------------------------------------------ * void V_Pane::Display(int scroll,int h,int v){} * * scroll==ACT_DRAW 	simple redraw of contents * scroll==DEACT_DRAW	deactivate scroll * scroll==ACT_REDRAW * scroll==DEACT_REDRAW * scroll==DRAW			complete redraw of contents * scroll==SCROLL_DRAW 	simple scroll of contents * scroll==ACT_REBUILD_DRAW	scroll and redraw of contents * scroll==DEACT_REBUILD_DRAW scroll and redraw of contents inactivate state *------------------------------------------------------------------------------*/void V_Pane::Display(int scroll,int h,int v) { itemList->Display(); }void V_Pane::CalcSize(Rect *r,Point *p,int flag,int sizeWarn) {}void V_Pane::SizeNotify(void) {}void V_Pane::MouseDown(Point pt,long modifier)	{#if MACINTOSH	LocalToGlobal(&pt);	theWindow->Drag(pt);#endif //MACINTOSH	}void V_Pane::MouseUp(Point pt,long modifier) { }int V_Pane::KeyAction(char ch,long modifier) { return(FALSE); }#if WINKEYBOARDVAVIGATION		//JAM-WINDOWS-KEYBOARD-NAVIGATION [[[int V_Pane::KeyUpAction(char ch,long modifier) { return(FALSE); }#endif //WINKEYBOARDVAVIGATION	//JAM-WINDOWS-KEYBOARD-NAVIGATION ]]]int V_Pane::GetAction(long message,long modifier){return(FALSE);}void V_Pane::Track(Point pt,long modifier,int inside)	{	if (!inside) return;	if(itemList->Track(pt, modifier))return; 	}void V_Pane::GetVirtual(Rect *r) { *r=virtRect; }void V_Pane::CalcScroll()	{	Rect sizingRect;	// BUGBUG - changed sizing for scrollbar for dragging on macintosh!#if WINDOWS	sizingRect = dataRect;#elif MACINTOSH	sizingRect = contRect;#endif //WINDOWS	scrollRect=virtRect;		scrollRect.bottom-=(sizingRect.bottom-sizingRect.top);	if(scrollRect.bottom<scrollRect.top)		scrollRect.bottom=scrollRect.top;	scrollRect.right-=(sizingRect.right-sizingRect.left);	if(scrollRect.right<scrollRect.left)		scrollRect.right=scrollRect.left;	}void V_Pane::GetRect(Rect *pr)	{	Rect r;	Point p;	int sizeWarn;		theWindow->GetRect(&r);	sizeWarn=(r.bottom-r.top)<theWindow->warnSize.v||			 (r.right-r.left)<theWindow->warnSize.h;    sizeWarn=FALSE;	p.h=GetHScrollValue();	p.v=GetVScrollValue();	CalcSize(&r,&p,GETRECT,sizeWarn);	*pr=r;	}	// { DAS-VDRAG 9/3/93int V_Pane::OKDrop(V_Pane* pane){ return FALSE; }void V_Pane::Drop(Point pt, V_Pane *pane){/* do nothing */ }// } DAS-VDRAG 9/3/93// { DAS-VDRAG 9/4/93/*	the Drag method queries all panes that are being dragged on top of, including	unhilited ones. This allows us to drag into any window we want. To use this,	you need to only create a drag object, (see above), and for any pane that	might be interested in using the data from this object, simply derive	OKDrop to return TRUE if it is the correct V_Pane type. If the object is released	on top of this pane, the Drop method will be called, and the pane can pull out	the V_Pane object to get to the data.*/// { DAS-VDRAG-WINFIX 10/15/93  this has been substantially redone for Windowsvoid V_Pane::Drag(void)	{	Point pt,opt,ppt;	Rect wRect;	V_Offscreen *theScreen;	VGrafPort		wPort;// DAS-VWINDOW-FIX 9/17/93 	V_Pane *thePane=0L; // DAS-VDRAG-FIX 9/5/93	V_Document *doc;   // DAS-VDRAG-FIX 10/15/93#if MACINTOSH	WindowPtr whichWindow;	RgnHandle	saveRgn,grayRgn; // DAS-VWINDOW-FIX 9/26/93	short code;#elif WINDOWS	HWND whichWindow,w;    MSG	winMsg;	HDC dc;            // DAS-VDRAG-FIX 10/15/93    POINT wpt;         // DAS-VDRAG-FIX 10/15/93	HBRUSH	origBrush, dispBrush;  	// jca 12AUG94 VR1.0.1  resource leak jam 6OCT94	HPEN	origPen, dispPen;     	// jca 12AUG94 VR1.0.1  resource leak jam 6OCT94#endif	V_Window *theWindow;    VGrafDevice	mainDev;	UnsetPane();#if MACINTOSH	mainDev = GetMainDevice();#elif WINDOWS	mainDev = NULL;#endif // MACINTOSH// { DAS-VWINDOWS-FIX 9/17/93#if MACINTOSHGetWMgrPort(&wPort);SetPort(wPort);if(saveRgn=NewRgn())GetClip(saveRgn); // DAS-VWINDOWS-FIX 9/26/93grayRgn=GetGrayRgn(); // DAS-VWINDOW-FIX 9/26/93SetClip(grayRgn); // DAS-VWINDOW-FIX 9/26/93#elif WINDOWS// { DAS-VDRAG-FIX 10/15/93	dc=GetDC(NULL);	// jca 12AUG94 VR1.0.1 JAM 6OCT94 resource leak.  It is best if we discard the	// device context 'dc' with its original pen and brush.  So, we save	// them and substitute these simple ones.  The origPen and origBrush	// will be selected back into the dc just before it is destroyed.	dispPen = NULL;   // don't accidently use them    dispBrush = NULL;		origPen = SelectObject(dc, CreatePen(PS_SOLID, 2, RGB(0,0,0)));	origBrush = SelectObject(dc, CreateSolidBrush(RGB(255,255,255)));	SetGraphicContext(dc);// } DAS-VDRAG-FIX 10/15/93#endif// } DAS-VWINDOWS-FIX 9/17/93	#if WINDOWS//	PostMessage(paneWindow,WM_MOUSEMOVE,0,0L);	if (PeekMessage(&winMsg, NULL, WM_LBUTTONDOWN, WM_LBUTTONDOWN,PM_NOREMOVE))		{		pt.h = LOWORD(winMsg.lParam); // where is the cursor?		pt.v = HIWORD(winMsg.lParam); // where is the cursor?		if(IsWindow(winMsg.hwnd))        	{			GetWindowRect(winMsg.hwnd,&wRect);			pt.h+=wRect.left;			pt.v+=wRect.top;            }		}	else    	{pt.h = pt.v = 0;}#elif MACINTOSH	GetMouse(&pt);#endif  // WINDOWS	opt=pt;	DrawMarquee(TRUE);	DisplayDrag(pt);	#if MACINTOSH	while(Button())		{		GetMouse(&pt); // where is the cursor?		code = FindWindow(pt, (WindowPtr *)&whichWindow);		if(whichWindow)			{			theWindow=(V_Window *)GetWRefCon((GrafPtr)whichWindow);			theWindow->Locate(&wRect);			ppt.v=pt.v-wRect.top;			ppt.h=pt.h-wRect.left;			thePane=theWindow->FindPane(ppt);			if(thePane)				{				if(thePane==this){VSetCursor(vCursorArrow); thePane=NULL;} // DAS-VWINDOWS-FIX 9/29/93				else if(thePane->OKDrop(this))VSetCursor(vCursorArrow);				else {VSetCursor(vCursorNO); thePane=NULL;}// DAS-VWINDOWS-FIX 9/29/93				}			else VSetCursor(vCursorNO);			}		else			{			VSetCursor(vCursorNO);// DAS-VWINDOWS-FIX 9/29/93			thePane=NULL;			}#elif WINDOWS// { DAS-VDRAG 10/23/93	while(!(PeekMessage(&winMsg, NULL, WM_LBUTTONUP, WM_LBUTTONUP,PM_NOREMOVE)))		{		Rect 	winRect;		PeekMessage(&winMsg, NULL, WM_MOUSEMOVE, WM_MOUSEMOVE,PM_NOREMOVE);		pt.h = LOWORD(winMsg.lParam); // where is the cursor?		pt.v = HIWORD(winMsg.lParam); // where is the cursor?		if(IsWindow(winMsg.hwnd))        	{			GetWindowRect(winMsg.hwnd,&wRect);			pt.h+=wRect.left;			pt.v+=wRect.top;            }		whichWindow = NULL;		if (doc)			{			HINSTANCE   wI;            // using screen coordinates, find the window			wpt.x=pt.h;            wpt.y=pt.v;			whichWindow=WindowFromPoint(wpt);			if(whichWindow)wI=GetWindowTask(whichWindow);			else wI=NULL;			if(whichWindow && GetWindowTask(whichWindow)==GetCurrentTask())				{				POINT lpt;				char wclass[32];                w=whichWindow;				do	{					whichWindow=w;					lpt=wpt;                    ScreenToClient(whichWindow,&lpt);					w=ChildWindowFromPoint(whichWindow,lpt);					}while(whichWindow!=w && w!=0);//				HW(whichWindow);				GetClassName (whichWindow, wclass, sizeof(wclass));				if (strcmp (wclass, paneClassName) == 0)                	{					thePane = (V_Pane *)GetWindowLong(whichWindow,0);					if(thePane==this){VSetCursor(vCursorArrow); thePane=NULL;} // DAS-VWINDOWS-FIX 9/29/93					else if(thePane->OKDrop(this))VSetCursor(vCursorArrow);					else {VSetCursor(vCursorNO); thePane=NULL;}// DAS-VWINDOWS-FIX 9/29/93					}				else {thePane=NULL; VSetCursor(vCursorNO); }    				}			else {thePane=NULL; VSetCursor(vCursorNO); }			}	SetGraphicContext(dc);// } DAS-VDRAG 10/23/93#endif// } DAS-VWINDOWS-FIX 9/29/93		if(pt.h==opt.h && pt.v==opt.v)// the object has not moved			{			DrawMarquee(FALSE);			DisplayDrag(pt); // this moves the ants one step ahead			}		else // the object has moved			{			DrawMarquee(TRUE);			DisplayDrag(opt); // this erases the object			DisplayDrag(pt);	// this draws it in the new position			opt=pt;			}		}	DrawMarquee(TRUE);	// the final erase	DisplayDrag(pt);#if WINDOWS	VSetPenNormal();	// select the original brush and pen into the device context, so we can avoid leaking	// resources. jca 12AUG94 JAM 6OCT94 VR1.0.1	dispBrush = SelectObject(dc, origBrush);	dispPen = SelectObject(dc, origPen);	DeleteObject(dispBrush);    // destroy the brush/pen we created.	DeleteObject(dispPen);      	ReleaseDC(NULL,dc);#endif	if(thePane && thePane!=this)		{#if MACINTOSH   // DAS-BUGFIX 10/7/93		VSetPort(thePane->theWindow->theWindow,0L);		SetOrigin(0,0);		GlobalToLocal(&pt);				pt.h-=thePane->contRect.left;		pt.v-=thePane->contRect.top;#endif // MACINTOSH// DAS-VWINDOWS-FIX 9/17/93 removed screen references		thePane->SetPane();#if WINDOWS		GlobalToLocal(&pt);#endif		thePane->Drop(pt, this);		thePane->UnsetPane();		}		// { DAS-VWINDOWS-FIX 9/17/93#if MACINTOSH	SetPort(wPort); // Reset the screen to normal	if(saveRgn)SetClip(saveRgn); // DAS-VWINDOWS-FIX 9/26/93	DisposeRgn(saveRgn); // DAS-VWINDOWS-FIX 9/26/93	PenNormal();#elif  WINDOWS//	VSetPenNormal();//	theScreen->UnsetMetaPort();#endif	// } DAS-VWINDOWS-FIX 9/17/93	SetPane();	}// } DAS-VDRAG-WINFIX 10/15/93  this has been substantially redone for Windowsvoid V_Pane::DisplayDrag(Point pt)	{	Rect r;		r.top=pt.v-25;	r.bottom=pt.v+25;	r.left=pt.h-25;	r.right=pt.h+25;	VFrameRect(&r);	VMoveTo(r.left,r.top);	VLineTo(r.right,r.bottom);	VMoveTo(r.left,r.bottom);	VLineTo(r.right,r.top);	}// } DAS-VDRAG 9/4/93/*------------------------------------------------------------------------------ * void V_Pane::SetVScroll() * void V_Pane::SetHScroll() * Recalculate the scroll rate data. *------------------------------------------------------------------------------*/void V_Pane::SetVScroll()	{	int pg;		pg=(paneRect.bottom-paneRect.top)>>1;#if MACINTOSH	VertScroll->SetPage(pg);	VertScroll->SetMove(2);#endif //MACINTOSH	}void V_Pane::SetHScroll()	{	int pg;		pg=(paneRect.bottom-paneRect.top)>>1;#if MACINTOSH	HorzScroll->SetPage(pg);	HorzScroll->SetMove(2);#endif //MACINTOSH	}	VGrafDataV_Pane::GetMetaPort(Rect *r)	{	VGrafData data;#if MACINTOSH	data = theWindow->GetMetaPort(r);#elif WINDOWS	GetRect(r);	data = metaPort;#endif //WINDOWS	return data;	}voidV_Pane::ReleaseMetaPort(VGrafData data)	{#if MACINTOSH	theWindow->ReleaseMetaPort(data);#endif //MACINTOSH	}	/*------------------------------------------------------------------------------ * void V_Pane::SetMetaPort() * set offscreen port to be drawn into		 *------------------------------------------------------------------------------*/// DAS-VWINDOWS-FIX 9/17/93 returns an intint V_Pane::SetMetaPort()		{	Rect r,or;	RGBColor		*col;	VGrafPort 		savePort;	VGrafDevice 	saveDevice;		r=dataRect;	if(!outputOn)#if MACINTOSH		{		if(popup&POPUPDIALOG)/* DAS modified 7/2/90 */			{			if(offscreen==0 || offscreen->GetRefCon()!=-1L)				{				if(offscreen)offscreen->dOffscreen();				r=paneRect;				col = NULL;				offscreen=new(V_Offscreen);				if(offscreen->cOffscreen(&r,-1,col,NULL)) 					{					delete(offscreen);					offscreen=0;					}				else					{					offscreen->SetRefCon(-1L);					offscreen->SetMetaPort();					}				}			else offscreen->SetMetaPort();			SetOrigin(0,0);			inOffScreen=TRUE;			currentscreen=offscreen;			}		else			theWindow->SetMetaWin(-paneRect.left,-paneRect.top,&r);// DAS-VWIN 9/17/93		}#elif WINDOWS		{		V_Display *aDisplay,*bDisplay;		VGrafPort	realWindow;		Rect bounds;		realWindow = paneWindow;		bDisplay = this;		aDisplay = (offscreen)?(V_Display *)offscreen->GetRefCon():NULL;		GetRect(&bounds);		if(offscreen==NULL)			{			offscreen=new(V_Offscreen);			if(offscreen->cOffscreen(&bounds,-1,NULL,NULL)) 				{				delete(offscreen);				offscreen=NULL;				}			}		else			{			offscreen->GetRect(&or);//if(theWindow->offFlag)||(aDisplay!=bDisplay))			if((or.right-or.left)!=(bounds.right-bounds.left)				||(or.bottom-or.top)!=(bounds.bottom-bounds.top))				offscreen->Resize(&bounds, RESIZE_STANDARD);			}							if(offscreen) offscreen->SetRefCon((long)bDisplay);		else VSetPort(realWindow,NULL);		if(offscreen)			{			theWindow->offFlag=FALSE;			offscreen->SetMetaPort();			currentscreen=offscreen;			offscreen->SetClip(&r);			}		}					VGetPort(&savePort,&saveDevice);	itemList->SetDisplay(savePort);#endif //MACINTOSH	VClipRect(&r);	return 0;//  DAS-VWINDOWS-FIX 9/17/93 returns a value	}voidV_Pane::UnsetMetaPort()	{	VGrafPort 	savePort;	VGrafDevice 	saveDevice;		if(outputOn)return;	inOffScreen=FALSE;	if(offscreen) offscreen->UnsetMetaPort();	//본본본본본본 WHAT THE HELL IS THIS FOR????? VGetPort(&savePort,&saveDevice);	//본본본본본본 WHAT THE HELL IS THIS FOR????? itemList->SetDisplay(savePort);		currentscreen=NULL;	}/*------------------------------------------------------------------------------ * void V_Pane::MetaCopy(Rect *r) * copy offscreen to onscreen (if necessary)	 *------------------------------------------------------------------------------*/V_Offscreen *popScrn;void V_Pane::MetaCopy(Rect *r)			{	if(outputOn)return;#if MACINTOSH	if(popup&POPUPDIALOG)offscreen->MetaTo(popScrn,r,r);	else theWindow->MetaCopy(r);#elif WINDOWS	if(offscreen)		{		V_Display *aDisplay,*bDisplay;		bDisplay = this;		aDisplay=(V_Display *)offscreen->GetRefCon();		if(aDisplay==bDisplay)offscreen->MetaTo(bDisplay,r,r);		}#endif //WINDOWS	}void V_Pane::SetText(V_EditText *newText)	{#if MACINTOSH	int wrongPane;	if (theWindow->activeText && theWindow->activeText != newText)		{		wrongPane = (theWindow->activeText->thePane != this);		if (wrongPane)			{			UnsetPane();			theWindow->activeText->thePane->SetPane();			}		theWindow->activeText->Activate(0); 		if (wrongPane)			{			theWindow->activeText->thePane->UnsetPane();			SetPane();			}		}	theWindow->activeText = newText;	if(newText) newText->Activate(TRUE);#elif WINDOWS	if (newText)		newText->SetSelect(0, -1);  // jca.  This sets the text up right.#endif //MACINTOSH	}V_EditText *V_Pane::GetText()	{#if MACINTOSH	return(theWindow->activeText); #elif WINDOWS	return(NULL);	// jca 10JAN93 return *something*#endif //MACINTOSH	}void V_Pane::PopUp(Point pt,int border,Rect *toAvoid)	{	V_Window *w;	VGrafPort hwnd;    V_Document *doc;	SavePaneData spData;    V_Pane *oldPane;	VGrafPort 	savePort;	VGrafDevice 	saveDevice,screenDC; 	Rect  cTo;	VGrafData	toPort;	Point oPt,p = {0,0};	Rect sRect;	Rect rloc;	V_Offscreen *popBG;	Rect bgRect;	Rect popRect,rpad;	RGBColor	*col;#if MACINTOSH	RgnHandle saveClip;	extern RGBColor offColor[]; // DAS-VBUTTON 8/13/93	EventRecord	myEvent;#endif //MACINTOSH	spData.dataRect=dataRect;	spData.paneRect=paneRect;	spData.contRect=contRect;	spData.centerX=centerX;	spData.centerY=centerY;	VGetPort(&savePort,&saveDevice);	col = NULL;#if MACINTOSH	if(!VButton())		{		popup = FALSE;		// just copy later error handlers //GJR 12/22/93		return; /* don't even bother if we are not in the right state*/        }	if(offscreen==NULL)                  // copy WINDOWS, try to recover //GJR 12/22/93		{		Rect rect;		rect.top = 0;     // arbitrary small size		rect.left = 0;		rect.right = 32;        rect.bottom = 32;		offscreen=new(V_Offscreen);		if (!offscreen)        	{				VPlaySound(beepSound);				popup=FALSE;				return;            }		if(offscreen->cOffscreen(&rect,-1,col,NULL))			{			delete(offscreen);            offscreen = NULL;			VPlaySound(beepSound);			popup=FALSE;			return;			}		}	popScrn=FindScreen(pt);/* find the screen that the point is on*/	if (popScrn == 0)		{		pt.h = toAvoid->left;		popScrn=FindScreen(pt);		}	if (popScrn == 0)		{		pt.v = toAvoid->bottom;		popScrn=FindScreen(pt);		}	if (popScrn == 0)		{		pt.h = toAvoid->right;		popScrn=FindScreen(pt);		}		popScrn->GetRect(&sRect);	popScrn->SetMetaPort();	saveClip=NewRgn();	GetClip(saveClip);	popScrn->UnsetMetaPort();	popRect=sRect;	popup=POPUPDIALOG;	p.h=GetHScrollValue();	p.v=GetVScrollValue();	depth=popScrn->GetDepth();	CalcSize(&popRect,&p,POPUP,FALSE);	/*sizeWarn flag doesn't mean anything here*/	paneRect.bottom=(popRect.bottom-popRect.top)+pt.v;	paneRect.right=(popRect.right-popRect.left)+pt.h;	paneRect.top=pt.v;	paneRect.left=pt.h;	if(-1==offscreen->GetRefCon())		offscreen->SetRefCon(0);/*insure that this offscreen is new*/	FitRect(&paneRect,&sRect);		bgRect.top=bgRect.left=0;	bgRect.bottom=popRect.bottom-popRect.top;	bgRect.right=popRect.right-popRect.left;		rpad.top=paneRect.top-4;	rpad.left=paneRect.left-4;	rpad.bottom=paneRect.bottom+5;	rpad.right=paneRect.right+5;	contRect=paneRect;	PaneDepth();	SizeNotify();	rloc=rpad;	rloc.right-=rloc.left;	rloc.bottom-=rloc.top;	rloc.left=rloc.top=0;		popBG=new(V_Offscreen);	if(popBG->cOffscreen(&rloc,-1,col,NULL))		{		delete(popBG);		VPlaySound(beepSound);		popup=FALSE;		return;		}	VHideCursor();	popBG->ToMeta(popScrn,&rpad,&rloc);	VShowCursor();	popScrn->SetMetaPort();	rpad.left++;	rpad.top++;	if(border)/* do you want a base on the popup pane?*/		{		if(depth>2&&colorButton)TallColorButton(&rpad,offColor);		else 			{			rpad.right--;			rpad.bottom--;			MonoButton(&rpad,0);			VMoveTo(rpad.left,rpad.bottom);			VLineTo(rpad.right,rpad.bottom);			VLineTo(rpad.right,rpad.top);			rpad.right++;			rpad.bottom++;			}		}	SetOrigin(-paneRect.left,-paneRect.top);	dataRect=paneRect;	dataRect.right-=dataRect.left;	dataRect.bottom-=dataRect.top;	dataRect.left=dataRect.top=0;	centerX=(dataRect.right-dataRect.left)>>1;	centerY=(dataRect.bottom-dataRect.top)>>1;	dataRect.left--;	dataRect.top--;	VClipRect(&dataRect);	dataRect.left++;	dataRect.top++;	currentPane=this;	Display(DRAW,0,0);	popScrn->UnsetMetaPort();	do	{		popScrn->SetMetaPort();		EventAvail(everyEvent, &myEvent);		myEvent.where.h-=paneRect.left;		myEvent.where.v-=paneRect.top;		Track(myEvent.where,myEvent.modifiers,TRUE);		popScrn->UnsetMetaPort();		}while(VButton());	currentPane=0;	popScrn->SetMetaPort();	SetOrigin(0,0);	SetClip(saveClip);	DisposeRgn(saveClip);	VHideCursor();	rpad.top--;	rpad.left--;	popBG->MetaTo(popScrn,&rloc,&rpad);	popScrn->UnsetMetaPort();	VShowCursor();	popBG->dOffscreen();#elif WINDOWS	oPt = pt; //	ClientToScreen(currentPane->paneWindow,(LPPOINT)&pt);	LocalToGlobal(&pt);	SendMessage(currentPane->paneWindow,WM_LBUTTONUP,0,MAKELPARAM(oPt.h,oPt.v));	oldPane = currentPane;	if(oldPane)oldPane->UnsetPane();	if(offscreen==NULL)                  //  try to recover //GJR 12/22/93		{		Rect rect;		rect.top = 0;     // arbitrary small size		rect.left = 0;		rect.right = 32;		rect.bottom = 32;		offscreen=new(V_Offscreen);		if (!offscreen)    		{  // oops, couldn't create an offscreen struct. abort.			VPlaySound(beepSound);			popup=FALSE;           // copied from the MAC popBG			return;        	}		if(offscreen->cOffscreen(&rect,-1,col,NULL))			{   // oops, couldn't init an offscreen object, so kill object.			delete(offscreen);        	offscreen = NULL;			VPlaySound(beepSound);			popup=FALSE;           // copied from the MAC popBG			return;			}		}    ASSERT(offscreen != NULL);	popScrn = offscreen;     // Only if there's an offscreen.... jca 21 Dec 93	popup = POPUPDIALOG;//MODALDIALOG;	GetScreen(&sRect);	p.h=GetHScrollValue();	p.v=GetVScrollValue();	PaneDepth();    	// jca 15 feb 93 to set popup depth and size correctly    popRect = sRect;	   	CalcSize(&popRect,&p,POPUP,FALSE);	/*sizeWarn flag doesn't mean anything here*/	if(border)		{		popRect.left-=border;    	popRect.top-=border;		popRect.right+=(border+1);		popRect.bottom+=(border+1);		}	popRect.top+=pt.v;	popRect.bottom+=pt.v;	popRect.left+=pt.h;	popRect.right+=pt.h;	if (toAvoid == NULL)            // jca is there an avoidance area?		FitRect(&popRect, &sRect);  // force popup to fit within the screen	else                            // jca avoid button area, but fit within the screen		FitAvoidRect(&popRect, &sRect, toAvoid);	w = new(V_Window);	w->cWindow(&popRect,(strPtr)"Pop Up",p,p,p,POPUPDIALOG,WINDOW_DESTROY);	w->Install(this);	w->Show();	VDisplay(DRAW);	// hey!  this makes the color thingie stay up on the screen a la windows application	// PostMessage(paneWindow,WM_LBUTTONDOWN,0,0);	/* ick-o. feh. blort.  This is a really, major uncool place to put	these, but I haven't come up with a good way to sneak them into    the callback routine */	SetCapture(paneWindow);	popCapture = TRUE;	trapState = TRUE;    MainEvent(MODAL);	w->UnInstall(this);	w->Delete();	if(oldPane)		oldPane->SetPane();#endif //WINDOWS	VSetPort(savePort,saveDevice);	dataRect=spData.dataRect;	paneRect=spData.paneRect;	contRect=spData.contRect;	centerX=spData.centerX;	centerY=spData.centerY;	popup=FALSE;#if MACINTOSH	if(theWindow)/*just in case something depended on the warn size*/		{		Rect wR;		theWindow->GetRect(&wR);		p.h=GetHScrollValue();		p.v=GetVScrollValue();		CalcSize(&wR,&p,POPUP,(wR.right-wR.left)<theWindow->warnSize.h ||			(wR.bottom-wR.top)<theWindow->warnSize.v);		PaneDepth();		SizeNotify();		}#endif //MACINTOSH	}/*------------------------------------------------------------------------------ * V_MenuMgr *V_Document::GetMenuMgr() * This routine gives the programmer access to theMenu menu manager object. *------------------------------------------------------------------------------*/V_MenuMgr *V_Pane::GetMenuMgr(){ return theMenu; }/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/voidV_Pane::TrackHelp(Point pt,long modifier) // DAS-VWINDOW 9/30/93	{	}// { DAS-BUGFIX 10/14/93	voidV_Pane::Bubble(Point pt,Rect *hot,char *text)	{ #if MACINTOSH && VWT // BILBIL	HMMessageRecord theHelpMsg;	int i=0;	Point rloc;	if((gIsBalloon && HMGetBalloons() && !HMIsBalloon()))		{		LocalToGlobal(&pt);		rloc.v=hot->top;		rloc.h=hot->left;		LocalToGlobal(&rloc);		hot->top=rloc.v;		hot->left=rloc.h;				rloc.v=hot->bottom;		rloc.h=hot->right;		LocalToGlobal(&rloc);		hot->bottom=rloc.v;		hot->right=rloc.h;				theHelpMsg.hmmHelpType=khmmString;		while(i<255 && (theHelpMsg.u.hmmString[i+1]=text[i]))i++;  // *255*, not 256.  If the string is 256 (or more) bytes long, then we wipe out the stack jca 26APR95		theHelpMsg.u.hmmString[0]=i;		if (gIsBalloon)			HMShowBalloon(&theHelpMsg,pt,hot,NULL,0,6,kHMSaveBitsNoWindow);		}#endif //MACINTOSH && VWT// DAS-VWI 8/9/93#if VRif(IsVWIOn())VWIMessage(text);#endif	}// } DAS-BUGFIX 10/14/93	/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/int V_Pane::VOutput(struct V_Display * output)	{	SavePaneData so;	Rect r;	OSErr err;		SetCurrentPane(this);	if(!(err=output->Begin()))		{		outputOn=output; // DAS-VPRINT-UPDATE 9/17/93 		so.paneRect=paneRect;		so.contRect=contRect;		so.dataRect=dataRect;		so.virtRect=virtRect;		so.scrollRect=scrollRect;		so.vLoc=GetVScrollValue();		so.hLoc=GetHScrollValue();		so.xOrigin=xOrigin;		so.yOrigin=yOrigin;		so.depth=depth;		so.centerX=centerX;		so.centerY=centerY;				output->GetRect(&r);		dataRect=r;		depth=output->GetDepth();		if(!dither && depth<=0)depth--;				centerX=(dataRect.left+dataRect.right)>>1;		centerY=(dataRect.top+dataRect.bottom)>>1;		SizeNotify();		Output(output);		err=output->End();				paneRect=so.paneRect;		contRect=so.contRect;		dataRect=so.dataRect;		virtRect=so.virtRect;		scrollRect=so.scrollRect;		SetVScrollValue(so.vLoc);		SetHScrollValue(so.hLoc);		xOrigin=so.xOrigin;		yOrigin=so.yOrigin;		depth=so.depth;		centerX=so.centerX;		centerY=so.centerY;		SizeNotify();		outputOn=NULL;// DAS-VPRINT-UPDATE 9/17/93		SetPane();		UnsetPane();		if(err)ResultError(err);		}		currentPane=0;	return err;	}void V_Pane::Output(struct V_Display *output)	{	int drawType,x,y;		x=GetHScrollValue();	y=GetVScrollValue();	drawType = output->GetDisplayType();// DAS-VWINDOWS 10/9/93	switch(drawType)		{		case DISPLAY_PRINT: drawType = PRINT_DRAW; break;		case DISPLAY_PICT: drawType = PICT_DRAW; break;		default: break;		}	Display(drawType,x,y);	}void V_Pane::AddItem(V_Item *item) { itemList->AddItem(item); }void V_Pane::RemoveItem(V_Item *item) { itemList->RemoveItem(item); }#if MACINTOSHvoidV_PaneScroll::GetRect(Rect *r)	{ 	*r = bounds;	r->left+=thePane->paneRect.left;	r->right+=thePane->paneRect.left;	r->top+=thePane->paneRect.top;	r->bottom+=thePane->paneRect.top;	}	void V_VertScroll::Action()	{	int hval;		if(thePane->HorzScroll)hval=thePane->GetHScrollValue();	thePane->Display(SCROLL_DRAW,hval,GetValue());	}void V_HorzScroll::Action()	{	int vval;		if(thePane->VertScroll)vval=thePane->GetVScrollValue();	thePane->Display(SCROLL_DRAW,GetValue(),vval);	}#elif WINDOWSvoidV_PaneScroll::cItem()	{	V_Item::cItem();	whichScroll = 0;	SetSpeed(1);	SetMove(1);    SetPage(1);	}void V_PaneScroll::SetSpeed(int sp){ speed = sp; }void V_PaneScroll::SetPage(int p){ page = p; }void V_PaneScroll::SetMove(int m){ step = m; }void V_PaneScroll::SetValue(int val)	{    if(thePane)		SetScrollPos(thePane->paneWindow,whichScroll,val,TRUE);	}int V_PaneScroll::GetValue()	{	int val;	val = (thePane)?GetScrollPos(thePane->paneWindow,whichScroll):0;    return val;	}void V_PaneScroll::SetRange(int minSc,int maxSc)	{	if(thePane)		SetScrollRange(thePane->paneWindow,whichScroll,minSc,maxSc,TRUE);	}void V_PaneScroll::GetRange(int *minSc,int *maxSc)	{    if(thePane)		GetScrollRange(thePane->paneWindow,whichScroll,minSc,maxSc);	else { *minSc = *maxSc = 0; }	}voidV_PaneScroll::DoScroll(int code,int val)	{	HWND hwnd;	int dummy;	hwnd = thePane->paneWindow;	switch(code)		{		case SB_STEPPOS:			val=GetScrollPos(hwnd,whichScroll);			val+=step;			break;		case SB_STEPNEG:			val=GetScrollPos(hwnd,whichScroll);			val-=step;			break;		case SB_PAGEPOS:			val=GetScrollPos(hwnd,whichScroll);			val+=page;			break;		case SB_PAGENEG:			val=GetScrollPos(hwnd,whichScroll);			val-=page;			break;		case SB_THUMBPOSITION:		case SB_THUMBTRACK:			break;		case SB_TOP:			GetScrollRange(hwnd,whichScroll,&val,&dummy);			break;		case SB_BOTTOM:        	GetScrollRange(hwnd,whichScroll,&dummy,&val);			break;		case SB_ENDSCROLL:		default:        	return;        	break;		}	SetScrollPos(hwnd,whichScroll,val,TRUE);	if(code!=SB_THUMBTRACK)		thePane->VDisplay(SCROLL_DRAW);	}voidV_VertScroll::cItem()	{	V_PaneScroll::cItem();    whichScroll = SB_VERT;	}voidV_HorzScroll::cItem()	{	V_PaneScroll::cItem();    whichScroll = SB_HORZ;	}#endif //WINDOWS// MERGE-GOURAUD-PRO-10 [[[#if MACINTOSHint V_Pane::GetType(){	return V_PANE_PANE;}#endif// MERGE-GOURAUD-PRO-10 ]]]