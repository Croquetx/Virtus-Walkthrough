/*------------------------------------------------------------------------------ * VWINDOWSt - the window object toolbox * Version 1.0 * * Copyright c 1989 by Virtus Corporation * All Rights Reserved * Written by David A. Smith * 111 Gold Meadow Drive * Cary, North Carolina    27513 * (919) 469-8485 *------------------------------------------------------------------------------ * V_File.c * The Open method locks the V_File object and then leaves it in this state until * the Close method is called.  This allows all IO methods to operate without the * danger that the V_File object which also contains the parameter blocks will  * move as memory is required. *------------------------------------------------------------------------------*/#include "VTypes.h"#include "VFile.h"#include "VArray.h"#include "VIO.h"#include "VGraphic.h"#include "VDisplay.h"#include "VGUtil.h"#include "VGestalt.h"#include "VDialog.h"#include "VMain.h"#include "VSound.h"#include "VError.h"#include "VTextDef.h"#include "VMemUtil.h"#include "AppFiles.h" //JAM added 23July94#include "AppText.h"	// BILBIL - 13Dec94 - adding walkthru headers here is bad						//                    (V_Windows should not depend on walkthru.)#include <Aliases.h>#include <stdio.h>#include <string.h>#include <ctype.h>#include <Processes.h>// In case we don't have the universal headers...#ifndef NewDlgHookProc	#define NewDlgHookProc(x) (ProcPtr)x#endif#ifndef NewFileFilterProc	#define NewFileFilterProc(x) (ProcPtr)x#endifstrPtr CopyString(strPtr to, strPtr from);strPtr uname=(char *)TXT_UNTITLED_P;/*the default name for the file object*/		// PRO-JAPint _fileCount_ = 1;V_Array *PathName(short vRefNum);int ParsePathName(V_Array *path, long *dirID, short *vRefNum);int ParseRelativePath(V_Array *path1,V_Array *path2,int index,long *dirID,short *vRefNum);typedef char pathMember[33];#define BUFF_SIZE 512/*------------------------------------------------------------------------------ * strPtr CopyString(strPtr to, strPtr from) * Copies the from string into the to string.  It also returns a pointer to * the to string. *------------------------------------------------------------------------------*/strPtr CopyString(strPtr to, strPtr from){	strPtr rval=to;	while( *to++=*from++);	return(rval);}/*------------------------------------------------------------------------------ * int FileCount() * Returns the number of files that the user is requesting to load into the * the system. *------------------------------------------------------------------------------*/int FileCount(){short message,count=0;#ifndef __powercif(_fileCount_)	CountAppFiles(&message,&count);#endif //__powercreturn(count);}/*------------------------------------------------------------------------------ * V_File * The V_File system allows the programmer easy access to the file system.  It * handles such conveniences as GetFile and PutFile dialogs and performs all * of the overhead required in remembering the last loaded or saved file so * that the file will default back to this when required.  Files are always defined * as derived classes with the loadfile() and savefile() methods being redefined. * None of the other methods should ever be touched. *------------------------------------------------------------------------------ * void V_File::cFile(int q,long tp,long crt,strPtr qstr) * long tp;  the file type * long crt; the file creator * strPtr qstr; query string of this file * * This creates the file object and prepares it for the Get and Put dialogs. *------------------------------------------------------------------------------*/void V_File::cFile(int q,long tp,long crt,strPtr windowsStr,strPtr qstr){int i=0;short currentVol;		// BILBIL - 32bit int - 11/17/93#if VPRO	//MERGE-PRO-JAM-1	//JAM 14JULY94 added to handle embed/notembed textures [[[    EmbedTexturesFlag = FALSE;	//JAM 14JULY94 added to handle embed/notembed textures ]]]#endifquery=q&0x0F;newflag=q&NEWFLAG;openFlag=FALSE;CopyString(qStr,qstr);C2Pstr(qStr);minDiskSpace=33000L;VSetCursor(vCursorEarth);while(filname[i]=uname[i])i++;create=crt;type=tp;used=FALSE;relativeFile=0;alias=0;refCon=0;dataFork=TRUE;finderFlags=0;use_radio_button_save = FALSE;	// MERGE-GOURAUD-PROuse_alternate_type = FALSE;	// MERGE-GOURAUD-PROGetVol(NULL,&currentVol);		// BILBIL - 32bit int - 11/17/93pblk.ioVRefNum=currentVol;if(query==SAVE || query==SAVEAS || query==SAVECOPYAS)	cBuffer(DATA_OUT);else cBuffer(DATA_IN);Verify();/*forces the buffer V_Array to exist*/buffer->SetLength(BUFF_SIZE);typeArray=0;}void V_File::sFile(void){#ifndef __powercAppFile theFile;int i;query=LOADSTART;newflag=NEWFLAG;openFlag=FALSE;alias=0;dataFork=TRUE;finderFlags=0;CopyString(qStr,"");C2Pstr(qStr);minDiskSpace=33000L;VSetCursor(vCursorEarth);GetAppFiles( _fileCount_, &theFile );ClrAppFiles( _fileCount_ );_fileCount_++;pblk.ioNamePtr=(StringPtr)fname;Vmemcpy(pblk.ioNamePtr,theFile.fName,64);Vmemcpy(filname,theFile.fName,64);pblk.ioVRefNum=theFile.vRefNum;pblk.ioVersNum=theFile.versNum;pblk.ioPermssn=fsRdWrPerm;create=theCreator;type=theFile.fType;stationery=FALSE; /*don't have stationery in less than 7.0 */used=FALSE;cBuffer(DATA_IN);Verify();/*forces the buffer V_Array to exist*/buffer->SetLength(BUFF_SIZE);#endif //__powerc}void V_File::AEFile(FSSpec *fsspec){FInfo fndrInfo;int i;OSErr err;WDPBRec myBlock;query=LOADSTART;newflag=NEWFLAG;openFlag=FALSE;				dataFork=TRUE;finderFlags=0;SetLocation((char *)fsspec->name,fsspec->parID,fsspec->vRefNum,0);CopyString(qStr,"");C2Pstr(qStr);minDiskSpace=33000L;VSetCursor(vCursorEarth);_fileCount_++;err = FSpGetFInfo(fsspec,&fndrInfo);create=fndrInfo.fdCreator;type=fndrInfo.fdType;if(fndrInfo.fdFlags  & (0x0001<<11))stationery=TRUE;used=FALSE;cBuffer(DATA_IN);Verify();/*forces the buffer V_Array to exist*/buffer->SetLength(BUFF_SIZE);}/*------------------------------------------------------------------------------ * void V_File::dFile() * Just kill the file object. *------------------------------------------------------------------------------*/void V_File::dFile(){if(openFlag)Close();if(alias)DisposHandle((Handle)alias);if(typeArray)typeArray->dArray();dBuffer();}/*------------------------------------------------------------------------------ * long V_File::GetFType(void) * Returns the current file type. * * void V_File::AddFType(long tp) * Adds an additional type for the SFGetFile to use. *------------------------------------------------------------------------------*/long V_File::GetFType(void){return type;}void V_File::AddFType(long tp, strPtr dummy){int err;ObjLock((Handle)this);if(!typeArray)	{	typeArray=new(V_Array);	typeArray->cArray(0,sizeof(long),4);	if(type)typeArray->Append(&type);	}typeArray->Append(&tp);ObjUnlock((Handle)this);}/*------------------------------------------------------------------------------ * void V_File::GetFName(strPtr str) * Returns the file name as a C string in the buffer pointed to by str. *------------------------------------------------------------------------------*/void V_File::GetFName(strPtr str){CopyString(str,filname);P2Cstr(str);}/*------------------------------------------------------------------------------ * void V_File::SetName(strPtr fname) * Set the file name using the buffer pointed to by fname.  Convert this file  * name into a P string. *------------------------------------------------------------------------------*/void V_File::SetName(strPtr fname){int i=0;string str[255];CopyString(str,fname);C2Pstr(str);while(i<=str[0]) {filname[i]=str[i]; i++;}used=TRUE;}/*------------------------------------------------------------------------------ * void V_File::AppendFName(strPtr ext) * adds an extension to the file name, like .TIFF, .TEMP, TEMP3, etc. *------------------------------------------------------------------------------*/voidV_File::AppendFName(strPtr ext)	{	string tFName[255];	CopyString(tFName, filname);	P2Cstr(&tFName[0]);	if ((strlen(ext) <= MAX_LENGTH_APPENDAGE) && (strlen(ext) != 0))		{		if (strlen(tFName) + strlen(ext) + 1< MAX_LENGTH_FILENAME)		// jca 15 Oct 93			{			strcat(tFName, ".");	// jca 15 Oct 93            strcat(tFName, ext);			}		else			{			strcat(tFName, ".");	// jca 15 Oct 93            strcpy(&tFName[MAX_LENGTH_FILENAME - (strlen(ext)+1)], ext);	// jca 15 Oct 93            }        C2Pstr(tFName);        CopyString(filname, tFName);		}	/* else ack!  the appendage is too long! */	}// ABD MERGE-TEXTURE 9/13/93 [[[/*------------------------------------------------------------------------------ * GetFullPathStr() returns the type of buffer this is (in this case a V_FILE_TYPE). * 		changed to use vfsLocation							//GJR 10/06/93 *------------------------------------------------------------------------------*/int V_File::GetFullPathStr(char *fullPathName){char name[256];char dirName[300] = "\p";char fullName[300] = "\p";char tmp[300] = "\p";CInfoPBRec myCInfo;OSErr err;long dirID;short vRefNum;	GetLocation(name, &dirID, &vRefNum, NULL);	err = noErr;	myCInfo.dirInfo.ioNamePtr = (StringPtr)dirName;	myCInfo.dirInfo.ioDrParID = dirID;	do	{		myCInfo.dirInfo.ioVRefNum = vRefNum;		myCInfo.dirInfo.ioFDirIndex = -1;					// -1 means use ioDrDirID		myCInfo.dirInfo.ioDrDirID = myCInfo.dirInfo.ioDrParID;		err = PBGetCatInfo(&myCInfo, FALSE);		if (err == noErr)		{			P2Cstr(dirName);			strcat(dirName, ": ");			C2Pstr(dirName);			if ((dirName[0] + fullName[0]) > 255)				err = bdNamErr;					// too big to eat!			else			{				P2Cstr(dirName);				P2Cstr(fullName);				strcpy(tmp, dirName);				strcat(tmp, fullName);				strcpy(fullName, tmp);				C2Pstr(dirName);				C2Pstr(fullName);			}		}	}	while ((myCInfo.dirInfo.ioDrDirID != fsRtDirID) && (err == noErr));	P2Cstr(fullName);	strcpy(fullPathName, fullName);	return err;}// ABD MERGE-TEXTURE 9/13/93 ]]]/*------------------------------------------------------------------------------ * int V_File::VSetLocation(VfsLocation *vfsLocation_ptr) * int V_File::SetLocation(char *name,long directory,short volume,AliasHandle als) * This indicates the actual location of the file and will find the file.  It uses  * whatever data you pass it and assumes the rest is already set somehow. * If it returns 0, then the file was found. * * Contents of VfsLocation Structure							//GJR 10/06/93 * NOTE: The Innards of VfsLocation are ONLY to be touched by VFILE routines. * char *name; *		the name of the file. * long directory;  *		the real directory reference.  * short volume;   *		if the real directory value is set, then this is the real volume, * 		otherwise, this is the working volume and very likely different between * 		applications.  Use the real directory and real volume * AliasHandle alias; * 		this is the preferred method for finding files under system 7.0. *		This is what we really want, set that other stuff to 0. * *	modded to use VfsLocation; Platform independent.			//GJR 10/06/93 *------------------------------------------------------------------------------*/int V_File::VSetLocation(VfsLocation *vfsLocation){OSErr err = 0;	C2Pstr(&((vfsLocation->name)[0]));		//outside world is C	err = SetLocation(vfsLocation->name,	                  vfsLocation->directory,	                  vfsLocation->volume,					  vfsLocation->alias);	P2Cstr(&((vfsLocation->name)[0]));		//MERGE-GOURAUD-PRO-5 CHANGE THIS BACK TO THE WAY IT WAS GODDAMMIT!!!!	return (err);} int V_File::SetLocation(char *name, long directory,short volume,AliasHandle als){OSErr err=0;WDPBRec myBlock;FileParam fblk;FInfo fndrInfo;int i;ObjLock((Handle)this);query=REFERENCE;// VPLAYER moved this from below to always copy the name over, even if we get an error// laterif(name)	for(i=0;i<64;i++)		filname[i]=name[i];if(directory && volume)	{	myBlock.ioCompletion=0;	myBlock.ioResult=0;	myBlock.ioNamePtr=0;	myBlock.ioVRefNum=volume;	myBlock.ioWDProcID=0;	myBlock.ioWDDirID=directory;	err=PBOpenWD(&myBlock,FALSE);	if(err && !als){ObjUnlock((Handle)this); return err;}	volume=myBlock.ioVRefNum; /*this is now the working directory reference*/	}if(volume)	{	pblk.ioVRefNum=volume;	}if(als)	{	if(alias && (alias != als))DisposHandle((Handle)alias); // VPLAYER - fix 1/24/94	HandToHand((Handle *)&als);	alias=als;	err=-1;	if(gGestaltAvailable)		{		long rval;		FSSpec fsspec,rfsspec;		Boolean changed;				if(gAliasMgrPresent)			{			FSSpec *r_fsspec_ptr;	// ABD 15 Apr 93			short  aliasCount = 1;	// ABD find only one possible match			FSSpec aliasList[1];	// where the matches are stored						// if we are using a relative file, then use that when trying to resolve			// the alias ABD 15 Apr 93 MERGE-ALIAS			if (relativeFile)			{				err = FSMakeFSSpec(relativeFile->pblk.ioVRefNum,0L,					relativeFile->pblk.ioNamePtr,&rfsspec);				if (!err)					r_fsspec_ptr = &rfsspec;				else					r_fsspec_ptr = NULL;			}			else r_fsspec_ptr = NULL;						// ABD changed to use MatchAlias instead of ResolveAlias MERGE-ALIAS#if 1			err = MatchAlias(r_fsspec_ptr, kARMSearch + kARMNoUI, alias, &aliasCount, 				aliasList, &changed, NULL, NULL);			fsspec = aliasList[0];#else						if(!(err=ResolveAlias(r_fsspec_ptr,alias,&fsspec,&changed)))#endif							{				directory=fsspec.parID;				volume=fsspec.vRefNum;				for(i=0;i<64;i++)filname[i]=fsspec.name[i];				/*now find the working directory*/				myBlock.ioCompletion=0;				myBlock.ioResult=0;				myBlock.ioNamePtr=0;				myBlock.ioVRefNum=volume;				myBlock.ioWDProcID=0;				myBlock.ioWDDirID=directory;				err=PBOpenWD(&myBlock,FALSE);				err = FSpGetFInfo(&fsspec,&fndrInfo);				create=fndrInfo.fdCreator;				type=fndrInfo.fdType;				if(fndrInfo.fdFlags  & (0x0001<<11))stationery=TRUE;				volume=myBlock.ioVRefNum; /*this is now the working directory reference*/				}			}		}	else err=-1;	}if( !err && volume )/*now that we think we have found it, lets make sure!*/	{		char	temp[64];			Vmemcpy(fname,filname,64);		sprintf((char *)temp, "%s", fname);		pblk.ioNamePtr=(StringPtr)fname;	pblk.ioVRefNum=volume;		memset(&fblk,0,sizeof(FileParam));	fblk.qLink=pblk.qLink;	fblk.qType=pblk.qType;	fblk.ioTrap=pblk.ioTrap;	fblk.ioCmdAddr=pblk.ioCmdAddr;	fblk.ioCompletion=pblk.ioCompletion;	fblk.ioResult=pblk.ioResult;	fblk.ioNamePtr = (StringPtr)temp;	fblk.ioVRefNum=volume;	fblk.ioFRefNum=0;	err=PBGetFInfo((ParmBlkPtr)&fblk,FALSE); /*is it really there?*/	}ObjUnlock((Handle)this);return err;}/*------------------------------------------------------------------------------ * int V_File::FVerify(void) *------------------------------------------------------------------------------*/int V_File::FVerify(void){FileParam fblk;OSErr err;ObjLock((Handle)this);Vmemcpy(fname,filname,64);pblk.ioNamePtr=(StringPtr)fname;memset(&fblk,0,sizeof(FileParam));fblk.qLink=pblk.qLink;fblk.qType=pblk.qType;fblk.ioTrap=pblk.ioTrap;fblk.ioCmdAddr=pblk.ioCmdAddr;fblk.ioCompletion=pblk.ioCompletion;fblk.ioResult=pblk.ioResult;fblk.ioNamePtr = (StringPtr)fname;fblk.ioVRefNum=pblk.ioVRefNum;fblk.ioFRefNum=0;err=PBGetFInfo((ParmBlkPtr)&fblk,FALSE); /*is it really there?*/ObjUnlock((Handle)this);return err;}intV_File::GetBufferType(void){	return(V_FILETYPE);}/*------------------------------------------------------------------------------ * int V_File::GetLocation(VfsLocation *vfsLocation_ptr) * private int V_File::GetLocation(long directory,short volume,AliasHandle als) * This finds the actual location of the file for other applications. This * assumes that the location of the file is well understood. *		added Vfs structure				//GJR 10/06/93 *------------------------------------------------------------------------------*/int V_File::VGetLocation(VfsLocation *vfsLocation_ptr){OSErr err;	err = GetLocation(&(vfsLocation_ptr->name)[0],	                  &(vfsLocation_ptr->directory),	                  &(vfsLocation_ptr->volume),	                  &(vfsLocation_ptr->alias) );	P2Cstr(&(vfsLocation_ptr->name)[0]);		// outside world is C	return (err);}int V_File::GetLocation(char *name, long *directory,short *volume,AliasHandle *als){WDPBRec myBlock;OSErr err;int i;ObjLock((Handle)this);if (name) for(i=0;i<64;i++)name[i]=filname[i];		// ABD MERGE-TEXTURE 9/14/93myBlock.ioNamePtr=NULL;myBlock.ioVRefNum=pblk.ioVRefNum;myBlock.ioWDIndex=0;myBlock.ioWDProcID=0;if(err=PBGetWDInfo(&myBlock,FALSE)){ObjUnlock((Handle)this); return err;}Vmemcpy(fname,filname,64);pblk.ioNamePtr=(StringPtr)fname;if (directory) *directory=myBlock.ioWDDirID;		// ABD MERGE-TEXTURE 9/14/93if (volume) *volume=myBlock.ioWDVRefNum;		// ABD MERGE-TEXTURE 9/14/93if(gGestaltAvailable)	{	FSSpec fsspec,rfsspec;//JAM altered stuff in here 8/10/94	if(gAliasMgrPresent)		{		err = FSMakeFSSpec(pblk.ioVRefNum,0L,pblk.ioNamePtr,&fsspec);		if(!err)			{			if(relativeFile /*&& relativeFile->pblk*/)				{				err = FSMakeFSSpec(relativeFile->pblk.ioVRefNum,0L,					relativeFile->pblk.ioNamePtr,&rfsspec);				if(!err)					{					if(alias)DisposHandle((Handle)alias);					err = NewAlias(&rfsspec,&fsspec,&alias);					if (als)    		// ABD MERGE-TEXTURE 9/14/93						{							if(!err)								{								if(*als)DisposHandle((Handle)(*als));								err = NewAlias(&rfsspec,&fsspec, als);	//jam			            	    }	//						*als=alias;     // ABD MERGE-TEXTURE 9/14/93 why is this set outside of gAliasMgrPresent ????? jam moved inside 8/10/94						}					}				}			else				{				if(alias)DisposHandle((Handle)alias);				err = NewAlias(0L,&fsspec,&alias);				if (als)    		// ABD MERGE-TEXTURE 9/14/93					{						if(!err)							{							if(*als)DisposHandle((Handle)(*als));							err = NewAlias(0L,&fsspec, als);	//jam			                }//						*als=alias;     // ABD MERGE-TEXTURE 9/14/93 why is this set outside of gAliasMgrPresent ????? jam moved inside 8/10/94					}				}			}		}	}else if (als) 	*als=0;     // ABD MERGE-TEXTURE 9/14/93ObjUnlock((Handle)this);return err;}/*------------------------------------------------------------------------------ * int V_File::VIsSameLocation(VfsLocation *vfsLocation_ptr) * Says if the provided location matches the current files location. *		added 			//GJR 10/06/93 *------------------------------------------------------------------------------*/int V_File::VIsSameLocation(VfsLocation *testLocation){int matches = FALSE;VfsLocation *myVfsLocation;	VGetLocation(myVfsLocation);#if MACINTOSH	if ( (strcmp(myVfsLocation->name,testLocation->name)==0)	  && (myVfsLocation->volume==testLocation->volume)	  && (myVfsLocation->directory==testLocation->directory) )		{#elif WINDOWS	if ( (strcmp(myVfsLocation->path,testLocation->path)==0)	  && (strcmp(myVfsLocation->name,testLocation->name)==0)	  && (strcmp(myVfsLocation->ext, testLocation->ext)==0) )		{#endif		matches = TRUE;		}	return (matches);}/*------------------------------------------------------------------------------ * int VfsGetLocationFType(VfsLocation *vfsLocation, LongPtr type_ptr) * Finds the FileType of the provided VfsLocation. *		added 			//GJR 10/06/93 *------------------------------------------------------------------------------*/int VfsGetLocationFType(VfsLocation *vfsLocation, LongPtr type_ptr){#if MACINTOSHOSErr err = noErr;		string pname[255];		*type_ptr = MakeID('?','?','?','?');		//init to ?what? in case nothing found.				strcpy(pname, vfsLocation->name);		C2Pstr(pname);				if(gFSSpecCalls)			{			FSSpec fsspec;			FInfo fndrInfo;						strcpy(pname, vfsLocation->name);			C2Pstr(pname);			err = FSMakeFSSpec(vfsLocation->volume,vfsLocation->directory,(StringPtr)pname,&fsspec);			if(err){return -1;}			err = FSpGetFInfo(&fsspec,&fndrInfo);			if(err){return -1;}			*type_ptr=fndrInfo.fdType;			}		else			{	// added robustness on lesser platforms			//GJR 10/06/93			FInfo fndrInfo;			err = HGetFInfo(vfsLocation->volume,vfsLocation->directory,(StringPtr)pname,&fndrInfo);			if(err){return -1;}			*type_ptr=fndrInfo.fdType;			}#elif WINDOWS		*type_ptr = '????';		//init to ?what? in case nothing found.		if (validated&USE_EXTENSION)			{			if (!type)				{				/* this is the best guess about the file type */				/* or is it 	type = (long)vfsLocation->extension; */				type = MakeID(vfsLocation->extension[0],vfsLocation->extension[1],				              vfsLocation->extension[2],vfsLocation->extension[3]);				}			}#endif}/*------------------------------------------------------------------------------ * int VfsGetLocationFName(VfsLocation *vfsLocation, CharPtr name) * Finds the FName of the provided VfsLocation. *		added 			//GJR 10/06/93 *------------------------------------------------------------------------------*/int VfsGetLocationFName(VfsLocation *vfsLocation, CharPtr name){OSErr err = noErr;#if MACINTOSH	strcpy(name, vfsLocation->name);#elif WINDOWS	strcpy(name, vfsLocation->name);	strcat(name, vfsLocation->extension);#endif	return (err);}/*------------------------------------------------------------------------------ * int VfsIsSameLocation(VfsLocation *, VfsLocation_t *) * Says if the provided location matches the current files location. *		added 			//GJR 10/06/93 *------------------------------------------------------------------------------*/int VfsIsSameLocation(VfsLocation *oneLocation, VfsLocation *twoLocation){int matches = FALSE;#if MACINTOSH	if ( (strcmp(oneLocation->name,twoLocation->name)==0)	  && (oneLocation->volume==twoLocation->volume) 	  && (oneLocation->directory==twoLocation->directory) )		{#elif WINDOWS	if ( (strcmp(oneLocation->path,twoLocation->path)==0)	  && (strcmp(oneLocation->name,twoLocation->name)==0)	  && (strcmp(oneLocation->ext, twoLocation->ext)==0) )		{#endif		matches = TRUE;		}	return (matches);}/*------------------------------------------------------------------------------ * int VfsGetBogusLocation(VfsLocation *) * Put out a bogus location *		added 			//GJR 10/06/93 *------------------------------------------------------------------------------*/int VfsGetBogusLocation(VfsLocation *vfsLocation_ptr){OSErr err = noErr;#if MACINTOSH	vfsLocation_ptr->name[0]   = 0;	vfsLocation_ptr->volume    = -9191;	vfsLocation_ptr->directory = 0xDEADDEAD;	vfsLocation_ptr->alias     = 0;#elif WINDOWS	vfsLocation_ptr->name[0] = 0;	vfsLocation_ptr->extension[0] = '....';	vfsLocation_ptr->extension[4] = 0;	vfsLocation_ptr->path         = 0;#endif	return (err);}//JAM 23July94 [[[/*------------------------------------------------------------------------------ * int VfsIsVirtusModel(VfsLocation *) * See if file is virtus type, i.e. .vvr, .wlk, or .wtp *		added 			//JAM 4/23/94 *------------------------------------------------------------------------------*/int VfsIsVirtusModel(VfsLocation *location){	long FType;	VfsGetLocationFType(location, &FType);	if(FType == appFileTypeModel) return(TRUE);    else return(FALSE);}//JAM 23July94 ]]]/*------------------------------------------------------------------------------ * void V_File::FindSystem(void) *------------------------------------------------------------------------------*/int V_File::FindSystem(void){OSErr err;SysEnvRec ser;err=SysEnvirons(1,&ser);pblk.ioVRefNum=ser.sysVRefNum;return err;}/*------------------------------------------------------------------------------ * void V_File::SetMinDiskSpace(long) * Set the minimum disk space required to satisfy save. *------------------------------------------------------------------------------*/void V_File::SetMinDiskSpace(long mds){minDiskSpace=mds;}/*------------------------------------------------------------------------------ * void V_File::SetQuery(int,strPtr) * Set the query flag and the query string. *------------------------------------------------------------------------------*/void V_File::SetQuery(int q,strPtr qstr){query=q;CopyString(qStr,qstr);C2Pstr(qStr);switch(query)	{	case SAVE:	case SAVEAS:	case SAVECOPYAS:		direction = DATA_OUT;		break;			case LOAD:	case LOADAS:	case LOADSTART:	case PRINT:		direction = DATA_IN; 		break;	}}/*------------------------------------------------------------------------------ * int V_File::Find(void) *------------------------------------------------------------------------------*/pascal int FileFilter(ParmBlkPtr paramBlock);int typeLen;OSType *typeList;pascal int FileFilter(ParmBlkPtr paramBlock)	{	int	len, i;	int	modelType = FALSE;	int libraryType = FALSE;	// PRO-24#if VPLAYER	int	encryptType = FALSE;#endif //VPLAYER		if (typeLen < 1)		return FALSE;	for (i = 0; i < typeLen; i++)		{		if (typeList[i] == 'VMDL')			modelType = TRUE;#if VPLAYER		if (typeList[i] == 'VPly')			encryptType = TRUE;#endif //VPLAYER 		if (typeList[i] == 'VLIB')	// PRO-24			libraryType = TRUE;		// PRO-24		if (typeList[i] == paramBlock->fileParam.ioFlFndrInfo.fdType)			return FALSE;		}	#if VPLAYER	if (modelType || encryptType)#else	if (modelType)#endif //VPLAYER		{		long	type;		char	*name = (char*)paramBlock->fileParam.ioNamePtr;				len = (unsigned char)name[0];		if (len < 4) return -1;		type = ((long)(toupper(name[len-3])) << 24 | (long)(toupper(name[len-2])) << 16 |				(toupper(name[len-1])) << 8 | (toupper(name[len])));		switch (type)			{			case '.VVR':			case '.WLK':			case '.WTP':#if VPLAYER				if (modelType)#endif //VPLAYER				return FALSE;				break;#if VPLAYER			case '.VPY':				if (encryptType)					return FALSE;				break;#endif //VPLAYER			default:				return -1;				break;			}		}	// PRO-24 [[[	else if (libraryType)	{		long	type;		char	*name = (char*)paramBlock->fileParam.ioNamePtr;				len = (unsigned char)name[0];		if (len < 4) return -1;		type = ((long)(toupper(name[len-3])) << 24 | (long)(toupper(name[len-2])) << 16 |				(toupper(name[len-1])) << 8 | (toupper(name[len])));		switch (type)			{			case '.WLB':				if (libraryType)				return FALSE;				break;			default:				return -1;				break;			}		}	// PRO-24 ]]]	return -1;	}// MERGE-GOURAUD-PRO-11 [[[// MERGE-GOURAUD-PRO [[[pascal short DlgHookRadioButton(short item,DialogPtr theDialog);int localTryToSaveFileRefs;	// MERGE-GOURAUD-PROint localSaveVRFile;int oldTryToSaveFileRefs;pascal short DlgHookRadioButton(short item,DialogPtr theDialog)	{	ControlHandle newControl;	Rect r;	short itemType;		switch(item)		{		case -1:			oldTryToSaveFileRefs = localTryToSaveFileRefs;			GetDItem(theDialog, 9, &itemType, (Handle*)&newControl, &r);			SetCtlValue(newControl, !localTryToSaveFileRefs);			GetDItem(theDialog, 10, &itemType, (Handle*)&newControl, &r);			SetCtlValue(newControl, localTryToSaveFileRefs);			GetDItem(theDialog, 11, &itemType, (Handle*)&newControl, &r);			SetCtlValue(newControl, !localSaveVRFile);			GetDItem(theDialog, 12, &itemType, (Handle*)&newControl, &r);			SetCtlValue(newControl, localSaveVRFile);			break;		case 9:		// make self contained			localTryToSaveFileRefs = FALSE;			GetDItem(theDialog, 9, &itemType, (Handle*)&newControl, &r);			SetCtlValue(newControl, TRUE);			GetDItem(theDialog, 10, &itemType, (Handle*)&newControl, &r);			SetCtlValue(newControl, FALSE);			break;		case 10:	// use texture links			localTryToSaveFileRefs = TRUE;			GetDItem(theDialog, 9, &itemType, (Handle*)&newControl, &r);			SetCtlValue(newControl, FALSE);			GetDItem(theDialog, 10, &itemType, (Handle*)&newControl, &r);			SetCtlValue(newControl, TRUE);			break;		case 11:	// file type popup menu			if (localSaveVRFile)			{				GetDItem(theDialog, 9, &itemType, (Handle*)&newControl, &r);				SetCtlValue(newControl, !oldTryToSaveFileRefs);				GetDItem(theDialog, 10, &itemType, (Handle*)&newControl, &r);				SetCtlValue(newControl, oldTryToSaveFileRefs);			}			localSaveVRFile = FALSE;			GetDItem(theDialog, 9, &itemType, (Handle*)&newControl, &r);			HiliteControl(newControl, 0);			GetDItem(theDialog, 10, &itemType, (Handle*)&newControl, &r);			HiliteControl(newControl, 0);			GetDItem(theDialog, 11, &itemType, (Handle*)&newControl, &r);			SetCtlValue(newControl, TRUE);			GetDItem(theDialog, 12, &itemType, (Handle*)&newControl, &r);			SetCtlValue(newControl, FALSE);			break;		case 12:			oldTryToSaveFileRefs = localTryToSaveFileRefs;			localSaveVRFile = TRUE;			GetDItem(theDialog, 9, &itemType, (Handle*)&newControl, &r);			SetCtlValue(newControl, TRUE);			GetDItem(theDialog, 10, &itemType, (Handle*)&newControl, &r);			SetCtlValue(newControl, FALSE);			GetDItem(theDialog, 9, &itemType, (Handle*)&newControl, &r);			HiliteControl(newControl, 255);			GetDItem(theDialog, 10, &itemType, (Handle*)&newControl, &r);			HiliteControl(newControl, 255);			GetDItem(theDialog, 11, &itemType, (Handle*)&newControl, &r);			SetCtlValue(newControl, FALSE);			GetDItem(theDialog, 12, &itemType, (Handle*)&newControl, &r);			SetCtlValue(newControl, TRUE);			break;		default:			item = item;			break;		}	return item;	}// MERGE-GOURAUD-PRO ]]]// MERGE-GOURAUD-PRO-11 ]]]pascal short DlgHook(short item,DialogPtr theDialog);short newFlag = FALSE;pascal short DlgHook(short item,DialogPtr theDialog)	{	ControlHandle newControl;	Rect r;	short itemType;		switch(item)		{		case -1:			/*hide the new if it ain't supposed to be there*/			if(newFlag == FALSE)				{				GetDItem(theDialog, 11, &itemType, (Handle*)&newControl, &r);				HideControl(newControl);				}			newFlag = FALSE;			break;		case 11:			newFlag = TRUE;			item = 3; /* pretend we are a cancel */			break;		case 100:			/*let's waste some time here */			item = 0;			break;		default:			item = item;			break;		}	return item;	}int V_File::Find(void){OSErr err;SFTypeList typelist;OSType *theList;int numtypes=1;Point loc;SFReply reply;if(openFlag)	{	AlertMessage(TXT_FILEPROB);	return(TRUE);	}ObjLock((Handle)this);Vmemcpy(fname,filname,64);pblk.ioNamePtr=(StringPtr)fname;pblk.ioMisc=NULL;if(!used)	{	if(query==SAVE)query=SAVEAS;	else if(query==LOAD)query=LOADAS;	}retry:switch(query)	{	case SAVE:		pblk.ioPermssn=fsRdWrPerm;		break;	case SAVEAS:	case SAVECOPYAS:		// MERGE-GOURAUD-PRO-11 [[[		VSetCursor(vCursorArrow);		SetPt(&loc,100,80);		memset(&reply,0,sizeof(SFReply));		Vmemcpy(reply.fName,filname,64);		reply.vRefNum=pblk.ioVRefNum;		#if VPRO		if (use_radio_button_save)		{			localTryToSaveFileRefs = !GetEmbedTextures();			localSaveVRFile = FALSE;						SFPPutFile(loc  ,(StringPtr)qStr,(StringPtr)pblk.ioNamePtr,				NewDlgHookProc(DlgHookRadioButton),&reply,(short)3999,NULL);						if(reply.good) 			{		// PRO25				SetEmbedTextures(!localTryToSaveFileRefs);					if (localSaveVRFile)			// PRO25				{				use_alternate_type = localSaveVRFile;				}			}				}		else		#endif // VPRO		{			SFPutFile(loc  ,(StringPtr)qStr,(StringPtr)pblk.ioNamePtr,NULL,&reply);		}			if(reply.good==FALSE){ObjUnlock((Handle)this);return(TRUE);}		Vmemcpy(pblk.ioNamePtr,reply.fName,64);		pblk.ioVRefNum=reply.vRefNum;		pblk.ioVersNum=reply.version;		pblk.ioPermssn=fsRdWrPerm;		stationery=FALSE; /*this is the real thing, the user specifies stationery via								the finder*/		break;		// MERGE-GOURAUD-PRO-11 ]]]	case LOADAS:		VSetCursor(vCursorArrow);		SetPt(&loc,100,80);		if(typeArray)			{			theList=(OSType*)typeArray->Use();			numtypes=typeArray->ALength();			}		else			{			typelist[0]=type;			theList=typelist;			numtypes=1;			}		if(newflag)newFlag=TRUE;		memset(&reply,0,sizeof(SFReply));		Vmemcpy(reply.fName,filname,64);		reply.vRefNum=pblk.ioVRefNum;		// ABD changed typelist to theList so typeArray will work too 8/11/93 		typeLen = numtypes;		typeList = theList;#if VPLAYER		SFGetFile(loc,(StringPtr)qStr,NewFileFilterProc(FileFilter),-1,NULL,NULL,&reply);	// ABD // BILBIL - 11/16/93#else		SFGetFile(loc,(StringPtr)qStr,NewFileFilterProc(FileFilter),-1,NULL,NewDlgHookProc(DlgHook),&reply);	// ABD // BILBIL - 11/16/93#endif //VPLAYER		if(typeArray)typeArray->Unuse();		typeLen = 0;		typeList = NULL;		if(newflag && newFlag){ObjUnlock((Handle)this); return(TRUE);}		newflag=FALSE;		if(reply.good==FALSE){ObjUnlock((Handle)this);return(TRUE);}				else stationery=FALSE;		Vmemcpy(pblk.ioNamePtr,reply.fName,64);		pblk.ioVRefNum=reply.vRefNum;		pblk.ioVersNum=reply.version;		/*just keep going...*/	case LOAD:	case REFERENCE:	case LOADSTART:	case PRINT:		pblk.ioPermssn=fsRdWrPerm;		if(gFSSpecCalls)			{			FSSpec fsspec;			FInfo fndrInfo;			WDPBRec myBlock;			Boolean isFolder, wasAliased;						err = FSMakeFSSpec(pblk.ioVRefNum,0L,pblk.ioNamePtr,&fsspec);			if(err){ObjUnlock((Handle)this);return err;}			err = FSpGetFInfo(&fsspec,&fndrInfo);			if(err){ObjUnlock((Handle)this); return err;}			create=fndrInfo.fdCreator;			type=fndrInfo.fdType;			if(fndrInfo.fdFlags  & (0x0001<<11))stationery=TRUE;			if(gAliasMgrPresent)				{				// ABD this call to ResolveAliasFile is okay to do, because if we				// always do a SetLocation on files we are trying to find, then				// MatchAlias will have been called.  This routine should not,				// for example, go over AppleShare, because MatchAlias will have				// either already found the file.  At least in theory.				// MERGE-ALIAS								err=ResolveAliasFile(&fsspec,TRUE,&isFolder,&wasAliased);				myBlock.ioCompletion=0;				myBlock.ioResult=0;				myBlock.ioNamePtr=0;				myBlock.ioVRefNum=fsspec.vRefNum;				myBlock.ioWDProcID=0;				myBlock.ioWDDirID=fsspec.parID;				err=PBOpenWD(&myBlock,FALSE);				Vmemcpy(pblk.ioNamePtr,fsspec.name,64);				pblk.ioVRefNum=myBlock.ioVRefNum; /*this is now the working directory reference*/				}			}		else			{	// added robustness on lesser platforms			//GJR 10/06/93			FInfo fndrInfo;			err = HGetFInfo(pblk.ioVRefNum,0L,pblk.ioNamePtr,&fndrInfo);			if(err){ObjUnlock((Handle)this); return err;}			create=fndrInfo.fdCreator;			type=fndrInfo.fdType;			}		// change the type if we loaded this file due to file extension (from DOS).		{		char	*name = (char*)pblk.ioNamePtr;		int		len = (unsigned char)name[0];		OSType	newtype;		newtype = ((long)(toupper(name[len-3])) << 24 | (long)(toupper(name[len-2])) << 16 |				(toupper(name[len-1])) << 8 | (toupper(name[len])));		switch (newtype)			{			case '.VVR':			case '.WLK':			case '.WTP':				type = 'VMDL';				break;#if VPLAYER			case '.VPY':				type = 'VPly';				break;#endif //VPLAYER			default:				break;			}		}		break;	}if(query!=SAVECOPYAS)/*set the name to the true file name */	Vmemcpy(filname,pblk.ioNamePtr,64);ObjUnlock((Handle)this);return FALSE;/*no errors*/}/*------------------------------------------------------------------------------ * int V_File::MakeDirectory(void) * This allows you to create a directory at the current location (specified by * the pblk). * int V_File::SetDirectory(void) * This allows you to set the current directory to the current location (specified * by the pblk). *------------------------------------------------------------------------------*/int V_File::MakeDirectory(void){OSErr err;WDPBRec myBlock;HFileParam fblk;memset(&fblk,0,sizeof(HFileParam));myBlock.ioNamePtr=NULL;myBlock.ioVRefNum=pblk.ioVRefNum;myBlock.ioWDIndex=0;myBlock.ioWDProcID=0;if(err=PBGetWDInfo(&myBlock,FALSE))return err;Vmemcpy(fname,filname,64);fblk.ioNamePtr=(StringPtr)fname;fblk.ioVRefNum=myBlock.ioWDVRefNum;fblk.ioDirID=myBlock.ioWDDirID;err = PBDirCreate((HParmBlkPtr)&fblk,FALSE);return err;}int V_File::SetDirectory(void){WDPBRec myBlock;CInfoPBRec dInfo;OSErr err;ObjLock((Handle)this);myBlock.ioNamePtr=NULL;myBlock.ioVRefNum=pblk.ioVRefNum;myBlock.ioWDIndex=0;myBlock.ioWDProcID=0;err=PBGetWDInfo(&myBlock,FALSE);if(err){ObjUnlock((Handle)this); return err;}Vmemcpy(fname,filname,64);memset(&dInfo,0,sizeof(CInfoPBRec));dInfo.dirInfo.ioFDirIndex = 0;dInfo.dirInfo.ioDrDirID = myBlock.ioWDDirID;dInfo.dirInfo.ioVRefNum = myBlock.ioWDVRefNum;dInfo.dirInfo.ioNamePtr = (unsigned char *)fname;err = PBGetCatInfo(&dInfo,FALSE);ObjUnlock((Handle)this);if(err){ObjUnlock((Handle)this); return err;}myBlock.ioCompletion=0;myBlock.ioResult=0;myBlock.ioNamePtr=0;myBlock.ioVRefNum=dInfo.dirInfo.ioVRefNum;myBlock.ioWDProcID=0;myBlock.ioWDDirID=dInfo.dirInfo.ioDrDirID;err=PBOpenWD(&myBlock,FALSE);if(err){ObjUnlock((Handle)this); return err;}pblk.ioVRefNum=myBlock.ioVRefNum; /*this is now the working directory reference*/return err;}/*------------------------------------------------------------------------------ * int V_File::Open(int createFlag) * This allows you open the file to read and write.  The create flag allows you * to force this file to be open as a new file.  This should only be done if * you want to either create a new file or overwrite an existing file. *------------------------------------------------------------------------------*/int V_File::Open(int createFlag){OSErr err=0;FileParam fblk;if(openFlag)AlertMessage(TXT_FILEOPEN);ObjLock((Handle)this);Vmemcpy(fname,filname,64);pblk.ioNamePtr=(StringPtr)fname;pblk.ioMisc=(Ptr)NULL;VSetCursor(vCursorEarth);/* this might be used again, though vblk is obsoletevblk.ioVolIndex= -1;PBGetVInfo(&vblk,FALSE);if(direction==DATA_OUT &&((vblk.ioVAlBlkSiz*vblk.ioVFrBlk) < minDiskSpace))	{	AlertMessage(TXT_NO_DISK_SPACE);		// PRO-JAP	goto retry;	}VSetCursor(vCursorEarth);*/if(direction==DATA_OUT)/*save the file*/	{	if(createFlag)		{		err=PBCreate((ParmBlkPtr)&pblk,FALSE);		if(err==dupFNErr)			{			err=PBDelete((ParmBlkPtr)&pblk,FALSE);			if(err){ObjUnlock((Handle)this);return(err);}			err=PBCreate((ParmBlkPtr)&pblk,FALSE);			}		if(err){ObjUnlock((Handle)this);return(err);}		/*set creator and type*/		memset(&fblk,0,sizeof(FileParam));		fblk.qLink=pblk.qLink;		fblk.qType=pblk.qType;		fblk.ioTrap=pblk.ioTrap;		fblk.ioCmdAddr=pblk.ioCmdAddr;		fblk.ioCompletion=pblk.ioCompletion;		fblk.ioResult=pblk.ioResult;		fblk.ioNamePtr=pblk.ioNamePtr;		fblk.ioVRefNum=pblk.ioVRefNum;		fblk.ioFRefNum=0;		err=PBGetFInfo((ParmBlkPtr)&fblk,FALSE);		VSetCursor(vCursorEarth);		if(err){ObjUnlock((Handle)this);return(err);}		fblk.ioFlFndrInfo.fdType=type;		fblk.ioFlFndrInfo.fdCreator=create;		fblk.ioFlFndrInfo.fdFlags|=finderFlags;		err=PBSetFInfo((ParmBlkPtr)&fblk,FALSE);		VSetCursor(vCursorEarth);		if(err){ObjUnlock((Handle)this);return(err);}		}	if(dataFork)err=PBOpen((ParmBlkPtr)&pblk,FALSE);	else err=PBOpenRF((ParmBlkPtr)&pblk,FALSE);		if(err){ObjUnlock((Handle)this);return(err);}	if(createFlag)		{		err=PBSetEOF((ParmBlkPtr)&pblk,FALSE);		if(err){ObjUnlock((Handle)this);return(err);}		}	}else if(direction==DATA_IN)/*load the file*/	{	if(dataFork)err=PBOpen((ParmBlkPtr)&pblk,FALSE);	else err=PBOpenRF((ParmBlkPtr)&pblk,FALSE);	/*if there is an error because of a locked file, try to open read only*/	if(err==fLckdErr	|| err==opWrErr	|| err==permErr 	|| err==vLckdErr 	|| err==wrPermErr 	|| err==wPrErr	|| err==-5000)		{		pblk.ioPermssn=fsRdPerm;		if(dataFork)err=PBOpen((ParmBlkPtr)&pblk,FALSE);		else err=PBOpenRF((ParmBlkPtr)&pblk,FALSE);		}	if(err){ObjUnlock((Handle)this);return(err);}	}else err= -1;position=0;/* Fill the cache if loading a file... */if(!err)	{	if (direction == DATA_IN)		err=UpdateBuffer(0);	else		Buff_Ptr = Buff_Max = Buff_Begin = 0, Buff_End = BUFF_SIZE - 1;	openFlag=TRUE;	}return(err);/*hopefully, no problems*/}/*------------------------------------------------------------------------------ * int V_File::FindApplication(void) * This allows you to read and write to the current application. *------------------------------------------------------------------------------*/int V_File::FindApplication(void){Str255 apName;short apRefNum;Handle apParam;#ifdef __powercProcessSerialNumber	psn;ProcessInfoRec		info;OSErr				err;FSSpec				theSpecStorage;info.processName = NULL;info.processAppSpec = &theSpecStorage;psn.highLongOfPSN = 0;psn.lowLongOfPSN = kCurrentProcess;if(err = GetProcessInformation(&psn,&info)) return err;return SetLocation((char*)info.processAppSpec->name,info.processAppSpec->parID,info.processAppSpec->vRefNum,NULL);#elseGetAppParms(apName,&apRefNum,&apParam);P2Cstr((char*)apName);SetName((char*)apName);return Find();#endif //__powerc}/*------------------------------------------------------------------------------ * int V_File::Close(void) * This is called by the programmer to close the file properly. *------------------------------------------------------------------------------*/int V_File::Close(void){OSErr err;FileParam fblk;VolumeParam vblk;	int i;extern int cursNum;			// ABD MERGE5 8/25/93 WILLIAMSint oldCursNum = cursNum;		// ABD MERGE5 8/25/93 WILLIAMS/*----------------------------------flush the cache if saving. */if (direction == DATA_OUT)	err=UpdateBuffer(position - Buff_Ptr);/*----------------------------------flush the file*/err=PBFlushFile((ParmBlkPtr)&pblk,FALSE);if(err){ObjUnlock((Handle)this);return(err);}VSetCursor(vCursorEarth);/*----------------------------------close the file*/err=PBClose((ParmBlkPtr)&pblk,FALSE);if(err){ObjUnlock((Handle)this);return(err);}VSetCursor(vCursorEarth);openFlag=FALSE;/*----------------------------------set creator and type*/if(direction==DATA_OUT)	{	memset(&fblk,0,sizeof(FileParam));	fblk.qLink=pblk.qLink;	fblk.qType=pblk.qType;	fblk.ioTrap=pblk.ioTrap;	fblk.ioCmdAddr=pblk.ioCmdAddr;	fblk.ioCompletion=pblk.ioCompletion;	fblk.ioResult=pblk.ioResult;	fblk.ioNamePtr=pblk.ioNamePtr;	fblk.ioVRefNum=pblk.ioVRefNum;	fblk.ioFRefNum=0;	err=PBGetFInfo((ParmBlkPtr)&fblk,FALSE);	VSetCursor(vCursorEarth);	if(err){ObjUnlock((Handle)this);return(err);}	fblk.ioFlFndrInfo.fdType=type;	fblk.ioFlFndrInfo.fdCreator=create;	fblk.ioFlFndrInfo.fdFlags|=finderFlags;	err=PBSetFInfo((ParmBlkPtr)&fblk,FALSE);	VSetCursor(vCursorEarth);	if(err){ObjUnlock((Handle)this);return(err);}	}/*-----------------------------------flush the volume*/memset(&vblk,0,sizeof(VolumeParam));vblk.ioNamePtr=0l;vblk.ioCompletion=pblk.ioCompletion;vblk.ioVRefNum=pblk.ioVRefNum;err=PBFlushVol((ParmBlkPtr)&vblk,FALSE);VSetCursor(vCursorEarth);if(err){ObjUnlock((Handle)this);return(err);}/*----------------------------------if not SAVECOPYAS save this file name*/if(query!=SAVECOPYAS)	for(i=0;i<=fname[0];i++)filname[i]=fname[i];VSetCursor(vCursorEarth);ObjUnlock((Handle)this);VSetCursor(oldCursNum);			// ABD MERGE5 WILLIAMS 8/25/93used=TRUE;return(0);/*indicates that data has been saved correctly*/}/*------------------------------------------------------------------------------ * int V_File::OpenResource(int createFlag) * Opens the resource fork of the file for I/O. *------------------------------------------------------------------------------*/int V_File::OpenResource(int createFlag){int err=0;int cResource=CurResFile();short currentVol;FileParam fblk;ObjLock((Handle)this);pblk.ioNamePtr=(StringPtr)fname;if(direction==DATA_OUT)/*save the file*/	{	if(createFlag)		{		err=PBCreate((ParmBlkPtr)&pblk,FALSE);		if(err==dupFNErr)			{			err=PBDelete((ParmBlkPtr)&pblk,FALSE);			if(err){ObjUnlock((Handle)this);return(err);}			err=PBCreate((ParmBlkPtr)&pblk,FALSE);			}		if(err){ObjUnlock((Handle)this);return(err);}		GetVol(NULL,&currentVol);		SetVol(NULL,pblk.ioVRefNum);		CreateResFile(pblk.ioNamePtr);		SetVol(NULL,currentVol);		/*set creator and type*/		memset(&fblk,0,sizeof(FileParam));		fblk.qLink=pblk.qLink;		fblk.qType=pblk.qType;		fblk.ioTrap=pblk.ioTrap;		fblk.ioCmdAddr=pblk.ioCmdAddr;		fblk.ioCompletion=pblk.ioCompletion;		fblk.ioResult=pblk.ioResult;		fblk.ioNamePtr=pblk.ioNamePtr;		fblk.ioVRefNum=pblk.ioVRefNum;		fblk.ioFRefNum=0;		err=PBGetFInfo((ParmBlkPtr)&fblk,FALSE);		VSetCursor(vCursorEarth);		if(err){ObjUnlock((Handle)this);return(err);}		fblk.ioFlFndrInfo.fdType=type;		fblk.ioFlFndrInfo.fdCreator=create;		fblk.ioFlFndrInfo.fdFlags|=finderFlags;		err=PBSetFInfo((ParmBlkPtr)&fblk,FALSE);		VSetCursor(vCursorEarth);		if(err){ObjUnlock((Handle)this);return(err);}		}	resource=OpenRFPerm(pblk.ioNamePtr,pblk.ioVRefNum,fsRdWrPerm);	if(resource==-1)		{		GetVol(NULL,&currentVol);		SetVol(NULL,pblk.ioVRefNum);		CreateResFile(pblk.ioNamePtr);		SetVol(NULL,currentVol);		resource=OpenRFPerm(pblk.ioNamePtr,pblk.ioVRefNum,fsRdWrPerm);		if(resource==-1)err=-1;		}	if(err){UseResFile(cResource);ObjUnlock((Handle)this);return(err);}	}else if(direction==DATA_IN)/*load the file*/	{	resource=OpenRFPerm(pblk.ioNamePtr,pblk.ioVRefNum,fsRdWrPerm);	/*if there is an error because of a locked file, try to open read only*/	if(resource==-1)		{		pblk.ioPermssn=fsRdPerm;		resource=OpenRFPerm(pblk.ioNamePtr,pblk.ioVRefNum,fsRdWrPerm);		}	if(err){UseResFile(cResource);ObjUnlock((Handle)this);return(err);}	}else err= -1;UseResFile(cResource);return(err);/*no problems*/}/*------------------------------------------------------------------------------ * int V_File::CloseResource(void) * Closes the resource fork of the file. *------------------------------------------------------------------------------*/int V_File::CloseResource(void){FileParam fblk;OSErr err=0;/*this is simple*/if(resource!=0 && resource!=-1)	CloseResFile(resource);if(IODirection()==DATA_OUT)/*set the file type*/	{	memset(&fblk,0,sizeof(FileParam));	fblk.qLink=pblk.qLink;	fblk.qType=pblk.qType;	fblk.ioTrap=pblk.ioTrap;	fblk.ioCmdAddr=pblk.ioCmdAddr;	fblk.ioCompletion=pblk.ioCompletion;	fblk.ioResult=pblk.ioResult;	fblk.ioNamePtr=(StringPtr)filname;	fblk.ioVRefNum=pblk.ioVRefNum;	fblk.ioFRefNum=0;	err=PBGetFInfo((ParmBlkPtr)&fblk,FALSE);	VSetCursor(vCursorEarth);	if(err){ObjUnlock((Handle)this);return(err);}	fblk.ioFlFndrInfo.fdType=type;	fblk.ioFlFndrInfo.fdCreator=create;	fblk.ioFlFndrInfo.fdFlags|=finderFlags;	err=PBSetFInfo((ParmBlkPtr)&fblk,FALSE);	VSetCursor(vCursorEarth);	if(err){ObjUnlock((Handle)this);return(err);}	}ObjUnlock((Handle)this);return err;}/*------------------------------------------------------------------------------ * int V_File::IOResource(Handle buf,long type,int rNumber) * Reads/writes the resource to/from the file.  Note that this method DOES NOT * require the call to the open procedure.  Further, this call guarantees that * the applications resource is still valid.  There is a v *------------------------------------------------------------------------------*/int V_File::IOResource(Handle *buf,long type,int rID,strPtr rName){OSErr err=0;int cResource=CurResFile();/*get main resource file*/Handle rBuffer;Handle oldResource;ObjLock((Handle)this);if((unsigned char*)rName)P2Cstr(rName);UseResFile(resource);if(err=ResError())	goto EndResIO;if(direction==DATA_OUT)	{	rBuffer=*buf;	AddResource(rBuffer,type,rID,(unsigned char*)rName);/*make the handle into a resource*/	if(err=ResError())		goto EndResIO;	WriteResource(rBuffer);				/*save the resource into the file*/	if(err=ResError())		goto EndResIO;	UpdateResFile(resource);			/*update the resource file map*/	if(err=ResError())		goto EndResIO;	DetachResource(rBuffer);			/*make it NOT a resource anymore */	if(err=ResError())		goto EndResIO;	}else	{	*buf=GetResource(type,rID);	if(err=ResError())		goto EndResIO;	DetachResource(*buf);	if(err=ResError())		goto EndResIO;	}EndResIO:UseResFile(cResource);/*set resource file*/if(err)ResultError(err);if(rName)C2Pstr(rName);ObjUnlock((Handle)this);return err;}/*------------------------------------------------------------------------------ * int V_File::VRemoveResource(long type, int rID) * Removes a resource from the file. *------------------------------------------------------------------------------*/int V_File::VRemoveResource(long type, int rID){OSErr err=0;int cResource=CurResFile();Handle rBuffer;UseResFile(resource);if(err=ResError())	goto EndResIO;rBuffer=GetResource(type,rID);if(err=ResError())	goto EndResIO;RmveResource(rBuffer);if(err=ResError())	goto EndResIO;DisposHandle(rBuffer);UpdateResFile(resource);if(err=ResError())	goto EndResIO;EndResIO:UseResFile(cResource);return err;}/* -----------------------------------------------------------------------------	How the V_File Buffer Works:	The buffering system is a front-end to the traditional V_File routines	IO_Data, IOPosition, and IOSetPosition. All file accesses using these	methods are routed through the file buffer which performs the actual	file I/O in segments of BUFF_SIZE bytes. 		The actual file position is maintained in the variable "position", while	the position within the partition is tracked with "Buff_Ptr" (Buff_Ptr 	is always between 0 and BUFF_SIZE). 		"Buff_Max" tracks the highest position in the buffer that has been played with.	 This is intended to minimize disk writes when frequent jumps are involved. 	 When Update Buffer dumps the cache contents to disk, only locations zero to 	 Buff_Max or zero to Buff_Ptr have to be written (depending on who is greater).	 Thus, only the smallest possible number of bytes need to be written instead of the	 entire partition. This also covers the case where the very last segment of the 	 file needs to be written only to the very last position that was modified.	Buffer IO is performed by the methods IO_Buffer and UpdateBuffer.	IO_Buffer performs the transfers between IO_Data and the buffer.	UpdateBuffer handles the actual disk access (usually in increments of 	BUFF_SIZE). In short, information moves through the methods like this:			Read:	Disk->UpdateBuffer->IO_Buffer->IO_Data->Outside World			Write:	Outside World->IO_Data->IO_Buffer->UpdateBuffer->Disk			IO_Buffer traps the cases where the buffer faults in some way,	and calls UpdateBuffer to perform disk access as required...	IOSetPosition and IOPosition almost always cause faults, so they	have provisions for calling UpdateBuffer if necessary.  	IOSetDirection will also flush the buffer if the direction is changing	from writing to reading. */	/*------------------------------------------------------------------------------ * int V_File::UpdateBuffer(long start) * Updates the data cache from disk. *------------------------------------------------------------------------------*/int V_File::UpdateBuffer(long start){	OSErr 	err;	VSetCursor(vCursorEarth);		pblk.ioBuffer = (char *)buffer->Use();	pblk.ioPosMode = fsFromStart;	pblk.ioPosOffset = start;	if(direction == DATA_OUT) 	// DATA_OUT = Write the contents of the cache to disk.		{			if (Buff_Max > Buff_Ptr)		// The idea here is to write the				pblk.ioReqCount = Buff_Max;	// minimum possible amount of the			else							// cache out to disk.				pblk.ioReqCount = Buff_Ptr;			err = PBWrite((ParmBlkPtr)&pblk, FALSE);		}	else		{			pblk.ioReqCount = BUFF_SIZE;	// Fill the entire cache from disk.			err = PBRead((ParmBlkPtr)&pblk,FALSE);		}			/*	Since it is unlikely that a file can be divided into exact increments of		BUFF_SIZE, an EOF Error will occur when the last segment of the file		is loaded into the buffer... So this error is ignored.... */	if (err != -39)		/* Ignore EOF's */		{			if (err && err != TRUE)				/* SysBeep(10); */ ;			if(err != TRUE&&pblk.ioActCount!=pblk.ioReqCount)				{					if(!err)err=TRUE;					/* SysBeep(10); */				}		}	else err=0;/*I said, ignore EOF's*/	Buff_Ptr = Buff_Max = 0;	Buff_Begin = start;	Buff_End = start + BUFF_SIZE - 1;	buffer->Unuse();	return(err);}/* Cache requires this method to be rederived. */int V_File::IOSetDirection(int dir){	long	temp = Buff_Ptr;	OSErr	err=0;	if(dir==direction)return(0);	if (openFlag && direction == DATA_OUT)// Save the current block before reversing I/O		{			err = UpdateBuffer(Buff_Begin);			Buff_Ptr = temp;		}	direction=dir;	return(err);}/*------------------------------------------------------------------------------ * int V_File::IOBuffer(char *buf, long length) * Read from the data cache. *------------------------------------------------------------------------------*/int V_File::IOBuffer(char *buf, long length){int j;			/* temp loop counter */OSErr err=0;char *MainBuffer=(char*)buffer->Use();extern V_Meter *vMeter;while(!err && length>0)	{	if(vMeter && vMeter->total==-1)		vMeter->Update(TickCount());			if(direction==DATA_IN)		// EOF Error Trap.		{			long	file_length;				// Must always recheck file length because it might change without warning. 			err = IOLength(&file_length);															if (err) /* SysBeep(10); */ ;			if (position+length > file_length)  err = -39;	// EOF Error.		}	if (Buff_Ptr + length > BUFF_SIZE)	// Trap I/O requests that will fault.		{		int ilength = 0;	/* current length of interest */							/* only to be used for these partial length transfers */		if(Buff_Ptr < BUFF_SIZE)	// Are we finished with the current partition yet?			{			ilength = BUFF_SIZE-Buff_Ptr;						if (cryptOn)				{ /* then transfer via encryption */				if(direction==DATA_IN)					{  /* then decrypt from file into memory */					DeCrypt(buf,&MainBuffer[Buff_Ptr],ilength,position);					}				else   /* direction==DATA_OUT */					{  /* so encrypt on way out to file buffer system */					EnCrypt(&MainBuffer[Buff_Ptr],buf,ilength,position);					}				}			else				{ /* crypt is off, so use plain Vmemcpy to transfer */				if(direction==DATA_IN)					Vmemcpy(buf,&MainBuffer[Buff_Ptr],ilength);					else Vmemcpy(&MainBuffer[Buff_Ptr],buf,ilength);				}							Buff_Ptr = BUFF_SIZE;	// UpdateBuffer will expect this.			position += ilength;							}		if(direction == DATA_OUT)	// Write case is handled differently.			{			err=IOSetDirection(DATA_IN);	// This will store the cache contents.			if(!err)err=UpdateBuffer(position);	// Read the next segment for modification.			if(!err)err=IOSetDirection(DATA_OUT);	// Return to write mode.			}		else err=UpdateBuffer(position); /* load next partition for reading */		//		Buff_Begin = position, Buff_End = position + BUFF_SIZE - 1;//			already adjusted properly by UpdateBuffer		buf+=ilength;		length-=ilength;		}	else /*the data is all in the buffer so Buff_Begin and Buff_End remain unchanged*/		{/* CAUTION: prior routines use ilength, the following use this->length */		if (cryptOn)			{ /* then transfer via encryption */			if(direction==DATA_IN)				DeCrypt(buf,&MainBuffer[Buff_Ptr],length,position);				else EnCrypt(&MainBuffer[Buff_Ptr],buf,length,position);			}		else			{ /* !cryptOn, so use plain Vmemcpy to transfer */			if(direction==DATA_IN)				Vmemcpy(buf,&MainBuffer[Buff_Ptr],length);				else Vmemcpy(&MainBuffer[Buff_Ptr],buf,length);			}		Buff_Ptr += length;		position += length;		length=0;/*all done*/		}	}buffer->Unuse();return err;}/*------------------------------------------------------------------------------ * int V_File::IOData(void * buf,long length) * Reads/writes the buffer which is length data bytes long to/from the cache. *------------------------------------------------------------------------------*/int V_File::IOData(void * buf,long length){int		doChangeThePosition=TRUE;OSErr 	err = 0;if (direction==DATA_OUT) 	err = IOBuffer((char*)buf, length); else	{	long end;	if(chunkData.size!=-1)		{		end = chunkData.position+chunkData.size;		if (end < position+length)			{				length=end-position;				if(length<0)					{					err=-1;					doChangeThePosition = FALSE;					}				else if (length == 0)					{					err=TRUE;					doChangeThePosition = FALSE;					}				else					err = IOBuffer((char*)buf, length);			}		else 			err = IOBuffer((char*)buf, length);		}	else 		err = IOBuffer((char*)buf, length);	}if(err&&err!=TRUE)	/* SysBeep(10); */ ;return(err);}/*------------------------------------------------------------------------------ * int V_File::IOPosition(void *buf,long length,long mark) * Reads length data bytes of the file into the buffer starting at the mark. *------------------------------------------------------------------------------*/int V_File::IOPosition(void *buf,long length,long mark){OSErr err;err =IOSetPosition(mark);if(!err)err=IOData(buf, length);return err;}/*------------------------------------------------------------------------------ * int V_File::IOLength(long *length) * Determines the length of the file.  Returns an error if anything wrong happens. *------------------------------------------------------------------------------*/int V_File::IOLength(long *length){OSErr err;err=PBGetEOF((ParmBlkPtr)&pblk,FALSE);(*length)=(long)pblk.ioMisc;return err;}/*------------------------------------------------------------------------------ * int V_File::IOSetPosition(long loc) * Sets the position of the next file read or write. *------------------------------------------------------------------------------*/int V_File::IOSetPosition(long loc){OSErr	err = 0;long offset = Buff_Begin;if (direction == DATA_OUT && Buff_Ptr > Buff_Max)	Buff_Max = Buff_Ptr;				// Maintain value of Buff_Max.if (loc < Buff_Begin || loc > Buff_End)	{	/* Division truncation will produce correct offset. */	offset = (loc / BUFF_SIZE) * BUFF_SIZE;	if (direction == DATA_OUT)		{		err=IOSetDirection(DATA_IN);	// This will store the buffer contents.		if(!err)err=UpdateBuffer(offset);	// Read new segment for modification.		if(!err)err=IOSetDirection(DATA_OUT);	// Return to write mode.		}	else 		err=UpdateBuffer (offset); 		// Load new segment for reading. 	}position = loc;Buff_Ptr = loc - offset;return err;}/*------------------------------------------------------------------------------ * int V_File::IOSetLength(long loc) * Sets the length of the file. *------------------------------------------------------------------------------*/int V_File::IOSetLength(long loc){OSErr err;pblk.ioMisc=(Ptr)loc;err=PBSetEOF((ParmBlkPtr)&pblk,FALSE);return err;}/*------------------------------------------------------------------------------ * int V_File::Delete(void) * Deletes file. *------------------------------------------------------------------------------*/int V_File::Delete(void){OSErr err;Vmemcpy(fname,filname,64);pblk.ioNamePtr=(StringPtr)fname;pblk.ioMisc=(Ptr)NULL;err=PBDelete((ParmBlkPtr)&pblk,FALSE);if(!err)openFlag=FALSE;return err;}/*------------------------------------------------------------------------------ * int V_File::Rename(strPtr str,int flag) * Renames file. *------------------------------------------------------------------------------*/int V_File::Rename(strPtr str){OSErr err;char newName[255];strcpy(newName,str);C2Pstr(newName);Vmemcpy(fname,filname,64);pblk.ioNamePtr=(StringPtr)fname;pblk.ioMisc=newName;err=PBRename((ParmBlkPtr)&pblk,FALSE);if(!err)	{	Vmemcpy(filname,newName,64);	Vmemcpy(fname,filname,64);	}return err;}/*------------------------------------------------------------------------------ * int V_File::Copy(V_File *file) * Copys the file. *------------------------------------------------------------------------------*/#define COPYBLOCK 1024Lint V_File::Copy(V_File *fromFile){OSErr err = 0;long length,clength;char *buffer;int olddir;ObjLock((Handle)this);olddir=fromFile->direction;/* get the current file information */Vmemcpy(fname,filname,64);pblk.ioNamePtr=(StringPtr)fname;IOSetDirection(DATA_OUT);err=Open(TRUE);/*create the new file name*/fromFile->IOSetDirection(DATA_IN);if(!err)err=fromFile->Open(FALSE);if(!err)err=fromFile->IOLength(&length);if(!err)	buffer=NewPtr(COPYBLOCK);if(!buffer)err=-1;if(!err)	while(err==noErr && length>0)		{		clength=min(COPYBLOCK,length);		err=fromFile->IOData(buffer,clength);		if(!err)err=IOData(buffer,clength);		length-=COPYBLOCK;		if(MeterUpdate(clength))err=-2;		}Close();fromFile->Close();if(err)Delete();if(buffer)DisposPtr(buffer);fromFile->direction=olddir;ObjUnlock((Handle)this);return err;}/*------------------------------------------------------------------------------ * int V_File::Used() * Returns a flag that indicates whether the file has ever been read or written. * Used to protect the user from the programmer. *------------------------------------------------------------------------------*/int V_File::Used(){return(used);}/*------------------------------------------------------------------------------ * int V_File::ReadOnly() * Returns a flag that indicates whether the file is locked. *------------------------------------------------------------------------------*/int V_File::ReadOnly(){return(read_only);}/*------------------------------------------------------------------------------ * int V_File::Stationery() * Returns a flag that indicates whether the file has been set to be stationery. *------------------------------------------------------------------------------*/int V_File::Stationery(){return(stationery);}/*------------------------------------------------------------------------------ * void V_File::SetNewFlag(int) * int V_File::GetNewFlag(void) * These are used to make the SFGetFile use the New button. *------------------------------------------------------------------------------*/void V_File::SetNewFlag(int flag){newflag=flag;}int V_File::GetNewFlag(void){return newflag;}/*------------------------------------------------------------------------------ * int V_File::GetVolume(void) * void V_File::SetVolume(int vnum) *------------------------------------------------------------------------------*/int V_File::GetVolume(void){return pblk.ioVRefNum;}void V_File::SetVolume(int vnum){pblk.ioVRefNum=vnum;}/*------------------------------------------------------------------------------ * void V_File::SetRelative(V_File *relative) * This sets the relative reference file for this file.  This is used for setting * aliases and saving complete relative path names between a file and its owning * file document. *------------------------------------------------------------------------------*/void V_File::SetRelative(V_File *relative){relativeFile=relative;}/*------------------------------------------------------------------------------ * void V_File::SetFork(int fork) * This sets whether file operations apply to the data fork or to the resource * fork. It should be called before the call to Open(). *------------------------------------------------------------------------------*/void V_File::SetFork(int fork){dataFork = (fork == DATA_FORK);}/*------------------------------------------------------------------------------ * void V_File::FinderFlags(int bundle) * This controls changes to the file's Finder flags as the file is closed. * Currently, the only possible change is setting the bundle bit. The other * flags can't be changed and the bundle bit can't be cleared. *------------------------------------------------------------------------------*/void V_File::FinderFlags(int bundle){finderFlags = (bundle ? fHasBundle : 0);}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/int V_File::IOInsert(long position,long size){int oldDirection=IODirection();V_Array *inOut;long location,length,stub;if(size==0)return 0;IOLength(&length); /*how long is this sucker?*/IOSetLength(length+size);if(position==length)return 0;inOut=new(V_Array);inOut->cArray(size,1,size);/*create our temporary buffer*/location=length-size;while(location>position)	{	/*read the data in*/	IOSetPosition(location);	IOSetDirection(DATA_IN);	inOut->IO(this);		/*write the data back out at the new location*/	IOSetPosition(location+size);	IOSetDirection(DATA_OUT);	inOut->IO(this);	location-=size;	}stub=location+size-position;/*this is all that is left to move*/if(stub)/*anything there?*/	{	inOut->SetLength(stub);/*this is all we need*/	IOSetPosition(position);/*set at the beginning of the last bit*/	IOSetDirection(DATA_IN);	inOut->IO(this);		IOSetPosition(position+size);	IOSetDirection(DATA_OUT);	inOut->IO(this);	}/*clean up after we are done*/IOSetDirection(oldDirection);inOut->dArray();}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/int V_File::IODelete(long position,long size){int oldDirection=IODirection();V_Array *inOut;long location,length,stub;if(size==0)return 0;IOLength(&length); /*how long is this sucker?*/if(position+size==length)	{	IOSetLength(length-size);	return 0;	}inOut=new(V_Array);inOut->cArray(size,1,size);/*create our temporary buffer*/location=position+size;while(location+size<length)	{	/*read the data in*/	IOSetPosition(location);	IOSetDirection(DATA_IN);	inOut->IO(this);		/*send the data back out in the new location*/	IOSetPosition(location-size);	IOSetDirection(DATA_OUT);	inOut->IO(this);	location+=size;	}/*clean up after we are done*/stub=length-location;if(stub)/*anything left to transfer?*/	{	IOSetPosition(location);	inOut->SetLength(stub);	IOSetDirection(DATA_IN);	inOut->IO(this);		/*send the data back out to the new location*/	IOSetPosition(location-size);	IOSetDirection(DATA_OUT);	inOut->IO(this);	}IOSetLength(length-size);IOSetDirection(oldDirection);inOut->dArray();}/*------------------------------------------------------------------------------ * int V_File::IO(V_Buffer *buf) * This method is used to read and write this files reference data to or from * the V_Buffer *buf.  This allows us to find this file later if it contains  * data that another file may have use for.  For example, a 3D model might have * PICT images or QuickTime movies mapped to the surfaces.  Rather than saving * this information with the model, we only save a reference to it with the * model.  The order of importance of this information is as follows: * If System 7.0 was used and is being used now, use the alias manager.  Otherwise * use the realVRefNum and realDirID data.  If this fails as well, then we need * to resort to the full path name.  This might be necessary if there was a full * backup of the relevent files.  This also may fail if the folder containing the * files has been moved around, so the final method is to use a relative path, * assuming we know where the relevent related file is located!  The data is  * stored as follows: *  * 	file name *	chunk 'ALIS' *		file alias handle - requires system 7.0 to use, but it is the preferred method. *	chunk 'REFR' *		standard directory and volume reference numbers. * 	chunk 'FPTH' * 		file path name. *		index into file path name. *		reference path to index. * *------------------------------------------------------------------------------*/#define IFF_PATH 	'FPTH'#define IFF_ALIAS 	'ALIS'#define IFF_REFR	'REFR'int V_File::IO(V_Buffer *buf){OSErr err = noErr;						// init for people who check for errors during output //GJR 09/24/93short aliasLength;						// this shouldn't be an int!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!short zero = 0;long directory;short volume;int i;char name[64];V_Array *path1,*path2;short plength;				// used for IO_SHORT call must be short - BILBIL - 12/8/93pathMember *pdata;short i1,i2;if(buf->IODirection()==DATA_OUT)	{	/*-----------------Get the needed information for the next sections*/	GetLocation(name,&directory,&volume,&alias);	/*-----------------first, is there System 7.0 alias reference information available?*/		if(alias)/*everything worked out just fine*/		{		/*save the alias handle here*/		buf->OpenChunkW(IFF_ALIAS);		aliasLength=GetHandleSize((Handle)alias);		buf->IOType(&aliasLength,IO_SHORT);		buf->IOType(&zero,IO_SHORT);		HLock((Handle)alias);		buf->IOData(*alias,aliasLength);		HUnlock((Handle)alias);		buf->CloseChunk();		}	/*---------------------second, WRITE the dirID and the vRefNum*/		{		/*the vRefNum is a short and the file name is a pString*/		buf->OpenChunkW(IFF_REFR);		/*Save the file name*/		buf->IOType(name,IO_PSTRING);		buf->IOType(&directory,IO_LONG);		buf->IOType(&volume,IO_SHORT);		buf->CloseChunk();		}	/*-----------------third, save the absolute file location*/	if(path1=PathName(pblk.ioVRefNum))		{		buf->OpenChunkW(IFF_PATH);		buf->IOType(name,IO_PSTRING);		plength=path1->ALength();		buf->IOType(&plength,IO_SHORT);		pdata=(pathMember*)path1->Use();		for(i=0;i<plength;i++)			buf->IOType(pdata[i],IO_PSTRING);		path1->Unuse();		/*-----------------fourth, is there a related file? This is to generate a relative path.*/		plength=0;		if(relativeFile)			{			if(path2=PathName(relativeFile->pblk.ioVRefNum))				{				pathMember pm1,pm2;				i1=path1->ALength();				i2=path2->ALength();								do	{					path1->Get(i1-1,&pm1);					path2->Get(i2-1,&pm2);					if(0==memcmp(pm1,pm2,max(pm1[0],pm2[0])))						{						i1--;						i2--;						}					else break;					}while(i1>0 && i2>0);				/*now i1 is the index into path1 where the relative file					trees off*/				buf->IOType(&i1,IO_SHORT);				buf->IOType(&i2,IO_SHORT);				pdata=(pathMember*)path2->Use();				for(i=0;i<i2;i++)					buf->IOType(pdata[i],IO_PSTRING);				path2->Unuse();				path2->dArray();				}			}		else buf->IOType(&plength,IO_SHORT);		path1->dArray();		buf->CloseChunk();		}			}else if(buf->IODirection()==DATA_IN)	{	int found=FALSE;	int notDone=TRUE;		query=REFERENCE;	while(notDone && !found)		{		long id=buf->OpenChunkR();		short dummyShort;		if(id==0)break;		switch(id)			{			case IFF_ALIAS:/*read the alias information if there is any*/				if(!found)					{					if(alias)DisposHandle((Handle)alias);					buf->IOType(&aliasLength,IO_SHORT);					buf->IOType(&dummyShort,IO_SHORT);					alias=(AliasHandle)NewHandle(aliasLength);					HLock((Handle)alias);/*make sure its doesn't move*/					buf->IOData(*alias,aliasLength);					HUnlock((Handle)alias);					if(0==(err=SetLocation(0,0,0,alias)))found=TRUE;					DisposHandle((Handle)alias); /*get rid of it now*/					alias = NULL;					}				break;			case IFF_REFR:				if(!found)					{					/*Read the file name*/					buf->IOType(name,IO_PSTRING);					buf->IOType(&directory,IO_LONG);					buf->IOType(&volume,IO_SHORT);					if(0==(err=SetLocation(name,directory,volume,0)))found=TRUE;					}				break;			case IFF_PATH:				if(!found)					{					buf->IOType(name,IO_PSTRING);					buf->IOType(&plength,IO_SHORT);					path1=new(V_Array);					path1->cArray(plength,sizeof(pathMember),4);					pdata=(pathMember*)path1->Use();					for(i=0;i<plength;i++)						buf->IOType(pdata[i],IO_PSTRING);					path1->Unuse();					/*first, let's check to see if the file is where it used to be*/					if(0==(err=ParsePathName(path1, &directory, &volume)))						if(0==(err=SetLocation(name,directory,volume,0)))							{							path1->dArray();							found=TRUE;							}					/*Our last hope is that there is a relative file and that					  our file is in the same location relative to this file*/					if(!found)						{						if(relativeFile)/*we know where the relative file is*/							{							buf->IOType(&i1,IO_SHORT);							buf->IOType(&i2,IO_SHORT);							path2=new(V_Array);							path2->cArray(i2,sizeof(pathMember),4);							pdata=(pathMember*)path2->Use();							for(i=0;i<i2;i++)								buf->IOType(pdata[i],IO_PSTRING);							path2->Unuse();							volume=relativeFile->pblk.ioVRefNum;							if(0==(err=ParseRelativePath(path1,path2,i1, &directory, &volume)))								if(0==(err=SetLocation(name,directory,volume,0)))									{									found=TRUE;									}							path2->dArray();							}						path1->dArray();						}					}				notDone=FALSE;				break;			default: break;			}		buf->CloseChunk();		}	if(!found)err=fnfErr;	}else return err;return err;}// MERGE-PRO-JAM-1// JAM 7-18-94 to help handle embedding/file refs for textures[[[#if VPROshortV_File::GetEmbedTextures(void){	return(EmbedTexturesFlag);}voidV_File::SetEmbedTextures(short newvalue){	EmbedTexturesFlag = newvalue;}#endif// JAM 7-18-94 to help handle embedding/file refs for textures]]]V_Array *PathName(short vRefNum){V_Array *path;pathMember pm;CInfoPBRec block;WDPBRec myBlock;OSErr err;int i;long dirID;if(gHaveAUX && (vRefNum== -1))	dirID=2;else	{	myBlock.ioNamePtr=NULL;	myBlock.ioVRefNum=vRefNum;	myBlock.ioWDIndex=0;	myBlock.ioWDProcID=0;	err=PBGetWDInfo(&myBlock,FALSE);	if(err)return 0;	dirID=myBlock.ioWDDirID;	vRefNum=myBlock.ioWDVRefNum;	}path=new(V_Array);path->cArray(0,sizeof(pathMember),4);block.dirInfo.ioNamePtr=(unsigned char *)pm;block.dirInfo.ioDrParID=dirID;do	{	block.dirInfo.ioVRefNum=vRefNum;	block.dirInfo.ioFDirIndex=-1;	block.dirInfo.ioDrDirID=block.dirInfo.ioDrParID;	for(i=0;i<32;i++)pm[i]=0;/*clear the block*/	err=PBGetCatInfo(&block,FALSE);	if(err){path->dArray(); return 0;}	path->Append(&pm);	}while(block.dirInfo.ioDrDirID !=fsRtDirID);return path;}int ParsePathName(V_Array *path, long *dirID, short *vRefNum){OSErr err;int len=path->ALength(),i;CInfoPBRec dInfo;HParamBlockRec vInfo;pathMember pm,pm2;memset(&vInfo,0,sizeof(HParamBlockRec));memset(&dInfo,0,sizeof(CInfoPBRec));len--;path->Get(len,&pm);for(i=0;i<pm[0]+1;i++)pm2[i]=pm[i];pm2[pm2[0]+1]=':';pm2[0]++;vInfo.volumeParam.ioVRefNum = 	0;			//   Get its vRefNum...vInfo.volumeParam.ioNamePtr =	(unsigned char *)pm2;vInfo.volumeParam.ioVolIndex =	-1;err = PBHGetVInfo (&vInfo,false);if (err) return err;					//   and return an error if we couldn't find it/*ensure that the volume names still agree*/for(i=0;i<pm[0]+1;i++)	if(pm[i]!=pm2[i])return -1;*vRefNum = vInfo.volumeParam.ioVRefNum;	//   ...or put it into the Result*dirID=fsRtDirID;while(len--)	{	path->Get(len, &pm);	dInfo.dirInfo.ioFDirIndex = 0;	dInfo.dirInfo.ioDrDirID = *dirID;	dInfo.dirInfo.ioVRefNum = *vRefNum;	for(i=0;i<pm[0]+1;i++)pm2[i]=pm[i];	dInfo.dirInfo.ioNamePtr = (unsigned char *)pm2;	err = PBGetCatInfo(&dInfo,FALSE);	if(err)return err;	*dirID = dInfo.dirInfo.ioDrDirID;	}return err;}int ParseRelativePath(V_Array *path1,V_Array *path2,int index,long *dirID,short *vRefNum){WDPBRec myBlock;CInfoPBRec dInfo;OSErr err;int i,len;pathMember pm,pm2;/*convert the vRefNum into the volume/directory form*/if(gHaveAUX && (*vRefNum== -1))	*dirID=2;else	{	myBlock.ioNamePtr=NULL;	myBlock.ioVRefNum=*vRefNum;	myBlock.ioWDIndex=0;	myBlock.ioWDProcID=0;	err=PBGetWDInfo(&myBlock,FALSE);	*dirID=myBlock.ioWDDirID;	*vRefNum=myBlock.ioWDVRefNum;	}/*now trace up the path from the known file location comparing file path names*/memset(&dInfo,0,sizeof(CInfoPBRec));dInfo.dirInfo.ioNamePtr=(unsigned char *)pm;dInfo.dirInfo.ioDrParID=*dirID;len=path2->ALength();for(i=0;i<len && !err;i++)	{	dInfo.dirInfo.ioVRefNum=*vRefNum;	dInfo.dirInfo.ioFDirIndex=-1;	dInfo.dirInfo.ioDrDirID=dInfo.dirInfo.ioDrParID;		memset(pm,0,32);/*clear the block*/	err=PBGetCatInfo(&dInfo,FALSE);	path2->Get(i,&pm2);	if(!err)if(dInfo.dirInfo.ioDrDirID ==fsRtDirID)err=fnfErr;	if(!err)if(memcmp(pm,pm2,pm2[0]))err=fnfErr;	}if(!err)/*now get the top of the relative tree*/	{	dInfo.dirInfo.ioVRefNum=*vRefNum;	dInfo.dirInfo.ioFDirIndex=-1;	dInfo.dirInfo.ioDrDirID=dInfo.dirInfo.ioDrParID;			memset(pm,0,32);/*clear the block*/	err=PBGetCatInfo(&dInfo,FALSE);	path1->Get(index,&pm2);	if(!err)if(dInfo.dirInfo.ioDrDirID ==fsRtDirID)err=fnfErr;	if(!err)if(memcmp(pm,pm2,pm2[0]))err=fnfErr;	}/*we now have the top of the tree, we will now trace back down using path1*/if(!err)	{	*dirID=dInfo.dirInfo.ioDrDirID;	while(index--)		{		path1->Get(index, &pm);		dInfo.dirInfo.ioFDirIndex = 0;		dInfo.dirInfo.ioDrDirID = *dirID;		dInfo.dirInfo.ioVRefNum = *vRefNum;		dInfo.dirInfo.ioNamePtr = (unsigned char *)pm;		err = PBGetCatInfo(&dInfo,FALSE);		if(err)return err;		*dirID = dInfo.dirInfo.ioDrDirID;		}	}return err;}void TestPath(void);#include "AppFiles.h"void TestPath(void){V_File *file1;V_File *file2;V_File *file3;/*first choose two files to be related*//*this is the base file, the one we will try to find in a second*/file1=new(V_File);file1->cFile(LOADAS,appFileTypeModel,appFileCreator,"Test load 1", "");file1->Find();/*This is the relative file, we will assume that we know where this one is.  Note that this is typically the main document file (for example a 'VMDL')  while file1 will typically be a file used by the main file (for example  a 'PICT').*/file2=new(V_File);file2->cFile(LOADAS,appFileTypeModel,appFileCreator,"Test load 2", "");file2->Find();/*this is to let file1 know that it's location depends upon file2*/file1->SetRelative(file2);/*of course file 3 is where we will be putting the reference*/file3=new(V_File);file3->cFile(SAVEAS,appFileTypeModel,appFileCreator,"Test save 3", "");file3->Find();file3->Open(TRUE);file1->IO(file3);file3->Close();file3->dFile(); /*assume that we can find file 3 again*/file1->dFile(); /*so much for file1, if we wish to find it again,				we will need to use file3*/file3=new(V_File);file3->cFile(LOADAS,appFileTypeModel,appFileCreator,"Test load 3", "");file3->Find();file3->Open(TRUE);file1=new(V_File);file1->cFile(LOADAS,appFileTypeModel,appFileCreator,"Test find 1", "");file1->SetRelative(file2);/*now pull the reference back out of file3 to find file1, the methods it  uses to find the file are:  1. attempt to read the alias (note that this is greatly enhanced with the     use of the relative referenced file).  2. standard file reference method using file name, directory and volume numbers.   3. absolute path location using the text based path.  This is especially useful     following a full back up of the system which might invalidate the above methods.  4. relative path reference.  This allows you to find the file if you currently      know the location of the referenced file and they have not changed location     relative to each other.  That is they share a common containing directory     which may have moved but the files are where they were relative to this directory.*/file1->IO(file3);file3->Close();/*all done*/file1->dFile();file2->dFile();file3->dFile();}voidVfsLocation::cVfsLocation(){	alias = NULL;}voidVfsLocation::dVfsLocation(){	if(alias != NULL)	{		DisposHandle((Handle)alias);	}	delete this;}voidVfsLocation::CopyVfsLocation(VfsLocation *newvfs){	int err;	Boolean waschanged;	if(this == newvfs) return;	if(alias != NULL)	{		DisposHandle((Handle)alias);	}	strcpy(name, newvfs->name);	directory = newvfs->directory;	volume = newvfs->volume;	if(newvfs->alias != NULL)	{		FSSpec fsspec;		err = ResolveAlias(NULL, newvfs->alias, &fsspec, &waschanged);		if (!err) NewAlias(0L,&fsspec, &alias);	}	else	{    	alias = NULL;    }}