/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				 *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Platform: 	MACINTOSH 	X *				WINDOWS		X * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VIO.h"#define INVARRAY#include "VArray.h"#include "VMemUtil.h"#include <string.h>#if WINDOWS#include "DOS.h"		// DOS segment handlers		GJR 10/20/93						// Note: huge can't store across seg boundaries with single op#define SPANNEDHUGE(farptr, hifarptr) ((unsigned) FP_OFF(farptr) > (unsigned) FP_OFF(hifarptr))//jam 12-15-93 memcopy which can cross segment boundaries [[[void *Vhugememcpy(void *s1, void *s2, unsigned long n );void *Vhugememcpy(void *s1, void *s2, unsigned long n ){	//=============================================================================//	VERY SLOW, huge pointer loop//-----------------------------------------------------------------------------#if 0	char huge *a = (char huge *)s1;    char huge *b = (char huge *)s2;	unsigned long i;	for(i=0;i<n;i++) a[i] = b[i];	return(NULL);#endif/*	unsigned long i;	for(i=0;i<n;i++) a[i] = b[i];	return(NULL);*///=============================================================================// Medium. Replace inline memcpy with our own. it works.// 			(borlands does not work near seg boundaries??)//-----------------------------------------------------------------------------#if 0	char huge *ch1 = (char huge *)s1;	char huge *ch2 = (char huge *)s2;	char *c1, *c2;	long BytesToSegBndry, NumBytes;	while(n > 0)    {		c1 = (char *)ch1;		c2 = (char *)ch2;		if(OFFSETOF(c1) > OFFSETOF(c2))	{BytesToSegBndry = 0x00010000L - (long)OFFSETOF(c1);}		else		{BytesToSegBndry = 0x00010000L - (long)OFFSETOF(c2);}		if(BytesToSegBndry < n) { NumBytes = BytesToSegBndry; }		else						 { NumBytes = n; }//		memcpy((void *)c1, (void *)c2, NumBytes);		n -= NumBytes;		ch1 += NumBytes;		ch2 += NumBytes;		while(NumBytes--) *c1++ = *c2++;    }#endif//=============================================================================// Fast. Only hand borland's inline memcpy small amounts// 			Unknown how much smaller than 0xffff to give it. (0xffff messes up).//-----------------------------------------------------------------------------#if TRUE	char huge *ch1 = (char huge *)s1;	char huge *ch2 = (char huge *)s2;	char *c1, *c2;	unsigned long BytesToSegBndry, NumBytes;	while(n > 0)    {		c1 = (char *)ch1;		c2 = (char *)ch2;		if(OFFSETOF(c1) > OFFSETOF(c2))			{			BytesToSegBndry = (unsigned long)0x10000 - (unsigned long)OFFSETOF(c1);			}		else			{			BytesToSegBndry = (unsigned long)0x10000 - (unsigned long)OFFSETOF(c2);			}		if (BytesToSegBndry > 0x7FFFL) BytesToSegBndry = 0x7FFFL;   //MUST be .LT. 0x10000(16bit counter)		if(BytesToSegBndry < n)			{			NumBytes = BytesToSegBndry;			}		else			{			NumBytes = n;			}		memcpy((void *)c1, (void *)c2, NumBytes);		n -= NumBytes;		ch1 += NumBytes;       	ch2 += NumBytes;    }#endif}#endif //WINDOWS//jam 12-15-93 memcopy which can cross segment boundaries ]]]intV_Array::cArray(long ln,long sz,long blk)     // ABD MERGE-BUG2	{	long bytes;	if (blk == 0) blk = 1;		// prevent zero length allocations#if MACINTOSH &&USELOCK	blk<<=1; //this is to minimize the number of SetLength() resizes that occur#endif	if(ln==0)allocLength=blk;	else		{		allocLength=(ln+blk-1)/blk;		allocLength*=blk;		}	allocBlock=blk;	bytes=allocLength*sz;	length=ln;	size=sz;#if MACINTOSH            // ABD JAN95	parray = NULL;		// ABD JAN95#endif // MACINTOSH 	ABD JAN95	if(ln)byteLoc=ln*sz;	else byteLoc=0;	lockCount=0;#if WINDOWS&&DEBUG	if(bytes > 0x0000FFFFL)	{    	AlertMessage("V_Array::cArray 64Kbyte limit exceeded!");    }#endif	array=NewHandle(bytes);	if (array) 			{#if MACINTOSH&USELOCK		V_Array *theArray;		theArray=this;		masterIndex=AddMasterArray(&theArray);#endif		return(VARY_SUCCESS);		}	else		{#if MACINTOSH&USELOCK		CompactArrays(); // try to make another block		array=NewHandle(bytes);		if (array) 				{			V_Array *theArray;			theArray=this;			masterIndex=AddMasterArray(&theArray);			return(VARY_SUCCESS);			}#endif		/* if not enough mem, then set length to zero, so we won't        screw up lower memory */		length = 0;        allocLength = 0;        byteLoc = 0;		return(VARY_LOWMEM);        }	}void V_Array::dArray()	{#if MACINTOSH&&USELOCK	V_Array *theArray;	theArray=this;	RemoveMasterArray(masterIndex);	if(parray)HUnlock(array);#else	if(lockCount>0)HUnlock(array);#endif	DisposHandle((Handle)array);	delete(this);	}int V_Array::IO(struct V_Buffer *buffer)	{	int err;	Use();	err = buffer->IOData((void *)(char*)HDeref(array),length*size);	Unuse();	return err;	}	longV_Array::Find(void *v)	{	long i,j;	char *val;	char *a;	//	HLock(array);		bad idea.  jca 27 Sept 93 (it may already be locked)	a=(char*)HDeref(array);	val=(char*)v;	for(i=0;i<length;i++)		{		for(j=0;j<size;j++)			{			if(val[j]!=a[i*size+j])break;			}		if(j==size){ /*HUnlock(array);*/ return(i); }		}//	HUnlock(array);		bad idea.  jca 27 Sept 93 (in which case this would unlock it)	return(VARY_NOTFOUND);	}int V_Array::SetLength(long ln)	{	Handle narray;	char *n,*a;		if(lockCount>0)return(VARY_LOCKED);	if(ln>allocLength)		{		long oldAllocLength = allocLength;#if MACINTOSH&&USELOCK		if(parray)HUnlock(array);		parray=NULL;#endif			allocLength=(ln+allocBlock-1)/allocBlock; allocLength*=allocBlock;#if WINDOWS&&DEBUG	if(allocLength*size > 0x0000FFFFL)		{ //			AlertMessage("V_Array::setLength 64Kbyte limit exceeded!");	    }#endif		narray=NewHandle(size*allocLength);		if (!narray)			{            /* leave the V_Array as we found it */			allocLength = oldAllocLength;			return(VARY_LOWMEM);        	}		n=(char*)HDeref(narray);	    a=(char*)HDeref(array);//jam 12-15-93 memcopy which can cross segment boundaries [[[#if WINDOWS		if(length>0)Vhugememcpy(n,a,byteLoc);#else		if(length>0)Vmemcpy(n,a,byteLoc);#endif//jam 12-15-93 memcopy which can cross segment boundaries ]]]		DisposHandle((Handle)array);		array=narray;		}	length=ln;	byteLoc=length*size;	return(VARY_SUCCESS);	}int V_Array::Append(void *v)	{	Handle narray;	long i;	char *val;	char *n,*a;		val = (char*)v;	if(length==allocLength)		{		if(lockCount>0)return(VARY_LOCKED);#if MACINTOSH&&USELOCK		if(parray)HUnlock(array);		parray=NULL;#endif		allocLength+=allocBlock;#if WINDOWS&&DEBUG	if(allocLength*size > 0x0000FFFFL)		{    		AlertMessage("V_Array::Append 64Kbyte limit exceeded!");	    }#endif		narray=NewHandle(size*allocLength);		if (!narray)			{            /* leave the V_Array as we found it */			allocLength -= allocBlock;			return(VARY_LOWMEM);        	}		n=(char*)HDeref(narray);	    a=(char*)HDeref(array);//jam 12-15-93 check for segment crossing [[[#if DEBUG && WINDOWS		if((byteLoc >= 0x00010000L) || SPANNEDHUGE(n,n+byteLoc-1) || SPANNEDHUGE(a,a+byteLoc-1))    	    DEBUGGER();#endif//jam 12-15-93 check for segment crossing ]]]		Vmemcpy(n,a,byteLoc);		DisposHandle((Handle)array);		array=narray;		}	a=(char*)HDeref(array);	for(i=0;i<size;i++)		a[byteLoc++]=val[i];	length++;	return(length-1);	}int V_Array::Insert(long loc,void * v)	{	Handle narray;	long i;	long byteloc=loc*size;	char *val;	char *a,*n;	val = (char*)v;		if(loc<0||loc>length)return(VARY_RANGE);	if(length==allocLength)		{		if(lockCount>0)return(VARY_LOCKED);#if MACINTOSH&&USELOCK		if(parray)HUnlock(array);		parray=NULL;#endif		allocLength+=allocBlock;#if WINDOWS&&DEBUG	if(allocLength*size > 0x0000FFFFL)		{			AlertMessage("V_Array::Insert 64Kbyte limit exceeded!");	    }#endif		narray=NewHandle(size*allocLength);		if (!narray)			{            /* leave the V_Array as we found it */			allocLength -= allocBlock;			return(VARY_LOWMEM);        	}		n=(char*)HDeref(narray);	    a=(char*)HDeref(array);//jam 12-15-93 check for segment crossing [[[#if DEBUG && WINDOWS		if(allocLength*size >= 0x00010000L) DEBUGGER();		//if the size >= 64k, one of the following 3 lines is guaranteed to involve        //seg crossing#endif//jam 12-15-93 check for segment crossing ]]]		if(loc>0)Vmemcpy(n,a,byteloc);		if(loc<length)Vmemcpy(n+byteloc+size,a+byteloc,(length-loc)*size);		for(i=0;i<size;i++)n[byteloc+i]=val[i];		DisposHandle((Handle)array);		array=narray;		}	else		{	    a=(char*)HDeref(array);		if(loc<length)Vmemmove(a+byteloc+size,a+byteloc,(length-loc)*size);		for(i=0;i<size;i++)a[byteloc+i]=val[i];		}	byteLoc+=size;	length++;	return(VARY_SUCCESS);	}int V_Array::Remove(long loc)	{	Handle narray;	long i,byteloc;	char *a;		if(loc<0||loc>=length)return(VARY_RANGE);	byteloc=loc*size;	a=(char*)HDeref(array);	if(loc<length-1)Vmemmove(a+byteloc,a+byteloc+size,(length-loc-1)*size);	length--;	byteLoc-=size;	return(VARY_SUCCESS);	}	int V_Array::Get(long loc,void * v)	{	long byteloc;	int i;	char *val,*a;		if(loc<0||loc>=length)return(VARY_RANGE);	val = (char*)v;	byteloc=loc*size;//	HLock(array);		bad idea.  jca 27 Sept 93 (it may already be locked)	a=(char*)HDeref(array);	for(i=0;i<size;i++)		val[i]=a[byteloc+i];//	HUnlock(array);		bad idea.  jca 27 Sept 93 (and this would unlock it)	return(VARY_SUCCESS);	}		void * V_Array::GetAddress(long loc)	{	long byteloc;		if(loc<0||loc>=length)return(NULL);	byteloc=loc*size;	return (char*)HDeref(array)+byteloc;	}	int V_Array::Put(long loc,void * v)	{	long byteloc=loc*size;	int i;	char *val,*a;		if(loc<0||loc>=length)return(VARY_RANGE);	val = (char*)v;//	HLock(array);		bad idea.  jca 27 Sept 93 (it may already be locked)	a=(char*)HDeref(array);	for(i=0;i<size;i++)a[byteloc+i]=val[i];//	HUnlock(array);		bad idea.  jca 27 Sept 93 (in which case this would unlock it)	return(VARY_SUCCESS);	}int V_Array::Exchange(long loc1,long loc2)	{	long byteloc1;	long byteloc2;	unsigned char c;	char *a;	int i;		if(loc1<0||loc1>=length||loc2<0||loc2>=length)return(VARY_RANGE);	byteloc1=loc1*size;	byteloc2=loc2*size;//	HLock(array); DAS-VARRAY 10/2/93 bad idea, might already be locked	a=(char*)HDeref(array);	for(i=0;i<size;i++)		{		c=a[byteloc1+i];		a[byteloc1+i]=a[byteloc2+i];		a[byteloc2+i]=c;		}//	HUnlock(array); DAS-VARRAY 10/2/93 bad idea, might already be locked	return(VARY_SUCCESS);	}void V_Array::Reverse()	{	register char *ca, *p1, *p2, c;	long i, j,l;		l=length/2;//	HLock(array);DAS-VARRAY 10/2/93 bad idea, might already be locked	ca = (char*)HDeref(array);	for (i = 0; i < l; i++)		{		p1 = ca + i*size;		p2 = ca + (length-1-i)*size;			for (j = 0; j < size; j++)			{			c = *p1;			*p1++ = *p2;			*p2++ = c;			}		}//	HUnlock(array);DAS-VARRAY 10/2/93 bad idea, might already be locked	}int V_Array::CopyArray(V_Array *to)	{	long bytelength,tobytelength;	char *t,*a;		if(to->lockCount>0)return(VARY_LOCKED);	bytelength=size*length;	if(to->size!=size||to->allocBlock!=allocBlock)		{		tobytelength=to->allocLength*to->size;		to->allocLength=tobytelength/(size*allocBlock);		to->allocLength*=allocBlock;		to->size=size;		to->allocBlock=allocBlock;		}	to->SetLength(length);	t=(char*)HDeref(to->array);	a=(char*)HDeref(array);//jam 12-15-93 memcopy which can cross segment boundaries [[[#if WINDOWS	if(length>0)Vhugememcpy(t,a,bytelength);#else	if(length>0)Vmemcpy(t,a,bytelength);#endif//jam 12-15-93 memcopy which can cross segment boundaries ]]]	return(VARY_SUCCESS);	}void * V_Array::Use()	{#if MACINTOSH&&USELOCK	lockCount++;	if(parray)return parray;	else 		{		if (lockCount==1)HLock(array);		return parray=((char *)HDeref(array));		}#else	if (lockCount++==0)HLock(array);	return((char*)HDeref(array));#endif	}void V_Array::Unuse()	{#if MACINTOSH&&USELOCKlockCount--;#else	if(--lockCount==0)HUnlock(array);#endif	}void *V_Array::Abuse()	{#if MACINTOSH&&USELOCK	if(parray)return parray;	else#endif		return((char*)HDeref(array));	}long V_Array::ALength() { return(length); }void V_Array::QuickSort() 	{ 	Use(); // DAS-VARRAY 10/2/93 this guy might already be locked	QS(0,length-1); 	Unuse(); // DAS-VARRAY 10/2/93 this guy might already be locked	}int dx=40;void V_Array::QS(long from,long to)	{	long i,j,k;	char *cdata,*idata,*jdata;	char *a;		i=from+1;	j=to;	a=(char*)HDeref(array); //assumes that it is already locked	cdata=a+from*size;/*this is the first element*/	idata=a+i*size;	jdata=a+j*size;	while(i<=j)		{		while(j>=from && Compare(cdata,jdata)<=0)			{			j--;			jdata-=size;			}		while(i<=to && Compare(cdata,idata)>0)			{			i++;			idata+=size;			}		if(i<j)			{			Exchange(i,j);			i++;			idata+=size;			j--;			jdata-=size;			}		}	if(j>from)		{		Exchange(from,j);		j--;		if(j>from)QS(from,j);		}	if(i<to)QS(i,to);	}#if FALSEvoid V_Array::InsertSort()	{	long top=length-1;	register int i,item;	register char *idata,*jdata;	short **stackHandle;	int localStack[110];	short *stack;	int stackTop=0;		if(length>100)		{		stackHandle=(short **)NewHandle(length*sizeof(short));		stack= *stackHandle;		}	else stack=localStack;		while(top)		{		if(stackTop)/*pop the stack*/			{			stackTop--;			item=stack[stackTop];			}		else item=0;		jdata=(*array);		jdata+=size*item;		idata=jdata+size;		for(i=item+1;i<=top;i++,idata+=size)			{			if(Compare(idata,jdata)>0)				{				stack[stackTop]=item;/*save this guy where he was*/				stackTop++;				item=i;				jdata=idata;				}			}		if(item!=top)Exchange(item,top);		top--;		}	if(length>100)DisposHandle((Handle)stackHandle);	}#endif#if TRUEvoid V_Array::InsertSort()	{	long top;	register int i,j;	register char *idata,*jdata;	char *a;		if(length<=1)return;		j=0;	top=length-1;	Use(); // DAS-VARRAY 10/2/93 this guy might already be locked	a=(char*)HDeref(array);	jdata=a;	while(top)		{		idata=jdata+size;		i=j+1;		while(i<=top && Compare(idata,jdata)<=0) /*i less than or equivalent than j?*/			{			idata+=size;			i++;			}		if(i==top+1)/*j made it to the top of the list*/			{			Exchange(j,top);			if(j)				{				j--;/*get the next item to carry up*/				jdata-=size;				}			top--;			}		else /*move the found object down to the bottom and start again*/			{			if(j+1!=i)Exchange(j+1,i);			jdata+=size;			j++;			}		}	Unuse();// DAS-VARRAY 10/2/93 this guy might already be locked	}#endifint V_Array::Compare(void *data1, void *data2) { return(0); }voidV_Array::InsertArray(V_Array *a, int i)	{	int j;	Handle h;	char *c;		h=NewHandle(a->size);	c=(char*)HDeref(h);	j = a->ALength();	while (j-- > 0)		{		a->Get(j, c);		Insert(i, c);		}	DisposHandle(h);	}voidV_Array::RemoveRange(int i, int j)	{	while (i <= j)		{		Remove(i);		j--;		}	}intV_Array::Push(void *thing){	return(Append(thing));}void *V_Array::Pop(void *thing){	if (byteLoc-size<0)		return(NULL);	else		{		char *a;		byteLoc-=size;		length--;a=(char*)HDeref(array);		Vmemmove(thing,a+byteLoc,size);		}	return(thing);}#if MACINTOSH/* The masterArray is the array containing ALL other arrays. They are installed into	here when they are created. The default state of the arrays is to be locked. If	the heap begins to fragment, this array is used to completely unlock all of the	arrays (that are not in use) compact the heap, and then lock them all again. This	array is always kept as a handle. */MasterArray *masterArray;int MasterArray::cArray(long ln,long sz,long blk)       // ABD MERGE-BUG2	{	queueHead=0;	V_Array::cArray(ln,sz,blk);	}	void MasterArray::dArray(void)	{	if(lockCount>0)HUnlock(array);	DisposHandle((Handle)array);	delete(this);	}void InitArrays(void)	{	masterArray=new(MasterArray);	masterArray->cArray(0,sizeof(V_Array *),256);	}	int CompactArrays(void)															//GJR 10/26/93	{	int didSomething = FALSE;		// return a flag for doing any changes (not counts cuz may wrap)	//GJR 10/26/93#if USELOCK	V_Array **aOFa;	V_Array *a;	long i,l;	aOFa=(V_Array **)masterArray->Use();	l=masterArray->ALength();	for(i=0;i<l;i++,aOFa++)		{		a=*aOFa;		if((!(((long)a)&0x01)) && a->lockCount==0 && a->parray)			{			HUnlock(a->array);			a->parray=NULL;			didSomething = TRUE;		// tell the world we accomplished a change // GJR 10/26/93			}		}	masterArray->Unuse();	// DAS-Insure that the master array is ALWAYS unlocked so that it can move around.	if(masterArray->parray)		{		HUnlock(masterArray->array);		masterArray->parray=NULL;		}	CompactMem(maxSize); // compact the heap#endif	return (didSomething);											// GJR 10/26/93	}	long AddMasterArray(V_Array **array)	{	long *data=(long*)masterArray->Abuse();	long index;	if(masterArray->queueHead) // is there already a place to put this?		{		index=masterArray->queueHead; // this is the first free spot		masterArray->queueHead=data[index]>>1; // this is the next free spot		masterArray->Put(index,array); // fill the old spot with the array data		}	else  // all filled up, need more room		{		masterArray->Append(array); // add the array to the end		index=masterArray->length-1;		}	return index;	}	void RemoveMasterArray(long index)	{	long *data=(long*)masterArray->Abuse();		if(masterArray->queueHead)		{		data[index]=0x01|(masterArray->queueHead<<1); // now data[index] is the location of the last freed object		masterArray->queueHead=index;	// queueHead is the location of this freed object		}											// make sure that it is an odd value	else			{		data[index]=0x01;					// this is the start of the linked list		masterArray->queueHead=index;	// this points to the start of the linked list		}	}#endif // MACINTOSH/* DAS-VARRAY 10/2/93  * Vmempy and Vmemmove are essentially duplicates of the standard C/C++ library routines * that we would ordinarily be using here. The reason that they are HERE is because * V_Array uses these items in a fairly loose way moving essentially unlocked handles  * around. Now this can be a problem if the segment containing Vmemcpy is NOT already * loaded into memory. Since the arguments to this routine are POINTERS, we need to  * dereference the handles that we wish to copy. Thus, the stack now has values on it * that point to an area of memory that can change if a memory event occurs. Loading in * a code segment, for instance one that might contain Vmemcpy, is just such an event. This * invalidates the dereferenced data causing no small amount of difficulty for the hapless  * programmer. Note that this is fixable in one of two ways: * 1) Lock everything, all the time. Just to be sure. This allows you to sleep at night *    but unfortunately, takes a lot of time. Don't do it this way. * 2) Make sure that these routines that move memory are ALREADY IN MEMORY when they are *    called. How do we do this? Since the only place we care about this bizarre behavior *    is inside of V_Arrays, they should be as close to this class as possible and sure *    enough, here they are. DON'T MOVE THEM...EVER. * * Isn't it nice to know that Windows avoids this problem by having their memory management * written by simpletons? */#ifndef __powerc#if THINK_C||THINK_CPLUS // DAS-C++ 10/2/93void *Vmemcpy(void *s1, void *s2, size_t n ){	asm {		move.l	s1,d0		;  D0.L = result		movea.l	d0,a0		;  A0 = s1		movea.l	s2,a1		;  A1 = s2		move.l	n ,d1		;  D1.L = n		bra.s	@2@1		move.b	(a1)+,(a0)+		subq.l	#1,d1@2		bne.s	@1	}}void *Vmemmove( void *s1, void *s2, size_t n){	asm {		move.l	s1,d0		;  D0.L = result		movea.l	d0,a0			;  A0 = s1		movea.l	s2,a1		;  A1 = s2		move.l	n,d1		;  D1.L = n		beq.s	@3		cmpa.l	a0,a1		bhi.s	@2		adda.l	d1,a0		adda.l	d1,a1@1		move.b	-(a1),-(a0)		subq.l	#1,d1		bne.s	@1		bra.s		@3@2		move.b	(a1)+,(a0)+		subq.l	#1,d1		bne.s	@2@3	}}#endif //THINK_C#endif // not def __powerc