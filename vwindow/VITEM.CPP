/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *			 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Platform: 	MACINTOSH 	X *				WINDOWS		 * Notes: FOR WINDOWS  *	1)The GetStockObject(font) call returns an identifier for the proper font. This ID * is used by the SelectObject() call to load the proper font before drawing. We will * not be using True Type fonts, bet rather guarentee that each font requested by  * V_Windows applications are available at those identifiers. Currently there is no  * support for alternate text faces. *	2) GetAppInstance() returns the application instance this Control belongs to. * 	3) GetParentWindow() returns the parent window of this child window. * * 	„ Need to figure out how scrollbar control is done. This may need a callback. *	„ V_Text only supports normal facing and guarenteed fonts. * History:  *------------------------------------------------------------------------------ */#include "AppText.h"#include "VTypes.h"#include "VItem.h"#include "VWindow.h"#include "VPane.h"#include "VDocumnt.h"#include "VDialog.h"#include "VGraphic.h"#include "VGUtil.h"#include "VMain.h"#include "VMenu.h"#include "VTextDef.h"  // for the V_Control.  It must know what type of buttons it has#include "IntfDlog.h"#include "Misc.h"#include "AppDeflt.h"#include <string.h>voidV_Item::cItem()	{	VStyleRec	style;	thePane = NULL;	// BILBIL - 12/01/93 {{{	style.just = vJustLeft;	style.font = vDefTextFont;	style.face = vDefTextFace;	style.size = vDefTextSize;	style.textFlags = TEXT_AUTOFORMAT|TEXT_ERASE;	SetStyle(&style);	// BILBIL - 12/01/93 }}}	}void V_Item::dItem() { delete this; }void V_Item::Display() { }void V_Item::Idle() { }#if WINDOWSHWND V_Item::FindControl(DWORD cntrl, int code) {  return NULL; }void V_Item::FocusOn() { }#endif //WINDOWSlong V_Item::GetControlType(){ return(0L); } // jca 31Jan94int V_Item::MouseDown(Point p, long modifiers) { return FALSE; }int V_Item::Track(Point p, long modifiers) { return TRUE; }void V_Item::SetDisplay(VGrafPort port) { }void V_Item::Install(V_Pane *pane) { thePane = pane;	 }void V_Item::Uninstall() { thePane = NULL; }void V_Item::SetRect(Rect *r) { bounds = *r; }void V_Item::GetRect(Rect *r) { *r = bounds; }void V_Item::Activate(int state) { }int  V_Item::GetActiveState() { return TRUE; }void V_Item::Tab() { }voidV_Item::SetStyle(VStyleRec *style)	{	just = style->just;	font = style->font;	face = style->face;	size = style->size;	textFlags = style->textFlags;	}	voidV_Item::GetStyle(VStyleRec *style)	{	style->just = just;	style->font = font;	style->face = face;	style->size = size;	style->textFlags = textFlags;	}#if MACINTOSH/* Returns the item's rectangle, in the window's coordinate system.  bounds * is normally in the pane's coordinate system. */voidV_Item::GlobalRect(Rect *r)	{	*r = bounds;		r->left+=thePane->paneRect.left;	r->right+=thePane->paneRect.left;	r->top+=thePane->paneRect.top;	r->bottom+=thePane->paneRect.top;	}#endif //MACINTOSHvoidV_Text::cItem()	{	V_Item::cItem();	text = NULL;	}voidV_Text::dItem()	{	if(NULL != text)		DisposHandle((Handle)text);	V_Item::dItem();	}voidV_Text::SetUp()	{	VSetFont(font,size,face);	if(!(textFlags&TEXT_ERASE))		VTextMode(vSrcXor);	}voidV_Text::UnSetUp()	{	VSetFont(vDefTextFont,vDefTextSize,vDefTextFace);	if(!(textFlags&TEXT_ERASE))		VTextMode(vSrcOr);	}voidV_Text::Display()	{	Rect r;	char *textPtr;	int	length;		if (text && thePane && thePane->theWindow 		 && thePane->theWindow->Visible())		{		GetRect(&r);		SetUp();				HLock((Handle)text);		textPtr = (char *)HDeref(text);		length = strlen(textPtr);#if MACINTOSH		if(textFlags&TEXT_AUTOFORMAT)					TextBox(textPtr, length, &r, just);		else			VDrawText(textPtr,0,length,&r);#elif WINDOWS		 //		SetTextAlign(currentDevice,just);		if (currentDevice)			{	// BILBIL - this tries to output multiple lines if we can, else do the regular stuff - 11/24/93			if (! DrawText(currentDevice,textPtr,length,&r,					DT_LEFT|DT_NOPREFIX|DT_WORDBREAK))			TextOut(currentDevice,r.left, r.top,textPtr,length);            }#endif //WINDOWS				HUnlock((Handle)text);				UnSetUp();		}	V_Item::Display();	}voidV_Text::SetText(strPtr str)	{	char *textPtr;	if(NULL != text)		DisposHandle((Handle)text);	text = NewHandle(strlen((char *)str)+1);		HLock((Handle)text);	textPtr = (char *)HDeref(text);	strcpy(textPtr, str);	HUnlock((Handle)text);	}voidV_Text::GetText(strPtr str)	{	char *textPtr;	HLock((Handle)text);	textPtr = (char *)HDeref(text);	strcpy(str, textPtr);	HUnlock((Handle)text);	}intV_Text::TextLength()	{    char *textPtr;	int n;	HLock((Handle)text);	textPtr = (char *)HDeref(text);	n = strlen(textPtr);	HUnlock((Handle)text);    return(n);    }voidV_EditText::cItem()	{	V_Text::cItem();	text = NULL;	frame = DEFAULT_FRAME;	}voidV_EditText::dItem(void)	{	if (NULL != textbox)#if MACINTOSH				TEDispose(textbox);#elif WINDOWS				DestroyWindow(textbox);#endif //WINDOWS	V_Text::dItem();	}voidV_EditText::Install(V_Pane *pane)	{	Rect r;	char *textPtr;	long winStyle;	V_Text::Install(pane);		if(NULL == text) 		SetText("");		GetRect(&r);	SetUp();	HLock((Handle)text);	textPtr = (char *)HDeref(text);#if MACINTOSH			textbox = TENew(&r, &r);	TESetText(textPtr, strlen(textPtr), textbox);	TESetJust(just,textbox);	pane->itemList->AddTabItem(this);#elif WINDOWS	winStyle = WS_CHILD|WS_VISIBLE|WS_BORDER|WS_TABSTOP|WS_GROUP;//|ES_AUTOHSCROLL|ES_LEFT;	textbox = CreateWindowEx(WS_EX_NOPARENTNOTIFY,"EDIT",textPtr,winStyle,		r.left,r.top,(r.right - r.left),(r.bottom - r.top),thePane->GetParentWindow(),		IDC_VIRTUS,GetAppInstance(),NULL);	SendMessage(textbox,WM_SETFONT,GetFont(font,size,face),MAKELONG(FALSE,0));#endif //WINDOWS	HUnlock((Handle)text);	UnSetUp();	}voidV_EditText::Uninstall(void)	{	char 	str[256];	int		n;	if(NULL != textbox)		{		GetText(str);#if MACINTOSH				thePane->itemList->RemoveTabItem(this);		TEDispose(textbox);#elif WINDOWS		DestroyWindow(textbox);#endif //WINDOWS				textbox = NULL;		thePane->SetText(NULL); /* this probably shouldnt be handled here */		SetText(str);		}	}voidV_EditText::Display(void)	{	Rect r;		VGrafPort port;	VGrafPort savePort;    VGrafDevice saveDevice;		// MERGE-GOURAUD-PRO-4	GetRect(&r);#if MACINTOSH			(*textbox)->destRect = r;	(*textbox)->viewRect = r;	VGetPort(&savePort, &saveDevice);		// MERGE-GOURAUD-PRO-4	VSetPort((*textbox)->inPort, NULL);		// MERGE-GOURAUD-PRO-4	VEraseRect(&r);	VSetPort(savePort, saveDevice);		// MERGE-GOURAUD-PRO-4	TEUpdate(&r, textbox);		if (frame)		{		VGetPort(&savePort, &saveDevice);		// MERGE-GOURAUD-PRO-4		VSetPort((*textbox)->inPort, NULL);		// MERGE-GOURAUD-PRO-4		InsetRect(&r,-frame,-frame);		PenNormal();		FrameRect(&r);		//GetWMgrPort(&port);		//if (thePort == port)		// 	DEBUGSTR((UChar*)"\pAck!  WMgr Port!  Go get Drew!");	// MERGE-GOURAUD-PRO-8		VSetPort(savePort, saveDevice);		// MERGE-GOURAUD-PRO-4		}#elif WINDOWS	RedrawWindow(textbox,NULL,NULL,RDW_INVALIDATE|RDW_UPDATENOW|RDW_NOCHILDREN);#endif //WINDOWS	}void V_EditText::SetDisplay(VGrafPort port)	{ #if MACINTOSH		//VGrafPort p2;  GetWMgrPort(&p2);	//if (port == p2)		//DEBUGSTR((UChar*)"\pAck!  WMgr Port!  Go get Drew!");	// MERGE-GOURAUD-PRO-8	(*textbox)->inPort = port;#endif //MACINTOSH	}#if WINDOWSHWNDV_EditText::FindControl(DWORD cntrl, int code)	{	if (cntrl!=textbox) return NULL;	if (code==EN_KILLFOCUS) Action(V_ENTER, 0);	return textbox;	}voidV_EditText::FocusOn()	{	if (textbox)    	SetFocus(textbox);    }#endif //WINDOWS	intV_EditText::MouseDown(Point p, long modifiers)	{	int result;	#if MACINTOSH	result = (VPtInRect(p,&bounds) ? TRUE : FALSE );	if(result)		{		VSetCursor(vCursorText);		thePane->SetText(this);		thePane->SetPane();		TEClick(p, (modifiers & V_SHIFT) ? TRUE : FALSE, textbox);		thePane->UnsetPane();		}#elif WINDOWS	result = FALSE;#endif //WINDOWS	return result;	}void V_EditText::Idle() 	{ 	VGrafPort port;	thePane->SetPane();#if MACINTOSH			TEIdle(textbox); #endif //MACINTOSH	thePane->UnsetPane();		//GetWMgrPort(&port);		//if (thePort == port)		// 	DEBUGSTR((UChar*)"\pAck!  WMgr Port!  Go get Drew!");	// MERGE-GOURAUD-PRO-8	}void V_EditText::SetFrame(int f) { frame = f; }voidV_EditText::Activate(int state)	{	if(NULL != textbox)		{		if (state) 			{#if MACINTOSH					TEActivate(textbox);#elif WINDOWS			EnableWindow(textbox,TRUE);			CreateCaret(textbox,NULL,NULL,NULL);#endif //WINDOWS			}		else			{			Action(V_CLEANUP, 0);#if MACINTOSH					TEDeactivate(textbox);			if (this==thePane->GetText()) 				thePane->theWindow->activeText = NULL;/* this is an awful reach */#elif WINDOWS			DestroyCaret();			EnableWindow(textbox,FALSE);#endif //WINDOWS			}		}	}voidV_EditText::SetRect(Rect *r)	{	Rect tr;		V_Text::SetRect(r);		if(NULL != textbox)		{		GetRect(&tr);#if MACINTOSH				(*textbox)->destRect = tr;		(*textbox)->viewRect = tr;		TECalText(textbox);#elif WINDOWS		MoveWindow(textbox,tr.left,tr.top,(tr.right - tr.left),(tr.bottom - tr.top),TRUE);#endif //WINDOWS		}	}voidV_EditText::SetText(strPtr str)	{	char *textPtr;	V_Text::SetText(str);		if(NULL != textbox)		{		HLock(text);		textPtr = (char *)HDeref(text);#if MACINTOSH				TESetText(textPtr, strlen(textPtr), textbox);#elif WINDOWS		SetWindowText(textbox,textPtr);#endif //WINDOWS		HUnlock(text);		}	}	voidV_EditText::GetText(strPtr str)	{	int n;	if (NULL != textbox)		{#if MACINTOSH				Handle s;		n = (*textbox)->teLength;		if (n > 255)	// MERGE-GOURAUD-PRO-7 255 chars max			n = 255;	// MERGE-GOURAUD-PRO-7		s = (Handle)TEGetText(textbox);		HLock((Handle)s);		strncpy((char *)str,*s,n);	// MERGE-GOURAUD-PRO-7		str[n]=0;					// MERGE-GOURAUD-PRO-7		HUnlock((Handle)s);#elif WINDOWS		n = GetWindowText(textbox,str,256);#endif //WINDOWS		V_Text::SetText(str);		}			V_Text::GetText(str);	}intV_EditText::TextLength()	{	int n;	if (NULL != textbox)		{#if MACINTOSH				n = (*textbox)->teLength;#elif WINDOWS		n = GetWindowTextLength(textbox);#endif //WINDOWS		}	else		n = V_Text::TextLength();    return(n);	}voidV_EditText::SetSelect(int begin, int end)	{ 	if(NULL != textbox) 		{#if MACINTOSH				TESetSelect(begin, end, textbox); #elif WINDOWS		long param = MAKELPARAM(begin,end);		SendMessage(textbox,EM_SETSEL,0,param);		SetFocus(textbox);	// jca.  I think this is the right place.#endif //WINDOWS		}	}voidV_EditText::Edit(char c, long modifier)	{	if(!Action(c, modifier))		{#if MACINTOSH				thePane->SetPane();			// MERGE-GOURAUD-PRO-4		TEKey(c, textbox);		thePane->UnsetPane();		// MERGE-GOURAUD-PRO-4#elif WINDOWS#endif //WINDOWS		}	}voidV_EditText::Tab()	{	thePane->SetPane();	thePane->SetText(this);	SetSelect(0, 32767);	thePane->UnsetPane();	}			intV_EditText::Action(char c, long modifier)	{	V_Item *item;	int theType;		if (modifier & V_COMMAND) return(FALSE);		switch(c)		{		case V_TAB:			thePane->itemList->Tab(this);			break;					case V_ENTER:		case V_RETURN:			// ABD MERGE-GOURAUD-PRO-10 [[[            #if MACINTOSH			theType=thePane->GetType();			if (theType==V_PANE_DIALOG)				((V_Dialog *)thePane)->CR();/* this is an awful reach as well */			// ABD ...it is an awful reach but no more idiotic than any other piece of code			// in this program.  Plus it's the only thing that makes enter and return work,			// so I'm putting it back in.  19 Sep 94			#endif			break;			// ABD MERGE-GOURAUD-PRO-10 ]]]					default:			return FALSE;			break;		}	return TRUE;	}// jca 22OCT94 PRO/PLAYER credits.  To do a multiline edit box under Windows, you// must give the ES_MULTILINE style, which makes all our other edit text items// stop working.  So this is to handle doing multiline boxes on the PC, which the mac// does right anyway.  [[[voidV_MultilineEditText::Install(V_Pane *pane)	{	Rect r;	char *textPtr;	long winStyle;	V_Text::Install(pane);		if(NULL == text) 		SetText("");		GetRect(&r);	SetUp();	HLock((Handle)text);	textPtr = (char *)HDeref(text);#if MACINTOSH			textbox = TENew(&r, &r);	TESetText(textPtr, strlen(textPtr), textbox);	TESetJust(just,textbox);	pane->itemList->AddTabItem(this);#elif WINDOWS	winStyle = ES_MULTILINE|WS_CHILD|WS_VISIBLE|WS_BORDER|WS_TABSTOP|WS_GROUP;//|ES_AUTOHSCROLL|ES_LEFT;	textbox = CreateWindowEx(WS_EX_NOPARENTNOTIFY,"EDIT",textPtr,winStyle,		r.left,r.top,(r.right - r.left),(r.bottom - r.top),thePane->GetParentWindow(),		IDC_VIRTUS,GetAppInstance(),NULL);	SendMessage(textbox,WM_SETFONT,GetFont(font,size,face),MAKELONG(FALSE,0));#endif //WINDOWS	HUnlock((Handle)text);	UnSetUp();	}// ]]] jca 22OCT94voidV_Control::cItem()	{	V_Item::cItem();	theControl = NULL;	text = NULL;	SetValue(0);	SetRange(0,1);	group = NULL;#if WINDOWS	theControlNumber = IDC_VIRTUS;#endif	}voidV_Control::dItem(void)	{	V_Control *cntrl;    int num;	cntrl = this;	if(NULL != group)		{		num = group->Find(&cntrl);		if(num>=0) group->Remove(num);		if(group->ALength() == 0)			group->dArray();        group = NULL;        }	if(NULL != theControl)		{#if MACINTOSH				DisposeControl(theControl);#elif WINDOWS		DestroyWindow(theControl);#endif //WINDOWS		theControl=NULL;		}	if(NULL != text)		DisposHandle((Handle)text);	V_Item::dItem();	}voidV_Control::Display(void)	{#if MACINTOSH			Draw1Control(theControl);#elif WINDOWS	RedrawWindow(theControl,NULL,NULL,RDW_INVALIDATE|RDW_UPDATENOW|RDW_NOCHILDREN);#endif //WINDOWS	V_Item::Display();	}void V_Control::SetDisplay(VGrafPort port)	{ #if MACINTOSH			(*theControl)->contrlOwner = port;#elif WINDOWS#endif //WINDOWS	}#if WINDOWSHWNDV_Control::FindControl(DWORD cntrl, int code)	{	if (cntrl != theControl) return NULL;	if (code == BN_CLICKED) Action();    return theControl;	}voidV_Control::SetCtrlNumber(int newCtrl)	{	theControlNumber = newCtrl;	}intV_Control::GetCtrlNumber(char *buttonText)	{    // what is the approriate window button id?	if (!strcmp(buttonText, TXTC_OK))			return(IDOK);	else if (!strcmp(buttonText, TXTC_CANCEL))	return(IDCANCEL);	else if (!strcmp(buttonText, TXTC_YES))		return(IDYES);	else if (!strcmp(buttonText, TXTC_NO))		return(IDNO);	else										return(IDC_VIRTUS);	}voidV_Control::FocusOn()	{	if (theControl)		SetFocus(theControl);    }voidV_Control::GetText(strPtr str)      	{	char newTitle[256],*textPtr;		if(NULL == text)    	{		str[0] = '\0';		return;        }	HLock((Handle)text);	textPtr = (char *)HDeref(text);	strcpy(str,textPtr);	HUnlock((Handle)text);	}voidV_Control::SetStyle(VStyleRec *style)	{	V_Item::SetStyle(style);	if (theControl)		SendMessage(theControl,WM_SETFONT,GetFont(font,size,face),			MAKELONG(FALSE,0));	}#endif //WINDOWSvoid	/* DUDE MJU */V_Control::Install(V_Pane *pane)	{	string className[256],*textPtr;	Rect r;#if WINDOWS    int	controlNumber;#endif		V_Item::Install(pane);		if(NULL == text)		SetText("");	GetRect(&r);	HLock(text);	textPtr = (char *)HDeref(text);	strcpy(className,textPtr);    // DAS-BUG FIX 10/7/93#if MACINTOSH			C2Pstr(className);	thePane->WindowPane();		// DAS-VWINDOWS-FIX 9/22/93	ClipRect(&thePane->paneRect); // DAS-VWINDOWS-FIX 9/22/93		theControl = NewControl(thePane->GetParentWindow(), &r, (ConstStr255Param)className, TRUE, value, minValue, maxValue, GetControlType(), 0);	SetCRefCon(theControl,(long)this);#elif WINDOWS	if(thePane->theWindow)  // DAS-BUGFIX 10/7/93        {		GetControlClass(className);		VStyleRec	style;		theControl = CreateWindowEx(WS_EX_NOPARENTNOTIFY,className,textPtr,GetControlType()|WS_CHILD|WS_VISIBLE,			r.left,r.top,(r.right - r.left),(r.bottom - r.top),thePane->GetParentWindow(),			theControlNumber,GetAppInstance(),NULL);		GetStyle(&style);		SetStyle(&style);		}		// DAX|S-BUGFIX 10/7/93#endif //WINDOWS	HUnlock(text);	}voidV_Control::Uninstall()	{	if(NULL != theControl)		{		V_Item::Uninstall();#if MACINTOSH				DisposeControl(theControl);#elif WINDOWS		DestroyWindow(theControl);#endif //WINDOWS		theControl = NULL;		}	}	voidV_Control::Activate(int state)	{	V_Item::Activate(state); 	if(NULL != theControl)		{#if MACINTOSH				HiliteControl(theControl, (state ? 0 : 255));#elif WINDOWS		EnableWindow(theControl,(state ? TRUE : FALSE));#endif //WINDOWS		}	}intV_Control::MouseDown(Point p, long modifiers)	{	int result;#if MACINTOSH			result = (TestControl(theControl, p)) ? TRUE : FALSE;	if(result)		{		VClipRect(&thePane->contRect);		if (TrackControl(theControl, p, NULL))			Action();		}#elif WINDOWS	result = FALSE;#endif //WINDOWS	return(result);	}longV_Control::GetControlType()	{#if MACINTOSH	return FALSE; #elif WINDOWS	V_Control *cntrl;    V_Array *grp;	long type=0;	cntrl = this;	if((grp=GetGroup()) == NULL || grp->Find(&cntrl)==0)    	type=WS_GROUP;	return type;#endif //WINDOWS	}#if WINDOWSvoid V_Control::GetControlClass(char *className) { strcpy(className,"BUTTON"); }#endif //WINDOWSint  V_Control::GetActiveState() 	{ 	int result;	if(NULL == theControl) result = FALSE;	else 		{#if MACINTOSH				result = ((*theControl)->contrlHilite ? TRUE : FALSE);#elif WINDOWS	 	result = TRUE;#endif //WINDOWS		}	return result;	}	void V_Control::Action() { }voidV_Control::SetRect(Rect *r)	{	Rect tr;    int vis;	if((r->top!=bounds.top) || (r->bottom!=bounds.bottom) || (r->left!=bounds.left) 		|| (r->right!=bounds.right))		{		V_Item::SetRect(r);		if (theControl && thePane)			{			GetRect(&tr);#if MACINTOSH			vis = (thePane->theWindow && thePane->theWindow->Visible())?TRUE:FALSE;			if(vis) HideControl(theControl);			MoveControl(theControl,tr.left,tr.top);			SizeControl(theControl,tr.right-tr.left,tr.bottom-tr.top);			if(vis)ShowControl(theControl);#elif WINDOWS			MoveWindow(theControl,tr.left,tr.top,(tr.right - tr.left),(tr.bottom - tr.top),TRUE);#endif //WINDOWS			}		}	}voidV_Control::SetValue(int v)	{	value = v;	if(NULL != theControl)		{#if MACINTOSH				SetCtlValue(theControl, value);#elif WINDOWS		SendMessage(theControl,BM_SETCHECK,value,0);#endif //WINDOWS		}	}intV_Control::GetValue(void)	{	if(NULL != theControl) 		{#if MACINTOSH				value = GetCtlValue(theControl);#elif WINDOWS		value = SendMessage(theControl,BM_GETCHECK,0,0);#endif //WINDOWS		}	return value;	}voidV_Control::SetRange(int scrMin,int scrMax)	{	minValue = scrMin;	maxValue = scrMax;	if(NULL != theControl)		{#if MACINTOSH				SetCtlMin(theControl, minValue);		SetCtlMax(theControl, maxValue);#elif WINDOWS		if( SBS_VERT == GetControlType())			SetScrollRange(theControl,SB_CTL,minValue,maxValue,TRUE);#endif //WINDOWS		}	}voidV_Control::GetRange(int *scrMin,int *scrMax)	{	if(NULL != theControl)		{#if MACINTOSH				minValue = GetCtlMin(theControl);		maxValue = GetCtlMax(theControl);#elif WINDOWS		if( SBS_VERT == GetControlType())			GetScrollRange(theControl,SB_CTL,&minValue,&maxValue);#endif //WINDOWS		}	*scrMin = minValue;	*scrMax = maxValue;	}						voidV_Control::SetText(strPtr str)	{	char newTitle[256],*textPtr;		if(NULL != text)		DisposHandle((Handle)text);	text = NewHandle(strlen((char *)str)+1);		HLock((Handle)text);	textPtr = (char *)HDeref(text);	strcpy(textPtr,str);		if(NULL != theControl)		{#if MACINTOSH				strcpy(newTitle,textPtr);		C2Pstr(newTitle);		SetCTitle(theControl, (ConstStr255Param)newTitle);#elif WINDOWS		SetWindowText(theControl, textPtr);#endif //WINDOWS		}	HUnlock((Handle)text);	}	voidV_Control::SetGroup(V_Array *g)	{	V_Control *cntrl;	group = g;	if(NULL != group)		{		cntrl = this;		group->Append(&cntrl);		}	}V_Array *V_Control::GetGroup(void) { return group; }voidV_CtrlButton::cItem()	{	defFlag = FALSE;	V_Control::cItem();	}voidV_CtrlButton::Display()	{	Rect r;		V_Control::Display();			if (defFlag)		{		GetRect(&r);#if MACINTOSH				VSetPenSize(3,3);		VInsetRect(&r,-4,-4);		FrameRoundRect(&r,16,16);		VSetPenSize(1,1);#elif WINDOWS#endif //WINDOWS		}	}	voidV_CtrlButton::SetDefault(int f)	{	defFlag = f;#if WINDOWS	if(NULL != theControl && defFlag) SetFocus(theControl);#endif //WINDOWS	}intV_CtrlButton::GetDefault()	{	return defFlag;	}voidV_CtrlButton::Install(V_Pane *pane)	{	V_Control::Install(pane);#if WINDOWS	if(defFlag) SetFocus(theControl);#endif //WINDOWS	}longV_CtrlButton::GetControlType()	{#if MACINTOSH	return pushButProc; #elif WINDOWS	long type;	type = V_Control::GetControlType() | WS_TABSTOP;	type |= (defFlag ? BS_DEFPUSHBUTTON : BS_PUSHBUTTON);	return type;#endif //WINDOWS	}voidV_CtrlButton::Action(void)	{	long cTime;	#if MACINTOSH	cTime=VGetTime()+8;	HiliteControl(theControl, 1);	V_Control::Action();//	while(cTime>VGetTime());//	HiliteControl(theControl, 0);		HiliteControl(theControl, 0);	#elif WINDOWS	V_Control::Action();#endif //WINDOWS	}long V_CtrlCheck::GetControlType() 	{ #if MACINTOSH	return checkBoxProc; #elif WINDOWS	return V_Control::GetControlType() | WS_TABSTOP|BS_CHECKBOX;#endif //WINDOWS	}void V_CtrlCheck::Action() { SetValue(!GetValue()); }longV_CtrlRadio::GetControlType()	{ #if MACINTOSH	return radioButProc; #elif WINDOWS	long type;	type = V_Control::GetControlType();    if(type&WS_GROUP) type |= WS_TABSTOP;	type |= BS_RADIOBUTTON;	return type;#endif //WINDOWS	}voidV_CtrlRadio::Action(void)	{    V_Array *grp;	V_CtrlRadio **pItem,*radioItem;	int i,length,num;		if((grp=GetGroup()) != NULL)		{		radioItem = this;		length = grp->ALength();		num = grp->Find(&radioItem);		pItem = (V_CtrlRadio **)grp->Use();		for (i=0; i<length; i++,pItem++)			(*pItem)->SetValue((i==num) ? TRUE : FALSE);		grp->Unuse();		}	}longV_CtrlScrollBar::GetControlType()	{ #if MACINTOSH	return scrollBarProc; #elif WINDOWS	return SBS_VERT;#endif //WINDOWS	}#if WINDOWSvoid V_CtrlScrollBar::GetControlClass(char *className) 	{ 	strcpy(className,"Scrollbar"); 	}voidV_CtrlScrollBar::SetValue(int v)	{	value = v;	if(NULL != theControl)		SetScrollPos(theControl,SB_CTL,value,TRUE);	}	intV_CtrlScrollBar::GetValue()	{	if(NULL != theControl)		value = GetScrollPos(theControl,SB_CTL);	return value;	}#endif //WINDOWSintV_CtrlScrollBar::MouseDown (Point pt, long modifier)	{   										long theValue,lastValue,MaxTick; 						int	 maximum,minimum;	short	code;	int 	newcode,result;		result = TRUE;#if MACINTOSH	code = TestControl(theControl, pt);	result = code ? TRUE : FALSE;		if (!result) return result;	newcode = code;		GetRange(&minimum,&maximum);	lastValue=GetValue();		HiliteControl(theControl, code);	/* Darken the arrow */		do  									/* Do the scroll as long as the button is down */		{   								/* Timer used for repeat scrolling */		MaxTick = VGetTime() + scrollDelay;/* Time delay for auto-scroll */		theValue = GetValue();	/* Get current state */		if(newcode==code)			switch(code)			{			case inUpButton:			/* See if in the Up arrow */				theValue -= move;/* Subtract the single decrement */				if (theValue < minimum)   		/* Check for boundary conditions */					theValue = minimum;   		/* Pin at the start value */				break;			case inDownButton:  		/* See if in the Down arrow */				theValue += move;/* Add the single decrement */				if (theValue > maximum)    		/* Check for boundary conditions */					theValue = maximum;    		/* Pin at the stop value */				break;				case inPageUp:   			/* See if in the up/left grey area */				theValue -= page;/* Subtract the page increment */				if (theValue < minimum)   		/* Check for boundary conditions */				theValue = minimum;   		/* Pin at the Start value */				break;				case inPageDown:			/* See if in the down/right grey area */				theValue += page;/* Add the page increment */				if (theValue > maximum)    		/* Check for boundary conditions */					theValue = maximum;    		/* Pin at the Stop value */				break;			case inThumb:   			/* See if in the drag box area */				code = TrackControl(theControl, pt, NULL);/* Let the OS drag it around */				theValue = GetValue();/* Get current state */				break;			}			/*mod das 1/3/90 */		if(theValue!=lastValue)			{			SetValue(theValue);	/* Set new state */			thePane->SetPane();			Action();						/*do the thing*/			thePane->UnsetPane();			} 		lastValue=theValue;		do 								/* Start of delay routine */			 {  }   					/* Spin on doing nothing */		while ( (VButton() == TRUE) && (VGetTime() <= MaxTick));/* Exit when time up or mouse button up */		VGetMouse(&pt);		newcode=TestControl(theControl,pt);		}  								/* End for StillDown */	while (StillDown( ) == TRUE);  		/* End for StillDown */	FlushEvents(mUpMask,0);	HiliteControl(theControl, 0);		/* Lighten the arrow */#elif WINDOWS	result = FALSE;#endif //WINDOWS	return result;	}  									/* End for HandleWScrollBar */void V_CtrlScrollBar::SetSpeed(int i) { scrollDelay = i; }void V_CtrlScrollBar::SetPage(int i) { page = i; }void V_CtrlScrollBar::SetMove(int i) { move = i; }voidV_CtrlScrollBar::ScrollRate()	{	SetMove(8);	SetPage((min(thePane->contRect.right-thePane->contRect.left,		thePane->contRect.bottom-thePane->contRect.top))/2);	SetSpeed(9);	}#if MACINTOSHvoidV_PopMenu::cItem()	{	V_Text::cItem();    value = 0;    check_current_value = TRUE;		// ABD added for VPRO	popMenu = new(V_Menu);	popMenu->cMenu(TXT_EMPTYSTRING, ActiveDocument());    AddItems();	}voidV_PopMenu::dItem()	{    popMenu->dMenu();    V_Text::dItem();	}voidV_PopMenu::Display()	{	VSetPattern(vPatBlack);	VForeColor(&vBlack);	DrawDropRect(&popRect);    V_Text::Display();	}voidV_PopMenu::Reset()		// MERGE14	{	    value = 1;    if (popMenu)    	popMenu->dMenu();    	popMenu = new(V_Menu);	popMenu->cMenu(TXT_EMPTYSTRING, ActiveDocument());    AddItems();	}voidV_PopMenu::SetRect(Rect *r)	{	Rect nR;	char *textPtr;	nR = *r;	if(NULL != text)		{		SetUp();		HLock(text);		textPtr = (char *)HDeref(text);		nR.right = nR.left + VTextWidth(textPtr,0,strlen(textPtr)) + 1;		HUnlock(text);		}	V_Text::SetRect(&nR);	popRect = bounds;	popRect.top--;	popRect.bottom++;	popRect.left-=MENUPOP_PAD;	popRect.right+=MENUPOP_PAD;	}voidV_PopMenu::SetText(strPtr str)	{	Rect	r;	V_Text::SetText(str);	r = bounds;    SetRect(&r);    }intV_PopMenu::MouseDown(Point p,long modifiers)	{	int	result,newOne;	result = VPtInRect(p,&popRect);	if(TRUE == result)		{		p.h = popRect.left;		p.v = popRect.top;		if (check_current_value)		// VPRO			popMenu->Select(value,TRUE);		newOne = popMenu->PopUp(thePane,p,value);		if(newOne>0)			{			if (check_current_value)		// VPRO				popMenu->Select(value,FALSE);	// to unselect the check on the mac			SetValue(newOne);            Action();			}		}	return result;	}voidV_PopMenu::Action()	{	if (NULL != thePane)    	thePane->VDisplay(DRAW);	}voidV_PopMenu::SetValue(int v)	{	char str[256];	value = v;	popMenu->GetTitle(value,str);    SetText(str);	}intV_PopMenu::GetValue()	{    return(value);	}voidV_PopMenu::AddItems()	{	}		// added for VPRO [[[void V_PopMenu::SetCheckCurrentValue(int val){	check_current_value = val;}// added for VPRO ]]]voidV_PopMenu::Append(strPtr item)	{    popMenu->Append(item);    }// ABD MERGE11 WILLIAMS 9/10/93 [[[voidV_PopMenu::AppendSeparator()		{    popMenu->AppendSeparator();    }// ABD MERGE11 WILLIAMS 9/10/93 ]]]#elif WINDOWSlongV_PopMenu::GetControlType()	{	return WS_TABSTOP|WS_GROUP|WS_VSCROLL|CBS_DROPDOWNLIST|CBS_HASSTRINGS;	}voidV_PopMenu::GetControlClass(char *className)	{	strcpy(className,"COMBOBOX");	}HWNDV_PopMenu::FindControl(DWORD cntrl, int code)	{	if (cntrl != theControl) return NULL;	if (code == CBN_SELENDOK) Action();	return theControl;	}voidV_PopMenu::Install(V_Pane *pane)	{	V_Control::Install(pane);    AddItems();    }voidV_PopMenu::Action()	{	if (NULL != thePane)		{		GetValue();		thePane->VDisplay(DRAW);        }	}voidV_PopMenu::SetValue(int v)	{	value = v;	if(NULL != theControl)		SendMessage(theControl,CB_SETCURSEL,value-1,0);	}intV_PopMenu::GetValue(void)	{	if(NULL != theControl)		value = SendMessage(theControl,CB_GETCURSEL,0,0) + 1;	return value;	}voidV_PopMenu::AddItems()	{	}voidV_PopMenu::Append(strPtr item)	{	if(NULL != theControl)    	SendMessage(theControl,CB_ADDSTRING,0,(LPARAM)(LPCSTR)item);    }// BG - 11/1/93 [[[voidV_PopMenu::AppendSeparator()		{//	BG - ELVIS - we need to at least think of doing something here 11/01/93	}// BG - 11/1/93 ]]]intV_PopMenu::DroppedDown(void)	{	if(NULL != theControl)		return SendMessage(theControl,CB_GETDROPPEDSTATE,0,0);	else		return 0;	}#endif //WINDOWSvoidV_Icon::cItem()	{	V_Item::cItem();	id = 0;	icon = NULL;	}voidV_Icon::dItem()	{    // 12APR94 jca [[#if WINDOWS	DestroyIcon(icon);#endif // WINDOWS	V_Item::dItem();    // 12APR94 jca ]]	}voidV_Icon::SetIconID(int newId)	{	id = newId;#if MACINTOSH	icon = (Handle)GetIcon(id);#elif WINDOWS	// This will only load Windows system icons. Need to pass in    // the app instance if we need icons from the executable file.	icon = LoadIcon(NULL,MAKEINTRESOURCE(id));#endif //WINDOWS	}voidV_Icon::Display(void)	{	Rect r;	if (icon && thePane->theWindow && thePane->theWindow->Visible())		{		GetRect(&r);#if MACINTOSH		PlotIcon(&r, icon);#elif WINDOWS			DrawIcon(GetGraphicContext(),r.left,r.top,icon);#endif //WINDOWS		}	}voidV_OutlineBox::Display(void)	{	Rect r;	if (thePane->theWindow && thePane->theWindow->Visible())		{		GetRect(&r);		VForeColor(&vColorSlateD);		VFrameRect(&r);		VForeColor(&vBlack);		}	}voidV_ItemList::cItemList()	{	cArray(0,sizeof(V_Item *),4);	tabItems = NULL;	thePane = NULL;	}voidV_ItemList::dItemList(void)	{	V_Item **pItem;	int i;		if(NULL != tabItems)		tabItems->dArray();		pItem = (V_Item **)Use();	for (i=0; i<length; i++,pItem++)		(*pItem)->dItem();	Unuse();		dArray();	}// DeleteItems// get rid of the contents, but leave list ready for reuse//voidV_ItemList::DeleteItems(void)	{	V_Item **pItem;	int i;		if (tabItems)    	{		tabItems->SetLength(0);	// no more tab items, but keep memory		}	pItem = (V_Item **)Use();	for (i=0; i<length; i++,pItem++)		(*pItem)->dItem();	Unuse();	SetLength(0);			// no more array contents, but keep memory	}voidV_ItemList::Install(V_Pane *pane)	{	V_Item **pItem;	int i;		thePane = pane;		pItem = (V_Item **)Use();	for (i=0; i<length; i++,pItem++)		(*pItem)->Install(thePane);	Unuse();	}voidV_ItemList::Uninstall(void)	{	V_Item **pItem;	int i;		pItem = (V_Item **)Use();	for (i=0; i<length; i++,pItem++)		(*pItem)->Uninstall();	Unuse();	}intV_ItemList::Track(Point p, long modifiers)	{	V_Item **pItem;	Rect bR;	int i,result;		result = FALSE;		pItem = (V_Item **)Use();	for (i=0; i<length; i++,pItem++)		{		(*pItem)->GetRect(&bR);		if (VPtInRect(p,&bR))			result = (*pItem)->Track(p, modifiers);		if (result) break;		}	Unuse();		return result;	}voidV_ItemList::AddItem(V_Item *item)	{	if(VARY_NOTFOUND == Find(&item)) Append(&item);	if(NULL != thePane) item->Install(thePane);	}voidV_ItemList::RemoveItem(V_Item *item)	{	int i;		i = Find(&item);	if (i>=0)		{		item->Uninstall();		Remove(i);		}	}voidV_ItemList::AddTabItem(V_Item *item)	{	if(NULL == tabItems)		{		tabItems = new(V_Array);		tabItems->cArray(0,sizeof(V_Item*),4);		}	tabItems->Append(&item);	}voidV_ItemList::RemoveTabItem(V_Item *item)	{	int i;		if(NULL == tabItems) return;		i = tabItems->Find(&item);	if (i>=0) tabItems->Remove(i);	if(0 == tabItems->ALength())		{		tabItems->dArray();		tabItems = NULL;		}	}voidV_ItemList::Tab(V_Item *item)	{	int inum,tabLength;		if(NULL == tabItems) return;	tabLength = tabItems->ALength();		if(NULL != item) 		{		inum=tabItems->Find(&item);		inum=nextIndex(inum,1,tabLength);		}	else		inum=0;			tabItems->Get(inum,&item);	item->Tab();	}voidV_ItemList::Display()	{	V_Item **pItem;	int i;		pItem = (V_Item **)Use();	for (i=0; i<length; i++,pItem++)		(*pItem)->Display();		Unuse();	}voidV_ItemList::Activate(int state)	{	int i;	V_Item **pItem;		pItem = (V_Item **)Use();	for (i=0; i<length; i++,pItem++)		(*pItem)->Activate(state);			Unuse();	}//JAM altered 4-27 for VPRO texture and preference dialogs [[[intV_ItemList::MouseDown(Point p, long modifiers)	{#if 1	V_Item *pItem;	int i,inItem;		inItem = FALSE;		for (i = 0; i < length; i++)	{		Get((long) i, &pItem);		if(inItem = pItem->MouseDown(p, modifiers)) break;	}	return (inItem) ? (i+1) : FALSE;#endif#if 0	V_Item **pItem;	int i,inItem;		inItem = FALSE;		pItem = (V_Item **)Use();	for (i = 0; i < length; i++,pItem++)		if(inItem = (*pItem)->MouseDown(p, modifiers)) break;		Unuse();		return (inItem) ? (i+1) : FALSE;#endif	}	//JAM altered 4-27 for VPRO texture and preference dialogs ]]]#if WINDOWSHWND V_ItemList::FindControl(DWORD cntrl, int code)	{	V_Item  *pItem;	int 	i;	HWND	inItem;		inItem = FALSE;	for(i=0; i < length; i++)		{		// avoid locking, since lower routines may change this        // very control. // GJR 08/02/95        Get(i, &pItem);		if(inItem=(pItem)->FindControl(cntrl,code)) break;        }	return (inItem);	}V_Control *V_ItemList::FindControlType(int code)	{	V_Item **pItem;       // jca not all items in the list are controls.	int 	i;	int		inItem;		inItem = FALSE;	pItem = (V_Item**)Use();	for(i=0; i < length;i++,pItem++)		if((*pItem)->GetControlType() & code)			{			inItem = TRUE;			break;			}	Unuse();	if (inItem)		return ((V_Control*)*pItem);	else		return NULL;	}#endif //WINDOWS	voidV_ItemList::SetDisplay(VGrafPort port)	{	V_Item **pItem;	int i;		pItem = (V_Item **)Use();	for (i = 0; i < length; i++,pItem++)		(*pItem)->SetDisplay(port);	Unuse();	}//JAM added for merge VPRO 5-3-94 [[[/* Display() draws the text, if possible. */voidV_StatTextBox::Display(void)	{#if MACINTOSH	//need to do this routine for windows	Rect gr,ggr;	int width;	PenState ps;	if (thePane->theWindow && thePane->theWindow->theWindow && thePane->theWindow->Visible())		{		GetPenState(&ps);		GlobalRect(&gr);		TextFont(font);		TextFace(face);		TextSize(size);		HLock(text);//		VSetRect(ggr, gr.left, gr.top + 7, gr.right, gr.bottom)		ggr.left = gr.left; ggr.top = gr.top + 7; ggr.right = gr.right; ggr.bottom = gr.bottom;		PenNormal();		FrameRect(&ggr);		C2Pstr(*text);		width = StringWidth((StringPtr)*text);		P2Cstr(*text);//		VSetRect(ggr, gr.left + 3, gr.top, gr.left + width + 7, gr.top + 20)		ggr.left = gr.left+3; ggr.top = gr.top; ggr.right = gr.left+width+7; ggr.bottom = gr.top+20;		TextBox((StringPtr)*text, strlen((char *)*text), &ggr, just);		/*MoveTo(gr.left, gr.bottom);		DrawText((StringPtr)*text, 0,  strlen((char *)*text));*/		HUnlock(text);		TextFont(0);		TextFace(0);		TextSize(12);		SetPenState(&ps);		}	V_Item::Display();#elif WINDOWS	//need to do this routine for windows	V_Text::Display();#endif	}//JAM added for merge VPRO 5-3-94 ]]]	