/*------------------------------------------------------------------------------ * VWINDOWSt - the window object toolbox * Version 1.0 * * Copyright c 1989 by Virtus Corporation * All Rights Reserved * Written by David A. Smith * Virtus Corporation * 117 Edinburgh So. Suite 204 * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * V_Controller.c *------------------------------------------------------------------------------*/#include "VTypes.h"#if MACINTOSH#include "VIO.h"#include "VDocumnt.h"#include "VFile.h"#include "VError.h"#include <AppleEvents.h>pascal OSErr  OpenApplication(AppleEvent  *message, AppleEvent *reply, long refcon);pascal OSErr  OpenDocuments(AppleEvent *message, AppleEvent *reply, long refcon);pascal OSErr  QuitApplication(AppleEvent *message, AppleEvent *reply, long refcon);void SetUpHighLevelEvents(void);void DoHighLevelEvent(EventRecord *myEvent);pascal OSErr OpenApplication(AppleEvent  *message, AppleEvent *reply, long refcon){NewDocument(0L,INIT);return 0; /*no errors*/}/*this code is a paraphrase of the code in Inside Macintosh Volume VI, Listing 6-6 */pascal OSErr OpenDocuments(AppleEvent *message, AppleEvent *reply, long refcon){FSSpec myFSS;AEDescList  docList;OSErr err;long i, itemsInList,actualSize;AEKeyword  keyWd;DescType returnedType;V_File *file;/* get the direct parameter--a descriptor list--and put it into docList */if(err = AEGetParamDesc(message,keyDirectObject,typeAEList,&docList))	{	ResultError(err);	ExitToShell();	}/* count the number of descriptor records in the list */if(err = AECountItems(&docList,&itemsInList))	{	ResultError(err);	ExitToShell();	}/* now get the descriptor record from the list, get the alias record out of it,   and open the associated file */for(i=0;i<itemsInList;i++) 	{ 	if(err = AEGetNthPtr(&docList, i+1, typeFSS, &keyWd, &returnedType, 		(Ptr)&myFSS, sizeof(myFSS), &actualSize))	 	{		ResultError(err);		ExitToShell();		}	file=new(V_File);	file->AEFile(&myFSS);	NewDocument(file,refcon);	}if(err = AEDisposeDesc(&docList)) 	{	ResultError(err);	ExitToShell();	}return 0;}pascal OSErr QuitApplication(AppleEvent *message, AppleEvent *reply, long refcon){V_Document *doc;extern int mainNotDone;if(theSuper->ALength())	{	theSuper->Get(0,&doc);	if(!doc->Quit())/* someone did not want to exit!*/		return userCanceledErr;	}else mainNotDone=FALSE;/* main event loop flag */return 0; /* no errors here */}// In case we don't have the universal headers...#ifndef NewAEEventHandlerProc	#define NewAEEventHandlerProc(x)	(Ptr)x#endifvoid SetUpHighLevelEvents(void){OSErr err;err=AEInstallEventHandler(kCoreEventClass,kAEOpenApplication,NewAEEventHandlerProc(OpenApplication),0L,FALSE);if(err)	{	ResultError(err);	ExitToShell();	}err=AEInstallEventHandler(kCoreEventClass,kAEOpenDocuments,NewAEEventHandlerProc(OpenDocuments),LOADSTART,FALSE);if(err)	{	ResultError(err);	ExitToShell();	}err=AEInstallEventHandler(kCoreEventClass,kAEPrintDocuments,NewAEEventHandlerProc(OpenDocuments),PRINT,FALSE);if(err)	{	ResultError(err);	ExitToShell();	}err=AEInstallEventHandler(kCoreEventClass,kAEQuitApplication,NewAEEventHandlerProc(QuitApplication),0L,FALSE);if(err)	{	ResultError(err);	ExitToShell();	}}void DoHighLevelEvent(EventRecord *event){OSErr err;err=AEProcessAppleEvent(event);if(err)	ResultError(err);}#endif // MACINTOSH