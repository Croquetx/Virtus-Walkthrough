/*------------------------------------------------------------------------------ * VWINDOWSt - the window object toolbox * * Copyright c 1989 by Virtus Corporation * All Rights Reserved * Written by David A. Smith * 111 Gold Meadow Drive * Cary, North Carolina    27513 * (919) 469-8485 *------------------------------------------------------------------------------ * V_Display.h *------------------------------------------------------------------------------*/#ifndef V_DISPLAY#define V_DISPLAYint UsePlatformDraw(int);extern int usePlatformDrawFlag;int VSetUserFlash(int wSetBool);int VGetUserFlash(void);extern int gwUserFlash;int VGetFlashAble(void);extern int gwSampleMethodInit;int UseQD(int);int ReInitDither(void);#include "VIO.h"extern  int inOffScreen;extern  struct V_Offscreen *nilPort;extern  int colorQD;extern struct V_Offscreen *currentscreen;extern struct V_Offscreen *offscreen;extern struct V_Array *screen;#if WINDOWS#ifndef HBITMAPINFO	DECLARE_HANDLE(HBITMAPINFO);#endifextern HBITMAPINFO  hbmiDibBmiPal;extern LPBITMAPINFO lpbmiDibBmiPal;#endif //WINDOWSextern VCGrafPort mainPort;extern VGrafDevice mainDevice;extern VGrafDevice dummyDevice;#if MACINTOSH#include <QDOffscreen.h>#define VSetPort(x,y) if(colorQD)SetGWorld((CGrafPtr)x,(GDHandle)y); else SetPort((GrafPort *)x)#define VGetPort(x,y) if(colorQD)GetGWorld((CGrafPtr *)x,y); else GetPort((GrafPtr *)x)#define vSrcCopy	srcCopy#define vSrcInvert	notSrcCopy#define vSrcDither	ditherCopy		//Permit nice mac thumbnails	//GJR 10/01/93#elif WINDOWS#define VSetPort(x,y) (x,y)#define VGetPort(x,y) (x,y)HDC VGetDC(HWND);void VReleaseDC(HWND,HDC);#define vSrcCopy	SRCCOPY#define vSrcDither	SRCCOPY			// Pick the nicest Windows has 	//GJR 10/01/93									// When we do our own dithered bitblt, we will									// just have to create a BitBltDither routine, since									// these mode values are full 32 bits on windows and									// their is no room for a "dither" flag.#endif //WINDOWS// things for IO		jca 15 Sept 93#define LWORD_ALIGN(x)	(((x+0x1F)&(~0x1F))/8)enum BMapCompression {	UseNoCompression=-1,	NoCompression= 0	};enum ToolboxDrawStyles{	MONO_QD = 0,	COLOR_QD,	COLOR_QD32	};	enum DisplayStyles{	DISPLAY_PICT = -6,	DISPLAY_PRINT,	DISPLAY_DIALOG,	DISPLAY_PANE,	DISPLAY_WINDOW,	DISPLAY_OFFSCREEN,	DISPLAY_NONE		};	enum PictStyles{	PICT_OFFSCREEN = 1,	PICT_ANTIALIAS		};enum ResizeOptions {	RESIZE_STANDARD = 0,    RESIZE_PRESERVE_DEPTH		// don't change the bit depth	};/*------------------------------------------------------------------------------ * V_Display * This is a base class for all of the displayable output objects.  These objects * are: * V_Offscreen - the offscreen graphics object. * V_Window - the window display object. * V_Pane - the sub window display object. * V_Dialog - the sub window/pane display object. *------------------------------------------------------------------------------*/struct V_Display:V_IO{	VCGrafPort 	metaPort;#if WINDOWS	HBRUSH 	oldBrush;	HPEN	oldPen;	HDC 	oldDevice;	HFONT 	oldFont;	HBITMAP	oldBitmap;	HPALETTE oldPalette;#endif //WINDOWS	int displayType;// DAS-VWINDOWS 10/9/93	int bitType;	int bitDepth;		Rect rect;	Point resolution;	/* number of pixels to the unit */	int lock;			/* are the pixels locked?						*/	virtual int Begin(void);	virtual int End(void);	void SetDisplayType(int);	int GetDisplayType(void);		virtual int GetDepth(void);	virtual int ColorsRemapped(void);	void SetDepth(int);	virtual void GetRect(Rect*);	void PutRect(Rect*);	virtual VGrafData GetMetaPort(Rect *);	virtual void ReleaseMetaPort(VGrafData);	virtual int SetMetaPort(void);// DAS-VR 9/17/93 printing pixMaps	virtual void UnsetMetaPort(void);// DAS-VR 9/17/93 printing pixMaps	void Blit(VGrafData,VGrafData,Rect*,Rect*,long);	void BlitMask(VGrafData,VGrafData,VGrafData,Rect*,Rect*,Rect*,long);	void SetDisplayPort(void);	void UnsetDisplayPort(void);	void GetResolution(Point *);	void PutResolution(Point *);	};	/*------------------------------------------------------------------------------ * V_Offscreen *  The V_Offscreen is an offscreen buffer that is used to draw an image which *  can then be transferred into a V_Pane.  On the Macintosh it may be implemented *  in any one of three ways depending upon the machine and the available  *  software release, either as a standard bitmap (see inside Mac Volume 1) or *  a PixMap (see Inside Mac Volume 5) or as a GWorld (see 32bit Quickdraw *  release notes).  The programmer typically does not need to worry about which *  environment he is operating in because the V_Offscreen will perform  *  correctly. *------------------------------------------------------------------------------ * void V_Offscreen::MetaTo(V_Display * theObject,Rect *rfrom,Rect *rto) * void V_Offscreen::ToMeta(V_Display * theObject,Rect *rfrom,Rect *rto) * void V_Offscreen::MetaToMode(V_Display *theObject,Rect *rfrom,Rect *rto,int mode) * void V_Offscreen::ToMetaMode(V_Display *theObject,Rect *rfrom,Rect *rto,int mode) * void V_Offscreen::MaskMetaTo(V_Display *theObject,V_Offscreen *mask,Rect *rfrom,Rect *rto) * V_Display *theObject;  where we are transferring to or from, this is either another *					V_Offscreen or a V_Window. * Rect *rfrom;  what part are we transferring and where are we transferring it to? * Rect *rto; * int mode; 	 what is the transfer mode? (OR,XOR,AND...) * V_Offscreen *mask; this is used to force the V_Offscreen to copy only where the *					mask is nonzero. * These are the various V_Offscreen transfer functions.  You are either transferring * a V_Offscreen to a V_Window or V_Offscreen or you are transferring the image back the * other way. *-------Macintosh Bug Alert!!!----------------------------------------- *	  The Macintosh complains when you attempt to do a copybits with the *	  destination rectangle overhanging the destination bitmap only on *	  top!  It has been fixed in 32-bit quickdraw. *----------------------------------------------------------------------- *------------------------------------------------------------------------------*/struct V_Offscreen:V_Display{	VGrafDevice gDevice;		/* graphics device if a screen					*/	VHBitmap bitmap;			/* if old QD or if a mask this is used			*/	Handle baseAddr;			/* this is the data bits.						*/	struct V_Array *raster;		/* this is for fast bitmap xfers				*/	struct V_Array *ditherTable;	/*this is for fast dithered color lookups	*/	struct V_Array *colorTable;		/*this holds the raw color information		*/	struct V_Array *vaFRedColor;	/* Flash Red true color conversion			*/	struct V_Array *vaFGreenColor;	/*  holds clump values for conversion speed */	struct V_Array *vaFBlueColor;	/* Flash color clump converters				*/	Rect rsize;					/* actual location of the offscreen bitmap		*/	Rect clipRect;				/* clipping rectangle based upon origin			*/	long refCon;				/* user definable flag.							*/	int screen;					/* is this the main screen?						*/	int xOffset;	int yOffset;	int rowBytes;	unsigned char *baseAddress;	WORD wMethodInit;	LPBYTE *lpbBmRowAddresses;#if WINDOWS	WORD	wBmWidth;	WORD	wBmHeight;	WORD	wBmWidthBytes;	LPBYTE	lpbBmBits;	WORD	wBmPlanes;	WORD	wBmBitsPixel;	WORD	wBmSegmentIndex;	WORD	wBmScanSegment;	WORD	wBmFillBytes;	BOOL fBmOk;	struct V_Array *vaBmRowAddresses;#ifdef gjrTryDibs	HDC	 hdcDib;	HBITMAPINFO hbmiDibBmi;	LPBITMAPINFO lpbmiDibBmi;    HSTR hDibBits;	LPSTR lpDibBits;#endif  // gjrTryDibs#endif //WINDOWS#if MACINTOSH	Long	ctSeed;		CTabPtr UseColorTable(void);#endif //MACINTOSH	int cOffscreen(Rect *,int,RGBColor *, struct V_Array *);	void cScreen(VGrafDevice);	void dOffscreen(void);	int LoadPNum(int,int);	int Resize(Rect *, int);	int GetXOffset(void);	int GetYOffset(void);	virtual int GetRowWidth(void);	BOOL SetGFlashRoutines(void);	void UnSetGFlashRoutines(void);	int IsFlashOn(void);      		// jca 10FEB94	virtual RGBColor GetPixelColor(int , int );		// ABD MERGE-TEXTURE 9/13/93	virtual void SetPixelColor(int , int, RGBColor *);	// ABD MERGE-DITHER	void SetCurrent(void);    void UnSetCurrent(void);	void InitColor(void);	void BuildColor(void);	void ReleaseColor(void);	int BuildDither(void);    int ReInitDither(void);	ULong GetDither(RGBColor *rgb);	ULong GetDither4Bytes(RGBColor *rgb);	ULong GetNoDither(RGBColor *rgb);	int FBuildTrueColor(void);	int IOPictFile(struct V_Buffer *buf,int depth);	int IOPict(struct V_Buffer *buf,long length, int depth);	int cMask(struct V_Offscreen *);	void MetaTo(struct V_Display *,Rect *,Rect *);	void ToMeta(struct V_Display *,Rect *,Rect *);	void MetaToMode(struct V_Display *,Rect *,Rect *,long);	void MetaToDither(struct V_Display *,Rect *,Rect *);		// ABD MERGE-DITHER	void PixelTo(struct V_Display *, Rect *, Rect *);	void ToMetaMode(struct V_Display *,Rect *,Rect *,long);	void ToMetaDither(struct V_Display *,Rect *,Rect *);		// ABD MERGE-DITHER	void ToPixel(struct V_Display *, Rect *, Rect *);	void MaskMetaTo(struct V_Display *,struct V_Offscreen *,Rect *,Rect *);	void MaskMetaToMain(struct V_Display *,struct V_Offscreen *,Rect *,Rect *,Rect *);	virtual int SetMetaPort(void);	virtual void UnsetMetaPort(void);	virtual VGrafData GetMetaPort(Rect *);	virtual void ReleaseMetaPort(VGrafData);	int ANewBitMap(Rect *);	virtual void GetRect(Rect *);	void SetClip(Rect *);	void GetClip(Rect *);	virtual int GetDepth(void);	int ColorsRemapped(void);	short ColorTo256(RGBColor *);		// MERGE-GOURAUD	void IndexToColorNew(RGBColor *, long);		// MERGE-GOURAUD		// PRO-19	RGBColor IndexToColor(int);		// MERGE-DITHER	int ColorToIndex(RGBColor *);		// MERGE-DITHER 	// MERGE-VSHA	void SetRefCon(long);	long GetRefCon(void);	virtual unsigned char **UseRaster(VGrafPort *, VGrafDevice *);		// MERGE23	virtual void UnuseRaster(VGrafPort *, VGrafDevice *);		// MERGE23	void UnuseColorTable(void);	int Begin(void);	int End(void);	void SetGBmInfo(void);#if MACINTOSH	BOOL GetGdiBitmapInfo(void);#elif WINDOWS	BOOL GetGdiBitmapInfo(HANDLE hDC, HANDLE hBmp);#ifdef gjrTryDibs	void DibBlit(VGrafData toPort,Rect *from,Rect *to,long mode);	void cDib();	void dDib();	void ResizeDib(int wWidth, int wHeight);#endif // gjrTryDibs#endif // MACINTOSH	virtual unsigned char *GetBaseAddr(void);	void Antialias(void);	int IO_BMAP(V_Buffer *, struct V_Array *, int);	// ABD MERGE6 WILLIAMS 8/27/93	virtual int IO_CMAP(V_Buffer *, struct V_Array*, int);	// jca 14 Sept 93// note that these should only be used with extreme caution	virtual int IO_INIT_READER(Rect *, int, struct V_Array *);  // jca 15 Dec 93	int IO_BMAP_STRIPE(V_Buffer *, struct V_Array *, long, long, int, int); // jca 27 Sept 93	virtual int IO_BITMAP_STRIPE(V_Buffer *, struct V_Array*, long, long, long, long, int, int);	// jca 27 Sept 93	virtual int Lock(void);				// ABD MERGE6 WILLIAMS 8/30/93	virtual void Unlock(void);			// ABD MERGE6 WILLIAMS 8/30/93	};#if WINDOWS#if 1extern WORD	gwBmWidth;extern WORD	gwBmHeight;extern WORD	gwBmWidthBytes;extern LPBYTE	glpbBmBits;extern WORD	gwBmPlanes;extern WORD   	gwBmBitsPixel;extern WORD	gwBmSegmentIndex;extern WORD	gwBmScanSegment;extern WORD	gwBmFillBytes;extern BOOL gfBmOk;/*  used on mac, too.  See below.extern LONG *gplFRedColor;extern LONG *gplFGreenColor;extern LONG *gplFBlueColor;*/extern struct V_Array *gvaBmRowAddresses;extern LPBYTE *glpbBmRowAddresses;#endif#endif //WINDOWSextern LONG *gplFRedColor;			//jca.  17 aug 93.  these are used on the Macextern LONG *gplFGreenColor;extern LONG *gplFBlueColor;/*------------------------------------------------------------------------------ * V_Picture * V_Pictures handle images stored in the Macintosh 'PICT' format.  They are * loaded drawn, or used to create a V_Offscreen object.  Since the V_Picture  * needs to handle files it uses a derived V_File class, P_File, for this * specific purpose. *------------------------------------------------------------------------------*/struct V_Picture:V_Display{	VPictHandle picture;	/* the picture itself 							*/	int ptype;			/* what type? 0=resource,1=file,2=spooled file 	*/	int makeBits;		/* this specifies if we want copyBits type or not*/		void cPicture(int bits);	int GetPictNum(int);	void dPicture(void);	void GetRect(Rect *);	void Draw(Rect *);	int Begin(void);	int End(void);	int IOPictFile(struct V_Buffer *);/*reads/writes PICT file with header*/	int IOPict(struct V_Buffer*,long);/*reads/writes PICT file (not the header)	*/	int IOChunk(struct V_Buffer *);	 /*reads/writes PICT chunks	*/	int IOResource(struct V_File *, int, strPtr);	};/*------------------------------------------------------------------------------ * V_Pixel8 * Create and hold a directly accessible 8bit pixelmap. * Used to hold texture mips *------------------------------------------------------------------------------*/struct V_Pixel8:V_Offscreen{	int  cPixel8(Rect *,int,RGBColor *, struct V_Array *);	void dPixel8(void);	int GetDepth(void);	void GetRect(Rect*);	int GetRowWidth(void);	RGBColor GetPixelColor(int , int );		// ABD MERGE-TEXTURE 9/13/93	void SetPixelColor(int , int, RGBColor *);	// ABD MERGE-DITHER 	VGrafData GetMetaPort(Rect *);	void ReleaseMetaPort(VGrafData);	int SetMetaPort(void);	void UnsetMetaPort(void);	unsigned char **UseRaster(VGrafPort *, VGrafDevice *);		// MERGE23	void UnuseRaster(VGrafPort *, VGrafDevice *);		// MERGE23	unsigned char *GetBaseAddr(void);	int Lock(void);				// ABD MERGE6 WILLIAMS 8/30/93	void Unlock(void);			// ABD MERGE6 WILLIAMS 8/30/93	int cCreateCopy(struct V_Offscreen *);	int IO_INIT_READER(Rect *, int, struct V_Array *);  // jca 15 Dec 93	int IO_BITMAP_STRIPE(V_Buffer *, struct V_Array*, long, long, long, long, int, int);	// jca 15 Dec 93	int IO_CMAP(V_Buffer *, struct V_Array*, int);	// jca 15 Dec 93	};#endif //V_DISPLAY