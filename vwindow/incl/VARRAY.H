/*------------------------------------------------------------------------------ * VWINDOWSt - the window object toolbox * * Copyright c 1989 by Virtus Corporation * All Rights Reserved * Written by David A. Smith * 111 Gold Meadow Drive * Cary, North Carolina    27513 * (919) 469-8485 *------------------------------------------------------------------------------ * V_Array.h *------------------------------------------------------------------------------*/#ifndef V_ARRAY#define V_ARRAY#include "WHandle.h"#include "VIO.h"#define VARY_SUCCESS   0     /* successful completion */ #define VARY_LOCKED   -1     /* operation failed because array is locked */#define VARY_RANGE    -2     /* array index is out of range */#define VARY_NOTFOUND -3     /* Find() couldn't */#define VARY_LOWMEM   -4     /* not enough memory to allocate the array  */#if MACINTOSH#define USELOCK TRUE		// this turns on/off the array of arrays for faster memory#elif WINDOWS#define USELOCK FALSE       // jca 25 Oct 93#endif/*------------------------------------------------------------------------------ * V_Array * This class is designed to handle virtual arrays of any type.  These arrays * are implemented as handles though through the use of the Use and Unuse * methods they can be accessed directly.  Since they are handles, they are * relocatable and should not fragment the heap. *------------------------------------------------------------------------------*/struct V_Array:V_IO{	Handle array;   	/* the handle which contains the array data		*/#if MACINTOSH	Ptr  parray;		/* the pointer that deferenced handle value     */	long masterIndex;	/* index into the masterArray					*/#endif	long length;		/* the length of the array in items.			*/	long size;			/* the size of each individual item.			*/	long allocLength;	/* the size of the allocated array in items.	*/	long byteLoc;		/* location of next appended field				*/	long allocBlock;		/* ABD MERGE-BUG2 the length increment for expansions.			*/	long lockCount;		/* ABD MERGE-BUG2 number of nested Use method calls.			*/		virtual int IO(struct V_Buffer *);	virtual int cArray(long, long, long);  // ABD MERGE-BUG2	virtual void dArray(void);	virtual int Append(void *);	virtual int Insert(long, void *);	virtual int Remove(long);	virtual int Put(long, void *);	virtual void Reverse(void);	virtual int Compare(void *, void *);		int Get(long, void *);	int SetLength(long);	void* GetAddress(long);	int Exchange(long,long);	void InsertArray(struct V_Array *, int); 	void RemoveRange(int, int); 	int CopyArray(struct V_Array *);	void Unuse(void);	void *Use(void);	void *Abuse(void);	long Find(void *);	long ALength(void);	void InsertSort(void);	void QuickSort(void);	void QS(long, long);	/* jca.  we should have some stack methods, since	we tend to use V_Arrays as stacks.  Not as proper	as having a V_Stack class perhaps, but useful.	These will be inlined for speed */	int	 Push(void *thing);	void *Pop(void *);	};#if MACINTOSH/* The masterArray is the array containing ALL other arrays. They are installed into	here when they are created. The default state of the arrays is to be locked. If	the heap begins to fragment, this array is used to completely unlock all of the	arrays (that are not in use) compact the heap, and then lock them all again. This	array is always kept as a handle. */struct MasterArray:V_Array{	long queueHead;		virtual int cArray(long, long, long);    // ABD MERGE-BUG2	virtual void dArray(void);	};void InitArrays(void);int  CompactArrays(void);					// help defrag memory		//GJR 10/26/93long AddMasterArray(V_Array **array);void RemoveMasterArray(long);#endif#if MACINTOSH && USELOCK#ifndef INVARRAY#define Unuse() lockCount--#define ALength() length#endif#define VA_Unuse(va) (va)->lockCount--#define VA_Abuse(va) ((void *)((va)->parray?(va)->parray:HDeref((va)->array)))#define VA_Use(va,a,type) (a=(type*)(va)->Use())#define VA_Length(va)	((va)->length)#define VA_Append(va,data,type) 	(va)->Append(&(data))	#define VA_Truncate(va) { (va)->length=0; (va)->byteLoc=0; }#else#define VA_Abuse(va)	((void *)HDeref((va)->array))#define VA_Use(va,a,type) { if((va)->lockCount++==0)HLock((va)->array); (a)=(type *)HDeref((va)->array); }#define VA_Length(va)	((va)->length)#define VA_Unuse(va) { if(--(va)->lockCount==0)HUnlock((va)->array); }#define VA_Append(va,data,type) 						\	{ 													\	if ((va)->length < (va)->allocLength)				\		{												\		*(type *)(HDeref((va)->array)+(va)->byteLoc) = (data); \		(va)->byteLoc += (va)->size;					\		(va)->length++;									\		}												\	else (va)->Append(&(data));							\	}#define VA_Truncate(va) { (va)->length=0; (va)->byteLoc=0; }#endif#endif //V_ARRAY