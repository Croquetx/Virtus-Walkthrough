/* POOL.H -- SmartHeap Internals Include File * Professional Memory Management Library for Windows 3.x * * Copyright (C) 1991, 1992 by Arthur D. Applegate * All Rights Reserved. * * No part of this source code may be copied, modified or reproduced * in any form without retaining the above copyright notice. * This source code, or source code derived from it, may not be redistributed * without express written permission of the author. */#if defined(_MSC_VER)#if (_MSC_VER != 700)#error Warning: Compiling SmartHeap with untested version of Microsoft C. SmartHeap has been tested only with Microsoft C/C++ 7.0.#endif#ifdef _MSC_VER#pragma warning(disable:4001)//#pragma warning(disable:4704)#endif#define ASM __asm// between-separator for assembly statements#define __ ASM// end-separator for assembly statements#define ___#define ASM_LABEL(l) ASM { l: }#define ASM_MEMBER(type,member) type.member//#pragma optimize("b0t", on)//#pragma optimize("z", on)#elif defined(__BORLANDC__)#if (__BORLANDC__ != 0x0400 && __BORLANDC__ != 0x0410)#error Warning: Compiling SmartHeap with untested version of Borland C++. SmartHeap has been tested only with Borland C++ 3.0 and 3.1.#endif#define ASM asm// between-separator for assembly statements#define __ ;// end-separator for assembly statements#define ___ ;#define ASM_LABEL(l) l:#define ASM_MEMBER(type,member) .(type)member#else#error Attempt to compile SmartHeap source code with unsupported compiler.  SmartHeap source has been tested only with Borland C++ 3.0/3.1 and Microsoft C/C++ 7.0. Changes may be required to the macros in POOL.H to support other compilers.#endif/*** Include Files ***/#include <windows.h>#include <dos.h>#include "smrtheap.h"#include "smrtansi.h"#ifdef __BORLANDC__#pragma hdrstop#endif// DWE 3/21/93 -- From WINDOWS.H; Windows doesn't define for C++#define max(a,b)            (((a) > (b)) ? (a) : (b))#define min(a,b)            (((a) < (b)) ? (a) : (b))/*** Types ***/typedef struct __TaskRecord NEAR *PTaskRecord;typedef struct __TaskRecord{	HANDLE hTask;				// the task that owns this record; 0 if shared	MEM_SAFETY_LEVEL safetyLevel; // safety level for pools owned by this task	MEM_ERROR_FN errorFn;	// user-defined error-handling function	MEM_POOL mallocPool;	// memory pool for malloc/free calls for this task	PTaskRecord next;} TaskRecord;struct Pool{	unsigned wSignature;				// identifying constant for validation	unsigned wFirstSegment;			// selector of first sub-allocated segment	unsigned wFirstHugeSegment;	// selector of first huge block	PTaskRecord pTaskRec;			// task record of pool	BOOL isFixedSize;					// fixed vs variable-size blocks	BOOL isWrongTaskOK;				// references from non-owning task OK?	long lFreeBytes;					// current number of bytes in free store	long lFreestoreThreshold;		// max number of bytes to keep in free store	struct Pool NEAR *next;};typedef struct tagFixedSizeLink{	struct tagFixedSizeLink NEAR *next;  // for fixed-size free-list} FixedSizeLink;typedef struct{	FixedSizeLink NEAR *pFreeList; // head of fixed-size free-list	unsigned wBlockSize;		// bytes per block allocated from fixed-size pool	unsigned wIncrement;		// bytes to add when segment grows	PSTR pEnd;					// beginning of uninitialized portion of segment} FixedSizeHeader;typedef struct HeapEntryTAG{	unsigned wPrev; //  (wPrev & ~0x03) gives struct HeapEntryTAG NEAR *pPrev	struct HeapEntryTAG NEAR *pNext;	union {		struct {			unsigned handle;			unsigned memory[1];		} moveableBlock;		struct {			unsigned memory[1];		} fixedBlock;	} mem;} HeapEntry;#define IS_MOVEABLE(x) ((x) & 0x02)	// not double-word aligned#define HEAP_ENTRY_MOVEABLE(p) (IS_MOVEABLE((p)->wPrev))#define HEAP_ENTRY_INUSE(p) ((p)->wPrev & 0x01)#define VALID_OFFSET(wMem, wLimit) \	((unsigned)(wMem) >= sizeof(SegmentHeader) && (unsigned)(wMem) < (wLimit))// local heap blocks not in use are linked into a doubly-linked free-listtypedef struct FreeHeapEntryTAG{	struct FreeHeapEntryTAG NEAR *pPrev;	struct FreeHeapEntryTAG NEAR *pNext;	unsigned wSize;	struct FreeHeapEntryTAG NEAR *pPrevFree;	struct FreeHeapEntryTAG NEAR *pNextFree;} FreeHeapEntry;typedef struct{	PSTR pMem;	BYTE flags;	BYTE lockCount;} MoveableHandle;typedef struct{	BYTE reserved[4];	unsigned allocCount;	HeapEntry NEAR *pFirst;} HeapHeader;typedef struct{	BYTE reserved[6];	HeapHeader NEAR *pHeap;	BYTE reservedForpAtomAndStack[8];} DefaultHeader;typedef struct{	union	{		DefaultHeader hdr;	// data specific to local local heap manager		FixedSizeHeader FS;	// data specific to fixed-size blocks	} segHead;	MEM_POOL pPool;		// pointer to the pool containing this segment	unsigned wNextSegment;	// next global segment in the pool	unsigned wAllocCount;		// count of sub-allocations from this segment	unsigned exceedingSize;	// block size that exceeds segment's capacity	// Keep sizeof(SegmentHeader) even so that allocations are word-aligned.	// if members are added after exceedingSize, must change MIN_SEG_SIZE below} SegmentHeader;#ifdef __BORLANDC__#define MIN_SEG_SIZE ASM_MEMBER(SegmentHeader,exceedingSize)+4#else#define MIN_SEG_SIZE SIZE SegmentHeader+2#endiftypedef struct{	MEM_POOL pPool;	unsigned wNextSegment;} HugeSegHeader;// The macro below tests for an offset of either zero or four -- i.e. either a// pointer returned by GlobalAlloc or a huge ptr returned by MemAllocSmart.// If the HugeSegHeader structure changes, the macro needs to change too.#define IS_HUGE_PTR(lpMem) (lpMem && !(POINTER_OFFSET(lpMem) & 0xFFFB))#define MIN_HUGE_SEG_SIZE 4/*** Constants ***/#define MAX_BLOCK_SIZE (0xFFF0-sizeof(SegmentHeader)) // max seg#define MIN_BLOCK_SIZE 2#define MIN_FREESTORE_THRESHOLD 0x0000FFFFL		// threshold must exceed 64K/* Maximum block size that SmartHeap can sub-allocate */#define MAX_SUBALLOC_SIZE 32768u		// maximum size to be sub-allocated// ideal pool signature:// i) won't end in 5, D, 7, or F (these are the values that selectors end in)// ii) will be high in the address space, so they can't be pPool or pTaskRec// iii) won't be a possible safety level (i.e. > 4)// iv) will be out of range of a possible ErrorAPI// v) two low-order bits should be on, so that it can't be an entry in DLL's//    local heap at all// => how about: 0xFFFB#define POOL_SIGNATURE 0xFFFB#define LOCALHEAP_INIT_SIZE 256	// documented minimum heap size#define SEGMENT_GRANULARITY 32	// granularity of segs alloced by GlobalAlloc// access rights for valid code and read/write data selectors, respectively:#define CODE_ACCESS_MASK 0x9A00#define DATA_ACCESS_MASK 0x9200/*** Macros ***/// WITH_DS: Execute 'code' with the DS register set to 'newDS', then restore// DS. Note that _setDS's scope is limited to this macro.  It is imperative// that 'code' not transfer control out of the block (e.g. no goto, return,// longjmp, break, et cetra).  Also, no Windows calls that might switch// tasks -- e.g. MessageBox.  Also, _code can't reference global variables.#ifdef ASM#define WITH_DS(newDS, _code) {	\	ASM {									\		mov ax,newDS __				\		push ds __						\		mov ds,ax ___}					\	{										\		_code;							\	}										\	ASM { pop ds ___}					\}#else// debug.c must be in the same code segment for the out-of-line WITH_DS!#define WITH_DS(newDS, code) \{ \	extern unsigned PASCAL _setDS(unsigned); \	unsigned oldDS = _setDS(newDS); \	code; \	_setDS(oldDS); \}#endif#ifndef ASM	extern unsigned PASCAL _ValidateSegment(unsigned);#endif#ifdef ASM#define INT_MUL(_a, _b, overflow) {	\		ASM {							\			mov ax,_a __			\			mul _b __				\			jc overflow __			\			mov (_a),ax ___}}#else// The casts in the C version are needed to detect overflow.// Unfortunately, this results in unnecessary long multiplication.// Assembly version above is therefore much preferred.#define INT_MUL(_a, _b, overflow) {					\	long __l = (long)((long)(_a) * (long)(_b)); \	if (HIWORD(__l)) goto overflow;					\	(_a) = (unsigned)__l; }#endif#ifdef DEBUG#define __STR(ln) #ln#define _STR(ln) __STR(ln)#define WIN_ASSERT(retVal, exp) { if (!(exp)) { (void)DisplayMessage( \	"Assertion failed: " #exp ".  File: " __FILE__ "; line: "_STR(__LINE__));\	return retVal; } }#else#define WIN_ASSERT(retVal, exp)#endif#define TASKID_OFFSET 0x00FA#ifdef _MSC_VER#define LP_SEGMENT(wSeg) (((__segment)wSeg):>(SegmentHeader __based(void) *)0)#define LP_HUGE_SEG(wSeg)(((__segment)wSeg):>(HugeSegHeader __based(void) *)0)//#define LP_SEGMENT(wSeg) ((SegmentHeader __based((__segment)wSeg) *)0)//#define LP_HUGE_SEG(wSeg) ((HugeSegHeader __based((__segment)wSeg) *)0)#define LP_TASKID(hTask) (((__segment)(hTask)):>(unsigned __based(void) *)TASKID_OFFSET)#elif __BORLANDC__#define LP_SEGMENT(wSegment) ((SegmentHeader _seg *)(wSegment))#define LP_HUGE_SEG(wSegment) ((HugeSegHeader _seg *)(wSegment))#define LP_TASKID(hTask) (((unsigned _seg *)(hTask) + (void near *)TASKID_OFFSET))#else#define LP_SEGMENT(wSegment) ((SegmentHeader FAR *)MAKELONG(0, wSegment))#define LP_HUGE_SEG(wSegment) ((HugeSegHeader FAR *)MAKELONG(0, wSegment))#define LP_TASKID(hTask) ((LPWORD)MAKELONG(TASKID_OFFSET, hTask))#endif#define P_SEGMENT ((SegmentHeader NEAR *)0)#define LP_SEGMENT_FS(wSegment) (LP_SEGMENT(wSegment)->segHead.FS)#define P_SEGMENT_FS (P_SEGMENT->segHead.FS)#define LP_HEAP(wSegment) (LP_SEGMENT(wSegment)->segHead.hdr)#define P_HEAP (P_SEGMENT->segHead.hdr)#ifdef _MSC_VER#define POINTER_SEGMENT(lpMem) HIWORD(lpMem)#else#define POINTER_SEGMENT(lpMem) (FP_SEG(lpMem))#endif#define POINTER_OFFSET(lpMem) LOWORD(lpMem)#define HANDLE_SEGMENT(MemHandle) POINTER_SEGMENT(MemHandle)#define HANDLE_OFFSET(MemHandle) POINTER_OFFSET(MemHandle)#ifdef ASM#define ASM_SEG(lpPtr) WORD PTR lpPtr+2#define ASM_OFF(lpPtr) WORD PTR lpPtr#else#define ASM_SEG(lpPtr) POINTER_SEGMENT(lpPtr)#define ASM_OFF(lpPtr) POINTER_OFFSET(lpPtr)#endif#define IS_THRESHOLD_ON(pPool) \(HANDLE_SEGMENT(pPool->lFreestoreThreshold)!=HANDLE_SEGMENT(MEM_THRESHOLD_OFF))#define _APPEND1(_x,_y) _x ## _y#define _APPEND(_x,_y) _APPEND1(_x,_y)#define GENLABEL(desc) _APPEND(desc,__LINE__)#define CHECK_POOL(pPool) \	((pPool) <= HighestPool && (pPool)->wSignature == POOL_SIGNATURE)// All these macros may look confusing, but they result in MEM_SAFETY_SOME// checking in a mere 11 to 16 inline instructions, with control passing to// the function if any checks fail, or if MEM_SAFETY_FULL is in effect// (thus maximizing speed in non-error conditions while minimizing code size).#define VALIDATE_POOL_INTERNAL(errRet, pPool, nFixedSize, moreCode) {	\	if (bSafety) {														\		if (!CHECK_POOL(pPool))										\			goto invalidPool;											\	/* full safety checking, and error-handling invocation */	\		if (pPool->pTaskRec->safetyLevel >= MEM_SAFETY_FULL)		\invalidPool: \	if (!ValidatePool(pPool,nFixedSize,MEM_BAD_MEM_POOL,(DWORD)(WORD)pPool)) \			return errRet;												\		moreCode;														\	}}// generic pool validation#define VALIDATE_POOL(errRet, pPool)							\	VALIDATE_POOL_INTERNAL(errRet, pPool, -1, ;)// verify match between variable-size operators and pools#define VALIDATE_POOL_VAR(errRet, pPool)						\	VALIDATE_POOL_INTERNAL(errRet, pPool, 0,					\		if (pPool->isFixedSize)									\			goto invalidPool;									\	)// verify match between fixed-size operators and pools#define VALIDATE_POOL_FS(errRet, pPool)							\	VALIDATE_POOL_INTERNAL(errRet, pPool, 1,					\		if (!pPool->isFixedSize)								\			goto invalidPool;									\	)#define VALIDATE_POINTER_INTERNAL(errRet, lpPtr, validationCall) {\	if (bSafety) {												\		register MEM_POOL pPool;								\		VALIDATE_SEGMENT_AND_OFFSET(ASM_SEG(lpPtr), ASM_OFF(lpPtr), invalidPtr)\		if (POINTER_OFFSET(lpPtr) < sizeof(SegmentHeader))					\			goto invalidPtr;									\		pPool = LP_SEGMENT(POINTER_SEGMENT(lpPtr))->pPool;						\		if (!CHECK_POOL(pPool))								\			goto invalidPtr;									\	/* full safety checking, and error-handling invocation */	\		if (pPool->pTaskRec->safetyLevel >= MEM_SAFETY_FULL) {	\invalidPtr:	if (!validationCall)								\				return errRet; }									\	}}#define VALIDATE_POINTER(errRet, lpMem, nFixedSize)	\	VALIDATE_POINTER_INTERNAL(errRet, lpMem,				\		ValidatePointer(lpMem, nFixedSize))#define VALIDATE_POINTER_VAR(errRet, lpMem) {			\	/* fixed pointers are double-word aligned */			\	if (POINTER_OFFSET(lpMem) & 0x03)						\		goto invalidPtr;											\	VALIDATE_POINTER(errRet, lpMem, 0) }#define VALIDATE_POINTER_FS(errRet, lpMem)				\	VALIDATE_POINTER(errRet, lpMem, 1)#define VALIDATE_POINTER_SLOW(errRet, lpMem) {			\	if (bSafety && !ValidatePointer(lpMem, 0))			\		return errRet; }#define VALIDATE_HANDLE(errRet, MemHandle) {	\	if (bSafety &&										\		!ValidateHandle(HANDLE_OFFSET(MemHandle), HANDLE_SEGMENT(MemHandle))) \		return errRet;	}#ifdef ASM#define VALIDATE_SEG(wSelector, errorLabel) {							\	ASM {																				\			sub cx,cx __															\			lsl cx,wSelector __		/* put seg limit in cx if valid */\			cmp cx,MIN_SEG_SIZE __	/* test seg > header */				\			ja GENLABEL(_seg_ok) __												\		}																				\	goto errorLabel;																\	GENLABEL(_seg_ok): ; }#else// debug.c must not be compiled into own segment if _ValidateSegment is used!#define VALIDATE_SEG(wSelector, errorLabel) {						\	if (_ValidateSegment(wSelector) < sizeof(SegmentHeader)+2)	\		goto errorLabel;														\	}#endif /* ASM */// to validate a segment whose pool is not known#define VALIDATE_SEGMENT(wSelector, errorLabel) {		\	if (bSafety) {													\		VALIDATE_SEG(wSelector, GENLABEL(_error))			\		if (!CHECK_POOL(LP_SEGMENT(wSelector)->pPool)) {\GENLABEL(_error):  goto errorLabel; }                 \	}}// Validate a segment whose pool is known; assumption here is that there// is a call to VALIDATE_POOL, and hence an invalidPool label in the// same lexical scope.  On error, control is transferred to _error, where the// erroneous pool is freed by clearing its wSignature field, then// control is transferred to the invalidPool label in the VALIDATE_POOL macro,// which will invoke the error handling routine, then return the appropriate// error return code.  All this is to save code space of multiple redundant// inline error-handler invocations and error code returns.#define VALIDATE_SEGMENT_OF_POOL(wSelector, pool) {	\	if (bSafety) {													\		VALIDATE_SEG(wSelector, GENLABEL(_error))			\		if (LP_SEGMENT(wSelector)->pPool != (pool)) {	\GENLABEL(_error): (pool)->wSignature = 0;					\			goto invalidPool;										\	}}}#define VALIDATE_HUGE_PTR(errRet, lpPtr) {							\	if (bSafety) {																\		register MEM_POOL pPool;											\		VALIDATE_SEGMENT_AND_OFFSET(ASM_SEG(lpPtr),					\			MIN_HUGE_SEG_SIZE, GENLABEL(_error))						\		if (POINTER_OFFSET(lpPtr) != 0) {								\			pPool = LP_HUGE_SEG(POINTER_SEGMENT(lpPtr))->pPool;\			if (!CHECK_POOL(pPool)) goto GENLABEL(_error);			\			/* full safety checking, and error-handling invocation */\			if (pPool->pTaskRec->safetyLevel >= MEM_SAFETY_FULL) {\GENLABEL(_error):	if (!ValidatePointer(lpPtr, 0))					\					return errRet; }}											\	}}#define VALIDATE_HUGE_SEG_OF_POOL(wSelector, pool) {			\	if (bSafety) {															\		VALIDATE_SEGMENT_AND_OFFSET(wSelector,						\			MIN_HUGE_SEG_SIZE, GENLABEL(_error))					\		if (LP_HUGE_SEG(wSelector)->pPool != (pool)) {			\GENLABEL(_error): (pool)->wSignature = 0;							\			goto invalidPool;												\	}}}// to validate a segment and offset; bSafety known to be TRUE#ifdef ASM#define VALIDATE_SEGMENT_AND_OFFSET(wSel, wOffset, errorLabel) {			\	ASM {																						\		lar ax,wSel __			/* test access rights */							\		jnz GENLABEL(_seg_not_ok) __		/* jump if not valid */				\		and ax,CODE_ACCESS_MASK __	/* make sure loaded and R/W access... */\		cmp ax,DATA_ACCESS_MASK __	/* ... but NOT code access */				\		jne GENLABEL(_seg_not_ok) __													\		lsl cx,wSel __			/* put seg limit in cx if valid */				\		cmp cx,wOffset __		/* make sure segment big enough for wOffset */\		ja GENLABEL(_seg_is_ok) ___													\	}																							\	ASM_LABEL(GENLABEL(_seg_not_ok))													\	goto errorLabel;																		\	GENLABEL(_seg_is_ok): ; }#else#define VALIDATE_SEGMENT_AND_OFFSET(wSelector, wOffset, errorLabel) { \	if (_ValidateSegment(wSelector) <= (wOffset))		\		goto errorLabel;								\	}#endif /* ASM */#ifdef ASM#define VALIDATE_TASK(hTask, errorLabel) {							\	ASM {																			\		lsl ax,hTask __		/* put seg limit in ax if valid */	\		jnz errorLabel	__		/* jump if not valid */					\		/* look for "TD" (Task Database) at offset 0xFA to verify task handle*/\		cmp ax,0xFE __															\		jb errorLabel ___}													\		if (*LP_TASKID(hTask) != 0x4454)									\			goto errorLabel;													\	}#else#define VALIDATE_TASK(hTask, errorLabel) {				\		if (_ValidateSegment(hTask) < 0xFE)				\			goto errorLabel;							\	/* look for "TD" (Task Database) at offset 0xFA to verify task handle*/\		if (*LP_TASKID(hTask) != 0x4454)									\			goto errorLabel;							\	}#endif  /* ASM */#ifdef ASM#define SEGMENT_LIMIT(wSel, wSize) ASM {						\	mov ax,0 __			/* for 0 result if invalid */			\	lsl ax,wSel __		/* put seg limit in ax if valid */	\	mov wSize,ax ___													\	}#else#define SEGMENT_LIMIT(wSel, wSize) { \	(wSize) = (unsigned)GlobalSize(LOWORD(GlobalHandle(wSel))) - 1; }#endif /* ASM */#define GET_MALLOC_POOL(pPool) {									\	if (!Tasks || Tasks->hTask != GetCurrentTask()			\			|| (pPool = Tasks->mallocPool) == 0)				\		pPool = GetMallocPool();									\	}/*** Global Variables ***/extern HANDLE hLibInst;			// DLL instance handleextern MEM_API EntryAPI;		// identifier of the most recently called APIextern MEM_POOL Pools;			// list of poolsextern MEM_POOL HighestPool;	// memory pool with highest addressextern BOOL bSafety;				// global toggle for safety checksextern TaskRecord SharedTaskRecord; // task record for shared memory poolsextern PTaskRecord Tasks;		// task list (first is record last looked up)extern unsigned wMaxReallocTail;	// end of heap ptr (to avoid LocalReAlloc bug)/*** Function Prototypes ***/#if defined(DEBUG) || defined(TRACE)void FAR PASCAL DisplayMessage(LPSTR);#endifBOOL PASCAL FreeChainedSegment(MEM_POOL pPool, unsigned wSegment);BOOL PASCAL FindSegment(unsigned FAR *pNewSeg);void PASCAL NewHugeSegment(MEM_POOL, unsigned);void PASCAL FreeHugeSegment(unsigned);void PASCAL ShrinkAllPools(MEM_POOL pSkipPool);BOOL FAR PASCAL ValidatePool(MEM_POOL, int, int, DWORD);BOOL FAR PASCAL ValidatePointer(LPVOID lpMem, int nFixedSize);BOOL FAR PASCAL ValidateHandle(HANDLE hMem, unsigned wSegment);int FAR PASCAL isHeapEntryInUse(MEM_POOL, unsigned, HANDLE, unsigned, int,	BOOL, BOOL);int FAR PASCAL isBlockInUseFS(MEM_POOL, LPVOID, int, BOOL, BOOL);long PASCAL MemPoolShrinkInternal(MEM_POOL pPool);BOOL FAR PASCAL MemPoolCheckInternal(MEM_POOL pPool);MEM_POOL_STATUS FAR PASCAL MemPoolWalkInternal(MEM_POOL, MEM_POOL_ENTRY FAR *,	BOOL);void PASCAL InitFixedSizePool(MEM_POOL pPool, unsigned wSegment);BOOL FAR PASCAL InvokeErrorHandler(MEM_POOL, MEM_ERROR, DWORD);BOOL IsDSfull(void);MEM_POOL FAR PASCAL GetMallocPool(void);PTaskRecord FAR PASCAL FindTaskRecord(HANDLE);PTaskRecord FAR PASCAL GetTaskRecord(HANDLE);BOOL PASCAL FreePool(MEM_POOL);