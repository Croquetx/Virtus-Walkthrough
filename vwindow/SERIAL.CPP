/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	Tim Kingsbury *				David W. Easter *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ *//* Serial numbers are expressed in the form:  PREFIX-FLAGS-CHECK   Each segment must be separated by a dash.  The prefix segment contains the opening   text as well as the serial number (ex. SWTAB001). The prefix can be any length.      The flags are represented as three digits of hexadecimal:   	   		1st digit: The modifier flags are logically ORed together into a single   					4 bit number (whose hexadecimal value is used here)   					   					The modifier flags and their binary values are:   							   						None 			0000		   						Not for Resale	0001  					   					These binary values are ORed together if multiple flags are set.   					This makes it possible to easily extract all of the flag information   					from this single digit of hex. Currently, the last three bits   					are unused, and will always be set to zero.  For the time being,   					this hex digit will always be either zero or one.   					   		2nd and 3rd:  If there is an expiration date, then these digits will be set,   						otherwise they will be zeros. The second digit is the month and   						the third is the year. Years are expressed as a hexadecimal   						extension from the year 1990. (ie. 1992 = 2, 1999 = 9, 2000 = A   						... in 2016, if anyone still cares, this will need to be revised)   				  		The third digit is also in hexadecimal (Jan to Dec = 1 to C).   				  			The end of the serial number is a four digit check value that is based on	everything that preceded it. CheckNumber is a function that evaluates a serial	number and returns TRUE if it is legitimate.  For clarification, it expects to	receive a string such as "SWTAB019-000-2AFC".   				  		*/#include "Serial.h"#include "VTypes.h"#include <stdlib.h>#include <stdio.h>#include <string.h>#ifdef VINSTALLER     					// jca 21 Oct 93 {#define beepSound	1        // if this is the installer for windows, thenint VPlaySound(int);         // we have these defined elsewhere#define MakeID(a,b,c,d)	((long)(a) << 24 | (long)(b) << 16 | (c) << 8 | (d))#else#include "VSound.h"          // otherwise, use system stuff#include "VIO.h"#endif // VINSTALLER && WINDOWS  	// jca 21 Oct 93 }// PRO-JAP moved strings to AppText.h#define NONE_FLAG			16#include "VTextDef.h"	//PRO-JAP// Converts a decimal integer into a num_digits sized string representation// of its hexadecimal value.void BuildHexStr(char *buffer, int input, int num_digits){	int	starting_pos;		sprintf(buffer, "%04X",input);		// Maxes out at four digits...	starting_pos = strlen(buffer) - num_digits;	strcpy(buffer, buffer+starting_pos);}// Fills buffer with a four digit hexadecimal value CRC value divisible by decimal 42.void Generate_CRC(char *buffer, int input){	int	temp;		input = input * 256;	temp = abs(input - (input % 42));	if ((temp % 42) != 0) 		VPlaySound(beepSound);			// Something has gone very wrong... 	BuildHexStr(buffer, temp, 4);}// Returns the location of the next occurence of a certain character in a string.int FindChar(char *buffer, char match){	int		i = 0, size = strlen(buffer);		while (buffer[i] != match && i < size) i++;	if (i == size)		return -1;	else		return i;}unsigned long CRCTable[256];/*---------------------------------------------------------------------*//*	Cyclic Redundancy Code routines 	CRC32		see dr. dobbs may '92  pg 64+; aug '92 pg 12+	CCITT16	SYNCH16		see technical aspects of data communication, pg 154+, John McNamara	32-bit CRC as spec'd by CCITT	Terms are		 32    26    23    22    16    12    11    10    8    7    5    4    2    1	   X^  + X^  + X^  + X^  + X^  + X^  + X^  + X^  + X^ + X^ + X^ + X^ + X^ + X^ + 1   	Note that this is implemented by shifting RIGHT -> hi bit is to 	the right.  If viewed as a series of hardware xor latches, the 	next xor is selected by the bit being shifted OUT of the crc.	As McNamara states, we use the highest power(32) to test/feedback the values, THEN	we shift, LAST we combine in the feedbacked values.	To make this faster, a syndrome table is precomputed.  Since its easier 	to work with bytes at the low end of the register, we flip the msb 	to be the rightmost position, ready for shifting RIGHT and OUT.		With exponents going for ^32 to ^0, notice that we need 33 bits.	The highest exponent is "preshifted" off the right side. Thats why	the CRC32 ends in 20.	24 25 26 27 28 29 30 31 32	0  0  1  0  0  0  0  0  1	2           0           1	Any crc could be used, just copy and use a different poly specifier.  	Again, note that the x^0 etc is on the left, and x^23 is to the right.		For CRC's less than 32 bits, the high power must be off the right end, and	masking should be done afters to emphasize the limited number of bits.*//*---------------------------------------------------------------------*/#define CRC32_POLYNOMIAL (0xEDB88320L)#define HUHCRC16_POLYNOMIAL (0x50080000L)		// I don't know where this came from#define CCITT16_POLYNOMIAL	(0x00008408)	// 0,5,12,16	1000/0100/0000/1000 1#define SYNCH16_POLYNOMIAL	(0x0000A001)	// 0,2,15,16	1100/0000/0000/0001 1/*---------------------------------------------------------------------*/voidInitCRCTable(){int i;int j;unsigned long crc;	for ( i=0 ; i<= 255 ; i++ )		// for each possible 8-bit value	{		crc = i;	// pretend the low byte started with the value 'i'				for ( j=0 ; j<8 ; j++ )		{  			/* if the incoming is 'i', find all the repercussions */						if (crc & 1)		// if bit shifting out is 1, xor poly again			{				crc >>= 1; 				// shift the selector bit out				crc &= 0x7FFFFFFFL;		// (don't trust unsigned shifting)				crc ^= CRC32_POLYNOMIAL;			}			else			{  				/* else no change, just get next bit */				crc >>= 1;				crc &= 0x7FFFFFFFL;			}		}			CRCTable[i] = crc;	}}	/*---------------------------------------------------------------------*//*	CalculateCRC	This is the routine that calculates the CRC.  We precondition the CRC 	with all ones to start the series going.  Note that if the input chars 	happen to exactly match the current CRC, then the beginning of the 	file is missed mod 32 (bits).  The original chose all ones to match 	some other utilities and to 'generate' even with zeroed files.	Actually, this is where a key could be used -- just set the CRC to 	start with the key value.*/unsigned longHash(unsigned long crc, unsigned char ichar){int crcTable_idx;unsigned long temp1;unsigned long temp2;		crcTable_idx = (crc ^ ichar) & 0xff;	// mix the input with the crc, 											// use to select the actual 											// mixing values to use.	temp1 = CRCTable[crcTable_idx];  		// get the changing bits	temp2 = (crc >> 8) & 0x00FFFFFFL;		// shift out the 8 bits we just used	crc = temp1 ^ temp2; 					// mix back together 		return (crc);}#if VWT && !VPRO	//jca 24OCT94 don't use in pro, silly.// jca 17JAN94 make vwt use old serializing method.#define OLD_SERIALIZER	1#endif// Verifies a serial number passed in string form...int CheckNumber(char *buffer){	short	temp = 0, i = 0, j = 0, flags;	char	temp_str[60];	char	prefix[60], dateFlags[4], checkSum[5];	short	bufLen;#if VR           // jca 20 Oct 93 {	long	crc = MakeID(' ', 'V', 'R', ' ');#elif VPRO        // need to test VPRO before VWT//	long	crc = MakeID('V', 'P', 'R', 'O');   // Pro 1.0 jca 24OCT94	long	crc = MakeID('P', 'R', 'O', '2');#elif VWT	long	crc = MakeID('V', 'W', 'T', ' ');#else#error No crc seed for the serial number#endif // VR     // jca 20 Oct 93 }	int		crcint = 0;#if DEBUG && !VINSTALLER	char	debugstr[10];#endif //DEBUG		bufLen = strlen(buffer);	if (bufLen < 7) return FALSE; // not enough characters	InitCRCTable();	for (i=0; i<bufLen; i++)		// make all caps		{		if ((buffer[i] >= 0x61) && (buffer[i] <=0x7A))			buffer[i] -= 0x20;		}#if !OLD_SERIALIZER	// jca 24OCT 94 [[[ for pro; ignore all non-alphanumerics	memset(temp_str, 0, 60);	for (i = 0, j = 0; i < bufLen; i++)		{		if ((((buffer[i] >= 0x61) && (buffer[i] <= 0x7A)) ||			((buffer[i] >= 0x41) && (buffer[i] <= 0x5A))) ||			((buffer[i] >= 0x30) && (buffer[i] <= 0x39)))            temp_str[j++] = buffer[i];		}	strcpy(buffer, temp_str);    bufLen = strlen(buffer);	if (bufLen < 7) return FALSE; // not enough characters#endif	// jca 24OCT 94 ]]] for pro; ignore all non-alphanumerics	checkSum[4] = 0x00;				// extract the checksum info	for (i = 3; i >=0; i--)		{		checkSum[i] = buffer[--bufLen];#if !OLD_SERIALIZER		if (checkSum[i] == 'O') checkSum[i] = '0';#endif // !OLD_SERIALIZER		}	if (buffer[bufLen-1] == '-') --bufLen;	dateFlags[3] = 0x00;				// extract the date flags	for (i = 2; i >=0; i--)		{		dateFlags[i] = buffer[--bufLen];#if !OLD_SERIALIZER		if (dateFlags[i] == 'O') dateFlags[i] = '0';#endif // !OLD_SERIALIZER		}	if (buffer[bufLen-1] == '-') --bufLen;		prefix[bufLen] = 0x00;	for (i=0; i < bufLen; i++)		{		prefix[i] = buffer[i];#if OLD_SERIALIZER		temp += prefix[i];#else		if ((prefix[i] == '0') && (i < bufLen-3))			prefix[i] = 'O';		if ((prefix[i] == 'O') && (i >= bufLen-3))			prefix[i] = '0';		crc = Hash(crc, prefix[i]);#endif // OLD_SERIALIZER		}	temp_str[1] = 0x00;	temp_str[0] = dateFlags[0];	sscanf(temp_str, "%X", &flags);#if OLD_SERIALIZER	if (!flags)		temp += NONE_FLAG;		// No flag modifiers	else		for (j = 8; j >= 1 && flags; j = j / 2)	// Extract flag mods			if ((flags - j) >= 0) 					flags -= j, temp += j;	temp_str[0] = dateFlags[1]; 		// Get Month	sscanf(temp_str, "%X", &j);	temp += j;	temp_str[0] = dateFlags[2]; 		// Get Year	sscanf(temp_str, "%X", &j);	temp += j;	Generate_CRC(temp_str, temp);				// Make a new CRC Value#else	if (!flags)		crc = Hash(crc, NONE_FLAG);		// No flag modifiers	else		for (j = 8; j >= 1 && flags; j = j / 2)	// Extract flag mods			if ((flags - j) >= 0) 				{ flags -= j; crc = Hash(crc, j); }	temp_str[0] = dateFlags[1]; 		// Get Month	sscanf(temp_str, "%X", &j);	crc = Hash(crc, j);	temp_str[0] = dateFlags[2]; 		// Get Year	sscanf(temp_str, "%X", &j);	crc = Hash(crc, j); 	 	for (j=1; j<=30*7; j+=7) Hash(crc,j);		//Slosh the bits around GJR091493		crcint = (int)(crc & 0x0000FFFF);	crcint += (int)(crc>>16)&0x0000FFFF;	BuildHexStr(temp_str, crcint, 4);			// Make a string from crc value#endif // OLD_SERIALIZER#if MACINTOSH && DEBUGdebugstr[0] = 8;debugstr[1] = temp_str[0];debugstr[2] = temp_str[1];debugstr[3] = temp_str[2];debugstr[4] = temp_str[3];debugstr[5] = checkSum[0];debugstr[6] = checkSum[1];debugstr[7] = checkSum[2];debugstr[8] = checkSum[3];debugstr[9] = 0;ParamText((unsigned char*)debugstr,NULL,NULL,NULL);Alert(3003,NULL);#endif //DEBUG	if (!strcmp(temp_str, checkSum))		// Compare it to one that was passed in.		{		sprintf(buffer,"%s-%s-%s",prefix,dateFlags,checkSum);		return TRUE;		}	else		return FALSE;}intDecode(char *str,int length)	{	if(length==0)return TRUE;	length--;	while(length)		{		str[length]^=str[length-1];		length--;		}	str[0]^='V';	return TRUE;	}int Encode(char *str,int length)	{	int i;	if(length==0)return TRUE;	str[0]^='V';	for(i=1;i<length;i++)		{		str[i]^=str[i-1];		}	return TRUE;	}time_t CheckDate(char *str)	{				int loc;	time_t theTime=0;		loc=FindChar(str,'-');	loc++;	if(0x01&HexToNum(str[loc]))/*not for resale copy*/		{		struct tm time;		time.tm_mon=HexToNum(str[loc+1]);		time.tm_year=HexToNum(str[loc+2]);		if(time.tm_year>0 && time.tm_mon>0)			{			time.tm_sec=time.tm_min=time.tm_hour=time.tm_wday=time.tm_yday=time.tm_isdst=0;			time.tm_year+=90;			time.tm_mon--;			time.tm_mday=1;			theTime=mktime(&time);			}		else theTime=1;		}	return theTime;	}intDoExpirationDate(char *str, char *dateStr)	{	time_t date;	int result=FALSE;	if(str != NULL)		{		date=*(time_t *)str;		if(date)			{			struct tm *ltime;			if(date==1)				sprintf((char *)dateStr,TXT_NOTRESALEERR);			else				{				ltime=localtime(&date);				if((unsigned long)date<(unsigned long)time(0))					{					sprintf(dateStr,"%s %d/%d/%d. %s",TXT_EXPIRED,ltime->tm_mon+1,ltime->tm_mday,ltime->tm_year,TXT_VIRTUSHELP);					result = TRUE;					}                else					sprintf((char *)dateStr,"%s %d/%d/%d %s",TXT_EXPDATE,ltime->tm_mon+1,ltime->tm_mday,ltime->tm_year,TXT_NOTRESALEERR);				}			}		}	return result;	}int HexToNum(char c){// jca 21 Oct 93 made this an if-else form.  Should be okay, and microsoft c++ is hot on the idea.if(c>='0' && c<='9')return (c-'0');else if(c>='a' && c<='f')return (10+c-'a');else if(c>='A' && c<='F')return (10+c-'A');else return(0);}