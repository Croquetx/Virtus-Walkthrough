/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  *		1) The query message dialog can handle 4 lines of text for a total of x characters. * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VDialog.h"#include "VDocumnt.h"#include "VWindow.h"#include "VItem.h"#include "VMenu.h"#include "VMemUtil.h"#include "VMain.h"#include "VGUtil.h"#include "VGraphic.h"#include "VTextDef.h"#include "WTypes.h"#include "VWI.H" //DAS-VWI 10/2/93#include "AppFiles.h"#include "AppText.h"	//PRO-JAP#include <stdio.h>#include <string.h>#if MACINTOSH#ifndef __powerc#include <profile.h>#endif#endifV_Meter	*vMeter = NULL;#if WINDOWSextern HWND hwndFrame;#endif //WINDOWS// { DAS-VWINDOWS-FIX 9/28/93 fixed this suckerint CenterDialog(Rect *r,int width,int height,int lineWidth)	{	int numLines,maxWidth,tmpWidth;		GetScreen(r);			maxWidth = ((r->right-r->left)/3)<<1;	maxWidth = min(maxWidth,400); // DAS-VWINDOWS 9/28/93	if(lineWidth>0)		{		maxWidth=min(maxWidth,width);		tmpWidth = maxWidth;		numLines = 1;//		lineWidth-=(lineWidth/10); 		tmpWidth-=D_LEDGE+D_ICNW+D_EDGE*2;	// DAS-VWINDOWS 9/29/93		tmpWidth-=(tmpWidth/10); 			// DAS-VWINDOWS 9/29/93		while(lineWidth>tmpWidth)			{			lineWidth-=tmpWidth;			numLines++;			}		}	else		{		numLines = 1;		maxWidth = width;        }		r->left = ((r->right - r->left) >> 1 ) - (maxWidth>>1);	r->right = r->left + maxWidth;	// MERGE-GOURAUD-PRO-10 [[[	#if 0	r->top = (r->bottom-r->top)/3;	r->bottom = r->top + height;	#else	// new code for centering vertically	r->top = ((r->bottom+r->top) >> 1) - (height >> 1);	r->bottom = r->top + height;	#endif	// MERGE-GOURAUD-PRO-10 ]]]	return numLines;	}// } DAS-VWINDOWS-FIX 9/28/93 V_Dialog *V_Dialog::cDialog(Rect *r)	{	V_Window *w;    V_Document *doc;	Point pt = {0,0};			resolution.h = resolution.v = 72; /* 72 pixels/inch */	useOffscreen = FALSE;	okay = FALSE;	defBtn = NULL;	cPane(0);	SetDisplayType(DISPLAY_DIALOG);// DAS-VWINDOWS 10/9/93	active = TRUE;	w = new(V_Window);#if WINDOWS	w->cWindow(r,title,pt,pt,pt,DRAGBAR|MODALDIALOG,WINDOW_DESTROY);#elif MACINTOSH	w->cWindow(r,title,pt,pt,pt,MODALDIALOG,WINDOW_DESTROY);	SetUp(w);#endif //WINDOWS	w->Install(this);	return(this);	}void V_Dialog::SetTitle(char *str)	{	strcpy(title,str);	if(theWindow)		theWindow->SetTitle(title);	}void V_Dialog::CloseDialog(void)	{	}void V_Dialog::dPane(void)	{	CloseDialog();	V_Pane::dPane();	}int V_Dialog::Modal(void)	{	V_Menu *vMenu;	VGrafPort hwnd;    V_Document *doc;	int i;#if MACINTOSH	for(i=0;i<visibleMMgr->ALength();i++)		{		visibleMMgr->Get(i,&vMenu);		vMenu->Activate(0,FALSE);		}	VFlushEvents(app2Mask);#elif WINDOWS//	SetCapture(paneWindow);	if (GetCapture())      // jca.  No one should have the capture here.		ReleaseCapture();#endif	MainEvent(MODAL);#if WINDOWS//	ReleaseCapture();#elif MACINTOSH	for(i=0;i<visibleMMgr->ALength();i++)		{		visibleMMgr->Get(i,&vMenu);		vMenu->Activate(0,TRUE);		}#endif //MACINTOSH	return(okay);	}void V_Dialog::Delete() {theWindow->Delete(); }void V_Dialog::Show(void)	{	theWindow->Show();	if (!GetText())		itemList->Tab(NULL);	}voidV_Dialog::SetDefBtn(V_CtrlButton *btn)	{	if(defBtn==btn) return;	if(NULL!=defBtn)defBtn->SetDefault(FALSE);	defBtn = btn;	if(NULL!=defBtn)defBtn->SetDefault(TRUE);	}void V_Dialog::CR(void)	{	if (!itemList||!defBtn) return;	defBtn->Action();	}void V_Dialog::Display(int type,int h,int v)	{	Rect	r;		if(useOffscreen)		{		r = dataRect;//		SetMetaPort();		VEraseRect(&r);		}			V_Pane::Display(type,h,v);	if(useOffscreen)		{//		MetaCopy(&r);//		UnsetMetaPort();		}	}int V_Dialog::KeyAction(char c, long modifier)	{	if (modifier & V_COMMAND) return FALSE;	if (c == V_ENTER || c == V_RETURN) CR();	return FALSE;	}	voidV_CtrlButton_Die::cItem()	{	okay = FALSE;	V_CtrlButton::cItem();	}voidV_CtrlButton_Die::Action()	{//	extern HWND hwndFrame;//	HWND saveHWND=hwndFrame;//	hwndFrame=thePane->paneWindow;	((V_Dialog *)thePane)->okay = okay;	VSendMessage(DieWindowEvent);//    hwndFrame=saveHWND;	}void V_CtrlButton_Die::SetFlag(int f) { okay = f; }/*** struct StdCloseDialog ***********************************************//* The standard dialog to be used when a document has unsaved changes. */intStdCloseDialog::cStdCloseDialog(strPtr fname)	{	V_CtrlButton_Die *button;	V_Array	*buttonGroup;	V_Document *doc;    V_Icon *icon;	V_Text *text;	char str[256];	Rect r;	int result;		r = systemLayoutSpec[stdCloseDlog].destRect;	CenterDialog(&r,r.right-r.left,r.bottom-r.top,0);	cDialog(&r);	#if WINDOWS	if((doc = GetCurrentDocument()) != NULL)		{        char str[256];		doc->GetTitlePrefix(str);		SetTitle(str);        }#endif //WINDOWS	sprintf((char *)str,systemLayoutSpec[saveMsg].title,fname);	text = new(V_Text);	text->cItem();	text->SetRect(&systemLayoutSpec[saveMsg].destRect);	text->SetText(str);	AddItem(text);		buttonGroup = new(V_Array);	buttonGroup->cArray(0,sizeof(V_CtrlButton_Die*),4);	/*see page 2-32 of IM Vol IV for this layout*/	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&systemLayoutSpec[saveSave].destRect);	button->SetText(systemLayoutSpec[saveSave].title);	button->SetFlag(QYES);	button->SetGroup(buttonGroup);	SetDefBtn(button);#if WINDOWS    button->SetCtrlNumber(IDYES);#endif	AddItem(button);			button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&systemLayoutSpec[saveDontSave].destRect);	button->SetText(systemLayoutSpec[saveDontSave].title);	button->SetFlag(QNO);	button->SetGroup(buttonGroup);#if WINDOWS	button->SetCtrlNumber(IDNO);#endif	AddItem(button);		button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&systemLayoutSpec[saveCancel].destRect);	button->SetText(systemLayoutSpec[saveCancel].title);	button->SetFlag(QCANCEL);	button->SetGroup(buttonGroup);#if WINDOWS    button->SetCtrlNumber(IDCANCEL);#endif	AddItem(button);	if(lowMemory>=memoryCritical)		button->Activate(FALSE);#if WINDOWS	icon = new(V_Icon);	icon->cItem();	icon->SetRect(&systemLayoutSpec[saveIcon].destRect);	icon->SetIconID(WARN_ICON_ID);	AddItem(icon);#endif //WINDOWS			useOffscreen = TRUE;			Show();	Modal();	result=okay;	Delete();		return result;	}QueryDialog *QueryDialog::cQueryDialog(strPtr msg)	{	V_CtrlButton_Die	*button;    V_Document *doc;	V_Array	*buttonGroup;	V_Text	*text;	V_Icon  *icon;	Rect r;		r = systemLayoutSpec[stdQueryDlog].destRect;	CenterDialog(&r,r.right-r.left,r.bottom-r.top,0);	cDialog(&r);#if WINDOWS	if((doc = GetCurrentDocument()) != NULL)		{        char str[256];		doc->GetTitlePrefix(str);		SetTitle(str);        }#endif //WINDOWS	text = new(V_Text);	text->cItem();	text->SetRect(&systemLayoutSpec[queryMsg].destRect);	text->SetText(msg);	AddItem(text);	buttonGroup = new(V_Array);	buttonGroup->cArray(0,sizeof(V_CtrlButton_Die*),4);	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&systemLayoutSpec[queryOK].destRect);	button->SetText(systemLayoutSpec[queryOK].title);	button->SetFlag(TRUE);	button->SetGroup(buttonGroup);#if WINDOWS    button->SetCtrlNumber(IDOK);#endif	SetDefBtn(button);	AddItem(button);	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&r);	button->SetRect(&systemLayoutSpec[queryCancel].destRect);	button->SetText(systemLayoutSpec[queryCancel].title);	button->SetFlag(FALSE);	button->SetGroup(buttonGroup);#if WINDOWS    button->SetCtrlNumber(IDCANCEL);#endif	AddItem(button);	icon = new(V_Icon);	icon->cItem();	icon->SetRect(&systemLayoutSpec[queryIcon].destRect);	icon->SetIconID(WARN_ICON_ID);	AddItem(icon);		useOffscreen = TRUE;	Show();		return(this);	}/*** struct AlertDialog ***********************************************//* A standard alert dialog. *//* A standard alert dialog. */#if MACINTOSH#define DIALOG_EDGEWIDTH	36#define DIALOG_MINWIDTH		173#define ALERT_HEIGHT		89#elif WINDOWS#define DIALOG_EDGEWIDTH	D_LEDGE+D_EDGE#define DIALOG_MINWIDTH		250#define ALERT_HEIGHT		110#endif //WINDOWSint AlertMessage(strPtr msg)	{	AlertDialog	*alert;	int result;	alert = new(AlertDialog);	result = alert->cAlertDialog(msg);//	Debugger();		// еееее ABD	return result;	}intAlertDialog::cAlertDialog(strPtr msg)	{	V_CtrlButton_Die	*button;	V_Document *doc;	V_Icon	*icon;	V_Text	*text;	Rect r,tr;#if WINDOWS	HDC	hdc;#endif //WINDOWS	int success,length,width,lines,textWidth;	#if WINDOWS	hdc = GetDC(NULL);	currentDevice = hdc;#endif //WINDOWS	VSetFont(vSystemFont,vSystemFontSize,vNormal);	length = strlen(msg);	width = VTextWidth(msg,0,length);#if WINDOWS	ReleaseDC(NULL,hdc);#endif //WINDOWS	if(width<DIALOG_MINWIDTH)width = DIALOG_MINWIDTH;	    textWidth=width;	width+=(DIALOG_EDGEWIDTH+D_ICNW+D_EDGE);		lines = CenterDialog(&r,width,ALERT_HEIGHT,textWidth);	r.bottom+=(lines-1)*D_LINEH;	cDialog(&r);#if WINDOWS	if((doc = GetCurrentDocument()) != NULL)		{        char str[256];		doc->GetTitlePrefix(str);		SetTitle(str);        }	else  // jca 5 Dec 93 ELVIS {		{		// This is really not a solution, but a hack. If there is		// no document, then messages don't make it back from the		// buttons to the windows.  I'm TEMPORARILY going to call		// MessageBox() instead of our stuff.		MessageBox(NULL, msg, NULL, MB_OK|MB_ICONINFORMATION);        Delete();		return(okay); 		} // jca 5 Dec 93 ELVIS }#endif //WINDOWS	r.right -= r.left;	r.bottom -= r.top;	r.left = 0;	r.top = 0;	tr = r;	tr.left = D_LEDGE;	tr.right = tr.left+D_ICNW;	tr.top = D_EDGE;	tr.bottom = tr.top+D_ICNH;	icon = new(V_Icon);	icon->cItem();	icon->SetRect(&tr);	icon->SetIconID(ALERT_ICON_ID);	AddItem(icon);	tr.left = tr.right + D_EDGE;	tr.top = D_EDGE + (D_ICNH-D_TEXTH>>1);	tr.bottom = tr.top + (lines*D_LINEH+3);	tr.right = r.right - D_EDGE;	text = new(V_Text);	text->cItem();	text->SetRect(&tr);	text->SetText(msg);	AddItem(text);#if MACINTOSH	tr = r;	tr.right-=D_EDGE; 	tr.left = tr.right - D_BTNW;	tr.bottom -= D_EDGE;	tr.top = tr.bottom - D_BTNH;#elif WINDOWS	tr = r;	tr.left = (tr.right-D_BTNW) >> 1; 	tr.right = tr.left + D_BTNW;	tr.bottom -= D_EDGE; 	tr.top = tr.bottom - D_BTNH;#endif //WINDOWS	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&tr);	button->SetText(TXTC_OK);	button->SetFlag(TRUE);	SetDefBtn(button);#if WINDOWS    button->SetCtrlNumber(IDOK);#endif	AddItem(button);		useOffscreen = TRUE;	Show();	success = Modal();		Delete();		return(success);	}// MERGE-VPRO-2 [[[#define FOUR_BUTTON_HEIGHT	72int FourButtonMessage(strPtr msg,strPtr b1Text,strPtr b2Text,strPtr b3Text,strPtr b4Text, int def)	{	FourButtonDialog	*fb;	int result;	fb = new(FourButtonDialog);	result = fb->cFourButtonDialog(msg,b1Text,b2Text,b3Text,b4Text,def);	return result;	}intFourButtonDialog::cFourButtonDialog(strPtr msg,strPtr button1Text,strPtr button2Text,	strPtr button3Text,strPtr button4Text, int whichDefault)	{	V_Text			*statText;	V_CtrlButton_Die	*button;	Rect tr,r;	int success,width,length,lines;			VSetFont(vSystemFont,vSystemFontSize,vNormal);	length = strlen(msg);	width = VTextWidth(msg,0,length);	if(width<DIALOG_MINWIDTH)width = DIALOG_MINWIDTH;	width+=DIALOG_EDGEWIDTH;		lines = CenterDialog(&r,width+50,FOUR_BUTTON_HEIGHT,width);	r.bottom+=(lines-1)*16;	cDialog(&r);	r.right -= r.left;	r.bottom -= r.top;	r.left = 0;	r.top = 0;	tr = r;		tr.left = 23;tr.top = 13;tr.bottom = tr.top + (lines*16+3);tr.right-=13;	statText = new(V_Text);	statText->cItem();	statText->SetRect(&tr);	statText->SetText(msg);	AddItem(statText);		tr = r;/* buttonOne */	tr.bottom = tr.bottom - 10;	tr.top = tr.bottom - 20;	tr.right = tr.right - 13; tr.left = tr.right - 120;	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&tr);	button->SetText(button1Text);	button->SetFlag(1);	//MERGE-PRO-JAM-2	if  ((whichDefault & DEFAULT_BUTTON_TWO) == DEFAULT_BUTTON_TWO)		SetDefBtn(button);	AddItem(button);	/* buttonTwo */	tr.right = tr.left - 13; tr.left = tr.right - 120;	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&tr);	button->SetText(button2Text);	button->SetFlag(2);	//MERGE-PRO-JAM-2	if  ((whichDefault & DEFAULT_BUTTON_TWO) == DEFAULT_BUTTON_TWO)		SetDefBtn(button);	AddItem(button);	/* buttonThree */	tr.right = tr.left - 13; tr.left = tr.right - 120;	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&tr);	button->SetText(button3Text);	button->SetFlag(3);	//MERGE-PRO-JAM-2	if  ((whichDefault & DEFAULT_BUTTON_THREE) == DEFAULT_BUTTON_THREE)		SetDefBtn(button);	AddItem(button);/* buttonFour */	tr.right = tr.left - 13; tr.left = tr.right - 120;	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&tr);	button->SetText(button4Text);	button->SetFlag(4);	//MERGE-PRO-JAM-2	if  ((whichDefault & DEFAULT_BUTTON_FOUR) == DEFAULT_BUTTON_FOUR)		SetDefBtn(button);	AddItem(button);		useOffscreen = TRUE;	Show();		success = Modal();		Delete();		return(success);	}#if MACINTOSH#define SIX_BUTTON_HEIGHT	88	//MERGE-PRO-JAM-3#define SIX_BUTTON_MINWIDTH	173	//MERGE-PRO-JAM-3#elif WINDOWS#define SIX_BUTTON_HEIGHT	88	//MERGE-PRO-JAM-3#define SIX_BUTTON_MINWIDTH	400	//MERGE-PRO-JAM-3#endifint SixButtonMessage(strPtr msg,strPtr b1Text,strPtr b2Text,strPtr b3Text,strPtr b4Text, strPtr b5Text,strPtr b6Text,int def)	{	SixButtonDialog	*fb;	int result;	fb = new(SixButtonDialog);	result = fb->cSixButtonDialog(msg,b1Text,b2Text,b3Text,b4Text,b5Text,b6Text,def);	return result;	}intSixButtonDialog::cSixButtonDialog(strPtr msg,strPtr button1Text,strPtr button2Text,	strPtr button3Text,strPtr button4Text, strPtr button5Text,strPtr button6Text,int whichDefault)	{	V_Text			*statText;	V_CtrlButton_Die	*button;	Rect tr,r;	int success,width,length,lines;		VSetFont(vSystemFont,vSystemFontSize,vNormal);	length = strlen(msg);	width = VTextWidth(msg,0,length);	//MERGE-PRO-JAM-3	if(width<SIX_BUTTON_MINWIDTH)width = SIX_BUTTON_MINWIDTH; //MERGE-PRO-JAM-3	width+=DIALOG_EDGEWIDTH;		lines = CenterDialog(&r,width,SIX_BUTTON_HEIGHT,width); //MERGE-PRO-JAM-3	r.bottom+=(lines-1)*16;	cDialog(&r);	r.right -= r.left;	r.bottom -= r.top;	r.left = 0;	r.top = 0;	tr = r;		tr.left = 23;tr.top = 13;tr.bottom = tr.top + (lines*16+3);tr.right-=10;	statText = new(V_Text);	statText->cItem();	statText->SetRect(&tr);	statText->SetText(msg);	AddItem(statText);		tr = r;/* buttonOne */	tr.bottom = tr.bottom - 10;	tr.top = tr.bottom - 20;	tr.right = tr.right - 10; tr.left = tr.right - 120;	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&tr);	button->SetText(button1Text);	button->SetFlag(1);	//MERGE-PRO-JAM-2	if  ((whichDefault & DEFAULT_BUTTON_ONE) == DEFAULT_BUTTON_ONE)		SetDefBtn(button);	AddItem(button);	/* buttonTwo */	tr.right = tr.left - 10; tr.left = tr.right - 120;	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&tr);	button->SetText(button2Text);	button->SetFlag(2);	//MERGE-PRO-JAM-2	if  ((whichDefault & DEFAULT_BUTTON_TWO) == DEFAULT_BUTTON_TWO)		SetDefBtn(button);	AddItem(button);	/* buttonThree */	tr.right = tr.left - 10; tr.left = tr.right - 120;	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&tr);	button->SetText(button3Text);	button->SetFlag(3);	//MERGE-PRO-JAM-2	if  ((whichDefault & DEFAULT_BUTTON_THREE) == DEFAULT_BUTTON_THREE)		SetDefBtn(button);	AddItem(button);/* buttonFour */	tr.bottom = tr.top - 9;	tr.top = tr.bottom - 20;	tr.right = r.right - 10; tr.left = tr.right - 120;	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&tr);	button->SetText(button4Text);	button->SetFlag(4);	//MERGE-PRO-JAM-2	if  ((whichDefault & DEFAULT_BUTTON_FOUR) == DEFAULT_BUTTON_FOUR)		SetDefBtn(button);	AddItem(button);/* buttonFive */	tr.right = tr.left - 10; tr.left = tr.right - 120;	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&tr);	button->SetText(button5Text);	button->SetFlag(5);	//MERGE-PRO-JAM-2	if  ((whichDefault & DEFAULT_BUTTON_FIVE) == DEFAULT_BUTTON_FIVE)		SetDefBtn(button);	AddItem(button);/* buttonSix */	tr.right = tr.left - 10; tr.left = tr.right - 120;	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&tr);	button->SetText(button6Text);	button->SetFlag(6);	//MERGE-PRO-JAM-2	if  ((whichDefault & DEFAULT_BUTTON_SIX) == DEFAULT_BUTTON_SIX)		SetDefBtn(button);	AddItem(button);		useOffscreen = TRUE;	Show();		success = Modal();		Delete();		return(success);	}#if MACINTOSH#define THREE_BUTTON_HEIGHT	72	//MERGE-PRO-JAM-3#define THREE_BUTTON_MINWIDTH	173	//MERGE-PRO-JAM-3#elif WINDOWS#define THREE_BUTTON_HEIGHT	72	//MERGE-PRO-JAM-3#define THREE_BUTTON_MINWIDTH	400	//MERGE-PRO-JAM-3#endifint ThreeButtonMessage(strPtr msg,strPtr b1Text,strPtr b2Text,strPtr b3Text, int def)	{	ThreeButtonDialog	*fb;	int result;	fb = new(ThreeButtonDialog);	result = fb->cThreeButtonDialog(msg,b1Text,b2Text,b3Text,def);	return result;	}intThreeButtonDialog::cThreeButtonDialog(strPtr msg,strPtr button1Text,strPtr button2Text,	strPtr button3Text,int whichDefault)	{	V_Text			*statText;	V_CtrlButton_Die	*button;	Rect tr,r;	int success,width,length,lines;	 	VSetFont(vSystemFont,vSystemFontSize,vNormal);	length = strlen(msg);	width = VTextWidth(msg,0,length);	if(width<THREE_BUTTON_MINWIDTH)width = THREE_BUTTON_MINWIDTH; //MERGE-PRO-JAM-3	width+=DIALOG_EDGEWIDTH;		lines = CenterDialog(&r,width,THREE_BUTTON_HEIGHT,width); //MERGE-PRO-JAM-3	r.bottom+=(lines-1)*16;	cDialog(&r);	r.right -= r.left;	r.bottom -= r.top;	r.left = 0;	r.top = 0;	tr = r;		tr.left = 23;tr.top = 13;tr.bottom = tr.top + (lines*16+3);  // PRO-12	tr.right-=((r.right - r.left) - 380) >> 1;	// MERGE-GOURAUD-PRO-12	statText = new(V_Text);	statText->cItem();	statText->SetRect(&tr);	statText->SetText(msg);	AddItem(statText);		tr = r;/* buttonOne */	tr.bottom = tr.bottom - 10;	tr.top = tr.bottom - 20;	tr.right = tr.right - 10; tr.left = tr.right - 120;	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&tr);	button->SetText(button1Text);	button->SetFlag(1);	//MERGE-PRO-JAM-2	if  ((whichDefault & DEFAULT_BUTTON_ONE) == DEFAULT_BUTTON_ONE)		SetDefBtn(button);	AddItem(button);	/* buttonTwo */	tr.right = tr.left - 10; tr.left = tr.right - 120;	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&tr);	button->SetText(button2Text);	button->SetFlag(2);	//MERGE-PRO-JAM-2	if  ((whichDefault & DEFAULT_BUTTON_TWO) == DEFAULT_BUTTON_TWO)		SetDefBtn(button);	AddItem(button);	/* buttonThree */	tr.right = tr.left - 10; tr.left = tr.right - 120;	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&tr);	button->SetText(button3Text);	button->SetFlag(3);	//MERGE-PRO-JAM-2	if  ((whichDefault & DEFAULT_BUTTON_THREE) == DEFAULT_BUTTON_THREE)		SetDefBtn(button);	AddItem(button);		useOffscreen = TRUE;	Show();		success = Modal();		Delete();		return(success);	}// MERGE-VPRO-2 ]]]#if MACINTOSH#define WARNING_HEIGHT	72#elif WINDOWS#define WARNING_HEIGHT	110#endif //WINDOWSint WarningMessage(strPtr msg,strPtr b1Text,strPtr b2Text, int def)	{	WarningDialog	*warning;	int result;	warning = new(WarningDialog);	result = warning->cWarningDialog(msg,b1Text,b2Text,def);//	Debugger();		// ееееее	return result;	}intWarningDialog::cWarningDialog(strPtr msg,strPtr button1Text,strPtr button2Text,int whichDefault)	{	V_CtrlButton_Die	*button;	V_Array	*buttonGroup;	V_Document *doc;	V_Icon	*icon;	V_Text	*text;	Rect tr,r;#if WINDOWS	HDC	hdc;#endif //WINDOWS	int success,length,width,lines,textWidth;	#if WINDOWS	hdc = GetDC(NULL);	currentDevice = hdc;#endif //WINDOWS	VSetFont(vSystemFont,vSystemFontSize,vNormal);	length = strlen(msg);	width = VTextWidth(msg,0,length);#if WINDOWS	ReleaseDC(NULL,hdc);#endif //WINDOWS	if(width<DIALOG_MINWIDTH)width = DIALOG_MINWIDTH;    textWidth=width;	width+=(DIALOG_EDGEWIDTH+D_ICNW+D_EDGE);	lines = CenterDialog(&r,width,WARNING_HEIGHT,textWidth);	r.bottom+=(lines-1)*D_LINEH;	cDialog(&r);#if WINDOWS	if((doc = GetCurrentDocument()) != NULL)		{        char str[256];		doc->GetTitlePrefix(str);		SetTitle(str);		}#endif //WINDOWS	r.right -= r.left;	r.bottom -= r.top;	r.left = 0;	r.top = 0;	tr = r;	tr.left = D_LEDGE;	tr.right = tr.left+D_ICNW;	tr.top = D_EDGE;	tr.bottom = tr.top+D_ICNH;	icon = new(V_Icon);	icon->cItem();	icon->SetRect(&tr);	icon->SetIconID(WARN_ICON_ID);	AddItem(icon);	tr.left = tr.right + D_EDGE;	#if MACINTOSH		// MERGE-GOURAUD-PRO-12	tr.top = D_EDGE;		// MERGE-GOURAUD-PRO-12 stop making dialogs look ugly	#else		// MERGE-GOURAUD-PRO-12 stop making dialogs look ugly	tr.top = D_EDGE + (D_ICNH-D_TEXTH>>1);		// MERGE-GOURAUD-PRO-12 stop making dialogs look ugly	#endif 	// MACINTOSH	// MERGE-GOURAUD-PRO-12 stop making dialogs look ugly	tr.bottom = tr.top + (lines*D_LINEH+3);	tr.right = r.right - D_EDGE;	text = new(V_Text);	text->cItem();	text->SetRect(&tr);	text->SetText(msg);	AddItem(text);	buttonGroup = new(V_Array);	buttonGroup->cArray(0,sizeof(V_CtrlButton_Die*),4);/* buttonTwo */#if MACINTOSH	tr = r;	tr.right-=D_EDGE; tr.left = tr.right - D_BTNW;	tr.bottom-=D_EDGE; tr.top = tr.bottom - D_BTNH;#elif WINDOWS	tr = r;	tr.right = (tr.right-D_BTNSEP) >> 1; 	tr.left = tr.right - D_BTNW;	tr.bottom -= D_EDGE; 	tr.top = tr.bottom - D_BTNH;#endif //WINDOWS	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&tr);	button->SetText(button2Text);	button->SetFlag(!(whichDefault&POSITIVE_BUTTON_ONE) ? TRUE : FALSE);	button->SetGroup(buttonGroup);	if(!(whichDefault&DEFAULT_BUTTON_ONE)) 	SetDefBtn(button);#if WINDOWS	button->SetCtrlNumber(button->GetCtrlNumber(button2Text));#endif	AddItem(button);/* buttonOne */#if MACINTOSH	tr.right = tr.left - D_EDGE; tr.left = tr.right - D_BTNW;#elif WINDOWS	tr.left = tr.right + D_BTNSEP;	tr.right = tr.left + D_BTNW;#endif //WINDOWS	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&tr);	button->SetText(button1Text);	button->SetFlag(whichDefault&POSITIVE_BUTTON_ONE ? TRUE : FALSE);	button->SetGroup(buttonGroup);	if(whichDefault&DEFAULT_BUTTON_ONE) SetDefBtn(button);#if WINDOWS	button->SetCtrlNumber(button->GetCtrlNumber(button1Text));#endif	AddItem(button);		useOffscreen = TRUE;	Show();		success = Modal();		Delete();		return(success);	}int  InputTextDialog::cInputDialog(char *winTitle, char *titleStr, char *str,int inputType)	{	V_Text 	*title;	V_CtrlButton_Die 	*button;	V_Array	*buttonGroup;	V_EditText 	*name;	Rect		r;	int			success;	r = systemLayoutSpec[stdInputDlog].destRect;	CenterDialog(&r,r.right-r.left,r.bottom-r.top,0);	cDialog(&r);	frame = 3;    SetTitle(winTitle);		title = new(V_Text);	title->cItem();	title->SetRect(&systemLayoutSpec[inputTitle].destRect);	title->SetText(titleStr);	AddItem(title);	name = new(V_EditText);	name->cItem();	name->SetRect(&systemLayoutSpec[inputType].destRect);	name->SetText(str);//	name->SetSelect(0,32767); // this must happen after the item is added, and occurs in the SetText()	AddItem(name);	buttonGroup = new(V_Array);	buttonGroup->cArray(0,sizeof(V_CtrlButton_Die*),4);	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&systemLayoutSpec[inputOK].destRect);	button->SetText(systemLayoutSpec[inputOK].title);	button->SetFlag(TRUE);	button->SetGroup(buttonGroup);	SetDefBtn(button);#if WINDOWS    button->SetCtrlNumber(IDOK);#endif	AddItem(button);	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&systemLayoutSpec[inputCancel].destRect);	button->SetText(systemLayoutSpec[inputCancel].title);	button->SetFlag(FALSE);	button->SetGroup(buttonGroup);#if WINDOWS    button->SetCtrlNumber(IDCANCEL);#endif	AddItem(button);	useOffscreen = TRUE;	Show();		SetText(name);	if(Modal())			{		name->GetText(str);		success = TRUE;		}	else		success = FALSE;			Delete();		return(success);	}#if VRML_ANCHOR			// VRML-ABD 23JUN95int  WideInputTextDialog::cInputDialog(char *winTitle, char *titleStr, char *str,int inputType)	{	V_Text 	*title;	V_CtrlButton_Die 	*button;	V_Array	*buttonGroup;	V_EditText 	*name;	Rect		r;	int			success;	int realInputType;	r = systemLayoutSpec[stdInputDlogWide].destRect;	CenterDialog(&r,r.right-r.left,r.bottom-r.top,0);	cDialog(&r);	frame = 3;    SetTitle(winTitle);        if (inputType == inputText)    	realInputType = inputTextWide;    else if (inputType == inputNumber)    	realInputType = inputNumberWide;		title = new(V_Text);	title->cItem();	title->SetRect(&systemLayoutSpec[inputTitleWide].destRect);	title->SetText(titleStr);	AddItem(title);	name = new(V_EditText);	name->cItem();	name->SetRect(&systemLayoutSpec[realInputType].destRect);	name->SetText(str);//	name->SetSelect(0,32767); // this must happen after the item is added, and occurs in the SetText()	AddItem(name);	buttonGroup = new(V_Array);	buttonGroup->cArray(0,sizeof(V_CtrlButton_Die*),4);	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&systemLayoutSpec[inputOKWide].destRect);	button->SetText(systemLayoutSpec[inputOKWide].title);	button->SetFlag(TRUE);	button->SetGroup(buttonGroup);	SetDefBtn(button);#if WINDOWS    button->SetCtrlNumber(IDOK);#endif	AddItem(button);	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&systemLayoutSpec[inputCancelWide].destRect);	button->SetText(systemLayoutSpec[inputCancelWide].title);	button->SetFlag(FALSE);	button->SetGroup(buttonGroup);#if WINDOWS    button->SetCtrlNumber(IDCANCEL);#endif	AddItem(button);	useOffscreen = TRUE;	Show();		SetText(name);	if(Modal())			{		name->GetText(str);		success = TRUE;		}	else		success = FALSE;			Delete();		return(success);	}#endif // VRML_ANCHORint  QRevert(char *fileName)	{	QueryRevert	*qRevert;	int			result = 0;		qRevert = new(QueryRevert);	result = qRevert->DoQuery(fileName);		return(result);	}intQueryRevert::DoQuery(char *fileName)	{	V_Text *text;	V_Document *doc;	V_Icon *icon;	V_CtrlButton_Die *button;	V_Array	*buttonGroup;	char	str[256];	Rect	r;	int		result;		r = systemLayoutSpec[stdRevertDlog].destRect;	CenterDialog(&r,r.right-r.left,r.bottom-r.top,0);	cDialog(&r);	#if WINDOWS	if((doc = GetCurrentDocument()) != NULL)		{        char str[256];		doc->GetTitlePrefix(str);		SetTitle(str);        }#endif //WINDOWS	sprintf(str,systemLayoutSpec[discardSMsg].title,fileName);	text = new(V_Text);	text->cItem();	text->SetRect(&systemLayoutSpec[discardSMsg].destRect);	text->SetText(str);	AddItem(text);	buttonGroup = new(V_Array);	buttonGroup->cArray(0,sizeof(V_CtrlButton_Die*),4);	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&systemLayoutSpec[discardYes].destRect);	button->SetText(systemLayoutSpec[discardYes].title);	button->SetFlag(TRUE);	button->SetGroup(buttonGroup);	SetDefBtn(button);#if WINDOWS    button->SetCtrlNumber(IDYES);#endif	AddItem(button);	button = new(V_CtrlButton_Die);	button->cItem();	button->SetRect(&systemLayoutSpec[discardNo].destRect);	button->SetText(systemLayoutSpec[discardNo].title);	button->SetFlag(FALSE);	button->SetGroup(buttonGroup);#if WINDOWS    button->SetCtrlNumber(IDNO);#endif	AddItem(button);#if WINDOWS	icon = new(V_Icon);	icon->cItem();	icon->SetRect(&systemLayoutSpec[revertIcon].destRect);	icon->SetIconID(WARN_ICON_ID);	AddItem(icon);#endif //WINDOWS			useOffscreen = TRUE;	Show();	result =  Modal();	Delete();		return(result);	}// PRO25 [[[int  QOKCancel(char *str)	{	QueryDialog	*q;	int result = 0;		q = new(QueryDialog);	q->cQueryDialog(str);	result =  q->Modal();	q->Delete();		return(result);	}// PRO25 ]]]#if MACINTOSH#define METER_WIDTH			293#define METER_HEIGHT		86#define METER_SHEIGHT		70#define METER_SSHEIGHT		54#define METER_SPACE			13#define METER_TEXTHEIGHT	16#define METER_TEXTWIDTH		250#define METER_COUNTWIDTH	38#define METER_FILLHEIGHT	11#define METER_FILLWIDTH		188#define METER_FILLLEFT		13#define METER_BUTTONHEIGHT	20#define METER_BUTTONWIDTH	59#define METER_BUTTONLEFT	234#elif WINDOWS#define METER_WIDTH			297//#define METER_HEIGHT		98//#define METER_SHEIGHT		82//#define METER_SSHEIGHT		66#define METER_HEIGHT	   122#define METER_SHEIGHT	   104#define METER_SSHEIGHT		68#define METER_SPACE			13//#define METER_TEXTHEIGHT	18#define METER_TEXTHEIGHT	18#define METER_TEXTWIDTH		250#define METER_COUNTWIDTH	38#define METER_FILLHEIGHT	13#define METER_FILLWIDTH		188#define METER_FILLLEFT		13#define METER_BUTTONHEIGHT	28#if JAPANESE#define METER_BUTTONWIDTH	84#else#define METER_BUTTONWIDTH	61#endif //JAPANESE#define METER_BUTTONLEFT	236#endif //WINDOWSRGBColor meterBlue= { 0xCCCD, 0xCCCD, 0xFFFF };RGBColor meterGray = { 0x451F, 0x451F, 0x451F };#define NUM_TICKS WAITTIME(167)  /* The number of clock ticks between meter updates.  The higher							the number, the less often the meter can update. */					/*  So far, the performance testing indicates that this value						is almost completely irrelevant... It only seems to have						an effect on the meter's appearance, not the program's						performance.  For now it's only a precautionary measure						against someone calling the hell out of the update routine. */ 														void StopButton::Action()	{#if MACINTOSH	((V_Dialog *)thePane)->okay = TRUE;#elif WINDOWS	V_CtrlButton_Die::Action();#endif //MACINTOSH	}/* I needed to "reinvent the wheel" on this one in order to have dialog boxes	with title bars. */V_Dialog  *V_Meter::cDialog(Rect *r)	{	V_Window *w;	Point pW = InitPt(0,METER_WIDTH);	Point pMin = InitPt(METER_SSHEIGHT,METER_WIDTH);	Point pMax;	Rect  screenRect;			// BILL - need to make bigger for credit meter stuff sometimes.	GetScreen(&screenRect);	pMax.h = screenRect.right - screenRect.left - 20;	pMax.v = screenRect.bottom - screenRect.top - 80;	w = new(V_Window);	useOffscreen = FALSE;	okay = FALSE;	defBtn = NULL;	cPane(FALSE);	active = TRUE;	frame = 3;	w->cWindow(r, TXT_PROGRESS, pMin, pMax, pW, DRAGBAR|MODALDIALOG, WINDOW_DESTROY);	// PRO-JAP	w->Install(this);		return(this);	}void V_Meter::cMeter(int code)		// ABD MERGE21	{		Rect	r;			message = NULL;	message2 = NULL;	countText = NULL;	GetScreen(&r);	fillBox = r;		current_pos = 0;	total = 0, 	show_count = FALSE;	cDialog(&r);// MERGE21 [[[	if (code == 0)	{		stop = new(StopButton);		stop->SetRect(&r);		stop->SetText(TXTC_CANCEL);		stop->SetFlag(QCANCEL);		SetDefBtn(stop);	#if WINDOWS	    stop->SetCtrlNumber(IDCANCEL);	#endif	AddItem(stop);	}	else if (code == STOP_BUTTON)	{		stop = new(StopButton);		stop->SetRect(&r);		stop->SetText(TXTC_STOP);		stop->SetFlag(TRUE);		SetDefBtn(stop);	#if WINDOWS	    stop->SetCtrlNumber(IDCANCEL);	#endif	}	else if (code == NO_BUTTON)	{		stop = NULL;	}// MERGE21 ]]]	if(!countText)		{		countText = new(V_Text);		countText->cItem();		countText->SetRect(&r);		AddItem(countText);		}	}void V_Meter::StartMeter()	{	Rect		wr, br, fr, m1r, m2r, cr;	int 		size, i, height, width;	extern int	dontMoveDialog;	GetScreen(&wr);	wr.left = wr.left + ((wr.right-wr.left)>>1) - (METER_WIDTH>>1);/* centered */	wr.right = wr.left + METER_WIDTH;	wr.top = wr.top + ((wr.bottom-wr.top)>>1) - (METER_HEIGHT>>1); /* third from the top */		m1r.left = METER_FILLLEFT;	m1r.right = METER_FILLLEFT + METER_TEXTWIDTH;	m1r.top = METER_SPACE;	m1r.bottom = m1r.top + METER_TEXTHEIGHT;	#if WINDOWS	m1r.bottom += METER_TEXTHEIGHT; //JAM 10OCT94 make room for 2 lines of meter text    #endif	m2r.left = METER_FILLLEFT;	m2r.right = METER_FILLLEFT + METER_TEXTWIDTH;	m2r.top = m1r.bottom + 2;	m2r.bottom = m2r.top + METER_TEXTHEIGHT;		size = 0;	if (message) size++;	if (message2) size++;	switch(size)		{		case 0:			wr.bottom = wr.top + METER_SSHEIGHT;			m1r.bottom = m2r.bottom = 0;			break;		case 1:			wr.bottom = wr.top + METER_SHEIGHT;			m2r = m1r;			break;		case 2:			wr.bottom = wr.top + METER_HEIGHT;			break;		}	if (message) message->SetRect(&m1r);	if (message2) message2->SetRect(&m2r);	if (countText)		{		cr = m2r;		cr.left = METER_BUTTONLEFT;		cr.right = cr.left + METER_COUNTWIDTH;		countText->SetRect(&cr);		}			theWindow->SetTitle(title);	theWindow->Move(&wr);		height = wr.bottom - wr.top;	width = wr.right - wr.left;		fr.left = METER_FILLLEFT;	if (stop)		fr.right = width - METER_SPACE - METER_BUTTONWIDTH - METER_FILLLEFT;	else		fr.right = width - METER_FILLLEFT;	fr.bottom = (height-METER_SPACE) - ((METER_BUTTONHEIGHT-METER_FILLHEIGHT)>>1);	fr.top = fr.bottom - METER_FILLHEIGHT;	fillBox = fr;    lastRight = 0;    SetTotal(total);	if (stop)		{		br.right = width - METER_SPACE;		br.left = br.right - METER_BUTTONWIDTH;		br.bottom = height - METER_SPACE;		br.top = br.bottom - METER_BUTTONHEIGHT;		stop->SetRect(&br);		}		Show();	VDisplay(DRAW);		/* Redraw necessary in order to show stat texts. */#if WINDOWS	dontMoveDialog=TRUE;	MSG msg;    int result;	while(PeekMessage(&msg,NULL,0,0,PM_NOYIELD|PM_REMOVE))		{		result = IsDialogMessage(paneWindow, &msg);		if (!result)			{			TranslateMessage (&msg);			DispatchMessage (&msg);			}		}    dontMoveDialog=FALSE;#endif //WINDOWS	}	void V_Meter::Display(int type,int x,int y)	{	Rect	r;		Rect	r1,r2;	Point	p;    int		temp;	r1 = fillBox;	switch(type)		{		case -DRAW:			r1.top++;			r1.bottom--;			r1.left++;			r1.right--;			if (r1.right > r1.left)            	{				VForeColor(&meterGray);				VPaintRect(&r1);				VForeColor(&vBlack);				}			break;#if MACINTOSH		case ACT_REDRAW:			Display(-DRAW, x, y);		case DRAW:			{			int evenOdd=0;			PolyHandle poly;			int i;						r = dataRect;			VClipRect(&r);			VFrameRect(&fillBox);						if (creditBitmap)				{				short	delta;								r = creditBitmap->rect;				r.top += METER_SPACE;				r.bottom += METER_SPACE;				r.left += METER_SPACE;				r.right += METER_SPACE;				delta = dataRect.right - dataRect.left - (METER_SPACE*2);				if (delta > (r.right-r.left))					{					delta = delta - (r.right-r.left);					r.right += (delta/2);					r.left += (delta/2);					}									// ABD JAN95 [[[				if (r.left < dataRect.left+METER_SPACE)					r.left = dataRect.left+METER_SPACE;				if (r.top < dataRect.top+METER_SPACE)					r.top = dataRect.top+METER_SPACE;				if (r.bottom > dataRect.bottom-METER_SPACE)					r.bottom = dataRect.bottom-METER_SPACE;				if (r.right > dataRect.right-METER_SPACE)					r.right = dataRect.right-METER_SPACE;				// ABD JAN95 ]]]				creditBitmap->MetaTo(this,&creditBitmap->rect,&r);				}			}#endif //MACINTOSH		default:#if WINDOWS			r = dataRect;			SetMetaPort();			VEraseRect(&r);			VForeColor(&meterBlue);			VPaintRect(&r1);			VForeColor(&vBlack);			VFrameRect(&r1);			MetaCopy(&r);			UnsetMetaPort();			if (creditBitmap)				{				short	delta;								r = creditBitmap->rect;				r.top += METER_SPACE;				r.bottom += METER_SPACE;				r.left += METER_SPACE;				r.right += METER_SPACE;				delta = dataRect.right - dataRect.left - (METER_SPACE*2);				if (delta > (r.right-r.left))					{					delta = delta - (r.right-r.left);					r.right += (delta/2);					r.left += (delta/2);					}				creditBitmap->MetaTo(this,&creditBitmap->rect,&r);				}#endif //WINDOWS			V_Pane::Display(type,x,y);			break;		}	if (show_count)		countText->Display();		}/* Returns TRUE if Stop button has been pressed. */int V_Meter::Update(long progress){		Point	p;	long	modifier;	int		rightval, oldval, saveval = fillBox.right;	char	ch;#if MACINTOSH	EventRecord	myEvent;#endif //MACINTOSH	if (okay) return TRUE;	if ((current_pos > total) || (total == -1)) 		oldval = fillBox.right - fillBox.left;	else		oldval = current_pos * total_inv + .5;		if (total == -1)		current_pos = progress;	else		current_pos += progress;		if ((current_pos > total) || (total == -1)) 		rightval = fillBox.right - fillBox.left;	else 		rightval = current_pos * total_inv + .5;			fillBox.right = fillBox.left + rightval;	if (total!=-1 && show_count) sprintf (count_text, "%ld", total - current_pos);	/*update the box only if it has changed at least one pixel*///	if (oldval != rightval)		VDisplay(-DRAW);	fillBox.right = saveval;#if MACINTOSH	if(EventAvail(keyDownMask|keyUpMask|autoKeyMask|mDownMask|mUpMask, &myEvent))		{		 switch(myEvent.what)			{			case keyDown:				ch = (myEvent.message & charCodeMask);				/* <ESC> or Command-. */				if (ch == V_ESCAPE || (ch == '.' && (myEvent.modifiers & cmdKey)))				if (stop) stop->Action();	// MERGE21				break;			case mouseDown:				p = myEvent.where;				modifier=myEvent.modifiers;				GlobalToLocal(&p);				MouseClick(p, modifier);				break;			default:				break;			}		FlushEvents(keyDownMask|keyUpMask|autoKeyMask|mDownMask|mUpMask,0);		}#elif WINDOWS		MSG msg;		int result;		extern int dontMoveDialog;        dontMoveDialog=TRUE;		while(PeekMessage(&msg,NULL,0,0,PM_NOYIELD|PM_REMOVE))			{			if (msg.message == VIRTUS_MESSAGE)				if(msg.lParam == DieWindowEvent)					{					okay = TRUE;	// jca 26APR94 set the cancel state.					// return TRUE;  jca 29APR94.  We should process all the					// messages before we return from here.  If we don't, this can cause					// problems the next time we put up the meter.						}			result = IsDialogMessage(paneWindow, &msg);			if (!result)				{				TranslateMessage (&msg);				DispatchMessage (&msg);				} 			}		dontMoveDialog=FALSE;#endif //WINDOWS			return(okay); // jca 29APR94 return the current state of the meter.	}void V_Meter::SetText1(char *line)	{ 	Rect r = { 0 , 0 , 0, 0 };			if(!message)		{		message = new(V_Text);		message->cItem();		message->SetRect(&r);		AddItem(message);		}//JAM added 27Jun94 to force meter to update when text is set/changed [[[//	message->SetText(line);  //this was the only line here before the change	message->GetRect(&r);	SetPane();	r.bottom+=5;	VEraseRect(&r);	message->SetText(line);	message->Display();	UnsetPane();//JAM added 27Jun94 to force meter to update when text is set/changed ]]]	}	void V_Meter::SetText2(char *line) 	{ 	Rect r = { 0 , 0 , 0, 0 };	if(!message2)		{		message2 = new(V_Text);		message2->cItem();		message2->SetRect(&r);		AddItem(message2);		}	message2->GetRect(&r);	SetPane();	r.bottom+=5;	VEraseRect(&r);	message2->SetText(line);	message2->Display();	UnsetPane();	}void V_Meter::SetCountText(char *line) 	{ 	Rect r = { 0 , 0 , 0 , 0 };	if(!countText)		{		show_count = TRUE;		countText = new(V_Text);		countText->cItem();		countText->SetRect(&r);		AddItem(countText);		}	countText->SetText(line); 	}void V_Meter::SetTitle(char *line) 	{ 	strcpy(title,line); 	if(theWindow)		theWindow->SetTitle(line);	}void V_Meter::SetTotal(long newTotal) 	{ 	short fillWidth = fillBox.right - fillBox.left;		total = newTotal;	if (total > 0)         // jca.  don't let there be a divide by zero		total_inv = fillWidth/(double)total; /* Minimize later computation. */	else		total_inv = fillWidth;	}	void V_Meter::SetCount(long newCount) { current_pos = newCount; }int  V_Meter::GetCount() { return(current_pos); }void V_Meter::ShowCount(int state) { show_count = state; }int MeterCreate()	{	if(vMeter)return(-1);	vMeter = new(V_Meter);	vMeter->cMeter(CANCEL_BUTTON);		// ABD MERGE21	return(0);	}void MeterStart()	{	int i;	V_Menu *vMenu;		if(vMeter)		{#if MACINTOSH		CleanMenus();		for(i=0;i<visibleMMgr->ALength();i++)			{			visibleMMgr->Get(i,&vMenu);			vMenu->Activate(0,FALSE);			}		DrawMenuBar();#endif //MACINTOSH		vMeter->StartMeter();		}	}// ABD MERGE-TEXTURE 9/14/93 [[[void V_Meter::GetText1(char *line)	{ 	if(message)		{		message->GetText(line); 		}	}int MeterStopCreate()	{	if(vMeter)return(-1);	vMeter = new(V_Meter);	vMeter->cMeter(STOP_BUTTON);		// ABD MERGE21	return(0);	}// ABD MERGE21 [[[int MeterNoButtonCreate()	{	if(vMeter)return(-1);	vMeter = new(V_Meter);	vMeter->cMeter(NO_BUTTON);		// ABD MERGE21	return(0);	}// ABD MERGE21 ]]]void MeterGetText(char *str) {  if(vMeter)vMeter->GetText1(str); }	// ABD 26 Mar 93// ABD MERGE-TEXTURE 9/14/93 ]]]void MeterStop()	{	if(vMeter == NULL) return;	if ((vMeter->creditText || vMeter->creditBitmap) && vMeter->stop)		{		Rect	size;		V_CtrlButton_Die	*buttonOK;		if (vMeter->countText)			{			vMeter->RemoveItem(vMeter->countText);			VEraseRect(&vMeter->countText->bounds);			vMeter->countText->dItem();			}		if (vMeter->message)			{			vMeter->message->SetText(finishedLoadingString);			vMeter->message->Display();			}		if (vMeter->message2)			{			vMeter->RemoveItem(vMeter->message2);			VEraseRect(&vMeter->message2->bounds);			vMeter->message2->dItem();			}		vMeter->stop->GetRect(&size);		vMeter->RemoveItem(vMeter->stop);		vMeter->stop->dItem();				buttonOK = new(V_CtrlButton_Die);		buttonOK->cItem();		buttonOK->SetRect(&size);		buttonOK->SetText(TXTC_OK);		buttonOK->SetFlag(TRUE);		vMeter->SetDefBtn(buttonOK);#if WINDOWS		buttonOK->SetCtrlNumber(IDOK);#endif		vMeter->AddItem(buttonOK);		vMeter->total = -1;		vMeter->Modal();		}	vMeter->Delete();	vMeter = NULL;	}	void MeterTitle(strPtr str) {  if(vMeter)vMeter->SetTitle(str); }void MeterSetText(strPtr str) {  if(vMeter)vMeter->SetText1(str); }void MeterSetCountTitle(strPtr str) { if(vMeter)vMeter->SetText2(str); }void MeterSetCountText(strPtr str) { if(vMeter)vMeter->SetCountText(str); }void MeterSetTotal(long newTotal) { if(vMeter)vMeter->SetTotal(newTotal); }void MeterSetCount(long newCount) { if(vMeter)vMeter->SetCount(newCount); }int  MeterGetCount() {  if(vMeter)return(vMeter->GetCount()); else return 0;}int  MeterUpdate(long num){	VCGrafPort savePort;	// PRO-15	VGrafDevice saveDevice;	// PRO-15	VGetPort(&savePort,&saveDevice);	// PRO-15#if VR	VWIMemory();#endif // VR	if(vMeter)	{	int val = vMeter->Update(num);	// PRO-15	VSetPort(savePort,saveDevice);	// PRO-15	return(val);	}	else	{ 	VSetPort(savePort,saveDevice);	// PRO-15		return 0;	}}// DAS-VWI 10/2/93void MeterSetCreditInfo(V_Offscreen *bitmap, V_Array *text)	{	Rect		sr, dr, r;	V_Window	*theWin = vMeter->theWindow;	VStyleRec	theStyle;	char		*string;	int			lines = 0;	long		currentPosition;		if (vMeter == NULL)		return;	vMeter->creditBitmap = bitmap;		theWin->Hide();	theWin->UnInstall(vMeter);		GetScreen(&sr);	dr.left = 0;	dr.right = METER_WIDTH;	dr.top = 0;	dr.bottom = METER_SPACE*2 + METER_TEXTHEIGHT*2;	if (bitmap)		{		int	delta;				delta = bitmap->rect.bottom - bitmap->rect.top;		dr.bottom += delta + METER_SPACE;		delta = bitmap->rect.right - bitmap->rect.left + (METER_SPACE*2);		if (delta > dr.right)			dr.right = delta;		}	if (text)		{	#if WINDOWS		HDC	hdc, saveDevice = currentDevice;	#endif //WINDOWS		int length,width;				string = (char*)text->Use();		length = text->ALength();	#if WINDOWS		hdc = GetDC(NULL);		currentDevice = hdc;	#endif //WINDOWS		VSetFont(vAppFont,10,vNormal);		width = VTextWidth(string,0,length);	#if WINDOWS		ReleaseDC(NULL,hdc);		currentDevice = saveDevice;	#endif //WINDOWS				lines = (width/(dr.right - dr.left - (D_EDGE*2) -10)) +1;		dr.bottom += (lines*14 + D_EDGE);		}	else		string = NULL;	vMeter->creditText = new(V_Text);	vMeter->creditText->cItem();	theStyle.just = vJustLeft;	theStyle.size = 10;	theStyle.font = vAppFont;	theStyle.face = vDefTextFace;	theStyle.textFlags = TEXT_AUTOFORMAT|TEXT_ERASE;	vMeter->creditText->SetStyle(&theStyle);	if (string)		vMeter->creditText->SetText(string);	if (text)		text->Unuse();	r.left = dr.left + METER_SPACE;	r.right = dr.right - METER_SPACE;	if (bitmap)		{		r.top = D_EDGE*2;		r.top += (bitmap->rect.bottom - bitmap->rect.top);		}	else		r.top = D_EDGE;	r.bottom = r.top + (lines*14);	vMeter->creditText->SetRect(&r);	vMeter->AddItem(vMeter->creditText);	dr.left = ((sr.right-sr.left) - dr.right)/2;	dr.right += dr.left;	dr.top = ((sr.bottom-sr.top) - dr.bottom)/2;	dr.bottom += dr.top;	// ABD JAN95 CREDITS	{	Rect screenRect;		GetScreen(&screenRect);		if (dr.left < screenRect.left+20)			dr.left = screenRect.left+20;		if (dr.top < screenRect.top+40)			dr.top = screenRect.top+40;		if (dr.bottom > screenRect.bottom-20)			dr.bottom = screenRect.bottom-20;		if (dr.right > screenRect.right-20)			dr.right = screenRect.right-20;	}	// ABD JAN95 CREDITS	theWin->Move(&dr);		dr.right = dr.right - dr.left;	dr.bottom = dr.bottom - dr.top;	dr.top = 0;	dr.left = 0;	if (dr.right < theWin->mnSize.h) dr.right = theWin->mnSize.h;	if (dr.bottom < theWin->mnSize.v) dr.bottom = theWin->mnSize.v;	vMeter->dataRect = dr;	vMeter->fillBox.left = dr.left + METER_SPACE;	vMeter->fillBox.top = dr.bottom - METER_FILLHEIGHT - METER_SPACE;	vMeter->fillBox.bottom = dr.bottom - METER_SPACE;	if (vMeter->stop)		{		r.top = dr.bottom - METER_BUTTONHEIGHT - METER_SPACE;		r.bottom = dr.bottom - METER_SPACE;		r.left = dr.right - METER_BUTTONWIDTH - METER_SPACE;		r.right = dr.right - METER_SPACE;		vMeter->stop->SetRect(&r);		vMeter->fillBox.right = r.left - METER_SPACE;		}	else		vMeter->fillBox.right = dr.right - METER_SPACE;	vMeter->SetTotal(vMeter->total);	r.top = dr.bottom - METER_FILLHEIGHT - METER_SPACE - METER_TEXTHEIGHT - 3;	r.bottom = dr.bottom - METER_FILLHEIGHT - METER_SPACE - 3;	r.left = vMeter->fillBox.left;	r.right = vMeter->fillBox.right;// BILBIL - this needs to be fixed!! not all in the same place	if (vMeter->countText) vMeter->countText->SetRect(&r);	if (vMeter->message) vMeter->message->SetRect(&r);	if (vMeter->message2) vMeter->message2->SetRect(&r);	theWin->Show();	theWin->Install(vMeter);	vMeter->SetPane();	vMeter->Display(DRAW, 0, 0);	vMeter->UnsetPane();	// BILBIL - force the meter to update using the new fillBox size	currentPosition = vMeter->current_pos;	vMeter->current_pos = -1;	vMeter->Update(currentPosition);	}// MERGE-GOURAUD-PRO-10 [[[#if MACINTOSHint V_Dialog::GetType(){	return V_PANE_DIALOG;}#endif// MERGE-GOURAUD-PRO-10 ]]]