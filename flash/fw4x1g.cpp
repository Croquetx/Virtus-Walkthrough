/*------------------------------------------------------------------------------ * VWINDOWSt - the window object toolbox * * Copyright c 1991 by Virtus Corporation * All Rights Reserved * Written by David A. Smith * Virtus Corporation * 117 Edinburgh So * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * F4x1.c *------------------------------------------------------------------------------ *//* * Caution: this is two separate programs. * When you edit one, copy the whole file to the other (fw4x1.cpp, fw4x1g.cpp) * and flip these defines so the opposites are 0 and 1 * this nonsense is because borland runs out of compile table space and * tasm runs out of 'memory'*/#define FLATSHADE 0  //fw4x1 is 1 here; fw4x1g is 0 here#define SMOOTHSHADE (!FLATSHADE)#include "VTypes.h"#include "VGUtil.h"#include "VDisplay.h"#include "Clip.h"#include "Flash.h"#include "Gouraud.h"		// JAM MERGE-GOURAUD-PRO#define MK_FP(a,b)  ((void far *)(((unsigned long)(a) << 16) | (b)))#if FLASHUSEASM						// Borland:	Must have Project LocalOption compile switch "-B" on.						// Borland: must do a DOS "TASM <filename.asm>" to get obj.#if BORLANDC>=0x452		// earlier borlands hate inline...#pragma inline    // Borlandc 4.0 likes this.  your milage may vary.#endif#endif/*------------------------------------------------------------------------------ * Define the function names *------------------------------------------------------------------------------ */#define FLine     FLine4x1#define FLineClip FLineClip4x1#define FlashFill FlashFill4x1#define FlashClip FlashClip4x1#define FFixedFLine FFixedFLine4x1#define FlashGouraud 		FlashGouraud4x1			// MERGE-GOURAUD#define FlashGouraudClip 	FlashGouraudClip4x1		// MERGE-GOURAUD/*------------------------------------------------------------------------------ * Define the two major data types. *------------------------------------------------------------------------------ */typedef unsigned long VColorType[5][2];typedef unsigned char GColorType;		// MERGE-GOURAUDtypedef struct 	PixType{LPLONG pixel;						int pos;                        int y;						LPLONG rowBase;						int offset;	// offset to next plane                        BYTE lineDither; // dither count for lines						} PixType;/*------------------------------------------------------------------------------ * AutoInit your static data areas here. *------------------------------------------------------------------------------ */// PIXPOS calcs the real position within a long// PIXBIT selects a scan-line ordered bit, input is 0..31// (x)^7 to invert bit order (little endian bit) within a byte#define PIXPOS(x) ((x)^0x7)#define PIXBIT(x) (1L<<PIXPOS(x))static BYTE pixpos[] =						{PIXPOS(0) ,PIXPOS(1) ,PIXPOS(2) ,PIXPOS(3) ,						 PIXPOS(4) ,PIXPOS(5) ,PIXPOS(6) ,PIXPOS(7) ,						 PIXPOS(8) ,PIXPOS(9) ,PIXPOS(10),PIXPOS(11),						 PIXPOS(12),PIXPOS(13),PIXPOS(14),PIXPOS(15),						 PIXPOS(16),PIXPOS(17),PIXPOS(18),PIXPOS(19),						 PIXPOS(20),PIXPOS(21),PIXPOS(22),PIXPOS(23),						 PIXPOS(24),PIXPOS(25),PIXPOS(26),PIXPOS(27),						 PIXPOS(28),PIXPOS(29),PIXPOS(30),PIXPOS(31)};static LONG pixbit[] =						{PIXBIT(0) ,PIXBIT(1) ,PIXBIT(2) ,PIXBIT(3) ,						 PIXBIT(4) ,PIXBIT(5) ,PIXBIT(6) ,PIXBIT(7) ,						 PIXBIT(8) ,PIXBIT(9) ,PIXBIT(10),PIXBIT(11),						 PIXBIT(12),PIXBIT(13),PIXBIT(14),PIXBIT(15),						 PIXBIT(16),PIXBIT(17),PIXBIT(18),PIXBIT(19),						 PIXBIT(20),PIXBIT(21),PIXBIT(22),PIXBIT(23),						 PIXBIT(24),PIXBIT(25),PIXBIT(26),PIXBIT(27),						 PIXBIT(28),PIXBIT(29),PIXBIT(30),PIXBIT(31)};static BYTE charadj[] =						{0,0,0,0,0,0,0,0,						 1,1,1,1,1,1,1,1,						 2,2,2,2,2,2,2,2,						 3,3,3,3,3,3,3,3};#define PIXPOS2(x) (((x)^0x7) - (charadj[x] << 3))#define PIXBIT2(x) (1L<<(PIXPOS(x) - (charadj[x] << 3)))static BYTE pixpos2[] =						{PIXPOS2(0) ,PIXPOS2(1) ,PIXPOS2(2) ,PIXPOS2(3) ,						 PIXPOS2(4) ,PIXPOS2(5) ,PIXPOS2(6) ,PIXPOS2(7) ,						 PIXPOS2(8) ,PIXPOS2(9) ,PIXPOS2(10),PIXPOS2(11),						 PIXPOS2(12),PIXPOS2(13),PIXPOS2(14),PIXPOS2(15),						 PIXPOS2(16),PIXPOS2(17),PIXPOS2(18),PIXPOS2(19),						 PIXPOS2(20),PIXPOS2(21),PIXPOS2(22),PIXPOS2(23),						 PIXPOS2(24),PIXPOS2(25),PIXPOS2(26),PIXPOS2(27),						 PIXPOS2(28),PIXPOS2(29),PIXPOS2(30),PIXPOS2(31)};static WORD pixbit2[] =						{PIXBIT2(0) ,PIXBIT2(1) ,PIXBIT2(2) ,PIXBIT2(3) ,						 PIXBIT2(4) ,PIXBIT2(5) ,PIXBIT2(6) ,PIXBIT2(7) ,						 PIXBIT2(8) ,PIXBIT2(9) ,PIXBIT2(10),PIXBIT2(11),						 PIXBIT2(12),PIXBIT2(13),PIXBIT2(14),PIXBIT2(15),						 PIXBIT2(16),PIXBIT2(17),PIXBIT2(18),PIXBIT2(19),						 PIXBIT2(20),PIXBIT2(21),PIXBIT2(22),PIXBIT2(23),						 PIXBIT2(24),PIXBIT2(25),PIXBIT2(26),PIXBIT2(27),						 PIXBIT2(28),PIXBIT2(29),PIXBIT2(30),PIXBIT2(31)};// Setting bit masks, LMASK keeps logical (wrto scan) left bits.//		RMASK keeps logical (wrto scan) right bits.//		Input is scanline 32bit position, 0..31;//		Output is either left keep or right keep bit mask.//			Includes the bit position itself (using PIXBIT)//		??Improvement?? pad ends of arrays with zeros to use even if bitpos is 0.//						This would avoid tests and branches for span ends.// For intel (little endian), this means progress 1's from lo byte to hi//     intel also wants hi bit to low within a byte//// LMASKIa sets all bits, then clears higher (scan right) bytes// LMASKIb takes LMASKIa, clears (scan right) lobits within target byte#define LMASKIa(x) ( 0xFFFFFFFF +  (1L<<((x)+8&~7)) )#define LMASKIb(x) ( (LMASKIa(x)^PIXBIT(x)) + (1L<<((x)&~7)) )#define LMASK(x) (LMASKIb((x))) // turn off following himem MSB bits#define RMASK(x) (~LMASK((x))) // opposite of RMASK, kill prior lomem LSB bits// (-1+(1L<<(x)))  // 0..x-1 still on, x..31 turned off// ((-1^(1L<<(x)))+1)  // turn off bits 0..x-1, x..31 still onstatic unsigned long lMask[]=						{0 ,						 LMASK(0) ,LMASK(1) ,LMASK(2) ,LMASK(3) ,						 LMASK(4) ,LMASK(5) ,LMASK(6) ,LMASK(7) ,						 LMASK(8) ,LMASK(9) ,LMASK(10),LMASK(11),						 LMASK(12),LMASK(13),LMASK(14),LMASK(15),						 LMASK(16),LMASK(17),LMASK(18),LMASK(19),						 LMASK(20),LMASK(21),LMASK(22),LMASK(23),						 LMASK(24),LMASK(25),LMASK(26),LMASK(27),						 LMASK(28),LMASK(29),LMASK(30),LMASK(31)};static unsigned long rMask[]=						{0 ,						 RMASK(0) ,RMASK(1) ,RMASK(2) ,RMASK(3) ,						 RMASK(4) ,RMASK(5) ,RMASK(6) ,RMASK(7) ,						 RMASK(8) ,RMASK(9) ,RMASK(10),RMASK(11),						 RMASK(12),RMASK(13),RMASK(14),RMASK(15),						 RMASK(16),RMASK(17),RMASK(18),RMASK(19),						 RMASK(20),RMASK(21),RMASK(22),RMASK(23),						 RMASK(24),RMASK(25),RMASK(26),RMASK(27),						 RMASK(28),RMASK(29),RMASK(30),RMASK(31)};/*------------------------------------------------------------------------------ * Define the macro pixel routines. * For additional information about this code, see the Flash.c sources. *------------------------------------------------------------------------------ */#define Pal4(color)  (((color)&0x8000?0x88888888:0)\					| ((color)&0x0800?0x44444444:0)\				   	| ((color)&0x0080?0x22222222:0)\					| ((color)&0x0008?0x11111111:0))// rightmost bit per color is in first plane (lsb order)#define InitColorPen(color,rgb) {unsigned long lcol0, lcol1;  \			  lcol0 = lcol1 = offscreen->GetDither(rgb); \              lcol0 &= 0x0F0F0000; lcol0 |= lcol0<<4; lcol0 |= lcol0>>16; \			  color[4][0] = lcol0; \			  lcol1 &= 0xF0F00000; lcol1 |= lcol1>>4; lcol1 |= lcol1>>16; \              color[4][1] = lcol1;  \			  color[3][0]= Pal4(lcol0); color[2][0]=Pal4(lcol0<<1); \			  color[1][0]= Pal4(lcol0<<2);color[0][0]=Pal4(lcol0<<3);  \			  color[3][1]= Pal4(lcol1); color[2][1]=Pal4(lcol1<<1); \			  color[1][1]= Pal4(lcol1<<2);color[0][1]=Pal4(lcol1<<3);  \			  }#define InitColorBrush(color,rgb) {unsigned long lcol0, lcol1;  \			  lcol0 = lcol1 = dither?offscreen->GetDither(rgb):offscreen->GetNoDither(rgb);  \			  lcol0 &= 0xFFFF0000; lcol0 |= lcol0>>16; \			  color[4][0] = lcol0; \			  lcol1 &= 0x0000FFFF; lcol1 |= lcol1<<16; \			  color[4][1] = lcol1;  \			  color[3][0]= Pal4(lcol0); color[2][0]=Pal4(lcol0<<1); \			  color[1][0]= Pal4(lcol0<<2);color[0][0]=Pal4(lcol0<<3);  \			  color[3][1]= Pal4(lcol1); color[2][1]=Pal4(lcol1<<1); \			  color[1][1]= Pal4(lcol1<<2);color[0][1]=Pal4(lcol1<<3);  \			  }// MERGE-GOURAUD [[[// this macro inits the color index based on the rgb -- index will range from 0..255// at most, and will be less for bit depths 1/2/4.  The index is an index into the standard color// table; index is an unsigned char, rgb is an RGBColor#define InitColorIndex(index,rgb) { index = rgb; }// MERGE-GOURAUD ]]]#define InitPixel(pix,xval,yval,to) {  \	pix.y = yval+to->yOffset; \    pix.rowBase = (LPLONG)glpbBmRowAddresses[pix.y];  \	pix.pixel= (LPLONG)((pix.rowBase)+ ((xval+to->xOffset)>>5) );  \	pix.offset = gwBmWidthBytes; \	pix.pos=((xval+to->xOffset)&0x1f);  \	pix.lineDither = 0;  \	}#if USE_HMD#pragma option -Od#define InitPixelHMDL(pix,xval,yval,to) {  \	pix.y = yval<<1;   \	pix.y += to->yOffset; \	if(gHMDOffsetLeft) pix.y += 1; \	pix.rowBase = (LPLONG)glpbBmRowAddresses[pix.y];  \	pix.pixel= (LPLONG)((pix.rowBase)+ ((xval+to->xOffset)>>5) );  \	pix.offset = gwBmWidthBytes; \	pix.pos=((xval+to->xOffset)&0x1f);  \	pix.lineDither = 0;  \	}#define InitPixelHMDR(pix,xval,yval,to) {  \	pix.y = yval<<1;   \	pix.y += to->yOffset; \	if(gHMDOffsetRight) pix.y += 1; \	pix.rowBase = (LPLONG)glpbBmRowAddresses[pix.y];  \	pix.pixel= (LPLONG)((pix.rowBase)+ ((xval+to->xOffset)>>5) );  \	pix.offset = gwBmWidthBytes; \	pix.pos=((xval+to->xOffset)&0x1f);  \	pix.lineDither = 0;  \	}#define AddLinePixelHMD(pix,to) { int xOffset; \	xOffset = (LPBYTE)pix.pixel - (LPBYTE)pix.rowBase;  \	pix.y+=2; \	pix.rowBase = (LPLONG)glpbBmRowAddresses[pix.y];  \	pix.pixel= (LPLONG)((LPBYTE)(pix.rowBase)+ (xOffset) );  \	}#endif // USE_HMD#define DecPixel(pix)  {if(!pix.pos)pix.pixel--; pix.pos=(pix.pos-1)&0x1f;}#define IncPixel(pix)  {pix.pos+=1; pix.pos&=0x1f;if(!pix.pos)pix.pixel++; }#define AddPixel(pix,length) {pix.pos+=length;pix.pixel+=pix.pos>>5;	\								pix.pos&=0x1f;}#define AddLinePixel(pix,to) { int xOffset; \	xOffset = (LPBYTE)pix.pixel - (LPBYTE)pix.rowBase;  \	pix.y++; \	pix.rowBase = (LPLONG)glpbBmRowAddresses[pix.y];  \	pix.pixel= (LPLONG)((LPBYTE)(pix.rowBase)+ (xOffset) );  \	}#define SetPixel(pix,color) {LPLONG lpl=pix.pixel;						\	*lpl=(*lpl&~pixbit[pix.pos])|(color[0][pix.lineDither]&pixbit[pix.pos]); \	(LPBYTE)lpl+=pix.offset; \	*lpl=(*lpl&~pixbit[pix.pos])|(color[1][pix.lineDither]&pixbit[pix.pos]); \	(LPBYTE)lpl+=pix.offset; \	*lpl=(*lpl&~pixbit[pix.pos])|(color[2][pix.lineDither]&pixbit[pix.pos]); \	(LPBYTE)lpl+=pix.offset; \	*lpl=(*lpl&~pixbit[pix.pos])|(color[3][pix.lineDither]&pixbit[pix.pos]); \	pix.lineDither ^= 0x01; \	}#define DecSetPixel(pix,color) do{SetPixel(pix,color);DecPixel(pix);}while(0)#define IncSetPixel(pix,color) do{SetPixel(pix,color);IncPixel(pix);}while(0)// MERGE-GOURAUD [[[// ok, please bear with us.// we need to take the rightjustified 4bit color value, and place it// near the masking bit for pix.pos. The masking bit for pix.pos says where// the color pixel is to be placed across the 4 bit planes, 1 bit per plane.// For positions near the right edge of the long, we align on the least bit and// shift right to get other three bits into right bitplanar position.// For positions near the left edge of the long, we align on the max bit, and// left shift to get the other bits into position.// This code presumes the least (rightmost) colorbit goes to the first plane.#define LPWORD UShortPtr#define SetPixel2(pix,color) \ {	unsigned short copiedcolor; \	LPWORD lps; \	copiedcolor = color; \	copiedcolor <<= pixpos2[pix.pos]; \	(LPBYTE)lps = (LPBYTE)pix.pixel + charadj[pix.pos]; \	*lps=(*lps&~pixbit2[pix.pos])|((copiedcolor)&pixbit2[pix.pos]); \	(LPBYTE)lps+=pix.offset; \	*lps=(*lps&~pixbit2[pix.pos])|((copiedcolor>>1)&pixbit2[pix.pos]); \	(LPBYTE)lps+=pix.offset; \	*lps=(*lps&~pixbit2[pix.pos])|((copiedcolor>>2)&pixbit2[pix.pos]); \	(LPBYTE)lps+=pix.offset; \	*lps=(*lps&~pixbit2[pix.pos])|((copiedcolor>>3)&pixbit2[pix.pos]); \	}#define IncSetPixel2(pix,color) do{SetPixel2(pix,color);IncPixel(pix);}while(0)#define PixVal(pix) (pix.pos)#define GetGouraudDither(dith_abcd, shade, color)	(gTextureShader[shade].dith[2][dith_abcd][color])// MERGE-GOURAUD ]]]#if FLATSHADE/*------------------------------------------------------------------------------ * ScanFillPatternXxx(). *------------------------------------------------------------------------------ */#define ScanFillPattern ScanFillPattern4x1void ScanFillPattern4x1(PixType pixel,int evenodd,int dx,VColorType color);								void ScanFillPattern4x1(PixType pixel,int evenodd,int dx,VColorType color) {int ml,mr;LPLONG pl,pr, plbase;long col=color[0][evenodd&1];unsigned long mask=0xAAAAAAAA;if (evenodd&1) mask = ~mask; // complement to select opposite pixelsplbase=pixel.pixel;pl=plbase;ml=(pixel.pos);  //  offset for leftmost pixelpixel.pos  += dx;pixel.pixel+=(pixel.pos>>5);pixel.pos  &=0x1f;pr=pixel.pixel;mr=(pixel.pos);  //  offset for one past rightmost pixel// Coding note:// ((old ^ new) &KeepOldBits) ^ new// uses (a^b^b==a) property to keep old wherever KeepOldBits is set.// old bits are replaced by new bits only where KeepOldBits is clear/off.if(pl==pr)/*same 32 bits*/	{	if(ml)		{		if(mr)*pl =(((*pl^col)&(lMask[ml]|rMask[mr]|mask))^col);		else *pl  =(((*pl^col)&(lMask[ml]             |mask))^col);		}	else if(mr)*pl=(((*pl^col)&(             rMask[mr]|mask))^col);	}else 	{	if(ml)*pl++=(((*pl^col)&(lMask[ml]             |mask))^col);	while(pl!=pr)		  *pl++=(((*pl^col)&(                          mask))^col);	if(mr)*pl  =(((*pl^col)&(             rMask[mr]|mask))^col);	}(LPBYTE)plbase+=pixel.offset;pl=plbase;    // only pl incs. plbase and pr stay unchanged in loop.(LPBYTE)pr+=pixel.offset;col=color[1][evenodd&1];if(pl==pr)/*same 32 bits*/	{	if(ml)		{		if(mr)*pl =(((*pl^col)&(lMask[ml]|rMask[mr]|mask))^col);		else *pl  =(((*pl^col)&(lMask[ml]             |mask))^col);		}	else if(mr)*pl=(((*pl^col)&(             rMask[mr]|mask))^col);	}else 	{	if(ml)*pl++=(((*pl^col)&(lMask[ml]             |mask))^col);	while(pl!=pr)		  *pl++=(((*pl^col)&(                          mask))^col);	if(mr)*pl  =(((*pl^col)&(             rMask[mr]|mask))^col);	}(LPBYTE)plbase+=pixel.offset;pl=plbase;    // only pl incs. plbase and pr stay unchanged in loop.(LPBYTE)pr+=pixel.offset;col=color[2][evenodd&1];if(pl==pr)/*same 32 bits*/	{	if(ml)		{		if(mr)*pl =(((*pl^col)&(lMask[ml]|rMask[mr]|mask))^col);		else *pl  =(((*pl^col)&(lMask[ml]             |mask))^col);		}	else if(mr)*pl=(((*pl^col)&(             rMask[mr]|mask))^col);	}else 	{	if(ml)*pl++=(((*pl^col)&(lMask[ml]             |mask))^col);	while(pl!=pr)		  *pl++=(((*pl^col)&(                          mask))^col);	if(mr)*pl  =(((*pl^col)&(             rMask[mr]|mask))^col);	}(LPBYTE)plbase+=pixel.offset;pl=plbase;  // only pl incs. plbase and pr stay unchanged in loop.(LPBYTE)pr+=pixel.offset;col=color[3][evenodd&1];if(pl==pr)/*same 32 bits*/	{	if(ml)		{		if(mr)*pl =(((*pl^col)&(lMask[ml]|rMask[mr]|mask))^col);		else *pl  =(((*pl^col)&(lMask[ml]             |mask))^col);		}	else if(mr)*pl=(((*pl^col)&(             rMask[mr]|mask))^col);	}else 	{	if(ml)*pl++=(((*pl^col)&(lMask[ml]             |mask))^col);	while(pl!=pr)		  *pl++=(((*pl^col)&(                          mask))^col);	if(mr)*pl  =(((*pl^col)&(             rMask[mr]|mask))^col);	}}														/*------------------------------------------------------------------------------ * ScanFillxxx. *------------------------------------------------------------------------------ */#define ScanFill ScanFill4x1void ScanFill4x1(PixType pixel,int evenodd,int dx,VColorType color);										void ScanFill4x1(PixType pixel,int evenodd,int dx,VColorType color)											{int ml,mr;				LPLONG pl,pr, plbase;long col=color[0][evenodd&1];long lNumLongs;long lNumLongsSave;plbase=pixel.pixel;pl=plbase;ml=((long)pixel.pos);pixel.pos  += dx;lNumLongs   = pixel.pos>>5;pixel.pixel+= lNumLongs;pixel.pos  &= 0x1f;pr=pixel.pixel;mr=((long)pixel.pos);lNumLongsSave = lNumLongs;		// Save for repeated useif(pl==pr)/*same 32 bits*/	{	if(ml)		{		if(mr)*pl =(((*pl^col)&(lMask[ml]|rMask[mr]))^col);		else *pl  =(((*pl^col)&(lMask[ml]             ))^col);		}	else if(mr)*pl=(((*pl^col)&(             rMask[mr]))^col);	}else 	{	if(ml)		{		*pl++=(((*pl^col)&(lMask[ml]             ))^col);		lNumLongs -= 1;  // account for doing one already		}#if FLASHUSEASM	if (FlashUseAsm)		{		WORD plSegment;        LONG plOffset;		plSegment = SELECTOROF(pl);		plOffset = OFFSETOF(pl);		ASM { 						// Borland:	Must have Project LocalOption compile switch "-B" on.						// Borland: must do a DOS "TASM <filename.asm>" to get obj.			pushfd				/* MS wants DF saved *///			push eax			push ecx			push edi		    /* yuch */        	mov eax, col			mov ecx, lNumLongs	/* num of 32bits to move */			mov es,plSegment            mov edi,plOffset			cld					/* set direction to forwards */			rep  stosd			/* store doubles(32 bits) at a time */            mov pl,di		/* update the lower offset */			pop edi			pop ecx//			pop eax            popfd			}		}	else#endif		{		while(pl!=pr)*pl++=col;		}	if(mr)*pl  =(((*pl^col)&(             rMask[mr]))^col);	}(LPBYTE)plbase+=pixel.offset;pl=plbase;    // only pl incs. plbase and pr stay unchanged in loop.(LPBYTE)pr+=pixel.offset;col=color[1][evenodd&1];lNumLongs = lNumLongsSave;if(pl==pr)/*same 32 bits*/	{	if(ml)		{		if(mr)*pl =(((*pl^col)&(lMask[ml]|rMask[mr]))^col);		else *pl  =(((*pl^col)&(lMask[ml]             ))^col);		}	else if(mr)*pl=(((*pl^col)&(             rMask[mr]))^col);	}else 	{	if(ml)		{		*pl++=(((*pl^col)&(lMask[ml]             ))^col);		lNumLongs -= 1;  // account for doing one already		}#if FLASHUSEASM	if (FlashUseAsm)		{		WORD plSegment;        LONG plOffset;		plSegment = SELECTOROF(pl);		plOffset = OFFSETOF(pl);		ASM { 						// Borland:	Must have Project LocalOption compile switch "-B" on.						// Borland: must do a DOS "TASM <filename.asm>" to get obj.			pushfd				/* MS wants DF saved *///			push eax			push ecx			push edi		    /* yuch */        	mov eax, col			mov ecx, lNumLongs	/* num of 32bits to move */			mov es,plSegment            mov edi,plOffset			cld					/* set direction to forwards */			rep  stosd			/* store doubles(32 bits) at a time */            mov pl,di		/* update the lower offset */			pop edi			pop ecx//			pop eax            popfd			}		}	else#endif		{		while(pl!=pr)*pl++=col;		}	if(mr)*pl  =(((*pl^col)&(             rMask[mr]))^col);	}(LPBYTE)plbase+=pixel.offset;pl=plbase;    // only pl incs. plbase and pr stay unchanged in loop.(LPBYTE)pr+=pixel.offset;col=color[2][evenodd&1];lNumLongs = lNumLongsSave;if(pl==pr)/*same 32 bits*/	{	if(ml)		{		if(mr)*pl =(((*pl^col)&(lMask[ml]|rMask[mr]))^col);		else *pl  =(((*pl^col)&(lMask[ml]             ))^col);		}	else if(mr)*pl=(((*pl^col)&(             rMask[mr]))^col);	}else 	{	if(ml)		{		*pl++=(((*pl^col)&(lMask[ml]             ))^col);		lNumLongs -= 1;  // account for doing one already		}#if FLASHUSEASM	if (FlashUseAsm)		{		WORD plSegment;        LONG plOffset;		plSegment = SELECTOROF(pl);		plOffset = OFFSETOF(pl);		ASM { 						// Borland:	Must have Project LocalOption compile switch "-B" on.						// Borland: must do a DOS "TASM <filename.asm>" to get obj.			pushfd				/* MS wants DF saved *///			push eax			push ecx			push edi		    /* yuch */        	mov eax, col			mov ecx, lNumLongs	/* num of 32bits to move */			mov es,plSegment            mov edi,plOffset			cld					/* set direction to forwards */			rep  stosd			/* store doubles(32 bits) at a time */            mov pl,di		/* update the lower offset */			pop edi			pop ecx//			pop eax            popfd			}		}	else#endif		{		while(pl!=pr)*pl++=col;		}	if(mr)*pl  =(((*pl^col)&(             rMask[mr]))^col);	}(LPBYTE)plbase+=pixel.offset;pl=plbase;  // only pl incs. plbase and pr stay unchanged in loop.(LPBYTE)pr+=pixel.offset;col=color[3][evenodd&1];lNumLongs = lNumLongsSave;if(pl==pr)/*same 32 bits*/	{	if(ml)		{		if(mr)*pl =(((*pl^col)&(lMask[ml]|rMask[mr]))^col);		else *pl  =(((*pl^col)&(lMask[ml]             ))^col);		}	else if(mr)*pl=(((*pl^col)&(             rMask[mr]))^col);	}else 	{	if(ml)		{		*pl++=(((*pl^col)&(lMask[ml]             ))^col);		lNumLongs -= 1;  // account for doing one already		}#if FLASHUSEASM	if (FlashUseAsm)		{		WORD plSegment;        LONG plOffset;		plSegment = SELECTOROF(pl);		plOffset = OFFSETOF(pl);		ASM { 						// Borland:	Must have Project LocalOption compile switch "-B" on.						// Borland: must do a DOS "TASM <filename.asm>" to get obj.			pushfd				/* MS wants DF saved *///			push eax			push ecx			push edi		    /* yuch */        	mov eax, col			mov ecx, lNumLongs	/* num of 32bits to move */			mov es,plSegment            mov edi,plOffset			cld					/* set direction to forwards */			rep  stosd			/* store doubles(32 bits) at a time */            mov pl,di		/* update the lower offset */			pop edi			pop ecx//			pop eax            popfd			}		}	else#endif		{		while(pl!=pr)*pl++=col;		}	if(mr)*pl  =(((*pl^col)&(             rMask[mr]))^col);	}}#endif //FLATSHADE// MERGE-GOURAUD [[[/*------------------------------------------------------------------------------ * GouraudFillxxxx *------------------------------------------------------------------------------ */// GOURAUD -- we have to pattern fill dx pixels, going from intensity il to intensity ir#define DefaultGouraudFillPattern DefaultGouraudFillPattern4x1#define DefaultGouraudFill DefaultGouraudFill4x1#define GouraudFillPattern DefaultGouraudFillPattern4x1#define GouraudFill DefaultGouraudFill4x1// MERGE-GOURAUD ]]]#include "FlashZ.h"