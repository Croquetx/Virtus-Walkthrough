/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1993 by Virtus Corporation * All Rights Reserved * Written by  	Gregory J Rivera *				 *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File: * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#if MACINTOSH#include "VArray.h"#include "VDisplay.h"BOOLV_Offscreen::GetGdiBitmapInfo(void){#if THIS_WERE_WORKING_BETTER// jca 24 aug 93.  Lots of weirdnesses about bitdepths > 8.// perhaps someday this can be fixed for the mac.	int iRow, bHeight, shifter;	unsigned char *base;	BOOL err = 0;	long maxSize;	// Create the array, make it the right size	bHeight = rect.bottom - rect.top;	if (!vaBmRowAddresses)		{ // create it fresh		vaBmRowAddresses = new(V_Array);		vaBmRowAddresses->cArray(bHeight,sizeof(LPBYTE),1);		}	lpbBmRowAddresses = (LPBYTE *)vaBmRowAddresses->Abuse();	// for 16 and 32-bit depths, we use short and long pointers (respectively)	// to access the pixels.  Thus, the offsets need to be in terms of the	// pointer increments (short or long), rather than bytes.	switch(bitDepth)		{		case 32:	shifter = 2; break;		case 16:	shifter = 1; break;		default:	shifter = 0; break;		}	// calc the starting base address (a number of lines)	base = (unsigned char *)((GetRowWidth()>>shifter)*(GetYOffset())); 	// calc the max size of the bitmap, and don't exceed it!	maxSize = (long)(bHeight)*(GetRowWidth()>>shifter) + (long)base;		for (iRow=0; iRow<bHeight && !err; iRow++)		{		lpbBmRowAddresses[iRow] = base;		err = ((long)lpbBmRowAddresses[iRow] > maxSize);		base += (GetRowWidth()>>shifter);        }     return(err);#else return(0);#endif}#elif WINDOWS#include "ToolHelp.h"#include "GdiObj.h"#include "VArray.h"#include "VDisplay.h"#include "DOS.h"		// DOS segment handlers		GJR092093#define NEEDSHUGE(farptr, bytelen) (unsigned FP_OFF(farptr) > (-(signed)(bytelen)))typedef LOCALENTRY FAR * LPLOCALENTRY;BOOL ContainsLocalHeap(WORD seg);BOOLFindALocalEntry(HANDLE hBmp, HGLOBAL wLocalSegment, LPLOCALENTRY pLocalEntry);BOOLFindGdiLocalEntry(HANDLE hBmp, LPWORD pwLocalSegment, LPLOCALENTRY pLocalEntry);BOOLIsProperPixelAddress(VCGrafPort metaport, int iXColumn, int iYRow, WORD wSize, LPBYTE lpByte);BOOLIsProperPixelAddress(VCGrafPort metaport, int iXColumn, int iYRow, int iSize, LPBYTE lpByte){COLORREF	crBlack = RGB(0x00, 0x00, 0x00);	// black testing colorCOLORREF	crWhite = RGB(0xFF, 0xFF, 0xFF);	// white testing colorBYTE		bOldByte;							// old value at that addressBYTE		bNewByte;                           // hopefully different new valueBYTE huge*	hugepByte;                          // avoid segment hasslesint			i;BOOL		ok;	ok = FALSE;			// presume guilty until everything checks out	hugepByte = lpByte;		// avoid segment end problems	for (i=0; i<iSize; i++)		{		if (IsBadWritePtr(hugepByte, 1)) goto Error_Return; // thunder cards straddle segs		bOldByte = *hugepByte;		SetPixel(metaport, iXColumn, iYRow, crBlack);		if (bOldByte != *hugepByte) goto Changed_A_Byte;		SetPixel(metaport, iXColumn, iYRow, crWhite);		if (bOldByte != *hugepByte) goto Changed_A_Byte;		hugepByte++;	// check the next byte in pixel for changes		}    goto Error_Return;	// oops, couldn't find a byte the pixel changed. Not here.Changed_A_Byte:			// Yeah, changing colors changed a value at this loc. Found it.	ok = TRUE;          // Nothing else to test. return ok.	return (ok);Error_Return:	ok = FALSE;	return (ok);}//=============================================================================BOOLV_Offscreen::GetGdiBitmapInfo(HANDLE hDC, HANDLE hBmp){LOCALENTRY le;WORD seg;GLOBALENTRY ge;BOOL ok;LPGDIOBJHDR lpGoh;LPBITMAPOBJ lpBmo;HANDLE hPbm;LPGDIPBITMAP lpPbm;// Use a direct method to find out about our bitmap// GetObject is to return the width, height, and color info.// The info (like width) is useful for braindead drivers that need help.BITMAP	bm;WORD	wOk;	wOk = GetObject(hBmp, sizeof(bm), &bm);    ASSERT(wOk == sizeof(bm)); // if it don't match, check if values are ok, then change test. 	if (wOk != 0)	// loose ok test    	{		wBmWidth = bm.bmWidth;		wBmHeight = bm.bmHeight;		wBmWidthBytes = bm.bmWidthBytes;		wBmPlanes = bm.bmPlanes;		wBmBitsPixel = bm.bmBitsPixel;		}	else		{ // should never need this... just keep rest from crashing badly. Fake it small.		wBmWidth = rect.right;		wBmHeight = rect.bottom;		wBmWidthBytes = rect.right/8;		wBmPlanes = 1;		wBmBitsPixel = 1;        }	ok = FindGdiLocalEntry(hBmp, &seg, &le);	if (!ok) goto Error_Return;	lpGoh = (LPGDIOBJHDR) MK_FP(seg, le.wAddress);    if ((lpGoh->wMagic & 0x000f) != 0x000b) goto Error_Return;	lpBmo = (LPBITMAPOBJ)lpGoh;	if ( (LOWORD(GetVersion()) == 0x0a03)	  && (GetSystemMetrics(SM_DEBUG)) )		(char FAR *)lpBmo += sizeof(GDIOBJDBG) - sizeof(GDIOBJHDR);    hPbm = lpBmo->hmemBitmap;		lpPbm = (LPGDIPBITMAP) MK_FP(GlobalHandleToSel(hPbm), 0x0000);	if (lpPbm->bmType != 0) goto Error_Return;	wBmWidth = lpPbm->bmWidth;	wBmHeight = lpPbm->bmHeight;	wBmWidthBytes = lpPbm->bmWidthBytes;	lpbBmBits = lpPbm->bmBits;	wBmPlanes = lpPbm->bmPlanes;	wBmBitsPixel = lpPbm->bmBitsPixel;	wBmSegmentIndex = lpPbm->bmSegmentIndex;	wBmScanSegment = lpPbm->bmScanSegment;	wBmFillBytes = lpPbm->bmFillBytes;	ok = !IsBadReadPtr(lpbBmBits, 2);	if (!ok) goto Error_Return;	ok = !IsBadWritePtr(lpbBmBits, 2);	if (!ok) goto Error_Return;// Now lets define the row addresses	{	int iRow;	WORD seg,offset;    WORD oldseg, oldoffset;	int	iSize;		// size in bytes per pixel    int iRowSize;	// size for an entire row, in bytes    LPBYTE lpByte;	iSize    = (wBmBitsPixel + 7) >> 3;  // size horizontally in bytes per pixel	iRowSize = wBmWidthBytes*wBmPlanes;  // size in total bytes per row// Create the array, make it the right size	if (!vaBmRowAddresses)		{ // create it fresh		vaBmRowAddresses = new(V_Array);		vaBmRowAddresses->cArray(0,sizeof(LPBYTE),1);		}    vaBmRowAddresses->SetLength(wBmHeight);	lpbBmRowAddresses = (LPBYTE *)vaBmRowAddresses->Abuse();    // Start with first row. Init.    iRow      = 0;    // Calc address of starting row. Check for reasonableness.	seg    = FP_SEG(lpbBmBits);	offset = FP_OFF(lpbBmBits);	lpByte = (LPBYTE)MK_FP(seg,offset);	ok = !IsBadWritePtr(lpByte, iRowSize);	if (!ok) goto Error_Return;	ok = IsProperPixelAddress(metaPort, 0, iRow, iSize, lpByte);	if (!ok) goto Error_Return;    // Save our validated address pointer	lpbBmRowAddresses[iRow] = lpByte;    // Now, calc each new one, checking for segment hassles	for (; iRow<wBmHeight - 1; )		{		oldoffset = offset;		oldseg    = seg;		iRow++;		offset = oldoffset + iRowSize;        seg    = oldseg;		lpByte = (LPBYTE)MK_FP(seg,offset);		if ( (IsBadWritePtr(lpByte, iRowSize))		  || (!IsProperPixelAddress(metaPort, 0, iRow, iSize, lpByte)) )			{ // Then Something is wrong with the address            // Use methods that fit old windows drivers			offset = 0;			seg    = oldseg + wBmSegmentIndex;			lpByte = (LPBYTE)MK_FP(seg,offset);			if ( (IsBadWritePtr(lpByte, iRowSize))			  || (!IsProperPixelAddress(metaPort, 0, iRow, iSize, lpByte)) )			    {  // Then wrong guess for next segment location. Try again.			   	// Try a variation on windows drivers definitions.			    offset =  oldoffset + iRowSize + wBmFillBytes;			   	seg    = oldseg + wBmSegmentIndex;			   	lpByte = (LPBYTE)MK_FP(seg,offset);			   	if ( (IsBadWritePtr(lpByte, iRowSize))			      || (!IsProperPixelAddress(metaPort, 0, iRow, iSize, lpByte)) )			        {  // Then wrong guess for next segment location. Try again.					// Thunder boards and DIBs, maybe we skipped to the next segment					offset = oldoffset + iRowSize;					seg    = oldseg + wBmSegmentIndex;					lpByte = (LPBYTE)MK_FP(seg,offset);					if ( (IsBadWritePtr(lpByte, iRowSize))   // should completely fit into next segment					  || (!IsProperPixelAddress(metaPort, 0, iRow, iSize, lpByte)) )						{  // Then wrong guess for next segment location. Try again.						// Thunder boards and DIBS, maybe we ARE correct, just span two segs						offset = oldoffset + iRowSize;						seg    = oldseg;						lpByte = (LPBYTE)MK_FP(seg,offset);						if ( (IsBadWritePtr(lpByte, -(signed)(FP_OFF(offset)) ))     // should use all of current segment						  || (IsBadWritePtr(MK_FP(oldseg+wBmSegmentIndex, 0), iRowSize + (signed)FP_OFF(offset) )) // and some of next						  || (!IsProperPixelAddress(metaPort, 0, iRow, iSize, lpByte)) )							{  // Then wrong guess for next segment location. Try again.							goto Error_Return;  // NOPE, no more chances.                            }						}					}				}			}New_Seg_Ok:		lpbBmRowAddresses[iRow] = lpByte;		}	}   // End of define row address//	fBmOk = TRUE;	return (fBmOk);Error_Return:#if DEBUG	{	char szOutput[1024] = "X";		wsprintf((LPSTR)&szOutput,			(LPSTR)"%s%d\n %s%d\n %s%d\n %s%d\n %s%d\n %s%d\n %s%d\n %s%d\n ",			(LPSTR)"wBmWidth =", wBmWidth,			(LPSTR)"wBmHeight =", wBmHeight,			(LPSTR)"wBmWidthBytes =", wBmWidthBytes,			(LPSTR)"wBmPlanes =", wBmPlanes,			(LPSTR)"wBmBitsPixel =", wBmBitsPixel,			(LPSTR)"wBmSegmentIndex =", wBmSegmentIndex,			(LPSTR)"wBmScanSegment =", wBmScanSegment,			(LPSTR)"wBmFillBytes =", wBmFillBytes);		MessageBox(0, szOutput, "BITMAP DEBUG", MB_OK);    }#endif	fBmOk = FALSE;	return (fBmOk);}BOOLFindALocalEntry(HANDLE hBmp, HGLOBAL wLocalSegment, LPLOCALENTRY lpLocalEntry)	{    LOCALENTRY le;	BOOL ok;	WORD seg;	seg = wLocalSegment;    if (! seg) goto ERROR_RETURN;	/* seg is not always formed properly.  This should fix it.	   seg is used as a selector (seg &= 0xfffc)	   we OR in the 1 (seg |= 1) to force this to be a local	   (vs. global) memory-mapping descriptor table.	seg &= 0xfffc;	seg |= 1;	jca 30 Sept 93  removed; I don't think it's	necessary.... *crash!* */	le.dwSize = sizeof(le);/*	ok = LocalFirst(&le, seg & 0xfff9);	ok = LocalFirst(&le, seg & 0xfffb);   	ok = LocalFirst(&le, seg | 0x0003);  jca 30 Sept 93... ditto*/	ok = LocalFirst(&le, seg);	if (ok && le.hHandle == hBmp) goto FOUND_IT;	while ( ok )        {		ok = LocalNext(&le);		if (ok && le.hHandle == hBmp) goto FOUND_IT;		}ERROR_RETURN:	return (FALSE);FOUND_IT:	*lpLocalEntry = le;    return (TRUE);	}BOOLFindGdiLocalEntry(HANDLE hBmp, LPWORD lpwLocalSegment, LPLOCALENTRY lpLocalEntry)	{    GLOBALENTRY ge;    BOOL ok;	HANDLE hGDI = GetModuleHandle("GDI");	SYSHEAPINFO shi;    HGLOBAL wLocalSegment;	memset((char *)&shi, 0, sizeof(SYSHEAPINFO));    	// jca 30 Sept 93   (must init the struct)	shi.dwSize = sizeof(SYSHEAPINFO); 					// jca 30 Sept 93	SystemHeapInfo(&shi);	wLocalSegment = shi.hGDISegment;	ok = FindALocalEntry(hBmp, wLocalSegment, lpLocalEntry);    if (ok && lpLocalEntry->hHandle == hBmp) goto Found_It;	ge.dwSize = sizeof(ge);    ok = GlobalFirst(&ge, GLOBAL_ALL);	    while ( ok )        {        if (ge.hOwner == hGDI)			{            if (ContainsLocalHeap(ge.hBlock) &&					(ge.hBlock != shi.hGDISegment))				{                wLocalSegment = ge.hBlock;				ok = FindALocalEntry(hBmp, wLocalSegment, lpLocalEntry);                if (ok && lpLocalEntry->hHandle == hBmp) goto Found_It;				}			}        ok = GlobalNext(&ge, GLOBAL_ALL);		}ErrorReturn:	return (FALSE);Found_It:	*lpwLocalSegment = wLocalSegment;	return (TRUE);	}// We can rely on ToolHelp to tell us whether a block contains a// valid local heap; all the homebrew validity checks are not needed hereBOOL ContainsLocalHeap(WORD seg)	{    LOCALENTRY le;    le.dwSize = sizeof(le);    return LocalFirst(&le, seg);	}#endif //MACINTOSH