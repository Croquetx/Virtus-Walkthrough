/*------------------------------------------------------------------------------ * VWINDOWSÂ - the window object toolbox * * Copyright c 1991 by Virtus Corporation * All Rights Reserved * Written by David A. Smithx * Virtus Corporation * 117 Edinburgh So * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * FLASH.c *------------------------------------------------------------------------------ */#include "WTypes.h"#include "VMath.h"#include "Clip.h"#include "Flash.h"#include "objprclp.h"int (*inside)(Point3DAllInfo, LineData *, FFixed *);int (*CalcIntersection)(LineData *, Point3DAllInfo *, FFixed,				Point3DAllInfo *, FFixed,				PointFFixed *, PointFFixed *,				Point3DAllInfo *, PointFFixed *);long (*WinInside)(PointFFixed, LineData *, FFixed *);int (*WinCalcIntersection)(LineData *, PointFFixed *, FFixed,						   PointFFixed *, FFixed, PointFFixed *);// MERGE-GOURAUD [[[int (*GouraudCalcIntersection)(LineData *LineInfo,				PointFFixed *pt1, FFixed LineEqVal1,				PointFFixed *pt2, FFixed LineEqVal2,				FFixed *inten1, FFixed *inten2,				PointFFixed *pout, FFixed *intenout);// MERGE-GOURAUD ]]]FFixed HorizontalLineYValue, VerticalLineXValue;extern V_Array *ClipPtsFFixed1;extern V_Array *ClipPtsFFixed2;extern V_Array *FramePts1;         		//JAM Frame Fix 27Sept94extern V_Array *FramePts2;              //JAM Frame Fix 27Sept94extern V_Array *ClipPts3DAllInfo1;extern V_Array *ClipPts3DAllInfo2;extern V_Array *ClipPtsGouraud1;		// MERGE-GOURAUDextern V_Array *ClipPtsGouraud2;		// MERGE-GOURAUD/*given two points on a line, finds the coefficients for the line equation  ax + by + c = 0*/// JAM 3-7-94 two lines removed from here, added to objprclp.h to allow makeline// routine to be used by other filesvoidWinMakeLine(PointFFixed p1, PointFFixed p2, LineData *LineInfo){	long width1, width2;	long templong;		LineInfo->a.l = p2.v.l - p1.v.l;	LineInfo->b.l = p1.h.l - p2.h.l;	templong = LineInfo->a.l;	if(templong < 0) templong = -templong;	BIT_WIDTH(templong, width1);	templong = LineInfo->b.l;	if(templong < 0) templong = -templong;	BIT_WIDTH(templong, width2);	if(width1 > width2)	{		width1 = -(width1 - 16);	}	else 	{		width1 = -(width2 - 16);	}	FFFShift(LineInfo->a, width1);	FFFShift(LineInfo->b, width1);	LineInfo->c.l = -(FFMult(p1.h, LineInfo->a).l + FFMult(p1.v, LineInfo->b).l);}	intStandardWinCalcIntersection(LineData *LineInfo,							PointFFixed *pt1, FFixed LineEqVal1,							PointFFixed *pt2, FFixed LineEqVal2,							PointFFixed *pout);intStandardWinCalcIntersection(LineData *LineInfo,							PointFFixed *pt1, FFixed LineEqVal1,							PointFFixed *pt2, FFixed LineEqVal2,							PointFFixed *pout){	FFixed ff1, ff2, ratio;	//	ff1.l = FFMult(LineInfo->a, pt1->h).l + FFMult(LineInfo->b, pt1->v).l + LineInfo->c.l;//	ff2.l = FFMult(LineInfo->a, pt2->h).l + FFMult(LineInfo->b, pt2->v).l + LineInfo->c.l;	ff1 = LineEqVal1;	ff2 = LineEqVal2;	if(ff1.l < 0)	{		if(ff2.l <= 0) DEBUGGER();		ff1.l = - ff1.l;	}	else	{		if((ff2.l >= 0) || (ff1.l == 0))DEBUGGER();		ff2.l = -ff2.l;	}		if(ff1.l >= ff2.l)	{		ff2.l += ff1.l;		ratio = FFDiv(ff1, ff2);		if(ratio.l < 0) ratio.l = 0;		if(ratio.l > 0x00010000) ratio.l = 0x00010000;				ff1.l = pt2->h.l - pt1->h.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		pout->h.l = pt1->h.l + ff1.l;				ff1.l = pt2->v.l - pt1->v.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		pout->v.l = pt1->v.l + ff1.l;	}	else	{		ff1.l += ff2.l;		ratio = FFDiv(ff2, ff1);		if(ratio.l < 0) ratio.l = 0;		if(ratio.l > 0x00010000) ratio.l = 0x00010000;				ff1.l = pt1->h.l - pt2->h.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		pout->h.l = pt2->h.l + ff1.l;				ff1.l = pt1->v.l - pt2->v.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		pout->v.l = pt2->v.l + ff1.l;	}	return(1);}longStandardWinInside(PointFFixed p, LineData *LineInfo, FFixed *result);longStandardWinInside(PointFFixed p, LineData *LineInfo, FFixed *result){	FFixed signtest;		signtest = FFMult(LineInfo->a, p.h);	signtest.l += FFMult(LineInfo->b, p.v).l;	signtest.l += LineInfo->c.l;	*result = signtest;	if(signtest.l < 0) return(INSIDE);	if(signtest.l == 0) return(EXACTLY_ON);	return(OUTSIDE);}intWinCalcIntersectionWithHorizontalLine(LineData *LineInfo,							PointFFixed *pt1, FFixed LineEqVal1,							PointFFixed *pt2, FFixed LineEqVal2,							PointFFixed *pout);intWinCalcIntersectionWithHorizontalLine(LineData *LineInfo,							PointFFixed *pt1, FFixed LineEqVal1,							PointFFixed *pt2, FFixed LineEqVal2,							PointFFixed *pout){	FFixed ff1, ff2, ratio;	//	ff1.l = pt1->v.l - HorizontalLineYValue.l;//	ff2.l = pt2->v.l - HorizontalLineYValue.l;	ff1 = LineEqVal1;	ff2 = LineEqVal2;	if(ff1.l < 0)	{		if(ff2.l <= 0) DEBUGGER();		ff1.l = - ff1.l;	}	else	{		if((ff2.l >= 0) || (ff1.l == 0))DEBUGGER();		ff2.l = -ff2.l;	}		if(ff1.l >= ff2.l)	{		ff2.l += ff1.l;		ratio = FFDiv(ff1, ff2);		if(ratio.l < 0) ratio.l = 0;		if(ratio.l > 0x00010000) ratio.l = 0x00010000;				ff1.l = pt2->h.l - pt1->h.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		pout->h.l = pt1->h.l + ff1.l;				pout->v = HorizontalLineYValue;	}	else	{		ff1.l += ff2.l;		ratio = FFDiv(ff2, ff1);		if(ratio.l < 0) ratio.l = 0;		if(ratio.l > 0x00010000) ratio.l = 0x00010000;				ff1.l = pt1->h.l - pt2->h.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		pout->h.l = pt2->h.l + ff1.l;				pout->v = HorizontalLineYValue;	}	return(1);}longWinInsideHorizontalLine(PointFFixed p, LineData *LineInfo, FFixed *result);longWinInsideHorizontalLine(PointFFixed p, LineData *LineInfo, FFixed *result){	if(LineInfo->b.l > 0)	{		result->l = p.v.l - HorizontalLineYValue.l;	}	else	{		result->l = HorizontalLineYValue.l - p.v.l;	}	if(result->l > 0) return(OUTSIDE);	if(result->l < 0) return(INSIDE);	return(EXACTLY_ON);}intWinCalcIntersectionWithVerticalLine(LineData *LineInfo,							PointFFixed *pt1, FFixed LineEqVal1,							PointFFixed *pt2, FFixed LineEqVal2,							PointFFixed *pout);intWinCalcIntersectionWithVerticalLine(LineData *LineInfo,							PointFFixed *pt1, FFixed LineEqVal1,							PointFFixed *pt2, FFixed LineEqVal2,							PointFFixed *pout){	FFixed ff1, ff2, ratio;	//	ff1.l = pt1->h.l - VerticalLineXValue.l;//	ff2.l = pt2->h.l - VerticalLineXValue.l;	ff1 = LineEqVal1;	ff2 = LineEqVal2;	if(ff1.l < 0)	{		if(ff2.l <= 0) DEBUGGER();		ff1.l = - ff1.l;	}	else	{		if((ff2.l >= 0) || (ff1.l == 0))DEBUGGER();		ff2.l = -ff2.l;	}		if(ff1.l >= ff2.l)	{		ff2.l += ff1.l;		ratio = FFDiv(ff1, ff2);		if(ratio.l < 0) ratio.l = 0;		if(ratio.l > 0x00010000) ratio.l = 0x00010000;				pout->h = VerticalLineXValue;				ff1.l = pt2->v.l - pt1->v.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		pout->v.l = pt1->v.l + ff1.l;	}	else	{		ff1.l += ff2.l;		ratio = FFDiv(ff2, ff1);		if(ratio.l < 0) ratio.l = 0;		if(ratio.l > 0x00010000) ratio.l = 0x00010000;				pout->h = VerticalLineXValue;				ff1.l = pt1->v.l - pt2->v.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		pout->v.l = pt2->v.l + ff1.l;	}	return(1);}longWinInsideVerticalLine(PointFFixed p, LineData *LineInfo, FFixed *result);longWinInsideVerticalLine(PointFFixed p, LineData *LineInfo, FFixed *result){	if(LineInfo->a.l > 0)	{		result->l = p.h.l - VerticalLineXValue.l;	}	else	{		result->l = VerticalLineXValue.l - p.h.l;	}	if(result->l > 0) return(OUTSIDE);	if(result->l < 0) return(INSIDE);	return(EXACTLY_ON);}//Changed by JAM 3-7-94 to utilize saved cliping poly line equations [[[longWinClipToLine(PointFFixed *p, char *olddrawframe, long plength, LineData *LineInfo,			  PointFFixed *newp, char *newdrawframe, long *lengthout);longWinClipToLine(PointFFixed *p, char *olddrawframe, long plength, LineData *LineInfo,			  PointFFixed *newp, char *newdrawframe, long *lengthout){	long inpt, outpt;	long NumOfCrossings = 0;	long AnchorInOutOn, InOutOn;	long i, j;	long PreviousInOutOn;	FFixed AnchorLineTestResult, LineTestResult, PreviousLineTestResult;		inpt = outpt = 0;			AnchorInOutOn = InOutOn = WinInside(p[0], LineInfo, &LineTestResult);	AnchorLineTestResult = LineTestResult;	if(InOutOn == OUTSIDE)	{		do		{			PreviousLineTestResult = LineTestResult;			inpt++;		} while((inpt < plength) &&			   ((InOutOn = WinInside(p[inpt], LineInfo, &LineTestResult)) == OUTSIDE));		if(inpt == plength)		{			return(REJECT);		}		if(InOutOn != EXACTLY_ON)		{			if(WinCalcIntersection(LineInfo, &(p[inpt-1]), PreviousLineTestResult,								   &(p[inpt]), LineTestResult, &(newp[outpt])))			{            	//this edge is part of original poly, so has frame if original poly had frame				newdrawframe[outpt] = olddrawframe[inpt-1]; //JAM Frame Fix 27Sept94				outpt++;			}		}		NumOfCrossings++;	}		while(inpt < plength)	{		do		{			PreviousLineTestResult = LineTestResult;			newp[outpt] = p[inpt];			//this edge is part of original poly, so has frame if original poly had frame			newdrawframe[outpt] = olddrawframe[inpt]; //JAM Frame Fix 27Sept94			inpt++;			outpt++;			PreviousInOutOn = InOutOn;		} while((inpt < plength) &&			   ((InOutOn = WinInside(p[inpt], LineInfo, &LineTestResult)) != OUTSIDE));		if(inpt < plength)		{			if(PreviousInOutOn != EXACTLY_ON)			{				if(WinCalcIntersection(LineInfo, &(p[inpt]), LineTestResult,									   &(p[inpt-1]), PreviousLineTestResult, &(newp[outpt])))				{					//this edge is new, so it does not have frame					newdrawframe[outpt] = 0; //JAM Frame Fix 27Sept94					outpt++;				}			}			NumOfCrossings++;			do			{				PreviousLineTestResult = LineTestResult;				inpt++;			} while((inpt < plength) &&				   ((InOutOn = WinInside(p[inpt], LineInfo, &LineTestResult)) == OUTSIDE));			if(inpt < plength)			{				if(InOutOn != EXACTLY_ON)				{					if(WinCalcIntersection(LineInfo, &(p[inpt-1]), PreviousLineTestResult,										   &(p[inpt]), LineTestResult, &(newp[outpt])))					{						//this edge is part of original poly, so has frame if original poly had frame						newdrawframe[outpt] = olddrawframe[inpt-1]; //JAM Frame Fix 27Sept94						outpt++;					}				}				NumOfCrossings++;			}		}	}	if(NumOfCrossings > 0)	{		if((AnchorInOutOn == OUTSIDE) && (InOutOn == INSIDE))		{			if(WinCalcIntersection(LineInfo, &(p[0]), AnchorLineTestResult,								   &(p[plength-1]), LineTestResult, &(newp[outpt])))			{				//this edge is new so it doesn't have frame				newdrawframe[outpt] = 0; //JAM Frame Fix 27Sept94				outpt++;			}		}		else if((AnchorInOutOn == INSIDE) && (InOutOn == OUTSIDE))		{			if(WinCalcIntersection(LineInfo, &(p[plength-1]), LineTestResult,								   &(p[0]), AnchorLineTestResult, &(newp[outpt])))			{				//this edge is part of original poly, so has frame if original poly had frame				newdrawframe[outpt] = olddrawframe[plength-1]; //JAM Frame Fix 27Sept94				outpt++;			}		}		}	if(outpt < 3) return(REJECT);	*lengthout = outpt;	return(ACCEPT);}longWinBoundingBoxCheck(Point *p, long plength, FFixedRect *BoundingBox, short MinPixels);longWinBoundingBoxCheck(Point *p, long plength, FFixedRect *BoundingBox, short MinPixels){	FFixed hmin, hmax, vmin, vmax;	long index;	FFixed tempfixed;	short hminshort, hmaxshort, vminshort, vmaxshort;		{		Point *ptemp = p;		short tempshort;				hminshort = hmaxshort = ptemp->h;		vminshort = vmaxshort = ptemp->v;		ptemp++;		index = plength-1;		while(index--)		{			tempshort = ptemp->h;			if(tempshort < hminshort) hminshort = tempshort;			else if(tempshort > hmaxshort) hmaxshort = tempshort;			tempshort = ptemp->v;			if(tempshort < vminshort) vminshort = tempshort;			else if(tempshort > vmaxshort) vmaxshort = tempshort;			ptemp++;		}	}	/*	if(hmax < BoundingBox->left.l) return REJECT;	if(hmin > BoundingBox->right.l) return REJECT;	if(vmax < BoundingBox->top.l) return REJECT;	if(vmin > BoundingBox->bottom.l) return REJECT;	*/	hmax.intg = hmaxshort; hmax.frac = 0;	hmin.intg = hminshort; hmin.frac = 0;	vmax.intg = vmaxshort; vmax.frac = 0;	vmin.intg = vminshort; vmin.frac = 0;	//we reject if bounding boxes don't intersect OR intersection is too small	//(too small = less than or equal to MinPixels high or wide)	tempfixed.frac = 0; tempfixed.intg = MinPixels;	if(hmax.l - BoundingBox->left.l <= tempfixed.l) return REJECT;	if(BoundingBox->right.l - hmin.l <= tempfixed.l) return REJECT;	if(vmax.l - BoundingBox->top.l <= tempfixed.l) return REJECT;	if(BoundingBox->bottom.l - vmin.l <= tempfixed.l) return REJECT;	return(ACCEPT);}intClip::WinClipToPoly(Point *polyin, long lengthin, PointFFixed **polyoutptr, char **frameoutptr, long *lengthout,					short MinPixels){	long index;	LineData *LineInfos;	PointFFixed *ClipShapePtr;	long oldcliplength;	PointFFixed *polyout1, *polyout2, *tempptr;    char *frameout1, *frameout2, *tempptr2;	long templong;		/* code significantly faster if bounding box check is in line*/	/*	if(WinBoundingBoxCheck(polyin, lengthin, &BoundingBox, MinPixels) == REJECT)	{		return(REJECT);	}	*/		{		FFixed hmin, hmax, vmin, vmax;		long index;		FFixed tempfixed;		short hminshort, hmaxshort, vminshort, vmaxshort;				{			Point *ptemp = polyin;			short tempshort;					hminshort = hmaxshort = ptemp->h;			vminshort = vmaxshort = ptemp->v;			ptemp++;			index = lengthin-1;			while(index--)			{				tempshort = ptemp->h;				if(tempshort < hminshort) hminshort = tempshort;				else if(tempshort > hmaxshort) hmaxshort = tempshort;				tempshort = ptemp->v;				if(tempshort < vminshort) vminshort = tempshort;				else if(tempshort > vmaxshort) vmaxshort = tempshort;				ptemp++;			}		}		hmax.intg = hmaxshort; hmax.frac = 0;		hmin.intg = hminshort; hmin.frac = 0;		vmax.intg = vmaxshort; vmax.frac = 0;		vmin.intg = vminshort; vmin.frac = 0;		//we reject if bounding boxes don't intersect OR intersection is too small		//(too small = less than or equal to MinPixels high or wide)		tempfixed.frac = 0; tempfixed.intg = MinPixels;		if(hmax.l - BoundingBox.left.l <= tempfixed.l) return REJECT;		if(BoundingBox.right.l - hmin.l <= tempfixed.l) return REJECT;		if(vmax.l - BoundingBox.top.l <= tempfixed.l) return REJECT;		if(BoundingBox.bottom.l - vmin.l <= tempfixed.l) return REJECT;	}		//get temporary array to put result clip into	oldcliplength = ClipShape->ALength();	if(oldcliplength <= 2) return REJECT;	if(ClipPtsFFixed1->ALength() < lengthin+oldcliplength)    {    	ClipPtsFFixed1->Unuse();    	ClipPtsFFixed1->SetLength(lengthin+oldcliplength);    	polyout1 = (PointFFixed *)ClipPtsFFixed1->Use();    	ClipPtsFFixed2->Unuse();    	ClipPtsFFixed2->SetLength(lengthin+oldcliplength);    	polyout2 = (PointFFixed *)ClipPtsFFixed2->Use();    }    else    {    	polyout1 = (PointFFixed *)ClipPtsFFixed1->Abuse();    	polyout2 = (PointFFixed *)ClipPtsFFixed2->Abuse();    }	//JAM Frame Fix 27Sept94	if(FramePts1->ALength() < lengthin+oldcliplength)    {		FramePts1->Unuse();		FramePts1->SetLength(lengthin+oldcliplength);		frameout1 = (char *)FramePts1->Use();		FramePts2->Unuse();		FramePts2->SetLength(lengthin+oldcliplength);		frameout2 = (char *)FramePts2->Use();    }    else    {		frameout1 = (char *)FramePts1->Abuse();		frameout2 = (char *)FramePts2->Abuse();    }	//copy in points onto out points	{		PointFFixed *pFF = polyout1;		Point *pt = polyin;		char *frameptr = frameout1;		//JAM Frame Fix 27Sept94		long index;				index = lengthin;		while(index--)		{			pFF->h.frac = pFF->v.frac = 0;			pFF->h.intg = pt->h;			pFF->v.intg = pt->v;			*frameptr = 1;		//JAM Frame Fix 27Sept94			pFF++;			pt++;			frameptr++;         //JAM Frame Fix 27Sept94		}	}		LineInfos = (LineData *)LineEqtns->Abuse();	ClipShapePtr = (PointFFixed *)ClipShape->Abuse();	index = 0;	*lengthout = lengthin;	while(index < ClipShape->ALength())	{		if(LineInfos[index].a.l == 0)		{			WinCalcIntersection = WinCalcIntersectionWithHorizontalLine;			WinInside = WinInsideHorizontalLine;			HorizontalLineYValue = ClipShapePtr[index].v;		}		else if(LineInfos[index].b.l == 0)		{			WinCalcIntersection = WinCalcIntersectionWithVerticalLine;			WinInside = WinInsideVerticalLine;			VerticalLineXValue = ClipShapePtr[index].h;		}		else		{			WinCalcIntersection = StandardWinCalcIntersection;			WinInside = StandardWinInside;		}		templong = *lengthout;		//JAM Frame Fix 27Sept94		if(			WinClipToLine(polyout1, frameout1, templong, &(LineInfos[index]),						  polyout2, frameout2, lengthout) == REJECT		  ) { return(REJECT); }		index++;		tempptr = polyout1;		polyout1 = polyout2;		polyout2 = tempptr;		//JAM Frame Fix 27Sept94		tempptr2 =frameout1;		frameout1 = frameout2;		frameout2 = tempptr2;	}	*polyoutptr = polyout1;	//JAM Frame Fix 27Sept94	if(frameoutptr) *frameoutptr = frameout1;	return(ACCEPT);}//Changed by JAM 3-7-94 to utilize saved cliping poly line equations ]]]			/*these two routines clip a line segment vertically (crossed by a horizontal line)  and horizontally (crossed by a vertical line), replacing the first pair of points  with the clip intersection */voidClipLineVertical(FFixed *FFx1, FFixed *FFy1, FFixed FFyclip, FFixed *FFx2, FFixed *FFy2){	FFixed tempfixed, ratio;		tempfixed.l = FFy2->l - FFy1->l;	ratio.l = FFyclip.l - FFy1->l;	ratio = FFDiv(ratio, tempfixed);	tempfixed.l = FFx2->l - FFx1->l;	tempfixed = FFMult(ratio, tempfixed);	FFx1->l += tempfixed.l;	FFy1->l = FFyclip.l;}voidClipLineHorizontal(FFixed *FFx1, FFixed *FFy1, FFixed FFxclip, FFixed *FFx2, FFixed *FFy2){	FFixed tempfixed, ratio;		tempfixed.l = FFx2->l - FFx1->l;	ratio.l = FFxclip.l - FFx1->l;	ratio = FFDiv(ratio, tempfixed);	tempfixed.l = FFy2->l - FFy1->l;	tempfixed = FFMult(ratio, tempfixed);	FFy1->l += tempfixed.l;	FFx1->l = FFxclip.l;}/*clips line to rectangle by clipping to each side.  assumes y2 > y1*//*  the clip is moved in by 1/4 unit on each side to avoid problems with drawing  on the right or left edge of the clip, which is outside the clip*/intClipLineToRect(Rect rclip, FFixed *FFx1, FFixed *FFy1, FFixed *FFx2, FFixed *FFy2){	FFixed FFcliptop, FFclipbottom, FFclipleft, FFclipright;		FFcliptop.intg = rclip.top;	FFclipbottom.intg = rclip.bottom;	FFclipright.intg = rclip.right;	FFclipleft.intg = rclip.left;	FFcliptop.frac = FFclipbottom.frac = FFclipright.frac = FFclipleft.frac = 0;	/*move the clip in by 1/4th so that valid values will be      on or inside the clip*/	FFcliptop.l += FixedPointFive.l>>1;	FFclipbottom.l -= FixedPointFive.l>>1;	FFclipleft.l += FixedPointFive.l>>1;	FFclipright.l -= FixedPointFive.l>>1;	/*valid values are on or inside the clip.  We clip off any      pieces which are outside the clip*/	if((FFx1->l < FFclipleft.l) && (FFx2->l >= FFclipleft.l)) {		ClipLineHorizontal(FFx1, FFy1, FFclipleft, FFx2, FFy2);	}	else if((FFx2->l < FFclipleft.l) && (FFx1->l >= FFclipleft.l)) {		ClipLineHorizontal(FFx2, FFy2, FFclipleft, FFx1, FFy1);	}	if((FFx1->l > FFclipright.l) && (FFx2->l <= FFclipright.l)) {		ClipLineHorizontal(FFx1, FFy1, FFclipright, FFx2, FFy2);	}	else if((FFx2->l > FFclipright.l) && (FFx1->l <= FFclipright.l)) {		ClipLineHorizontal(FFx2, FFy2, FFclipright, FFx1, FFy1);	}    /*we know FFy1 <= FFy2, so only have to check one direction*/	if((FFy1->l < FFcliptop.l) && (FFy2->l >= FFcliptop.l)) {		ClipLineVertical(FFx1, FFy1, FFcliptop, FFx2, FFy2);	}	if((FFy2->l > FFclipbottom.l) && (FFy1->l <= FFclipbottom.l)) {		ClipLineVertical(FFx2, FFy2, FFclipbottom, FFx1, FFy1);	}	/*if one point is inside (on or within) rect now, both are.*/	if((FFy1->l >= FFcliptop.l) && (FFy1->l <= FFclipbottom.l) &&	   (FFx1->l >= FFclipleft.l) && (FFx1->l <= FFclipright.l)) 	{#if DEBUG	/*dummy check.  See if the other point really is inside*/	if((FFy2->l < FFcliptop.l) || (FFy2->l > FFclipbottom.l) ||	  (FFx2->l < FFclipleft.l) || (FFx2->l > FFclipright.l))     DEBUGGER();#endif		return(ACCEPT);    //there is something to draw	}	else 	{		return(REJECT);   //clipped out of existance	}}void WinMakeLine(PointFFixed, PointFFixed, LineData *);//Changed by JAM 3-7-94 to utilize saved cliping poly line equations [[[longClipSegmentToLine(LineData *LineInfo, PointFFixed *pt1, PointFFixed *pt2);longClipSegmentToLine(LineData *LineInfo, PointFFixed *pt1, PointFFixed *pt2){	FFixed ff1, ff2, ratio;	PointFFixed *pout;				ff1.l = FFMult(LineInfo->a, pt1->h).l + FFMult(LineInfo->b, pt1->v).l + LineInfo->c.l;	ff2.l = FFMult(LineInfo->a, pt2->h).l + FFMult(LineInfo->b, pt2->v).l + LineInfo->c.l;	if(ff1.l >= 0)	{		if(ff1.l == 0)		{			if(ff2.l > 0){ return(REJECT); }			else { return(ACCEPT); }		}		else		{				if(ff2.l >= 0) { return(REJECT); }		}		ff2.l = -ff2.l;		pout = pt1;	}	else	{		if(ff2.l <= 0) { return(ACCEPT); }		ff1.l = -ff1.l;		pout = pt2;	}			if(ff1.l >= ff2.l)	{		ff2.l += ff1.l;		ratio = FFDiv(ff1, ff2);		if(ratio.l < 0) ratio.l = 0;		if(ratio.l > 0x00010000) ratio.l = 0x00010000;				ff1.l = pt2->h.l - pt1->h.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		pout->h.l = pt1->h.l + ff1.l;				ff1.l = pt2->v.l - pt1->v.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		pout->v.l = pt1->v.l + ff1.l;	}	else	{		ff1.l += ff2.l;		ratio = FFDiv(ff2, ff1);		if(ratio.l < 0) ratio.l = 0;		if(ratio.l > 0x00010000) ratio.l = 0x00010000;				ff1.l = pt1->h.l - pt2->h.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		pout->h.l = pt2->h.l + ff1.l;				ff1.l = pt1->v.l - pt2->v.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		pout->v.l = pt2->v.l + ff1.l;	}	return(CROSSED);}longClipSegmentToVerticalLine(LineData *LineInfo, PointFFixed *pt1, PointFFixed *pt2);longClipSegmentToVerticalLine(LineData *LineInfo, PointFFixed *pt1, PointFFixed *pt2){	FFixed ff1, ff2, ratio;	PointFFixed *pout;		if(LineInfo->a.l > 0)		{			ff1.l = pt1->h.l - VerticalLineXValue.l;		ff2.l = pt2->h.l - VerticalLineXValue.l;	}	else	{		ff1.l = VerticalLineXValue.l - pt1->h.l;		ff2.l = VerticalLineXValue.l - pt2->h.l;	}	if(ff1.l >= 0)	{		if(ff1.l == 0)		{			if(ff2.l > 0){ return(REJECT); }			else { return(ACCEPT); }		}		else		{				if(ff2.l >= 0) { return(REJECT); }		}		ff2.l = -ff2.l;		pout = pt1;	}	else	{		if(ff2.l <= 0) { return(ACCEPT); }		ff1.l = -ff1.l;		pout = pt2;	}			if(ff1.l >= ff2.l)	{		ff2.l += ff1.l;		ratio = FFDiv(ff1, ff2);		if(ratio.l < 0) ratio.l = 0;		if(ratio.l > 0x00010000) ratio.l = 0x00010000;				pout->h.l = VerticalLineXValue.l;				ff1.l = pt2->v.l - pt1->v.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		pout->v.l = pt1->v.l + ff1.l;	}	else	{		ff1.l += ff2.l;		ratio = FFDiv(ff2, ff1);		if(ratio.l < 0) ratio.l = 0;		if(ratio.l > 0x00010000) ratio.l = 0x00010000;				pout->h.l = VerticalLineXValue.l;				ff1.l = pt1->v.l - pt2->v.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		pout->v.l = pt2->v.l + ff1.l;	}	return(CROSSED);}longClipSegmentToHorizontalLine(LineData *LineInfo, PointFFixed *pt1, PointFFixed *pt2);longClipSegmentToHorizontalLine(LineData *LineInfo, PointFFixed *pt1, PointFFixed *pt2){	FFixed ff1, ff2, ratio;	PointFFixed *pout;		if(LineInfo->b.l > 0)			{		ff1.l = pt1->v.l - HorizontalLineYValue.l;		ff2.l = pt2->v.l - HorizontalLineYValue.l;	}	else	{		ff1.l = HorizontalLineYValue.l - pt1->v.l;		ff2.l = HorizontalLineYValue.l - pt2->v.l;	}	if(ff1.l >= 0)	{		if(ff1.l == 0)		{			if(ff2.l > 0){ return(REJECT); }			else { return(ACCEPT); }		}		else		{				if(ff2.l >= 0) { return(REJECT); }		}		ff2.l = -ff2.l;		pout = pt1;	}	else	{		if(ff2.l <= 0) { return(ACCEPT); }		ff1.l = -ff1.l;		pout = pt2;	}			if(ff1.l >= ff2.l)	{		ff2.l += ff1.l;		ratio = FFDiv(ff1, ff2);		if(ratio.l < 0) ratio.l = 0;		if(ratio.l > 0x00010000) ratio.l = 0x00010000;				ff1.l = pt2->h.l - pt1->h.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		pout->h.l = pt1->h.l + ff1.l;				pout->v = HorizontalLineYValue;	}	else	{		ff1.l += ff2.l;		ratio = FFDiv(ff2, ff1);		if(ratio.l < 0) ratio.l = 0;		if(ratio.l > 0x00010000) ratio.l = 0x00010000;				ff1.l = pt1->h.l - pt2->h.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		pout->h.l = pt2->h.l + ff1.l;				pout->v = HorizontalLineYValue;	}	return(CROSSED);}intClip::ClipLineToPoly(PointFFixed *p1, PointFFixed *p2){	short plength, i;	LineData *LineEqtnsPtr;	PointFFixed *ClipShapePtr;	long ClipResult;		if(reject) return(REJECT);	//clipper is empty, immediately reject line		//BoundingBox Check	if(p1->h.l > p2->h.l)	{		if((p1->h.l < BoundingBox.left.l) ||		  (p2->h.l > BoundingBox.right.l))		{			return REJECT;		}	}	else	{		if((p2->h.l < BoundingBox.left.l) ||		  (p1->h.l > BoundingBox.right.l))		{			return REJECT;		}	}	if(p1->v.l > p2->v.l)	{		if((p1->v.l < BoundingBox.top.l) ||		  (p2->v.l > BoundingBox.bottom.l))		{			return REJECT;		}	}	else	{		if((p2->v.l < BoundingBox.top.l) ||		  (p1->v.l > BoundingBox.bottom.l))		{			return REJECT;		}	}		plength = ClipShape->ALength();		LineEqtnsPtr = (LineData *)LineEqtns->Abuse();	ClipShapePtr = (PointFFixed *)ClipShape->Abuse();		for(i=0;i<plength;i++)	{		if(LineEqtnsPtr[i].a.l == 0)		{			HorizontalLineYValue = ClipShapePtr[i].v;			ClipResult = ClipSegmentToHorizontalLine(&(LineEqtnsPtr[i]), p1, p2);		}		else if(LineEqtnsPtr[i].b.l == 0)		{			VerticalLineXValue = ClipShapePtr[i].h;			ClipResult = ClipSegmentToVerticalLine(&(LineEqtnsPtr[i]), p1, p2);		}		else		{			ClipResult = ClipSegmentToLine(&(LineEqtnsPtr[i]), p1, p2);		}		if(ClipResult == REJECT)		{//			LineEqtns->Unuse();			return(REJECT);		}	}		return(ACCEPT);}//Changed by JAM 3-7-94 to utilize saved cliping poly line equations ]]]	/*find correct texture value using formula		u1*(w1/w) + ratio(u2*(w2/w) - u1*(w1/w))	*/voidPerspectiveCorrectBetween(Point3DAllInfo *pt1, PointFFixed *tx1, 						  Point3DAllInfo *pt2, PointFFixed *tx2, 						  FFixed ratio,						  Point3DAllInfo *pout, PointFFixed *tout){	FFixed ff1, ff2, ff3, ff4;	long width1, width2;		if(pt1->perspecD != pt2->perspecD)	{		ff1.l = pt1->perspecD;		ff2.l = pout->perspecD;		ff1 = FFDiv(ff1, ff2);		ff3.l = pt2->perspecD;		ff2 = FFDiv(ff3, ff2);		/*now ff1 = w1/w and ff2 = w2/w*/		//watch for overflow.  Assumes ff2 < 1 so ff1 is only trouble		BIT_WIDTH(ff1.intg, width1);		if(tx1->h.intg >= 0)		{			if(tx1->v.intg >= 0)			{				if(tx1->h.intg > tx1->v.intg) { BIT_WIDTH(tx1->h.intg, width2); }				else { BIT_WIDTH(tx1->v.intg, width2); }			}			else			{				if(tx1->h.intg > -tx1->v.intg) { BIT_WIDTH(tx1->h.intg, width2); }				else { BIT_WIDTH(-tx1->v.intg, width2); }			}		}		else		{			if(tx1->v.intg >= 0)			{				if(-tx1->h.intg > tx1->v.intg) { BIT_WIDTH(-tx1->h.intg, width2); }				else { BIT_WIDTH(tx1->v.intg, width2); }			}			else			{				if(-tx1->h.intg > -tx1->v.intg) { BIT_WIDTH(-tx1->h.intg, width2); }				else { BIT_WIDTH(-tx1->v.intg, width2); }			}		}		if(width1 + width2 > 15)		{			width1 = width1 + width2 - 15;			ff1.l >>= width1;			ff2.l >>= width1;		}		else		{			width1 = 0;		}				ff3 = FFMult(tx1->h, ff1);		ff4.l = FFMult(tx2->h, ff2).l - ff3.l;		tout->h.l = (ff3.l + FFMult(ratio, ff4).l) << width1;		ff3 = FFMult(tx1->v, ff1);		ff4.l = FFMult(tx2->v, ff2).l - ff3.l;		tout->v.l = (ff3.l + FFMult(ratio, ff4).l) << width1;	}	else	{		ff1.l = tx2->h.l - tx1->h.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		tout->h.l = tx1->h.l + ff1.l;				ff1.l = tx2->v.l - tx1->v.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		tout->v.l = tx1->v.l + ff1.l;	}}voidBetweenTwoPoints(Point3DAllInfo *pt1, PointFFixed *tx1,				 Point3DAllInfo *pt2, PointFFixed *tx2,				 FFixed ratio,				 Point3DAllInfo *pout, PointFFixed *textureout);voidBetweenTwoPoints(Point3DAllInfo *pt1, PointFFixed *tx1,				 Point3DAllInfo *pt2, PointFFixed *tx2,				 FFixed ratio,				 Point3DAllInfo *pout, PointFFixed *textureout){	FFixed ff1;	Point3DAllInfo presult;			ff1.l = pt2->ScreenX.l - pt1->ScreenX.l;	if(ff1.l != 0) ff1 = FFMult(ff1, ratio);	presult.ScreenX.l = pt1->ScreenX.l + ff1.l;		ff1.l = pt2->ScreenY.l - pt1->ScreenY.l;	if(ff1.l != 0) ff1 = FFMult(ff1, ratio);	presult.ScreenY.l = pt1->ScreenY.l + ff1.l;			ff1.l = pt2->perspecD - pt1->perspecD;	if(ff1.l != 0) ff1 = FFMult(ff1, ratio);	presult.perspecD = ff1.l + pt1->perspecD;			PerspectiveCorrectBetween(pt1, tx1, pt2, tx2, ratio, &presult, textureout);	*pout = presult;}voidBetweenTwoPointsHLine(Point3DAllInfo *pt1, PointFFixed *tx1,				 Point3DAllInfo *pt2, PointFFixed *tx2,				 FFixed ratio,				 Point3DAllInfo *pout, PointFFixed *textureout);voidBetweenTwoPointsHLine(Point3DAllInfo *pt1, PointFFixed *tx1,				 Point3DAllInfo *pt2, PointFFixed *tx2,				 FFixed ratio,				 Point3DAllInfo *pout, PointFFixed *textureout){	FFixed ff1;	Point3DAllInfo presult;			ff1.l = pt2->ScreenX.l - pt1->ScreenX.l;	if(ff1.l != 0) ff1 = FFMult(ff1, ratio);	presult.ScreenX.l = pt1->ScreenX.l + ff1.l;		presult.ScreenY = HorizontalLineYValue;			ff1.l = pt2->perspecD - pt1->perspecD;	if(ff1.l != 0) ff1 = FFMult(ff1, ratio);	presult.perspecD = ff1.l + pt1->perspecD;			PerspectiveCorrectBetween(pt1, tx1, pt2, tx2, ratio, &presult, textureout);	*pout = presult;}voidBetweenTwoPointsVLine(Point3DAllInfo *pt1, PointFFixed *tx1,				 Point3DAllInfo *pt2, PointFFixed *tx2,				 FFixed ratio,				 Point3DAllInfo *pout, PointFFixed *textureout);voidBetweenTwoPointsVLine(Point3DAllInfo *pt1, PointFFixed *tx1,				 Point3DAllInfo *pt2, PointFFixed *tx2,				 FFixed ratio,				 Point3DAllInfo *pout, PointFFixed *textureout){	FFixed ff1;	Point3DAllInfo presult;			presult.ScreenX = VerticalLineXValue;		ff1.l = pt2->ScreenY.l - pt1->ScreenY.l;	if(ff1.l != 0) ff1 = FFMult(ff1, ratio);	presult.ScreenY.l = pt1->ScreenY.l + ff1.l;			ff1.l = pt2->perspecD - pt1->perspecD;	if(ff1.l != 0) ff1 = FFMult(ff1, ratio);	presult.perspecD = ff1.l + pt1->perspecD;			PerspectiveCorrectBetween(pt1, tx1, pt2, tx2, ratio, &presult, textureout);	*pout = presult;}intStandardCalcIntersection(LineData *LineInfo,				Point3DAllInfo *pt1, FFixed LineEqVal1,				Point3DAllInfo *pt2, FFixed LineEqVal2,				PointFFixed *tx1, PointFFixed *tx2,				Point3DAllInfo *pout, PointFFixed *textureout);intStandardCalcIntersection(LineData *LineInfo,				Point3DAllInfo *pt1, FFixed LineEqVal1,				Point3DAllInfo *pt2, FFixed LineEqVal2,				PointFFixed *tx1, PointFFixed *tx2,				Point3DAllInfo *pout, PointFFixed *textureout){	FFixed ff1, ff2, ratio;	//	ff1.l = FFMult(LineInfo->a, pt1->ScreenX).l + FFMult(LineInfo->b, pt1->ScreenY).l + LineInfo->c.l;//	ff2.l = FFMult(LineInfo->a, pt2->ScreenX).l + FFMult(LineInfo->b, pt2->ScreenY).l + LineInfo->c.l;	ff1 = LineEqVal1;	ff2 = LineEqVal2;	if(ff1.l < 0)	{		#if DEBUG		if(ff2.l <= 0) DEBUGGER();		#endif		ff1.l = - ff1.l;	}	else	{		#if DEBUG		if((ff2.l >= 0) || (ff1.l == 0))DEBUGGER();		#endif		ff2.l = -ff2.l;	}		if(ff1.l >= ff2.l)	{		ff2.l += ff1.l;		ratio = FFDiv(ff1, ff2);		if(ratio.l < 0) ratio.l = 0;		if(ratio.l > 0x00010000) ratio.l = 0x00010000;				BetweenTwoPoints(pt1, tx1, pt2, tx2, ratio, pout, textureout);	}	else	{		ff1.l += ff2.l;		ratio = FFDiv(ff2, ff1);		if(ratio.l < 0) ratio.l = 0;		if(ratio.l > 0x00010000) ratio.l = 0x00010000;				BetweenTwoPoints(pt2, tx2, pt1, tx1, ratio, pout, textureout);			}		return(1);}intStandardInside(Point3DAllInfo p, LineData *LineInfo, FFixed *result);intStandardInside(Point3DAllInfo p, LineData *LineInfo, FFixed *result){	FFixed signtest;		signtest = FFMult(LineInfo->a, p.ScreenX);	signtest.l += FFMult(LineInfo->b, p.ScreenY).l;	signtest.l += LineInfo->c.l;	*result = signtest;	if(signtest.l > 0) return(OUTSIDE);	if(signtest.l < 0) return(INSIDE);	return(EXACTLY_ON);}intCalcIntersectionWithHorizontalLine(LineData *LineInfo,				Point3DAllInfo *pt1, FFixed LineEqVal1,				Point3DAllInfo *pt2, FFixed LineEqVal2,				PointFFixed *tx1, PointFFixed *tx2,				Point3DAllInfo *pout, PointFFixed *textureout);intCalcIntersectionWithHorizontalLine(LineData *LineInfo,				Point3DAllInfo *pt1, FFixed LineEqVal1,				Point3DAllInfo *pt2, FFixed LineEqVal2,				PointFFixed *tx1, PointFFixed *tx2,				Point3DAllInfo *pout, PointFFixed *textureout){	FFixed ff1, ff2, ratio;	//	ff1.l = pt1->ScreenY.l - HorizontalLineYValue.l;//	ff2.l = pt2->ScreenY.l - HorizontalLineYValue.l;	ff1 = LineEqVal1;	ff2 = LineEqVal2;	if(ff1.l < 0)	{		#if DEBUG		if(ff2.l <= 0) DEBUGGER();		#endif		ff1.l = - ff1.l;	}	else	{		#if DEBUG		if((ff2.l >= 0) || (ff1.l == 0))DEBUGGER();		#endif		ff2.l = -ff2.l;	}		if(ff1.l >= ff2.l)	{		ff2.l += ff1.l;		ratio = FFDiv(ff1, ff2);		if(ratio.l < 0) ratio.l = 0;		if(ratio.l > 0x00010000) ratio.l = 0x00010000;				BetweenTwoPointsHLine(pt1, tx1, pt2, tx2, ratio, pout, textureout);	}	else	{		ff1.l += ff2.l;		ratio = FFDiv(ff2, ff1);		if(ratio.l < 0) ratio.l = 0;		if(ratio.l > 0x00010000) ratio.l = 0x00010000;				BetweenTwoPointsHLine(pt2, tx2, pt1, tx1, ratio, pout, textureout);			}		return(1);}intInsideHorizontalLine(Point3DAllInfo p, LineData *LineInfo, FFixed *result);intInsideHorizontalLine(Point3DAllInfo p, LineData *LineInfo, FFixed *result){	if(LineInfo->b.l > 0)	{		result->l = p.ScreenY.l - HorizontalLineYValue.l;	}	else	{		result->l = HorizontalLineYValue.l - p.ScreenY.l;	}	if(result->l > 0) return(OUTSIDE);	if(result->l < 0) return(INSIDE);	return(EXACTLY_ON);}intCalcIntersectionWithVerticalLine(LineData *LineInfo,				Point3DAllInfo *pt1, FFixed LineEqVal1,				Point3DAllInfo *pt2, FFixed LineEqVal2,				PointFFixed *tx1, PointFFixed *tx2,				Point3DAllInfo *pout, PointFFixed *textureout);intCalcIntersectionWithVerticalLine(LineData *LineInfo,				Point3DAllInfo *pt1, FFixed LineEqVal1,				Point3DAllInfo *pt2, FFixed LineEqVal2,				PointFFixed *tx1, PointFFixed *tx2,				Point3DAllInfo *pout, PointFFixed *textureout){	FFixed ff1, ff2, ratio;	//	ff1.l = pt1->ScreenX.l - VerticalLineXValue.l;//	ff2.l = pt2->ScreenX.l - VerticalLineXValue.l;	ff1 = LineEqVal1;	ff2 = LineEqVal2;	if(ff1.l < 0)	{		#if DEBUG		if(ff2.l <= 0) DEBUGGER();		#endif		ff1.l = - ff1.l;	}	else	{		#if DEBUG		if((ff2.l >= 0) || (ff1.l == 0))DEBUGGER();		#endif		ff2.l = -ff2.l;	}		if(ff1.l >= ff2.l)	{		ff2.l += ff1.l;		ratio = FFDiv(ff1, ff2);		if(ratio.l < 0) ratio.l = 0;		if(ratio.l > 0x00010000) ratio.l = 0x00010000;				BetweenTwoPointsVLine(pt1, tx1, pt2, tx2, ratio, pout, textureout);	}	else	{		ff1.l += ff2.l;		ratio = FFDiv(ff2, ff1);		if(ratio.l < 0) ratio.l = 0;		if(ratio.l > 0x00010000) ratio.l = 0x00010000;				BetweenTwoPointsVLine(pt2, tx2, pt1, tx1, ratio, pout, textureout);			}		return(1);}intInsideVerticalLine(Point3DAllInfo p, LineData *LineInfo, FFixed *result);intInsideVerticalLine(Point3DAllInfo p, LineData *LineInfo, FFixed *result){	if(LineInfo->a.l > 0)	{		result->l = p.ScreenX.l - VerticalLineXValue.l;	}	else	{		result->l = VerticalLineXValue.l - p.ScreenX.l;	}	if(result->l > 0) return(OUTSIDE);	if(result->l < 0) return(INSIDE);	return(EXACTLY_ON);}//Changed by JAM 3-7-94 to utilize saved cliping poly line equations [[[/*clip poly to line.  fairly clever method which does not require  a scratch array--just handles end job carefully so as to not overwrite points*/intClipToLine(Point3DAllInfo *p, PointFFixed *texture, long plength, LineData *LineInfo,		   Point3DAllInfo *newp, PointFFixed *newtexture, long *lengthout);intClipToLine(Point3DAllInfo *p, PointFFixed *texture, long plength, LineData *LineInfo,		   Point3DAllInfo *newp, PointFFixed *newtexture, long *lengthout){		int inpt, outpt;	int NumOfCrossings = 0;	int AnchorInOutOn, InOutOn;	int PreviousInOutOn;	int i,j;	FFixed AnchorLineTestResult, LineTestResult, PreviousLineTestResult;		inpt = outpt = 0;	AnchorInOutOn = InOutOn = inside(p[0], LineInfo, &LineTestResult);	AnchorLineTestResult = LineTestResult;	if(InOutOn == OUTSIDE)	{		do		{			PreviousLineTestResult = LineTestResult;			inpt++;		} while((inpt < plength) &&			   ((InOutOn = inside(p[inpt], LineInfo, &LineTestResult)) == OUTSIDE));		if(inpt == plength)		{			return(REJECT);		}		if(InOutOn != EXACTLY_ON)		{			if(CalcIntersection(LineInfo, &(p[inpt-1]), PreviousLineTestResult,							    &(p[inpt]), LineTestResult,								&(texture[inpt-1]), &(texture[inpt]),								&(newp[outpt]), &(newtexture[outpt])))			{				outpt++;			}		}		NumOfCrossings++;	}		while(inpt < plength)	{		do		{			PreviousLineTestResult = LineTestResult;			newp[outpt] = p[inpt];			newtexture[outpt] = texture[inpt];			inpt++;			outpt++;			PreviousInOutOn = InOutOn;		} while((inpt < plength) &&			   ((InOutOn = inside(p[inpt], LineInfo, &LineTestResult)) != OUTSIDE));		if(inpt < plength)		{			if(PreviousInOutOn != EXACTLY_ON)			{				if(CalcIntersection(LineInfo, &(p[inpt]), LineTestResult,								    &(p[inpt-1]), PreviousLineTestResult,									&(texture[inpt]), &(texture[inpt-1]),									&(newp[outpt]), &(newtexture[outpt])))				{					outpt++;				}			}			NumOfCrossings++;			do			{				PreviousLineTestResult = LineTestResult;				inpt++;			} while((inpt < plength) &&				   ((InOutOn = inside(p[inpt], LineInfo, &LineTestResult)) == OUTSIDE));			if(inpt < plength)			{				if(InOutOn != EXACTLY_ON)				{					if(CalcIntersection(LineInfo, &(p[inpt-1]), PreviousLineTestResult,									    &(p[inpt]), LineTestResult,										&(texture[inpt-1]), &(texture[inpt]),										&(newp[outpt]), &(newtexture[outpt])))					{						outpt++;					}				}				NumOfCrossings++;			}		}	}	if(NumOfCrossings > 0)	{		if((AnchorInOutOn == OUTSIDE) && (InOutOn == INSIDE))		{			if(CalcIntersection(LineInfo, &(p[0]), AnchorLineTestResult,								&(p[plength-1]), LineTestResult, 								&(texture[0]), &(texture[plength-1]),								&(newp[outpt]), &(newtexture[outpt])))			{				outpt++;			}		}		else if((AnchorInOutOn == INSIDE) && (InOutOn == OUTSIDE))		{			if(CalcIntersection(LineInfo, &(p[plength-1]), LineTestResult,								&(p[0]), AnchorLineTestResult,								&(texture[plength-1]), &(texture[0]),								&(newp[outpt]), &(newtexture[outpt])))			{				outpt++;			}		}		}	if(outpt < 3) return(REJECT);	*lengthout = outpt;	return(ACCEPT);}shortBoundingBoxCheck(Point3DAllInfo *p, long plength, FFixedRect *BoundingBox, short MinPixels);shortBoundingBoxCheck(Point3DAllInfo *p, long plength, FFixedRect *BoundingBox, short MinPixels){	long hmin, hmax, vmin, vmax, index, templong;	FFixed tempfixed;		hmin = hmax = p->ScreenX.l;	vmin = vmax = p->ScreenY.l;	p++;	for(index=1;index<plength;index++)	{		templong = p->ScreenX.l;		if(templong < hmin) hmin = templong;		else if(templong > hmax) hmax = templong;		templong = p->ScreenY.l;		if(templong < vmin) vmin = templong;		else if(templong > vmax) vmax = templong;		p++;	}	/*	if(hmax < BoundingBox->left.l) return REJECT;	if(hmin > BoundingBox->right.l) return REJECT;	if(vmax < BoundingBox->top.l) return REJECT;	if(vmin > BoundingBox->bottom.l) return REJECT;	*/	//we reject if bounding boxes don't intersect OR intersection is too small	tempfixed.frac = 0; tempfixed.intg = MinPixels;	if(hmax - BoundingBox->left.l <= tempfixed.l) return REJECT;	if(BoundingBox->right.l - hmin <= tempfixed.l) return REJECT;	if(vmax - BoundingBox->top.l <= tempfixed.l) return REJECT;	if(BoundingBox->bottom.l - vmin <= tempfixed.l) return REJECT;	return(ACCEPT);}/*clip the poly to the screen and any windows*//*may need to alter so clip is in same order every time*/intClip::ClipToPoly(Point3DAllInfo *polyin, PointFFixed *texturein, long lengthin,		   Point3DAllInfo **polyoutptr, PointFFixed **textureoutptr, long *lengthout,		   short MinPixels){	int index;	LineData *LineInfos;	PointFFixed *ClipShapePtr;	long oldcliplength;	Point3DAllInfo *polyout1, *polyout2, *tempPoint3DAllInfoptr;	PointFFixed *textureout1, *textureout2, *tempPointFFixedptr;	long templong;		if(BoundingBoxCheck(polyin, lengthin, &BoundingBox, MinPixels) == REJECT)	{		return(REJECT);	}		//get temporary array to put result clip into	oldcliplength = ClipShape->ALength();    if(ClipPtsFFixed1->ALength() < lengthin+oldcliplength)    {    	ClipPtsFFixed1->Unuse();    	ClipPtsFFixed1->SetLength(lengthin+oldcliplength);    	textureout1 = (PointFFixed *)ClipPtsFFixed1->Use();    	ClipPtsFFixed2->Unuse();    	ClipPtsFFixed2->SetLength(lengthin+oldcliplength);    	textureout2 = (PointFFixed *)ClipPtsFFixed2->Use();    }    else    {    	textureout1 = (PointFFixed *)ClipPtsFFixed1->Abuse();    	textureout2 = (PointFFixed *)ClipPtsFFixed2->Abuse();    }    if(ClipPts3DAllInfo1->ALength() < lengthin+oldcliplength)    {    	ClipPts3DAllInfo1->Unuse();    	ClipPts3DAllInfo1->SetLength(lengthin+oldcliplength);    	polyout1 = (Point3DAllInfo *)ClipPts3DAllInfo1->Use();    	ClipPts3DAllInfo2->Unuse();    	ClipPts3DAllInfo2->SetLength(lengthin+oldcliplength);    	polyout2 = (Point3DAllInfo *)ClipPts3DAllInfo2->Use();    }    else    {    	polyout1 = (Point3DAllInfo *)ClipPts3DAllInfo1->Abuse();    	polyout2 = (Point3DAllInfo *)ClipPts3DAllInfo2->Abuse();    }	    	//copy in points onto out points	{		Point3DAllInfo *polyouttmp = polyout1;		Point3DAllInfo *polyintmp = polyin;		PointFFixed *textureouttmp = textureout1;		PointFFixed *textureintmp= texturein;		long index;				index = lengthin;		while(index--)		{			*polyouttmp = *polyintmp;			*textureouttmp = *textureintmp;			polyouttmp++; polyintmp++; textureouttmp++; textureintmp++;		}	}		LineInfos = (LineData *)LineEqtns->Abuse();	ClipShapePtr = (PointFFixed *)ClipShape->Abuse();	index = 0;	*lengthout = lengthin;	while(index < ClipShape->ALength())	{		if(LineInfos[index].a.l == 0)		{			CalcIntersection = CalcIntersectionWithHorizontalLine;			inside = InsideHorizontalLine;			HorizontalLineYValue = ClipShapePtr[index].v;		}		else if(LineInfos[index].b.l == 0)		{			CalcIntersection = CalcIntersectionWithVerticalLine;			inside = InsideVerticalLine;			VerticalLineXValue = ClipShapePtr[index].h;		}		else		{			CalcIntersection = StandardCalcIntersection;			inside = StandardInside;		}		templong = *lengthout;		if(			ClipToLine(polyout1, textureout1, templong, &(LineInfos[index]),					   polyout2, textureout2, lengthout) == REJECT		  ) { return(REJECT); }		index++;		tempPoint3DAllInfoptr = polyout1;		polyout1 = polyout2;		polyout2 = tempPoint3DAllInfoptr;		tempPointFFixedptr = textureout1;		textureout1 = textureout2;		textureout2 = tempPointFFixedptr;	}	*polyoutptr = polyout1;	*textureoutptr = textureout1;	return(ACCEPT);}//Changed by JAM 3-7-94 to utilize saved cliping poly line equations ]]]/*used for temporary array for clipping for flash*/V_Array *flashtemparray = NULL;PointFFixed *flashtemparrayptr;long flashtemparraylength;PointFFixed *InitFlashTemporaryArray(long plength){	if(flashtemparraylength < plength)	{		flashtemparray->Unuse();		flashtemparray->SetLength(plength);		flashtemparrayptr = (PointFFixed *)flashtemparray->Use();		flashtemparraylength = plength;	}	return(flashtemparrayptr);}voidInitClipping(void){	flashtemparray = new(V_Array);	flashtemparray->cArray(0, sizeof(PointFFixed), 8);	flashtemparrayptr = (PointFFixed *)flashtemparray->Use();	flashtemparraylength = 0;}voidEndClipping(void){	flashtemparray->Unuse();	flashtemparray->dArray();}// MERGE-GOURAUD [[[						  /*------------------------------------------------------------------------------------------*/intGouraudStandardCalcIntersection(LineData *LineInfo,				PointFFixed *pt1, FFixed LineEqVal1,				PointFFixed *pt2, FFixed LineEqVal2,				FFixed *inten1, FFixed *inten2,				PointFFixed *pout, FFixed *inten_out);intGouraudStandardCalcIntersection(LineData *LineInfo,				PointFFixed *pt1, FFixed LineEqVal1,				PointFFixed *pt2, FFixed LineEqVal2,				FFixed *inten1, FFixed *inten2,				PointFFixed *pout, FFixed *inten_out){	FFixed ff1, ff2, ratio;	FFixed diff;		ff1 = LineEqVal1;	ff2 = LineEqVal2;	if(ff1.l < 0)	{		#if DEBUG		if(ff2.l <= 0) DEBUGGER();		#endif		ff1.l = - ff1.l;	}	else	{		#if DEBUG		if((ff2.l >= 0) || (ff1.l == 0))DEBUGGER();		#endif		ff2.l = -ff2.l;	}		if(ff1.l >= ff2.l)	{		ff2.l += ff1.l;		ratio = FFDiv(ff1, ff2);		if(ratio.l < 0) ratio.l = 0;		if(ratio.l > 0x00010000) ratio.l = 0x00010000;				ff1.l = pt2->h.l - pt1->h.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		pout->h.l = pt1->h.l + ff1.l;				ff1.l = pt2->v.l - pt1->v.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		pout->v.l = pt1->v.l + ff1.l;				ff1.l = inten2->l - inten1->l;		// GOURAUD		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		// GOURAUD		inten_out->l = inten1->l + ff1.l;		// GOURAUD	}	else	{		ff1.l += ff2.l;		ratio = FFDiv(ff2, ff1);		if(ratio.l < 0) ratio.l = 0;		if(ratio.l > 0x00010000) ratio.l = 0x00010000;				ff1.l = pt1->h.l - pt2->h.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		pout->h.l = pt2->h.l + ff1.l;				ff1.l = pt1->v.l - pt2->v.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		pout->v.l = pt2->v.l + ff1.l;				ff1.l = inten1->l - inten2->l;		// GOURAUD		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		// GOURAUD		inten_out->l = inten2->l + ff1.l;		// GOURAUD	}		return(1);}/*------------------------------------------------------------------------------------------*/intGouraudCalcIntersectionWithHorizontalLine(LineData *LineInfo,				PointFFixed *pt1, FFixed LineEqVal1,				PointFFixed *pt2, FFixed LineEqVal2,				FFixed *inten1, FFixed *inten2,				PointFFixed *pout, FFixed *intenout);intGouraudCalcIntersectionWithHorizontalLine(LineData *LineInfo,				PointFFixed *pt1, FFixed LineEqVal1,				PointFFixed *pt2, FFixed LineEqVal2,				FFixed *inten1, FFixed *inten2,				PointFFixed *pout, FFixed *intenout){FFixed ff1, ff2, ratio;FFixed diff;		ff1 = LineEqVal1;	ff2 = LineEqVal2;	if(ff1.l < 0)	{		#if DEBUG		if(ff2.l <= 0) DEBUGGER();		#endif		ff1.l = - ff1.l;	}	else	{		#if DEBUG		if((ff2.l >= 0) || (ff1.l == 0))DEBUGGER();		#endif		ff2.l = -ff2.l;	}		if(ff1.l >= ff2.l)	{		ff2.l += ff1.l;		ratio = FFDiv(ff1, ff2);		if(ratio.l < 0) ratio.l = 0;		if(ratio.l > 0x00010000) ratio.l = 0x00010000;		ff1.l = inten2->l - inten1->l;		// GOURAUD		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		// GOURAUD		intenout->l = inten1->l + ff1.l;		// GOURAUD		ff1.l = pt2->h.l - pt1->h.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		pout->h.l = pt1->h.l + ff1.l;				pout->v = HorizontalLineYValue;	}	else	{		ff1.l += ff2.l;		ratio = FFDiv(ff2, ff1);		if(ratio.l < 0) ratio.l = 0;		if(ratio.l > 0x00010000) ratio.l = 0x00010000;		ff1.l = inten1->l - inten2->l;		// GOURAUD		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		// GOURAUD		intenout->l = inten2->l + ff1.l;		// GOURAUD		ff1.l = pt1->h.l - pt2->h.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		pout->h.l = pt2->h.l + ff1.l;				pout->v = HorizontalLineYValue;	}		return(1);}/*------------------------------------------------------------------------------------------*/intGouraudCalcIntersectionWithVerticalLine(LineData *LineInfo,				PointFFixed *pt1, FFixed LineEqVal1,				PointFFixed *pt2, FFixed LineEqVal2,				FFixed *inten1, FFixed *inten2,				PointFFixed *pout, FFixed *intenout);intGouraudCalcIntersectionWithVerticalLine(LineData *LineInfo,				PointFFixed *pt1, FFixed LineEqVal1,				PointFFixed *pt2, FFixed LineEqVal2,				FFixed *inten1, FFixed *inten2,				PointFFixed *pout, FFixed *intenout){FFixed ff1, ff2, ratio;FFixed diff;		ff1 = LineEqVal1;	ff2 = LineEqVal2;	if(ff1.l < 0)	{		#if DEBUG		if(ff2.l <= 0) DEBUGGER();		#endif		ff1.l = - ff1.l;	}	else	{		#if DEBUG		if((ff2.l >= 0) || (ff1.l == 0))DEBUGGER();		#endif		ff2.l = -ff2.l;	}		if(ff1.l >= ff2.l)	{		ff2.l += ff1.l;		ratio = FFDiv(ff1, ff2);		if(ratio.l < 0) ratio.l = 0;		if(ratio.l > 0x00010000) ratio.l = 0x00010000;				pout->h = VerticalLineXValue;		ff1.l = inten2->l - inten1->l; 		// GOURAUD		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		// GOURAUD		intenout->l = inten1->l + ff1.l;		// GOURAUD		ff1.l = pt2->v.l - pt1->v.l; 		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		pout->v.l = pt1->v.l + ff1.l;	}	else	{		ff1.l += ff2.l;		ratio = FFDiv(ff2, ff1);		if(ratio.l < 0) ratio.l = 0;		if(ratio.l > 0x00010000) ratio.l = 0x00010000;					pout->h = VerticalLineXValue;		ff1.l = inten1->l - inten2->l; 		// GOURAUD		if(ff1.l != 0) ff1 = FFMult(ff1, ratio); 		// GOURAUD		intenout->l = inten2->l + ff1.l; 		// GOURAUD		ff1.l = pt1->v.l - pt2->v.l;		if(ff1.l != 0) ff1 = FFMult(ff1, ratio);		pout->v.l = pt2->v.l + ff1.l;	}		return(1);}/*------------------------------------------------------------------------------------------*/intGouraudClipToLine(PointFFixed *p, FFixed *inten, long plength, LineData *LineInfo,		   PointFFixed *newp, FFixed *newinten, long *lengthout);intGouraudClipToLine(PointFFixed *p, FFixed *inten, long plength, LineData *LineInfo,		   PointFFixed *newp, FFixed *newinten, long *lengthout){	int inpt, outpt;int NumOfCrossings = 0;int AnchorInOutOn, InOutOn;int PreviousInOutOn;int i,j;FFixed AnchorLineTestResult, LineTestResult, PreviousLineTestResult;		inpt = outpt = 0;	AnchorInOutOn = InOutOn = WinInside(p[0], LineInfo, &LineTestResult);	AnchorLineTestResult = LineTestResult;	if(InOutOn == OUTSIDE)	{		do		{			PreviousLineTestResult = LineTestResult;			inpt++;		} while((inpt < plength) &&			   ((InOutOn = WinInside(p[inpt], LineInfo, &LineTestResult)) == OUTSIDE));		if(inpt == plength)		{			return(REJECT);		}		if(InOutOn != EXACTLY_ON)		{			if(GouraudCalcIntersection(LineInfo, &(p[inpt-1]), PreviousLineTestResult,							    &(p[inpt]), LineTestResult,								&(inten[inpt-1]), &(inten[inpt]),								&(newp[outpt]), &(newinten[outpt])))			{				outpt++;			}		}		NumOfCrossings++;	}		while(inpt < plength)	{		do		{			PreviousLineTestResult = LineTestResult;			newp[outpt] = p[inpt];			newinten[outpt] = inten[inpt];			inpt++;			outpt++;			PreviousInOutOn = InOutOn;		} while((inpt < plength) &&			   ((InOutOn = WinInside(p[inpt], LineInfo, &LineTestResult)) != OUTSIDE));		if(inpt < plength)		{			if(PreviousInOutOn != EXACTLY_ON)			{				if(GouraudCalcIntersection(LineInfo, &(p[inpt]), LineTestResult,								    &(p[inpt-1]), PreviousLineTestResult,									&(inten[inpt]), &(inten[inpt-1]),									&(newp[outpt]), &(newinten[outpt])))				{					outpt++;				}			}			NumOfCrossings++;			do			{				PreviousLineTestResult = LineTestResult;				inpt++;			} while((inpt < plength) &&				   ((InOutOn = WinInside(p[inpt], LineInfo, &LineTestResult)) == OUTSIDE));			if(inpt < plength)			{				if(InOutOn != EXACTLY_ON)				{					if(GouraudCalcIntersection(LineInfo, &(p[inpt-1]), PreviousLineTestResult,									    &(p[inpt]), LineTestResult,										&(inten[inpt-1]), &(inten[inpt]),										&(newp[outpt]), &(newinten[outpt])))					{						outpt++;					}				}				NumOfCrossings++;			}		}	}	if(NumOfCrossings > 0)	{		if((AnchorInOutOn == OUTSIDE) && (InOutOn == INSIDE))		{			if(GouraudCalcIntersection(LineInfo, &(p[0]), AnchorLineTestResult,								&(p[plength-1]), LineTestResult, 								&(inten[0]), &(inten[plength-1]),								&(newp[outpt]), &(newinten[outpt])))			{				outpt++;			}		}		else if((AnchorInOutOn == INSIDE) && (InOutOn == OUTSIDE))		{			if(GouraudCalcIntersection(LineInfo, &(p[plength-1]), LineTestResult,								&(p[0]), AnchorLineTestResult,								&(inten[plength-1]), &(inten[0]),								&(newp[outpt]), &(newinten[outpt])))			{				outpt++;			}		}		}	if(outpt < 3) return(REJECT);	*lengthout = outpt;	return(ACCEPT);}/*------------------------------------------------------------------------------------------*/intClip::GouraudClipToPoly(Point *polyin, long lengthin, PointFFixed **polyoutptr, long *lengthout,			FFixed *inten_in, FFixed **inten_outptr, short MinPixels){long index;LineData *LineInfos;PointFFixed *ClipShapePtr;long oldcliplength;PointFFixed *polyout1, *polyout2, *tempptr;long templong;FFixed *inten_out1, *inten_out2, *tempFFixedptr;PointFFixed *tempPointptr;		{		FFixed hmin, hmax, vmin, vmax;		long index;		FFixed tempfixed;		short hminshort, hmaxshort, vminshort, vmaxshort;				{			Point *ptemp = polyin;			short tempshort;					hminshort = hmaxshort = ptemp->h;			vminshort = vmaxshort = ptemp->v;			ptemp++;			index = lengthin-1;			while(index--)			{				tempshort = ptemp->h;				if(tempshort < hminshort) hminshort = tempshort;				else if(tempshort > hmaxshort) hmaxshort = tempshort;				tempshort = ptemp->v;				if(tempshort < vminshort) vminshort = tempshort;				else if(tempshort > vmaxshort) vmaxshort = tempshort;				ptemp++;			}		}		hmax.intg = hmaxshort; hmax.frac = 0;		hmin.intg = hminshort; hmin.frac = 0;		vmax.intg = vmaxshort; vmax.frac = 0;		vmin.intg = vminshort; vmin.frac = 0;		//we reject if bounding boxes don't intersect OR intersection is too small		//(too small = less than or equal to MinPixels high or wide)		tempfixed.frac = 0; tempfixed.intg = MinPixels;		if(hmax.l - BoundingBox.left.l <= tempfixed.l) return REJECT;		if(BoundingBox.right.l - hmin.l <= tempfixed.l) return REJECT;		if(vmax.l - BoundingBox.top.l <= tempfixed.l) return REJECT;		if(BoundingBox.bottom.l - vmin.l <= tempfixed.l) return REJECT;	}			//get temporary array to put result clip into	oldcliplength = ClipShape->ALength();	if(oldcliplength <= 2) return REJECT;	if((ClipPtsFFixed1->ALength() < lengthin+oldcliplength)  ||  // MERGE-BUG-DEC94		(ClipPtsGouraud1->ALength() < lengthin+oldcliplength)) 	// MERGE-BUG-DEC94    {    	ClipPtsFFixed1->Unuse();    	ClipPtsFFixed1->SetLength(lengthin+oldcliplength);    	polyout1 = (PointFFixed *)ClipPtsFFixed1->Use();    	    	ClipPtsFFixed2->Unuse();    	ClipPtsFFixed2->SetLength(lengthin+oldcliplength);    	polyout2 = (PointFFixed *)ClipPtsFFixed2->Use();    	    	ClipPtsGouraud1->Unuse();    	ClipPtsGouraud1->SetLength(lengthin+oldcliplength);    	inten_out1 = (FFixed *)ClipPtsGouraud1->Use();    	    	ClipPtsGouraud2->Unuse();    	ClipPtsGouraud2->SetLength(lengthin+oldcliplength);    	inten_out2 = (FFixed *)ClipPtsGouraud2->Use();    }    else    {    	polyout1 = (PointFFixed *)ClipPtsFFixed1->Abuse();    	polyout2 = (PointFFixed *)ClipPtsFFixed2->Abuse();    	inten_out1 = (FFixed *)ClipPtsGouraud1->Abuse();    	inten_out2 = (FFixed *)ClipPtsGouraud2->Abuse();    }	    	//copy in points onto out points and in intensities onto out intensities	{		PointFFixed *pFF = polyout1;		Point *pt = polyin;		FFixed *inten = inten_out1;		FFixed *in = inten_in;		long index;				index = lengthin;		while(index--)		{			pFF->h.frac = pFF->v.frac = 0;			pFF->h.intg = pt->h;			pFF->v.intg = pt->v;			pFF++;			pt++;			// GOURAUD DEBUG [[[			ASSERT(in->intg >= 0);			ASSERT(in->intg < 32);			// GOURAUD DEBUG ]]]						*inten = *in;			inten++;			in++;		}	}		LineInfos = (LineData *)LineEqtns->Abuse();	ClipShapePtr = (PointFFixed *)ClipShape->Abuse();	index = 0;	*lengthout = lengthin;	while(index < ClipShape->ALength())	{		if(LineInfos[index].a.l == 0)		{			GouraudCalcIntersection = GouraudCalcIntersectionWithHorizontalLine;			WinInside = WinInsideHorizontalLine;			HorizontalLineYValue = ClipShapePtr[index].v;		}		else if(LineInfos[index].b.l == 0)		{			GouraudCalcIntersection = GouraudCalcIntersectionWithVerticalLine;			WinInside = WinInsideVerticalLine;			VerticalLineXValue = ClipShapePtr[index].h;		}		else		{			GouraudCalcIntersection = GouraudStandardCalcIntersection;			WinInside = StandardWinInside;		}		templong = *lengthout;		if(			GouraudClipToLine(polyout1, inten_out1, templong, &(LineInfos[index]),					   polyout2, inten_out2, lengthout) == REJECT		  ) { return(REJECT); }		index++;		tempPointptr = polyout1;		polyout1 = polyout2;		polyout2 = tempPointptr;		tempFFixedptr = inten_out1;		inten_out1 = inten_out2;		inten_out2 = tempFFixedptr;	}		*polyoutptr = polyout1;	*inten_outptr = inten_out1;	return(ACCEPT);}// MERGE-GOURAUD ]]]