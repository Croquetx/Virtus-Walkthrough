/*------------------------------------------------------------------------------ * VWINDOWSt - the window object toolbox * * Copyright c 1991 by Virtus Corporation * All Rights Reserved * Written by David A. Smith * Virtus Corporation * 117 Edinburgh So * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * F4.c *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VGUtil.h"#include "VDisplay.h"#include "Clip.h"#include "Flash.h"#include "Gouraud.h"		// JAM MERGE-GOURAUD-PRO#include "DOS.h"		// DOS segment handlers		GJR 10/20/93						// Note: huge can't store across seg boundaries with single op#define SPANNEDHUGE(farptr, hifarptr) ((unsigned) FP_OFF(farptr) > (unsigned) FP_OFF(hifarptr))#if FLASHUSEASMextern int FlashUseAsm = TRUE;		// enable asm code						// Borland:	Must have Project LocalOption compile switch "-B" on.						// Borland: must do a DOS "TASM <filename.asm>" to get obj.#if BORLANDC>=0x452		// earlier borlands hate inline...#pragma inline    // Borlandc 4.0 likes this.  your milage may vary.#endif#endif/*------------------------------------------------------------------------------ * Define the function names *------------------------------------------------------------------------------ */#define FLine FLine4#define FLineClip FLineClip4#define FlashFill FlashFill4#define FlashClip FlashClip4#define FFixedFLine FFixedFLine4#define FlashGouraud 		FlashGouraud4			// MERGE-GOURAUD#define FlashGouraudClip 	FlashGouraudClip4		// MERGE-GOURAUD/*------------------------------------------------------------------------------ * Define the two major data types. *------------------------------------------------------------------------------ */typedef unsigned long VColorType[2];typedef unsigned char GColorType;		// MERGE-GOURAUDtypedef struct 	PixType{LPLONG pixel;						int pos;                        int y;						LPLONG rowBase;						int offset;	// offset to next plane                        BYTE lineDither;  // dither counter for lines						} PixType;/*------------------------------------------------------------------------------ * AutoInit your static data areas here. *------------------------------------------------------------------------------ */// PIXBIT selects a scan-line ordered pixel bits, input is 0..7#define PIXBIT(x) (0x0fL<<(((x)^1)*4))static LONG pixbit[] =						{PIXBIT(0) ,PIXBIT(1) ,PIXBIT(2) ,PIXBIT(3),						 PIXBIT(4) ,PIXBIT(5) ,PIXBIT(6) ,PIXBIT(7) };// Setting bit masks, LMASK keeps logical (wrto scan) left bits.//		RMASK keeps logical (wrto scan) right bits.//		Input is scanline pixel position, 0..7;//		Output is either left keep or right keep bit mask.//		Left says where the starting NEW pixel is,//			so Left==0 says replace from the beginning,//			   Left==1 says pixel 0 is left alone, but replace pixel 1+//		Right says where to STOP, and KEEP OLD.(points one past last new store)//			so Right==0 says don't store into this longword at all//			   Right==1 says store into pixel 0, but leave 1+ alone.// For intel (little endian), this means progress 1's from lo byte to hi//     intel also wants hi bit to low within a byte//// Just show the masks. Be Careful				//GJR 10/20/93// There is NO 'LM0'. the first loc says no mask, so is zero//  for BOTH left mask and right mask. This avoids some extra edge testing in the code#define LM1 0x000000F0L#define LM2 0x000000FFL#define LM3 0x0000F0FFL#define LM4 0x0000FFFFL#define LM5 0x00F0FFFFL#define LM6 0x00FFFFFFL#define LM7 0xF0FFFFFFLstatic unsigned long lMask[]=						{0 ,						 LM1 ,LM2 ,LM3 ,LM4,						 LM5 ,LM6 ,LM7     };static unsigned long rMask[]=						{0 ,						 ~LM1 ,~LM2 ,~LM3 ,~LM4,						 ~LM5 ,~LM6 ,~LM7      };/*------------------------------------------------------------------------------ * Define the macro pixel routines. * For additional information about this code, see the Flash.c sources. *------------------------------------------------------------------------------ */// rightmost bit per color is in first plane (lsb order)#define InitColorPen(color,rgb) {unsigned long lcol;  \			  unsigned long lcol0=offscreen->GetDither(rgb); \			  lcol = lcol0 & 0x0F0F0000; lcol |= lcol<<4; lcol |= lcol>>16; \			  color[0]=lcol;  \              lcol = lcol0 & 0xF0F00000; lcol |= lcol>>4; lcol |= lcol>>16; \              color[1]=lcol;  \			  }#define InitColorBrush(color,rgb) {unsigned long lcol=dither?offscreen->GetDither(rgb):offscreen->GetNoDither(rgb); \			  color[0]=lcol&0xFFFF0000; color[0] |= lcol>>16; \			  color[1]=lcol&0x0000FFFF; color[1] |= lcol<<16; \			  }// MERGE-GOURAUD [[[// this macro inits the color index based on the rgb -- index will range from 0..255// at most, and will be less for bit depths 1/2/4.  The index is an index into the standard color// table; index is an unsigned char, rgb is an RGBColor#define InitColorIndex(index,rgb) { index = rgb; }// MERGE-GOURAUD ]]]#define InitPixel(pix,xval,yval,to) {  \	pix.y = yval+to->yOffset; \    pix.rowBase = (LPLONG)glpbBmRowAddresses[pix.y];  \	pix.pixel= (LPLONG)((pix.rowBase)+ ((xval+to->xOffset)>>3) );  \	pix.offset = gwBmWidthBytes; \	pix.pos=((xval+to->xOffset)&0x07);  \	pix.lineDither = 0;  \	}#if USE_HMD#pragma option -Od#define InitPixelHMDL(pix,xval,yval,to) {\	pix.y = yval<<1; \	pix.y += to->yOffset; \	if(gHMDOffsetLeft) pix.y += 1; \	pix.rowBase = (LPLONG)glpbBmRowAddresses[pix.y];  \	pix.pixel= (LPLONG)((pix.rowBase)+ ((xval+to->xOffset)>>3) );  \	pix.offset = gwBmWidthBytes; \	pix.pos=((xval+to->xOffset)&0x07);  \	pix.lineDither = 0;  \	}#define InitPixelHMDR(pix,xval,yval,to) {\	pix.y = yval<<1; \	pix.y += to->yOffset; \	if(gHMDOffsetRight) pix.y += 1; \	pix.rowBase = (LPLONG)glpbBmRowAddresses[pix.y];  \	pix.pixel= (LPLONG)((pix.rowBase)+ ((xval+to->xOffset)>>3) );  \	pix.offset = gwBmWidthBytes; \	pix.pos=((xval+to->xOffset)&0x07);  \	pix.lineDither = 0;  \	}#define AddLinePixelHMD(pix,to) { int xOffset; \	xOffset = (LPBYTE)pix.pixel - (LPBYTE)pix.rowBase;  \	pix.y+=2; \	pix.rowBase = (LPLONG)glpbBmRowAddresses[pix.y];  \	pix.pixel= (LPLONG)((LPBYTE)(pix.rowBase)+ (xOffset) );  \	}#endif // USE_HMD#define DecPixel(pix)  {if(!pix.pos)pix.pixel--; pix.pos=(pix.pos-1)&0x07;}#define IncPixel(pix)  {pix.pos+=1; pix.pos&=0x07;if(!pix.pos)pix.pixel++; }#define AddPixel(pix,length) {pix.pos+=length;pix.pixel+=pix.pos>>3;	\								pix.pos&=0x07;}#define AddLinePixel(pix,to) { int xOffset; \	xOffset = (LPBYTE)pix.pixel - (LPBYTE)pix.rowBase;  \	pix.y++; \	pix.rowBase = (LPLONG)glpbBmRowAddresses[pix.y];  \	pix.pixel= (LPLONG)((LPBYTE)(pix.rowBase)+ (xOffset) );  \	}#define SetPixel(pix,color) {LPLONG lpl=pix.pixel;	\	if (SPANNEDHUGE(pix.rowBase, lpl))	\		{ char huge* hugelpl  = (char *)pix.rowBase;	\				 hugelpl += FP_OFF(lpl) - FP_OFF(pix.rowBase); \				 lpl      = (LPLONG)hugelpl;	\	    }	\	*lpl=((*lpl^color[pix.lineDither])&~pixbit[pix.pos])^color[pix.lineDither]; \	pix.lineDither ^= 0x01;  \	}#define DecSetPixel(pix,color) do{SetPixel(pix,color);DecPixel(pix);}while(0)#define IncSetPixel(pix,color) do{SetPixel(pix,color);IncPixel(pix);}while(0)// MERGE-GOURAUD [[[#define SetPixel2(pix,color) {LPLONG lpl=pix.pixel;								\	unsigned long copiedcolor; \	copiedcolor = color; \	copiedcolor |= (copiedcolor << 4); \	copiedcolor |= (copiedcolor << 8); \    copiedcolor |= (copiedcolor << 16); \	if (SPANNEDHUGE(pix.rowBase, lpl))	\		{ char huge* hugelpl  = (char *)pix.rowBase;	\				 hugelpl += FP_OFF(lpl) - FP_OFF(pix.rowBase); \				 lpl      = (LPLONG)hugelpl;	\	    }	\	*lpl=((*lpl^copiedcolor)&~pixbit[pix.pos])^copiedcolor; \	pix.lineDither ^= 0x01;  \	}#define IncSetPixel2(pix,color) do{SetPixel2(pix,color);IncPixel(pix);}while(0)#define PixVal(pix) (((long)pix.pixel << 1) | pix.pos)#define GetGouraudDither(dith_abcd, shade, color)	(gTextureShader[shade].dith[2][dith_abcd][color])// MERGE-GOURAUD ]]]/*------------------------------------------------------------------------------ * ScanFillPatternXxx(). *------------------------------------------------------------------------------ */#define ScanFillPattern ScanFillPattern4void ScanFillPattern4(PixType pixel,int evenodd,int dx,VColorType color);								void ScanFillPattern4(PixType pixel,int evenodd,int dx,VColorType color) {int ml,mr;LPLONG pl;//LPLONG pr;LPLONG plbase;long lNumLongs;     // actually the number of longword CROSSINGSlong col=color[evenodd&1];unsigned long mask=0xF0F0F0F0;if (evenodd&1) mask = ~mask; // complement to select opposite pixelsplbase=pixel.pixel;pl=plbase;if (SPANNEDHUGE(pixel.rowBase, pl))  // Segment Adjust	//GJR 10/20/93	{ char huge* hugepl  = (char huge*)pixel.rowBase;				 hugepl += FP_OFF(pl) - FP_OFF(pixel.rowBase);				 pl      = (LPLONG)hugepl;    }ml=(pixel.pos);  // offset for leftmost bitspixel.pos  += dx;lNumLongs   = pixel.pos>>3;pixel.pixel+= lNumLongs;pixel.pos  &=0x07;mr=(pixel.pos);  // offset for one past rightmost bits// Coding note:// ((old ^ new) &KeepOldBits) ^ new// uses (a^b^b==a) property to keep old wherever KeepOldBits is set.// old bits are replaced by new bits only where KeepOldBits is clear/off.if (lNumLongs == 0) // same 32 bits	{		*pl =(((*pl^col)&(lMask[ml]|rMask[mr]|mask))^col);	}else 	{    // Do prefix if not a full longword	if(ml)		{		*pl++=(((*pl^col)&(lMask[ml]             |mask))^col);		if (FP_OFF(pl) == 0)  // Segment Adjust	//GJR 10/20/93			{ char huge* hugepl  = (char huge*)pixel.rowBase;			hugepl += FP_OFF(pl) - FP_OFF(pixel.rowBase);			pl      = (LPLONG)hugepl;			}        lNumLongs--;		}    // Now do longwords	if (SPANNEDHUGE(pl, pl + lNumLongs))		{		long huge *hugepl = pl;		for (;lNumLongs > 0; lNumLongs--)			{			*hugepl++=(((*hugepl^col)&(                       mask))^col);			}        pl = hugepl;	// keep left pointer at next longword location		}	else		{		for (;lNumLongs > 0; lNumLongs--)		  *pl++=(((*pl^col)&(                       mask))^col);		}    // Finish with suffix, if any	if(mr)*pl  =(((*pl^col)&(             rMask[mr]|mask))^col);	}}														/*------------------------------------------------------------------------------ * ScanFillxxx. *------------------------------------------------------------------------------ */#define ScanFill ScanFill4void ScanFill4(PixType pixel,int evenodd,int dx,VColorType color);										void ScanFill4(PixType pixel,int evenodd,int dx,VColorType color)											{int ml,mr;				LPLONG pl;LPLONG plbase;long lNumLongs;long col=color[evenodd&1];plbase=pixel.pixel;pl=plbase;if (SPANNEDHUGE(pixel.rowBase, pl))  // Segment Adjust	//GJR 10/20/93	{ char huge* hugepl  = (char huge*)pixel.rowBase;				 hugepl += FP_OFF(pl) - FP_OFF(pixel.rowBase);				 pl      = (LPLONG)hugepl;    }ml=((long)pixel.pos);pixel.pos  += dx;lNumLongs   = pixel.pos>>3;pixel.pixel+= lNumLongs;pixel.pos  &= 0x07;mr=((long)pixel.pos);if (lNumLongs == 0)  // if we are not crossing any 32 bit boundaries (i.e. only one long needed)	{		*pl =(((*pl^col)&(lMask[ml]|rMask[mr]))^col);	}else 	{    ASSERT(lNumLongs > 0);	if(ml)		{		*pl++=(((*pl^col)&(lMask[ml]             ))^col);		if (FP_OFF(pl) == 0)  // Segment Adjust	//GJR 10/20/93			{ char huge* hugepl  = (char huge*)pixel.rowBase;						 hugepl += FP_OFF(pl) - FP_OFF(pixel.rowBase);						 pl      = (LPLONG)hugepl;    		}		lNumLongs -= 1;  // account for doing one already        if (lNumLongs == 0) goto DoneStoringLongs;		}	ASSERT(lNumLongs > 0);#if FLASHUSEASM	if ( FlashUseAsm	  && !SPANNEDHUGE(pl, pl + lNumLongs))		{		WORD plSegment;        LONG plOffset;		plSegment = SELECTOROF(pl);		plOffset = OFFSETOF(pl);		ASM { 						// Borland:	Must have Project LocalOption compile switch "-B" on.						// Borland: must do a DOS "TASM <filename.asm>" to get obj.			pushfd				/* MS wants DF saved *///			push eax			push ecx			push edi		    /* yuch */        	mov eax, col			mov ecx, lNumLongs	/* num of 32bits to move */			mov es,plSegment            mov edi,plOffset			cld					/* set direction to forwards */			rep  stosd			/* store doubles(32 bits) at a time */            mov pl,di			/* keep pl pointing to the next longword */			pop edi			pop ecx//			pop eax            popfd			}		}	else#endif		{		long huge *hugepl = pl;		for (; lNumLongs > 0; lNumLongs--)			{			*hugepl++=col;			}        pl = hugepl;		// keep pl pointing to next long to store into		}DoneStoringLongs:					// done with prefix and longs. Do suffix, if any	if(mr)*pl  =(((*pl^col)&(             rMask[mr]))^col);	}}// MERGE-GOURAUD [[[/*------------------------------------------------------------------------------ * GouraudFillxxxx *------------------------------------------------------------------------------ */// GOURAUD -- we have to pattern fill dx pixels, going from intensity il to intensity ir#define DefaultGouraudFillPattern DefaultGouraudFillPattern4#define DefaultGouraudFill DefaultGouraudFill4#define GouraudFillPattern DefaultGouraudFillPattern4#define GouraudFill DefaultGouraudFill4// MERGE-GOURAUD ]]]					#include "FlashZ.h"