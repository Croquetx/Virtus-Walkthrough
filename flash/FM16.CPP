/*------------------------------------------------------------------------------ * VWINDOWSt - the window object toolbox * * Copyright c 1991 by Virtus Corporation * All Rights Reserved * Written by David A. Smith * Virtus Corporation * 117 Edinburgh So * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * F16.c *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VMath.h"#include "VToolBox.h"#include "VDisplay.h"#include "VGUtil.h"#include "Clip.h"#include "Flash.h"#include "TextSrvr.h"		// MERGE-GOURAUD#include "Gouraud.h"		// MERGE-GOURAUD/*------------------------------------------------------------------------------ * Define the function names *------------------------------------------------------------------------------ */#define FLine FLine16#define FLineClip FLineClip16#define FlashFill FlashFill16#define FlashClip FlashClip16#define FFixedFLine FFixedFLine16#define FlashGouraud 		FlashGouraud16			// MERGE-GOURAUD#define FlashGouraudClip 	FlashGouraudClip16		// MERGE-GOURAUD/*------------------------------------------------------------------------------ * Define the two major data types. *------------------------------------------------------------------------------ */// 32bit stores 4 bytes per pixel.// THIS FORMAT IS DIFFERENT FROM ALL OTHER SUB-32 FORMS.// SO TOTALLY DIFFERENT CODE IS USED.typedef ULong VColorType[1];typedef unsigned short GColorType;		// MERGE-GOURAUD#define PixType	unsigned short *	#define LMASK(x) (0xFFFFFFFF+(1L<<((1-x)*16))) // turn off following, himem, MSB bits#define RMASK(x) (~LMASK((x))) // opposite of LMASK, kill prior lomem LSB bitsstatic ULong lMask[]=						{LMASK(0) ,LMASK(1)};static ULong rMask[]=						{RMASK(0) ,RMASK(1)};/*------------------------------------------------------------------------------ * AutoInit your static data areas here. *------------------------------------------------------------------------------ */#define PIXBIT(x) (0x0ffffL<<(((1-x)*16)))static LONG pixbit[] = {PIXBIT(0) ,PIXBIT(1)};/*------------------------------------------------------------------------------ * Define the macro pixel routines. * For additional information about this code, see the Flash.c sources. *------------------------------------------------------------------------------ */// rightmost bit per color is in first plane (lsb order)#define InitColorPen(color,rgb) { color[0] = offscreen->GetDither(rgb); }#define InitColorBrush(color,rgb) {InitColorPen(color,rgb);}// MERGE-GOURAUD [[[// this macro inits the color index based on the rgb -- index will range from 0..255// at most, and will be less for bit depths 1/2/4.  The index is an index into the standard color// table; index is an unsigned char, rgb is an RGBColor#define InitColorIndex(index,rgb) { index = rgb; }// MERGE-GOURAUD ]]]/*void InitPixel(PixType pix, int xval, int yval, V_Offscreen *to);void InitPixel(PixType pix, int xval, int yval, V_Offscreen *to){    pix = (unsigned short *)to->baseAddress;     pix += ((LONG)(glpbBmRowAddresses[yval+to->yOffset]) );    pix += (xval+to->xOffset);}*/#define InitPixel(pix,xval,yval,to) {pix = (unsigned short*)to->baseAddress; \pix += (xval-to->xOffset); \pix += (yval-to->yOffset)*((long)to->rowBytes>>1);}//#define InitPixel(pix,xval,yval,to)   { pix = (unsigned short *)to->baseAddress; \//    pix += ((LONG)(glpbBmRowAddresses[yval+to->yOffset])>>1);\//    pix += (xval+to->xOffset);}// MERGE-HMD [[[#if USE_HMD#define InitPixelHMDL(pix,xval,yval,to) {pix = (unsigned short*)to->baseAddress; \pix += (xval-to->xOffset); \pix += (yval-to->yOffset)*((long)to->rowBytes); \if (gHMDOffsetLeft) pix += ((long)(to->rowBytes>>1));	}#define InitPixelHMDR(pix,xval,yval,to) {pix = (unsigned short*)to->baseAddress; \pix += (xval-to->xOffset); \pix += (yval-to->yOffset)*((long)to->rowBytes); \if (gHMDOffsetRight) pix += ((long)(to->rowBytes>>1));	}#define AddLinePixelHMD(pix,to) pix += (long)to->rowBytes#endif // USE_HMD// MERGE-HMD ]]]#define DecPixel(pix)  pix--#define IncPixel(pix)  pix++#define AddPixel(pix,length) pix+=length#define AddLinePixel(pix,to) pix += to->rowBytes>>1#define SetPixel(pix,color) *pix=(unsigned short)color[0]#define DecSetPixel(pix,color) *pix--=(unsigned short)color[0]#define IncSetPixel(pix,color) *pix++=(unsigned short)color[0]//#define DecSetPixel(pix,color) do{SetPixel(pix,color);DecPixel(pix);}while(0)//#define IncSetPixel(pix,color) do{SetPixel(pix,color);IncPixel(pix);}while(0)// MERGE-GOURAUD [[[#define IncSetPixel2(pix,color) *pix++=(unsigned short)color#define SetPixel2(pix,color) *pix=(unsigned short)color	#define PixVal(pix) ((unsigned long)pix)		// PRO-13#define GetGouraudDither(dith_abcd, shade, color)	(gTextureShader[shade].color16bit[color])// MERGE-GOURAUD ]]]/*------------------------------------------------------------------------------ * ScanFillPatternXxx(). *------------------------------------------------------------------------------ */#define ScanFillPattern ScanFillPattern16void ScanFillPattern16(PixType pixel,int evenodd,int dx,VColorType color);								void ScanFillPattern16(PixType pixel,int evenodd,int dx,VColorType color) {											short col=color[0];unsigned short * pl;pl = (unsigned short *)pixel;			if((evenodd & 1)^(((long)pl>>1) & 1))	{ // jitter our starting location	pl +=1;	dx--;	}while(dx>0)	{	*pl = col;    pl += 2;  // skip every other pixel	dx -= 2;  // count the pairs of pixels	}}																			/*------------------------------------------------------------------------------ * ScanFillxxx. *------------------------------------------------------------------------------ */#define ScanFill ScanFill16			void ScanFill16(PixType pixel,int evenodd,int dx,VColorType color);										void ScanFill16(PixType pixel,int evenodd,int dx,VColorType color)											{			unsigned short* pl;WORD col;pl = pixel;col = color[0];while(dx-- >0)	*pl++ = col;#if 0int ml,mr;				ULong *pl,*pr;ULong col=color[evenodd];pl=(ULong *)(((long)pixel)&0xFFFFFFFE);ml=((long)pixel)&0x01;pixel+=dx;pr=(ULong *)(((long)pixel)&0xFFFFFFFE);mr=((long)pixel)&0x01;		if(pl==pr)/*same 32 bits*/	{	if(ml)		{		if(mr)*pl=(*pl&(rMask[ml]|lMask[mr]))|(lMask[ml]&rMask[mr]&col);		else *pl=(*pl&rMask[ml])|(lMask[ml]&col);		}	else if(mr)*pl=(*pl&lMask[mr])|(rMask[mr]&col);	}else 	{// the powerpc section does exactly the same thing except that the compiler does// not handle the post-increment correctly. - BILBIL - 12/8/93#if __PPCC__	if(ml)		{		*pl=(*pl&rMask[ml])|(lMask[ml]&col);		*pl++;		}#else	if(ml)*pl++=(*pl&rMask[ml])|(lMask[ml]&col);#endif //__PPCC__	while(pl!=pr)*pl++=col;	if(mr)*pl=(*pl&lMask[mr])|(rMask[mr]&col);	}#endif}				// MERGE-GOURAUD [[[/*------------------------------------------------------------------------------ * GouraudFillxxxx *------------------------------------------------------------------------------ */// GOURAUD -- we have to pattern fill dx pixels, going from intensity il to intensity ir#define DefaultGouraudFillPattern DefaultGouraudFillPattern16#define DefaultGouraudFill DefaultGouraudFill16#define GouraudFillPattern GouraudFillPattern16A#define GouraudFill GouraudFill16A/*------------------------------------------------------------------------------------------*//**/void GouraudFill16(PixType pixel, int evenodd, int dx, int actual_dx, int left_unused,	FFixed il, FFixed ir, GColorType *dith_a, GColorType *dith_b, unsigned short *jitter,	long *jitter_diffs);										void GouraudFill16(PixType pixel, int evenodd, int dx, int actual_dx, int left_unused,	FFixed il, FFixed ir, GColorType *dith_a, GColorType *dith_b, unsigned short *jitter,	long *jitter_diffs)								{		register long increment, i; FFixed fdx, diff;	// determine the fraction of intensity and pixels -- how much do I bump the intensity	// per pixel?		fdx.intg = actual_dx;	fdx.frac = 0;	diff.l = ir.l - il.l;	increment = FFDiv(diff, fdx).l;		i = il.l;	while (left_unused--)		i += increment;	while (dx--)	{		IncSetPixel2(pixel, dith_a[i >> 16]);		i += increment;	} }							/*------------------------------------------------------------------------------------------*//**/void GouraudFill16A(PixType pixel, long evenodd, long dx, long actual_dx, long left_unused,		// MERGE-GOURAUD-PRO-10	FFixed il, FFixed ir, GColorType *dith_a, GColorType *dith_b, unsigned short *jitter,	long *jitter_diffs);										void GouraudFill16A(PixType pixel, long evenodd, long dx, long actual_dx, long left_unused,		// MERGE-GOURAUD-PRO-10	FFixed il, FFixed ir, GColorType *dith_a, GColorType *dith_b, unsigned short *jitter,	long *jitter_diffs)								{		FFixed fdx, diff;register long increment, big_increment, i;	// pretend these are FFixedlong adx;		// MERGE-GOURAUD-PRO-10	// determine the fraction of intensity and pixels -- how much to bump the intensity	// per pixel		fdx.intg = actual_dx;	fdx.frac = 0;	diff.l = ir.l - il.l;	increment = FFDiv(diff, fdx).l;		// get the initial intensity	i = il.l;			// do the part that is clipped out on the left -- just increment the number of times	// (left_unused is the number of pixels on the left that are clipped out)	// (also note that pixel has been inited to the value that we are actually supposed to	// start drawing at, so we don't increment pixel here)	while (left_unused--)		i += increment;	// compute how many pairs of pixels to do	adx = (dx >> 1);		// subtract the number of pairs from dx	dx -= (adx << 1);	// loop through the pairs -- note that since we know we are on a even word boundary,	// we can hard-code the dith_a and dith_b values	while (adx--)	{	register long jitt;		jitt = jitter[(PixVal(pixel) >> 1) & 0xF]; jitt += i;		// PRO-13		IncSetPixel2(pixel, dith_a[jitt >> 16]);		i += increment;				jitt = jitter[(PixVal(pixel) >> 1) & 0xF]; jitt += i;		// PRO-13		IncSetPixel2(pixel, dith_a[jitt >> 16]);		i += increment;	}		// do the last pixel -- at this point dx will be 0 or 1	if (dx)	{	register long jitt;		jitt = jitter[(PixVal(pixel) >> 1) & 0xF]; jitt += i;		// PRO-13		SetPixel2(pixel, dith_a[jitt >> 16]);		// note no need to do IncSet		// note no need to increment i	}}							// MERGE-GOURAUD ]]]/*------------------------------------------------------------------------------------------*//**/void GouraudFillPattern16A(PixType pixel, long evenodd, long dx, long actual_dx, long left_unused,		// MERGE-GOURAUD-PRO-6	FFixed il, FFixed ir, GColorType *dith_a, GColorType *dith_b, unsigned short *jitter);										void GouraudFillPattern16A(PixType pixel, long evenodd, long dx, long actual_dx, long left_unused,		// MERGE-GOURAUD-PRO-6	FFixed il, FFixed ir, GColorType *dith_a, GColorType *dith_b, unsigned short *jitter)								{		register FFixed increment, double_increment, i, fdx, diff;int extra_pixel = FALSE;	// determine the fraction of intensity and pixels -- how much to bump the intensity	// per pixel -- note that we use the actual dx, which is the number of pixels across	// the whole scan line (i.e. it doesn't include clipping) so that our dx is correct		fdx.intg = actual_dx;	fdx.frac = 0;	diff.l = ir.l - il.l;	increment = FFDiv(diff, fdx);	// do initial increment to make our screen pattern -- do the initial skip-a-pixel	// if we need to.	if(((PixVal(pixel) >> 2) & 1) ^ (evenodd & 1))	{		// skip a pixel		IncPixel(pixel);				// make this pixel part of the left unused so we get the right intensity		// for the pixels we actually draw.  Remember that pixel has been inited		// based on the place we are supposed to start drawing from, so we must		// decrement dx.		left_unused++;		dx--;	}		// get the initial intensity	i = il;			// do the part that is clipped out on the left -- just increment the number of times	// (left_unused is the number of pixels on the left that are clipped out)	// (also note that pixel has been inited to the value that we are actually supposed to	// start drawing at, so we don't increment pixel here)	while (left_unused--)		i.l += increment.l;			// compute a double increment so we only have to do 1 add per pixel for the next	// intensity value	double_increment.l = (increment.l << 1);		// if dx is odd, then the following loop will not draw the last pixel in the scan	// line.  	if (dx & 1)	{		extra_pixel = TRUE;		dx--;	}			// now do the drawing -- dx is the number of pixels to actually draw	// This loop draw a pixel and then skips a pixel repeatedly.	while (dx > 0)	{	FFixed jitt;	register short jittintgpart;			// add in the jitter value		jitt.intg = 0;		jitt.frac = jitter[PixVal(pixel) & 0xF];		jitt.l += i.l;			// write the pixel		if (PixVal(pixel) & 1)			{			jittintgpart = jitt.intg;			IncSetPixel2(pixel, dith_a[jittintgpart]);            }		else			{			jittintgpart = jitt.intg;			IncSetPixel2(pixel, dith_b[jittintgpart]);            }				// skip a pixel (dither pattern fill)		IncPixel(pixel);		// increment the intensity for two pixels		i.l += double_increment.l;				// decrement dx; by 2 since we are doing a dither fill		dx -= 2;	} 			if (extra_pixel)	{	FFixed jitt;			// add in the jitter value		jitt.intg = 0;		jitt.frac = jitter[PixVal(pixel) & 0xF];		jitt.l += i.l;			// write the extra pixel -- no need to increment because this is the last pixel		if (PixVal(pixel) & 1)        	{			SetPixel2(pixel, dith_a[jitt.intg]);            }		else        	{			SetPixel2(pixel, dith_b[jitt.intg]);            }	}}							#define USE_JITTER_VALS_NO_DITHER 1			// MERGE-GOURAUD#include "FlashZ.h"#undef USE_JITTER_VALS_NO_DITHER			// MERGE-GOURAUD