/*------------------------------------------------------------------------------ * VWINDOWSt - the window object toolbox * * Copyright c 1991 by Virtus Corporation * All Rights Reserved * Written by David A. Smith * Virtus Corporation * 117 Edinburgh So * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Fw24.c *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VGUtil.h"#include "VDisplay.h"#include "Clip.h"#include "Flash.h"#include "Gouraud.h"			// MERGE-GOURAUD#include "DOS.h"		// DOS segment handlers		GJR092093						// Note: huge can't store across seg boundaries with single op#define SPANNEDHUGE(farptr, hifarptr) ((unsigned) FP_OFF(farptr) > (unsigned) FP_OFF(hifarptr))#if FLASHUSEASM						// Borland:	Must have Project LocalOption compile switch "-B" on.						// Borland: must do a DOS "TASM <filename.asm>" to get obj.#if BORLANDC>=0x452		// earlier borlands hate inline...#pragma inline    // Borlandc 4.0 likes this.  your milage may vary.#endif#endif/*------------------------------------------------------------------------------ * Define the function names *------------------------------------------------------------------------------ */#define FLine FLine24#define FLineClip FLineClip24#define FlashFill FlashFill24#define FlashClip FlashClip24#define FFixedFLine FFixedFLine24#define FlashGouraud 		FlashGouraud24	// MERGE-GOURAUD#define FlashGouraudClip 	FlashGouraudClip24	// MERGE-GOURAUD/*------------------------------------------------------------------------------ * Define the two major data types. *------------------------------------------------------------------------------ */// 24bit stores 3 bytes per pixel.// THIS FORMAT IS DIFFERENT FROM ALL OTHER SUB-32 FORMS.// SO TOTALLY DIFFERENT CODE IS USED.typedef unsigned char VColorType[4];		// must be a longword equivalenttypedef ULong GColorType;		// MERGE-GOURAUDtypedef struct 	PixType{LPBYTE pixel;						int y;						LPBYTE rowBase;                        int offset;	// offset to next plane						} PixType;/*------------------------------------------------------------------------------ * AutoInit your static data areas here. *------------------------------------------------------------------------------ *//*------------------------------------------------------------------------------ * Define the macro pixel routines. * For additional information about this code, see the Flash.c sources. *------------------------------------------------------------------------------ */// rightmost bit per color is in first plane (lsb order)#define InitColorPen(color,rgb) {unsigned long lcol; \			  lcol = offscreen->GetDither(rgb); \			  ((LONG *)color)[0] = lcol;  \			  }#define InitColorBrush(color,rgb) {InitColorPen(color,rgb);  \			  }// MERGE-GOURAUD [[[// this macro inits the color index based on the rgb -- index will range from 0..255// at most, and will be less for bit depths 1/2/4.  The index is an index into the standard color// table; index is an unsigned char, rgb is an RGBColor#define InitColorIndex(index,rgb) { index = rgb; }// MERGE-GOURAUD ]]]#define InitPixel(pix,xval,yval,to) {  \	pix.y = yval+to->yOffset; \    pix.rowBase = glpbBmRowAddresses[pix.y];  \	pix.pixel= ((pix.rowBase)+ ((xval+to->xOffset)*3) );  \	pix.offset = gwBmWidthBytes; }#if USE_HMD#pragma option -Od#define InitPixelHMDL(pix,xval,yval,to) {  \	pix.y = yval << 1;\	pix.y += to->yOffset; \    if(gHMDOffsetLeft) pix.y += 1; \	pix.rowBase = glpbBmRowAddresses[pix.y];  \	pix.pixel= ((pix.rowBase)+ ((xval+to->xOffset)*3) );  \	pix.offset = gwBmWidthBytes; }#define InitPixelHMDR(pix,xval,yval,to) {  \	pix.y = yval << 1;\	pix.y += to->yOffset; \	if(gHMDOffsetRight) pix.y += 1; \	pix.rowBase = glpbBmRowAddresses[pix.y];  \	pix.pixel= ((pix.rowBase)+ ((xval+to->xOffset)*3) );  \	pix.offset = gwBmWidthBytes; }#define AddLinePixelHMD(pix,to) { int xOffset; \	xOffset = pix.pixel - pix.rowBase;  \	pix.y+=2; \	pix.rowBase = glpbBmRowAddresses[pix.y];  \	pix.pixel= ((pix.rowBase)+ (xOffset) );  \	}#endif // USE_HMD#define DecPixel(pix)  {pix.pixel-= 3; }#define IncPixel(pix)  {pix.pixel+= 3; }#define AddPixel(pix,length) {pix.pixel+=length*3;}#define AddLinePixel(pix,to) { int xOffset; \	xOffset = pix.pixel - pix.rowBase;  \	pix.y++; \	pix.rowBase = glpbBmRowAddresses[pix.y];  \	pix.pixel= ((pix.rowBase)+ (xOffset) );  \	}#define SetPixel(pix,color) {LPBYTE lpl=pix.pixel;	\	if (SPANNEDHUGE(pix.rowBase, lpl + 2))	\	{ char huge* hugelpl  = pix.rowBase;	\				 hugelpl += FP_OFF(lpl) - FP_OFF(pixel.rowBase); \		*hugelpl++=color[0]; 	\		*hugelpl++=color[1]; 	\		*hugelpl++=color[2]; 	\		} \	else  \    	{ \		*lpl++=color[0]; \		*lpl++=color[1]; \		*lpl++=color[2]; \        }  \	}#define DecSetPixel(pix,color) do{SetPixel(pix,color);DecPixel(pix);}while(0)#define IncSetPixel(pix,color) do{SetPixel(pix,color);IncPixel(pix);}while(0)// MERGE-GOURAUD [[[#define SetPixel2(pix,color) {char *colorptr = (char*)(&color); SetPixel(pix,colorptr) }#define IncSetPixel2(pix,color) do{SetPixel2(pix,color);IncPixel(pix);}while(0)#define PixVal(pix) ((long)pix.pixel)//note: although pixval & 0xf will not yield 0,1,2,...//it will yield 0,3,6,9,12,15,2,5... which looks//just as good on the jitter.#define GetGouraudDither(dith_abcd, shade, color)	(gTextureShader[shade].color24bit[color])//#define IncSetPixel2(pix,color)//#define SetPixel2(pix,color)//#define PixVal(pix) (pix.offset)//#define GetGouraudDither(dith_abcd, shade, color)	(gTextureShader[shade].truecolor[color])// MERGE-GOURAUD ]]]/*------------------------------------------------------------------------------ * ScanFillPatternXxx(). *------------------------------------------------------------------------------ */#define ScanFillPattern ScanFillPattern24void ScanFillPattern24(PixType pixel,int evenodd,int dx,VColorType color);								void ScanFillPattern24(PixType pixel,int evenodd,int dx,VColorType color) {LPBYTE pb,pbbase;long lNumBytes;     // since 3 bytes per color, use bytes, not longs.pbbase = pixel.pixel;pb = pbbase;lNumBytes = dx * 3;if ((evenodd^(LONG)pb)&1)	{ // jitter our starting location	pb +=3;	dx--;	lNumBytes -= 3;	}// ideal is lNumBytes-1, but this includes, without overdoing it too often //GJR 10/20/93if (SPANNEDHUGE(pixel.rowBase, pb + lNumBytes))	{ char huge* hugepb  = pixel.rowBase;                 hugepb += FP_OFF(pb) - FP_OFF(pixel.rowBase);  // done separately to process seg crossings	while(dx>0)		{		*hugepb++ = color[0];		*hugepb++ = color[1];		*hugepb++ = color[2];	  		hugepb += 3;  //skip over every other pixel, 3 bytes each		dx -= 2;  //count the two pixels		}	}else	{	while(dx>0)		{		*pb++ = color[0];		*pb++ = color[1];		*pb++ = color[2];	  		pb += 3;  //skip over every other pixel, 3 bytes each    	dx -= 2;  //count the two pixels		}    }}														/*------------------------------------------------------------------------------ * ScanFillxxx. *------------------------------------------------------------------------------ */#define ScanFill ScanFill24void ScanFill24(PixType pixel,int evenodd,int INdx,VColorType color);										void ScanFill24(PixType pixel,int evenodd,int INdx,VColorType color)											{int dx = INdx;LPBYTE pb,pbbase;long lNumBytes;     // since 3 bytes per color, use bytes, not longs.pbbase = pixel.pixel;pb = pbbase;lNumBytes = dx * 3;// NO ASM YET// Should do sets of 3bytes*4pixels=3longwordsif (SPANNEDHUGE(pixel.rowBase, pb + lNumBytes))	{ char huge* hugepb  = pixel.rowBase;				 hugepb += FP_OFF(pb) - FP_OFF(pixel.rowBase);  // done separately to process seg crossings	while(dx>0)		{		*hugepb++ = color[0];		*hugepb++ = color[1];		*hugepb++ = color[2];	  		dx -= 1;		}	}else	{	while(dx>0)		{		*pb++ = color[0];		*pb++ = color[1];		*pb++ = color[2];	  		dx -= 1;		}    }}// MERGE-GOURAUD [[[/*------------------------------------------------------------------------------ * GouraudFillxxxx *------------------------------------------------------------------------------ */// GOURAUD -- we have to pattern fill dx pixels, going from intensity il to intensity ir#define DefaultGouraudFillPattern DefaultGouraudFillPattern24#define DefaultGouraudFill DefaultGouraudFill24#define GouraudFillPattern DefaultGouraudFillPattern24#define GouraudFill GouraudFill24A/*------------------------------------------------------------------------------------------*//**/#if 0void GouraudFill24(PixType pixel, int evenodd, int dx, int actual_dx, int left_unused,	FFixed il, FFixed ir, GColorType *dith_a, GColorType *dith_b, unsigned short *jitter,	long *jitter_diffs);										void GouraudFill24(PixType pixel, int evenodd, int dx, int actual_dx, int left_unused,	FFixed il, FFixed ir, GColorType *dith_a, GColorType *dith_b, unsigned short *jitter,	long *jitter_diffs)								{		register long increment, i; FFixed fdx, diff;	// determine the fraction of intensity and pixels -- how much do I bump the intensity	// per pixel?		fdx.intg = actual_dx;	fdx.frac = 0;	diff.l = ir.l - il.l;	increment = FFDiv(diff, fdx).l;		i = il.l;	while (left_unused--)		i += increment;	while (dx--)	{		IncSetPixel2(pixel, dith_a[i >> 16]);		i += increment;	} }							#endif/*------------------------------------------------------------------------------------------*//**/void GouraudFill24A(PixType pixel, long evenodd, long dx, long actual_dx, long left_unused,	FFixed il, FFixed ir, GColorType *dith_a, GColorType *dith_b, unsigned short *jitter,	long *jitter_diffs);										void GouraudFill24A(PixType pixel, long evenodd, long dx, long actual_dx, long left_unused,	FFixed il, FFixed ir, GColorType *dith_a, GColorType *dith_b, unsigned short *jitter,	long *jitter_diffs)								{		FFixed fdx, diff;register long increment, big_increment, i;	// pretend these are FFixedlong adx;	// determine the fraction of intensity and pixels -- how much to bump the intensity	// per pixel		fdx.intg = actual_dx;	fdx.frac = 0;	diff.l = ir.l - il.l;	increment = FFDiv(diff, fdx).l;		// get the initial intensity	i = il.l;			// do the part that is clipped out on the left -- just increment the number of times	// (left_unused is the number of pixels on the left that are clipped out)	// (also note that pixel has been inited to the value that we are actually supposed to	// start drawing at, so we don't increment pixel here)	while (left_unused--)		i += increment;	// compute how many pairs of pixels to do	adx = (dx >> 1);		// subtract the number of pairs from dx	dx -= (adx << 1);	// loop through the pairs -- note that since we know we are on a even word boundary,	// we can hard-code the dith_a and dith_b values	while (adx--)	{	register long jitt;		//note: although pixval & 0xf will not yield 0,1,2,...		//it will yield 0,3,6,9,12,15,2,5... which looks		//just as good on the jitter.		jitt = jitter[PixVal(pixel) & 0xF]; jitt += i;		IncSetPixel2(pixel, dith_a[jitt >> 16]);		i += increment;				jitt = jitter[PixVal(pixel) & 0xF]; jitt += i;		IncSetPixel2(pixel, dith_a[jitt >> 16]);		i += increment;	}		// do the last pixel -- at this point dx will be 0 or 1	if (dx)	{	register long jitt;		jitt = jitter[PixVal(pixel) & 0xF]; jitt += i;		SetPixel2(pixel, dith_a[jitt >> 16]);		// note no need to do IncSet		// note no need to increment i	}}							// MERGE-GOURAUD ]]]#define USE_JITTER_VALS_NO_DITHER 1			// MERGE-GOURAUD#include "FlashZ.h"#undef USE_JITTER_VALS_NO_DITHER			// MERGE-GOURAUD