/*------------------------------------------------------------------------------ * VWINDOWSÂ - the window object toolbox * * Copyright c 1991 by Virtus Corporation * All Rights Reserved * Written by David A. Smith * Virtus Corporation * 117 Edinburgh So * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * F1.c *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VMath.h"#include "VToolBox.h"#include "VDisplay.h"#include "VGUtil.h"#include "Clip.h"#include "Flash.h"#include "TextSrvr.h"		// MERGE-GOURAUD#include "Gouraud.h"		// MERGE-GOURAUD/*------------------------------------------------------------------------------ * Define the function names *------------------------------------------------------------------------------ */#define FLine FLine1#define FLineClip FLineClip1#define FlashFill FlashFill1#define FlashClip FlashClip1#define FFixedFLine FFixedFLine1#define FlashGouraud 		FlashGouraud1			// MERGE-GOURAUD#define FlashGouraudClip 	FlashGouraudClip1		// MERGE-GOURAUD/*------------------------------------------------------------------------------ * Define the two major data types. *------------------------------------------------------------------------------ */typedef unsigned long VColorType[2];typedef unsigned char GColorType;		// MERGE-GOURAUDtypedef struct 	PixType{unsigned char * pixel;						int pos;						} PixType;static unsigned char pixbits[]={0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01};static unsigned long lMask[]={0,0x7FFFFFFF,0x3FFFFFFF,0x1FFFFFFF,0x0FFFFFFF,							0x07FFFFFF,0x03FFFFFF,0x01FFFFFF,0x00FFFFFF,0x007FFFFF,							0x003FFFFF,0x001FFFFF,0x000FFFFF,0x0007FFFF,0x0003FFFF,							0x0001FFFF,0x0000FFFF,0x00007FFF,0x00003FFF,0x00001FFF,							0x00000FFF,0x000007FF,0x000003FF,0x000001FF,0x000000FF,							0x0000007F,0x0000003F,0x0000001F,0x0000000F,0x00000007,							0x00000003,0x00000001};static unsigned long rMask[]={0,0x80000000,0xC0000000,0xE0000000,0xF0000000,							0xF8000000,0xFC000000,0xFE000000,0xFF000000,0xFF800000,							0xFFC00000,0xFFE00000,0xFFF00000,0xFFF80000,0xFFFC0000,							0xFFFE0000,0xFFFF0000,0xFFFF8000,0xFFFFC000,0xFFFFE000,							0xFFFFF000,0xFFFFF800,0xFFFFFC00,0xFFFFFE00,0xFFFFFF00,							0xFFFFFF80,0xFFFFFFC0,0xFFFFFFE0,0xFFFFFFF0,0xFFFFFFF8,							0xFFFFFFFC,0xFFFFFFFE};					/*------------------------------------------------------------------------------ * Define the pixel routines. * For additional information about this code, see the Flash.c sources. *------------------------------------------------------------------------------ */#define InitColorPen(color,rgb) color[0] = 0xFFFFFFFF// for now, jam to black.  jca 24 aug 93/*{color[0]=offscreen->GetNoDither(rgb); \	color[1]=(color[0]>>16)|(color[0]&0xFFFF0000);	\	color[0]=(color[0]<<16)|(color[0]&0x0000FFFF);	\	}*/#define InitColorBrush(color,rgb) {color[0]=offscreen->GetDither(rgb); \	color[1]=(color[0]>>16)|(color[0]&0xFFFF0000);	\	color[0]=(color[0]<<16)|(color[0]&0x0000FFFF);	\	}	// MERGE-GOURAUD [[[// this macro inits the color index based on the rgb -- index will range from 0..255// at most, and will be less for bit depths 1/2/4.  The index is an index into the standard color// table; index is an unsigned char, rgb is an RGBColor, indix is a GColorType#define InitColorIndex(index,rgb) {index = rgb; }// MERGE-GOURAUD ]]]#define InitPixel(pix,xval,yval,to) {pix.pixel=(unsigned char*)to->baseAddress; \	pix.pixel+=((xval-to->xOffset)>>3); \	pix.pixel+=(yval-to->yOffset)*(long)to->rowBytes; \	pix.pos=((xval-to->xOffset)&0x07);}	 // MERGE-HMD [[[#if USE_HMD#define InitPixelHMDL(pix,xval,yval,to) {pix.pixel=(unsigned char*)to->baseAddress; \	pix.pixel+=((xval-to->xOffset)>>3); \	pix.pixel+=(yval-to->yOffset)*((long)to->rowBytes << 1); \	if (gHMDOffsetLeft) pix.pixel += ((long)(to->rowBytes));	\	pix.pos=((xval-to->xOffset)&0x07); \	}#define InitPixelHMDR(pix,xval,yval,to) {pix.pixel=(unsigned char*)to->baseAddress; \	pix.pixel+=((xval-to->xOffset)>>3); \	pix.pixel+=(yval-to->yOffset)*((long)to->rowBytes << 1); \	if (gHMDOffsetRight) pix.pixel += ((long)(to->rowBytes));	 \	pix.pos=((xval-to->xOffset)&0x07); \	}#define AddLinePixelHMD(pix,to) pix.pixel+=((long)to->rowBytes << 1)#endif // USE_HMD// MERGE-HMD ]]]	 #define DecPixel(pix)  {if(!pix.pos)pix.pixel--; pix.pos= (pix.pos-1)&0x07;}#define IncPixel(pix)  {if(pix.pos==0x07)pix.pixel++; pix.pos= (pix.pos+1)&0x07;}#define AddPixel(pix,length) {pix.pixel+=length>>3;					\	pix.pos += (length&0x07);if(pix.pos&~0x07){pix.pixel++;} pix.pos&=0x07}}	// MERGE-GOURAUD [[[#define SetPixel2(pix,color) *pix.pixel = \(color&pixbits[pix.pos]|((unsigned char)(*pix.pixel))&~pixbits[pix.pos])	#define IncSetPixel2(pix,color) do{SetPixel2(pix,color);IncPixel(pix);}while(0)#define PixVal(pix) (pix.pos)					#define GetGouraudDither(dith_abcd, shade, color)	(gTextureShader[shade].dith[0][dith_abcd][color])// MERGE-GOURAUD ]]]#define AddLinePixel(pix,to) pix.pixel+=to->rowBytes#define SetPixel(pix,color) *pix.pixel = \(color[0]&pixbits[pix.pos]|((unsigned char)(*pix.pixel))&~pixbits[pix.pos])		#define DecSetPixel(pix,color) do{SetPixel(pix,color);DecPixel(pix);}while(0)#define IncSetPixel(pix,color) do{SetPixel(pix,color);IncPixel(pix);}while(0)#define ScanFillPattern ScanFillPattern1void ScanFillPattern1(PixType pixel,int ytop,int dx,VColorType color);								void ScanFillPattern1(PixType pixel,int ytop,int dx,VColorType color) {														// Smith recommends we not do patterns for 2-bit and under.}#define ScanFill ScanFill1								void ScanFill1(PixType pixel,int evenodd,int dx,VColorType color);										void ScanFill1(PixType pixel,int evenodd,int dx,VColorType color)											{int ml,mr;				unsigned long *pl,*pr;unsigned long col=color[evenodd];int hl=pixel.pos;pl=(unsigned long *)(((long)pixel.pixel)&0xFFFFFFFC);ml=((long)pixel.pixel)&0x03;ml=(ml<<3)+hl;pixel.pixel+=(dx>>3);pr=(unsigned long *)(((long)pixel.pixel)&0xFFFFFFFC);mr=((long)pixel.pixel)&0x03;/* the byte inside the long word */mr=(mr<<3)+(dx&07)+hl; /*the pixel inside the byte*/if(mr>=32)	{pr++;mr-=32;}if(pl==pr)/*same 32 bits*/	{	if(ml)		{		if(mr)*pl=(*pl&(rMask[ml]|lMask[mr]))|(lMask[ml]&rMask[mr]&col);		else *pl=(*pl&rMask[ml])|(lMask[ml]&col);		}	else if(mr)*pl=(*pl&lMask[mr])|(rMask[mr]&col);	}else 	{#if __PPCC__	if(ml)		{		*pl=(*pl&rMask[ml])|(lMask[ml]&col);		*pl++;		}#else	if(ml)*pl++=(*pl&rMask[ml])|(lMask[ml]&col);#endif //__PPCC__	while(pl!=pr)*pl++=col;	if(mr)*pl=(*pl&lMask[mr])|(rMask[mr]&col);	}}			// MERGE-GOURAUD [[[/*------------------------------------------------------------------------------ * GouraudFillxxxx *------------------------------------------------------------------------------ */// GOURAUD -- we have to pattern fill dx pixels, going from intensity il to intensity ir#define DefaultGouraudFillPattern DefaultGouraudFillPattern1#define DefaultGouraudFill DefaultGouraudFill1#define GouraudFillPattern DefaultGouraudFillPattern1#define GouraudFill DefaultGouraudFill1// MERGE-GOURAUD ]]]								#include "FlashZ.h"