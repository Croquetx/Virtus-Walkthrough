/*------------------------------------------------------------------------------ * VWINDOWSt - the window object toolbox * * Copyright (c) 1993 by Virtus Corporation * All Rights Reserved * Written by David A. Smith * Virtus Corporation * 117 Edinburgh So * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Flash.c * Generic Graphics Package * * This package was written to provide device independence for the Virtus * Flash fill graphics code. It requires the programmer to provide the * following set of definitions, macros, and functions. This is extremely * easy to do and requires about two pages of code to address almost any  * kind of direct memory-access architecture. * * This code was designed to work with the main function, where this file is * #included at the end of the file. * #include "Flash.c" *------------------------------------------------------------------------------ * Data types: * PixType - the data type of the pixel address * VColorType - the data type of the color information, usually has even/odd data. *------------------------------------------------------------------------------ * Function Macros: * These are the Flash.c routines. They need to be redefined to be the function * names that will actually be called. For example, for a VGA driver, you might * redefine these as: * * #define FLine FlineVGA * * FLine * FLineClip * FlashFill * FlashClip * ScanFillPattern - also defined by user * ScanFill - also defined by user *------------------------------------------------------------------------------ * Macros: * InitColorPen - calculate the VColorType that will be used, pen for lines * InitColorBrush - calculate the VColorType that will be used, brush for fill area polys * InitPixel - calculate the location of the first pixel that will be used * DecPixel - calculate the pixel to the left of the current pixel * IncPixel - calculate the pixel to the right of the current pixel * AddPixel - calculate the pixel length away from the current pixel * AddLinePixel - calculate the pixel directly under the current pixel * DecSetPixel - set the current pixel to the color, calc left of current * IncSetPixel - set the current pixel to the color, calc right of current * SetPixel - set the current pixel to the specified color *------------------------------------------------------------------------------ * Functions: * ScanFillPattern - fill the scan line in the appropriate color & pattern * ScanFill - fill the scan line in the specified color *------------------------------------------------------------------------------ */#ifndef FLATSHADE#define FLATSHADE 1#endif#ifndef SMOOTHSHADE#define SMOOTHSHADE 1#endif#include "objprclp.h"#include "TextSrvr.h"		// MERGE-GOURAUD for gTextureShader#if USE_HMD			// MERGE-HMD#include "HMD.h"	// MERGE-HMD#endif // USE_HMD	// MERGE-HMD#if FLATSHADE/*------------------------------------------------------------------------------ * Fline(V_Offscreen *to, int x1,int y1,int x2,int y2, RGBColor *rgb) *------------------------------------------------------------------------------*/void FLine(V_Offscreen *to, int x1,int y1,int x2,int y2, RGBColor *rgb){int xt,yt;int dx,dy,odx,deltaN,deltaY;int deltaX;Rect rclip;VColorType color;PixType pixel;FFixed FFx, FFy, FFdeltaX, FFdeltaY, FFslope, tempfixed, tempfixed2;FFixed FFx1, FFy1, FFx2, FFy2;int oldinteger;rclip = to->clipRect;/*--------draw from top to bottom, reverse points if necessary*/if(y1>y2)	{xt=x1;x1=x2;x2=xt;yt=y1;y1=y2;y2=yt;}/*are we even visible?*/if(y1>=rclip.bottom)return;if(y2<rclip.top)return;// { DAS-LIZARD KING 10/2/93if(x1>=rclip.right && x2>=rclip.right)return;if(x1<rclip.left && x2<rclip.left)return;// } DAS-LIZARD KING 10/2/93/*clip line to screen.  do not draw if clip eliminates line all together*/FFx1.intg = x1;FFy1.intg = y1;FFx2.intg = x2;FFy2.intg = y2;FFx1.frac = FFy1.frac = FFx2.frac = FFy2.frac = 0;if(ClipLineToRect(rclip, &FFx1, &FFy1, &FFx2, &FFy2)) return;InitColorPen(color,rgb);FFx = FFx1; FFy = FFy1;FFdeltaY.l = FFy2.l - FFy1.l;FFdeltaX.l = FFx2.l - FFx1.l;if(FFdeltaX.l >= 0) {	if(FFdeltaX.l < FFdeltaY.l) {		deltaY = FFRound(FFy2) - FFRound(FFy1);		FFslope = FFDiv(FFdeltaX, FFdeltaY);				/*advance to sample row*/		tempfixed.intg = FFRound(FFy);		tempfixed.frac = FixedPointFive.frac;		tempfixed2.l = tempfixed.l - FFy.l;		FFx.l += FFMult(tempfixed2, FFslope).l;		FFy = tempfixed;				/*handle rounding of FFx*///		FFx.l += FixedPointFive.l;				// MERGE-HMD [[[		#if USE_HMD		if ((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX)) 		{			if (gHMD->eye == EYE_LEFT)			{				InitPixelHMDL(pixel,FFx.intg, FFy.intg, to);			}			else if (gHMD->eye == EYE_RIGHT)			{				InitPixelHMDR(pixel,FFx.intg, FFy.intg, to);			}			else 			{				DEBUGGER();		// something bad has happened				InitPixel(pixel,FFx.intg, FFy.intg, to);			}		}		else			InitPixel(pixel,FFx.intg, FFy.intg, to);		#else		InitPixel(pixel,FFx.intg, FFy.intg, to);		#endif // USE_HMD		// MERGE-HMD ]]]		oldinteger = FFx.intg;		if(deltaY)		{			/*need to do last pixels separately to avoid letting           AddLinePixel address bad location*/			deltaY--;			while(deltaY--)			{				FFx.l += FFslope.l;				if(FFx.intg != oldinteger) {					IncSetPixel(pixel,color);					oldinteger = FFx.intg;				}				else {					SetPixel(pixel, color);				}				// MERGE-HMD [[[				#if USE_HMD				if ((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX)) 		// ABD HMD MAR95					{ AddLinePixelHMD(pixel,to); }				else					{ AddLinePixel(pixel,to); }				#else				// MERGE-HMD ]]]				AddLinePixel(pixel,to);				#endif // USE_HMD			}         SetPixel(pixel, color);      }	}	else {		deltaX = FFRound(FFx2) - FFRound(FFx1);		FFslope = FFDiv(FFdeltaY, FFdeltaX);				/*advance to sample column*/		tempfixed.intg = FFRound(FFx);		tempfixed.frac = FixedPointFive.frac;		tempfixed2.l = tempfixed.l - FFx.l;		FFy.l += FFMult(tempfixed2, FFslope).l;		FFx = tempfixed;				/*handle rounding of FFy*///		FFy.l += FixedPointFive.l;				// MERGE-HMD [[[		#if USE_HMD		if ((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX)) 		{			if (gHMD->eye == EYE_LEFT)			{				InitPixelHMDL(pixel,FFx.intg, FFy.intg, to);			}			else if (gHMD->eye == EYE_RIGHT)			{				InitPixelHMDR(pixel,FFx.intg, FFy.intg, to);			}			else 			{				DEBUGGER();		// something bad has happened				InitPixel(pixel,FFx.intg, FFy.intg, to);			}		}		else			InitPixel(pixel,FFx.intg, FFy.intg, to);		#else		InitPixel(pixel,FFx.intg, FFy.intg, to);		#endif // USE_HMD		// MERGE-HMD ]]]		oldinteger = FFy.intg;		if(deltaX)		{			/*need to do last pixels separately to avoid letting           AddLinePixel address bad location*/			deltaX--;			while(deltaX--)			{				IncSetPixel(pixel, color);				FFy.l += FFslope.l;				if(FFy.intg != oldinteger) {					// MERGE-HMD [[[					#if USE_HMD					if ((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX))						{ AddLinePixelHMD(pixel,to); }					else						{ AddLinePixel(pixel,to); }					#else					// MERGE-HMD ]]]					AddLinePixel(pixel,to);					#endif // USE_HMD					oldinteger = FFy.intg;				}			}         SetPixel(pixel, color);      }	}}else {	if(-FFdeltaX.l < FFdeltaY.l) {		deltaY = FFRound(FFy2) - FFRound(FFy1);		FFslope = FFDiv(FFdeltaX, FFdeltaY);				/*advance to sample row*/		tempfixed.intg = FFRound(FFy);		tempfixed.frac = FixedPointFive.frac;		tempfixed2.l = tempfixed.l - FFy.l;		FFx.l += FFMult(tempfixed2, FFslope).l;		FFy = tempfixed;				/*handle rounding of FFx*///		FFx.l += FixedPointFive.l;				// MERGE-HMD [[[		#if USE_HMD		if ((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX)) 		{			if (gHMD->eye == EYE_LEFT)			{				InitPixelHMDL(pixel,FFx.intg, FFy.intg, to);			}			else if (gHMD->eye == EYE_RIGHT)			{				InitPixelHMDR(pixel,FFx.intg, FFy.intg, to);			}			else 			{				DEBUGGER();		// something bad has happened				InitPixel(pixel,FFx.intg, FFy.intg, to);			}		}		else			InitPixel(pixel,FFx.intg, FFy.intg, to);		#else		InitPixel(pixel,FFx.intg, FFy.intg, to);		#endif // USE_HMD		// MERGE-HMD ]]]		oldinteger = FFx.intg;		if(deltaY)		{			/*need to do last pixels separately to avoid letting           AddLinePixel address bad location*/			deltaY--;			while(deltaY--)			{				FFx.l += FFslope.l;				if(FFx.intg != oldinteger) {					DecSetPixel(pixel,color);					oldinteger = FFx.intg;				}				else {					SetPixel(pixel, color);				}				// MERGE-HMD [[[				#if USE_HMD				if ((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX))					{ AddLinePixelHMD(pixel,to); }				else					{ AddLinePixel(pixel,to); }				#else				// MERGE-HMD ]]]				AddLinePixel(pixel,to);				#endif // USE_HMD			}			SetPixel(pixel,color);      }	}	else {		deltaX = FFRound(FFx1) - FFRound(FFx2);		FFslope = FFDiv(FFdeltaY, FFdeltaX);				/*advance (right-to-left) to sample column*/		tempfixed.intg = FFRound(FFx);		tempfixed.frac = 0;		tempfixed.l -= FixedPointFive.frac;		tempfixed2.l = tempfixed.l - FFx.l;		FFy.l += FFMult(tempfixed2, FFslope).l;		FFx = tempfixed;				/*handle rounding of FFy*///		FFy.l += FixedPointFive.l;				// MERGE-HMD [[[		#if USE_HMD		if ((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX)) 		{			if (gHMD->eye == EYE_LEFT)			{				InitPixelHMDL(pixel,FFx.intg, FFy.intg, to);			}			else if (gHMD->eye == EYE_RIGHT)			{				InitPixelHMDR(pixel,FFx.intg, FFy.intg, to);			}			else 			{				DEBUGGER();		// something bad has happened				InitPixel(pixel,FFx.intg, FFy.intg, to);			}		}		else			InitPixel(pixel,FFx.intg, FFy.intg, to);		#else		InitPixel(pixel,FFx.intg, FFy.intg, to);		#endif // USE_HMD		// MERGE-HMD ]]]		oldinteger = FFy.intg;		if(deltaX)		{			/*need to do last pixels separately to avoid letting           AddLinePixel address bad location*/			deltaX--;			while(deltaX--)			{				DecSetPixel(pixel, color);				FFy.l -= FFslope.l;				if(FFy.intg != oldinteger) {					// MERGE-HMD [[[					#if USE_HMD					if ((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX))						{ AddLinePixelHMD(pixel,to); }					else						{ AddLinePixel(pixel,to); }					#else					// MERGE-HMD ]]]					AddLinePixel(pixel,to);					#endif // USE_HMD					oldinteger = FFy.intg;				}			}         SetPixel(pixel, color);      }	}}}/*------------------------------------------------------------------------------ * void FLineClip(V_Offscreen *to, int x1,int y1,int x2,int y2, *		RGBColor *rgb, Clip *clipper) *------------------------------------------------------------------------------*/void FLineClip(V_Offscreen *to, int x1,int y1,int x2,int y2,	RGBColor *rgb, Clip *clipper){PointFFixed p1, p2;if (clipper->reject) return;/*clip line to screen and clipper bounding box.  do not draw if clip eliminates line all together*/p1.h.intg = x1;p1.v.intg = y1;p2.h.intg = x2;p2.v.intg = y2;p1.h.frac = p1.v.frac = p2.h.frac = p2.v.frac = 0;if(clipper->ClipLineToPoly(&p1, &p2) == REJECT) return;FFixedFLine(to, p1.h, p1.v, p2.h, p2.v, rgb);}void FFixedFLine(V_Offscreen *to, FFixed x1,FFixed y1,FFixed x2,FFixed y2,	RGBColor *rgb){FFixed xt,yt;int dx,dy,odx,deltaN,deltaY;VColorType color;PixType pixel;int deltaX;FFixed FFx, FFy, FFdeltaX, FFdeltaY, FFslope, tempfixed, tempfixed2;FFixed FFx1, FFy1, FFx2, FFy2;int oldinteger;//if(y1>y2)//	{xt=x1;x1=x2;x2=xt;yt=y1;y1=y2;y2=yt;}if(y1.l>y2.l)	{xt=x1;x1=x2;x2=xt;yt=y1;y1=y2;y2=yt;}FFx1 = x1;FFy1 = y1;FFx2 = x2;FFy2 = y2;InitColorPen(color,rgb);FFx = FFx1; FFy = FFy1;FFdeltaY.l = FFy2.l - FFy1.l;FFdeltaX.l = FFx2.l - FFx1.l;if(FFdeltaX.l >= 0) {	if(FFdeltaX.l < FFdeltaY.l) {		deltaY = FFRound(FFy2) - FFRound(FFy1);		FFslope = FFDiv(FFdeltaX, FFdeltaY);				/*advance to sample row*/		tempfixed.intg = FFRound(FFy);		tempfixed.frac = FixedPointFive.frac;		tempfixed2.l = tempfixed.l - FFy.l;		FFx.l += FFMult(tempfixed2, FFslope).l;		FFy = tempfixed;				/*handle rounding of FFx*///		FFx.l += FixedPointFive.l;				// MERGE-HMD [[[		#if USE_HMD		if ((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX)) 		{			if (gHMD->eye == EYE_LEFT)			{				InitPixelHMDL(pixel,FFx.intg, FFy.intg, to);			}			else if (gHMD->eye == EYE_RIGHT)			{				InitPixelHMDR(pixel,FFx.intg, FFy.intg, to);			}			else 			{				DEBUGGER();		// something bad has happened				InitPixel(pixel,FFx.intg, FFy.intg, to);			}		}		else			InitPixel(pixel,FFx.intg, FFy.intg, to);		#else		InitPixel(pixel,FFx.intg, FFy.intg, to);		#endif // USE_HMD		// MERGE-HMD ]]]		oldinteger = FFx.intg;		if(deltaY)		{			/*need to do last pixels separately to avoid letting           AddLinePixel address bad location*/			deltaY--;			while(deltaY--)			{				FFx.l += FFslope.l;				if(FFx.intg != oldinteger) {					IncSetPixel(pixel,color);					oldinteger = FFx.intg;				}				else {					SetPixel(pixel, color);				}				// MERGE-HMD [[[				#if USE_HMD				if ((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX))					{ AddLinePixelHMD(pixel,to); }				else					{ AddLinePixel(pixel,to); }				#else				// MERGE-HMD ]]]				AddLinePixel(pixel,to);				#endif // USE_HMD			}         SetPixel(pixel, color);      }	}	else {		deltaX = FFRound(FFx2) - FFRound(FFx1);		FFslope = FFDiv(FFdeltaY, FFdeltaX);				/*advance to sample column*/		tempfixed.intg = FFRound(FFx);		tempfixed.frac = FixedPointFive.frac;		tempfixed2.l = tempfixed.l - FFx.l;		FFy.l += FFMult(tempfixed2, FFslope).l;		FFx = tempfixed;				/*handle rounding of FFy*///		FFy.l += FixedPointFive.l;				// MERGE-HMD [[[		#if USE_HMD		if ((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX)) 		{			if (gHMD->eye == EYE_LEFT)			{				InitPixelHMDL(pixel,FFx.intg, FFy.intg, to);			}			else if (gHMD->eye == EYE_RIGHT)			{				InitPixelHMDR(pixel,FFx.intg, FFy.intg, to);			}			else 			{				DEBUGGER();		// something bad has happened				InitPixel(pixel,FFx.intg, FFy.intg, to);			}		}		else			InitPixel(pixel,FFx.intg, FFy.intg, to);		#else		InitPixel(pixel,FFx.intg, FFy.intg, to);		#endif // USE_HMD		// MERGE-HMD ]]]		oldinteger = FFy.intg;		if(deltaX)		{			/*need to do last pixels separately to avoid letting           AddLinePixel address bad location*/			deltaX--;			while(deltaX--)			{				IncSetPixel(pixel, color);				FFy.l += FFslope.l;				if(FFy.intg != oldinteger) {					// MERGE-HMD [[[					#if USE_HMD					if ((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX))						{ AddLinePixelHMD(pixel,to); }					else						{ AddLinePixel(pixel,to); }					#else					// MERGE-HMD ]]]					AddLinePixel(pixel,to);					#endif // USE_HMD					oldinteger = FFy.intg;				}			}         SetPixel(pixel, color);      }	}}else {	if(-FFdeltaX.l < FFdeltaY.l) {		deltaY = FFRound(FFy2) - FFRound(FFy1);		FFslope = FFDiv(FFdeltaX, FFdeltaY);				/*advance to sample row*/		tempfixed.intg = FFRound(FFy);		tempfixed.frac = FixedPointFive.frac;		tempfixed2.l = tempfixed.l - FFy.l;		FFx.l += FFMult(tempfixed2, FFslope).l;		FFy = tempfixed;				/*handle rounding of FFx*///		FFx.l += FixedPointFive.l;				// MERGE-HMD [[[		#if USE_HMD		if ((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX)) 		{			if (gHMD->eye == EYE_LEFT)			{				InitPixelHMDL(pixel,FFx.intg, FFy.intg, to);			}			else if (gHMD->eye == EYE_RIGHT)			{				InitPixelHMDR(pixel,FFx.intg, FFy.intg, to);			}			else 			{				DEBUGGER();		// something bad has happened				InitPixel(pixel,FFx.intg, FFy.intg, to);			}		}		else			InitPixel(pixel,FFx.intg, FFy.intg, to);		#else		InitPixel(pixel,FFx.intg, FFy.intg, to);		#endif // USE_HMD		// MERGE-HMD ]]]		oldinteger = FFx.intg;		if(deltaY)		{			/*need to do last pixels separately to avoid letting           AddLinePixel address bad location*/			deltaY--;			while(deltaY--)			{				FFx.l += FFslope.l;				if(FFx.intg != oldinteger) {					DecSetPixel(pixel,color);					oldinteger = FFx.intg;				}				else {					SetPixel(pixel, color);				}				// MERGE-HMD [[[				#if USE_HMD				if ((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX))					{ AddLinePixelHMD(pixel,to); }				else					{ AddLinePixel(pixel,to); }				#else				// MERGE-HMD ]]]				AddLinePixel(pixel,to);				#endif // USE_HMD			}			SetPixel(pixel,color);      }	}	else {		deltaX = FFRound(FFx1) - FFRound(FFx2);		FFslope = FFDiv(FFdeltaY, FFdeltaX);				/*advance (right-to-left) to sample column*/		tempfixed.intg = FFRound(FFx);		tempfixed.frac = 0;		tempfixed.l -= FixedPointFive.frac;		tempfixed2.l = tempfixed.l - FFx.l;		FFy.l += FFMult(tempfixed2, FFslope).l;		FFx = tempfixed;				/*handle rounding of FFy*///		FFy.l += FixedPointFive.l;				// MERGE-HMD [[[		#if USE_HMD		if ((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX)) 		{			if (gHMD->eye == EYE_LEFT)			{				InitPixelHMDL(pixel,FFx.intg, FFy.intg, to);			}			else if (gHMD->eye == EYE_RIGHT)			{				InitPixelHMDR(pixel,FFx.intg, FFy.intg, to);			}			else 			{				DEBUGGER();		// something bad has happened				InitPixel(pixel,FFx.intg, FFy.intg, to);			}		}		else			InitPixel(pixel,FFx.intg, FFy.intg, to);		#else		InitPixel(pixel,FFx.intg, FFy.intg, to);		#endif // USE_HMD		// MERGE-HMD ]]]		oldinteger = FFy.intg;		if(deltaX)		{			/*need to do last pixels separately to avoid letting           AddLinePixel address bad location*/			deltaX--;			while(deltaX--)			{				DecSetPixel(pixel, color);				FFy.l -= FFslope.l;				if(FFy.intg != oldinteger) {					// MERGE-HMD [[[					#if USE_HMD					if ((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX))						{ AddLinePixelHMD(pixel,to); }					else						{ AddLinePixel(pixel,to); }					#else					// MERGE-HMD ]]]					AddLinePixel(pixel,to);					#endif // USE_HMD					oldinteger = FFy.intg;				}			}         SetPixel(pixel, color);      }	}}}/*------------------------------------------------------------------------------ *int FlashFill(V_Offscreen *to,V_Array *points, *	RGBColor *rgb,RGBColor *lineColor,int mode,int pattern) *------------------------------------------------------------------------------*/int FlashFill(V_Offscreen *to,V_Array *points,	RGBColor *rgb,RGBColor *lineColor,int mode,int pattern){int plength,index_left=0,index_right;int tlh,tlv,trh,trv;Point *pt;VColorType color;//PixType pix;PixType pixel;int dyl,odyl,dxl,odxl,ddxl,dyr,odyr,dxr,odxr,ddxr,deltay,reset;int dx;int xl;int xr;int i,j;Rect rclip,tclip; // DAS-LIZARD KING 10/2/93int pv,ph; // DAS-LIZARD KING 10/2/93int ytop;int notDone=TRUE;int rval=FALSE;int frame;int dither;#if FASTER_PLEASEFFixed leftXFF, rightXFF, rdxFF, ldxFF, tempxFF, tempyFF;#endifplength=points->ALength();frame=mode&CLIP_FRAME;dither=mode&CLIP_DITHER;if(plength<=2|| !(mode&CLIP_FILL))	if(frame)	{	plength--;	if(plength>1)		{		pt=(Point *)points->Use();		for(i=0;i<plength;i++)			FLine(to,pt[i].h,pt[i].v,pt[i+1].h,pt[i+1].v,lineColor);		FLine(to,pt[0].h,pt[0].v,pt[plength].h,pt[plength].v, lineColor);		points->Unuse();		}	return TRUE;	}else return FALSE;pt=(Point *)points->Use();rclip=to->clipRect;/* find a point with the highest Y.  If there are several with the same Y value, this	will pick the first one in the point list (not necessarily the leftmost point) */// { DAS-LIZARD KING 10/2/93 simple checktclip.right=tclip.left=pt[0].h;tclip.bottom=tclip.top= pt[0].v;for(i=1;i<plength;i++)	{	pv=pt[i].v; ph=pt[i].h;		if(tclip.left>ph)tclip.left=ph;	if(tclip.right<ph)tclip.right=ph;	if(tclip.top>pv)tclip.top=pv;	if(tclip.bottom<pv)tclip.bottom=pv;	if(pt[index_left].v>pv)index_left=i;	}if( rclip.left>=tclip.right ||	rclip.right<tclip.left ||	rclip.top>=tclip.bottom ||	rclip.bottom<tclip.top)		{		points->Unuse();		return FALSE;		}// } DAS-LIZARD KING 10/2/93/* Now find the leftmost point with the highest Y, in case there are several points	with the same Y value as the current index_left. */index_right=index_left;j=0;while(pt[index_left].v==pt[i=previousNum(index_left,plength)].v && ++j<plength)	index_left=i;if(j==plength)goto endit;/* if the next point after the original index_left (which was the first point in the 	point list with the highest Y val) has the same yval, then dY for that line segment is	zero.  We want to get the next segment with a non-zero dY, since any number of segments	with dY==0 can be drawn with a single scanline.  So, find the point that begins the 	next segment with a non-zero dY */j=0;while(pt[index_right].v==pt[i=nextNum(index_right,plength)].v && ++j<plength)	index_right=i;if(j==plength)goto endit;/* index_left is now the point ending the +dY segment, index_right is the point that	begins the -dY segment at the top of the polygon. Set some local variables for the	positions, and then set index_left to the point beginning that segment, and set 	index_right to the point ending its segment */tlh=pt[index_left].h;tlv=pt[index_left].v;trh=pt[index_right].h;trv=pt[index_right].v;index_left=previousNum(index_left,plength);index_right=nextNum(index_right,plength);ytop=tlv;InitColorBrush(color,rgb);//InitPixel(pix,0,tlv,to);/* dxl and dyl are the x and y components of the left segment's slope, which will get	changed in the loop.  odxl and odxl are the old, unchanged values.  Ditto dxr, dyr,	odxr, odyr, excepth for the right segment.  Note that the left slope is reversed 	from what you would expect (it's start_point - end_point) */odyl=dyl=pt[index_left].v-tlv;odxl=dxl=pt[index_left].h-tlh;dxl>>=1;odyr=dyr=pt[index_right].v-trv;odxr=dxr=pt[index_right].h-trh;dxr>>=1;xl=tlh;xr=trh;#if FASTER_PLEASEtempxFF=FFZero;tempyFF=FFZero;tempxFF.intg = odxl; tempyFF.intg = odyl;if (odyl != 0)	ldxFF = FFDiv(tempxFF, tempyFF);else ldxFF.intg = 1;tempxFF.intg = odxr; tempyFF.intg = odyr;if (odyl != 0)	rdxFF = FFDiv(tempxFF, tempyFF);else rdxFF.intg = 1;leftXFF.intg = xl;		leftXFF.frac = 0;rightXFF.intg = xr;		rightXFF.frac = 0;leftXFF.l += ldxFF.l >> 1;rightXFF.l += rdxFF.l >> 1;#endifrval=TRUE;if(ytop>=rclip.bottom)goto endit;/* The Scan Fill: */do	{	if(index_left==index_right)notDone=FALSE;		// the segments meet at the base, so this is our last pass	/* figure out how long to scan using these slopes.  deltay = min(dyl, dyr)		Set the ending case (so we can figure out the next slope correctly), and 		make the max(dyl, dyr) -= deltay.  This is the left over for the next slope		calculations */	if(dyl < dyr)		{		deltay=dyl;		reset=1;		dyr-=dyl;		dyl=0;		}	else if(dyr < dyl)		{		deltay=dyr;		reset=2;		dyl-=dyr;		dyr=0;		}	else		{		deltay=dyr;		reset=3;		dyl=dyr=0;		}			/* Do it. */	while(deltay--)		{#if FASTER_PLEASE		xl = FFRound(leftXFF);		xr = FFRound(rightXFF);#endif		if(ytop>=rclip.top)			{			//pixel=pix;			if(rclip.left>xl)				{				// MERGE-HMD [[[				#if USE_HMD				if ((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX)) 				{					if (gHMD->eye == EYE_LEFT)					{						InitPixelHMDL(pixel,rclip.left, ytop, to);					}					else if (gHMD->eye == EYE_RIGHT)					{						InitPixelHMDR(pixel,rclip.left, ytop, to);					}					else 					{						DEBUGGER();		// something bad has happened						InitPixel(pixel,rclip.left, ytop, to);					}				}				else					InitPixel(pixel,rclip.left,ytop,to);//AddPixel(pixel,rclip.left);				#else				InitPixel(pixel,rclip.left,ytop,to);//AddPixel(pixel,rclip.left);				#endif // USE_HMD				// MERGE-HMD ]]]				if(xr>rclip.right)dx=rclip.right-rclip.left;				else dx=xr-rclip.left;				}			else				{				// MERGE-HMD [[[				#if USE_HMD				if ((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX)) 				{					if (gHMD->eye == EYE_LEFT)					{						InitPixelHMDL(pixel,xl,ytop, to);					}					else if (gHMD->eye == EYE_RIGHT)					{						InitPixelHMDR(pixel,xl,ytop, to);					}					else 					{						DEBUGGER();		// something bad has happened						InitPixel(pixel,xl,ytop, to);					}				}				else					InitPixel(pixel,xl,ytop,to);//AddPixel(pixel,rclip.left);				#else				InitPixel(pixel,xl,ytop,to);//AddPixel(pixel,rclip.left);				#endif // USE_HMD				// MERGE-HMD ]]]				if(xr>rclip.right)dx=rclip.right-xl;				else dx=xr-xl;				}			if(dx>0)				{				if(pattern)/*dithered fill (every other pixel)*/					ScanFillPattern(pixel,ytop&0x01,dx,color);				else					ScanFill(pixel,ytop&0x01,dx,color);				}			}		//AddLinePixel(pix,to);		ytop++;		if(ytop>=rclip.bottom)goto endit;#if FASTER_PLEASE		leftXFF.l += ldxFF.l;//		xl = leftXFF.intg;		rightXFF.l += rdxFF.l;//		xr = rightXFF.intg;#else		/* recalc the x-starting position and ending position  according to the slopes. */		// c-code equivalent to mac assembler		// do bresenham for left and right sides		if (odxl > 0) 			{			while (dxl > 0) 				{				xl++;				dxl -= odyl;				}			dxl += odxl;			}		else if (odxl < 0) 			{			while (dxl < 0) 				{				xl--;				dxl += odyl;				}			dxl += odxl;			}					if (odxr > 0) 			{			while (dxr > 0) 				{				xr++;				dxr -= odyr;				}			dxr += odxr;			}		else if (odxr < 0) 			{			while (dxr < 0) 				{				xr--;				dxr += odyr;				}			dxr += odxr;			}#endif		}			/* Set up the next section.  If there is a section of segment left over, we 		will be doing scans with it next.  This is where we calculate the next 		set of slopes */	if(reset&1)		{		tlv=pt[index_left].v;		xl=tlh=pt[index_left].h;		do	{			index_left=previousNum(index_left,plength);			odyl=dyl=pt[index_left].v-tlv;			odxl=dxl=pt[index_left].h-tlh;			dxl>>=1;			}while(tlv>pt[index_left].v && notDone && index_left!=index_right);#if FASTER_PLEASE		tempxFF.intg = odxl; tempyFF.intg = odyl;		if (odyl != 0)			ldxFF = FFDiv(tempxFF, tempyFF);		else {ldxFF.intg = 1; ldxFF.frac = 0; }		leftXFF.frac=0; 		leftXFF.intg = tlh;		leftXFF.l += ldxFF.l >> 1;#endif		}	if((reset&2) && index_left != index_right)		{		trv=pt[index_right].v;		xr=trh=pt[index_right].h;		do	{			index_right=nextNum(index_right,plength);			odyr=dyr=pt[index_right].v-trv;			odxr=dxr=pt[index_right].h-trh;			dxr>>=1;			}while(trv>pt[index_right].v && notDone && index_left!=index_right);	#if FASTER_PLEASE		tempxFF.intg = odxr; tempyFF.intg = odyr;		if (odyl != 0)			rdxFF = FFDiv(tempxFF, tempyFF);		else {rdxFF.intg = 1; rdxFF.frac = 0; }		rightXFF.frac = 0;		rightXFF.intg = trh;		rightXFF.l += rdxFF.l >> 1;#endif		}	}while(notDone);	endit:if(rval && frame)	{	plength--;	if(plength>1)		{		for(i=0;i<plength;i++)			FLine(to,pt[i].h,pt[i].v,pt[i+1].h,pt[i+1].v,lineColor);		FLine(to,pt[0].h,pt[0].v,pt[plength].h,pt[plength].v, lineColor);		}	}points->Unuse();return rval;}/*------------------------------------------------------------------------------ * int FlashClip(V_Offscreen *to,V_Array *points, * 	RGBColor *rgb,RGBColor *lineColor,Clip *clipper, int mode,int pattern) *------------------------------------------------------------------------------*/int FlashClip(V_Offscreen *to,V_Array *points,	RGBColor *rgb,RGBColor *lineColor,Clip *clipper, int mode,int pattern){long plength, plength2, templong;int index_left=0,index_right;Point *pt;VColorType color;//PixType pix;PixType pixel;int dyl, dyr;FFixed tempfixed, dxl, dxr, xl, xr, yl, yr;int deltay,reset;int dx;int cxl;int cxr;int i,j;Rect rclip; int cleft,cright;int ytop;struct ClipStruct *clip;int cliptop,clipbottom,clipindex;int notDone=TRUE;int rval=FALSE;int frame;int dither;PointFFixed *ClipShapePtr, *ptFF;char *framearray;LineData *LineEqtnsPtr;#if FASTER_PLEASEFFixed leftXFF, rightXFF, rdxFF, ldxFF, tempxFF, tempyFF;#endifplength=points->ALength();if(plength <= 2) return TRUE;if (clipper->reject) return TRUE;frame=mode&CLIP_FRAME;dither=mode&CLIP_DITHER;if(plength<=2||!(mode&CLIP_FILL))	if(frame)		{		plength--;		if(plength>1)			{			pt=(Point *)points->Use();			for(i=0;i<plength;i++)				FLineClip(to,pt[i].h,pt[i].v,pt[i+1].h,pt[i+1].v,lineColor,clipper);			FLineClip(to,pt[0].h,pt[0].v,pt[plength].h,pt[plength].v, lineColor,clipper);			points->Unuse();			}		return TRUE;		}else return FALSE;pt=(Point *)points->Use();//templong = clipper->ClipShape->ALength();//ptFF = InitFlashTemporaryArray(templong + plength + (long)1);if(clipper->WinClipToPoly(pt, plength, &ptFF, &framearray, &plength2, 0) == REJECT){	points->Unuse();	return TRUE;}for(i=1;i<plength2;i++)	{	if(ptFF[index_left].v.l>ptFF[i].v.l)index_left=i;	}index_right=index_left;j=0;while(FFRound(ptFF[index_left].v)==FFRound(ptFF[i=previousNum(index_left,plength2)].v) && ++j<plength2)index_left=i;if(j==plength2)goto endit;j=0;while(FFRound(ptFF[index_right].v)==FFRound(ptFF[i=nextNum(index_right,plength2)].v) && ++j<plength2)index_right=i;if(j==plength2)goto endit;xl=ptFF[index_left].h;yl=ptFF[index_left].v;xr=ptFF[index_right].h;yr=ptFF[index_right].v;index_left=previousNum(index_left,plength2);index_right=nextNum(index_right,plength2);ytop = FFRound(yl);InitColorBrush(color,rgb);//InitPixel(pix,0,tlv,to);dyl = FFRound(ptFF[index_left].v) - FFRound(yl);dyr = FFRound(ptFF[index_right].v) - FFRound(yr);tempfixed.l = ptFF[index_left].v.l - yl.l;dxl.l = ptFF[index_left].h.l - xl.l;dxl = FFDiv(dxl, tempfixed);tempfixed.l = ptFF[index_right].v.l - yr.l;dxr.l = ptFF[index_right].h.l - xr.l;dxr = FFDiv(dxr, tempfixed);/*handle vertical rounding*//*jump down to sample row*/tempfixed.frac = 0;tempfixed.intg = FFRound(yl);tempfixed.l += FixedPointFive.l;tempfixed.l = tempfixed.l - yl.l;xl.l += FFMult(dxl, tempfixed).l;tempfixed.frac = 0;tempfixed.intg = FFRound(yr);tempfixed.l += FixedPointFive.l;tempfixed.l = tempfixed.l - yr.l;xr.l += FFMult(dxr, tempfixed).l;	/*handle rounding*/xr.l += FixedPointFive.l;xl.l += FixedPointFive.l;rval=TRUE;do	{	if(index_left==index_right)notDone=FALSE;	if(dyl < dyr)		{		deltay=dyl;		reset=1;		dyr-=dyl;		dyl=0;		}	else if(dyr < dyl)		{		deltay=dyr;		reset=2;		dyl-=dyr;		dyr=0;		}	else		{		deltay=dyr;		reset=3;		dyl=dyr=0;		}	while(deltay--)		{		cxl = xl.intg;		cxr = xr.intg;		// MERGE-HMD [[[		#if USE_HMD		if ((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX)) 		{			if (gHMD->eye == EYE_LEFT)			{				InitPixelHMDL(pixel,cxl,ytop, to);			}			else if (gHMD->eye == EYE_RIGHT)			{				InitPixelHMDR(pixel,cxl,ytop, to);			}			else 			{				DEBUGGER();		// something bad has happened				InitPixel(pixel,cxl,ytop, to);			}		}		else			InitPixel(pixel,cxl,ytop, to);		#else		InitPixel(pixel,cxl,ytop,to);//AddPixel(pixel,rclip.left);		#endif // USE_HMD		// MERGE-HMD ]]]		dx=cxr-cxl;		if(dx>0)			{			if(pattern)				ScanFillPattern(pixel,ytop&0x01,dx,color);			else				ScanFill(pixel,ytop&0x01,dx,color);			}		//AddLinePixel(pix,to);		ytop++;				xl.l += dxl.l;		xr.l += dxr.l;		}	if(reset&1)		{		yl=ptFF[index_left].v;		xl=ptFF[index_left].h;		do	{			index_left=previousNum(index_left,plength2);			dyl = FFRound(ptFF[index_left].v) - FFRound(yl);			tempfixed.l = ptFF[index_left].v.l - yl.l;			dxl.l = ptFF[index_left].h.l - xl.l;			dxl = FFDiv(dxl, tempfixed);			}while(FFRound(yl)>FFRound(ptFF[index_left].v) && notDone && index_left!=index_right);			/*jump down to sample row*/			tempfixed.frac = 0;			tempfixed.intg = FFRound(yl);			tempfixed.l += FixedPointFive.l;			tempfixed.l = tempfixed.l - yl.l;			xl.l += FFMult(dxl, tempfixed).l;			/*handle rounding*/			xl.l += FixedPointFive.l;		}	if((reset&2) && index_left != index_right)		{		yr = ptFF[index_right].v;		xr = ptFF[index_right].h;		do	{			index_right=nextNum(index_right,plength2);			dyr = FFRound(ptFF[index_right].v) - FFRound(yr);			tempfixed.l = ptFF[index_right].v.l - yr.l;						dxr.l = ptFF[index_right].h.l - xr.l;			dxr = FFDiv(dxr, tempfixed);			}while(FFRound(yr)>FFRound(ptFF[index_right].v) && notDone && index_left!=index_right);				/*jump down to sample row*/			tempfixed.frac = 0;			tempfixed.intg = FFRound(yr);			tempfixed.l += FixedPointFive.l;			tempfixed.l = tempfixed.l - yr.l;			xr.l += FFMult(dxr, tempfixed).l;			/*handle rounding*/			xr.l += FixedPointFive.l;		}	}while(notDone);endit:if(rval && frame)	{	if(plength2>2)		{	//JAM draw frames where clipped polygon is part of original polygon[[[		j= plength2 - 1;		for(i=0;i<plength2;i++)		{			if(framearray[j])			{				FFixedFLine(to, ptFF[i].h, ptFF[i].v, ptFF[j].h, ptFF[j].v, lineColor);			}            j = i;        	#if 0			int dontdrawflag;			long templong;			dontdrawflag = 0;			templong = clipper->ScreenRect.left.l;			if ((ptFF[i].h.l == templong) && (ptFF[j].h.l == templong))				dontdrawflag = 1;			templong = clipper->ScreenRect.right.l;			if ((ptFF[i].h.l == templong) && (ptFF[j].h.l == templong))				dontdrawflag = 1;			templong = clipper->ScreenRect.top.l;			if ((ptFF[i].v.l == templong) && (ptFF[j].v.l == templong))				dontdrawflag = 1;			templong = clipper->ScreenRect.bottom.l;			if ((ptFF[i].v.l == templong) && (ptFF[j].v.l == templong))				dontdrawflag = 1;			if (!dontdrawflag)			{				FFixedFLine(to, ptFF[i].h, ptFF[i].v, ptFF[j].h, ptFF[j].v, lineColor);			   }			j = i;            #endif		}	//JAM eliminate extra screen-edge lines ]]]		}	}points->Unuse();return rval;}#endif FLATSHADE#if SMOOTHSHADE// MERGE-GOURAUD [[[#ifndef DONT_COMPILE_GOURAUD/*------------------------------------------------------------------------------------------*//**/void DefaultGouraudFillPattern(PixType pixel, long evenodd, long dx, long actual_dx, long left_unused,		// MERGE-GOURAUD-PRO-6	FFixed il, FFixed ir, GColorType *dith_a, GColorType *dith_b, unsigned short *jitter);										void DefaultGouraudFillPattern(PixType pixel, long evenodd, long dx, long actual_dx, long left_unused,		// MERGE-GOURAUD-PRO-6	FFixed il, FFixed ir, GColorType *dith_a, GColorType *dith_b, unsigned short *jitter)								{		register FFixed increment, double_increment, i, fdx, diff;int extra_pixel = FALSE;	// determine the fraction of intensity and pixels -- how much to bump the intensity	// per pixel -- note that we use the actual dx, which is the number of pixels across	// the whole scan line (i.e. it doesn't include clipping) so that our dx is correct		fdx.intg = actual_dx;	fdx.frac = 0;	diff.l = ir.l - il.l;	increment = FFDiv(diff, fdx);	// do initial increment to make our screen pattern -- do the initial skip-a-pixel	// if we need to.	if((PixVal(pixel) & 1) ^ (evenodd & 1))	{		// skip a pixel		IncPixel(pixel);				// make this pixel part of the left unused so we get the right intensity		// for the pixels we actually draw.  Remember that pixel has been inited		// based on the place we are supposed to start drawing from, so we must		// decrement dx.		left_unused++;		dx--;	}		// get the initial intensity	i = il;			// do the part that is clipped out on the left -- just increment the number of times	// (left_unused is the number of pixels on the left that are clipped out)	// (also note that pixel has been inited to the value that we are actually supposed to	// start drawing at, so we don't increment pixel here)	while (left_unused--)		i.l += increment.l;			// compute a double increment so we only have to do 1 add per pixel for the next	// intensity value	double_increment.l = (increment.l << 1);		// if dx is odd, then the following loop will not draw the last pixel in the scan	// line.  	if (dx & 1)	{		extra_pixel = TRUE;		dx--;	}			// now do the drawing -- dx is the number of pixels to actually draw	// This loop draw a pixel and then skips a pixel repeatedly.	while (dx > 0)	{	FFixed jitt;	register short jittintgpart;			// add in the jitter value		jitt.intg = 0;		jitt.frac = jitter[PixVal(pixel) & 0xF];		jitt.l += i.l;			// write the pixel		if (PixVal(pixel) & 1)			{			jittintgpart = jitt.intg;			IncSetPixel2(pixel, dith_a[jittintgpart]);            }		else			{			jittintgpart = jitt.intg;			IncSetPixel2(pixel, dith_b[jittintgpart]);            }				// skip a pixel (dither pattern fill)		IncPixel(pixel);		// increment the intensity for two pixels		i.l += double_increment.l;				// decrement dx; by 2 since we are doing a dither fill		dx -= 2;	} 			if (extra_pixel)	{	FFixed jitt;			// add in the jitter value		jitt.intg = 0;		jitt.frac = jitter[PixVal(pixel) & 0xF];		jitt.l += i.l;			// write the extra pixel -- no need to increment because this is the last pixel		if (PixVal(pixel) & 1)        	{			SetPixel2(pixel, dith_a[jitt.intg]);            }		else        	{			SetPixel2(pixel, dith_b[jitt.intg]);            }	}}							/*------------------------------------------------------------------------------------------*//**/void DefaultGouraudFill(PixType pixel, long evenodd, long dx, long actual_dx, long left_unused,		// MERGE-GOURAUD-PRO-6	FFixed il, FFixed ir, GColorType *dith_a, GColorType *dith_b, unsigned short *jitter,	long *jitter_diffs);										void DefaultGouraudFill(PixType pixel, long evenodd, long dx, long actual_dx, long left_unused,		// MERGE-GOURAUD-PRO-6	FFixed il, FFixed ir, GColorType *dith_a, GColorType *dith_b, unsigned short *jitter,	long *jitter_diffs)								{		FFixed fdx, diff;register long increment, big_increment, i;	// pretend these are FFixedlong adx;		// MERGE-GOURAUD-PRO-10	// determine the fraction of intensity and pixels -- how much to bump the intensity	// per pixel		fdx.intg = actual_dx;	fdx.frac = 0;	diff.l = ir.l - il.l;	increment = FFDiv(diff, fdx).l;		// get the initial intensity	i = il.l;			// do the part that is clipped out on the left -- just increment the number of times	// (left_unused is the number of pixels on the left that are clipped out)	// (also note that pixel has been inited to the value that we are actually supposed to	// start drawing at, so we don't increment pixel here)	while (left_unused--)		i += increment;			// if we are on a long word boundary, then do the long span	if ((PixVal(pixel) & 0x3) == 0) goto long_span;		// how many pixels in the first short span?	// We've already tested for being on a long word boundary, so this test will either be	// 1, 2, or 3.  It can't be 0 because then the long word test would have succeeded.  It	// can't be 4 for the same reason.   	adx = 4 - (PixVal(pixel) & 0x3);		// make sure that adx is not greater than dx -- we only want to do dx pixels at the	// most, so clamp adx to dx.  This way if adx is greater than dx, then adx will be set	// to dx, and then dx (in the next line) will be set to zero.	if (adx > dx)		adx = dx;		// subtract out how many pixels we are going to do	// note that adx cannot be bigger than dx because of the previous statement, so this will	// make dx zero at the very least (dx will not be negative as a result of this)	// (this is done now because adx is modified in the loop)	dx -= adx;		// at this point we have 1, 2, or 3 pixels to do.  Use a switch statement without break	// statements (loop unrolling)		switch (adx)	{	register long jitt;		case 3:			jitt = jitter[PixVal(pixel) & 0xF]; jitt += i;			#if USE_JITTER_VALS_NO_DITHER				IncSetPixel2(pixel, dith_a[jitt >> 16]);			#else				if (PixVal(pixel) & 1) { IncSetPixel2(pixel, dith_a[jitt >> 16]); }				else { IncSetPixel2(pixel, dith_b[jitt >> 16]); }			#endif			i += increment;			// NOTE lack of break statement is intentional					case 2:			jitt = jitter[PixVal(pixel) & 0xF]; jitt += i;			#if USE_JITTER_VALS_NO_DITHER				IncSetPixel2(pixel, dith_a[jitt >> 16]);			#else				if (PixVal(pixel) & 1) { IncSetPixel2(pixel, dith_a[jitt >> 16]); }				else { IncSetPixel2(pixel, dith_b[jitt >> 16]); }			#endif			i += increment;			// NOTE lack of break statement is intentional					case 1:			jitt = jitter[PixVal(pixel) & 0xF]; jitt += i;			#if USE_JITTER_VALS_NO_DITHER				IncSetPixel2(pixel, dith_a[jitt >> 16]);			#else				if (PixVal(pixel) & 1) { IncSetPixel2(pixel, dith_a[jitt >> 16]); }				else { IncSetPixel2(pixel, dith_b[jitt >> 16]); }			#endif			i += increment;			// NOTE lack of break statement is intentional	}long_span:	// if there is not enough pixels left to fill a long word then do the short span	if (dx < 16) goto short_span;		// compute how many longs we need to do	adx = (dx >> 4);		// subtract out how many pixels we are going to do (long words)	// (this is done now because adx is modified in the loop)	dx -= (adx << 4);		big_increment = (increment << 4);		// large span -- fill long words	while (adx--)	{	register long jitt;	#if USE_JITTER_VALS_NO_DITHER	long *jitt_diffs = &(jitter_diffs[PixVal(pixel) & 0x7]);	#else	long *jitt_diffs = &(jitter_diffs[(PixVal(pixel) >> 1) & 0x7]);	#endif			// note that the dith_ values are hard-coded here.  Obviously if we are on a long		// word boundary, then the first dither value is even (i.e. dith_b), the next odd, etc.				// 1st two pixels use the same jitter value				jitt = i;		jitt += jitter[PixVal(pixel) & 0xF];				IncSetPixel2(pixel, dith_b[jitt >> 16]);		jitt += increment;		IncSetPixel2(pixel, dith_a[jitt >> 16]);		// 2nd two pixels use the next jitter value, so increment jitt by jitt_diffs		jitt += (*jitt_diffs++);		jitt += increment;		IncSetPixel2(pixel, dith_b[jitt >> 16]);		jitt += increment;		IncSetPixel2(pixel, dith_a[jitt >> 16]);		// 3rd two pixels use the next jitter value, so increment jitt by jitt_diffs		jitt += (*jitt_diffs++);		jitt += increment;		IncSetPixel2(pixel, dith_b[jitt >> 16]);		jitt += increment;		IncSetPixel2(pixel, dith_a[jitt >> 16]);		// 4th two pixels use the next jitter value, so increment jitt by jitt_diffs		jitt += (*jitt_diffs++);		jitt += increment;		IncSetPixel2(pixel, dith_b[jitt >> 16]);		jitt += increment;		IncSetPixel2(pixel, dith_a[jitt >> 16]);		// 5th two pixels use the next jitter value, so increment jitt by jitt_diffs		jitt += (*jitt_diffs++);		jitt += increment;		IncSetPixel2(pixel, dith_b[jitt >> 16]);		jitt += increment;		IncSetPixel2(pixel, dith_a[jitt >> 16]);		// 6th two pixels use the next jitter value, so increment jitt by jitt_diffs		jitt += (*jitt_diffs++);		jitt += increment;		IncSetPixel2(pixel, dith_b[jitt >> 16]);		jitt += increment;		IncSetPixel2(pixel, dith_a[jitt >> 16]);		// 7th two pixels use the next jitter value, so increment jitt by jitt_diffs		jitt += (*jitt_diffs++);		jitt += increment;		IncSetPixel2(pixel, dith_b[jitt >> 16]);		jitt += increment;		IncSetPixel2(pixel, dith_a[jitt >> 16]);		// 8th two pixels use the next jitter value, so increment jitt by jitt_diffs		jitt += (*jitt_diffs);		jitt += increment;		IncSetPixel2(pixel, dith_b[jitt >> 16]);		jitt += increment;		IncSetPixel2(pixel, dith_a[jitt >> 16]);				// increment i by the multiple-pixel increment		i += big_increment;	}short_span:		// up to 7 pixels to do here	// we know that if we got here, then we are on an even word boundary, but we are	// doing fewer than 8 pixels (i.e. 7 or fewer).  So we do them in pairs.	// compute how many pairs of pixels to do	adx = (dx >> 1);		// subtract the number of pairs from dx	dx -= (adx << 1);	// loop through the pairs -- note that since we know we are on a even word boundary,	// we can hard-code the dith_a and dith_b values	while (adx--)	{	register long jitt;		jitt = jitter[PixVal(pixel) & 0xF]; jitt += i;		IncSetPixel2(pixel, dith_b[jitt >> 16]);		i += increment;				jitt = jitter[PixVal(pixel) & 0xF]; jitt += i;		IncSetPixel2(pixel, dith_a[jitt >> 16]);		i += increment;	}		// do the last pixel -- at this point dx will be 0 or 1	if (dx)	{	register long jitt;		jitt = jitter[PixVal(pixel) & 0xF]; jitt += i;		SetPixel2(pixel, dith_b[jitt >> 16]);		// note no need to do IncSet		// note no need to increment i	}}							/*------------------------------------------------------------------------------------------*//* GOURAUD SHADING *//*------------------------------------------------------------------------------------------*//*	Gouraud shading works based on the intensity values passed in in the V_Array 'intensities'.	These intensities correspond to the screen points 'points' array passed in.  	Intensity values are indices into the TextureShader and go from 0..MAX_TEXTURE_SHADING_LEVELS-1.	Right now this is from 0..31.		Note that for gouraud shading, because we use the shading table, we need the unshaded rgb	value for this poly, so rgb is unshaded.*//*------------------------------------------------------------------------------ *int FlashGouraud(V_Offscreen *to,V_Array *points,V_Array *intensities, *	unsigned char rgb_index,RGBColor *lineColor,int mode,int pattern) *------------------------------------------------------------------------------*/int FlashGouraud(V_Offscreen *to,V_Array *points,V_Array *intensities,	unsigned char rgb_index, RGBColor *lineColor,int mode,int pattern){Clip *clipper, *newClip;Rect r;	clipper = new(Clip);	clipper->cClip();	to->GetRect(&r);	newClip = clipper->CreateInitialClip(&r);	FlashGouraudClip(to, points, intensities, rgb_index, lineColor, newClip, mode, pattern);	newClip->dClip();	clipper->dClip();}/*------------------------------------------------------------------------------ * int FlashGouraudClip(V_Offscreen *to,V_Array *points,V_Array *intensities, * 	unsigned char rgb_index,RGBColor *lineColor,Clip *clipper, int mode,int pattern) *------------------------------------------------------------------------------*/int FlashGouraudClip(V_Offscreen *to,V_Array *points,V_Array *intensities,	unsigned char rgb_index,RGBColor *lineColor,Clip *clipper, int mode,int pattern){long plength, plength2, templong;int index_left=0,index_right;Point *pt;VColorType color;//PixType pix;PixType pixel;int dyl, dyr;FFixed tempfixed, xl, xr, yl, yr;int deltay,reset;int dx;int cxl;int cxr;int i,j;Rect rclip; int cleft,cright;int ytop;struct ClipStruct *clip;int cliptop,clipbottom,clipindex;int notDone=TRUE;int rval=FALSE;int frame;int dither;PointFFixed *ClipShapePtr, *ptFF;LineData *LineEqtnsPtr;FFixed leftXFF, rightXFF, rdxFF, ldxFF, tempxFF, tempyFF;FFixed total_dy_left, total_dy_right, dx_per_dy_left, dx_per_dy_right;// GOURAUD [[[FFixed current_inten_left, next_inten_left, di_per_dy_left, total_di_left;FFixed current_inten_right, next_inten_right, di_per_dy_right, total_di_right;GColorType gcolor;						// GOURAUD -- note GColorType (unsigned char, 0.255, color index)FFixed *inten, *clipped_inten;			// GOURAUDGColorType dith_a[34], dith_b[34], dith_c[34], dith_d[34];	// GOURAUDextern TextureShader gTextureShader;		// GOURAUDFFixed leftIFF, rightIFF, rdiFF, ldiFF, tempiFF;		// GOURAUDFFixed til,tir;							FFixed dil,odil,ddil,dir,odir,ddir;		// GOURAUDFFixed il,ir;							// GOURAUD// GOURAUD ]]]plength=points->ALength();if(plength <= 2) return TRUE;if (clipper->reject) return TRUE;frame=mode&CLIP_FRAME;dither=mode&CLIP_DITHER;if(plength<=2||!(mode&CLIP_FILL))	if(frame)		{		plength--;		if(plength>1)			{			pt=(Point *)points->Use();			for(i=0;i<plength;i++)				FLineClip(to,pt[i].h,pt[i].v,pt[i+1].h,pt[i+1].v,lineColor,clipper);			FLineClip(to,pt[0].h,pt[0].v,pt[plength].h,pt[plength].v, lineColor,clipper);			points->Unuse();			}		return TRUE;		}else return FALSE;pt=(Point *)points->Use();inten = (FFixed *)intensities->Use();		// GOURAUD// GOURAUD [[[ DEBUG// check intensities for validityfor(i=0;i<plength;i++)	{		ASSERT(inten[i].l >= 0);		if (inten[i].l < 0) inten[i].l = (long)0;		ASSERT(inten[i].l < ((long)32 << (long)16));		if (inten[i].l >= ((long)32 << (long)16)) { inten[i].intg = 31; inten[i].frac = 0; }	}// GOURAUD ]]] DEBUG//templong = clipper->ClipShape->ALength();//ptFF = InitFlashTemporaryArray(templong + plength + (long)1);if(clipper->GouraudClipToPoly(pt, plength, &ptFF, &plength2, inten, &clipped_inten, 0) == REJECT){	points->Unuse();	intensities->Unuse();	// GOURAUD	return TRUE;}// GOURAUD [[[ DEBUG// check clipped intensities for validityfor(i=0;i<plength2;i++)	{		ASSERT(clipped_inten[i].l >= 0);		if (clipped_inten[i].l < 0) clipped_inten[i].l = (long)0;		ASSERT(clipped_inten[i].l < ((long)32 << (long)16));		if (clipped_inten[i].l >= ((long)32 << (long)16)) 			{ clipped_inten[i].intg = 31; clipped_inten[i].frac = 0; }	}// GOURAUD ]]] DEBUGfor(i=1;i<plength2;i++)	{	if(ptFF[index_left].v.l>ptFF[i].v.l)index_left=i;	}index_right=index_left;j=0;while(FFRound(ptFF[index_left].v)==FFRound(ptFF[i=previousNum(index_left,plength2)].v) && ++j<plength2)index_left=i;if(j==plength2)goto endit;j=0;while(FFRound(ptFF[index_right].v)==FFRound(ptFF[i=nextNum(index_right,plength2)].v) && ++j<plength2)index_right=i;if(j==plength2)goto endit;xl=ptFF[index_left].h;yl=ptFF[index_left].v;xr=ptFF[index_right].h;yr=ptFF[index_right].v;current_inten_left = clipped_inten[index_left];		// GOURAUDcurrent_inten_right = clipped_inten[index_right];		// GOURAUDindex_left=previousNum(index_left,plength2);index_right=nextNum(index_right,plength2);next_inten_left = clipped_inten[index_left];		// GOURAUDnext_inten_right = clipped_inten[index_right];		// GOURAUDytop = FFRound(yl);InitColorIndex(gcolor,rgb_index);		// GOURAUD -- init the texture shader color index (0..255)//InitColorBrush(color,rgb);//InitPixel(pix,0,tlv,to);dyl = FFRound(ptFF[index_left].v) - FFRound(yl);dyr = FFRound(ptFF[index_right].v) - FFRound(yr);total_dy_left.l = ptFF[index_left].v.l - yl.l;dx_per_dy_left.l = ptFF[index_left].h.l - xl.l;ASSERT(total_dy_left.l != 0);dx_per_dy_left = FFDiv(dx_per_dy_left, total_dy_left);total_dy_right.l = ptFF[index_right].v.l - yr.l;dx_per_dy_right.l = ptFF[index_right].h.l - xr.l;ASSERT(total_dy_right.l != 0);dx_per_dy_right = FFDiv(dx_per_dy_right, total_dy_right);// GOURAUD [[[total_di_left.l = next_inten_left.l - current_inten_left.l ;total_di_right.l = next_inten_right.l - current_inten_right.l;ASSERT(total_dy_left.l != 0);		// GOURAUD DEBUGdi_per_dy_left = FFDiv(total_di_left, total_dy_left);ASSERT(total_dy_right.l != 0);		// GOURAUD DEBUGdi_per_dy_right = FFDiv(total_di_right, total_dy_right);// GOURAUD ]]]/*handle vertical rounding*//*jump down to sample row*/tempfixed.frac = 0;tempfixed.intg = FFRound(yl);tempfixed.l += FixedPointFive.l;tempfixed.l = tempfixed.l - yl.l;xl.l += FFMult(dx_per_dy_left, tempfixed).l;current_inten_left.l += FFMult(di_per_dy_left,tempfixed).l;tempfixed.frac = 0;tempfixed.intg = FFRound(yr);tempfixed.l += FixedPointFive.l;tempfixed.l = tempfixed.l - yr.l;xr.l += FFMult(dx_per_dy_right, tempfixed).l;current_inten_right.l += FFMult(di_per_dy_right,tempfixed).l;/*handle rounding*/xr.l += FixedPointFive.l;xl.l += FixedPointFive.l;// GOURAUD [[[// fill in the local dither arrays -- fill in two 0 values, and two 31 values, to avoid overflowdith_a[0] = GetGouraudDither(0, 0, gcolor);dith_b[0] = GetGouraudDither(1, 0, gcolor);dith_c[0] = GetGouraudDither(2, 0, gcolor);dith_d[0] = GetGouraudDither(3, 0, gcolor);for ( i = 0 ; i < 32 ; i++ ) 	//jam altered{	dith_a[i+1] = GetGouraudDither(0, i, gcolor);	dith_b[i+1] = GetGouraudDither(1, i, gcolor);	dith_c[i+1] = GetGouraudDither(2, i, gcolor);	dith_d[i+1] = GetGouraudDither(3, i, gcolor);}dith_a[33] = GetGouraudDither(0, 31, gcolor);dith_b[33] = GetGouraudDither(1, 31, gcolor);dith_c[33] = GetGouraudDither(2, 31, gcolor);dith_d[33] = GetGouraudDither(3, 31, gcolor);// GOURAUD ]]]rval=TRUE;do	{	if(index_left==index_right)notDone=FALSE;	if(dyl < dyr)		{		deltay=dyl;		reset=1;		dyr-=dyl;		dyl=0;		}	else if(dyr < dyl)		{		deltay=dyr;		reset=2;		dyl-=dyr;		dyr=0;		}	else		{		deltay=dyr;		reset=3;		dyl=dyr=0;		}	while(deltay--)		{		cxl = xl.intg;		cxr = xr.intg;		// GOURAUD DEBUG [[[		ASSERT(current_inten_left.l >= 0);		ASSERT(current_inten_left.l < ((long)32 << (long)16));		ASSERT(current_inten_right.l >= 0);		ASSERT(current_inten_right.l < ((long)32 << (long)16));		// GOURAUD DEBUG ]]]		// MERGE-HMD [[[		#if USE_HMD		if ((gUseHMDs) && (gHMD) && (gHMD->GetType() == HMD_VREX)) 		{			if (gHMD->eye == EYE_LEFT)			{				InitPixelHMDL(pixel,cxl,ytop, to);			}			else if (gHMD->eye == EYE_RIGHT)			{				InitPixelHMDR(pixel,cxl,ytop, to);			}			else 			{				DEBUGGER();		// something bad has happened				InitPixel(pixel,cxl,ytop, to);			}		}		else			InitPixel(pixel,cxl,ytop, to);		#else		InitPixel(pixel,cxl,ytop,to);//AddPixel(pixel,cxl);		#endif // USE_HMD		// MERGE-HMD ]]]		dx=cxr-cxl;		if(dx>0)			{			extern unsigned short gJitterVals[8][16];	// GOURAUD			extern long gJitterDiffs[8][16];	// GOURAUD			extern unsigned short gJitterValsNoDither[8][8];	// GOURAUD				if(pattern)/*dithered fill (every other pixel)*/					GouraudFillPattern(pixel, (long)ytop, (long)dx, (long)dx, (long)0, current_inten_left, current_inten_right, 	// MERGE-GOURAUD-PRO-6						&(dith_a[1]), &(dith_b[1]), (unsigned short *)(&(gJitterVals[(ytop >> 1) & 0x7])));				else				{				#if USE_JITTER_VALS_NO_DITHER					if (ytop & 0x1)						GouraudFill(pixel, (long)ytop, (long)dx, (long)dx, (long)0, current_inten_left, current_inten_right, 	// MERGE-GOURAUD-PRO-6						&(dith_a[1]), &(dith_b[1]), (unsigned short *)(&(gJitterValsNoDither[ytop & 0x7])),						(long *)(&(gJitterDiffs[ytop & 0x7])));					else						GouraudFill(pixel, (long)ytop, (long)dx, (long)dx, (long)0, current_inten_left, current_inten_right, 	// MERGE-GOURAUD-PRO-6						&(dith_c[1]), &(dith_d[1]), (unsigned short *)(&(gJitterValsNoDither[ytop & 0x7])),						(long *)(&(gJitterDiffs[ytop & 0x7])));				#else					if (ytop & 0x1)						GouraudFill(pixel, (long)ytop, (long)dx, (long)dx, (long)0, current_inten_left, current_inten_right, 	// MERGE-GOURAUD-PRO-6						&(dith_a[1]), &(dith_b[1]), (unsigned short *)(&(gJitterVals[(ytop >> 1) & 0x7])),						(long *)(&(gJitterDiffs[(ytop >> 1) & 0x7])));					else						GouraudFill(pixel, (long)ytop, (long)dx, (long)dx, (long)0, current_inten_left, current_inten_right, 	// MERGE-GOURAUD-PRO-6						&(dith_c[1]), &(dith_d[1]), (unsigned short *)(&(gJitterVals[(ytop >> 1) & 0x7])),						(long *)(&(gJitterDiffs[(ytop >> 1) & 0x7])));				#endif				}			}		//AddLinePixel(pix,to);		ytop++;				xl.l += dx_per_dy_left.l;		xr.l += dx_per_dy_right.l;		// GOURAUD [[[		current_inten_left.l += di_per_dy_left.l;		current_inten_right.l += di_per_dy_right.l;		// GOURAUD ]]]		// GOURAUD DEBUG [[[		if (deltay)		{			ASSERT(current_inten_left.l >= 0);			ASSERT(current_inten_left.l < ((long)32 << (long)16));			ASSERT(current_inten_right.l >= 0);			ASSERT(current_inten_right.l < ((long)32 << (long)16));		}		// GOURAUD DEBUG ]]]		}	if(reset&1)		{		yl=ptFF[index_left].v;		xl=ptFF[index_left].h;		current_inten_left = clipped_inten[index_left];		// GOURAUD		do	{			index_left=previousNum(index_left,plength2);			dyl = FFRound(ptFF[index_left].v) - FFRound(yl);			total_dy_left.l = ptFF[index_left].v.l - yl.l;			dx_per_dy_left.l = ptFF[index_left].h.l - xl.l;			//ASSERT(total_dy_left.l != 0);	// GOURAUD DEBUG			dx_per_dy_left = FFDiv(dx_per_dy_left, total_dy_left);			}while(FFRound(yl)>FFRound(ptFF[index_left].v) && notDone && index_left!=index_right);						/*jump down to sample row*/			tempfixed.frac = 0;			tempfixed.intg = FFRound(yl);			tempfixed.l += FixedPointFive.l;			tempfixed.l = tempfixed.l - yl.l;			xl.l += FFMult(dx_per_dy_left, tempfixed).l;			/*handle rounding*/			xl.l += FixedPointFive.l;			// GOURAUD [[[			next_inten_left = clipped_inten[index_left];			total_di_left.l = next_inten_left.l - current_inten_left.l ;			//ASSERT(total_dy_left.l != 0);	// GOURAUD DEBUG			di_per_dy_left = FFDiv(total_di_left, total_dy_left);			current_inten_left.l += FFMult(di_per_dy_left,tempfixed).l;			// GOURAUD DEBUG [[[			#if 0			ASSERT(current_inten_left.l >= 0);			ASSERT(current_inten_left.l < ((long)32 << (long)16));			ASSERT(current_inten_right.l >= 0);			ASSERT(current_inten_right.l < ((long)32 << (long)16));			ASSERT(next_inten_left.l >= 0);			ASSERT(next_inten_left.l < ((long)32 << (long)16));			ASSERT(next_inten_right.l >= 0);			ASSERT(next_inten_right.l < ((long)32 << (long)16));			#endif			// GOURAUD DEBUG ]]]			// GOURAUD ]]]		}	if((reset&2) && index_left != index_right)		{		yr = ptFF[index_right].v;		xr = ptFF[index_right].h;		current_inten_right = clipped_inten[index_right];	// GOURAUD		do	{			index_right=nextNum(index_right,plength2);			dyr = FFRound(ptFF[index_right].v) - FFRound(yr);					total_dy_right.l = ptFF[index_right].v.l - yr.l;			dx_per_dy_right.l = ptFF[index_right].h.l - xr.l;			//ASSERT(total_dy_right.l != 0);	// GOURAUD DEBUG			dx_per_dy_right = FFDiv(dx_per_dy_right, total_dy_right);			}while(FFRound(yr)>FFRound(ptFF[index_right].v) && notDone && index_left!=index_right);							/*jump down to sample row*/			tempfixed.frac = 0;			tempfixed.intg = FFRound(yr);			tempfixed.l += FixedPointFive.l;			tempfixed.l = tempfixed.l - yr.l;			xr.l += FFMult(dx_per_dy_right, tempfixed).l;			/*handle rounding*/			xr.l += FixedPointFive.l;			// GOURAUD [[[			next_inten_right = clipped_inten[index_right];			total_di_right.l = next_inten_right.l - current_inten_right.l;			//ASSERT(total_dy_right.l != 0);	// GOURAUD DEBUG			di_per_dy_right = FFDiv(total_di_right, total_dy_right);			current_inten_right.l += FFMult(di_per_dy_right,tempfixed).l;			// GOURAUD DEBUG [[[			#if 0			ASSERT(current_inten_left.l >= 0);			ASSERT(current_inten_left.l < ((long)32 << (long)16));			ASSERT(current_inten_right.l >= 0);			ASSERT(current_inten_right.l < ((long)32 << (long)16));			ASSERT(next_inten_left.l >= 0);			ASSERT(next_inten_left.l < ((long)32 << (long)16));			ASSERT(next_inten_right.l >= 0);			ASSERT(next_inten_right.l < ((long)32 << (long)16));			#endif			// GOURAUD DEBUG ]]]			// GOURAUD ]]]		}	}while(notDone);endit:// GOURAUD -- NOTE THAT GOURAUD SHADED POLYS HAVE NO FRAMESpoints->Unuse();intensities->Unuse();	// GOURAUDreturn rval;}#endif // DONT_COMPILE_GOURAUD// MERGE-GOURAUD ]]]#endif //SMOOTHSHADE