/* GDIOBJ.H -- GDI-related structuresLocal object types:	GDIOBJHDR/GDIOBJDBG	BRUSHOBJ	PENOBJ	PALETTEOBJ	FONTOBJ	BITMAPOBJ    DC        from Chapter 8 of "Undocumented Windows"  (Addison-Wesley, 1992)by Andrew Schulman, Dave Maxey and Matt Pietrek.Copyright (c) Dave Maxey 1992*/#ifdef __cplusplusextern "C" {#endif/*	Pull this in from gdidefs.inc; rename to GdiPbitmap to avoid hassles. Leave comment openBITMAP		struc							    ;*/ typedef struct {		 /*  bmType	    dw	0	; 0 means main memory bitmap.  Non-zero     ;*/ short int bmType;		 /*				; is number of physical display and format				; of the rest of the structure known only				; to device driver  bmWidth	    dw	0	; Width of bitmap in pixels		    ;*/ unsigned short int bmWidth;	 /*  bmHeight	    dw	0	; Height of bitmap in pixels		    ;*/ unsigned short int bmHeight;	 /*  bmWidthBytes	    dw	0	; #bytes per scan line			    ;*/ unsigned short int bmWidthBytes; /*  bmPlanes	    db	0	; # of planes in bitmap 		    ;*/ BYTE		   bmPlanes;	 /*  bmBitsPixel	    db	0	; # of bits per pixel			    ;*/ BYTE		   bmBitsPixel;  /*  bmBits	    dd	0	; Far pointer to bits of main memory bitmap ;*/ BYTE FAR	  *bmBits;	 /*  bmWidthPlanes     dd	0	; Product of bmWidthBytes and bmHeight	    ;*/ unsigned long int  bmWidthPlanes;/*  bmlpPDevice	    dd	0	; Pointer to associated PDevice 	    ;*/ BYTE FAR	  *bmlpPDevice;  /*  bmSegmentIndex    dw	0	; Index to plaens next segment if non-zero  ;*/ unsigned short int bmSegmentIndex; /*  bmScanSegment     dw	0	; Number of scans per segment		    ;*/ unsigned short int bmScanSegment; /*  bmFillBytes	    dw	0	; Number of unused bytes per segment	    ;*/ unsigned short int bmFillBytes;   /*		    dw	0						    ;*/ unsigned short int futureUse4;	  /*		    dw	0						    ;*/ unsigned short int futureUse5;	  /*BITMAP		    ends						    ;*/ } GDIPBITMAP, FAR *LPGDIPBITMAP;// Minimum allocation for any object appears to be 16h bytestypedef struct tagGDIOBJHDR {	HANDLE		hNext;      // 00h Handle to next (sometimes flags in 3.0)	WORD		wMagic;		// 02h Obj type in 3.0, Magic in 3.1	DWORD		dwCount;	// 04h Sequence number	WORD		wMetaList;	// 08h	} GDIOBJHDR, FAR *LPGDIOBJHDR;	// 0Ah totaltypedef struct tagGDIOBJDBG {	HANDLE		hNext;		// 00h Handle to next (sometimes flags in 3.0)	WORD		wMagic;		// 02h Obj type in 3.0, Magic in 3.1	DWORD		dwCount;	// 04h Sequence number	WORD		wMetaList;	// 08h	WORD		wSelCount;	// 0Ah Count of times selected???	HANDLE		hOwner;		// 0Ch Owning task	} GDIOBJDBG, FAR *LPGDIOBJDBG;	// 0Eh total	// NOTE all offsets after 'header' from here on in this file will be// 4 bytes more when 3.1 DEBUG version is runningtypedef struct tagBRUSHOBJ {	GDIOBJHDR	header;		// 00h	LOGBRUSH	logbrush;	// 0Ah	COLORREF	crHatchBk;	// 12h extra DWord for hatched brush color	}	BRUSHOBJ, FAR *LPBRUSHOBJ;	// 1Ah totaltypedef struct tagPENOBJ {	GDIOBJHDR	header;		// 00h	LOGPEN		logpen;		// 0Ah	} PENOBJ, FAR *LPPENOBJ;		// 16h totaltypedef struct tagPALETTEOBJ {	GDIOBJHDR	header;		// 00h	LOGPALETTE	logpalette;	// 0Ah	} PALETTEOBJ, FAR *LPPALETTEOBJ;// size depends on logpalettetypedef struct tagFONTOBJ {	GDIOBJHDR	header;		// 00h	LOGFONT		logfont;	// 0Ah	} FONTOBJ, FAR *LPFONTOBJ;		// size depends on strlen(typeface name) 	typedef struct tagRGNOBJ {	GDIOBJHDR	header;		// 00h//	RGN			rgn;		// 0Ah	} RGNOBJ, FAR *LPRGNOBJ;typedef struct tagBITMAPOBJ {	GDIOBJHDR	header;		// 00h	HANDLE		hmemBitmap;	// 0Ah	BOOL		bSelected;	// 0Ch Currently selected into a DC ???	HANDLE		h0E;		// 0Eh Unknown handle (not hDC as in book)	} BITMAPOBJ, FAR *LPBITMAPOBJ;typedef struct tagDC {	GDIOBJHDR	header;		// 00h 	BYTE	byFlags;		// 0Ah	BYTE	byFlags2;		// 0Bh	HANDLE	hMetaFile;		// 0Ch	HRGN	hrgnClip;		// 0Eh handle to (reclangular) clip region	HANDLE	hPDevice;		// 10h Phys device handle	HANDLE	hLPen;			// 12h Log. pen	HANDLE	hLBrush;		// 14h Log. brush	HANDLE	hLFont;			// 16h Log. Font	HANDLE	hBitmap;		// 18h Selected bitmap	HANDLE	dchPal;			// 1Ah Selected palette	HANDLE	hLDevice;		// 1Ch Log. device	HRGN	hRaoClip;		// 1Eh clip region	HANDLE	hPDeviceBlock;	// 20h	HANDLE	hPPen;			// 22h Phys. pen	HANDLE	hPBrush;		// 24h Phys. brush	HANDLE	hPFontTrans;	// 26h 	HANDLE	hPFont;			// 28h Phys. font	LPVOID	lpPDevice;		// 2Ah 	WORD	pLDevice;		// 2Eh near pointer to log. device info	WORD	pRaoClip;		// 30h near pointer to clip region	WORD	pPDeviceBlock;	// 32h near pointer to GDIINFO	WORD	pPPen;			// 34h 	WORD	pPBrush;		// 36h 	WORD	pPFontTrans;	// 38h near pointer to hPFontTrans	LPVOID	lpPFont;		// 3Ah Font engine entrypoint	int		nPFTIndex;		// 3Eh 	LPVOID	Transform;		// 40h 	/* Begin DRAWMODE structure - see DDK doc */	WORD	wROP2;			// 44h Raster Op drawing mode	WORD	wBkMode;		// 46h Background mode (opaque/transparent)	DWORD	dwBkColor;		// 48h Phys. Background color	DWORD	dwTextColor;	// 4Ch Phys. text color	int		nTBreakExtra;	// 50h Text padding for ExtTextOut justification	int		nBreakExtra;	// 52h pad per break = nTBreakExtra / BreakCount	WORD	wBreakErr;		// 54h SetTextJustify called with nBreakExtra = 0?	int		nBreakRem;		// 56h remainder of nTBreakExtra / nBreakCount	int		nBreakCount;	// 58h Count of break characters in string	int		nCharExtra;		// 5Ah Per char additional padding	DWORD	crLbkColor;		// 5Ch Logical background color	DWORD	crLTextColor;	// 60h Logical text color	/* End DRAWMODE structure */	int		LCursPosX;		// 64h Log curs pos X	int		LCursPosY;		// 66h Log curs pos Y	int		WndOrgX; 		// 68h window origin X	int		WndOrgY;		// 6Ah window origin Y	int		WndExtX;		// 6Ch window width	int		WndExtY;		// 6Eh window height	int		VportOrgX;		// 70h viewport origin X	int		VportOrgY;		// 72h viewport origin Y	int		VportExtX;		// 74h viewport width	int		VportExtY;		// 76h viewport height	int		UserVptOrgX;	// 78h (USER/user ??) viewport origin X	int		UserVptOrgY;	// 7Ah (USER/user ??) viewport origin Y	WORD	wMapMode;		// 7Ch mapping mode	WORD	wXFormFlags;	// 7Eh 	WORD	wRelAbs;		// 80h Relative/absolute mode	WORD	wPolyFillMode;	// 82h Polygon fill mode	WORD	wStretchBltMode;// 84h Bitblt stretch mode	BYTE	byPlanes;		// 86h for DC	BYTE	byBitsPix;		// 87h for DC	WORD	wPenWidth;		// 88h pen width in pix	WORD	wPenHeight;		// 8Ah pen width in pix	WORD	wTextAlign;		// 8Ch Text alignment flags	DWORD	dwMapperFlags;	// 8Eh 	WORD	wBrushOrgX;		// 92h brush origin X	WORD	wBrushOrgY;		// 94h brush origin Y	WORD	wFontAspectX;	// 96h one half of font aspect ratio	WORD	wFontAspectY;	// 98h other half of font aspect ratio	HANDLE	hFontWeights;	// 9Ah handle to font weights	WORD	wDCSaveLevel;	// 9Ch depth of stack of saved DCSAVEs	WORD	wcDCLocks;		// 9Eh count of locks on DC	HRGN	hVisRgn;		// A0h Handle to visible region	WORD	wDCOrgX;		// A2h DC origin X	WORD	wDCOrgY;		// A4h DC origin Y	FARPROC	lpfnPrint;		// A6h print driver entrypoint	WORD	wDCLogAtom;		// AAh Logical device driver name atom	WORD	wDCPhysAtom;	// ACh Physical device name atom	WORD	wDCFileAtom;	// AEh FILE: port file name atom	WORD	wPostScaleX;	// B0h 	WORD	wPostScaleY;	// B2h 	union {		struct {			// 3.0 fields from here			WORD	wB4;			// B4h			RECT	rectB6;			// B6h rect			WORD	wDCGlobFlags;	// BEh Bit 0 indicates DC dirty			WORD	wC0;			// C0h			} tail_3_0;		// 3.0 size: C2h total		struct {			// 3.1 fields from here			RECT	rectBounds;		// B4h Bounds rect			RECT	rectLVB;		// BCh "logical video buffer"			FARPROC	lpfnNotify;		// C4h Hook func			LPSTR	lpHookData;		// C8h hook data			WORD	wDCGlobFlags;	// CCh Bit 0 indicates DC dirty			HDC		hDCNext;		// CEh Next DC in linked list - Debug only			} tail_3_1;		// 3.1 size: CEh total nondebug, D6h debug		} dc_tail;	} DC, FAR *LPDC;	#ifdef __cplusplus}#endif