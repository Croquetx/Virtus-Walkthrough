/*------------------------------------------------------------------------------ * VWINDOWSÂ - the window object toolbox * * Copyright c 1991 by Virtus Corporation * All Rights Reserved * Written by David A. Smith * Virtus Corporation * 117 Edinburgh So * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * F4.c *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VMath.h"#include "VToolBox.h"#include "VDisplay.h"#include "VGUtil.h"#include "Clip.h"#include "Flash.h"#include "Gouraud.h"		// MERGE-GOURAUD/*------------------------------------------------------------------------------ * Define the function names *------------------------------------------------------------------------------ */#define FLine FLine4#define FLineClip FLineClip4#define FlashFill FlashFill4#define FlashClip FlashClip4#define FFixedFLine FFixedFLine4#define FlashGouraud 		FlashGouraud4			// MERGE-GOURAUD#define FlashGouraudClip 	FlashGouraudClip4		// MERGE-GOURAUD/*------------------------------------------------------------------------------ * Define the two major data types. *------------------------------------------------------------------------------ */typedef ULong VColorType[2];typedef unsigned char GColorType;		// MERGE-GOURAUDtypedef struct 	PixType{unsigned char * pixel;						int hilo;						} PixType;/*------------------------------------------------------------------------------ * Define the pixel routines. * For additional information about this code, see the Flash.c sources. *------------------------------------------------------------------------------ */#define InitColorPen(color,rgb) {color[0]=offscreen->GetNoDither(rgb); \	color[1]=(color[0]>>16)|(color[0]&0xFFFF0000);	\	color[0]=(color[0]<<16)|(color[0]&0x0000FFFF);	\	}#define InitColorBrush(color,rgb) {color[0]=offscreen->GetDither(rgb); \	color[1]=(color[0]>>16)|(color[0]&0xFFFF0000);	\	color[0]=(color[0]<<16)|(color[0]&0x0000FFFF);	\	}// MERGE-GOURAUD [[[// this macro inits the color index based on the rgb -- index will range from 0..255// at most, and will be less for bit depths 1/2/4.  The index is an index into the standard color// table; index is an unsigned char, rgb is an RGBColor#define InitColorIndex(index,rgb) { index = rgb; }// MERGE-GOURAUD ]]]#define InitPixel(pix,xval,yval,to) {pix.pixel=(unsigned char*)to->baseAddress; \	pix.pixel+=((xval-to->xOffset)>>1); \	pix.pixel+=(yval-to->yOffset)*(long)to->rowBytes; \	pix.hilo=((xval-to->xOffset)&1)?0:1;}	// MERGE-HMD [[[#if USE_HMD#define InitPixelHMDL(pix,xval,yval,to) {pix.pixel=(unsigned char*)to->baseAddress; \	pix.pixel+=((xval-to->xOffset)>>1); \	pix.pixel+=(yval-to->yOffset)*((long)to->rowBytes << 1); \	if (gHMDOffsetLeft) pix.pixel += ((long)(to->rowBytes));	\	pix.hilo=((xval-to->xOffset)&1)?0:1;}#define InitPixelHMDR(pix,xval,yval,to) {pix.pixel=(unsigned char*)to->baseAddress; \	pix.pixel+=((xval-to->xOffset)>>1); \	pix.pixel+=(yval-to->yOffset)*((long)to->rowBytes << 1); \	if (gHMDOffsetRight) pix.pixel += ((long)(to->rowBytes));\	pix.hilo=((xval-to->xOffset)&1)?0:1;}#define AddLinePixelHMD(pix,to) pix.pixel+=((long)to->rowBytes << 1)#endif // USE_HMD// MERGE-HMD ]]]#define DecPixel(pix)  {if(pix.hilo)pix.pixel--; pix.hilo^=1;}#define IncPixel(pix)  {if(!pix.hilo)pix.pixel++; pix.hilo^=1;}#define AddPixel(pix,length) {pix.pixel+=length>>1;					\	if(length&1){pix.hilo^=1;if(pix.hilo)pix.pixel++;}}#define AddLinePixel(pix,to) pix.pixel+=to->rowBytes#define SetPixel(pix,color) *pix.pixel=								\	(pix.hilo?(*pix.pixel&0x0F)|(color[0]&0x0F0):(*pix.pixel&0xF0)|(color[0]&0x0F))#define DecSetPixel(pix,color) do{SetPixel(pix,color);DecPixel(pix);}while(0)#define IncSetPixel(pix,color) do{SetPixel(pix,color);IncPixel(pix);}while(0)// MERGE-GOURAUD [[[#define SetPixel2(pix,color) *pix.pixel=								\	(pix.hilo?(*pix.pixel&0x0F)|(color&0x0F0):(*pix.pixel&0xF0)|(color&0x0F))#define IncSetPixel2(pix,color) do{SetPixel2(pix,color);IncPixel(pix);}while(0)#define PixVal(pix) (pix.hilo)#define GetGouraudDither(dith_abcd, shade, color)	(gTextureShader[shade].dith[2][dith_abcd][color])// MERGE-GOURAUD ]]]#define ScanFillPattern ScanFillPattern4void ScanFillPattern4(PixType pixel,int ytop,int dx,VColorType color);								void ScanFillPattern4(PixType pixel,int ytop,int dx,VColorType color) {														unsigned char mask;unsigned char mcolor;int i;if(pixel.hilo ^ (ytop &1 ))/*move forward one pixel*/	{	if(!pixel.hilo)pixel.pixel++;	pixel.hilo^=1;	}if(!pixel.hilo)	mask=0xF0;else	mask=0x0F;mcolor=color[0];for(i=0;i<dx;i+=2)	{	*pixel.pixel=(*pixel.pixel&mask)|mcolor;	pixel.pixel++;	}}														ULong lMask4[]={0,0x0FFFFFFF,0x00FFFFFF,0x000FFFFF,					0x0000FFFF,0x00000FFF,0x000000FF,0x0000000F};ULong rMask4[]={0,0xF0000000,0xFF000000,0xFFF00000,					0xFFFF0000,0xFFFFF000,0xFFFFFF00,0xFFFFFFF0};#define ScanFill ScanFill4								void ScanFill4(PixType pixel,int evenodd,int dx,VColorType color);										void ScanFill4(PixType pixel,int evenodd,int dx,VColorType color)											{int ml,mr;				ULong *pl,*pr;ULong col=color[evenodd];int hl=!pixel.hilo;pl=(ULong *)(((long)pixel.pixel)&0xFFFFFFFC);ml=((long)pixel.pixel)&0x03;ml=(ml<<1)+hl;pixel.pixel+=(dx>>1);pr=(ULong *)(((long)pixel.pixel)&0xFFFFFFFC);mr=((long)pixel.pixel)&0x03;/* the byte inside the long word */mr=(mr<<1)+(dx&1)+hl; /*the nibble inside the byte*/if(mr>=8)	{pr++;mr-=8;}if(pl==pr)/*same 32 bits*/	{	if(ml)		{		if(mr)*pl=(*pl&(rMask4[ml]|lMask4[mr]))|(lMask4[ml]&rMask4[mr]&col);		else *pl=(*pl&rMask4[ml])|(lMask4[ml]&col);		}	else if(mr)*pl=(*pl&lMask4[mr])|(rMask4[mr]&col);	}else 	{// the powerpc section does exactly the same thing except that the compiler does// not handle the post-increment correctly. - BILBIL - 12/8/93#if __PPCC__	if(ml)		{		*pl=(*pl&rMask4[ml])|(lMask4[ml]&col);		*pl++;		}#else	if(ml)*pl++=(*pl&rMask4[ml])|(lMask4[ml]&col);#endif //__PPCC__	while(pl!=pr)*pl++=col;	if(mr)*pl=(*pl&lMask4[mr])|(rMask4[mr]&col);	}}						// MERGE-GOURAUD [[[/*------------------------------------------------------------------------------ * GouraudFillxxxx *------------------------------------------------------------------------------ */// GOURAUD -- we have to pattern fill dx pixels, going from intensity il to intensity ir#define DefaultGouraudFillPattern DefaultGouraudFillPattern4#define DefaultGouraudFill DefaultGouraudFill4#define GouraudFillPattern DefaultGouraudFillPattern4#define GouraudFill DefaultGouraudFill4// MERGE-GOURAUD ]]]					#include "FlashZ.h"