/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   David A. Smith *               *               * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  * Platform:    MACINTOSH   X *              WINDOWS      *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VToolBox.h"#include "VPane.h"#include "VGraphic.h"#include "VGUtil.h"#include "VArray.h"#include "Clip.h"#include "EPSF.h"#include "Flash.h"#include "vdebug.h"		// ABD#include "VWCNTRL.h"	// ABD 3D PICK 8/13/93#include "POLYHDRN.h"	// ABD 3D PICK 8/13/93#include "POLYCONV.h"	// ABD 3D PICK 8/13/93#include "SURFFEAT.h"	// ABD 3D PICK 8/13/93#include "SURFACE.h"	// ABD 3D PICK 8/13/93#include "Gouraud.h"	// MERGE-GOURAUD#include "objprclp.h"	// JAM object precision clipping 2/22/93#include "HMD.h"	// MERGE-HMD DEBUG ONLY еееее#if MACINTOSH#undef FLASHUSEASM#define FLASHUSEASM 0#endif //MACINTOSH/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/// ABD 3D PICK 8/13/93 vint polyCheckMode = FALSE;	// ABD 3D PICK 8/13/93Point checkPolyLocation;	// ABD 3D PICK 8/13/93struct ObjSpec gCurrentObj;	// ABD 3D PICK 8/13/93struct ObjSpec gClickObj;	// ABD 3D PICK 8/13/93//JAM 6/3/94//This global determines how small a window may get and still be a clip window//(if a window is 2 pixels tall, the frame fills in the window and there's no//need to clip everything behind).  This global needs to be set to something//less than than 1 pixel for printing since banding causes screens to be very//short, i.e. 3 or fewer pixels)FFixed gGlobalWindowClipMin = INITFIXXED(0,0); //MERGE-PRO-JAM-3// ABD 3D PICK 8/13/93 -- removed obsolete variables pertaining to 3D PICK// This macro returns TRUE or FALSE depending on whether the user can pick through the // specified object.  We allow the user to pick through transparent// surface features and transparent surfaces.  This allows us to click through windows in// an intuitive way Modify this routine to taste --// perhaps disallowing clicks through textured surfaces/features or something.#define CAN_PICK_THROUGH_OBJECT(obj) 									\(																		\	(																	\		(obj.surffeat != NULL) && 										\		(IS_TRANSPARENT(obj.surffeat->opacity)) 							\	)																	\	||																	\	(																	\		(obj.surffeat == NULL) && 										\		(obj.surfNum != NO_SURFACE_SPEC) && 							\		(obj.polyc != NULL) && 											\		(obj.polyc->FindSurface(obj.surfNum) != NULL) && 				\		(IS_TRANSPARENT(obj.polyc->FindSurface(obj.surfNum)->opacity)) 	\	)																	\)// ABD 3D PICK 8/13/93 ^static V_Array *ident;static V_Array *tIdent;static V_Array *npIdent;		// ABD MERGE-TEXTURE 9/13/93static V_Array *gouIdent;		// ABD MERGE-GOURAUDextern int usePlatformDrawFlag;static V_Array *clipPts;V_Array *ClipPtsFFixed1;	//JAM Object precision clipping 3-15-93V_Array *ClipPtsFFixed2;	//JAM Object precision clipping 3-15-93V_Array *FramePts1;			//JAM Frame Fix 27Sept94V_Array *FramePts2;			//JAM Frame Fix 27Sept94V_Array *ClipPts3DAllInfo1;	//JAM Object precision clipping 3-15-93V_Array *ClipPts3DAllInfo2;	//JAM Object precision clipping 3-15-93V_Array *ClipPtsGouraud1;		// MERGE-GOURAUD gouraud Object precision clippingV_Array *ClipPtsGouraud2;		// MERGE-GOURAUD gouraud Object precision clippingV_Array *ScreenPolyPoints;	//JAM eliminate extra screen edge linesV_Array *mArray,*nArray;    // jca 13APR94 move these here.  They're apparently temps for LongDrawPoly.  Everyone denies having created them.#if VWT /* jca 17 Sept 93. Not in VR { */extern Filter *filter;#endif // VWT.  jca 17 Sept 93 }extern int polyFilter;#if WINDOWSstatic V_Array *polyPts;void PaintPoly(V_Array *);void FramePoly(V_Array *);#elif MACINTOSHint useQDFlag = FALSE;#endif //WINDOWSClip *virtusClipper;long clipCount;voidInitClipper()    {    virtusClipper = new(Clip);    virtusClipper->cClip();    clipPts = new(V_Array);    clipPts->cArray(0,sizeof(Point),8);	//JAM Object precision clipping 3-15-93 [[[	ClipPtsFFixed1 = new(V_Array);    ClipPtsFFixed1->cArray(0,sizeof(PointFFixed),8);    ClipPtsFFixed1->Use();	ClipPtsFFixed2 = new(V_Array);    ClipPtsFFixed2->cArray(0,sizeof(PointFFixed),8);    ClipPtsFFixed2->Use();	//JAM Frame Fix 27Sept94	FramePts1 = new(V_Array);	FramePts1->cArray(0,sizeof(char),8);	FramePts1->Use();	FramePts2 = new(V_Array);	FramePts2->cArray(0,sizeof(char),8);    FramePts2->Use();	ClipPts3DAllInfo1 = new(V_Array);    ClipPts3DAllInfo1->cArray(0,sizeof(Point3DAllInfo),8);    ClipPts3DAllInfo1->Use();    ClipPts3DAllInfo2 = new(V_Array);    ClipPts3DAllInfo2->cArray(0,sizeof(Point3DAllInfo),8);    ClipPts3DAllInfo2->Use();    ClipPtsGouraud1 = new(V_Array);						// MERGE-GOURAUD    ClipPtsGouraud1->cArray(0,sizeof(FFixed),8);		// MERGE-GOURAUD    ClipPtsGouraud1->Use();								// MERGE-GOURAUD    ClipPtsGouraud2 = new(V_Array);						// MERGE-GOURAUD    ClipPtsGouraud2->cArray(0,sizeof(FFixed),8);		// MERGE-GOURAUD    ClipPtsGouraud2->Use();								// MERGE-GOURAUD	//JAM Object precision clipping 3-15-93 ]]]	//JAM eliminate extra screen edge lines [[[	ScreenPolyPoints = new(V_Array);	ScreenPolyPoints->cArray(4,sizeof(Point),8);	ScreenPolyPoints->Use();	//JAM eliminate extra screen edge lines ]]]	ident = new(V_Array);    ident->cArray(0,sizeof(Point),8);    tIdent = new(V_Array);    tIdent->cArray(0,sizeof(PointFFixed),8);	// ABD MERGE-TEXTURE 9/15/93    // ABD MERGE-TEXTURE 9/15/93 [[[	npIdent = new(V_Array);	npIdent->cArray(0,sizeof(Point3DNoPersp),8);// ABD MERGE-TEXTURE 9/15/93 ]]]	// MERGE-GOURAUD [[[    gouIdent = new(V_Array);    gouIdent->cArray(0,sizeof(FFixed),8);	// MERGE-GOURAUD ]]]	mArray=new(V_Array);    mArray->cArray(0,sizeof(PointLong),8); 	nArray=new(V_Array);    nArray->cArray(0,sizeof(PointLong),8);#if WINDOWS    polyPts = new(V_Array);    polyPts->cArray(0,sizeof(POINT),8);#endif //WINDOWS    }voidReleaseClipper()    {    virtusClipper->dClip();    clipPts->dArray();	ClipPtsFFixed1->Unuse();		//JAM Object precision clipping 3-15-93    ClipPtsFFixed1->dArray();		//JAM Object precision clipping 3-15-93    ClipPtsFFixed2->Unuse();		//JAM Object precision clipping 3-15-93    ClipPtsFFixed2->dArray();		//JAM Object precision clipping 3-15-93	//JAM Frame Fix 27Sept94	FramePts1->Unuse();		//JAM Object precision clipping 3-15-93	FramePts1->dArray();		//JAM Object precision clipping 3-15-93	FramePts2->Unuse();		//JAM Object precision clipping 3-15-93	FramePts2->dArray();		//JAM Object precision clipping 3-15-93	ClipPts3DAllInfo1->Unuse();		//JAM Object precision clipping 3-15-93    ClipPts3DAllInfo1->dArray();	//JAM Object precision clipping 3-15-93	ClipPts3DAllInfo2->Unuse();		//JAM Object precision clipping 3-15-93    ClipPts3DAllInfo2->dArray();	//JAM Object precision clipping 3-15-93	ClipPtsGouraud1->Unuse();		// MERGE-GOURAUD	//jam 6oct94 need to delete	ClipPtsGouraud1->dArray();		// MERGE-GOURAUD	//jam 6oct94 need to delete	ClipPtsGouraud2->Unuse();		// MERGE-GOURAUD	//jam 6oct94 need to delete	ClipPtsGouraud2->dArray();		// MERGE-GOURAUD	//jam 6oct94 need to delete	ScreenPolyPoints->Unuse();	//JAM Object precision clipping 3-15-93	ScreenPolyPoints->dArray();	//JAM Object precision clipping 3-15-93	ident->dArray();    tIdent->dArray();    npIdent->dArray();	// ABD MERGE-TEXTURE 9/15/93    gouIdent->dArray();	// ABD MERGE-GOURAUD	mArray->dArray();	nArray->dArray();#if WINDOWS    polyPts->dArray();#endif //WINDOWS    }// ABD WILLIAMS MERGE-TEXTURE 9/13/93 [[[// ABD TEXTURE // do an absolute ident but ignore current pane and do no translationV_Array *RealAbsoluteIdent(V_Array *points,int inside){register long i,lngth = points->ALength();register Point *p,*data;if(!ident)	{	ident = new(V_Array);	ident->cArray(0,sizeof(Point),8);	}ident->SetLength(lngth);p= (Point *)VA_Abuse(points);data=(Point *)VA_Abuse(ident);	if(inside)/*then reverse the thing*/	{	data+=lngth;	for(i=0;i<lngth;i++)		{		--data;		*data=*p++;		}	}else	for(i=0;i<lngth;i++)		{		*data = *p++;		data++;		}return ident;}// MERGE-GOURAUD [[[/*------------------------------------------------------------------------------------------*/voidIndexIdentGouraud(V_Array *points,V_Array *index,int cw,V_Array *intensities,	V_Array **new_points,V_Array **new_intensities){register long i;register short *ind;register Point *p,*data;register FFixed *gou,*inten;Point initPt,lastPt;long tlength=1;long lngth = index->ALength();int cx,cy;if(currentPane)    {    cx=currentPane->centerX;    cy=currentPane->centerY;    }#if VWT /* jca 17 Sept 93. Not in VR { */else if (polyFilter)    {    /* treat a filter just like a pane */    cx = (filter->rect.left + filter->rect.right)>>1;    cy = (filter->rect.top + filter->rect.bottom)>>1;    }#endif // VWT jca 17 Sept 93 }else cx=cy=0;ident->SetLength(lngth);gouIdent->SetLength(lngth);/*now set the values*/  ind=(short *)VA_Abuse(index); // DAS-LIZARD KING 10/2/93p=(Point *)VA_Abuse(points);// DAS-LIZARD KING 10/2/93data=(Point *)VA_Abuse(ident);   // DAS-LIZARD KING 10/2/93gou=(FFixed *)VA_Abuse(gouIdent); inten=(FFixed *)VA_Abuse(intensities);if(cw)    {	*data=p[*ind];	*gou=*inten;	initPt=lastPt=*data;	data->h+=cx;	data->v=cy-data->v;	++data;	++ind; 	++gou; 	++inten;   for (i = 1; i < lngth; i++,ind++)        {        *data=p[*ind];		*gou=*inten;         if(data->h!=lastPt.h || data->v!=lastPt.v)			{   			lastPt=*data;			data->h+=cx;			data->v=cy-data->v;			data++;			tlength++;  			gou++;			inten++;			}		}    }else      {    ind+=lngth;    inten+=lngth;	*data=p[*--ind];	*gou=*--inten;	initPt=lastPt=*data;	data->h+=cx;	data->v=cy-data->v;	data++;	gou++;    for (i=1;i<lngth;i++)        {        *data=p[*--ind];		*gou=*--inten;		if(data->h!=lastPt.h || data->v!=lastPt.v)			{   			lastPt=*data;			data->h+=cx;			data->v=cy-data->v;			data++;			tlength++;			gou++;			}        }    }if(initPt.h==lastPt.h && initPt.v==lastPt.v)tlength--;if(tlength!=lngth){	ident->SetLength(tlength);	gouIdent->SetLength(tlength);}*new_points = ident;*new_intensities = gouIdent;}/*------------------------------------------------------------------------------------------*/voidIdentGouraud(V_Array *points,int cw,V_Array *intensities,	V_Array **new_points,V_Array **new_intensities){register long i,lngth = points->ALength(),tlength=1;register Point *p,*data,lastPt;register FFixed *gou,*inten;Point initPt;int cx,cy;if(currentPane)    {    cx=currentPane->centerX;    cy=currentPane->centerY;    }#if VWT /* jca 17 Sept 93. Not in VR { */else if (polyFilter)    {    /* treat a filter just like a pane */    cx = (filter->rect.left + filter->rect.right)>>1;    cy = (filter->rect.top + filter->rect.bottom)>>1;    }#endif // VWT jca 17 Sept 93 }else cx=cy=0;ident->SetLength(lngth);gouIdent->SetLength(lngth);p=(Point *)VA_Abuse(points);// DAS-LIZARD KING 10/2/93data=(Point *)VA_Abuse(ident);   // DAS-LIZARD KING 10/2/93gou=(FFixed *)VA_Abuse(gouIdent); inten=(FFixed *)VA_Abuse(intensities);if(cw)    {    for(i=0;i<lngth;i++,p++)        {        *data=*p;        *gou=*inten;        if(i)            {            if(data->h!=lastPt.h || data->v!=lastPt.v)                {                   lastPt=*data;                data->h+=cx;                data->v=cy-data->v;                ++data;                ++gou;                tlength++;                }            }        else{            initPt=lastPt=*data;            data->h+=cx;            data->v=cy-data->v;            ++data;            ++gou;            }        }    }else{    p+=lngth;    inten+=lngth;    for(i=0;i<lngth;i++)        {        *data=*--p;        *gou=*--inten;		if(i)            {            if(data->h!=lastPt.h || data->v!=lastPt.v)                {                   lastPt=*data;                data->h+=cx;                data->v=cy-data->v;                ++data;                ++gou;                tlength++;                }            }        else{            initPt=lastPt=*data;            data->h+=cx;            data->v=cy-data->v;            ++data;            ++gou;            }        }    }if(initPt.h==lastPt.h && initPt.v==lastPt.v)tlength--;if(tlength!=lngth){	ident->SetLength(tlength);	gouIdent->SetLength(tlength);}*new_points = ident;*new_intensities = gouIdent;}/*------------------------------------------------------------------------------------------*/// MERGE-GOURAUD ]]]// ABD TEXTUREV_Array *AbsoluteIndexIdent(V_Array *points,V_Array *index,int cw){register long i,lngth = index->ALength();register short *ind;		// BILBIL - no ints, yuck - 11/17/93register Point *p,*data;int cx,cy;if(currentPane)	{	cx=currentPane->centerX;	cy= currentPane->centerY;	}#if VWT// jca - dont need this under VRelse if ((polyFilter) && (filter))	{	/* treat a filter just like a pane */	cx = (filter->rect.left + filter->rect.right)>>1;	cy = (filter->rect.top + filter->rect.bottom)>>1;		// PRO-15 illustrator snapshot fix	}#endif //VWTelse cx=cy=0;if(!ident)	{	ident = new(V_Array);	ident->cArray(0,sizeof(Point),8);	}ident->SetLength(lngth);ind=(short *)VA_Abuse(index);	// BILBIL - no ints, yuck - 11/17/93p=(Point *)VA_Abuse(points);data=(Point *)VA_Abuse(ident);if(cw)/*then reverse the thing*/	{	ind+=lngth;	for(i=0;i<lngth;i++)		{		--ind;		*data=p[*ind];		data->h+=cx;		data->v=cy-data->v;		data++;		}	}else	for(i=0;i<lngth;i++)		{		*data=p[*ind];		ind++;		data->h+=cx;		data->v=cy-data->v;		data++;		}return ident;}void	// JAM TEXTURENewIndexIdent(V_Array *screen, V_Array *nopersp, V_Array *texture, V_Array *index,		 int height, int cw,		 V_Array **screennew, V_Array **noperspnew, V_Array **texturenew){register long i,lngth = index->ALength(),tlength=1;register Point *p, *datap,*bdatap, lastPtp, initPtp;register PointFFixed *t, *datat,*bdatat, lastPtt, initPtt;register Point3DNoPersp *pnp, *datapnp, *bdatapnp, lastPtpnp, initPtpnp;register short *ind;		// BILBIL - no ints, yuck - 11/17/93int cx,cy;FFixed heightFixed;height--;heightFixed.intg = height;heightFixed.frac = 0;ind = (short *)VA_Abuse(index);	// BILBIL - no ints, yuck - 11/17/93if(currentPane)	{	cx=currentPane->centerX;	cy= currentPane->centerY;	}#if VWT// jca - dont need this for VRelse if ((polyFilter) && (filter))	{	/* treat a filter just like a pane */	cx = (filter->rect.left + filter->rect.right)>>1;	cy = (filter->rect.top + filter->rect.bottom)>>1;		// PRO-15 illustrator snapshot fix	}#endif //VWTelse cx=cy=0;// ABD TEXTURE ident inited in InitClipper() nowident->SetLength(lngth);p=(Point *)VA_Abuse(screen);bdatap=datap=(Point *)VA_Abuse(ident);// ABD TEXTURE npIdent inited in InitClipper() nownpIdent->SetLength(lngth);pnp=(Point3DNoPersp *)VA_Abuse(nopersp);bdatapnp=datapnp=(Point3DNoPersp *)VA_Abuse(npIdent);// ABD TEXTURE tIdent inited in InitClipper() nowtIdent->SetLength(lngth);t=(PointFFixed *)VA_Abuse(texture);bdatat=datat=(PointFFixed *)VA_Abuse(tIdent);if(cw)	{	for (i = 0; i < lngth; i++,ind++)		{		*datap=p[*ind];		*datapnp = pnp[*ind];		/*only as many texture points as there are surface points*/		*datat= t[i];		if(i)			{			if(datap->h!=lastPtp.h || datap->v!=lastPtp.v)				{					lastPtp=*datap;				lastPtpnp=*datapnp;				lastPtt=*t;								datap->h+=cx;				datap->v=cy-datap->v;				datat->v.l=heightFixed.l-datat->v.l;				++datap;				++datapnp;				++datat;				tlength++;				}			}		else{			initPtp=lastPtp=*datap;			initPtpnp=lastPtpnp=*datapnp;			initPtt=lastPtt=*datat;			datap->h+=cx;			datap->v=cy-datap->v;			datat->v.l=heightFixed.l-datat->v.l;			++datap;			++datapnp;			++datat;			}		}	}else{	ind+=lngth;	for (i=0;i<lngth;i++)		{		*datap=p[*--ind];		*datapnp=pnp[*ind];		*datat=t[lngth-i-1];		if(i)			{			if(datap->h!=lastPtp.h || datap->v!=lastPtp.v)				{					lastPtp=*datap;				lastPtpnp=*datapnp;				lastPtt=*datat;				datap->h+=cx;				datap->v=cy-datap->v;				datat->v.l=heightFixed.l-datat->v.l;				++datap;				++datapnp;				++datat;				tlength++;				}			}		else{			initPtp=lastPtp=*datap;			initPtpnp=lastPtpnp=*datapnp;			initPtt=lastPtt=*datat;			datap->h+=cx;			datap->v=cy-datap->v;			datat->v.l=heightFixed.l-datat->v.l;			++datap;			++datapnp;			++datat;			}		}	}if(initPtp.h==lastPtp.h && initPtp.v==lastPtp.v)tlength--;if(tlength!=lngth)ident->SetLength(tlength);*screennew = ident;*noperspnew = npIdent;*texturenew = tIdent;}void	// JAM TEXTURENewIdent(V_Array *screen, V_Array *nopersp, V_Array *texture, int height, int cw,		 V_Array **screennew, V_Array **noperspnew, V_Array **texturenew){register long i,lngth = screen->ALength(),tlength=1;register Point *p, *datap,*bdatap, lastPtp, initPtp;register PointFFixed *t, *datat,*bdatat, lastPtt, initPtt;register Point3DNoPersp *pnp, *datapnp, *bdatapnp, lastPtpnp, initPtpnp;int cx,cy;FFixed heightFixed;height--;heightFixed.intg = height;heightFixed.frac = 0;if(currentPane)	{	cx=currentPane->centerX;	cy= currentPane->centerY;	}#if VWTelse if ((polyFilter) && (filter))	{	/* treat a filter just like a pane */	cx = (filter->rect.left + filter->rect.right)>>1;	cy = (filter->rect.top + filter->rect.bottom)>>1;		// PRO-15 illustrator snapshot fix	}#endif //VWTelse cx=cy=0;// ABD TEXTURE ident inited in InitClipperident->SetLength(lngth);p=(Point *)VA_Abuse(screen);bdatap=datap=(Point *)VA_Abuse(ident);// ABD TEXTURE npIdent inited in InitClippernpIdent->SetLength(lngth);pnp=(Point3DNoPersp *)VA_Abuse(nopersp);bdatapnp=datapnp=(Point3DNoPersp *)VA_Abuse(npIdent);// ABD TEXTURE tIdent inited in InitClippertIdent->SetLength(lngth);t=(PointFFixed *)VA_Abuse(texture);bdatat=datat=(PointFFixed *)VA_Abuse(tIdent);	if(cw)	{	for(i=0;i<lngth;i++,p++,pnp++,t++)		{		*datap=*p;		*datapnp = *pnp;		*datat = *t;		if(i)			{			if(datap->h!=lastPtp.h || datap->v!=lastPtp.v)				{					lastPtp=*datap;				lastPtpnp=*datapnp;				lastPtt=*t;								datap->h+=cx;				datap->v=cy-datap->v;				datat->v.l=heightFixed.l-datat->v.l;				++datap;				++datapnp;				++datat;				tlength++;				}			}		else{			initPtp=lastPtp=*datap;			initPtpnp=lastPtpnp=*datapnp;			initPtt=lastPtt=*datat;			datap->h+=cx;			datap->v=cy-datap->v;			datat->v.l=heightFixed.l - datat->v.l;			++datap;			++datapnp;			++datat;			}		}	}else{	p+=lngth;	pnp+=lngth;	t+=lngth;	for(i=0;i<lngth;i++)		{		*datap=*--p;		*datapnp=*--pnp;		*datat=*--t;		if(i)			{			if(datap->h!=lastPtp.h || datap->v!=lastPtp.v)				{					lastPtp=*datap;				lastPtpnp=*datapnp;				lastPtt=*datat;				datap->h+=cx;				datap->v=cy-datap->v;				datat->v.l=heightFixed.l-datat->v.l;				++datap;				++datapnp;				++datat;				tlength++;				}			}		else{			initPtp=lastPtp=*datap;			initPtpnp=lastPtpnp=*datapnp;			initPtt=lastPtt=*datat;			datap->h+=cx;			datap->v=cy-datap->v;			datat->v.l=heightFixed.l-datat->v.l;			++datap;			++datapnp;			++datat;			}		}	}if(initPtp.h==lastPtp.h && initPtp.v==lastPtp.v)tlength--;if(tlength!=lngth)ident->SetLength(tlength);*screennew = ident;*noperspnew = npIdent;*texturenew = tIdent;}// ABD WILLIAMS MERGE-TEXTURE 9/13/93 ]]]// { DAS-LIZARD KING 10/2/93V_Array *IndexIdent(V_Array *points,V_Array *index,int cw){register long i;register short *ind;register Point *p,*data;Point initPt,lastPt;long tlength=1;long lngth = index->ALength();int cx,cy;if(currentPane)    {	cx=currentPane->centerX;	cy= currentPane->centerY;	}#if VWT /* jca 17 Sept 93. Not in VR { */else if (polyFilter)    {    /* treat a filter just like a pane */    cx = (filter->rect.left + filter->rect.right)>>1;	cy = (filter->rect.top + filter->rect.bottom)>>1;		// PRO-15 illustrator snapshot fix	}#endif // VWT jca 17 Sept 93 }else cx=cy=0;ident->SetLength(lngth);/*now set the values*/  ind=(short *)VA_Abuse(index); // DAS-LIZARD KING 10/2/93p=(Point *)VA_Abuse(points);// DAS-LIZARD KING 10/2/93data=(Point *)VA_Abuse(ident);   // DAS-LIZARD KING 10/2/93if(cw)    {	*data=p[*ind];	initPt=lastPt=*data;	data->h+=cx;	data->v=cy-data->v;	++data;	++ind;    for (i = 1; i < lngth; i++,ind++)        {        *data=p[*ind];         if(data->h!=lastPt.h || data->v!=lastPt.v)			{   			lastPt=*data;			data->h+=cx;			data->v=cy-data->v;			data++;			tlength++;			}		}    }else      {    ind+=lngth;	*data=p[*--ind];	initPt=lastPt=*data;	data->h+=cx;	data->v=cy-data->v;	data++;    for (i=1;i<lngth;i++)        {        *data=p[*--ind];		if(data->h!=lastPt.h || data->v!=lastPt.v)			{   			lastPt=*data;			data->h+=cx;			data->v=cy-data->v;			data++;			tlength++;			}        }    }if(initPt.h==lastPt.h && initPt.v==lastPt.v)tlength--;if(tlength!=lngth)ident->SetLength(tlength);return ident;}// } DAS-LIZARD KING 10/2/93V_Array *Ident(V_Array *points,int cw){register long i,lngth = points->ALength(),tlength=1;register Point *p,*data,lastPt;Point initPt;int cx,cy;if(currentPane)    {	cx=currentPane->centerX;	cy= currentPane->centerY;	}#if VWT /* jca 17 Sept 93. Not in VR { */else if (polyFilter)    {    /* treat a filter just like a pane */    cx = (filter->rect.left + filter->rect.right)>>1;	cy = (filter->rect.top + filter->rect.bottom)>>1;		// PRO-15 illustrator snapshot fix	}#endif // VWT jca 17 Sept 93 }else cx=cy=0;ident->SetLength(lngth);p=(Point *)VA_Abuse(points);// DAS-LIZARD KING 10/2/93data=(Point *)VA_Abuse(ident);   // DAS-LIZARD KING 10/2/93if(cw)    {    for(i=0;i<lngth;i++,p++)        {        *data=*p;        if(i)            {            if(data->h!=lastPt.h || data->v!=lastPt.v)                {                   lastPt=*data;                data->h+=cx;                data->v=cy-data->v;                ++data;                tlength++;                }            }        else{            initPt=lastPt=*data;            data->h+=cx;            data->v=cy-data->v;            ++data;            }        }    }else{    p+=lngth;    for(i=0;i<lngth;i++)        {        *data=*--p;        if(i)            {            if(data->h!=lastPt.h || data->v!=lastPt.v)                {                   lastPt=*data;                data->h+=cx;                data->v=cy-data->v;                ++data;                tlength++;                }            }        else{            initPt=lastPt=*data;            data->h+=cx;            data->v=cy-data->v;            ++data;            }        }    }if(initPt.h==lastPt.h && initPt.v==lastPt.v)tlength--;if(tlength!=lngth)ident->SetLength(tlength);return ident;}V_Array *AbsoluteIdent(V_Array *points,int inside)/*same as Ident but no loss of points*/{register long i,lngth = points->ALength();register Point *p,*data;int cx,cy;if(currentPane)    {	cx=currentPane->centerX;	cy= currentPane->centerY;	}#if VWT /* jca 17 Sept 93. Not in VR { */else if (polyFilter)    {    /* treat a filter just like a pane */    cx = (filter->rect.left + filter->rect.right)>>1;	cy = (filter->rect.top + filter->rect.bottom)>>1;		// PRO-15 illustrator snapshot fix	}#endif // VWT jca 17 Sept 93 }else cx=cy=0;ident->SetLength(lngth);p=(Point *)VA_Abuse(points);// DAS-LIZARD KING 10/2/93data=(Point *)VA_Abuse(ident);   // DAS-LIZARD KING 10/2/93if(inside)/*then reverse the thing*/    {    data+=lngth;    for(i=0;i<lngth;i++)        {        --data;        *data=*p++;        data->h+=cx;        data->v=cy-data->v;        }    }else    for(i=0;i<lngth;i++)        {        *data=*p++;        data->h+=cx;        data->v=cy-data->v;        data++;        }return ident;}// ABD MERGE16 9/25/93 [[[V_Array *AbsoluteIdentTexture(V_Array *points,int height,int inside){register long i,lngth = points->ALength();register PointFFixed *p,*data;FFixed heightFixed;height--;heightFixed.intg = height;heightFixed.frac = 0;if(!tIdent)	{	tIdent = new(V_Array);	tIdent->cArray(0,sizeof(PointFFixed),8);	}tIdent->SetLength(lngth);p=(PointFFixed*)VA_Abuse(points);data=(PointFFixed*)VA_Abuse(tIdent);	if(inside)/*then reverse the thing*/	{	data+=lngth;	for(i=0;i<lngth;i++)		{		--data;		*data=*p++;		data->v.l=heightFixed.l-data->v.l;		}	}elsefor(i=0;i<lngth;i++)	{	*data=*p++;	data->v.l=heightFixed.l-data->v.l;	data++;	}return tIdent;}V_Array *IdentTexture(V_Array *points,int height,int cw){register long i,lngth = points->ALength(),tlength=1;register PointFFixed *p,*data, lastPt;PointFFixed initPt;FFixed heightFixed;height--;heightFixed.intg = height;heightFixed.frac = 0;if(!tIdent)	{	tIdent = new(V_Array);	tIdent->cArray(0,sizeof(PointFFixed),8);	}tIdent->SetLength(lngth);p=(PointFFixed*)VA_Abuse(points);data=(PointFFixed*)VA_Abuse(tIdent);	if(cw)	{	for(i=0;i<lngth;i++,p++)		{		*data=*p;		if(i)			{			if(data->h.l!=lastPt.h.l || data->v.l!=lastPt.v.l)				{					lastPt=*data;				data->v.l=heightFixed.l-data->v.l;				++data;				tlength++;				}			}		else{			initPt=lastPt=*data;			data->v.l=heightFixed.l-data->v.l;			++data;			}		}	}else {	p+=lngth;	for(i=0;i<lngth;i++)		{		*data=*--p;		if(i)			{			if(data->h.l!=lastPt.h.l || data->v.l!=lastPt.v.l)				{					lastPt=*data;				data->v.l=heightFixed.l-data->v.l;				++data;				tlength++;				}			}		else{			initPt=lastPt=*data;			data->v.l=heightFixed.l-data->v.l;			++data;			}		}	}if(initPt.h.l==lastPt.h.l && initPt.v.l==lastPt.v.l)tlength--;if(tlength!=lngth)tIdent->SetLength(tlength);return tIdent;}// ABD MERGE16 9/25/93 ]]]/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/void Clip::cClip(void){if (!offscreen || !gwUserFlash || !offscreen->wMethodInit || usePlatformDrawFlag || polyCheckMode || polyFilter)    {    method=QD_METHOD;    cArray(0,max(sizeof(semitrap), sizeof(struct ClipStruct)),8);    type=FALSE;    contain.top=     32000;    contain.bottom=  -32000;    contain.left=    32000;    contain.right=  -32000;    }else    {  // use our own methods    method=offscreen->wMethodInit;     // method=FLASH_METHOD;    cArray(0,max(sizeof(struct ClipStruct), sizeof(semitrap)), 480);    }type=FALSE;contain.top=     32000;         // gjr just to be safe... (so is max() above)contain.bottom=  -32000;        // I don't trust the shared clips.contain.left=    32000;contain.right=  -32000;ClipShape = NULL;	//JAM 1-94 Exact clippingLineEqtns = NULL;	//JAM 3-7-94 Save Line Equations for clipperreject = FALSE;		//JAM 2-94 Exact clipping}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/Clip *Clip::CreateInitialClip(Rect *r){int	plength;Clip *newClip, *resultClip;int	i;Point *p;plength=4;p = (Point*)ScreenPolyPoints->Abuse();p[0].h = p[3].h = r->left;p[1].h = p[2].h = r->right;p[0].v = p[1].v = r->top;p[2].v = p[3].v = r->bottom;if(!type)/*then use the whole thing!*/    {    newClip=new(Clip);    newClip->cClip();    newClip->type = TRUE;    if(!(newClip->method))    {	   if(!newClip->MakeQDClip(ScreenPolyPoints))        {			newClip->dClip();	        newClip = NULL;        }	    resultClip = newClip;       return resultClip;    }    resultClip = newClip;	//JAM 1-94 added to create object-precision clipping poly	if(resultClip != NULL)	{		if(reject)		{			resultClip->reject = TRUE;			resultClip->dClip();			resultClip = NULL;			return resultClip;		}		ClipClipExact(resultClip, ScreenPolyPoints); 		if(resultClip->reject)		{			resultClip->dClip();			resultClip = NULL;		}	}	//MERGE-PRO-JAM-2	//added to again make lines drawn due to clip not be drawn	resultClip->ScreenRect = resultClip->BoundingBox;    return resultClip;    }	DEBUGGER();	return(NULL);}#if 1Clip *Clip::ClipClip(V_Array *points){int plength,index_left=0,index_right;int tlh,tlv,trh,trv;Point *pt;int dyl,odyl,dxl,odxl,ddxl,dyr,odyr,dxr,odxr,ddxr,deltay,reset;int xl;int xr;int i,j;int yytop;struct ClipStruct *clip,addClip;int cliptop,clipbottom,clipindex;int notDone=TRUE;int start=TRUE;Clip *newClip, *resultClip;int cleft,cright;FFixed leftXFF, rightXFF, rdxFF, ldxFF, tempxFF, tempyFF;plength=points->ALength();if(plength<=2){ return 0; }if(!type)/*then use the whole thing!*/    {    newClip=new(Clip);    newClip->cClip();    newClip->type = TRUE;    if(!(newClip->method))    {       if(!newClip->MakeQDClip(points))        {			newClip->dClip();	        newClip = NULL;        }	    resultClip = newClip;       return resultClip;    }    resultClip = newClip;	//JAM 1-94 added to create object-precision clipping poly	if(resultClip != NULL)	{		if(reject)		{			resultClip->reject = TRUE;			resultClip->dClip();			resultClip = NULL;			return resultClip;		}		ClipClipExact(resultClip, points); 		if(resultClip->reject)		{			resultClip->dClip();			resultClip = NULL;		} 	}    return resultClip;    }else     {    if (!method)        {        newClip=new(Clip);        newClip->cClip();        resultClip =ClipClipQD(newClip->MakeQDClip(points));       return resultClip;        }    }newClip=new(Clip);//newClip->cArray(0,sizeof(struct ClipStruct),8);/*we know it can't be bigger*/newClip->type=TRUE;newClip->method=method; // ?? copy current method ??resultClip = newClip;//JAM 1-94 added to create object-precision clipping polyif(resultClip != NULL)	{	if(reject)	{		resultClip->reject = TRUE;		resultClip->dClip();		resultClip = NULL;		return resultClip;	}	ClipClipExact(resultClip, points);	if(resultClip->reject)	{		resultClip->dClip();		resultClip = NULL;	}}//JAM 1-94 added to create object-precision clipping polyreturn resultClip;}#endif/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/void Clip::dClip(void){//JAM 1-94 remove exact clipping poly [[[if(ClipShape !=NULL){	ClipShape->Unuse();	ClipShape->dArray();	if(LineEqtns != NULL)	{		LineEqtns->Unuse();		LineEqtns->dArray();	}}//JAM 1-94 remove exact clipping poly ]]]if(array)dArray();else delete this;/*ain't nothin here to worry about*/}/*------------------------------------------------------------------------------// ABD 3D PICK 8/13/93 obj is the object being drawn; used for 3d pick (polyCheckMode)// if NULL is passed in for this parameter, the routine will still work but the object drawn// will not be found in polyCheckMode *------------------------------------------------------------------------------*/int Clip::DrawPoly(V_Array *points,int fillmode,struct GouraudRendSettings *grs, int pattern, int linepattern,	// MERGE-GOURAUD		// MERGE-BUG    RGBColor *color,RGBColor *lineColor,int cw, struct ObjSpec *obj)	// ABD 3D PICK 8/13/93{int rval,penMode,penType,i;// ABD 3D PICK 8/13/93// If the object passed in is not NULL, then remember it as the current object.if ((polyCheckMode) && (obj != NULL)) gCurrentObj = *obj;		// ABD 3D PICK 8/13/93if(!pattern) {penMode=FALSE;pattern=FALSE;}clipCount++;if (!method)    {    rval=  DrawQD(Ident(points,cw),color,lineColor,fillmode,penMode,pattern,linepattern);    }else    {   // MERGE-GOURAUD [[[   extern int gGouraud;     if ((grs != NULL) && (grs->intensities != NULL) && (gGouraud))		// // еее DEBUG: fillmode & CLIP_GOURAUD ??? 	    {	    V_Array *new_points;	    V_Array *new_intensities;	    unsigned char unshaded_color = grs->unshaded_color;	    IdentGouraud(points, cw, grs->intensities, &new_points, &new_intensities);	    if(type)rval= (*FlashGouraudClip)(offscreen, new_points, new_intensities,unshaded_color,lineColor,this,fillmode,pattern);	    else rval= (*FlashGouraud)(offscreen,new_points, new_intensities,unshaded_color,lineColor,fillmode,pattern);	    }    else    	{		    if(type)rval= (*FlashClip)(offscreen,Ident(points,cw),color,lineColor,this,fillmode,pattern);		    else rval= (*FlashFill)(offscreen,Ident(points,cw),color,lineColor,fillmode,pattern); 		}    // MERGE-GOURAUD ]]]    }return rval;}/*------------------------------------------------------------------------------// ABD 3D PICK 8/13/93 obj is the object being drawn; used for 3d pick (polyCheckMode)// if NULL is passed in for this parameter, the routine will still work but the object drawn// will not be found in polyCheckMode *------------------------------------------------------------------------------*/int Clip::NewDrawPoly(V_Array *points,int fillmode,struct GouraudRendSettings *grs,int penmode,int pattern, int linepattern,		// MERGE-GOURAUD	// MERGE-BUG    RGBColor *color,RGBColor *lineColor,int cw, struct ObjSpec *obj)	// ABD 3D PICK 8/13/93{int rval;// ABD 3D PICK 8/13/93// If the object passed in is not NULL, then remember it as the current object.if ((polyCheckMode) && (obj != NULL)) gCurrentObj = *obj;		// ABD 3D PICK 8/13/93#if WINDOWSint fillMode;  // jca, for diamond stealth 8 aug 93fillMode = GetPolyFillMode(currentDevice);	// diamond stealth hates the ALTERNATIVE fill mode.SetPolyFillMode(currentDevice, WINDING);#endif // WINDOWSclipCount++;rval=  DrawQD(Ident(points,cw),color,lineColor,fillmode,penmode,pattern,linepattern);		// MERGE-BUG#if WINDOWSSetPolyFillMode(currentDevice, fillMode);     	// diamond stealth. jca 8 aug 93#endif //WINDOWSreturn rval;}/*------------------------------------------------------------------------------// ABD 3D PICK 8/13/93 obj is the object being drawn; used for 3d pick (polyCheckMode)// if NULL is passed in for this parameter, the routine will still work but the object drawn// will not be found in polyCheckMode *------------------------------------------------------------------------------*//*int Clip::NewDrawPolyRef(V_Array *points,V_Array *pntRefs,    int fillmode,struct GouraudRendSettings *grs,int penmode,int pattern,int linepattern,RGBColor *color,		// MERGE-GOURAUD	// MERGE-BUG    RGBColor *lineColor,int cw, struct ObjSpec *obj)	// ABD 3D PICK 8/13/93{int rval;// ABD 3D PICK 8/13/93// If the object passed in is not NULL, then remember it as the current object.if ((polyCheckMode) && (obj != NULL)) gCurrentObj = *obj;		// ABD 3D PICK 8/13/93#if WINDOWSint fillMode;  // jca, for diamond stealth.  8 aug 93fillMode = GetPolyFillMode(currentDevice);	// diamond stealth hates the ALTERNATIVE fill mode.SetPolyFillMode(currentDevice, WINDING);#endif // WINDOWSclipCount++;rval=  DrawQD(IndexIdent(points,pntRefs,cw),color,lineColor,fillmode,penmode,pattern,linepattern);		// MERGE-BUG#if WINDOWSSetPolyFillMode(currentDevice, fillMode);     	// diamond stealth.  jca 8 aug 93#endif //WINDOWSreturn rval;}*//*------------------------------------------------------------------------------// ABD 3D PICK 8/13/93 obj is the object being drawn; used for 3d pick (polyCheckMode)// if NULL is passed in for this parameter, the routine will still work but the object drawn// will not be found in polyCheckMode *------------------------------------------------------------------------------*/int Clip::DrawPolyRef(V_Array *points,V_Array *pntRefs,    int fillmode,struct GouraudRendSettings *grs, int pattern,int linepattern,RGBColor *color,RGBColor *lineColor,int cw,	// MERGE-GOURAUD	// MERGE-BUG    struct ObjSpec *obj)	// ABD 3D PICK 8/13/93{int rval,penMode,i;// ABD 3D PICK 8/13/93// If the object passed in is not NULL, then remember it as the current object.if ((polyCheckMode) && (obj != NULL)) gCurrentObj = *obj;		// ABD 3D PICK 8/13/93if(!pattern) {penMode=FALSE;pattern=FALSE;}clipCount++;if (!method)    {	rval=  DrawQD(IndexIdent(points,pntRefs,cw),color,lineColor,fillmode,penMode,pattern,linepattern);    }else    {    // MERGE-GOURAUD [[[     extern int gGouraud;    if ((grs != NULL) && (grs->intensities != NULL) && (gGouraud))		// // еее DEBUG: fillmode & CLIP_GOURAUD ??? 	    {	    V_Array *new_points;	    V_Array *new_intensities;	    unsigned char unshaded_color = grs->unshaded_color;	    IndexIdentGouraud(points, pntRefs, cw, grs->intensities, &new_points, &new_intensities);	    	    if(type)rval= (*FlashGouraudClip)(offscreen, new_points, new_intensities,	        unshaded_color,lineColor,this,fillmode,pattern);	    else rval= (*FlashGouraud)(offscreen, new_points, new_intensities,	        unshaded_color,lineColor,fillmode,pattern);	    }    else    	{    if(type)rval= (*FlashClip)(offscreen,IndexIdent(points,pntRefs,cw),        color,lineColor,this,fillmode,pattern);    else rval= (*FlashFill)(offscreen,IndexIdent(points,pntRefs,cw),        color,lineColor,fillmode,pattern);    	}    // MERGE-GOURAUD ]]]    }return rval;}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/Clip *currentClip;intClip::DrawQD(V_Array *points,RGBColor *color,RGBColor *lineColor,int mode,int penmode,int pattern, int linepattern)		// MERGE-BUG    {    Clip *newClip;    Point *p,tp;    int rval,i,len;    int frame;#if MACINTOSH    PolyHandle poly;    if(type==0) // then just draw the whole thing    	{#if VWT /* jca 17 Sept 93. Not in VR { */        if(polyFilter)            {            if(filter)filter->SavePoly(points,color,lineColor,mode);            return TRUE;            }        else#endif // VWT jca 17 Sept 93 }            {            len=points->ALength();            p=(Point *)points->Use();            poly=OpenPoly();            VMoveTo(p[0].h,p[0].v);            for(i=1;i<len;i++)                VLineTo(p[i].h,p[i].v);            VLineTo(p[0].h,p[0].v);            ClosePoly();            points->Unuse();            }        }    else        {        newClip=new(Clip);        newClip->cClip();        newClip->MakeQDClip(points);        if(0==(newClip=ClipClipQD(newClip)))return 0;#if VWT /* jca 17 Sept 93. Not in VR { */       if(polyFilter)            {            V_Array *points=newClip->GetQDOutline();            if(filter)filter->SavePoly(points,color,lineColor,mode);            points->dArray();            return TRUE;            }#endif // VWT jca 17 Sept 93 }        poly=OpenPoly();        newClip->DrawTrap();        ClosePoly();        newClip->dClip();        }                // ABD 3D PICK 8/13/93 v// THIS CODE NEEDS TO BE PORTED TO WINDOWS!!!! PORT ME!!!!	if (polyCheckMode)	// ABD	{	Rect b;		// ignore transparent, untextured surface features -- this allows us to click through		// transparent windows.  		if (CAN_PICK_THROUGH_OBJECT(gCurrentObj))		{			// do nothing		}		else		{		// we've got a polygon now -- instead of drawing it lets see if the point		// we were given is in this polygon.  If it is, then we update the gClickObj struct		// to be the same as the object we are currently drawing, saved in the gCurrentObj struct.		// The only problem is that the stupid mac polygon routines do not support PtInPoly,		// so we check the bounds of the polygon first, and then if the point is in the bounds		// of the polygon we go ahead and make a region out of it, and check the region.  Blech.				b = (*poly)->polyBBox;		if (PtInRect(checkPolyLocation, &b))		{		RgnHandle rgn;					// create a temporary region to test			rgn = NewRgn();			OpenRgn();			FramePoly(poly);		// make a region out of the qd poly			CloseRgn(rgn);						// if we clicked in this poly, then save the current object			if (PtInRgn(checkPolyLocation, rgn))				gClickObj = gCurrentObj;					// dispose of our temporary region			DisposeRgn(rgn);		}		}	}	else	// ABD actually drawing this polygon (not a 3D pick)	{		// ABD this is the same code that was here before -- just draw the poly instead of		// testing it			    if(color)VForeColor(color); // DAS-1BIT-FIX 9/13/93	    frame=mode&CLIP_FRAME;// DAS-VR&VWT-BUGFIX 9/11/93// This same code is used to create the design view images now	    if(penmode)VPenMode(penmode);	    if(mode&CLIP_FILL)	        {	        if(pattern)VSetPattern(pattern);	        PaintPoly(poly);	        }//	    VSetPenNormal();	    if(frame)			{			// ABD moved following lines around JAN95			// to fix black surf features in 1-bit mode			if(lineColor)VForeColor(lineColor);// DAS-1BIT-FIX 9/13/93			VSetPattern(linepattern);		// MERGE-BUG			FramePoly(poly);	        }	}  // ABD 3D PICK 8/13/93 ^            KillPoly(poly);#elif WINDOWS    HRGN rgn;    POINT *wp;	int	savePattern;	// jca 8 aug 93	VPenState savePen;    if(type==0)/*then just draw the whole thing*/        {#if VWT /* jca 17 Sept 93. Not in VR { */        if(polyFilter)            {            if(filter)filter->SavePoly(points,color,lineColor,mode);            return TRUE;            }        else#endif // VWT jca 17 Sept 93 }            {            points->CopyArray(polyPts);            polyPts->Get(0,&tp);            polyPts->Append(&tp);            }        }    else        {        newClip=new(Clip);        newClip->cClip();        newClip->MakeQDClip(points);        if(0==(newClip=ClipClipQD(newClip)))return 0;#if VWT /* jca 17 Sept 93. Not in VR { */        if(polyFilter)            {            V_Array *points=newClip->GetQDOutline();            if(filter)filter->SavePoly(points,color,lineColor,mode);            points->dArray();            return TRUE;            }#endif // VWT jca 17 Sept 93 }        newClip->DrawTrap();        newClip->dClip();        }        // jca 4 Oct 93 {  port of pick code	if (polyCheckMode)	// ABD		{		Rect b;		// ignore transparent, untextured surface features -- this allows us to click through		// transparent windows.  		if (CAN_PICK_THROUGH_OBJECT(gCurrentObj))			{			// do nothing			}		else			{			// ABD MERGE-S171 [[[			int pt_in_clip;	// ABD MERGE-S171		// we've got a polygon now -- instead of drawing it lets see if the point		// we were given is in this polygon.  If it is, then we update the gClickObj struct		// to be the same as the object we are currently drawing, saved in the gCurrentObj struct.		// The only problem is that the stupid mac polygon routines do not support PtInPoly,		// so we check the bounds of the polygon first, and then if the point is in the bounds		// of the polygon we go ahead and make a region out of it, and check the region.  Blech.		// ABD MERGE-S171 we need to check the clip region to make sure we are clicking in		// it.  If the length of this clip region is zero, then there is no clip region so      // everything is okay.			if (ALength() == 0)				pt_in_clip = TRUE;			else			{			struct semitrap *st;			int found;				// make sure point is in clip region				pt_in_clip = FALSE;				// st is a list of semitraps, which contain 2 points defining the top/bottom				// edges of a bunch of stacked trapezoids.  We know the click loc, so find the				// actual trapezoid we may have clicked in.  Then            	found = FALSE;				st = (struct semitrap *)Use();				for ( i = ALength()-1 ; i >= 0 ; i-- )				{					if (st[i].left.v > checkPolyLocation.v)		// remember right.v == left.v					{               		found = TRUE;					break;               		}				}				// one more check -- make sure point is not above clip completely				if (i == ALength() - 1)					found = FALSE;            // now i contains the location of the first semitrap below checkPolyLocation				// now construct an actual clip poly from the trap -- if i is 0 then the				// clip poly is below the click loc, so we are not in the clip, and if i is				// not less than ALength then we are below the clip.				if (found)				{				Point pts[4];            int j = 0;				HRGN rgn;            	// start with upper left					pts[j++] = st[i+1].left;               // append the upper right if it is different from upper left					if (st[i+1].right.h != st[i+1].left.h)						pts[j++] = st[i+1].right;               // append the lower right					pts[j++] = st[i].right;               // append the lower left if it is different from lower right					if (st[i].right.h != st[i].left.h)						pts[j++] = st[i].left;					// create a temporary region to test					rgn = CreatePolygonRgn((POINT*)pts, j, WINDING);					// if we clicked in this poly, then save the current object					if (PtInRegion(rgn, checkPolyLocation.h, checkPolyLocation.v))						pt_in_clip = TRUE;							// dispose of our temporary region					DeleteObject(rgn);				}				Unuse();			}      	// only check the surface if the point is also in this clip region			if (pt_in_clip)				{				wp = (LPPOINT) points->Use();				// create a temporary region to test				rgn = CreatePolygonRgn(wp, points->ALength(), WINDING);				// if we clicked in this poly, then save the current object				if (PtInRegion(rgn, checkPolyLocation.h, checkPolyLocation.v))					gClickObj = gCurrentObj;						// dispose of our temporary region				DeleteObject(rgn);				points->Unuse();	// jca 25 Oct 93.  Oops.				}			// ABD MERGE-S171 ]]]			}		}	else	// ABD actually drawing this polygon (not a 3D pick)		{		// ABD this is the same code that was here before -- just draw the poly instead of		// testing it		if (pattern)	savePattern = VGetPattern();   // save state.  jca 8 aug 93		if (penmode)	VGetPen(&savePen);		if(penmode)VPenMode(penmode);		if(color)VForeColor(color);// DAS-1BIT-FIX 9/13/93    	if(mode&CLIP_FILL)        	{        	if(pattern)VSetPattern(pattern);			PaintPoly(polyPts);       	 	}	//  VSetPenNormal();    	if(mode&CLIP_FRAME)			{			RGBColor patColor;            int		saveLinePattern;			int 	useGray=FALSE;			if (linepattern)				{				saveLinePattern = VGetPattern();  // jca 11Apr94 save state.  We don't want to change it here.				VSetPattern(linepattern);		// MERGE-BUG                }			if(lineColor)VForeColor(lineColor);// DAS-1BIT-FIX 9/13/93			// why? Well, Windows doesn't support patterned pens.			// Dotted, dashed, and solid are all that Windows can offer			// so we check out the pen pattern (we've already set it, if			// we were going to) and change the line color based on that.			// jca 16MAR94			switch(VGetPattern())				{				// there's not enough range of greys to make any                // difference.				case vPatLtGray:				case vPatGray:				case vPatDkGray:                	useGray = TRUE;					VSetColor(patColor, 0x8000, 0x8000, 0x8000);                    VForeColor(&patColor);                	break;				}			FramePoly(polyPts);			if (useGray)            	{				if(color)	VForeColor(color);// jca 28MAR94 undo grey color/pat				else		VForeColor(&vBlack);				}			if (linepattern)      // jca 11Apr94 restore pattern            	VSetPattern(saveLinePattern);			}		if (pattern)	VSetPattern(savePattern);   // restore state. jca 8 aug 93		if (penmode)	VSetPen(&savePen);		}		// jca 4 Oct 93 }#endif //WINDOWS    return TRUE;}#if WINDOWS#include "ShowTest.h"voidPaintPoly(V_Array *points)    {	static LOGPEN nullLOGPEN = { PS_NULL, { 1, 1 }, 0 };	HPEN oldPen, nullPen;	long length;    POINT *p;	nullPen = CreatePenIndirect(&nullLOGPEN);	oldPen = SelectObject(currentDevice,nullPen);    length = points->ALength();    p = (POINT*)points->Use();    Polygon(currentDevice,p,length);    points->Unuse();	SelectObject(currentDevice,oldPen);	DeleteObject(nullPen);	}voidFramePoly(V_Array *points)    {    long length;    POINT *p;    length = points->ALength();    p = (POINT*)points->Use();    Polyline(currentDevice,p,length);    points->Unuse();    }#endif/*------------------------------------------------------------------------------ * Clip* Clip::MakeQDClip(V_Array *poly) * * Create this clipping poly based on the polygon poly. *------------------------------------------------------------------------------*/#define intersect(rval,x1,y1,x2,y2,y3)  \{                                       \int xx1=x1;                             \int yy1=y1;                             \register int dx=x2-xx1,dy1=y3-yy1,dy2=y2-yy1;   \register long d;                        \if(dy2)                                 \    {                                   \    d=(long)dx*dy1;                     \    rval=xx1+d/dy2;                     \    }                                   \else rval=xx1;                          \}Clip *Clip::MakeQDClip(V_Array *parray){int qt=FALSE;long index=0,index_left=0,index_right,i=0,old_left,old_right;Point *pt;long lngth=parray->ALength();semitrap last,st,lastval;SetLength(0);if(lngth<=2)    {    contain.top=-32000; contain.bottom=32000;    return this;    }type=TRUE;pt=(Point *)parray->Use();/*find the highest vertical (y) value of the array*/for(i=1;i<lngth;i++)if(pt[index_left].v<pt[i].v)index_left=i;index_right=index_left;last.left.v=last.right.v=pt[index_right].v;while(!qt && last.left.v==pt[index_left].v)    {    old_left=index_left;    index_left=nextNum(index_left,lngth);    if(index_left==index_right)qt=TRUE;    }last.left.h=pt[old_left].h;while(!qt && last.left.v==pt[index_right].v)    {    old_right=index_right;    index_right=previousNum(index_right,lngth);    if(old_left==index_right)qt=TRUE;    }if(!qt)    {    last.right.h=pt[old_right].h;    contain.left=last.left.h;    contain.right=last.right.h;    contain.top=pt[old_left].v;    last.lcross=last.rcross=TRUE;    Append(&last);    }while(!qt)    {    if(pt[index_left].v>pt[index_right].v)        {        st.left.v=st.right.v=pt[index_left].v;        st.left.h=pt[index_left].h;        st.lcross=TRUE;        st.rcross=FALSE;        intersect(st.right.h,last.right.h,last.left.v,pt[index_right].h,pt[index_right].v,st.left.v);        if(contain.left>pt[index_left].h)contain.left=pt[index_left].h;        index=index_left;        if(index_left==index_right)qt=TRUE;        index_left=nextNum(index_left,lngth);        if(st.left.h>st.right.h)/*this is a hack to prevent even worse problems later*/            {            last.left=st.right;            last.lcross=st.rcross;            last.right=st.left;            last.lcross=st.rcross;            }        else last=st;        Append(&last);        }    else if(pt[index_left].v<pt[index_right].v)        {        st.left.v=st.right.v=pt[index_right].v;        st.right.h=pt[index_right].h;        st.lcross=FALSE;        st.rcross=TRUE;        intersect(st.left.h,last.left.h,last.left.v,pt[index_left].h,pt[index_left].v,st.left.v);        if(contain.right<pt[index_right].h)contain.right=pt[index_right].h;        if(index_left==index_right)qt=TRUE;        index_right=previousNum(index_right,lngth);        if(st.left.h>st.right.h)/*this is a hack to prevent even worse problems later*/            {            last.left=st.right;            last.lcross=st.rcross;            last.right=st.left;            last.lcross=st.rcross;            }        else last=st;        Append(&last);        }    else /* pt[index_left].v==pt[index_right].v */        {        st.left.v=st.right.v=pt[index_left].v;        st.left.h=pt[index_left].h;        st.right.h=pt[index_right].h;        st.lcross=st.rcross=TRUE;        if(contain.left>pt[index_left].h)contain.left=pt[index_left].h;        if(contain.right<pt[index_right].h)contain.right=pt[index_right].h;        index=index_left;        if(index_left==index_right)qt=TRUE;        index_left=nextNum(index_left,lngth);        if(index_left==index_right)qt=TRUE;        index_right=previousNum(index_right,lngth);        if(st.left.h>st.right.h)/*this is a hack to prevent even worse problems later*/            {            last.left=st.right;            last.lcross=st.rcross;            last.right=st.left;            last.lcross=st.rcross;            }        else last=st;        Append(&last);        }           }contain.bottom=pt[index].v;parray->Unuse();return this;}/*------------------------------------------------------------------------------ * Clip * Clip::ClipClipQD(Clip *trap2) * This routine is destructive.  The trap2 value will be lost after the new * clip object has been created. *------------------------------------------------------------------------------*/Clip *Clip::ClipClipQD(Clip *trap2){Clip *ptrap;int l1=ALength();int l2=trap2->ALength();semitrap *st1;semitrap *st2;semitrap last;int index1=0,index2=0;semitrap tt1,tb1,tt2,tb2;int bottom;if(l2<=1){    trap2->dClip();    return 0;    }if(type==0)return trap2;if(contain.left>trap2->contain.right){trap2->dClip(); return 0;}if(contain.right<trap2->contain.left){trap2->dClip(); return 0;}if(contain.bottom>=trap2->contain.top){trap2->dClip(); return 0;}if(contain.top<=trap2->contain.bottom){trap2->dClip(); return 0;}/* We know now that the containing rects overlap*/st1=(semitrap *)Use();st2=(semitrap *)trap2->Use();while(index1 < l1 && st1[index1].left.v >= st2[index2].left.v)index1++;if(index1==l1){Unuse(); trap2->Unuse(); trap2->dClip(); return 0;}/*st1 is entirely on top of st2*/if(index1==0)/*the top of st1 is equal or less than the top of st2*/    {    while(index2 < l2 && st2[index2].left.v >= st1[index1].left.v)index2++;    if(index2==l2){Unuse(); trap2->Unuse();trap2->dClip(); return 0;}/*st2 is entirely on top of st1*/    if(index2==0)/*the top of st1 is NOT the same as the top of st2*/        {        last.left.v=last.right.v=st2[index2].left.v;        }    else    index2--;     }else index1--; /*we now have the starting trapezoids to begin working from*/if(st1[index1].left.v<st2[index2].left.v)/*1 cuts into 2*/    {    tt1=st1[index1];    tt2.left.v=tt2.right.v=tt1.left.v;    tt2.rcross=tt2.lcross=FALSE;     intersect(tt2.left.h,st2[index2].left.h,st2[index2].left.v,                       st2[index2+1].left.h,st2[index2+1].left.v,tt2.left.v);    intersect(tt2.right.h,st2[index2].right.h,st2[index2].left.v,                       st2[index2+1].right.h,st2[index2+1].left.v,tt2.left.v);    }else if(st1[index1].left.v>st2[index2].left.v)    {    tt2=st2[index2];    tt1.left.v=tt1.right.v=tt2.left.v;    tt1.lcross=tt1.rcross=FALSE;    intersect(tt1.left.h,st1[index1].left.h,st1[index1].left.v,                       st1[index1+1].left.h,st1[index1+1].left.v,tt1.left.v);    intersect(tt1.right.h,st1[index1].right.h,st1[index1].left.v,                       st1[index1+1].right.h,st1[index1+1].left.v,tt1.left.v);    }else /*st1[index1].left.v==st2[index2].left.v */    {    tt1=st1[index1];    tt2=st2[index2];    }/*This is the core of the routine.  Up to this point it was simply set up.*/ptrap=new(Clip);/*make a place to put the stuff*/ptrap->cArray(0,sizeof(semitrap),8);ptrap->type=TRUE;ptrap->method=method;/*make sure that this is the same*//*we need to find the top of the first trapezoid (if any)*/if(tt1.left.h>=tt2.left.h)tb1.left=tt1.left;else tb1.left=tt2.left;if(tt1.right.h<=tt2.right.h)tb1.right=tt1.right; else tb1.right=tt2.right; if(tb1.left.h<=tb1.right.h)/*we add the first trapezoid here*/    {    tb1.lcross=tb1.rcross=TRUE;    ptrap->contain.left=tb1.left.h;    ptrap->contain.right=tb1.right.h;    ptrap->contain.top=tt1.left.v;    ptrap->Append(&tb1);    }l1-=2; l2-=2;while(index1<=l1 && index2<=l2)    {    bottom = index1==l1 || index2==l2;    if(st1[index1+1].left.v>st2[index2+1].left.v)/*1 cuts into 2*/        {        tb1=st1[index1+1];        index1++;        tb2.left.v=tb2.right.v=tb1.left.v;        intersect(tb2.left.h,st2[index2].left.h,st2[index2].left.v,                           st2[index2+1].left.h,st2[index2+1].left.v,tb2.left.v);        intersect(tb2.right.h,st2[index2].right.h,st2[index2].right.v,                           st2[index2+1].right.h,st2[index2+1].right.v,tb2.left.v);        if(bottom || tb2.left.h==tb1.left.h)tb2.lcross=TRUE;        else tb2.lcross=FALSE;        if(bottom || tb2.right.h==tb1.right.h)tb2.rcross=TRUE;        else tb2.rcross=FALSE;        }    else if(st1[index1+1].left.v<st2[index2+1].left.v)        {        tb2=st2[index2+1];        index2++;        tb1.left.v=tb1.right.v=tb2.left.v;        intersect(tb1.left.h,st1[index1].left.h,st1[index1].left.v,                           st1[index1+1].left.h,st1[index1+1].left.v,tb1.left.v);        intersect(tb1.right.h,st1[index1].right.h,st1[index1].right.v,                           st1[index1+1].right.h,st1[index1+1].right.v,tb1.left.v);        if(bottom || tb2.left.h==tb1.left.h)tb1.lcross=TRUE;        else tb1.lcross=FALSE;        if(bottom || tb2.right.h==tb1.right.h)tb1.rcross=TRUE;        else tb1.rcross=FALSE;        }    else /*st1[index1+1].left.v==st2[index2+1].left.v */        {        index1++;        index2++;        tb1=st1[index1];        tb2=st2[index2];        if(bottom)            tb1.lcross=tb1.rcross=tb2.lcross=tb2.rcross=TRUE;        }    if(tt1.left.v==tb1.left.v)        {        if(ptrap->length==0)            {            tb1.lcross=tb1.rcross=tb2.lcross=tb2.rcross=TRUE;            }        else /*all we care about is tb*/            {            tt1.lcross=tb1.lcross || tb2.lcross;            tt1.rcross=tb1.rcross || tb2.rcross;            if(tb1.left.h<tb2.left.h){tt1.left.h=tb2.left.h;}            else {tt1.left.h=tb1.left.h; tt1.lcross=tb1.lcross;}            if(tb1.right.h<tb2.right.h){tt1.right.h=tb1.right.h;}            else {tt1.right.h=tb2.right.h; tt1.rcross=tb2.rcross;}            if(tt1.left.h<=tt1.right.h)                ptrap->Append(&tt1);            }        }    else        TI(&tt1,&tb1,&tt2,&tb2,ptrap);    tt1=tb1;    tt2=tb2;    }/*we are done, now clean up and get out of here*/Unuse();trap2->Unuse();if(ptrap->ALength()>1)    {    st1=(semitrap *)VA_Abuse(ptrap);// DAS-LIZARD KING 10/2/93    if(st1[ptrap->length-1].left.v==st1[ptrap->length-2].left.v)        {        ptrap->SetLength(ptrap->length-1);        ptrap->Get(ptrap->length-1,&tt1);        tt1.lcross=tt1.rcross=TRUE;        ptrap->Put(ptrap->length-1,&tt1);        }    trap2->dClip();        return ptrap;    }else trap2->dClip();ptrap->dArray();return 0;}Point CrissCross(Point p1, Point p2, Point q1, Point q2);Point CrissCross(Point p1, Point p2, Point q1, Point q2){Point p;int px,py,qx,qy,pqx,pqy,st;long d,t,t1,t2,x,y,tt,d2;px=p1.h-p2.h;py=p1.v-p2.v;if(px<0)    {    px=-px;    py=-py;    }qx=q2.h-q1.h;qy=q2.v-q1.v;t1=(long)px*qy;t2=(long)py*qx;d=t1-t2;if(d==0)return p1;else    {    pqx=q2.h-p2.h;    pqy=q2.v-p2.v;    t1=(long)qy*pqx;    t2=(long)qx*pqy;    t=t1-t2;    tt = t & 0xFFFF8000; /* GBA 7/26/90 - bug fixed */     if (tt!=0x00000000 && tt!=0xFFFF8000)        {        p.h=p2.h+(t*px)/d;        p.v=p2.v+(t*py)/d;        }    else        {        st=t;        x=(long)st*px;        p.h=p2.h+x/d;        y=(long)st*py;        p.v=p2.v+y/d;        }    }return p;}void Clip::TI(semitrap *xtt1, semitrap *xtb1, semitrap *xtt2, semitrap *xtb2,Clip *ptrap){semitrap tr,tm;semitrap tt1=*xtt1,tt2=*xtt2,tb1=*xtb1,tb2=*xtb2;Point pleft,pright;int ml,mr;int forceTop= ptrap->length==0;/*are there any overlaps? Ignore single points on top.*/if(tt1.left.h>=tt2.right.h && tb1.left.h>tb2.right.h)    return;if(tt2.left.h>=tt1.right.h && tb2.left.h>tb1.right.h)    return;/*first we cut trap 2 with the left side of trap 1*//*there is no cut*/if(tt1.left.h<=tt2.left.h && tb1.left.h<=tb2.left.h)    {    if(tt1.left.h==tt2.left.h)tt2.lcross=tt1.lcross || tt2.lcross;    if(tb1.left.h==tb2.left.h)tb2.lcross=tb1.lcross || tb2.lcross;    ml=FALSE;    }/*t1.left cuts t2.left off completely*/else if(tt1.left.h>=tt2.left.h && tb1.left.h>=tb2.left.h)    {    if(tt1.left.h==tt2.left.h)tt2.lcross=tt1.lcross || tt2.lcross;    else {tt2.left=tt1.left; tt2.lcross=tt1.lcross;}        if(tb1.left.h==tb2.left.h)tb2.lcross=tb1.lcross || tb2.lcross;    else {tb2.left=tb1.left; tb2.lcross=tb1.lcross;}    ml=FALSE;    }else  if(tt1.left.h<=tt2.left.h && tb1.left.h>=tb2.left.h)    {    tm.left=CrissCross(tt1.left,tb1.left,tt2.left,tb2.left);    tm.lcross=TRUE;    ml=TRUE;    if(tb2.left.h==tb1.left.h)tb2.lcross=tb2.lcross || tb1.lcross;    else tb2.lcross=tb1.lcross;    tb2.left=tb1.left;    }else  if(tt1.left.h>=tt2.left.h && tb1.left.h<=tb2.left.h)    {    tm.left=CrissCross(tt1.left,tb1.left,tt2.left,tb2.left);    tm.lcross=TRUE;    ml=TRUE;    if(tt2.left.h==tt1.left.h)tt2.lcross=tt1.lcross || tt2.lcross;    else tt2.lcross=tt1.lcross;    tt2.left=tt1.left;    }        /*now we cut trap 2 with the right side of trap 1*//*there is no cut*/if(tt1.right.h>=tt2.right.h && tb1.right.h>=tb2.right.h)    {    if(tt1.right.h==tt2.right.h)tt2.rcross=tt1.rcross || tt2.rcross;    if(tb1.right.h==tb2.right.h)tb2.rcross=tb1.rcross || tb2.rcross;    mr=FALSE;    }/*t1.left cuts t2.right off completely*/else if(tt1.right.h<=tt2.right.h && tb1.right.h<=tb2.right.h)    {    if(tt2.right.h==tt1.right.h){tt2.rcross=tt1.rcross || tt2.rcross;}    else {tt2.right=tt1.right;tt2.rcross=tt1.rcross;}    if(tb2.right.h==tb1.right.h){tb2.rcross=tb1.rcross || tb2.rcross;}    else {tb2.right=tb1.right; tb2.rcross=tb1.rcross;}    mr=FALSE;    }else  if(tt1.right.h>=tt2.right.h && tb1.right.h<=tb2.right.h)    {    tm.right=CrissCross(tt1.right,tb1.right,tt2.right,tb2.right);    tm.rcross=TRUE;    mr=TRUE;    if(tb2.right.h==tb1.right.h)tb2.rcross=tb2.rcross || tb1.rcross;    else tb2.rcross=tb1.rcross;    tb2.right=tb1.right;    }else  if(tt1.right.h<=tt2.right.h && tb1.right.h>=tb2.right.h)    {    tm.right=CrissCross(tt1.right,tb1.right,tt2.right,tb2.right);    tm.rcross=TRUE;    mr=TRUE;    if(tt2.right.h==tt1.right.h)tt2.rcross=tt1.rcross || tt2.rcross;    else tt2.rcross=tt1.rcross;    tt2.right=tt1.right;    }/*we have the left and right boundaries, so now lets intersect these*//*from the top...*/if(tt2.left.h>tt2.right.h)/*then we have a crossing at the top*/    {    if(ml)pleft=tm.left;    else pleft=tb2.left;    if(mr)pright=tm.right;    else pright=tb2.right;    tr.left=tr.right=CrissCross(tt2.left,pleft,tt2.right,pright);    if(tr.left.v!=tb1.left.v)        {        tr.lcross=tr.rcross=TRUE;        if(ptrap->length==0)ptrap->contain.top=tr.left.v;        if(tr.left.h<ptrap->contain.left)ptrap->contain.left=tr.left.h;        if(tr.right.h>ptrap->contain.right)ptrap->contain.right=tr.right.h;        ptrap->Append(&tr);        forceTop=FALSE;        }    else {forceTop=TRUE; tb2.lcross=tb2.rcross=TRUE;}    }/*now get the middle pieces*/if(ml)    {    if(mr)        {        if(tm.left.v==tm.right.v)            {            if(tm.left.h<ptrap->contain.left)ptrap->contain.left=tm.left.h;            if(tm.right.h>ptrap->contain.right)ptrap->contain.right=tm.right.h;            ptrap->Append(&tm);            forceTop=FALSE;            }        else if(tm.left.v<tm.right.v)            {            tr.right=tm.right;            tr.rcross=tm.rcross;            tr.left.v=tm.right.v;            intersect(tr.left.h,tt2.left.h,tt2.left.v,tm.left.h,tm.left.v,tr.left.v);            tr.lcross=FALSE;            if(tr.left.h<ptrap->contain.left)ptrap->contain.left=tr.left.h;            if(tr.right.h>ptrap->contain.right)ptrap->contain.right=tr.right.h;            if(forceTop){ptrap->contain.top=tr.left.v; tr.lcross=tr.rcross=TRUE;forceTop=FALSE;}            ptrap->Append(&tr);            tr.left=tm.left;            tr.lcross=tm.lcross;            tr.right.v=tm.left.v;            intersect(tr.right.h,tm.right.h,tm.right.v,tb2.right.h,tb2.right.v,tr.right.v);            tr.rcross=FALSE;            if(tr.left.h<ptrap->contain.left)ptrap->contain.left=tr.left.h;            if(tr.right.h>ptrap->contain.right)ptrap->contain.right=tr.right.h;            ptrap->Append(&tr);            }        else /*tm.left.v>tm.right.v*/            {            tr.left=tm.left;            tr.lcross=tm.lcross;            tr.right.v=tm.left.v;            intersect(tr.right.h,tt2.right.h,tt2.right.v,tm.right.h,tm.right.v,tr.right.v);            tr.rcross=FALSE;            if(tr.left.h<ptrap->contain.left)ptrap->contain.left=tr.left.h;            if(tr.right.h>ptrap->contain.right)ptrap->contain.right=tr.right.h;            if(forceTop){ptrap->contain.top=tr.left.v; tr.lcross=tr.rcross=TRUE;forceTop=FALSE;}            ptrap->Append(&tr);            tr.right=tm.right;            tr.rcross=tm.rcross;            tr.left.v=tm.right.v;            intersect(tr.left.h,tm.left.h,tm.left.v,tb2.left.h,tb2.left.v,tr.left.v);            tr.lcross=FALSE;            if(tr.left.h<ptrap->contain.left)ptrap->contain.left=tr.left.h;            if(tr.right.h>ptrap->contain.right)ptrap->contain.right=tr.right.h;            ptrap->Append(&tr);            }        }    else /*only middle left crosses*/        {        tr.left=tm.left;        tr.lcross=tm.lcross;        tr.right.v=tm.left.v;        intersect(tr.right.h,tt2.right.h,tt2.right.v,tb2.right.h,tb2.right.v,tr.right.v);        tr.rcross=FALSE;        if(tr.left.h<ptrap->contain.left)ptrap->contain.left=tr.left.h;        if(tr.right.h>ptrap->contain.right)ptrap->contain.right=tr.right.h;        if(forceTop){ptrap->contain.top=tr.left.v; tr.lcross=tr.rcross=TRUE;forceTop=FALSE;}        ptrap->Append(&tr);        }    }else if(mr)    {    tr.right=tm.right;    tr.rcross=tm.rcross;    tr.left.v=tm.right.v;    intersect(tr.left.h,tt2.left.h,tt2.left.v,tb2.left.h,tb2.left.v,tr.left.v);    tr.lcross=FALSE;    if(tr.left.h<ptrap->contain.left)ptrap->contain.left=tr.left.h;    if(tr.right.h>ptrap->contain.right)ptrap->contain.right=tr.right.h;    if(forceTop){ptrap->contain.top=tr.left.v; tr.lcross=tr.rcross=TRUE;forceTop=FALSE;}    ptrap->Append(&tr);    }/*finally, get the bottom piece*/if(tb2.left.h>tb2.right.h)    {    if(ml)pleft=tm.left;    else pleft=tt2.left;    if(mr)pright=tm.right;    else pright=tt2.right;    tr.left=tr.right=CrissCross(pleft,tb2.left,pright,tb2.right);    if(tr.left.v!=tt1.left.v)        {        tr.lcross=tr.rcross=TRUE;        if(tr.left.h<ptrap->contain.left)ptrap->contain.left=tr.left.h;        if(tr.right.h>ptrap->contain.right)ptrap->contain.right=tr.right.h;        ptrap->contain.bottom=tr.left.v;        if(forceTop){ptrap->contain.top=tr.left.v; tr.lcross=tr.rcross=TRUE;forceTop=FALSE;}        ptrap->Append(&tr);        }    else         {        ptrap->Get(ptrap->length-1,&tr);        tr.lcross=tr.rcross=TRUE;        ptrap->Put(ptrap->length-1,&tr);        }    }else    {    if(tb2.lcross || tb2.rcross)        {        if(forceTop)            {            if(tt2.left.h<=tt2.right.h)                {                if(tt2.left.h<ptrap->contain.left)ptrap->contain.left=tt2.left.h;                if(tt2.right.h>ptrap->contain.right)ptrap->contain.right=tt2.right.h;                ptrap->contain.bottom=tt2.left.v;                tt2.lcross=tt2.rcross=TRUE;                ptrap->Append(&tt2);                ptrap->contain.top=tt2.left.v;                }            else{                ptrap->contain.top=tb2.left.v;                tb2.lcross=tb2.rcross=TRUE;                }            forceTop=FALSE;            }        if(tb2.left.h<ptrap->contain.left)ptrap->contain.left=tb2.left.h;        if(tb2.right.h>ptrap->contain.right)ptrap->contain.right=tb2.right.h;        ptrap->contain.bottom=tb2.left.v;        ptrap->Append(&tb2);        }    else if(tb2.left.h==tb2.right.h)        {        tb2.lcross=TRUE;        if(tb2.left.h<ptrap->contain.left)ptrap->contain.left=tb2.left.h;        if(tb2.right.h>ptrap->contain.right)ptrap->contain.right=tb2.right.h;        ptrap->contain.bottom=tb2.left.v;        if(forceTop){ptrap->contain.top=tb2.left.v; tb2.lcross=tb2.rcross=TRUE;forceTop=FALSE;}        ptrap->Append(&tb2);        }    }}void Clip::DrawTrap(void){register long i;long lngth=ALength();semitrap *strap=(semitrap *)Use();#if MACINTOSHVMoveTo(strap[0].left.h,strap[0].left.v);for(i=1;i<lngth;i++)    if(strap[i].lcross)        VLineTo(strap[i].left.h,strap[i].left.v);for(i=lngth-1;i>=0;i--)    if(strap[i].rcross)        VLineTo(strap[i].right.h,strap[i].right.v);VLineTo(strap[0].left.h,strap[0].left.v);#endif //MACINTOSH#if WINDOWSpolyPts->SetLength(0);polyPts->Append(&strap[0].left);for(i=1;i<lngth;i++)    if(strap[i].lcross)        polyPts->Append(&strap[i].left);for(i=lngth-1;i>=0;i--)    if(strap[i].rcross)        polyPts->Append(&strap[i].right);polyPts->Append(&strap[0].left);#endif //WINDOWSUnuse();}V_Array *Clip::GetQDOutline(void){register long i;long lngth=ALength();V_Array *points;semitrap *strap=(semitrap *)Use();points=new(V_Array);points->cArray(0,sizeof(Point),8);points->Append(&strap[0].left);for(i=1;i<lngth;i++)    if(strap[i].lcross)        points->Append(&strap[i].left);for(i=lngth-1;i>=0;i--)    if(strap[i].rcross)        points->Append(&strap[i].right);Unuse();return points;}/*------------------------------------------------------------------------------ *------------------------------------------------------------------------------*/void Clip::GetRect(Rect *r){r->top=ytop;r->bottom=ytop+length;r->left=left;r->right=right;}// ABD 3D PICK 8/13/93 removed obsolete 3d pick routines that were here#if 1/*------------------------------------------------------------------------------ * int LongClipRect(PointLong p1, PointLong p2,Rect *r) * * Clip the line determined by the long Points p1 and p2 to the int rectangle * r.  If the line is clipped away entirely, return FALSE. *------------------------------------------------------------------------------*/#define ClipX(x1,y1,x2,y2,y3)   x1+(y3-y1)*(x2-x1)/(y2-y1)#define ClipY(x1,y1,x2,y2,x3)   y1+(x3-x1)*(y2-y1)/(x2-x1)int LongClipRect(PointLong *p1, PointLong *p2,Rect *r){int count=2;PointLong transfer;while(count)    {    /*clip to the left*/    if(p1->h<r->left)        {        if(p2->h<r->left)return FALSE;        p1->v=ClipY(p1->h,p1->v,p2->h,p2->v,r->left);        p1->h=r->left;        }    /*clip to the right*/    if(p1->h>r->right)        {        if(p2->h>r->right)return FALSE;        p1->v=ClipY(p1->h,p1->v,p2->h,p2->v,r->right);        p1->h=r->right;        }    /*clip to the top*/    if(p1->v<r->top)        {        if(p2->v<r->top)return FALSE;        p1->h=ClipX(p1->h,p1->v,p2->h,p2->v,r->top);        p1->v=r->top;        }    /*clip to the bottom */    if(p1->v>r->bottom)        {        if(p2->v>r->bottom)return FALSE;        p1->h=ClipX(p1->h,p1->v,p2->h,p2->v,r->bottom);        p1->v=r->bottom;        }    transfer=*p1;*p1=*p2;*p2=transfer;    count--;    }if(p1->h==p2->h && p1->v==p2->v)return FALSE;else return TRUE;}/*------------------------------------------------------------------------------ * void LongClipPoly(V_Array *parray, Rect *r, PointLong dp) * void IndexLongClipPoly(V_Array *parray, V_Array * index, Rect *r, PointLong dp) * * * Clip a polygon to the int rectangle r.   *------------------------------------------------------------------------------*/V_Array *IndexLongClipPoly(V_Array *parray, V_Array *pindex, Rect *r, PointLong dp)    {    V_Array *cArray;    short *index;    int i,lngth;    PointLong *p1,*p2;        index=(short *)pindex->Use();    lngth=pindex->ALength();    if(!mArray)        {        mArray=new(V_Array);        mArray->cArray(lngth,sizeof(PointLong),8);        }    else mArray->SetLength(lngth);    p1=(PointLong *)VA_Abuse(parray);// DAS-LIZARD KING 10/2/93    p2=(PointLong *)VA_Abuse(mArray);// DAS-LIZARD KING 10/2/93    for(i=0;i<lngth;i++)p2[i]=p1[index[i]];    cArray = LongClipPoly(mArray,r,dp);    pindex->Unuse();    return cArray;    }/*--------------------------------------------------------------*/V_Array * LongClipPoly(V_Array *parray,Rect *sClip,PointLong dp){Rect    r;PointLong *poly,p,p2;Point *pt;long i,n;long lngth;dp.h += currentPane->centerX;dp.v += currentPane->centerY;r.left = sClip->left-currentPane->centerX;r.right = sClip->right-currentPane->centerX;r.top = sClip->top-currentPane->centerY;r.bottom = sClip->bottom-currentPane->centerY;VA_Truncate(clipPts);lngth=parray->ALength();poly=(PointLong *)parray->Use();if(!mArray)    {    mArray=new(V_Array);    mArray->cArray(0,sizeof(PointLong),8);    }if(!nArray)    {    nArray=new(V_Array);    nArray->cArray(0,sizeof(PointLong),8);    }else    {    VA_Truncate(nArray);    }/*---TOP-----------------------------------------------------------------*/for(i=0;i<lngth;i++)    {    n=nextNum(i,lngth);    p.h=poly[i].h-dp.h;    p.v=poly[i].v-dp.v;    p2.h=poly[n].h-dp.h;    p2.v=poly[n].v-dp.v;        if(p.v>=r.top)        {        nArray->Append(&p);        if(p2.v<r.top)            {            p.h=ClipX(p.h,p.v,p2.h,p2.v,r.top);            p.v=r.top;            nArray->Append(&p);            }        }    else if(p2.v>=r.top)        {        p.h=ClipX(p.h,p.v,p2.h,p2.v,r.top);        p.v=r.top;        nArray->Append(&p);        }    }parray->Unuse();lngth=nArray->ALength();if(lngth==0)return clipPts;/*---BOTTOM---------------------------------------------------------------*/VA_Truncate(mArray);poly=(PointLong *)nArray->Use();lngth=nArray->ALength();for(i=0;i<lngth;i++)    {    n=nextNum(i,lngth);    p.h=poly[i].h;    p.v=poly[i].v;    p2.h=poly[n].h;    p2.v=poly[n].v;    if(p.v<=r.bottom)        {        mArray->Append(&p);        if(p2.v>r.bottom)            {            p.h=ClipX(p.h,p.v,p2.h,p2.v,r.bottom);            p.v=r.bottom;            mArray->Append(&p);            }        }    else if(p2.v<=r.bottom)        {        p.h=ClipX(p.h,p.v,p2.h,p2.v,r.bottom);        p.v=r.bottom;        mArray->Append(&p);        }    }nArray->Unuse();lngth=mArray->ALength();if(lngth==0)return clipPts;/*---LEFT------------------------------------------------------------*/poly=(PointLong *)mArray->Use();VA_Truncate(nArray);for(i=0;i<lngth;i++)    {    n=nextNum(i,lngth);    p.h=poly[i].h;    p.v=poly[i].v;    p2.h=poly[n].h;    p2.v=poly[n].v;    if(p.h>=r.left)        {        nArray->Append(&p);        if(p2.h<r.left)            {            p.v=ClipY(p.h,p.v,p2.h,p2.v,r.left);            p.h=r.left;            nArray->Append(&p);            }        }    else if(p2.h>=r.left)        {        p.v=ClipY(p.h,p.v,p2.h,p2.v,r.left);        p.h=r.left;        nArray->Append(&p);        }    }mArray->Unuse();lngth=nArray->ALength();if(lngth==0)return clipPts;/*---RIGHT----------------------------------------------------------*/VA_Truncate(mArray);poly=(PointLong *)nArray->Use();for(i=0;i<lngth;i++)    {    n=nextNum(i,lngth);    p.h=poly[i].h;    p.v=poly[i].v;    p2.h=poly[n].h;    p2.v=poly[n].v;    if(p.h<=r.right)        {        mArray->Append(&p);        if(p2.h>r.right)            {            p.v=ClipY(p.h,p.v,p2.h,p2.v,r.right);            p.h=r.right;            mArray->Append(&p);            }        }    else if(p2.h<=r.right)        {        p.v=ClipY(p.h,p.v,p2.h,p2.v,r.right);        p.h=r.right;        mArray->Append(&p);        }    }nArray->Unuse();lngth=mArray->ALength();if(lngth==0)return clipPts;clipPts->SetLength(lngth);poly=(PointLong *)mArray->Use();pt=(Point*)clipPts->Use();for(i=0;i<lngth;i++,poly++,pt++)    { pt->h = poly->h; pt->v = -poly->v; }clipPts->Unuse();mArray->Unuse();return clipPts;}#endif// ABD 3D PICK 8/13/93 v/*------------------------------------------------------------------------------*//*	ABD 3D PICK	Pass this routine a ViewController, a point to test, and a ptr to an object specifier	record, and it will fill in the object specifier record with the object clicked on.*/void FindPoly(struct ViewController *c, Point p, struct ObjSpec *obj){	// turn on polyCheckMode	polyCheckMode = TRUE;		// set the click location	checkPolyLocation = p;		// make sure we start with no object	gCurrentObj.poly = NULL;	gCurrentObj.polyc = NULL;	gCurrentObj.surfNum = NO_SURFACE_SPEC;	gCurrentObj.surfSide = NO_SURFACE_SPEC;	gCurrentObj.surffeat = NULL;	gClickObj.poly = NULL;	gClickObj.polyc = NULL;	gClickObj.surfNum = NO_SURFACE_SPEC;	gClickObj.surfSide = NO_SURFACE_SPEC;	gClickObj.surffeat = NULL;		// do a fake update so that the pane gets "redrawn" and we can tell which	// polygon is under the point -- note that we do not update the observer 	// because we don't want the design view to be redrawn	c->Request(NULL, msgUpdate, obj3dPick, 0);		// turn off polyCheckMode	polyCheckMode = FALSE;		// return the object clicked upon	*obj = gClickObj;}// ABD 3D PICK 8/13/93 ^// JAM Exact Clipping 1-94 [[[	    			#define CLIPMINWIDTHHEIGHT 0	//MERGE-PRO-JAM-3voidClip::ClipClipExact(Clip *NewClip, V_Array *points){	short i;	long plength;	Point *p;	PointFFixed *ClipShapePtr, *NewClipShapePtr, *PointFFixedPtr;	LineData *LineEqtnsPtr, *NewLineEqtnsPtr;	long oldcliplength, newcliplength, hmin, vmin, hmax, vmax;	FFixed tempfixed;	long templong;		/*if this is first clip, then make the entered points the only clip*/	if(ClipShape == NULL)	{		plength = points->ALength();		NewClip->ClipShape = new(V_Array);	    NewClip->ClipShape->cArray(plength,sizeof(PointFFixed),8);	    ClipShapePtr = (PointFFixed *)NewClip->ClipShape->Use();		NewClip->LineEqtns = new(V_Array);	    NewClip->LineEqtns->cArray(plength,sizeof(LineData),8);	    LineEqtnsPtr = (LineData *)NewClip->LineEqtns->Use();		p = (Point *)points->Use();		for(i=0;i<plength;i++)		{			ClipShapePtr[i].h.intg = p[i].h;			ClipShapePtr[i].v.intg = p[i].v;			ClipShapePtr[i].h.frac = ClipShapePtr[i].v.frac = 0;		}		/*move screen poly in by 1/4th so that valid values will be on or inside		  the clip*/		hmin = hmax = ClipShapePtr[0].h.l;		vmin = vmax = ClipShapePtr[0].v.l;		for(i=1;i<plength;i++)		{			templong = ClipShapePtr[i].h.l;			if(templong < hmin) hmin = templong;			else if(templong > hmax) hmax = templong;			templong = ClipShapePtr[i].v.l;			if(templong < vmin) vmin = templong;			else if(templong > vmax) vmax = templong;		}		tempfixed.l = FixedPointFive.l >> 1;		NewClip->BoundingBox.top.l = vmin + tempfixed.l;		NewClip->BoundingBox.bottom.l = vmax - tempfixed.l;		NewClip->BoundingBox.left.l = hmin + tempfixed.l;		NewClip->BoundingBox.right.l = hmax - tempfixed.l;		//JAM added 4-15-94 to make frame lines not be drawn on screen        NewClip->ScreenRect = this->ScreenRect;		for(i=0;i<plength;i++)		{			if(ClipShapePtr[i].h.l == hmin) ClipShapePtr[i].h.l += tempfixed.l;			else ClipShapePtr[i].h.l -= tempfixed.l;			if(ClipShapePtr[i].v.l == vmin) ClipShapePtr[i].v.l += tempfixed.l;			else ClipShapePtr[i].v.l -= tempfixed.l;		}		for(i=1;i<plength;i++)		{			WinMakeLine(ClipShapePtr[i-1], ClipShapePtr[i], &(LineEqtnsPtr[i]));		}		WinMakeLine(ClipShapePtr[plength-1], ClipShapePtr[0], &(LineEqtnsPtr[0]));				points->Unuse();//JAM 6-3-93 [[[//JAM 6-3-93 altered so that a variable determines the minimum clipping window size.//this is so that for printing, bands which are small (3 pixels or less tall) will//not screw things up//		tempfixed.intg = 4; tempfixed.frac = 0;		if(NewClip->BoundingBox.right.l - NewClip->BoundingBox.left.l <= gGlobalWindowClipMin.l)		{			NewClip->reject = TRUE;		}		if(NewClip->BoundingBox.bottom.l - NewClip->BoundingBox.top.l <= gGlobalWindowClipMin.l)		{			NewClip->reject = TRUE;		}//JAM 6-3-93 ]]]//	    NewClip->LineEqtns->Unuse();//	    NewClip->ClipShape->Unuse();	    return;	}	else	{		plength = points->ALength();	    		p = (Point *)points->Use();        //JAM Frame Fix 27Sept94		if(WinClipToPoly(p, plength, &NewClipShapePtr, NULL, &newcliplength,	    				 CLIPMINWIDTHHEIGHT) == REJECT)	    {			NewClip->reject = TRUE;	    	points->Unuse();	    	return;	    }	    		points->Unuse();		    		hmin = hmax = NewClipShapePtr[0].h.l;		vmin = vmax = NewClipShapePtr[0].v.l;		for(i=1;i<newcliplength;i++)		{			templong = NewClipShapePtr[i].h.l;			if(templong < hmin) hmin = templong;			else if(templong > hmax) hmax = templong;			templong = NewClipShapePtr[i].v.l;			if(templong < vmin) vmin = templong;			else if(templong > vmax) vmax = templong;		}		NewClip->BoundingBox.top.l = vmin;		NewClip->BoundingBox.bottom.l = vmax;		NewClip->BoundingBox.left.l = hmin;		NewClip->BoundingBox.right.l = hmax;		//JAM added 4-15-94 to make frame lines not be drawn on screen        NewClip->ScreenRect = this->ScreenRect;		//bounding box too small?//JAM 6-3-93 [[[//JAM 6-3-93 altered so that a variable determines the minimum clipping window size.//this is so that for printing, bands which are small (3 pixels or less tall) will//not screw things up//		tempfixed.intg = 4; tempfixed.frac = 0;		if(NewClip->BoundingBox.right.l - NewClip->BoundingBox.left.l <= gGlobalWindowClipMin.l)		{			NewClip->reject = TRUE;			return;		}		if(NewClip->BoundingBox.bottom.l - NewClip->BoundingBox.top.l <= gGlobalWindowClipMin.l)		{			NewClip->reject = TRUE;			return;		}				//copy new clip info into new clip		NewClip->ClipShape = new(V_Array);	    NewClip->ClipShape->cArray(newcliplength,sizeof(PointFFixed),8);	    PointFFixedPtr = (PointFFixed *)NewClip->ClipShape->Use();	    for(i=0;i<newcliplength;i++)	    {	    	PointFFixedPtr[i] = NewClipShapePtr[i];	    }//		NewClip->ClipShape->Unuse();	    		NewClip->LineEqtns = new(V_Array);	    NewClip->LineEqtns->cArray(newcliplength,sizeof(LineData),8);	    NewLineEqtnsPtr = (LineData *)NewClip->LineEqtns->Use();		for(i=1;i<newcliplength;i++)		{			WinMakeLine(NewClipShapePtr[i-1], NewClipShapePtr[i], &(NewLineEqtnsPtr[i]));		}		WinMakeLine(NewClipShapePtr[newcliplength-1], NewClipShapePtr[0], &(NewLineEqtnsPtr[0]));//		NewClip->LineEqtns->Unuse();			    return;	}	}// JAM Exact Clipping 1-94 ]]]