/*------------------------------------------------------------------------------ * VWINDOWSÂ - the window object toolbox * * Copyright c 1991 by Virtus Corporation * All Rights Reserved * Written by David A. Smith * Virtus Corporation * 117 Edinburgh So * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * F2.c *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VMath.h"#include "VToolBox.h"#include "VDisplay.h"#include "VGUtil.h"#include "Clip.h"#include "Flash.h"#include "Gouraud.h"		// MERGE-GOURAUD/*------------------------------------------------------------------------------ * Define the function names *------------------------------------------------------------------------------ */#define FLine FLine2#define FLineClip FLineClip2#define FlashFill FlashFill2#define FlashClip FlashClip2#define FFixedFLine FFixedFLine2#define FlashGouraud 		FlashGouraud2			// MERGE-GOURAUD#define FlashGouraudClip 	FlashGouraudClip2		// MERGE-GOURAUD/*------------------------------------------------------------------------------ * Define the two major data types. *------------------------------------------------------------------------------ */typedef unsigned long VColorType[2];typedef unsigned char GColorType;		// MERGE-GOURAUDtypedef struct 	PixType{unsigned char * pixel;						int pos;						} PixType;static unsigned char pixbits[]={0xC0,0x30,0x0C,0x03};static unsigned long lMask[]={0,0x3FFFFFFF,0x0FFFFFFF,0x03FFFFFF,						0x00FFFFFF,0x003FFFFF,0x000FFFFF,0x0003FFFF,						0x0000FFFF,0x00003FFF,0x00000FFF,0x000003FF,						0x000000FF,0x0000003F,0x0000000F,0x00000003};static unsigned long rMask[]={0,0xC0000000,0xF0000000,0xFC000000,						0xFF000000,0xFFC00000,0xFFF00000,0xFFFC0000,						0xFFFF0000,0xFFFFC000,0xFFFFF000,0xFFFFFC00,						0xFFFFFF00,0xFFFFFFC0,0xFFFFFFF0,0xFFFFFFFC};					/*------------------------------------------------------------------------------ * Define the pixel routines. * For additional information about this code, see the Flash.c sources. *------------------------------------------------------------------------------ */#define InitColorPen(color,rgb) {color[0]=offscreen->GetNoDither(rgb); \	color[1]=(color[0]>>16)|(color[0]&0xFFFF0000);	\	color[0]=(color[0]<<16)|(color[0]&0x0000FFFF);	\	}#define InitColorBrush(color,rgb) {color[0]=offscreen->GetDither(rgb); \	color[1]=(color[0]>>16)|(color[0]&0xFFFF0000);	\	color[0]=(color[0]<<16)|(color[0]&0x0000FFFF);	\	}// MERGE-GOURAUD [[[// this macro inits the color index based on the rgb -- index will range from 0..255// at most, and will be less for bit depths 1/2/4.  The index is an index into the standard color// table; index is an unsigned char, rgb is an RGBColor#define InitColorIndex(index,rgb) { index = rgb; }// MERGE-GOURAUD ]]]#define InitPixel(pix,xval,yval,to) {pix.pixel=(unsigned char*)to->baseAddress; \	pix.pixel+=((xval-to->xOffset)>>2); \	pix.pixel+=(yval-to->yOffset)*(long)to->rowBytes; \	pix.pos=((xval-to->xOffset)&0x03);}	 // MERGE-HMD [[[#if USE_HMD#define InitPixelHMDL(pix,xval,yval,to) {pix.pixel=(unsigned char*)to->baseAddress; \	pix.pixel+=((xval-to->xOffset)>>2); \	pix.pixel+=(yval-to->yOffset)*((long)to->rowBytes << 1); \	if (gHMDOffsetLeft) pix.pixel += ((long)(to->rowBytes));	 \	pix.pos=((xval-to->xOffset)&0x03);}#define InitPixelHMDR(pix,xval,yval,to) {pix.pixel=(unsigned char*)to->baseAddress; \	pix.pixel+=((xval-to->xOffset)>>2); \	pix.pixel+=(yval-to->yOffset)*((long)to->rowBytes << 1); \	if (gHMDOffsetRight) pix.pixel += ((long)(to->rowBytes));	\	pix.pos=((xval-to->xOffset)&0x03);}#define AddLinePixelHMD(pix,to) pix.pixel+=((long)to->rowBytes << 1)#endif // USE_HMD// MERGE-HMD ]]]#define DecPixel(pix)  {if(!pix.pos)pix.pixel--; pix.pos= (pix.pos-1)&0x03;}#define IncPixel(pix)  {if(pix.pos==0x03)pix.pixel++; pix.pos= (pix.pos+1)&0x03;}#define AddPixel(pix,length) {pix.pixel+=length>>2;					\	pix.pos += (length&0x03);if(pix.pos&~0x03){pix.pixel++;} pix.pos&=0x03}}	#define AddLinePixel(pix,to) pix.pixel+=to->rowBytes#define SetPixel(pix,color) *pix.pixel = \(color[0]&pixbits[pix.pos]|((unsigned char)(*pix.pixel))&~pixbits[pix.pos])		#define DecSetPixel(pix,color) do{SetPixel(pix,color);DecPixel(pix);}while(0)#define IncSetPixel(pix,color) do{SetPixel(pix,color);IncPixel(pix);}while(0)// MERGE-GOURAUD [[[#define SetPixel2(pix,color) *pix.pixel = \(color&pixbits[pix.pos]|((unsigned char)(*pix.pixel))&~pixbits[pix.pos])	#define IncSetPixel2(pix,color) do{SetPixel2(pix,color);IncPixel(pix);}while(0)#define PixVal(pix) (pix.pos)#define GetGouraudDither(dith_abcd, shade, color)	(gTextureShader[shade].dith[1][dith_abcd][color])// MERGE-GOURAUD ]]]#define ScanFillPattern ScanFillPattern2void ScanFillPattern2(PixType pixel,int ytop,int dx,VColorType color);								void ScanFillPattern2(PixType pixel,int ytop,int dx,VColorType color) {														// Smith recommends we not do patterns for 2-bit and under.}#define ScanFill ScanFill2								void ScanFill2(PixType pixel,int evenodd,int dx,VColorType color);										void ScanFill2(PixType pixel,int evenodd,int dx,VColorType color)											{int ml,mr;				unsigned long *pl,*pr;unsigned long col=color[evenodd];int hl=pixel.pos;pl=(unsigned long *)(((long)pixel.pixel)&0xFFFFFFFC);ml=((long)pixel.pixel)&0x03;ml=(ml<<2)+hl;pixel.pixel+=(dx>>2);pr=(unsigned long *)(((long)pixel.pixel)&0xFFFFFFFC);mr=((long)pixel.pixel)&0x03;/* the byte inside the long word */mr=(mr<<2)+(dx&3)+hl; /*the pixel inside the byte*/if(mr>=16)	{pr++;mr-=16;}if(pl==pr)/*same 32 bits*/	{	if(ml)		{		if(mr)*pl=(*pl&(rMask[ml]|lMask[mr]))|(lMask[ml]&rMask[mr]&col);		else *pl=(*pl&rMask[ml])|(lMask[ml]&col);		}	else if(mr)*pl=(*pl&lMask[mr])|(rMask[mr]&col);	}else 	{#if __PPCC__	if(ml)		{		*pl=(*pl&rMask[ml])|(lMask[ml]&col);		*pl++;		}#else	if(ml)*pl++=(*pl&rMask[ml])|(lMask[ml]&col);#endif //__PPCC__	while(pl!=pr)*pl++=col;	if(mr)*pl=(*pl&lMask[mr])|(rMask[mr]&col);	}}											// MERGE-GOURAUD [[[/*------------------------------------------------------------------------------ * GouraudFillxxxx *------------------------------------------------------------------------------ */// GOURAUD -- we have to pattern fill dx pixels, going from intensity il to intensity ir#define DefaultGouraudFillPattern DefaultGouraudFillPattern2#define DefaultGouraudFill DefaultGouraudFill2#define GouraudFillPattern DefaultGouraudFillPattern2#define GouraudFill DefaultGouraudFill2// MERGE-GOURAUD ]]]#include "FlashZ.h"