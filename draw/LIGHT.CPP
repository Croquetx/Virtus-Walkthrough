/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	David A. Smith *				David W. Easter *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "Light.h"#include "WalkBuff.h"#include "VMath.h"#include "VMemUtil.h"#include "VGraphic.h"	// ABD MERGE-TEXTURE 9/13/93voidLightModel::cLightModel(void)	{	cArray(0,sizeof(Light *),4);	}voidLightModel::dLightModel(void)	{	Light *light;	while (length)		{		light = GetLight(0);		RemoveLight(light);		light->dLight();		}	dArray();	}voidLightModel::Copy(LightModel *lm)	{	Light **light,*l;	int i;		light = (Light **)Use();	for (i=0; i<length; i++)		{		l = light[i]->Copy();		lm->Append(&l);		}	Unuse();	}intLightModel::AddLight(Light *light)	{	return Append(&light);	}intLightModel::RemoveLight(Light *light)	{	return Remove(Find(&light));	}Light *LightModel::GetLight(int num)	{	Light *light;	if (Get(num, &light))		return(NULL);	else		return(light);	}// ABD MERGE-TEXTURE 9/13/93 [[[FFixed			// MERGE-GOURAUDLightModel::CalcShadeLevel(int max_levels, Point3D normal)	{	// we shade white and then see how dark it is.  From this we determine a	// shading level	RGBColor new_color = CalcShade(vWhite, normal);	double val;		// MERGE-GOURAUD	double Y = 0.0;		Y = (0.299 * (double)new_color.red) +		(0.587 * (double)new_color.green) +		(0.114 * (double)new_color.blue);	val = ((double)(max_levels-1)) - ((double)((Y / 65535.0) * (double)(max_levels-1)));	// MERGE-GOURAUD#if DEBUG	if ((val < 0.0) || (val > (double)(max_levels-1))) DEBUGGER();	// MERGE-GOURAUD#endif		return (DblToFixed(val));	// MERGE-GOURAUD	}// ABD MERGE-TEXTURE 9/13/93 ]]]RGBColorLightModel::CalcShade(RGBColor color, Point3D normal)	{	Light **light, *lght;	int nLights, i;	long brightness;	ULong red = 0, green = 0, blue = 0, tmp;	RGBColor shadeColor;	nLights = ALength();	light = (Light **)Use();		for (i = 0; i < nLights; i++)		{		lght = *light++;		if (!lght->active) continue;		brightness = (long)lght->source.x * normal.x +			(long)lght->source.y * normal.y + (long)lght->source.z * normal.z;		if (!lght->source.x && !lght->source.y && !lght->source.z)			brightness = 0x10000L;		if (brightness < 0) brightness = 0;		tmp = (ULong)color.red * lght->color.red >> 16;		red += tmp * brightness >> 16;		tmp = (ULong)color.green * lght->color.green >> 16;		green += tmp * brightness >> 16;		tmp = (ULong)color.blue * lght->color.blue >> 16;		blue += tmp * brightness >> 16;		}	Unuse();	shadeColor.red = red < 0x10000L ? red : 0xffff;	shadeColor.green = green < 0x10000L ? green : 0xffff;	shadeColor.blue = blue < 0x10000L ? blue : 0xffff;		return (shadeColor);	}/* DWE */intLightModel::IO(V_Buffer *buf)	{	short nLights, i;	Light *light, **l;	int err = 0;	ObjLock((ObjectHandle)this);	if (buf->IODirection() == DATA_IN)		{		err = buf->IOType(&nLights, IO_SHORT);		for (i = 0; i < nLights && !err; i++)			{			light = new(Light);			light->cLight();			err = light->IO(buf);/* Check for validity (AMBIENT or INFINITE) */			if (!err) Append(&light);			else light->dLight();			}		}	else		{		nLights = ALength();		l = (Light **)Use();		err = buf->IOType(&nLights, IO_SHORT);		for (i = 0; i < nLights && !err; i++)			err = (*l++)->IO(buf);		Unuse();		}	ObjUnlock((ObjectHandle)this);	return(err);	}/* DWE */intLightModel::IO_ELGT(V_Buffer *buf)	{	short nLights, i;	Light *light, **l;	int err = 0;	ObjLock((ObjectHandle)this);	if (buf->IODirection() == DATA_IN)		{		err = buf->IOType(&nLights, IO_SHORT);		for (i = 0; i < nLights && !err; i++)			{			if (i < ALength())				{				Get(i, &light);				err = light->IO_ELGT(buf);				}			}		}	else		{		nLights = ALength();		l = (Light **)Use();		err = buf->IOType(&nLights, IO_SHORT);				for (i = 0; i < nLights && !err; i++)			err = (*l++)->IO_ELGT(buf);		Unuse();		}	ObjUnlock((ObjectHandle)this);	return(err);	}Light *Light::cLight(void)	{	SetSource(0,0,256);	SetShade(0x8000);	SetBrightness(0x100);	Activate(TRUE);	return(this);	}voidLight::dLight(void)	{	delete(this);	}Light *Light::Copy(void)	{	Light *copy;		copy = new(Light);	copy->cLight();	copy->source = source;	copy->color = color;	copy->brightness = brightness;	copy->active = active;		return(copy);	}voidLight::SetSource(int x, int y, int z)	{	source.x = x;	source.y = y;	source.z = z;	}voidLight::SetAmbient(void)	{	source.x = 0;	source.y = 0;	source.z = 0;	}voidLight::SetColor(RGBColor rgb)	{	color = rgb;	}voidLight::SetShade(int s)	{	color.red = s;	color.green = s;	color.blue = s;	}voidLight::SetBrightness(int b)	{	brightness = b;	}voidLight::Activate(int a)	{	active = a;	}intLight::Ambient(void)	{	return (!source.x && !source.y && !source.z);	}/* DWE */intLight::IO(V_Buffer *buf)	{	short type;	Point3DFFixed src;	FFixed brght;	int err = 0;	ObjLock((ObjectHandle)this);	if (buf->IODirection() == DATA_OUT)		{		type = (Ambient() ? LIGHT_AMBIENT : LIGHT_INFINITE);		src.x.intg = source.x; src.x.frac = 0;		src.y.intg = source.y; src.y.frac = 0;		src.z.intg = source.z; src.z.frac = 0;				src.x = FFShift(src.x, -8);		src.y = FFShift(src.y, -8);		src.z = FFShift(src.z, -8);		brght.intg = brightness; brght.frac = 0;		brght = FFShift(brght, -8);		}	err = buf->IOType(&type, IO_SHORT);	if (!err) IOType(buf, &src, IO_POINT3D_FFIXED);	if (!err) IOType(buf, &color, IO_RGB_COLOR);	if (!err) IOType(buf, &brght, IO_FFIXED);	if (buf->IODirection() == DATA_IN && !err)		{		src.x = FFShift(src.x, 8);		src.y = FFShift(src.y, 8);		src.z = FFShift(src.z, 8);		source.x = FFRound(src.x);		source.y = FFRound(src.y);		source.z = FFRound(src.z);		brght = FFShift(brght, 8);		brightness = FFRound(brght);		}	ObjUnlock((ObjectHandle)this);	return(err);	}/* DWE */intLight::IO_ELGT(V_Buffer *buf)	{	short flags;	int err = 0;	ObjLock((ObjectHandle)this);	if (buf->IODirection() == DATA_OUT)		flags = (active ? 0x0001 : 0x0000);	err = buf->IOType(&flags, IO_SHORT);	if (buf->IODirection() == DATA_IN && !err)		active = (flags & 0x0001 ? TRUE : FALSE);	ObjUnlock((ObjectHandle)this);	return(err);	}/* old IO methods *//* DWE */intLightModel::IO_LGHT06(V_Buffer *buf)	{	short nLights, i;	Light *light, **l;	int err;		err = 0;		ObjLock((ObjectHandle)this);	buf->IOType(&nLights, IO_SHORT);	for (i = 0; i < nLights; i++)		{		light = new(Light);		light->cLight();		light->IO_LGHT06(buf);		Append(&light);		}	ObjUnlock((ObjectHandle)this);		return err;	}/* DWE */intLight::IO_LGHT06(V_Buffer *buf)	{	int err;		err = 0;		ObjLock((ObjectHandle)this);	IOType(buf, &source, IO_POINT3D);	IOType(buf, &color, IO_RGB_COLOR);	buf->IOType(&brightness, IO_SHORT);	buf->IOType(&active, IO_SHORT);	ObjUnlock((ObjectHandle)this);		return err;	}