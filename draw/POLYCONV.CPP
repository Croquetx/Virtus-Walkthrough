/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	 *				David W. Easter *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "PolyConv.h"#include "Drawing.h"#include "Polyhdrn.h"#include "Surface.h"#include "View.h"#include "SurfDef.h"#include "SurfFeat.h"#include "Slice.h"#include "DispArry.h"#include "Clip.h"#include "SinTable.h"#include "WTypes.h"#include "VGraphic.h"#include "VDisplay.h"#include "VGUtil.h"#include "VMemUtil.h"#include "VMath.h"#include "Position.h"#include "InTransp.h"#include "vdebug.h"		// ABD#include "TextItem.h"	// ABD MERGE-TEXTURE 9/15/93#include "Gouraud.h"	// MERGE-GOURAUD#include <stdlib.h>#include <stddef.h>#include <math.h>/* *	Constructor/destructor methods. */voidPolyConvex::cPolyConvex(Polyhedron *poly)	{	/*	 *	Initialize references to neighbors.	 */    CurrentlyDrawingInside = 0;	polyhedron = poly;	contents = NULL;	/*	 *	Allocate space for surface array.	 */	surfaces = new(V_Array);	surfaces->cArray(0, sizeof(Surface *), 4);		/*	 *	Initialize derived data.	 */	boundMin.x = 0; boundMin.y = 0; boundMin.z = 0;	boundMax.x = 0; boundMax.y = 0; boundMax.z = 0;	posnBoundMin.x = 0; posnBoundMin.y = 0; posnBoundMin.z = 0;	posnBoundMax.x = 0; posnBoundMax.y = 0; posnBoundMax.z = 0;	boundCenter.x = 0; boundCenter.y = 0; boundCenter.z = 0;	posnBoundCenter.x = 0; posnBoundCenter.y = 0; posnBoundCenter.z = 0;	/* boundR = 0; */	posnBoundR = 0;	inverted = FALSE;		/*	 *	Initialize data for 3D rendering.	 */	calculated = 0;	sorted = 0;	entered = 0;	rendCenterY = 0;	clipPlanes = 0;	visible = 0;	closePolys = NULL;	index = 0; lastIndex = 0;	dispPolys = NULL;	dispPolyNum = 0;	}voidPolyConvex::dPolyConvex()	{	int nSurfaces, i;	Surface **surf;	if (contents != NULL)		contents->dArray();	nSurfaces = surfaces->ALength();	surf = (Surface **)surfaces->Use();	for (i = 0; i < nSurfaces; i++, surf++)		(*surf)->dSurface();	surfaces->Unuse();	surfaces->dArray();		if (closePolys != NULL)		closePolys->dArray();	if (dispPolys != NULL)		dispPolys->dArray();	delete(this);	}voidPolyConvex::Install(Polyhedron *owner)	{	int nPieces, i;	PolyConvex **piec, *pce;	if (contents == NULL)		{		contents = new(V_Array);		contents->cArray(0, sizeof(PolyConvex *), 4);				dispPolys = new(DispArray);		dispPolys->cArray(0, sizeof(PolyConvex *), 4);		}		if (owner->pieces != NULL)		{		nPieces = owner->pieces->ALength();		piec = (PolyConvex **)owner->pieces->Use();		for (i = 0; i < nPieces; i++, piec++)			contents->Append(piec);		owner->pieces->Unuse();		}	else		{		pce = owner->piece;		contents->Append(&pce);		}	}voidPolyConvex::Remove(Polyhedron *owner)	{	int nPolys, i = 0;	PolyConvex *poly;	nPolys = contents->ALength();	while (i < nPolys)		{		contents->Get(i, &poly);		if (poly->polyhedron == owner)			{			contents->Remove(i);			nPolys--;			}		else i++;		}	}voidPolyConvex::TestClose(PolyConvex *poly)	{	long distSquare, limitSquare, tmp;	short dx, dy, dz;	short limit;	Surface *surf;	int mine,found=FALSE;		if (posnBoundMax.x > poly->posnBoundMin.x && posnBoundMin.x < poly->posnBoundMax.x ||		posnBoundMax.y > poly->posnBoundMin.y && posnBoundMin.y < poly->posnBoundMax.y ||		posnBoundMax.z > poly->posnBoundMin.z && posnBoundMin.z < poly->posnBoundMax.z)		{		dx = posnBoundCenter.x - poly->posnBoundCenter.x;		dy = posnBoundCenter.y - poly->posnBoundCenter.y;		dz = posnBoundCenter.z - poly->posnBoundCenter.z;			distSquare = (long)dx * dx;		tmp = (long)dy * dy;		distSquare += tmp;		tmp = (long)dz * dz;		distSquare += tmp;				limit = posnBoundR + poly->posnBoundR;		limitSquare = (long)limit * limit;				if (distSquare < limitSquare)/*DAS 12/12/90 this block completely reworked to support new sort vector*/			{			Point3D center,normal;			int x,y,z,b;			long bval,b1,b2;			long xx,yy,zz,mag;			if (posnBoundR > poly->posnBoundR)				{				if (FindSepSurface(poly,&normal,&center))					found = TRUE;				else if (poly->FindSepSurface(this,&normal,&center))					{					found = TRUE;					normal.x=-normal.x;					normal.y=-normal.y;					normal.z=-normal.z;					}				}			else				{				if (poly->FindSepSurface(this,&normal,&center))					{					found = TRUE;					normal.x=-normal.x;					normal.y=-normal.y;					normal.z=-normal.z;					}				else if (FindSepSurface(poly,&normal,&center))					found = TRUE;				}						if(!found)/*if we don't find a good solution above, let's make our own*/				{				b=posnBoundR;				b1 = (long)b * b;				b=poly->posnBoundR;				b2 = (long)b * b;								bval=b1+b2;				center.x=(b2*posnBoundCenter.x + b1*poly->posnBoundCenter.x)/bval;				center.y=(b2*posnBoundCenter.y + b1*poly->posnBoundCenter.y)/bval;				center.z=(b2*posnBoundCenter.z + b1*poly->posnBoundCenter.z)/bval;								x=poly->posnBoundCenter.x-posnBoundCenter.x;				y=poly->posnBoundCenter.y-posnBoundCenter.y;				z=poly->posnBoundCenter.z-posnBoundCenter.z;								xx = (long)x * x;				yy = (long)y * y;				zz = (long)z * z;				mag = LSqrt(xx + yy + zz);				if(mag)					{					normal.x = ((long)x<<8) / mag;					normal.y = ((long)y<<8) / mag;					normal.z = ((long)z<<8) / mag;					}				else					{					normal.x=normal.y=normal.z=0;					}				found=TRUE;				}			if(found)				{				AddClose(poly, center, normal);				normal.x= -normal.x;				normal.y= -normal.y;				normal.z= -normal.z;				poly->AddClose(this,center, normal);				}			}		}	}voidPolyConvex::KillClose()	{	int nClose, i;	ClosePolys *close;		if (closePolys != NULL)		{		nClose = closePolys->ALength();		close = (ClosePolys *)closePolys->Use();				for (i = 0; i < nClose; i++, close++)			close->poly->RemoveClose(this);			closePolys->Unuse();		closePolys->SetLength(0);		}	}/*DAS 12/12/90 changed to support the new sort method */voidPolyConvex::AddClose(PolyConvex *poly, Point3D center, Point3D normal)	{	ClosePolys cp;	if (closePolys == NULL)		{		closePolys = new(V_Array);		closePolys->cArray(0, sizeof(ClosePolys), 4);		}	cp.poly = poly;	cp.center = center;	cp.normal = normal;		closePolys->Append(&cp);	}voidPolyConvex::RemoveClose(PolyConvex *poly)	{	int nClose, i;	ClosePolys cp;		nClose = closePolys->ALength();	for (i = 0; i < nClose; i++)		{		closePolys->Get(i, &cp);		if (cp.poly == poly)			{			closePolys->Remove(i);			break;			}		}	}intPolyConvex::FindSepSurface(PolyConvex *poly,Point3D *norm, Point3D *center)	{	int nSurfaces, npSurfaces, npSurfPoints, i, j, k;	Surface **surf, **pSurf, *rSurf;	short *pSurfPnt;	Point3DFFixed refPoint, *pPnt, pnt;	short refPointNum, dx, dy, dz;	long cx,cy,cz;	Point3D normal;	long dotProd, dotSum, lastSum, tmp;		rSurf = NULL;	lastSum = -1;	nSurfaces = surfaces->ALength();	surf = (Surface **)surfaces->Use();		for (i = 0; i < nSurfaces; i++, surf++)		{		(*surf)->points->Get(0, &refPointNum);		polyhedron->posnPoints->Get(refPointNum, &refPoint);		normal = (*surf)->posnNormal;		dx = poly->posnBoundCenter.x - FFRound(refPoint.x);		dy = poly->posnBoundCenter.y - FFRound(refPoint.y);		dz = poly->posnBoundCenter.z - FFRound(refPoint.z);		dotProd = (long)normal.x * dx;		tmp = (long)normal.y * dy;		dotProd += tmp;		tmp = (long)normal.z * dz;		dotProd += tmp;				if (dotProd < 0) continue;		pPnt = (Point3DFFixed*)poly->polyhedron->posnPoints->Use();		npSurfaces = poly->surfaces->ALength();		pSurf = (Surface **)poly->surfaces->Use();		dotSum = 0;				for (j = 0; j < npSurfaces; j++, pSurf++)			{			npSurfPoints = (*pSurf)->points->ALength();			pSurfPnt = (short *)(*pSurf)->points->Use();			for (k = 0; k < npSurfPoints; k++)				{				pnt = pPnt[*pSurfPnt++];					pnt.x = FFSub(pnt.x, refPoint.x);/* MJU */				pnt.y = FFSub(pnt.y, refPoint.y);/* MJU */				pnt.z = FFSub(pnt.z, refPoint.z);/* MJU */				dx = FFRound(pnt.x);/* MJU */				dy = FFRound(pnt.y);/* MJU */				dz = FFRound(pnt.z);/* MJU */if (dx < 2 && dx > -2) dx = 0;if (dy < 2 && dy > -2) dy = 0;if (dz < 2 && dz > -2) dz = 0;							dotProd = (long)normal.x * dx;				tmp = (long)normal.y * dy;				dotProd += tmp;				tmp = (long)normal.z * dz;				dotProd += tmp;								if (dotProd < 0) break;				dotSum += dotProd;				}			(*pSurf)->points->Unuse();						if (k < npSurfPoints) break;			}				poly->polyhedron->posnPoints->Unuse();		poly->surfaces->Unuse();				if (j == npSurfaces && dotSum > lastSum)			{			lastSum = dotSum;			rSurf = *surf;			}		}	surfaces->Unuse();	if(rSurf)		{		int pLength;				*norm=rSurf->posnNormal;		rSurf->points->Get(0, &refPointNum);		polyhedron->posnPoints->Get(refPointNum, &refPoint);		center->x=FFRound(refPoint.x);		center->y=FFRound(refPoint.y);		center->z=FFRound(refPoint.z);				/*		cx = cy = cz = 0;		pLength=rSurf->points->ALength();		for(i=0;i<pLength;i++)			{			rSurf->points->Get(i, &refPointNum);			polyhedron->posnPoints->Get(refPointNum, &refPoint);			cx+=FFRound(refPoint.x);			cy+=FFRound(refPoint.y);			cz+=FFRound(refPoint.z);			}		center->x = cx/pLength;		center->y = cy/pLength;		center->z = cz/pLength;		*/				return TRUE;		}				else return(FALSE);	}voidPolyConvex::AddSurface(V_Array *pnts, int num, SurfDef *sDef)	{	Surface *surf;    int sErr;	// jca 20 Nov 93	surf = new(Surface);	sErr = surf->cSurface(this, sDef, num, pnts);	if (!sErr)                 	// jca 20 Nov 93 {		surfaces->Append(&surf);	else		surf->dSurface();      	// jca 20 Nov 93 }	if (sDef != NULL) sDef->AddSurface(surf);	}voidPolyConvex::SliceX()	{	V_Array *sliceDist, *sliceLines, *surfPnts;	int nSlices, nSurfaces, nLines, i, j, lineNum;	Slice **slice, *slic;	Surface *surf;	long *line, sliceLine;	short linePnt, linePnt0;	if (polyhedron->slices == NULL)		return;	sliceDist = new(V_Array);	sliceDist->cArray(0, sizeof(double), 4);	sliceLines = new(V_Array);	sliceLines->cArray(0, sizeof(long), 4);	surfPnts = new(V_Array);	surfPnts->cArray(0, sizeof(short), 4);	nSlices = polyhedron->slices->ALength();	slice = (Slice **)polyhedron->slices->Use();	for (i = 0; i < nSlices; i++)		{		slic = *slice++;		MakeSliceDist(slic, sliceDist);		sliceLines->SetLength(0);		nSurfaces = surfaces->ALength();			for (j = 0; j < nSurfaces; j++)			{			surfaces->Get(j, &surf);			if (!surf->SliceX(slic, sliceDist, sliceLines))				{				surf->dSurface();				surfaces->Remove(j);				j--;				nSurfaces--;				}			}		if ((nLines = sliceLines->ALength()) != 0)			{			line = (long *)sliceLines->Use();			surfPnts->SetLength(0);			linePnt = linePnt0 = line[0] & 0xffff;			lineNum = 0;			do				{				surfPnts->Append(&linePnt);				linePnt = line[lineNum] >> 16;				for (lineNum = 0; lineNum < nLines; lineNum++)					if ((line[lineNum] & 0xffff) == linePnt)						break;				} while (linePnt != linePnt0);				sliceLines->Unuse();			AddSurface(surfPnts, polyhedron->SliceToSurf(i),				polyhedron->FindSurfDef(polyhedron->SliceToSurf(i)));			}		}	polyhedron->slices->Unuse();	sliceDist->dArray();	sliceLines->dArray();	surfPnts->dArray();	}voidPolyConvex::KillNullSurfs()	{	int nSurfaces, i;	Surface **s, *surf;	nSurfaces = surfaces->ALength();	for (i = 0; i < nSurfaces; i++)		{		surfaces->Get(i,&surf);		if (surf->normal.x == 0 && surf->normal.y == 0 && surf->normal.z == 0)			{			surfaces->Remove(i);			surf->dSurface();			i--;			nSurfaces--;			}		}	}voidPolyConvex::PositionX()	{	Position *scalePosn, *shearPosn, *rotatePosn;	Point3DFFixed scal;	Shear3DFFixed shr;	Angle3DFFixed orient;	int nSurfaces, i, inv, invert;	Surface **surf;	Surface **surf_start;				// ABD MERGE-GOURAUD	int has_gouraud = FALSE;			// ABD MERGE-GOURAUD	scal = polyhedron->posn->GetScale3D();	shr = polyhedron->posn->GetShear3D();	orient = polyhedron->posn->GetOrientation3D();	inv = FALSE;	if (FFNegative(scal.x)) inv = !inv;	if (FFNegative(scal.y)) inv = !inv;	if (FFNegative(scal.z)) inv = !inv;	invert = (inv && !inverted || inverted && !inv);	inverted = inv;	if (!Pt3DFFOne(scal))		{		scal.x = FFDiv(FFOne, scal.x);		scal.y = FFDiv(FFOne, scal.y);		scal.z = FFDiv(FFOne, scal.z);		scalePosn = new(Position);		scalePosn->cPosition();		scalePosn->SetScale3D(scal);		}	else scalePosn = NULL;	if (!Shr3DFFZero(shr))		{		/* Hack; can't represent normal transform for shear in Position */		/* Surface::PositionX will recognize and do the right thing */		shearPosn = new(Position);		shearPosn->cPosition();		shearPosn->SetShear3D(shr);		}	else shearPosn = NULL;	if (!Ang3DFFZero(orient))		{		rotatePosn = new(Position);		rotatePosn->cPosition();		rotatePosn->SetOrientation3D(orient);		}	else rotatePosn = NULL;	nSurfaces = surfaces->ALength();	surf_start = (Surface **)surfaces->Use();		// ABD MERGE-GOURAUD		// ABD MERGE-GOURAUD [[[	// if any of the surfaces are gouraud-shaded, then we must transform every surface first, to	// make sure we have all of the correct normals, and *then* calculate all of the shading 	// values.  We must do this because surface shading values depend on the normals of other	// surfaces, and so we can't calc the shade of any surface until all of the surface normals	// have been transformed.  So we check to see if any surface is gouraud-shaded, and if so,	// then we do PositionXG() instead of PositionX().  PositionXG() doesn't do a CalcShade().  Then	// we go ahead and do all the CalcShade()s.  Actually, we could just do all the	// PositionXG()'s and then all of the CalcShade()'s in either case (gouraud or not gouraud).	// It doesn't really matter.		// determine if any surfaces are gouraud shaded	surf = surf_start;	for (i = 0; i < nSurfaces; i++)	{		if (((*surf)->GetShadeType(SURF_INSIDE) == SHADE_GOURAUD) || 			((*surf)->GetShadeType(SURF_OUTSIDE) == SHADE_GOURAUD))			{				has_gouraud = TRUE;				break;		// break because all we need is one gouraud-shaded surface			}		*surf++;	}				// if any surface is gouraud-shaded, then calc all the normals before calcing the shades	if (has_gouraud)	{		// gouraud case; do a PositionXG() for all surfaces and then a CalcShade() for all surfaces		surf = surf_start;		for (i = 0; i < nSurfaces; i++)			(*surf++)->PositionXG(scalePosn, shearPosn, rotatePosn, invert);   // MERGE-DEC94					// now that all of our normals have been fixed up, we can calc the gouraud shading		surf = surf_start;		// reset surf ptr to first surface		for (i = 0; i < nSurfaces; i++)			(*surf++)->CalcShade();	}	else	// otherwise just do the thing we used to do	{		// normal case; this is the code that was here before -- just do a PositionX() for all 		// surfaces		surf = surf_start;		for (i = 0; i < nSurfaces; i++)			(*surf++)->PositionX(scalePosn, shearPosn, rotatePosn, invert);	}	// ABD MERGE-GOURAUD ]]]	surfaces->Unuse();	if (scalePosn != NULL) scalePosn->dPosition();	if (shearPosn != NULL) shearPosn->dPosition();	if (rotatePosn != NULL) rotatePosn->dPosition();	}/* calculate sphere better (shouldn't necessarily be greater than box) */extern double Vsqrt(double);voidPolyConvex::CalcBound(int which)	{	Point3D bMin, bMax, bCenter;	short bR;	int nSurfaces, i;	Surface **surf;	int x, y, z;	long rSquare;	bMin.x = 32767; bMin.y = 32767; bMin.z = 32767;	bMax.x = -32768; bMax.y = -32768; bMax.z = -32768;	nSurfaces = surfaces->ALength();	surf = (Surface **)surfaces->Use();	for (i = 0; i < nSurfaces; i++)		(*surf++)->ExpandBound(&bMin, &bMax, which);	surfaces->Unuse();	bCenter.x = ((long)bMin.x + bMax.x) >> 1;	bCenter.y = ((long)bMin.y + bMax.y) >> 1;	bCenter.z = ((long)bMin.z + bMax.z) >> 1;	if (which == BOUND_DEF)		{		boundMin = bMin;		boundMax = bMax;		boundCenter = bCenter;		/* boundR = bR; */		}	else		{		if(0==nSurfaces)			{			bMin = Pt3DZero;			bMax = Pt3DZero;			bCenter = Pt3DZero;			bR = 0;			}		else			{			x = bMax.x - bCenter.x;			y = bMax.y - bCenter.y;			z = bMax.z - bCenter.z;			rSquare = (long)x*x + (long)y*y + (long)z*z;			bR = ceil(Vsqrt(rSquare));			}		posnBoundMin = bMin;		posnBoundMax = bMax;		posnBoundCenter = bCenter;		posnBoundR = bR;		}	}voidPolyConvex::MakeSliceDist(Slice *slice, V_Array *dist)	{/* needs to be in Polyhedron */	double a, b, c, d;	int nPoints, i;	Point3DFFixed *pnt, pt;	double *distVal;	a = FixedToDbl(slice->a);	b = FixedToDbl(slice->b);	c = FixedToDbl(slice->c);	d = FixedToDbl(slice->d);	nPoints = polyhedron->points->ALength();	dist->SetLength(nPoints);	pnt = (Point3DFFixed *)polyhedron->points->Use();	distVal = (double *)dist->Use();	for (i = 0; i < nPoints; i++)		{		pt = *pnt++;		*distVal++ = a*FixedToDbl(pt.x) + b*FixedToDbl(pt.y) + c*FixedToDbl(pt.z) + d;		}	polyhedron->points->Unuse();	dist->Unuse();	}Surface *PolyConvex::FindSurface(int surfNum)	{	int nSurfaces, i;	Surface **surf;	nSurfaces = surfaces->ALength();	surf = (Surface **)surfaces->Use();	for (i = 0; i < nSurfaces; i++, surf++)		if ((*surf)->surfNum == surfNum)			break;	surfaces->Unuse();		if (i != nSurfaces)		return(*surf);	else		return(NULL);	}voidPolyConvex::ExpandBound(Point3D *min, Point3D *max, int which)	{	Point3D bMin, bMax;	if (which == BOUND_DEF)		{		bMin = boundMin;		bMax = boundMax;		}	else		{		bMin = posnBoundMin;		bMax = posnBoundMax;		}	if (bMin.x < min->x) min->x = bMin.x;	if (bMin.y < min->y) min->y = bMin.y;	if (bMin.z < min->z) min->z = bMin.z;	if (bMax.x > max->x) max->x = bMax.x;	if (bMax.y > max->y) max->y = bMax.y;	if (bMax.z > max->z) max->z = bMax.z;	}voidPolyConvex::CalcShade()	{	int nSurfaces, i;	Surface **surf;	nSurfaces = surfaces->ALength();	surf = (Surface **)surfaces->Use();	for (i = 0; i < nSurfaces; i++)		(*surf++)->CalcShade();	surfaces->Unuse();	}intPolyConvex::Inside(Point3D pnt)	{	register int nSurfaces, i;	register Surface **surfIndex, *surf;	register Point3DFFixed *posnPnt;	Point3D vector, norm;	Point3DFFixed testPoint;	short pntNum,*pts;	long dotProd, tmpL;	long distSquare, limitSquare;	short dx, dy, dz, limitR, maxError;	int onSurface;		if (polyhedron->type == POLY_ROOT)		return(PNT_INSIDE);	if (pnt.x < posnBoundMin.x || pnt.x > posnBoundMax.x ||		pnt.y < posnBoundMin.y || pnt.y > posnBoundMax.y ||		pnt.z < posnBoundMin.z || pnt.z > posnBoundMax.z)		return(PNT_OUTSIDE);	dx = pnt.x - posnBoundCenter.x;	dy = pnt.y - posnBoundCenter.y;	dz = pnt.z - posnBoundCenter.z;	distSquare = (long)dx * dx;	tmpL = (long)dy * dy;	distSquare += tmpL;	tmpL = (long)dz * dz;	distSquare += tmpL;	limitR = posnBoundR;	limitSquare = (long)limitR * limitR;		if (distSquare > limitSquare)		return(PNT_OUTSIDE);	nSurfaces = surfaces->ALength();	surfIndex = (Surface **)VA_Abuse(surfaces);// DAS-LIZARD KING 10/2/93	posnPnt = (Point3DFFixed *)VA_Abuse(polyhedron->posnPoints);// DAS-LIZARD KING 10/2/93	onSurface = FALSE;	for (i = 0; i < nSurfaces; i++)		{		surf = *surfIndex++;		surf->points->Get(0, &pntNum);		testPoint = posnPnt[pntNum];		vector.x = FFRound(testPoint.x) - pnt.x;		vector.y = FFRound(testPoint.y) - pnt.y;		vector.z = FFRound(testPoint.z) - pnt.z;		norm = surf->posnNormal;				dotProd = (long)vector.x * norm.x;		tmpL = (long)vector.y * norm.y;		dotProd += tmpL;		tmpL = (long)vector.z * norm.z;		dotProd += tmpL;		maxError = (abs(vector.x) + abs(vector.y) + abs(vector.z)) >> 1;		if (dotProd < -maxError)			break;		else if (dotProd <= maxError)			onSurface = TRUE;		}	if (i < nSurfaces || nSurfaces == 0)		return(PNT_OUTSIDE);	else if (onSurface)		return(PNT_SURFACE);	else		return(PNT_INSIDE);	}//JAM 2MAR95 [[[//put in hack to prevent too deep recursion (e.g. due//to infinite loop)#define MAXRECURSIONLEVEL 25long gRecursionLevel = 0;//JAM 2MAR95 ]]]voidPolyConvex::DrawWalk(register View *view, Clip *clip, register PolyConvex *stop,	Surface *clipSurf, RGBAColor inheritedColor)	{	int vis = TRUE;	Clip *newClip = clip, *surfClip = NULL;	TRANSPARENCY_INTERP_INIT;	struct ObjSpec obj;				// ABD 3D PICK 8/13/93	struct ObjSpec *obj_ptr = NULL; // ABD 3D PICK 8/13/93		//JAM 2MAR95 [[[	//put in hack to prevent too deep recursion (e.g. due	//to infinite loop)	if(gRecursionLevel > MAXRECURSIONLEVEL) return;	gRecursionLevel++;	//JAM 2MAR95 ]]]	if (polyhedron->type == POLY_ROOT)		{		if (view->fill)			{			RGBColor color;			if (view->whiteShade)				color = vWhite;			else				{				color = polyhedron->insideColor;				if (view->interpTransp)					{					if (IS_TRANSLUCENT(inheritedColor.alpha))						{	                    /* these are macro calls, defined in Intransp.h */						/* interpolate alpha first, to set up the transparency vars */						InterpolateAlphaFrontToBack(OPAQUE_NOM, inheritedColor.alpha, color.red);	                	InterpolateColorFrontToBack(polyhedron->insideColor.red, inheritedColor.red, color.red);						InterpolateColorFrontToBack(polyhedron->insideColor.green, inheritedColor.green, color.green);						InterpolateColorFrontToBack(polyhedron->insideColor.blue, inheritedColor.blue, color.blue);						}					else if (IS_OPAQUE(inheritedColor.alpha))						{						color.red = inheritedColor.red;						color.green = inheritedColor.green;						color.blue = inheritedColor.blue;                        }					}				}			// ABD 3D PICK 8/13/93			// fill in the object specifier record for 3d picks 			if (polyCheckMode)			{				obj.poly = polyhedron;				// ABD 3D PICK 8/13/93				obj.polyc = this;					// ABD 3D PICK 8/13/93				obj.surfNum = NO_SURFACE_SPEC;		// ABD 3D PICK 8/13/93				obj.surfSide = NO_SURFACE_SPEC;		// ABD 3D PICK 8/13/93				obj.surffeat = NULL;					// ABD 3D PICK 8/13/93				obj_ptr = &obj;			}						// ABD MERGE-TEXTURE NOTE: no need to call Texture8 here unless root poly is textured			// ABD MERGE-GOURAUD NOTE: no need for gouraud shading unless root poly is gouraud shaded			newClip->DrawPoly(view->screenPoly, CLIP_FILL|(view->drawMode&CLIP_DITHER), NULL, 	// MERGE-GOURAUD 				FALSE, vPatBlack, &color, &vBlack, FALSE, obj_ptr);	// ABD 3D PICK 8/13/93			}		}	else		{		if (Calc3D(view))			{			if (clipSurf != NULL)				{				if (!clipSurf->clipped &&					(surfClip = clip->ClipPolyRef(polyhedron->rendPoints,					clipSurf->rendPoints, TRUE)) != NULL)					{					newClip = surfClip;					Draw3D(view, newClip, TRUE, inheritedColor);					}				else vis = FALSE;				}			else Draw3D(view, newClip, TRUE, inheritedColor);			}		else vis = FALSE;		}	if (vis && contents != NULL)		{		register short seq = polyhedron->drawing->sequence;		register int nPolyCs, i, recurse;		register PolyConvex **polyC;		if (sorted != seq)			{			sorted = seq;			VA_Truncate(dispPolys);			nPolyCs = VA_Length(contents);			VA_Use(contents, polyC, PolyConvex *);					for (i = 0; i < nPolyCs; i++, polyC++)				if ((*polyC)->Calc3D(view) || (view->drawMode & CLIP_BBOX))		// MERGE22 -- make sure all polys are included in bounding box calc					dispPolys->Append(polyC);					VA_Unuse(contents);		/* make sure sorts work with 0 or 1 and take this test out */if (VA_Length(dispPolys) > 1){			dispPolys->QuickSort();			dispPolys->CleanUp(view);}			recurse = FALSE;			dispPolyNum = 0;			}		else recurse = TRUE;		nPolyCs = VA_Length(dispPolys);		VA_Use(dispPolys, polyC, PolyConvex *);		if (recurse) nPolyCs = dispPolyNum;		for (i = 0; i < nPolyCs && *polyC != stop; i++)			{			(*polyC++)->Draw3D(view, newClip, FALSE, inheritedColor);			if (!recurse) dispPolyNum++;			}		VA_Unuse(dispPolys);		}		if (surfClip != NULL)		surfClip->dClip();			//JAM 2MAR95 [[[	//put in hack to prevent too deep recursion (e.g. due	//to infinite loop)	gRecursionLevel--;	//JAM 2MAR95 ]]]	}intPolyConvex::Calc3D(register View *view)	{	register short seq = polyhedron->drawing->sequence;	register V_Array *posnPoints = polyhedron->posnPoints;	register V_Array *rendPoints = polyhedron->rendPoints;	register V_Array *NoPerspPoints = polyhedron->NoPerspPoints;		// ABD MERGE-TEXTURE 9/13/93	short rendY;	Point3DLong mn,mx;	int userAbort = FALSE;	if (++view->abortCount == 25)		{		view->abortCount = 0;		if (view->testAbort && VCancel())			userAbort = TRUE;		if (VGetTime() - view->startTime >= 30)			VSetCursor(vCursorEarth);		}			//JAM 17FEB95 low memory walk rendering [[[	//if memory was too low for rendering the walkview, we'd pause for	//a full minute before MyGrowZone() is called.  I inserted this code	//to abort drawing if memory becomes low.  Doesn't appear to be a problem	//in Windows.	#if MACINTOSH//	if (FreeMem() < WALKVIEW_RENDER_MEM_THRESHOLD)	if (!MemThreshholdTest(WALKVIEW_RENDER_MEM_THRESHOLD))	{		if(gmemoryLowForWalkView == 0) { gmemoryLowForWalkView = 1; }	}	#endif	if ((view->abort || userAbort || lowMemory || gmemoryLowForWalkView) && this != view->viewPoly)		{ view->abort = TRUE; visible = FALSE; return(FALSE); }	//JAM 17FEB95 low memory walk rendering ]]]	if (calculated == seq) return(visible);	calculated = seq;	visible = TRUE;	if (polyhedron->hidden)		{ visible = FALSE; return(FALSE); }	if ((clipPlanes = view->Cull(posnBoundCenter, posnBoundR, &rendY)) < 0)		{ visible = FALSE; return(FALSE); }	view->TransRot(posnPoints, rendPoints);	if (!view->ClipSurf(surfaces, posnPoints, rendPoints, clipPlanes))		{ visible = FALSE; return(FALSE); }	view->Project(rendPoints,NoPerspPoints, &mn,&mx);		// ABD MERGE-TEXTURE 9/13/93	rendBoundMin=mn;	rendBoundMax=mx;	rendCenterY = rendY;	return(TRUE);	}/* deal with entered for following connections; if set for p, set for all connectedto p; maybe in PolyConvex::DrawWalk */voidPolyConvex::Draw3D(View *view, Clip *clip, int inside, RGBAColor inheritedColor)	{	int nSurfaces, i, surfVisible;	Surface **surfIndex, *surf;	SurfDef *sDef;	int nearSide = (inside ? SURF_INSIDE : SURF_OUTSIDE);int s = (inside ? SIDE_INSIDE : SIDE_OUTSIDE);	int userAbort = FALSE;	RGBAColor newColor;    TRANSPARENCY_INTERP_INIT;    struct ObjSpec obj;					// ABD 3D PICK 8/13/93    struct ObjSpec *obj_ptr = NULL;		// ABD 3D PICK 8/13/93    int has_texture = FALSE;	// ABD MERGE-TEXTURE 9/13/93    struct GouraudRendSettings grs;			// MERGE-GOURAUD    	if (++view->abortCount == 25)		{		if (view->testAbort && VCancel())			userAbort = TRUE;		if (VGetTime() - view->startTime >= 30)			VSetCursor(vCursorEarth);		}	//JAM 17FEB95 low memory walk rendering [[[	//if memory was too low for rendering the walkview, we'd pause for	//a full minute before MyGrowZone() is called.  I inserted this code	//to abort drawing if memory becomes low.  Doesn't appear to be a problem	//in Windows.	#if MACINTOSH//	if (FreeMem() < WALKVIEW_RENDER_MEM_THRESHOLD)	if (!MemThreshholdTest(WALKVIEW_RENDER_MEM_THRESHOLD))	{		if(gmemoryLowForWalkView == 0) { gmemoryLowForWalkView = 1; }	}	#endif		if ((view->abort || userAbort || lowMemory || gmemoryLowForWalkView) && this != view->viewPoly)		{ view->abort = TRUE; return; }	//JAM 17FEB95 low memory walk rendering ]]]		//JAM 3MAR95 to prevent infinite recursion:  if we are drawing the inside of a polyconvex,	//we should not be called upon to draw its outside	ASSERT(CurrentlyDrawingInside >= 0);	if(CurrentlyDrawingInside && (!inside)) return;	if(inside)	{		CurrentlyDrawingInside++;	}	// ABD MERGE2 8/17/93 v	if (view->drawMode & CLIP_BBOX)	{		view->boundMin.x = min(view->boundMin.x, posnBoundMin.x);		view->boundMin.y = min(view->boundMin.y, posnBoundMin.y);		view->boundMin.z = min(view->boundMin.z, posnBoundMin.z);		view->boundMax.x = max(view->boundMax.x, posnBoundMax.x);		view->boundMax.y = max(view->boundMax.y, posnBoundMax.y);		view->boundMax.z = max(view->boundMax.z, posnBoundMax.z);	}	// ABD MERGE2 8/17/93 ^	nSurfaces = VA_Length(surfaces);	VA_Use(surfaces, surfIndex, Surface *);	for (i = 0; i < nSurfaces; i++)		{		surf = *surfIndex++;		if (surf->clipped) continue;		if (!inside) { if (surf->visible != SURF_VIS_OUTSIDE) continue; }		else { if (surf->visible != SURF_VIS_INSIDE) continue; }		sDef = surf->surfDef;// ABD MERGE-TEXTURE 9/13/93 [[[		if (nearSide == SURF_INSIDE)			has_texture = (surf->GetTexture(SURF_INSIDE) != NULL);		else if (nearSide == SURF_OUTSIDE)			has_texture = (surf->GetTexture(SURF_OUTSIDE) != NULL);/*11-29-93 JAM [[[ patch to cause textures to	  not be used when doing GDI stuff*/	if(clip != NULL)    {		if (clip->method == QD_METHOD)		{ 		   	has_texture = FALSE;		}    }/*11-29-93 JAM ]]] patch to cause textures to      not be used when doing GDI stuff*/            if (view->whiteShade)		// PRO-14      	has_texture = FALSE;	// PRO-14// ABD MERGE-TEXTURE 9/13/93 ]]]		if ((!has_texture) &&			IS_OPAQUE(surf->opacity) &&			(sDef == NULL || sDef->features[SURF_SHARED] == NULL &&			!sDef->interesting[SURF_SHARED][s]))			{			RGBColor clr, lclr;			if (view->whiteShade)				{				clr = vWhite;				lclr = vBlack;				}			else				{				if (view->shade)					{					if (inside) clr = surf->insideShade;					else clr = surf->outsideShade;					}				else					{					if (inside) clr = surf->insideColor;					else clr = surf->outsideColor;					}				if (view->interpTransp)                	{					if (IS_TRANSLUCENT(inheritedColor.alpha))						{						InterpolateAlphaFrontToBack(OPAQUE_NOM, inheritedColor.alpha, newColor.alpha);						InterpolateColorFrontToBack(clr.red, inheritedColor.red, newColor.red);						InterpolateColorFrontToBack(clr.green, inheritedColor.green, newColor.green);						InterpolateColorFrontToBack(clr.blue, inheritedColor.blue, newColor.blue);						clr.red = newColor.red;						clr.green = newColor.green;						clr.blue = newColor.blue;            			}                    }				if (!view->blackFrame)					{					lclr.red = clr.red >> 1; lclr.red += lclr.red >> 1;					lclr.green = clr.green >> 1; lclr.green += lclr.green >> 1;					lclr.blue = clr.blue >> 1; lclr.blue += lclr.blue >> 1;					}				else lclr = vBlack;				}			// ABD 3D PICK 8/13/93			// fill in the obj spec for 3d pick			if (polyCheckMode)			{				obj.poly = polyhedron;									// ABD 3D PICK 8/13/93				obj.polyc = this;										// ABD 3D PICK 8/13/93				obj.surfNum = surf->surfNum;							// ABD 3D PICK 8/13/93				obj.surfSide = (inside ? SURF_INSIDE : SURF_OUTSIDE);	// ABD 3D PICK 8/13/93				obj.surffeat = NULL;										// ABD 3D PICK 8/13/93				obj_ptr = &obj;			}			if (view->gouraud)	// MERGE-GOURAUD-PRO-7			{	// PRO-14				if (view->whiteShade)	// PRO-14					grs.intensities = NULL;		// PRO-14				else	// PRO-14					grs.intensities = surf->GetRendIntensities(nearSide);	// MERGE-GOURAUD				}	// PRO-14			else	// MERGE-GOURAUD-PRO-7				grs.intensities = NULL;	// MERGE-GOURAUD-PRO-7			grs.unshaded_color = (inside ? surf->insideColorIndex : surf->outsideColorIndex);		// MERGE-GOURAUD						surfVisible = clip->DrawPolyRef(polyhedron->rendPoints, surf->rendPoints,				view->drawMode, &grs, FALSE, vPatBlack, &clr, &lclr, !inside, obj_ptr);	// MERGE-GOURAUD	// ABD 3D PICK 8/13/93			}		else surfVisible = surf->DrawSurface(view, clip, inside, SURF_SHARESIDE, inheritedColor);		if (surfVisible && sDef != NULL &&			(sDef->features[nearSide] != NULL || sDef->interesting[nearSide][s]))			surf->DrawSurface(view, clip, inside, SURF_NEARSIDE, inheritedColor);		}	//JAM 3MAR95 to prevent infinite recursion:  if we are drawing the inside of a polyconvex,	//we should not be called upon to draw its outside	if(inside)	{		CurrentlyDrawingInside--;		ASSERT(CurrentlyDrawingInside >= 0);		if(CurrentlyDrawingInside < 0) CurrentlyDrawingInside = 0;	}	VA_Unuse(surfaces);	}	// ABD MERGE-TEXTURE 9/13/93 [[[voidPolyConvex::UpdateSurfs()		// ABD TEXTURE{Surface **s;int i;	// ABD MERGE-MEM delete the surface outlines, so that when they are needed again,	// they will be reallocated and thus recalculated.  This saves memory because	// only those surfaces which require the outline (i.e. textured surfaces)	// will recalc it.	s = (Surface **)surfaces->Use();	for (i = 0 ; i < surfaces->ALength() ; i++ )	{		if (s[i]->outline)		{			s[i]->outline->dArray();						// Make sure we set outline to NULL; otherwise how will the texturing			// code know that the outline doesn't exist and needs to be created?			s[i]->outline = NULL;		}	}	surfaces->Unuse();}// ABD MERGE-TEXTURE 9/13/93 ]]]