/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	 *				David W. Easter *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  * This code has been substantially changed to support 22 bit values: * 16+6 bits, which gives us a much higher resolution image when objects are close by. * This allows us to create objects that are much smaller than one inch in size, without * having to compromise on speed. This wonderful code is brought to you by DAS on * August 4, 1993. XYZZY *------------------------------------------------------------------------------ */ #define FASTERSPACIALCLIP 1#include "VTypes.h"#include "View.h"#include "Drawing.h"#include "Polyhdrn.h"#include "PolyConv.h"#include "Surface.h"#include "SurfFeat.h"#include "Clip.h"#include "SinTable.h"#include "Unit.h"#include "VPane.h"#include "VGraphic.h"#include "VGUtil.h"#include "VMath.h"#include "vdebug.h"		// ABD#include "TextItem.h"	// ABD MERGE-TEXTURE 9/13/93#include "AppDeflt.h"	// ABD MERGE-TEXTURE 9/13/93#include "VSound.h"		// MERGE18#include "SurfDef.h"	// MERGE23#include "VTimer.h"		// MERGE-WALK-SLOW#if USE_HMD				// MERGE-HMD#include "HMD.h"		// MERGE-HMD#endif					// MERGE-HMD#include <math.h>#include <stddef.h>// Define AVERAGE_WALK_SPEED to be true if you want the step size to be modified when// walking.  This almost makes complex and non-complex parts of a model walk in a// reasonable fashion.#define AVERAGE_WALK_SPEED FALSE#if AVERAGE_WALK_SPEEDlong last_frame_msecs;				// MERGE-WALK-SLOW#endif //AVERAGE_WALK_SPEEDvoidView::cView(WalkDrawing *dwg)	{	drawing = dwg;	SetOptions(0);	point.x = 0;	point.y = 0;	point.z = 0;	angle.yaw = 0;	angle.pitch = 0;	angle.roll = 0;	CalcSines();#if AVERAGE_WALK_SPEED	last_frame_msecs = 1000;	// MERGE-WALK-SLOW#endif //AVERAGE_WALK_SPEED	/* set up viewPoly */	viewPolys = new(V_Array);	viewPolys->cArray(0, sizeof(PolyConvex *), 4);	ResetViewPoly();	/* set up data for virtual lens */	focalLength = 0;	filmWidth = 0;	screenDist = 0;	AllocPerspTable();	/* initialize pane information (dummy values) */	width = 0;	height = 0;	screenPoly = new(V_Array);	screenPoly->cArray(4, sizeof(Point), 4);	clip = new(Clip);	clip->cClip();	/* initialize 3D clipping data (dummy values) */	xClipA = 0; xClipB = 0; xDistConst = 0;	zClipA = 0; zClipB = 0; zDistConst = 0;	clipWidth = 0;	clipHeight = 0;	startTime = 0;	abort = FALSE;	abortCount = 0;	testAbort = FALSE;	/* create temporary clipping arrays */	tempPoints = new(V_Array);	tempPoints->cArray(0, sizeof(short), 4);	tempFeatPoints = new(V_Array);	tempFeatPoints->cArray(0, sizeof(Point3DLong), 4); // DAS - HIRES 8/8/93	}voidView::dView()	{	viewPolys->dArray();	FreePerspTable();		screenPoly->dArray();	clip->dClip();	tempPoints->dArray();	tempFeatPoints->dArray();	delete(this);	}voidView::SetOptions(int opt)	{	seeIn = (opt & DRAW_SEE_IN) ? TRUE : FALSE;	seeOut = (opt & DRAW_SEE_OUT) ? TRUE : FALSE;	seeThrough = (opt & DRAW_SEE_THROUGH) ? TRUE : FALSE;	frame = (opt & DRAW_FRAME) ? TRUE : FALSE;	fill = (opt & DRAW_FILL) ? TRUE : FALSE;	shade = (opt & DRAW_SHADE) ? TRUE : FALSE;	noShade = (opt & DRAW_NO_SHADE) ? TRUE : FALSE;	whiteShade = (opt & DRAW_WHITE_SHADE) ? TRUE : FALSE;	blackFrame = (opt & DRAW_BLACK_FRAME) ? TRUE : FALSE;	interpTransp = (opt & DRAW_INTERP_TRANSP) ? TRUE : FALSE;	dither = (opt & DRAW_DITHER) ? TRUE : FALSE;	bbox = (opt & DRAW_BBOX) ? TRUE : FALSE;	// ABD MERGE2 8/17/93	textures = (opt & DRAW_TEXTURES) ? TRUE : FALSE;	// BG	gouraud = (opt & DRAW_GOURAUD) ? TRUE : FALSE;	// ABD MERGE-GOURAUD	drawMode = 0;	if (fill) drawMode |= CLIP_FILL;	if (frame) drawMode |= CLIP_FRAME;	if (dither) drawMode |= CLIP_DITHER;	if (bbox) drawMode |= CLIP_BBOX;		// ABD MERGE2 8/17/93	if (gouraud) drawMode |= CLIP_GOURAUD;	// ABD MERGE-GOURAUD	}intView::GetOptions(int mask)	{	int opt = 0;	if (seeIn) opt |= DRAW_SEE_IN;	if (seeOut) opt |= DRAW_SEE_OUT;	if (seeThrough) opt |= DRAW_SEE_THROUGH;	if (frame) opt |= DRAW_FRAME;	if (fill) opt |= DRAW_FILL;	if (shade) opt |= DRAW_SHADE;	if (noShade) opt |= DRAW_NO_SHADE;	if (whiteShade) opt |= DRAW_WHITE_SHADE;	if (blackFrame) opt |= DRAW_BLACK_FRAME;	if (interpTransp) opt |= DRAW_INTERP_TRANSP;	if (dither) opt |= DRAW_DITHER;	if (bbox) opt |= DRAW_BBOX;		// ABD MERGE2 8/17/93	if (textures) opt |= DRAW_TEXTURES;	// BG	if (gouraud) opt |= DRAW_GOURAUD;	// ABD MERGE-GOURAUD	return(opt & mask);	}voidView::SetPoint(Point3D pnt)	{	if (point.x == pnt.x && point.y == pnt.y && point.z == pnt.z)		return;	point = pnt;	FindViewPoly();	drawing->Sequence();	}voidView::SetAngle(Angle3D angl)	{	angl.yaw &= 0xFF;	angl.pitch &= 0xFF;	angl.roll &= 0xFF;	if (angle.yaw == angl.yaw && angle.pitch == angl.pitch && angle.roll == angl.roll)		return;	angle.yaw = angl.yaw;	angle.pitch = angl.pitch;	angle.roll = angl.roll;	CalcSines();	drawing->Sequence();	}// ABD MERGE2 WILLIAMS 8/16/93 v// added thise method (same as Observer method) to this class because they should be // here also -- they do not reference any Observer methods or instance variables.voidView::SetFFPoint(Point3DFFixed pnt)	{	Point3D	tmpPt;			tmpPt.x = FFRound(pnt.x);	tmpPt.y = FFRound(pnt.y);	tmpPt.z = FFRound(pnt.z);		SetPoint(tmpPt);	}// ABD MERGE2 WILLIAMS 8/16/93 ^/* *	Back door version of SetAngle; bypasses CalcSines() and sets higher precision *	values of sines & cosines. Used only for playing smoothed paths. */voidView::SetFFAngleHiRes(Angle3DFFixed angl)	{	double roll, pitch, yaw;	double tmpS, tmpC;	angle.yaw = FFRound(angl.yaw) & 0xff;	angle.pitch = FFRound(angl.pitch) & 0xff;	angle.roll = FFRound(angl.roll) & 0xff;	yaw = FixedToDbl(angl.yaw) / 128.0 * PI;	pitch = FixedToDbl(angl.pitch) / 128.0 * PI;	roll = FixedToDbl(angl.roll) / 128.0 * PI;	tmpS = sin(-yaw); sinAngle.yaw = floor(tmpS * 32768 + .5);	tmpC = cos(-yaw); cosAngle.yaw = floor(tmpC * 32768 + .5);	if (tmpS > 0 && sinAngle.yaw == -32768) sinAngle.yaw = 32767;	if (tmpC > 0 && cosAngle.yaw == -32768) cosAngle.yaw = 32767;	tmpS = sin(-pitch); sinAngle.pitch = floor(tmpS * 32768 + .5);	tmpC = cos(-pitch); cosAngle.pitch = floor(tmpC * 32768 + .5);	if (tmpS > 0 && sinAngle.pitch == -32768) sinAngle.pitch = 32767;	if (tmpC > 0 && cosAngle.pitch == -32768) cosAngle.pitch = 32767;	tmpS = sin(-roll); sinAngle.roll = floor(tmpS * 32768 + .5);	tmpC = cos(-roll); cosAngle.roll = floor(tmpC * 32768 + .5);	if (tmpS > 0 && sinAngle.roll == -32768) sinAngle.roll = 32767;	if (tmpC > 0 && cosAngle.roll == -32768) cosAngle.roll = 32767;	drawing->Sequence();	}voidView::ResetTilt()	{	if (angle.pitch == 0 && angle.roll == 0)		return;	angle.pitch = 0;	angle.roll = 0;	CalcSines();	drawing->Sequence();	}voidView::Move(int velocity, int latVelocity, int vertVelocity,	int yawVelocity, int pitchVelocity, int rollVelocity)	{	Unit *un;	FFixed f;	int deltaX = 0, deltaY = 0, temp = 0;#if AVERAGE_WALK_SPEED	FFixed ff_velocity, ff_latVelocity, ff_vertVelocity, ff_yawVelocity, ff_pitchVelocity,		ff_rollVelocity, ff_last_frame_msecs, ff_denominator;		// MERGE-WALK-SLOW [[[	// OK here is what we want to do.  We want to have a constant walk rate with respect to	// real time.  So we need to 	// The last frame took last_frame_msecs milliseconds to render.  We'll just go ahead and	// assume that this frame will take the same amount of time.  velocity is given to us	// and we need to decrease it if the last frame was really fast to render.  E.g. If each frame 	// takes 16 milliseconds (approx 60 frames/sec) we would have a velocity of 60 frames * 1 foot	// per frame == 60 feet per second.  This is way too fast.  Since we want to have a velocity	// of 'velocity' feet per frame, we need to multiply velocity by last_frame_msecs/1000.  Thus,	// if the last frame took 1000 msecs, then we actually go at velocity.  If the last frame took	// 500 msecs, then we want to go half as far this frame because we are going to show twice as	// many frames in this second and so each frame should go only have the distance.		// to tune the walk speed:	// to go faster:  change ff_denominator to something smaller	// to go slower:  change ff_denominator to something larger		ff_velocity.intg = (short)velocity;	ff_velocity.frac = 0;	ff_latVelocity.intg = (short)latVelocity;	ff_latVelocity.frac = 0;	ff_vertVelocity.intg = (short)vertVelocity;	ff_vertVelocity.frac = 0;	ff_yawVelocity.intg = (short)yawVelocity;	ff_yawVelocity.frac = 0;	ff_pitchVelocity.intg = (short)pitchVelocity;	ff_pitchVelocity.frac = 0;	ff_rollVelocity.intg = (short)rollVelocity;	ff_rollVelocity.frac = 0;	ff_last_frame_msecs.intg = (short)last_frame_msecs;	ff_last_frame_msecs.frac = 0;	ff_denominator.frac = 0;		ff_denominator.intg = 400;	velocity = FFDiv(FFMult(ff_velocity, ff_last_frame_msecs), ff_denominator).intg;	latVelocity = FFDiv(FFMult(ff_latVelocity, ff_last_frame_msecs), ff_denominator).intg;	vertVelocity = FFDiv(FFMult(ff_vertVelocity, ff_last_frame_msecs), ff_denominator).intg;	ff_denominator.intg = 80;	yawVelocity = FFDiv(FFMult(ff_yawVelocity, ff_last_frame_msecs), ff_denominator).intg;	pitchVelocity = FFDiv(FFMult(ff_pitchVelocity, ff_last_frame_msecs), ff_denominator).intg;	rollVelocity = FFDiv(FFMult(ff_rollVelocity, ff_last_frame_msecs), ff_denominator).intg;	// MERGE-WALK-SLOW ]]]#endif //AVERAGE_WALK_SPEED#ifdef JOEBOB	un = drawing->polyhedron->GetUnit();	if (un != NULL)		{		if (un->GetSize() != unitSize)			{			unitSize = un->GetSize();			scale = DblToFixed(.0254 / unitSize);			}		if (velocity != 0)			{			f.intg = velocity; f.frac = 0;			f = FFMult(f, scale);			velocity = FFRound(f);			}			if (latVelocity != 0)			{			f.intg = latVelocity; f.frac = 0;			f = FFMult(f, scale);			latVelocity = FFRound(f);			}			if (vertVelocity != 0)			{			f.intg = vertVelocity; f.frac = 0;			f = FFMult(f, scale);			vertVelocity = FFRound(f);			}		}#endif //JOEBOB	if (velocity != 0)		{		temp = (long)velocity * cos256(angle.yaw+64) + 64;        deltaX += temp >> 7;		temp = (long)velocity * sin256(angle.yaw+64) + 64;		deltaY += temp >> 7;		}		if (latVelocity != 0)		{		temp = (long)latVelocity * sin256(angle.yaw+64) + 64;        deltaX += temp >> 7;		temp = (long)latVelocity * cos256(angle.yaw+64) + 64;		deltaY -= temp >> 7;		}		if (deltaX != 0 || deltaY != 0 || vertVelocity != 0 ||		yawVelocity != 0 || pitchVelocity != 0 || rollVelocity != 0)		{		point.x = LIMIT((long)point.x + deltaX, -32768L, 32767L);		point.y = LIMIT((long)point.y + deltaY, -32768L, 32767L);		point.z = LIMIT((long)point.z + vertVelocity, -32768L, 32767L);			angle.yaw = (angle.yaw + yawVelocity) & 0xff;		angle.pitch = (angle.pitch + pitchVelocity) & 0xff;		angle.roll = (angle.roll + rollVelocity) & 0xff;		CalcSines();			FindViewPoly();		drawing->Sequence();		}	}// MERGE18 [[[#define POINTS_EQUAL(a,b)	(((a).x == (b).x) && ((a).y == (b).y) && ((a).z == (b).z))/*------------------------------------------------------------------------------------------*//*	This routine moves the observer/view taking into account collisions with objects.		Call this routine instead of View::Move() when collision detection is on.*/voidView::MoveCollision(int velocity, int latVelocity, int vertVelocity,	int yawVelocity, int pitchVelocity, int rollVelocity){int deltaX = 0, deltaY = 0;struct PolyConvex *oldViewPoly = viewPoly;long tmp1;       // ABD MERGE-WH134// ABD MERGE-WH134 replace old code with this [[[	if (velocity != 0)	{		tmp1 = ((long)(velocity)) * ((long)(cos256(angle.yaw+64)));		tmp1 += 64;		tmp1 >>= 7;		deltaX += (short)tmp1;		tmp1 = ((long)(velocity)) * ((long)(sin256(angle.yaw+64)));		tmp1 += 64;		tmp1 >>= 7;		deltaY += (short)tmp1;	}		if (latVelocity != 0)	{		tmp1 = ((long)(latVelocity)) * ((long)(sin256(angle.yaw+64)));		tmp1 += 64;		tmp1 >>= 7;		deltaX += (short)tmp1;		tmp1 = ((long)(latVelocity)) * ((long)(cos256(angle.yaw+64)));		tmp1 += 64;		tmp1 >>= 7;		deltaY -= (short)tmp1;	}// ABD MERGE-WH134 ]]]	if (deltaX != 0 || deltaY != 0 || vertVelocity != 0 ||		yawVelocity != 0 || pitchVelocity != 0 || rollVelocity != 0)	{	Point3D oldPoint = point;	Point3D newPoint;	int collided;	int escape;		newPoint.x = LIMIT((long)oldPoint.x + deltaX, -32768L, 32767L);		newPoint.y = LIMIT((long)oldPoint.y + deltaY, -32768L, 32767L);		newPoint.z = LIMIT((long)oldPoint.z + vertVelocity, -32768L, 32767L);		point = newPoint;		FindViewPoly();				if ((viewPoly != oldViewPoly) || (viewPolys->ALength() != 0))		{		Point3Ddouble org, dir;		double tmax, tresult;		int result;					// we potentially collided, so compute our new location			CalcRay(oldPoint, newPoint, &org, &dir, &tmax);						// now let's test all of the surfaces of oldViewPoly and determine which one			// was hit.  If it is determined that we went through a window or door, then we			// do nothing (no collision).  But if we hit a wall, then compute our new location			// and then recompute our view poly just in case. 			result = oldViewPoly->RayIntersectSurfaces(&org, &dir, tmax, &tresult);		// MERGE26			if (result == RAY_HIT)			{				VPlaySound(bumpSound);				// compute the hit-the-wall point				// we do this by halving the segments repeatedly until the viewPoly equals				// the oldViewPoly								escape = 0;				while ((viewPoly != oldViewPoly) || (viewPolys->ALength() != 0))				{					point.x = (oldPoint.x + newPoint.x) >> 1;					point.y = (oldPoint.y + newPoint.y) >> 1;					point.z = (oldPoint.z + newPoint.z) >> 1;										// find our real view poly based on this point					FindViewPoly();										if (POINTS_EQUAL(point, oldPoint) || POINTS_EQUAL(point, newPoint))					{						point = oldPoint;						FindViewPoly();						break;					}					newPoint = point;				}			}			else // (result == RAY_MISSED)			{				// quick 'n' dirty collision detection -- check the newViewPoly too				result = viewPoly->RayIntersectSurfaces(&org, &dir, tmax, &tresult);		// MERGE26				if (result == RAY_HIT)				{					VPlaySound(bumpSound);						// compute the hit-the-wall point					// we do this by halving the segments repeatedly until the viewPoly equals					// the oldViewPoly										escape = 0;					while ((viewPoly != oldViewPoly) || (viewPolys->ALength() != 0))					{						point.x = (oldPoint.x + newPoint.x) >> 1;						point.y = (oldPoint.y + newPoint.y) >> 1;						point.z = (oldPoint.z + newPoint.z) >> 1;												// find our real view poly based on this point						FindViewPoly();											if (POINTS_EQUAL(point, oldPoint) || POINTS_EQUAL(point, newPoint))						{							point = oldPoint;							FindViewPoly();							break;						}						newPoint = point;					}				}				// MERGE-GOURAUD-PRO-12 [[[				else // (result == RAY_MISSED)				{                	if (viewPolys->ALength() != 0)						VPlaySound(bumpSound);						// hmm.  This ray missed too.  So we probably didn't go all the way					// in, but now we are "in" the wall.  So just do the same thing as					// above, but just look for a zero-length view poly list					while (viewPolys->ALength() != 0)					{						point.x = (oldPoint.x + newPoint.x) >> 1;						point.y = (oldPoint.y + newPoint.y) >> 1;						point.z = (oldPoint.z + newPoint.z) >> 1;												// find our real view poly based on this point						FindViewPoly();											if (POINTS_EQUAL(point, oldPoint) || POINTS_EQUAL(point, newPoint))						{							point = oldPoint;							FindViewPoly();							break;						}						newPoint = point;					}				}				// MERGE-GOURAUD-PRO-12 ]]]			}		}					// update our angle (angle not affected by collisions)		angle.yaw = (angle.yaw + yawVelocity) & 0xff;		angle.pitch = (angle.pitch + pitchVelocity) & 0xff;		angle.roll = (angle.roll + rollVelocity) & 0xff;		CalcSines();				// increment the frame count so that we know to re-clip everything		drawing->Sequence();	}}// MERGE18 ]]]voidView::CalcSines()	{	sinAngle.yaw = sin256w(-angle.yaw);	cosAngle.yaw = cos256w(-angle.yaw);	sinAngle.pitch = sin256w(-angle.pitch);	cosAngle.pitch = cos256w(-angle.pitch);	sinAngle.roll = sin256w(-angle.roll);	cosAngle.roll = cos256w(-angle.roll);	}voidView::ResetViewPoly()	{	viewPoly = drawing->polyhedron->piece;	FindViewPoly();	drawing->Sequence();	}voidView::FindViewPoly()	{	PolyConvex **poly;	int nPolys, i;	while (viewPoly->Inside(point) != PNT_INSIDE || viewPoly->polyhedron->hidden)		viewPoly = viewPoly->polyhedron->FindContainer()->piece;	while (TRUE)		{		Polyhedron *testPoly;		PolyConvex *subPoly;		viewPolys->SetLength(0);		testPoly = viewPoly->polyhedron;		if ((subPoly = testPoly->InsideContents(point, viewPolys)) == NULL ||			subPoly->polyhedron->hidden)			break;		viewPoly = subPoly;		}	if ((nPolys = viewPolys->ALength()) != 0)		{			for (i = nPolys-1; i >= 0; i--)			{			poly = (PolyConvex **)viewPolys->Abuse();			poly += i;			if ((*poly)->polyhedron->hidden)				viewPolys->Remove(i);			}		}	}voidView::AllocPerspTable()	{	perspTable1 = (ULong **)NewHandle(PERSP_LEN1 * sizeof(long));	perspTable2 = (unsigned short **)NewHandle(PERSP_LEN2/PERSP_ILV2 * sizeof(short));	perspTable3 = (unsigned short **)NewHandle(PERSP_LEN3/PERSP_ILV3 * sizeof(short));	perspTable4 = (unsigned short **)NewHandle(PERSP_LEN4/PERSP_ILV4 * sizeof(short));	}voidView::FreePerspTable()	{	DisposHandle((Handle)perspTable1);	DisposHandle((Handle)perspTable2);	DisposHandle((Handle)perspTable3);	DisposHandle((Handle)perspTable4);	}voidView::CalcPerspTable()	{	ULong multiplicand, l, dist;	register ULong *lTable;	register unsigned short *sTable;	register ULong i;	if (focalLength == 0 || width == 0 || height == 0) return;	l = (long)focalLength * (width << 1);	dist = l / filmWidth;	/* Limit distance to length of long part of perspective table */	if (dist >= PERSP_LEN1)		dist = PERSP_LEN1-1;		if (dist == screenDist)		return;	screenDist = dist;	multiplicand = (long)screenDist << 16;		HLock((Handle)perspTable1);	lTable = (ULong *)HDeref((Handle)perspTable1);	*lTable++ = multiplicand;	for (i = 1; i < PERSP_LEN1; i++)		*lTable++ = multiplicand / i;	HUnlock((Handle)perspTable1);	HLock((Handle)perspTable2);	sTable = (unsigned short *)HDeref((Handle)perspTable2);	for ( ; i < PERSP_LEN12; i += PERSP_ILV2)		*sTable++ = multiplicand / i;	HUnlock((Handle)perspTable2);	HLock((Handle)perspTable3);	sTable = (unsigned short *)HDeref((Handle)perspTable3);	for ( ; i < PERSP_LEN123; i += PERSP_ILV3)		*sTable++ = multiplicand / i;	HUnlock((Handle)perspTable3);	HLock((Handle)perspTable4);	sTable = (unsigned short *)HDeref((Handle)perspTable4);	for ( ; i < PERSP_LEN1234; i += PERSP_ILV4)		*sTable++ = multiplicand / i;	HUnlock((Handle)perspTable4);	}// MERGE-HMD [[[voidView::UpdateScreenPoly(int half_w, int half_h)	{	Point *scrn, pt;	scrn = (Point *)screenPoly->Use();	pt.h = -half_w; pt.v = -half_h; *scrn++ = pt;	pt.h = half_w;  pt.v = -half_h; *scrn++ = pt;	pt.h = half_w;  pt.v = half_h;  *scrn++ = pt;	pt.h = -half_w; pt.v = half_h;  *scrn++ = pt;	screenPoly->Unuse();	}// MERGE-HMD ]]]voidView::UpdatePane(int w, int h)	{	Point *scrn, pt;	int oldWidth = width, oldHeight = height;	width = w;	height = h;	UpdateScreenPoly(w, h);		// MERGE-HMD call the new routine now// MERGE-HMD replaced with above line #if 0scrn = (Point *)screenPoly->Use();	pt.h = -w; pt.v = -h; *scrn++ = pt;	pt.h = w;  pt.v = -h; *scrn++ = pt;	pt.h = w;  pt.v = h;  *scrn++ = pt;	pt.h = -w; pt.v = h;  *scrn++ = pt;	screenPoly->Unuse();#endif	// MERGE-HMD	CalcPerspTable();	CalcClipData();	if (oldWidth != w || oldHeight != h)		drawing->Sequence();	}voidView::SetFocalValue(int focal, int film)	{	int oldFocal = focalLength, oldFilm = filmWidth;	focalLength = focal;	filmWidth = film;		CalcPerspTable();	CalcClipData();	if (oldFocal != focal || oldFilm != film)		drawing->Sequence();	}voidView::CalcClipData()	{	int ratio, ratioLog;		if (focalLength == 0 || width == 0 || height == 0) return;	if (width >= screenDist)		{		ratio = (width + screenDist-1) / screenDist;		ratioLog = BitWidth(ratio-1);				xClipA = 8 + ratioLog;		xClipB = 8;		}	else		{		ratio = screenDist / width;		ratioLog = BitWidth(ratio) - 1;				xClipA = 8;		xClipB = 8 + ratioLog;		}	if (height >= screenDist)		{		ratio = (height + screenDist-1) / screenDist;		ratioLog = BitWidth(ratio-1);				zClipA = 8 + ratioLog;		zClipB = 8;		}	else		{		ratio = screenDist / height;		ratioLog = BitWidth(ratio) - 1;				zClipA = 8;		zClipB = 8 + ratioLog;		}	xDistConst = ceil(sqrt((1L << xClipA+xClipA) + (1L << xClipB+xClipB)));	zDistConst = ceil(sqrt((1L << zClipA+zClipA) + (1L << zClipB+zClipB)));// { DAS-LIZARD KING 10/2/93ratio=(32000L + screenDist-1)/screenDist;ratioLog=BitWidth(ratio-1);outsideClipA = 8+ratioLog;if(outsideClipA>14)outsideClipA=14; // DAS-BUGFIX 10/14/93outsideClipB = 8;outsideDistConst = ceil(sqrt((1L << outsideClipA+outsideClipA) + (1L << outsideClipB+outsideClipB)));// } DAS-LIZARD KING 10/2/93	clipWidth = screenDist * (1L << xClipA) / (1L << xClipB);	clipHeight = screenDist * (1L << zClipA) / (1L << zClipB);	}voidView::Draw(int cancelable, int clipToScreen)	{	PolyConvex **poly;	int nPolys, i;	RGBAColor inherit;	Clip *clip, *startClip, *screenClip = NULL;	clip = new(Clip);	clip->cClip();    startClip = clip;	startTime = VGetTime();	abort = FALSE;	abortCount = 0;	testAbort = cancelable;	inherit.red = inherit.blue = inherit.green = 0;	inherit.alpha = 0;	if (!fill)		{		Rect r = currentPane->dataRect;		// MERGE-HMD [[[		#if USE_HMD			// for VRex HMD, we ned to erase the whole pane, not just the top half (which			// is the half we are actually rendering into, so dataRect is fake)		if ((gUseHMDs) && (gHMD) && (gHMD->IsStretchedVertically()))		// ABD HMD JUL95			{				r.bottom <<= 1;			}		#endif // USE_HMD		// MERGE-HMD ]]]		VBackColor(&vWhite);		VEraseRect(&r);		}//	if (clipToScreen)		{//		screenClip = clip->ClipPoly(screenPoly, FALSE);		screenClip = clip->CreateInitialClip(&(currentPane->dataRect));		startClip = screenClip;		}#if WINDOWS	if (dither)	VSetPattern(vPatDithered);      // do gdi dithering.  jca 8 aug 93#endif	// ABD MERGE2 8/17/93 v	// This is used to calc the world bounding box.	if (drawMode & CLIP_BBOX)	{		boundMin.x = boundMin.y = boundMin.z = VMax;		boundMax.x = boundMax.y = boundMax.z = VMin;	}	// ABD MERGE2 8/17/93 ^#if AVERAGE_WALK_SPEED	StartTimingMilli();							// MERGE-WALK-SLOW	viewPoly->DrawWalk(this, startClip, NULL, NULL, inherit);	last_frame_msecs = EndTimingMilli();		// MERGE-WALK-SLOW#else	viewPoly->DrawWalk(this, startClip, NULL, NULL, inherit);#endif //AVERAGE_WALK_SPEED	if ((nPolys = VA_Length(viewPolys)) != 0)		{		VA_Use(viewPolys, poly, PolyConvex *);		for (i = 0; i < nPolys; i++)			(*poly++)->DrawWalk(this, startClip, NULL, NULL, inherit);		VA_Unuse(viewPolys);		}#if WINDOWS	if (dither) VSetPattern(vPatBlack);   // undo gdi dithering. jca 8 aug 93#endif	if (screenClip != NULL) screenClip->dClip();	clip->dClip();	if (abort) drawing->Sequence();	}// ABD MERGE3 8/18/93 v// This routine calcs a good observer position for the view based on the boundMin and// boundMax of the view (these must be calculated first by setting DRAW_BBOX and // drawing a frame)voidView::SetGoodObserverPosition(int panex, int paney)		// ABD WILLIAMS MERGE9  9/8/93{double max_width;double aspect_ratio = (double)paney / (double)panex;	// ABD WILLIAMS MERGE9  9/8/93Point3D widths, new_point;double view_angle, view_angle2;							// ABD WILLIAMS MERGE9  9/8/93Point3D item_center;double y;	// calculate the widths of the bounding box	widths.x = boundMax.x - boundMin.x;	widths.y = boundMax.y - boundMin.y;	widths.z = boundMax.z - boundMin.z;	item_center.x = (boundMax.x + boundMin.x) >> 1;	item_center.y = (boundMax.y + boundMin.y) >> 1;	item_center.z = (boundMax.z + boundMin.z) >> 1;		// calculate the max of these widths	max_width = (double)max(widths.x, widths.z);		// we want the maximum of these widths to be visible, and we assume that the	// observer is in a semi-good place already (i.e. probably looking at the	// front of the object).  So we move the observer backward	// until the maximum of these widths is visible.  	// calculate the actual viewing angle	view_angle = atan((double)(filmWidth >> 1) / (double)focalLength);	view_angle += (15.0 / 57.29577951);		// add some for a little bit of a margin											// (remember that view_angle is in radians)												// figure out the vertical view angle 	view_angle2 = view_angle * aspect_ratio;		// ABD WILLIAMS MERGE9  9/8/93		// figure out the smallest view angle (horiz or vert)	view_angle = min(view_angle, view_angle2);		// ABD WILLIAMS MERGE9  9/8/93		// compute the distance from the item center that we have to be to see the whole thing	y = max_width / tan(view_angle);		// compute the new point (subract our new y from the item center y)	new_point = item_center;		new_point.y -= (int)y;				// subtract our magic number	new_point.y -= (widths.y >> 1);		// subtract half of the bounding box in the y direction		// set the observer position	SetPoint(new_point);}// ABD MERGE3 8/18/93 ^/* *	Use the bounding sphere to test the entire poly against the clip planes */intView::Cull(Point3D center, short radius, short *rendCenterY)	{	register int clipPlanes;	Point3D viewPoint;	short sinYaw, cosYaw, sinPitch, cosPitch, sinRoll, cosRoll, tmpS1, tmpS2;	Point3D pt1, pt2;	long xDistVal, zDistVal, xDistLimit, zDistLimit, farY;	register int xFlip, zFlip;	long tmpL1, tmpL2;	clipPlanes = 0;	viewPoint = point;	sinYaw = sinAngle.yaw;	cosYaw = cosAngle.yaw;	pt1.x = center.x - viewPoint.x;	pt1.y = center.y - viewPoint.y;	pt1.z = center.z - viewPoint.z;	/* Yaw -- rotate from X to Y about Z */	tmpL1 = (long)pt1.x * cosYaw;	tmpL2 = (long)pt1.y * sinYaw;	pt2.x = tmpL1 - tmpL2 + 16384 >> 15;	tmpL1 = (long)pt1.x * sinYaw;	tmpL2 = (long)pt1.y * cosYaw;	pt2.y = tmpL1 + tmpL2 + 16384 >> 15;	pt2.z = pt1.z;	if (angle.pitch != 0 || angle.roll != 0)		{		sinPitch = sinAngle.pitch;		cosPitch = cosAngle.pitch;		sinRoll = sinAngle.roll;		cosRoll = cosAngle.roll;		/* Pitch -- rotate from Y to Z about X */		tmpL1 = (long)pt2.y * cosPitch;		tmpL2 = (long)pt2.z * sinPitch;		pt1.y = tmpL1 - tmpL2 + 16384 >> 15;		tmpL1 = (long)pt2.y * sinPitch;		tmpL2 = (long)pt2.z * cosPitch;		pt1.z = tmpL1 + tmpL2 + 16384 >> 15;		pt1.x = pt2.x;			/* Roll -- rotate from Z to X about Y */		tmpL1 = (long)pt1.z * cosRoll;		tmpL2 = (long)pt1.x * sinRoll;		pt2.z = tmpL1 - tmpL2 + 16384 >> 15;		tmpL1 = (long)pt1.z * sinRoll;		tmpL2 = (long)pt1.x * cosRoll;		pt2.x = tmpL1 + tmpL2 + 16384 >> 15;		pt2.y = pt1.y;		}	if (pt2.y <= -radius)		return(-1);	*rendCenterY = pt2.y;	tmpS1 = radius;	tmpS2 = xDistConst;	xDistLimit = (long)tmpS1 * tmpS2;	tmpS2 = zDistConst;	zDistLimit = (long)tmpS1 * tmpS2;	xFlip = FALSE; zFlip = FALSE;	if (pt2.x > 0) { pt2.x = -pt2.x; xFlip = TRUE; }	if (pt2.z > 0) { pt2.z = -pt2.z; zFlip = TRUE; }	xDistVal = DIST(pt2.y, pt2.x, xClipA, xClipB);	zDistVal = DIST(pt2.y, pt2.z, zClipA, zClipB);	/* test for entirely outside of cone */	if (xDistVal <= -xDistLimit || zDistVal <= -zDistLimit)		return(-1);// { DAS-LIZARD KING 10/2/93	tmpS1 = radius;	tmpS2 = outsideDistConst;	zDistLimit = xDistLimit = (long)tmpS1 * tmpS2;		xDistVal = DIST(pt2.y,pt2.x,outsideClipA,outsideClipB);	zDistVal = DIST(pt2.y,pt2.z,outsideClipA,outsideClipB);	/* test for not entirely inside of cone */	if (xDistVal < xDistLimit)		{		clipPlanes |= xFlip ? PLANE_0_M : PLANE_2_M;		if (DIST(pt2.y, -pt2.x, outsideClipA, outsideClipB) < xDistLimit)			clipPlanes |= xFlip ? PLANE_2_M : PLANE_0_M;		}	if (zDistVal < zDistLimit)		{		clipPlanes |= zFlip ? PLANE_1_M : PLANE_3_M;		if (DIST(pt2.y, -pt2.z, outsideClipA, outsideClipB) < zDistLimit)			clipPlanes |= zFlip ? PLANE_3_M : PLANE_1_M;		}	// } DAS-LIZARD KING 10/2/93		return(clipPlanes);	}/* *	Translate and rotate */voidView::TransRot(V_Array *points, V_Array *rendPoints)	{	Point3D viewPoint;	short sinYaw, cosYaw, sinPitch, cosPitch, sinRoll, cosRoll;	register int nPoints, i;	register Point3DFFixed *pntIndex;	register Point3DLong *rendPntIndex; // DAS - HIRES 8/8/93	Point3D pt1, pt2;	long tmpL1, tmpL2;	viewPoint = point;	sinYaw = sinAngle.yaw >> 6;	cosYaw = cosAngle.yaw >> 6;	nPoints = VA_Length(points);	rendPoints->SetLength(nPoints);	pntIndex = (Point3DFFixed *)VA_Abuse(points);	rendPntIndex = (Point3DLong *)VA_Abuse(rendPoints);	if (angle.pitch != 0 || angle.roll != 0)		{		sinPitch = sinAngle.pitch >> 6;		cosPitch = cosAngle.pitch >> 6;		sinRoll = sinAngle.roll >> 6;		cosRoll = cosAngle.roll >> 6;		for (i = 0; i < nPoints; i++, pntIndex++, rendPntIndex++)			{			Point3DLong pt1L,pt2L;						pt1L.x = (pntIndex->x.l>>10) - ((long)viewPoint.x<<6);			pt1L.y = (pntIndex->y.l>>10) - ((long)viewPoint.y<<6);			pt1L.z = (pntIndex->z.l>>10) - ((long)viewPoint.z<<6);			/* Yaw -- rotate from X to Y about Z */			tmpL1 = (long)pt1L.x * cosYaw;			tmpL2 = (long)pt1L.y * sinYaw;			pt2L.x = tmpL1 - tmpL2 >> 9;			tmpL1 = (long)pt1L.x * sinYaw;			tmpL2 = (long)pt1L.y * cosYaw;			pt2L.y = tmpL1 + tmpL2 >> 9;			pt2L.z = pt1L.z;				/* Pitch -- rotate from Y to Z about X */			tmpL1 = (long)pt2L.y * cosPitch;			tmpL2 = (long)pt2L.z * sinPitch;			pt1L.y = tmpL1 - tmpL2 >> 9;			tmpL1 = (long)pt2L.y * sinPitch;			tmpL2 = (long)pt2L.z * cosPitch;			pt1L.z = tmpL1 + tmpL2 >> 9;			pt1L.x = pt2L.x;			/* Roll -- rotate from Z to X about Y */			tmpL1 = (long)pt1L.z * cosRoll;			tmpL2 = (long)pt1L.x * sinRoll;			rendPntIndex->z = tmpL1 - tmpL2 >> 9;			tmpL1 = (long)pt1L.z * sinRoll;			tmpL2 = (long)pt1L.x * cosRoll;			rendPntIndex->x = tmpL1 + tmpL2 >> 9;			rendPntIndex->y = pt1L.y;				rendPntIndex->pad = 0;			}		}	else		{		for (i = 0; i < nPoints; i++, pntIndex++, rendPntIndex++)			{			long lx,ly,lz;						lx = (pntIndex->x.l>>10) - ((long)viewPoint.x<<6);			ly = (pntIndex->y.l>>10) - ((long)viewPoint.y<<6);			lz = (pntIndex->z.l>>10) - ((long)viewPoint.z<<6);						tmpL1 = lx * cosYaw;			tmpL2 = ly * sinYaw;			rendPntIndex->x = tmpL1 - tmpL2 >> 9;			tmpL1 = lx * sinYaw;			tmpL2 = ly * cosYaw;			rendPntIndex->y = tmpL1 + tmpL2 >> 9;			rendPntIndex->z = lz;			rendPntIndex->pad = 0;			}		}	}/* *	Project */#define PERSP(y) \	((y) < PERSP_LEN1 ? persp1[y] : \	((y) < PERSP_LEN12 ? persp2[(y)-PERSP_LEN1 >> PERSP_ILV2_S] : \	((y) < PERSP_LEN123 ? persp3[(y)-PERSP_LEN12 >> PERSP_ILV3_S] : \	persp4[(y)-PERSP_LEN123 >> PERSP_ILV4_S])))voidView::Project(V_Array *rendPoints, V_Array *NoPerspPoints, Point3DLong *rendBoundMin, Point3DLong *rendBoundMax)	{	register unsigned long *persp1;	unsigned short *persp2, *persp3, *persp4;	register int nCalcPoints, i;	int nCalcPoints2;	register Point3DLong *inPnt;   // DAS - HIRES 8/8/93	register Point3DNoPersp *inPnt2;	register Point *outPnt;	Point3DLong pt1;  // DAS - HIRES 8/8/93	long p22;			// DAS-HIRES this is temporary	Point3DNoPersp ptN;	Point pt2;	register unsigned long perspL, round;	long tmpL;	short persp;	long multiplicand;   // DAS - HIRES 8/8/93	int preShift,shiftDown;	FFixed tempfixed, tempfixed2;/*DAS-HIRES note that the rendPoints are now a 22 bit value.*//*	jca 11 aug 93.  How can this work on the Mac without crashing? It bombs under Windows.	persp1 = *perspTable1;	persp2 = *perspTable2;	persp3 = *perspTable3;	persp4 = *perspTable4;	*/// DAS-BUG! 10/9/93 this moves memory so the persp table dereference CAN FAIL!	nCalcPoints = VA_Length(rendPoints);	if(NoPerspPoints != NULL) {		NoPerspPoints->SetLength(nCalcPoints);		VA_Use(NoPerspPoints, inPnt2, Point3DNoPersp);	}		inPnt = (Point3DLong *) VA_Abuse(rendPoints);  // EASTER ABD JAN 95	// we don't move memory, so we don't need to lock it. // DAS-BUG! 10/9/93 it should be OK here	persp1 = (ULong *) HDeref((Handle)perspTable1);	persp2 = (unsigned short *) HDeref((Handle)perspTable2);	persp3 = (unsigned short *) HDeref((Handle)perspTable3);	persp4 = (unsigned short *) HDeref((Handle)perspTable4);	outPnt = (Point *)inPnt;	if (rendBoundMin != NULL)// DAS-HIRES these need to be 22 bit numbers.		{		rendBoundMin->x = 32767L<<6; 		rendBoundMin->y = 32767L<<6; 		rendBoundMin->z = 32767L<<6;				rendBoundMax->x = -32768L<<6; 		rendBoundMax->y = -32768L<<6; 		rendBoundMax->z = -32768L<<6;		}	for (i = 0; i < nCalcPoints; i++)		{		pt1 = *inPnt++;        // Discard out-of-range points.					// ClipSurf() or ClipFeat() will make pt1.pad negative if this		// point is outside the 3D clip region and has been clipped away.		// If pt1.y is negative, but pt1.pad is not, then a slice has cut		// this point off the object and it is not a vertex of any surface		// (if it were, the 3D clip would have handled it.) As a special		// case, allow for pt1.y == 0 as a hedge against round-off error.		// The perspective table will treat y == 0 just like y == 1.		if (pt1.pad < 0 || pt1.y < 0)			{ outPnt++; inPnt2++; continue; }		// DAS-HIRES the numbers are too large for the table.		p22=pt1.y;		if(shiftDown = pt1.y>=65536)			{			pt1.y>>=6;			pt1.x>>=6;			pt1.z>>=6;			}				perspL = PERSP(pt1.y);		preShift = 0;		if (perspL >= 32*1024L)			{			BIT_WIDTH(perspL, preShift);			preShift -= 15;			persp = perspL >> preShift;			}		else persp = perspL;		/*JAM used to experiment with just doing divides instead of table lookup*/		/*		preShift = 0;		persp = perspL = globalmultiplicand/(pt1.y + 1);		*/				round = 1L << 15-preShift;		tmpL = (long)pt1.x * persp;		pt2.h = tmpL + round >> 16-preShift;		tmpL = (long)pt1.z * persp;		pt2.v = tmpL + round >> 16-preShift;		if (pt1.pad)			{			if (pt1.pad & PLANE_0_M)				pt2.h = clipWidth;			else if (pt1.pad & PLANE_2_M)				pt2.h = -clipWidth-1;				if (pt1.pad & PLANE_1_M)				pt2.v = clipHeight+1;			else if (pt1.pad & PLANE_3_M)				pt2.v = -clipHeight;			}//DAS-HIRES This is ONLY for TEXTURE MAPPING. This insures that the numbers are 16-bit.// WE NEED TO USE 22-bit NUMBERS FOR TEXTURE MAPPING ANYWAY. PLEASE FIX THIS! DAS		if(!shiftDown)			{			perspL<<=6; // DAS-HIRES note that this is 1/y thus 1/(y>>6) 			pt1.y>>=6;			pt1.x>>=6;			pt1.z>>=6;			}		/*z is now depth for ptN*/				if(NoPerspPoints != NULL) {			ptN.x = (short)pt2.h;			ptN.y = (short)pt2.v;			ptN.z = (short)pt1.y;			ptN.noperspx = (short)pt1.x;			ptN.noperspy = (short)pt1.z;			ptN.perspecD = perspL;			*inPnt2++= ptN;		}		// MERGE-HMD [[[		#if USE_HMD		// shift down the number for VRex HMD		if ((gUseHMDs) && (gHMD) && (gHMD->IsStretchedVertically()))	// ABD HMD JUL95		{				pt2.v >>= 1;		}		#endif // USE_HMD		// MERGE-HMD ]]]		*outPnt++ = pt2;				if (rendBoundMin != NULL)			{			if (pt2.h < rendBoundMin->x) rendBoundMin->x = pt2.h;			if (p22 < rendBoundMin->y) rendBoundMin->y = p22;			if (pt2.v < rendBoundMin->z) rendBoundMin->z = pt2.v;				if (pt2.h > rendBoundMax->x) rendBoundMax->x = pt2.h;			if (p22 > rendBoundMax->y) rendBoundMax->y = p22;			if (pt2.v > rendBoundMax->z) rendBoundMax->z = pt2.v;			}		}		if(NoPerspPoints != NULL) {			VA_Unuse(NoPerspPoints);		}	}static char oddBits[] = { FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, TRUE,	TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, TRUE, FALSE };//JAM FASTERSPACIALCLIP [[[#if FASTERSPACIALCLIPV_Array *inTxtPnt1 = NULL, *inTxtPnt2 = NULL, *outTxtPnt1 = NULL, *outTxtPnt2 = NULL;	// JAMV_Array *inGouPnt1 = NULL, *inGouPnt2 = NULL, *outGouPnt1 = NULL, *outGouPnt2 = NULL;	// JAMvoidInitSpacialClip(){	inTxtPnt1 = new(V_Array);	inTxtPnt1->cArray(0, sizeof(PointFFixed), 4);	inTxtPnt1->Use();	inTxtPnt2 = new(V_Array);	inTxtPnt2->cArray(0, sizeof(PointFFixed), 4);	inTxtPnt2->Use();	outTxtPnt1 = new(V_Array);	outTxtPnt1->cArray(0, sizeof(PointFFixed), 4);	outTxtPnt1->Use();	outTxtPnt2 = new(V_Array);	outTxtPnt2->cArray(0, sizeof(PointFFixed), 4);	outTxtPnt2->Use();		inGouPnt1 = new(V_Array);	inGouPnt1->cArray(0, sizeof(FFixed), 4);	inGouPnt1->Use();	inGouPnt2 = new(V_Array);	inGouPnt2->cArray(0, sizeof(FFixed), 4);	inGouPnt2->Use();	outGouPnt1 = new(V_Array);	outGouPnt1->cArray(0, sizeof(FFixed), 4);	outGouPnt1->Use();	outGouPnt2 = new(V_Array);	outGouPnt2->cArray(0, sizeof(FFixed), 4);	outGouPnt2->Use();}voidEndSpacialClip(){	inTxtPnt1->Unuse();	inTxtPnt1->dArray();	inTxtPnt2->Unuse();	inTxtPnt2->dArray();	outTxtPnt1->Unuse();	outTxtPnt1->dArray();	outTxtPnt2->Unuse();	outTxtPnt2->dArray();	inGouPnt1->Unuse();	inGouPnt1->dArray();	inGouPnt2->Unuse();	inGouPnt2->dArray();	outGouPnt1->Unuse();	outGouPnt1->dArray();	outGouPnt2->Unuse();	outGouPnt2->dArray();}#endif//JAM FASTERSPACIALCLIP ]]]//JAM FASTERSPACIALCLIP [[[#if FASTERSPACIALCLIPintView::ClipSurf(V_Array *surfaces, V_Array *posnPoints, V_Array *rendPoints, int clipPlanes){int nSurfaces, i;int xA, xB, zA, zB;register Surface **surfIndex, *surf;Point3D viewPoint, vector, norm;Point3DFFixed testPoint;short pntNum;long dotProd, tmpL;int visible, clipOdd;int has_texture_inside = FALSE, has_texture_outside = FALSE;		// ABDint has_gouraud_inside = FALSE, has_gouraud_outside = FALSE;		// ABD MERGE-GOURAUDV_Offscreen *in_tx,*out_tx;		// ABDextern int gGouraud;		// MERGE-GOURAUD DEBUGunsigned long AbsoluteMaxClippedPoints;	// JAM most points that can result from clipping polyunsigned long ProbableMaxClippedPoints;	// JAM most points that will probably result from clipping poly	#if PROFILE	_profile = TRUE;	#endif	if (!clipPlanes)	{		nSurfaces = VA_Length(surfaces);		surfIndex = (Surface **)VA_Abuse(surfaces);			for (i = 0; i < nSurfaces; i++)		{			surf = *surfIndex++;							// еее THIS SHOULD CHECK the view to see if we should be drawing textures and/or gouraud,			// and if not, it should not clip the texture points.				has_texture_inside = (surf->GetTexture(SURF_INSIDE) != NULL);		// ABD			has_texture_outside = (surf->GetTexture(SURF_OUTSIDE) != NULL);		// ABD			// MERGE-GOURAUD [[[			has_gouraud_inside = (gGouraud) && (surf->GetShadeType(SURF_INSIDE) == SHADE_GOURAUD);					// ABD MERGE-CLIP // ABD DEBUG еее			has_gouraud_outside = (gGouraud) && (surf->GetShadeType(SURF_OUTSIDE) == SHADE_GOURAUD);					// ABD MERGE-CLIP // ABD DEBUG еее			// MERGE-GOURAUD ]]]				if (has_texture_inside)			{				in_tx = surf->GetTexture(SURF_INSIDE)->GetPicture(0);// Turn of thumbnail safety net since it doesnt work. FIND "GetThumbnail" to get all //GJR 09/24/93//				if (in_tx == NULL) 					// can't get the picture, so try using thumbnail//					in_tx = surf->GetTexture(SURF_INSIDE)->GetThumbnail();				if (in_tx == NULL) 					// can't even get the thumbnail, so give up!					has_texture_inside = FALSE;			}			if (has_texture_outside)			{				out_tx = surf->GetTexture(SURF_OUTSIDE)->GetPicture(0);//				if (out_tx == NULL) 					// can't get the picture, so try using thumbnail//					out_tx = surf->GetTexture(SURF_INSIDE)->GetThumbnail();				if (out_tx == NULL) 					// can't even get the thumbnail, so give up!					has_texture_outside = FALSE;			}			// no clip planes, so raw points are copied to rend points directly			if (has_texture_inside)			{				surf->GetRawTexturePoints(SURF_INSIDE)->CopyArray(surf->GetRendTexturePoints(SURF_INSIDE));			}			if (has_texture_outside)			{				surf->GetRawTexturePoints(SURF_OUTSIDE)->CopyArray(surf->GetRendTexturePoints(SURF_OUTSIDE));			}						// MERGE-GOURAUD [[[			if (has_gouraud_inside)				surf->GetRawIntensities(SURF_INSIDE)->CopyArray(surf->GetRendIntensities(SURF_INSIDE));			if (has_gouraud_outside)				surf->GetRawIntensities(SURF_OUTSIDE)->CopyArray(surf->GetRendIntensities(SURF_OUTSIDE));			// MERGE-GOURAUD ]]]					pntNum = ((short *)VA_Abuse(surf->points))[0];			testPoint = ((Point3DFFixed *)VA_Abuse(posnPoints))[pntNum];				viewPoint = point;			vector.x = testPoint.x.intg - viewPoint.x;			vector.y = testPoint.y.intg - viewPoint.y;			vector.z = testPoint.z.intg - viewPoint.z;/* { DAS-LIZARD KING 10/2/93 is this necessary?			if (testPoint.x.frac >= 0x8000) vector.x++;			if (testPoint.y.frac >= 0x8000) vector.y++;			if (testPoint.z.frac >= 0x8000) vector.z++;*/						norm = surf->posnNormal;//  DAS-LIZARD KING 10/2/93 this should be a bit more efficient			dotProd = 	(long)vector.x * norm.x +						(long)vector.y * norm.y +						(long)vector.z * norm.z;// } DAS-LIZARD KING 10/2/93						dotProd = (long)vector.x * norm.x;			tmpL = (long)vector.y * norm.y;			dotProd += tmpL;			tmpL = (long)vector.z * norm.z;			dotProd += tmpL;						if (dotProd < 0)				surf->visible = SURF_VIS_OUTSIDE;			else if (dotProd > 0)				surf->visible = SURF_VIS_INSIDE;			else				surf->visible = SURF_VIS_NEITHER;			surf->clipped = FALSE;			surf->rendPoints = surf->points;		}		#if PROFILE		_profile = FALSE;		DumpProfile();		#endif		return(TRUE);	}	visible = FALSE;	clipOdd = oddBits[clipPlanes];	xA = xClipA; xB = xClipB;	zA = zClipA; zB = zClipB;	nSurfaces = VA_Length(surfaces);	VA_Use(surfaces, surfIndex, Surface *);	for (i = 0; i < nSurfaces; i++)	{		register int nSurfPoints, j, clipP;	int plane, planeMask;	V_Array *srcSurfPnts, *destSurfPnts;	short *surfPnt, newPntNum;	short *destPnt;	long destPntCntr;	register short *surfPntIndex;	Point3DLong thisPt, lastPt, clipPt, *thisPtr; // DAS-HIRES 8/8/93	register long thisDist, lastDist;		surf = *surfIndex++;		pntNum = ((short *)VA_Abuse(surf->points))[0];		testPoint = ((Point3DFFixed *)VA_Abuse(posnPoints))[pntNum];		viewPoint = point;		vector.x = testPoint.x.intg - viewPoint.x;		vector.y = testPoint.y.intg - viewPoint.y;		vector.z = testPoint.z.intg - viewPoint.z;/* { DAS-LIZARD KING 10/2/93 is this necessary?		if (testPoint.x.frac >= 0x8000) vector.x++;		if (testPoint.y.frac >= 0x8000) vector.y++;		if (testPoint.z.frac >= 0x8000) vector.z++;*/				norm = surf->posnNormal;		//  DAS-LIZARD KING 10/2/93 this should be a bit more efficient		dotProd = 	(long)vector.x * norm.x +					(long)vector.y * norm.y +					(long)vector.z * norm.z;// } DAS-LIZARD KING 10/2/93		// DAS-LIZARD KING 10/9/93 need to TURN THIS OFF!/*		dotProd = (long)vector.x * norm.x;		tmpL = (long)vector.y * norm.y;		dotProd += tmpL;		tmpL = (long)vector.z * norm.z;		dotProd += tmpL;*/				if (dotProd < 0)			surf->visible = SURF_VIS_OUTSIDE;		else if (dotProd > 0)			surf->visible = SURF_VIS_INSIDE;		else			surf->visible = SURF_VIS_NEITHER;		has_texture_inside = (surf->GetTexture(SURF_INSIDE) != NULL);		// ABD		has_texture_outside = (surf->GetTexture(SURF_OUTSIDE) != NULL);		// ABD		has_gouraud_inside = (gGouraud) && (surf->GetShadeType(SURF_INSIDE) == SHADE_GOURAUD);					// ABD MERGE-CLIP // ABD DEBUG еее		has_gouraud_outside = (gGouraud) && (surf->GetShadeType(SURF_OUTSIDE) == SHADE_GOURAUD);					// ABD MERGE-CLIP // ABD DEBUG еее		if (has_texture_inside)		{			in_tx = surf->GetTexture(SURF_INSIDE)->GetPicture(0);//			if (in_tx == NULL) 					// can't get the picture, so try using thumbnail//				in_tx = surf->GetTexture(SURF_INSIDE)->GetThumbnail();			if (in_tx == NULL) 					// can't even get the thumbnail, so give up!				has_texture_inside = FALSE;		}		if (has_texture_outside)		{			out_tx = surf->GetTexture(SURF_OUTSIDE)->GetPicture(0);//			if (out_tx == NULL) 					// can't get the picture, so try using thumbnail//				out_tx = surf->GetTexture(SURF_OUTSIDE)->GetThumbnail();			if (out_tx == NULL) 					// can't even get the thumbnail, so give up!				has_texture_outside = FALSE;		}				surf->clipped = FALSE;		surf->rendPoints = surf->rendPointArray;		clipP = clipPlanes;		planeMask = 1;			srcSurfPnts = surf->points;				nSurfPoints = VA_Length(srcSurfPnts);		/*JAM claim: even with concave polys, 4*(num points in poly) + 4		  is greater or equal to the number of points resulting from clip		  to viewing planes*/        //JAM 15Feb94 put parens around shift to fix order		AbsoluteMaxClippedPoints = (((unsigned long) nSurfPoints) << 2) + 4;		ProbableMaxClippedPoints = ((unsigned long) nSurfPoints) + 4;		#if DEBUG		//this is here to test the expansion code that is supposed to		//handle cases where num of points exceeds nSurfPoints + 4,        //i.e. cases with concave polygons        ProbableMaxClippedPoints -= 4;		#endif						VA_Use(srcSurfPnts, surfPnt, short);				surf->rendPoints->SetLength(ProbableMaxClippedPoints);		tempPoints->SetLength(ProbableMaxClippedPoints);		if (clipOdd)		{			destSurfPnts = surf->rendPoints;			tempPoints->Use();		}		else		{			destSurfPnts = tempPoints;			surf->rendPoints->Use();		}		VA_Use(destSurfPnts, destPnt, short);				if (has_texture_inside)		// ABD		{			PointFFixed *tempptr1, *tempptr2;			struct V_Array *rawpts;						if(AbsoluteMaxClippedPoints > inTxtPnt1->ALength())			{				inTxtPnt1->Unuse();				inTxtPnt1->SetLength(AbsoluteMaxClippedPoints);				inTxtPnt1->Use();				inTxtPnt2->Unuse();				inTxtPnt2->SetLength(AbsoluteMaxClippedPoints);				inTxtPnt2->Use();			}			//			surf->GetRawTexturePoints(SURF_INSIDE)->CopyArray(inTxtPnt1);			rawpts = surf->GetRawTexturePoints(SURF_INSIDE);			tempptr1 = (PointFFixed *)rawpts->Use();			tempptr2 = (PointFFixed *)VA_Abuse(inTxtPnt1);			for(j=0;j<nSurfPoints;j++)			{				*tempptr2++ = *tempptr1++;			}			rawpts->Unuse();		}			if (has_texture_outside)		// ABD		{			PointFFixed *tempptr1, *tempptr2;			struct V_Array *rawpts;						if(AbsoluteMaxClippedPoints > outTxtPnt1->ALength())			{				outTxtPnt1->Unuse();				outTxtPnt1->SetLength(AbsoluteMaxClippedPoints);				outTxtPnt1->Use();				outTxtPnt2->Unuse();				outTxtPnt2->SetLength(AbsoluteMaxClippedPoints);				outTxtPnt2->Use();			}			//			surf->GetRawTexturePoints(SURF_OUTSIDE)->CopyArray(outTxtPnt1);			rawpts = surf->GetRawTexturePoints(SURF_OUTSIDE);			tempptr1 = (PointFFixed *)rawpts->Use();			tempptr2 = (PointFFixed *)VA_Abuse(outTxtPnt1);			for(j=0;j<nSurfPoints;j++)			{				*tempptr2++ = *tempptr1++;			}			rawpts->Unuse();		}		if (has_gouraud_inside)		// ABD		{			FFixed *tempptr1, *tempptr2;			struct V_Array *rawpts;						if(AbsoluteMaxClippedPoints > inGouPnt1->ALength())			{				inGouPnt1->Unuse();				inGouPnt1->SetLength(AbsoluteMaxClippedPoints);				inGouPnt1->Use();				inGouPnt2->Unuse();				inGouPnt2->SetLength(AbsoluteMaxClippedPoints);				inGouPnt2->Use();			}			//			surf->GetRawIntensities(SURF_INSIDE)->CopyArray(inGouPnt1);			rawpts = surf->GetRawIntensities(SURF_INSIDE);			tempptr1 = (FFixed *)rawpts->Use();			tempptr2 = (FFixed *)VA_Abuse(inGouPnt1);			for(j=0;j<nSurfPoints;j++)			{				*tempptr2++ = *tempptr1++;			}			rawpts->Unuse();		}			if (has_gouraud_outside)		// ABD		{			FFixed *tempptr1, *tempptr2;			struct V_Array *rawpts;						if(AbsoluteMaxClippedPoints > outGouPnt1->ALength())			{				outGouPnt1->Unuse();				outGouPnt1->SetLength(AbsoluteMaxClippedPoints);				outGouPnt1->Use();				outGouPnt2->Unuse();				outGouPnt2->SetLength(AbsoluteMaxClippedPoints);				outGouPnt2->Use();			}			//			surf->GetRawIntensities(SURF_OUTSIDE)->CopyArray(outGouPnt1);			rawpts = surf->GetRawIntensities(SURF_OUTSIDE);			tempptr1 = (FFixed *)rawpts->Use();			tempptr2 = (FFixed *)VA_Abuse(outGouPnt1);			for(j=0;j<nSurfPoints;j++)			{				*tempptr2++ = *tempptr1++;			}			rawpts->Unuse();		}		for (plane = 0; !surf->clipped && clipP; clipP >>= 1, planeMask <<= 1, plane++)		{			PointFFixed *inTxt1, *inTxt2, *outTxt1, *outTxt2;			FFixed *inGou1, *inGou2, *outGou1, *outGou2;						if (has_texture_inside)			{				inTxt1 = (PointFFixed *)VA_Abuse(inTxtPnt1);				inTxt2 = (PointFFixed *)VA_Abuse(inTxtPnt2);			}			if (has_texture_outside)			{				outTxt1 = (PointFFixed *)VA_Abuse(outTxtPnt1);				outTxt2 = (PointFFixed *)VA_Abuse(outTxtPnt2);			}			if (has_gouraud_inside)			{				inGou1 = (FFixed *)VA_Abuse(inGouPnt1);				inGou2 = (FFixed *)VA_Abuse(inGouPnt2);			}			if (has_gouraud_outside)			{				outGou1 = (FFixed *)VA_Abuse(outGouPnt1);				outGou2 = (FFixed *)VA_Abuse(outGouPnt2);			}						while (!(clipP & 1))			{ clipP >>= 1; planeMask <<= 1; plane++; }				surf->clipped = TRUE;	//			nSurfPoints = VA_Length(srcSurfPnts);//			VA_Use(srcSurfPnts, surfPnt, short); 			surfPnt = (short *)VA_Abuse(srcSurfPnts);			surfPntIndex = surfPnt;			destPnt = (short *)VA_Abuse(destSurfPnts);//			VA_Truncate(destSurfPnts);			destPntCntr = 0;						for (j = 0; j < nSurfPoints+1; j++, surfPntIndex++)				{				if (j < nSurfPoints) // XYZZY - HIRES					thisPtr = (Point3DLong *)VA_Abuse(rendPoints) + *surfPntIndex;				else // XYZZY - HIRES					thisPtr = (Point3DLong *)VA_Abuse(rendPoints) + *surfPnt;					thisPt = *thisPtr;					if (plane == 0)					thisDist = DIST(thisPt.y, -thisPt.x, xA, xB);				else if (plane == 1)					thisDist = DIST(thisPt.y, -thisPt.z, zA, zB);				else if (plane == 2)					thisDist = DIST(thisPt.y, thisPt.x, xA, xB);				else if (plane == 3)					thisDist = DIST(thisPt.y, thisPt.z, zA, zB);								if (thisDist < 0) thisPtr->pad |= ~0x00FF;					/* neither old or new points are clipped away */				if (thisDist >= 0 && (j == 0 || lastDist >= 0))				{					if (j < nSurfPoints)					{//						VA_Append(destSurfPnts, *surfPntIndex, short);						//if we are about to add a point and we already have the number						//of surface points plus four, we need to allocate more room.						//this should basically never happen except in bizare concave						//polygon situations.  This code should be tested in DEBUG=1						//mode due to the -4 on ProbableMaxClippedPoint earlier in the                        //routine in debug mode						if(destPntCntr >= ProbableMaxClippedPoints)						{							tempPoints->Unuse();							surf->rendPoints->Unuse();							tempPoints->SetLength(AbsoluteMaxClippedPoints);							surf->rendPoints->SetLength(AbsoluteMaxClippedPoints);							tempPoints->Use();							surf->rendPoints->Use();							surfPnt = (short *)VA_Abuse(srcSurfPnts);							surfPntIndex = &(surfPnt[j]);							destPnt = (short *)VA_Abuse(destSurfPnts);							#if DEBUG							if(ProbableMaxClippedPoints == AbsoluteMaxClippedPoints) DEBUGGER();							#endif							ProbableMaxClippedPoints = AbsoluteMaxClippedPoints;							AbsoluteMaxClippedPoints <<= 1;						}						destPnt[destPntCntr] = *surfPntIndex;						destPntCntr++;						if (has_texture_inside)		// ABD						{//						PointFFixed pt;													*inTxt2++ = inTxt1[j];//							inTxtPnt1->Get(j, &pt);//							inTxtPnt2->Append(&pt);						}						if (has_texture_outside)		// ABD						{//						PointFFixed pt;													*outTxt2++ = outTxt1[j];//							outTxtPnt1->Get(j, &pt);//							outTxtPnt2->Append(&pt);						}						if (has_gouraud_inside)		// ABD						{//						FFixed sh;													*inGou2++ = inGou1[j];//							inGouPnt1->Get(j, &sh);//							inGouPnt2->Append(&sh);						}						if (has_gouraud_outside)		// ABD						{//						FFixed sh;													*outGou2++ = outGou1[j];//							outGouPnt1->Get(j, &sh);//							outGouPnt2->Append(&sh);						}					}						surf->clipped = FALSE;				}					/* both old and new points are clipped away */				else if (thisDist < 0 && (j == 0 || lastDist < 0))					/* do nothing */ ;					/* only new point is clipped away -- cross from unclipped to clipped */				else if (thisDist < 0)				{					clipPt = CalcClip(lastPt, thisPt, lastDist, thisDist);					clipPt.pad = (lastPt.pad & thisPt.pad & 0x00FF) | planeMask;						if (has_texture_inside)		// ABD					{						/*						PointFFixed pt1, pt2, ptC;												inTxtPnt1->Get(j-1, &pt1);						if (j < nSurfPoints)							inTxtPnt1->Get(j, &pt2);						else							inTxtPnt1->Get(0, &pt2);												ptC = CalcClip2D(pt1, pt2, lastDist, thisDist);						inTxtPnt2->Append(&ptC);						*/												if(j < nSurfPoints)							*inTxt2++ = CalcClip2D(inTxt1[j-1], inTxt1[j], lastDist, thisDist);						else							*inTxt2++ = CalcClip2D(inTxt1[j-1], inTxt1[0], lastDist, thisDist);					}					if (has_texture_outside)		// ABD					{						/*						PointFFixed pt1, pt2, ptC;												outTxtPnt1->Get(j-1, &pt1);						if (j < nSurfPoints)							outTxtPnt1->Get(j, &pt2);						else							outTxtPnt1->Get(0, &pt2);												ptC = CalcClip2D(pt1, pt2, lastDist, thisDist);						outTxtPnt2->Append(&ptC);						*/												if(j < nSurfPoints)							*outTxt2++ = CalcClip2D(outTxt1[j-1], outTxt1[j], lastDist, thisDist);						else							*outTxt2++ = CalcClip2D(outTxt1[j-1], outTxt1[0], lastDist, thisDist);					}					if (has_gouraud_inside)		// ABD					{						/*						FFixed sh1, sh2, shC;												inGouPnt1->Get(j-1, &sh1);						if (j < nSurfPoints)							inGouPnt1->Get(j, &sh2);						else							inGouPnt1->Get(0, &sh2);												shC = CalcClip2DGouraud(sh1, sh2, lastDist, thisDist);						inGouPnt2->Append(&shC);						*/												if(j < nSurfPoints)							*inGou2++ = CalcClip2DGouraud(inGou1[j-1], inGou1[j], lastDist, thisDist);						else							*inGou2++ = CalcClip2DGouraud(inGou1[j-1], inGou1[0], lastDist, thisDist);					}					if (has_gouraud_outside)		// ABD					{						/*						FFixed sh1, sh2, shC;												outGouPnt1->Get(j-1, &sh1);						if (j < nSurfPoints)							outGouPnt1->Get(j, &sh2);						else							outGouPnt1->Get(0, &sh2);												shC = CalcClip2DGouraud(sh1, sh2, lastDist, thisDist);						outGouPnt2->Append(&shC);						*/												if(j < nSurfPoints)							*outGou2++ = CalcClip2DGouraud(outGou1[j-1], outGou1[j], lastDist, thisDist);						else							*outGou2++ = CalcClip2DGouraud(outGou1[j-1], outGou1[0], lastDist, thisDist);					}										newPntNum = VA_Length(rendPoints);//					VA_Append(destSurfPnts, newPntNum, short);					//if we are about to add a point and we already have the number					//of surface points plus four, we need to allocate more room.					//this should basically never happen except in bizare concave					//polygon situations.  This code should be tested in DEBUG=1					//mode due to the -4 on ProbableMaxClippedPoint earlier in the					//routine in debug mode					if(destPntCntr >= ProbableMaxClippedPoints)					{						tempPoints->Unuse();						surf->rendPoints->Unuse();						tempPoints->SetLength(AbsoluteMaxClippedPoints);						surf->rendPoints->SetLength(AbsoluteMaxClippedPoints);						tempPoints->Use();						surf->rendPoints->Use();						surfPnt = (short *)VA_Abuse(srcSurfPnts);						surfPntIndex = &(surfPnt[j]);						destPnt = (short *)VA_Abuse(destSurfPnts);						#if DEBUG						if(ProbableMaxClippedPoints == AbsoluteMaxClippedPoints) DEBUGGER();						#endif						ProbableMaxClippedPoints = AbsoluteMaxClippedPoints;						AbsoluteMaxClippedPoints <<= 1;					}					destPnt[destPntCntr] = newPntNum;					destPntCntr++;					VA_Append(rendPoints, clipPt, Point3DLong);				}					/* only old point is clipped away -- cross from clipped to unclipped */				else if (lastDist < 0)					{					clipPt = CalcClip(thisPt, lastPt, thisDist, lastDist);					clipPt.pad = (lastPt.pad & thisPt.pad & 0x00FF) | planeMask;						newPntNum = VA_Length(rendPoints);//					VA_Append(destSurfPnts, newPntNum, short);					//if we are about to add a point and we already have the number					//of surface points plus four, we need to allocate more room.					//this should basically never happen except in bizare concave					//polygon situations.  This code should be tested in DEBUG=1					//mode due to the -4 on ProbableMaxClippedPoint earlier in the					//routine in debug mode					if(destPntCntr >= ProbableMaxClippedPoints)					{						tempPoints->Unuse();						surf->rendPoints->Unuse();						tempPoints->SetLength(AbsoluteMaxClippedPoints);						surf->rendPoints->SetLength(AbsoluteMaxClippedPoints);						tempPoints->Use();						surf->rendPoints->Use();						surfPnt = (short *)VA_Abuse(srcSurfPnts);						surfPntIndex = &(surfPnt[j]);						destPnt = (short *)VA_Abuse(destSurfPnts);						#if DEBUG						if(ProbableMaxClippedPoints == AbsoluteMaxClippedPoints) DEBUGGER();						#endif						ProbableMaxClippedPoints = AbsoluteMaxClippedPoints;						AbsoluteMaxClippedPoints <<= 1;					}					destPnt[destPntCntr] = newPntNum;					destPntCntr++;					VA_Append(rendPoints, clipPt, Point3DLong);					if (has_texture_inside)		// ABD					{						/*						PointFFixed pt1, pt2, ptC;												inTxtPnt1->Get(j-1, &pt1);						if (j < nSurfPoints)							inTxtPnt1->Get(j, &pt2);						else							inTxtPnt1->Get(0, &pt2);												ptC = CalcClip2D(pt2, pt1, thisDist, lastDist);						inTxtPnt2->Append(&ptC);						*/												if(j < nSurfPoints)							*inTxt2++ = CalcClip2D(inTxt1[j], inTxt1[j-1], thisDist, lastDist);						else							*inTxt2++ = CalcClip2D(inTxt1[0], inTxt1[j-1], thisDist, lastDist);					}					if (has_texture_outside)		// ABD					{						/*						PointFFixed pt1, pt2, ptC;												outTxtPnt1->Get(j-1, &pt1);						if (j < nSurfPoints)							outTxtPnt1->Get(j, &pt2);						else							outTxtPnt1->Get(0, &pt2);												ptC = CalcClip2D(pt2, pt1, thisDist, lastDist);						outTxtPnt2->Append(&ptC);						*/												if(j < nSurfPoints)							*outTxt2++ = CalcClip2D(outTxt1[j], outTxt1[j-1], thisDist, lastDist);						else							*outTxt2++ = CalcClip2D(outTxt1[0], outTxt1[j-1], thisDist, lastDist);					}					if (has_gouraud_inside)		// ABD					{						/*						FFixed sh1, sh2, shC;												inGouPnt1->Get(j-1, &sh1);						if (j < nSurfPoints)							inGouPnt1->Get(j, &sh2);						else							inGouPnt1->Get(0, &sh2);												shC = CalcClip2D(sh2, sh1, thisDist, lastDist);						inGouPnt2->Append(&shC);						*/												if(j < nSurfPoints)							*inGou2++ = CalcClip2DGouraud(inGou1[j], inGou1[j-1], thisDist, lastDist);						else							*inGou2++ = CalcClip2DGouraud(inGou1[0], inGou1[j-1], thisDist, lastDist);					}					if (has_gouraud_outside)		// ABD					{						/*						FFixed sh1, sh2, shC;												outGouPnt1->Get(j-1, &sh1);						if (j < nSurfPoints)							outGouPnt1->Get(j, &sh2);						else							outGouPnt1->Get(0, &sh2);												shC = CalcClip2D(sh2, sh1, thisDist, lastDist);						outGouPnt2->Append(&shC);						*/												if(j < nSurfPoints)							*outGou2++ = CalcClip2DGouraud(outGou1[j], outGou1[j-1], thisDist, lastDist);						else							*outGou2++ = CalcClip2DGouraud(outGou1[0], outGou1[j-1], thisDist, lastDist);					}						if (j < nSurfPoints)					{//						VA_Append(destSurfPnts, *surfPntIndex, short);						//if we are about to add a point and we already have the number						//of surface points plus four, we need to allocate more room.						//this should basically never happen except in bizare concave						//polygon situations.  This code should be tested in DEBUG=1						//mode due to the -4 on ProbableMaxClippedPoint earlier in the						//routine in debug mode						if(destPntCntr >= ProbableMaxClippedPoints)						{							tempPoints->Unuse();							surf->rendPoints->Unuse();							tempPoints->SetLength(AbsoluteMaxClippedPoints);							surf->rendPoints->SetLength(AbsoluteMaxClippedPoints);							tempPoints->Use();							surf->rendPoints->Use();							surfPnt = (short *)VA_Abuse(srcSurfPnts);							surfPntIndex = &(surfPnt[j]);							destPnt = (short *)VA_Abuse(destSurfPnts);							#if DEBUG							if(ProbableMaxClippedPoints == AbsoluteMaxClippedPoints) DEBUGGER();							#endif							ProbableMaxClippedPoints = AbsoluteMaxClippedPoints;							AbsoluteMaxClippedPoints <<= 1;						}						destPnt[destPntCntr] = *surfPntIndex;						destPntCntr++;												if (has_texture_inside)		// ABD						{//						PointFFixed pt;													*inTxt2++ = inTxt1[j];//							inTxtPnt1->Get(j, &pt);//							inTxtPnt2->Append(&pt);						}						if (has_texture_outside)		// ABD						{//						PointFFixed pt;													*outTxt2++ = outTxt1[j];//							outTxtPnt1->Get(j, &pt);//							outTxtPnt2->Append(&pt);						}						if (has_gouraud_inside)		// ABD						{//						FFixed sh;													*inGou2++ = inGou1[j];//							inGouPnt1->Get(j, &sh);//							inGouPnt2->Append(&sh);						}						if (has_gouraud_outside)		// ABD						{//						FFixed sh;													*outGou2++ = outGou1[j];//							outGouPnt1->Get(j, &sh);//							outGouPnt2->Append(&sh);						}					}						surf->clipped = FALSE;				}							lastPt = thisPt;				lastDist = thisDist;			}	//			VA_Unuse(srcSurfPnts);						nSurfPoints = destPntCntr;#if DEBUG			if(nSurfPoints > ProbableMaxClippedPoints) DEBUGGER();#endif			srcSurfPnts = destSurfPnts;			if (destSurfPnts == tempPoints)				destSurfPnts = surf->rendPoints;			else				destSurfPnts = tempPoints;			if (has_texture_inside)		// ABD			{				V_Array *tempptr;								tempptr = inTxtPnt1;				inTxtPnt1 = inTxtPnt2;				inTxtPnt2 = tempptr;				//				inTxtPnt2->CopyArray(inTxtPnt1);//				inTxtPnt2->SetLength(0);			}			if (has_texture_outside)		// ABD			{				V_Array *tempptr;								tempptr = outTxtPnt1;				outTxtPnt1 = outTxtPnt2;				outTxtPnt2 = tempptr;				//				outTxtPnt2->CopyArray(outTxtPnt1);//				outTxtPnt2->SetLength(0);			}			if (has_gouraud_inside)		// ABD			{				V_Array *tempptr;								tempptr = inGouPnt1;				inGouPnt1 = inGouPnt2;				inGouPnt2 = tempptr;				//				inGouPnt2->CopyArray(inGouPnt1);//				inGouPnt2->SetLength(0);			}			if (has_gouraud_outside)		// ABD			{				V_Array *tempptr;								tempptr = outGouPnt1;				outGouPnt1 = outGouPnt2;				outGouPnt2 = tempptr;				//				outGouPnt2->CopyArray(outGouPnt1);//				outGouPnt2->SetLength(0);			}		}	 //		VA_Unuse(srcSurfPnts);//		VA_Unuse(destSurfPnts);		surf->points->Unuse();		tempPoints->Unuse();		surf->rendPoints->Unuse();		srcSurfPnts->SetLength(nSurfPoints);		destSurfPnts->SetLength(nSurfPoints);				if (!surf->clipped) visible = TRUE;	 		if (has_texture_inside)		// ABD		{			PointFFixed *tempptr1 = (PointFFixed *)VA_Abuse(inTxtPnt1);			PointFFixed *tempptr2;			struct V_Array *rendpts;						rendpts = surf->GetRendTexturePoints(SURF_INSIDE);			rendpts->SetLength(nSurfPoints);			tempptr2 = (PointFFixed *)rendpts->Use();						for(j=0;j<nSurfPoints;j++)			{				*tempptr2++ = *tempptr1++;			}			rendpts->Unuse();		}		if (has_texture_outside)		// ABD		{			PointFFixed *tempptr1 = (PointFFixed *)VA_Abuse(outTxtPnt1);			PointFFixed *tempptr2;			struct V_Array *rendpts;						rendpts = surf->GetRendTexturePoints(SURF_OUTSIDE);			rendpts->SetLength(nSurfPoints);			tempptr2 = (PointFFixed *)rendpts->Use();						for(j=0;j<nSurfPoints;j++)			{				*tempptr2++ = *tempptr1++;			}			rendpts->Unuse();		}		if (has_gouraud_inside)		// ABD		{			FFixed *tempptr1 = (FFixed *)VA_Abuse(inGouPnt1);			FFixed *tempptr2;			struct V_Array *rendpts;						rendpts = surf->GetRendIntensities(SURF_INSIDE);			rendpts->SetLength(nSurfPoints);			tempptr2 = (FFixed *)rendpts->Use();						for(j=0;j<nSurfPoints;j++)			{				*tempptr2++ = *tempptr1++;			}			rendpts->Unuse();		}		if (has_gouraud_outside)		// ABD		{			FFixed *tempptr1 = (FFixed *)VA_Abuse(outGouPnt1);			FFixed *tempptr2;			struct V_Array *rendpts;						rendpts = surf->GetRendIntensities(SURF_OUTSIDE);			rendpts->SetLength(nSurfPoints);			tempptr2 = (FFixed *)rendpts->Use();						for(j=0;j<nSurfPoints;j++)			{				*tempptr2++ = *tempptr1++;			}			rendpts->Unuse();		}	}	VA_Unuse(surfaces);	#if PROFILE	_profile = FALSE;	DumpProfile();	#endif	return(visible);}#else //if FASTERSPACIALCLIPintView::ClipSurf(V_Array *surfaces, V_Array *posnPoints, V_Array *rendPoints, int clipPlanes){int nSurfaces, i;int xA, xB, zA, zB;register Surface **surfIndex, *surf;Point3D viewPoint, vector, norm;Point3DFFixed testPoint;short pntNum;long dotProd, tmpL;int visible, clipOdd;int has_texture_inside = FALSE, has_texture_outside = FALSE;		// ABDint has_gouraud_inside = FALSE, has_gouraud_outside = FALSE;		// ABD MERGE-GOURAUDV_Array *inTxtPnt1 = NULL, *inTxtPnt2 = NULL, *outTxtPnt1 = NULL, *outTxtPnt2 = NULL;		// ABDV_Array *inGouPnt1 = NULL, *inGouPnt2 = NULL, *outGouPnt1 = NULL, *outGouPnt2 = NULL;		// ABD MERGE-GOURAUDV_Offscreen *in_tx,*out_tx;		// ABDextern int gGouraud;		// MERGE-GOURAUD DEBUG	#if PROFILE	_profile = TRUE;	#endif	if (!clipPlanes)	{		nSurfaces = VA_Length(surfaces);		surfIndex = (Surface **)VA_Abuse(surfaces);			for (i = 0; i < nSurfaces; i++)		{			surf = *surfIndex++;							// еее THIS SHOULD CHECK the view to see if we should be drawing textures and/or gouraud,			// and if not, it should not clip the texture points.				has_texture_inside = (surf->GetTexture(SURF_INSIDE) != NULL);		// ABD			has_texture_outside = (surf->GetTexture(SURF_OUTSIDE) != NULL);		// ABD			// MERGE-GOURAUD [[[			has_gouraud_inside = (gGouraud) && (surf->GetShadeType(SURF_INSIDE) == SHADE_GOURAUD);					// ABD MERGE-CLIP // ABD DEBUG еее			has_gouraud_outside = (gGouraud) && (surf->GetShadeType(SURF_OUTSIDE) == SHADE_GOURAUD);					// ABD MERGE-CLIP // ABD DEBUG еее			// MERGE-GOURAUD ]]]				if (has_texture_inside)			{				in_tx = surf->GetTexture(SURF_INSIDE)->GetPicture(0);// Turn of thumbnail safety net since it doesnt work. FIND "GetThumbnail" to get all //GJR 09/24/93//				if (in_tx == NULL) 					// can't get the picture, so try using thumbnail//					in_tx = surf->GetTexture(SURF_INSIDE)->GetThumbnail();				if (in_tx == NULL) 					// can't even get the thumbnail, so give up!					has_texture_inside = FALSE;			}			if (has_texture_outside)			{				out_tx = surf->GetTexture(SURF_OUTSIDE)->GetPicture(0);//				if (out_tx == NULL) 					// can't get the picture, so try using thumbnail//					out_tx = surf->GetTexture(SURF_INSIDE)->GetThumbnail();				if (out_tx == NULL) 					// can't even get the thumbnail, so give up!					has_texture_outside = FALSE;			}			// no clip planes, so raw points are copied to rend points directly			if (has_texture_inside)			{				surf->GetRawTexturePoints(SURF_INSIDE)->CopyArray(surf->GetRendTexturePoints(SURF_INSIDE));			}			if (has_texture_outside)			{				surf->GetRawTexturePoints(SURF_OUTSIDE)->CopyArray(surf->GetRendTexturePoints(SURF_OUTSIDE));			}						// MERGE-GOURAUD [[[			if (has_gouraud_inside)				surf->GetRawIntensities(SURF_INSIDE)->CopyArray(surf->GetRendIntensities(SURF_INSIDE));			if (has_gouraud_outside)				surf->GetRawIntensities(SURF_OUTSIDE)->CopyArray(surf->GetRendIntensities(SURF_OUTSIDE));			// MERGE-GOURAUD ]]]					pntNum = ((short *)VA_Abuse(surf->points))[0];			testPoint = ((Point3DFFixed *)VA_Abuse(posnPoints))[pntNum];				viewPoint = point;			vector.x = testPoint.x.intg - viewPoint.x;			vector.y = testPoint.y.intg - viewPoint.y;			vector.z = testPoint.z.intg - viewPoint.z;/* { DAS-LIZARD KING 10/2/93 is this necessary?			if (testPoint.x.frac >= 0x8000) vector.x++;			if (testPoint.y.frac >= 0x8000) vector.y++;			if (testPoint.z.frac >= 0x8000) vector.z++;*/						norm = surf->posnNormal;//  DAS-LIZARD KING 10/2/93 this should be a bit more efficient			dotProd = 	(long)vector.x * norm.x +						(long)vector.y * norm.y +						(long)vector.z * norm.z;// } DAS-LIZARD KING 10/2/93						dotProd = (long)vector.x * norm.x;			tmpL = (long)vector.y * norm.y;			dotProd += tmpL;			tmpL = (long)vector.z * norm.z;			dotProd += tmpL;						if (dotProd < 0)				surf->visible = SURF_VIS_OUTSIDE;			else if (dotProd > 0)				surf->visible = SURF_VIS_INSIDE;			else				surf->visible = SURF_VIS_NEITHER;			surf->clipped = FALSE;			surf->rendPoints = surf->points;		}		#if PROFILE		_profile = FALSE;		DumpProfile();		#endif		return(TRUE);	}	visible = FALSE;	clipOdd = oddBits[clipPlanes];	xA = xClipA; xB = xClipB;	zA = zClipA; zB = zClipB;	nSurfaces = VA_Length(surfaces);	VA_Use(surfaces, surfIndex, Surface *);	for (i = 0; i < nSurfaces; i++)	{		register int nSurfPoints, j, clipP;	int plane, planeMask;	V_Array *srcSurfPnts, *destSurfPnts;	short *surfPnt, newPntNum;	register short *surfPntIndex;	Point3DLong thisPt, lastPt, clipPt, *thisPtr; // DAS-HIRES 8/8/93	register long thisDist, lastDist;		surf = *surfIndex++;		// еее THIS SHOULD CHECK the view to see if we should be drawing textures and/or gouraud,		// and if not, it should not clip the texture points.		has_texture_inside = (surf->GetTexture(SURF_INSIDE) != NULL);		// ABD		has_texture_outside = (surf->GetTexture(SURF_OUTSIDE) != NULL);		// ABD			// MERGE-GOURAUD [[[		has_gouraud_inside = (gGouraud) && (surf->GetShadeType(SURF_INSIDE) == SHADE_GOURAUD);					// ABD MERGE-CLIP // ABD DEBUG еее		has_gouraud_outside = (gGouraud) && (surf->GetShadeType(SURF_OUTSIDE) == SHADE_GOURAUD);					// ABD MERGE-CLIP // ABD DEBUG еее		// MERGE-GOURAUD ]]]		if (has_texture_inside)		{			in_tx = surf->GetTexture(SURF_INSIDE)->GetPicture(0);//			if (in_tx == NULL) 					// can't get the picture, so try using thumbnail//				in_tx = surf->GetTexture(SURF_INSIDE)->GetThumbnail();			if (in_tx == NULL) 					// can't even get the thumbnail, so give up!				has_texture_inside = FALSE;		}		if (has_texture_outside)		{			out_tx = surf->GetTexture(SURF_OUTSIDE)->GetPicture(0);//			if (out_tx == NULL) 					// can't get the picture, so try using thumbnail//				out_tx = surf->GetTexture(SURF_OUTSIDE)->GetThumbnail();			if (out_tx == NULL) 					// can't even get the thumbnail, so give up!				has_texture_outside = FALSE;		}				if (has_texture_inside)		// ABD		{			inTxtPnt1 = new(V_Array);			inTxtPnt1->cArray(0, sizeof(PointFFixed), 4);			inTxtPnt2 = new(V_Array);			inTxtPnt2->cArray(0, sizeof(PointFFixed), 4);						surf->GetRawTexturePoints(SURF_INSIDE)->CopyArray(inTxtPnt1);		}			if (has_texture_outside)		// ABD		{			outTxtPnt1 = new(V_Array);			outTxtPnt1->cArray(0, sizeof(PointFFixed), 4);			outTxtPnt2 = new(V_Array);			outTxtPnt2->cArray(0, sizeof(PointFFixed), 4);						surf->GetRawTexturePoints(SURF_OUTSIDE)->CopyArray(outTxtPnt1);		}				// MERGE-GOURAUD [[[		if (has_gouraud_inside)		{			inGouPnt1 = new(V_Array);			inGouPnt1->cArray(0, sizeof(FFixed), 4);			inGouPnt2 = new(V_Array);			inGouPnt2->cArray(0, sizeof(FFixed), 4);						surf->GetRawIntensities(SURF_INSIDE)->CopyArray(inGouPnt1);		}			if (has_gouraud_outside)		{			outGouPnt1 = new(V_Array);			outGouPnt1->cArray(0, sizeof(FFixed), 4);			outGouPnt2 = new(V_Array);			outGouPnt2->cArray(0, sizeof(FFixed), 4);						surf->GetRawIntensities(SURF_OUTSIDE)->CopyArray(outGouPnt1);		}		// MERGE-GOURAUD ]]]		pntNum = ((short *)VA_Abuse(surf->points))[0];		testPoint = ((Point3DFFixed *)VA_Abuse(posnPoints))[pntNum];		viewPoint = point;		vector.x = testPoint.x.intg - viewPoint.x;		vector.y = testPoint.y.intg - viewPoint.y;		vector.z = testPoint.z.intg - viewPoint.z;/* { DAS-LIZARD KING 10/2/93 is this necessary?		if (testPoint.x.frac >= 0x8000) vector.x++;		if (testPoint.y.frac >= 0x8000) vector.y++;		if (testPoint.z.frac >= 0x8000) vector.z++;*/				norm = surf->posnNormal;		//  DAS-LIZARD KING 10/2/93 this should be a bit more efficient		dotProd = 	(long)vector.x * norm.x +					(long)vector.y * norm.y +					(long)vector.z * norm.z;// } DAS-LIZARD KING 10/2/93		// DAS-LIZARD KING 10/9/93 need to TURN THIS OFF!/*		dotProd = (long)vector.x * norm.x;		tmpL = (long)vector.y * norm.y;		dotProd += tmpL;		tmpL = (long)vector.z * norm.z;		dotProd += tmpL;*/				if (dotProd < 0)			surf->visible = SURF_VIS_OUTSIDE;		else if (dotProd > 0)			surf->visible = SURF_VIS_INSIDE;		else			surf->visible = SURF_VIS_NEITHER;		surf->clipped = FALSE;		surf->rendPoints = surf->rendPointArray;		clipP = clipPlanes;		planeMask = 1;			srcSurfPnts = surf->points;		if (clipOdd) destSurfPnts = surf->rendPoints;		else destSurfPnts = tempPoints;		lastDist = 0;        lastPt.x = lastPt.y = lastPt.z = 0;		for (plane = 0; !surf->clipped && clipP; clipP >>= 1, planeMask <<= 1, plane++)		{			while (!(clipP & 1))			{ clipP >>= 1; planeMask <<= 1; plane++; }				surf->clipped = TRUE;				nSurfPoints = VA_Length(srcSurfPnts);			VA_Use(srcSurfPnts, surfPnt, short); 			surfPntIndex = surfPnt;			VA_Truncate(destSurfPnts);						for (j = 0; j < nSurfPoints+1; j++, surfPntIndex++)				{				if (j < nSurfPoints) // XYZZY - HIRES					thisPtr = (Point3DLong *)VA_Abuse(rendPoints) + *surfPntIndex;				else // XYZZY - HIRES					thisPtr = (Point3DLong *)VA_Abuse(rendPoints) + *surfPnt;					thisPt = *thisPtr;					if (plane == 0)					thisDist = DIST(thisPt.y, -thisPt.x, xA, xB);				else if (plane == 1)					thisDist = DIST(thisPt.y, -thisPt.z, zA, zB);				else if (plane == 2)					thisDist = DIST(thisPt.y, thisPt.x, xA, xB);				else if (plane == 3)					thisDist = DIST(thisPt.y, thisPt.z, zA, zB);								if (thisDist < 0) thisPtr->pad |= ~0x00FF;					/* neither old or new points are clipped away */				if (thisDist >= 0 && (j == 0 || lastDist >= 0))				{					if (j < nSurfPoints)					{						VA_Append(destSurfPnts, *surfPntIndex, short);						if (has_texture_inside)		// ABD						{						PointFFixed pt;													inTxtPnt1->Get(j, &pt);							inTxtPnt2->Append(&pt);						}						if (has_texture_outside)		// ABD						{						PointFFixed pt;													outTxtPnt1->Get(j, &pt);							outTxtPnt2->Append(&pt);						}												// MERGE-GOURAUD [[[						if (has_gouraud_inside)						{						FFixed sh;													inGouPnt1->Get(j, &sh);							inGouPnt2->Append(&sh);						}						if (has_gouraud_outside)						{						FFixed sh;													outGouPnt1->Get(j, &sh);							outGouPnt2->Append(&sh);						}						// MERGE-GOURAUD ]]]					}						surf->clipped = FALSE;				}					/* both old and new points are clipped away */				else if (thisDist < 0 && (j == 0 || lastDist < 0))					/* do nothing */ ;					/* only new point is clipped away -- cross from unclipped to clipped */				else if (thisDist < 0)				{					clipPt = CalcClip(lastPt, thisPt, lastDist, thisDist);					clipPt.pad = (lastPt.pad & thisPt.pad & 0x00FF) | planeMask;						if (has_texture_inside)		// ABD					{						PointFFixed pt1, pt2, ptC;												inTxtPnt1->Get(j-1, &pt1);						if (j < nSurfPoints)							inTxtPnt1->Get(j, &pt2);						else							inTxtPnt1->Get(0, &pt2);												ptC = CalcClip2D(pt1, pt2, lastDist, thisDist);						inTxtPnt2->Append(&ptC);					}					if (has_texture_outside)		// ABD					{						PointFFixed pt1, pt2, ptC;												outTxtPnt1->Get(j-1, &pt1);						if (j < nSurfPoints)							outTxtPnt1->Get(j, &pt2);						else							outTxtPnt1->Get(0, &pt2);												ptC = CalcClip2D(pt1, pt2, lastDist, thisDist);						outTxtPnt2->Append(&ptC);					}						// MERGE-GOURAUD [[[					if (has_gouraud_inside)		// ABD					{					FFixed sh1, sh2, shC;												inGouPnt1->Get(j-1, &sh1);						if (j < nSurfPoints)							inGouPnt1->Get(j, &sh2);						else							inGouPnt1->Get(0, &sh2);												shC = CalcClip2DGouraud(sh1, sh2, lastDist, thisDist);						inGouPnt2->Append(&shC);					}					if (has_gouraud_outside)		// ABD					{					FFixed sh1, sh2, shC;												outGouPnt1->Get(j-1, &sh1);						if (j < nSurfPoints)							outGouPnt1->Get(j, &sh2);						else							outGouPnt1->Get(0, &sh2);												shC = CalcClip2DGouraud(sh1, sh2, lastDist, thisDist);						outGouPnt2->Append(&shC);					}					// MERGE-GOURAUD ]]]										newPntNum = VA_Length(rendPoints);					VA_Append(destSurfPnts, newPntNum, short);					VA_Append(rendPoints, clipPt, Point3DLong);				}					/* only old point is clipped away -- cross from clipped to unclipped */				else if (lastDist < 0)					{					clipPt = CalcClip(thisPt, lastPt, thisDist, lastDist);					clipPt.pad = (lastPt.pad & thisPt.pad & 0x00FF) | planeMask;						newPntNum = VA_Length(rendPoints);					VA_Append(destSurfPnts, newPntNum, short);					VA_Append(rendPoints, clipPt, Point3DLong);					if (has_texture_inside)		// ABD					{					PointFFixed pt1, pt2, ptC;											inTxtPnt1->Get(j-1, &pt1);						if (j < nSurfPoints)							inTxtPnt1->Get(j, &pt2);						else							inTxtPnt1->Get(0, &pt2);											ptC = CalcClip2D(pt2, pt1, thisDist, lastDist);						inTxtPnt2->Append(&ptC);					}					if (has_texture_outside)		// ABD					{					PointFFixed pt1, pt2, ptC;											outTxtPnt1->Get(j-1, &pt1);						if (j < nSurfPoints)							outTxtPnt1->Get(j, &pt2);						else							outTxtPnt1->Get(0, &pt2);											ptC = CalcClip2D(pt2, pt1, thisDist, lastDist);						outTxtPnt2->Append(&ptC);					}										// MERGE-GOURAUD [[[					if (has_gouraud_inside)		// ABD					{					FFixed sh1, sh2, shC;											inGouPnt1->Get(j-1, &sh1);						if (j < nSurfPoints)							inGouPnt1->Get(j, &sh2);						else							inGouPnt1->Get(0, &sh2);											shC = CalcClip2DGouraud(sh2, sh1, thisDist, lastDist);						inGouPnt2->Append(&shC);					}					if (has_gouraud_outside)		// ABD					{					FFixed sh1, sh2, shC;											outGouPnt1->Get(j-1, &sh1);						if (j < nSurfPoints)							outGouPnt1->Get(j, &sh2);						else							outGouPnt1->Get(0, &sh2);											shC = CalcClip2DGouraud(sh2, sh1, thisDist, lastDist);						outGouPnt2->Append(&shC);					}					// MERGE-GOURAUD ]]]						if (j < nSurfPoints)					{						VA_Append(destSurfPnts, *surfPntIndex, short);												if (has_texture_inside)		// ABD						{						PointFFixed pt;													inTxtPnt1->Get(j, &pt);							inTxtPnt2->Append(&pt);						}												if (has_texture_outside)		// ABD						{						PointFFixed pt;													outTxtPnt1->Get(j, &pt);							outTxtPnt2->Append(&pt);						}											// MERGE-GOURAUD [[[						if (has_gouraud_inside)		// ABD						{						FFixed sh;													inGouPnt1->Get(j, &sh);							inGouPnt2->Append(&sh);						}												if (has_gouraud_outside)		// ABD						{						FFixed sh;													outGouPnt1->Get(j, &sh);							outGouPnt2->Append(&sh);						}						// MERGE-GOURAUD ]]]					}						surf->clipped = FALSE;				}							lastPt = thisPt;				lastDist = thisDist;			}	//			VA_Unuse(srcSurfPnts);			srcSurfPnts->Unuse();						srcSurfPnts = destSurfPnts;			if (destSurfPnts == tempPoints)				destSurfPnts = surf->rendPoints;			else				destSurfPnts = tempPoints;			if (has_texture_inside)		// ABD			{				inTxtPnt2->CopyArray(inTxtPnt1);				inTxtPnt2->SetLength(0);			}			if (has_texture_outside)		// ABD			{				outTxtPnt2->CopyArray(outTxtPnt1);				outTxtPnt2->SetLength(0);			}						// MERGE-GOURAUD [[[			if (has_gouraud_inside)		// ABD			{				inGouPnt2->CopyArray(inGouPnt1);				inGouPnt2->SetLength(0);			}			if (has_gouraud_outside)		// ABD			{				outGouPnt2->CopyArray(outGouPnt1);				outGouPnt2->SetLength(0);			}			// MERGE-GOURAUD ]]]		}			if (!surf->clipped) visible = TRUE;	 		if (has_texture_inside)		// ABD		{			inTxtPnt1->CopyArray(surf->GetRendTexturePoints(SURF_INSIDE));			inTxtPnt1->dArray();			inTxtPnt2->dArray();		}		if (has_texture_outside)		// ABD		{			outTxtPnt1->CopyArray(surf->GetRendTexturePoints(SURF_OUTSIDE));			outTxtPnt1->dArray();			outTxtPnt2->dArray();		}		// MERGE-GOURAUD [[[		if (has_gouraud_inside)		// ABD		{			inGouPnt1->CopyArray(surf->GetRendIntensities(SURF_INSIDE));			inGouPnt1->dArray();			inGouPnt2->dArray();		}		if (has_gouraud_outside)		// ABD		{			outGouPnt1->CopyArray(surf->GetRendIntensities(SURF_OUTSIDE));			outGouPnt1->dArray();			outGouPnt2->dArray();		}		// MERGE-GOURAUD ]]]	}	VA_Unuse(surfaces);	#if PROFILE	_profile = FALSE;	DumpProfile();	#endif	return(visible);}#endif //if FASTERSPACIALCLIP#if FASTERSPACIALCLIPintView::ClipFeat(SurfFeature *feat, int clipPlanes)		// ABD TEXTURE{	register int nFeatPoints, j;	int xA, xB, zA, zB;	register int clipP;	int plane, planeMask;	V_Array *srcFeatPnts, *tmpArray;	register V_Array *destFeatPnts;	register Point3DLong *featPnt, *featPntIndex;	Point3DLong *destPnt;	long destPntCntr;	Point3DLong thisPt, lastPt, clipPt, *thisPtr; // DAS-HIRES	register long thisDist, lastDist;	int visible;	int has_texture = FALSE;	V_Array *txtPnt1, *txtPnt2;	V_Offscreen *tx;	unsigned long AbsoluteMaxClippedPoints;	// JAM most points that can result from clipping poly	unsigned long ProbableMaxClippedPoints;	// JAM most points that will probably result from clipping poly	/* feature is textured if feature texture field is not NULL */	has_texture = (feat->GetTexture() != NULL);	if (has_texture)	{		tx = feat->GetTexture()->GetPicture(0);//		if (tx == NULL) 					// can't get the picture, so try using thumbnail//			tx = feat->GetTexture()->GetThumbnail();		if (tx == NULL) 					// can't even get the thumbnail, so give up!			has_texture = FALSE;	}	// create some arrays to store the clipped texture points in	if (!clipPlanes)	{		// if no clip planes then the rend points are the same as the raw points		if (has_texture)		{			feat->GetRawTexturePoints()->CopyArray(feat->GetRendTexturePoints());		}		return(TRUE);	}		srcFeatPnts = feat->rendPoints;	destFeatPnts = tempFeatPoints;		nFeatPoints = VA_Length(srcFeatPnts);	//JAM 15Feb94 put parens around shift to fix order	AbsoluteMaxClippedPoints = (((unsigned long) nFeatPoints) << 2) + 4;	ProbableMaxClippedPoints = ((unsigned long) nFeatPoints) + 4;	#if DEBUG	//this is here to test the expansion code that is supposed to	//handle cases where num of points exceeds nSurfPoints + 4,	//i.e. cases with concave polygons    ProbableMaxClippedPoints -= 4;	#endif		srcFeatPnts->SetLength(ProbableMaxClippedPoints);	destFeatPnts->SetLength(ProbableMaxClippedPoints);	VA_Use(srcFeatPnts, featPnt, Point3DLong);	VA_Use(destFeatPnts, destPnt, Point3DLong);		if (has_texture)	{		// otherwise initialize our arrays to store the clipped texture points in, and		// copy the raw texture points into one of them		PointFFixed *tempptr1, *tempptr2;		struct V_Array *rawpts;				/*JAM claim: even with concave polys, 4*(num points in poly) + 4		  is greater or equal to the number of points resulting from clip		  to viewing planes*/					if(AbsoluteMaxClippedPoints > inTxtPnt1->ALength())		{			inTxtPnt1->Unuse();			inTxtPnt1->SetLength(AbsoluteMaxClippedPoints);			inTxtPnt1->Use();			inTxtPnt2->Unuse();			inTxtPnt2->SetLength(AbsoluteMaxClippedPoints);			inTxtPnt2->Use();		}//		feat->GetRawTexturePoints()->CopyArray(txtPnt1);		rawpts = feat->GetRawTexturePoints();		tempptr1 = (PointFFixed *)rawpts->Use();		tempptr2 = (PointFFixed *)VA_Abuse(inTxtPnt1);		for(j=0;j<nFeatPoints;j++)		{			*tempptr2++ = *tempptr1++;		}		rawpts->Unuse();	}	xA = xClipA; xB = xClipB;	zA = zClipA; zB = zClipB;	visible = TRUE;	clipP = clipPlanes;	planeMask = 1;	for (plane = 0; visible && clipP; clipP >>= 1, planeMask <<= 1, plane++)	{		PointFFixed *Txt1, *Txt2;					if (has_texture)		{			Txt1 = (PointFFixed *)VA_Abuse(inTxtPnt1);			Txt2 = (PointFFixed *)VA_Abuse(inTxtPnt2);		}					while (!(clipP & 1))			{ clipP >>= 1; planeMask <<= 1, plane++; }		visible = FALSE;//		nFeatPoints = VA_Length(srcFeatPnts);//		VA_Use(srcFeatPnts, featPnt, Point3DLong); featPntIndex = featPnt;		featPnt = (Point3DLong *)VA_Abuse(srcFeatPnts);		featPntIndex = featPnt;//		VA_Truncate(destFeatPnts);		destPnt = (Point3DLong *)VA_Abuse(destFeatPnts);		destPntCntr = 0;		for (j = 0; j < nFeatPoints+1; j++, featPntIndex++)		{			if (j < nFeatPoints)				thisPtr = featPntIndex;			else				thisPtr = featPnt;			thisPt = *thisPtr;			if (plane == 0)				thisDist = DIST(thisPt.y, -thisPt.x, xA, xB);			else if (plane == 1)				thisDist = DIST(thisPt.y, -thisPt.z, zA, zB);			else if (plane == 2)				thisDist = DIST(thisPt.y, thisPt.x, xA, xB);			else if (plane == 3)				thisDist = DIST(thisPt.y, thisPt.z, zA, zB);						if (thisDist < 0) thisPtr->pad |= ~0x00FF;			/* neither old or new points are clipped away */			if (thisDist >= 0 && (j == 0 || lastDist >= 0))			{				if (j < nFeatPoints)				{//					VA_Append(destFeatPnts, thisPt, Point3DLong);					//if we are about to add a point and we already have the number					//of surface feature points plus four, we need to allocate more room.					//this should basically never happen except in bizare concave					//polygon situations.  This code should be tested in DEBUG=1					//mode due to the -4 on ProbableMaxClippedPoint earlier in the					//routine in debug mode					if(destPntCntr >= ProbableMaxClippedPoints)					{						srcFeatPnts->Unuse();						destFeatPnts->Unuse();						srcFeatPnts->SetLength(AbsoluteMaxClippedPoints);						destFeatPnts->SetLength(AbsoluteMaxClippedPoints);						VA_Use(srcFeatPnts, featPnt, Point3DLong);						VA_Use(destFeatPnts, destPnt, Point3DLong);						featPnt = (Point3DLong *)VA_Abuse(srcFeatPnts);						featPntIndex = &(featPnt[j]);						destPnt = (Point3DLong *)VA_Abuse(destFeatPnts);						#if DEBUG						if(ProbableMaxClippedPoints == AbsoluteMaxClippedPoints) DEBUGGER();						#endif						ProbableMaxClippedPoints = AbsoluteMaxClippedPoints;						AbsoluteMaxClippedPoints <<= 1;					}					destPnt[destPntCntr] = thisPt;					destPntCntr++;					if (has_texture)					{						//PointFFixed pt;						*Txt2++ = Txt1[j];						//txtPnt1->Get(j, &pt);						//txtPnt2->Append(&pt);					}				}				visible = TRUE;			}			/* both old and new points are clipped away */			else if (thisDist < 0 && (j == 0 || lastDist < 0))				/* do nothing */ ;			/* only new point is clipped away -- cross from unclipped to clipped */			else if (thisDist < 0)			{				clipPt = CalcClip(lastPt, thisPt, lastDist, thisDist);				clipPt.pad = (lastPt.pad & thisPt.pad & 0x00FF) | planeMask;				if (has_texture)				{					/*					PointFFixed pt1, pt2, ptC;										txtPnt1->Get(j-1, &pt1);					if (j < nFeatPoints)						txtPnt1->Get(j, &pt2);					else						txtPnt1->Get(0, &pt2);										ptC = CalcClip2D(pt1, pt2, lastDist, thisDist);					txtPnt2->Append(&ptC);					*/					if(j < nFeatPoints)						*Txt2++ = CalcClip2D(Txt1[j-1],Txt1[j],lastDist,thisDist);					else						*Txt2++ = CalcClip2D(Txt1[j-1],Txt1[0],lastDist,thisDist);				}//				VA_Append(destFeatPnts, clipPt, Point3DLong);				//if we are about to add a point and we already have the number				//of surface feature points plus four, we need to allocate more room.				//this should basically never happen except in bizare concave				//polygon situations.  This code should be tested in DEBUG=1				//mode due to the -4 on ProbableMaxClippedPoint earlier in the				//routine in debug mode				if(destPntCntr >= ProbableMaxClippedPoints)				{					srcFeatPnts->Unuse();					destFeatPnts->Unuse();					srcFeatPnts->SetLength(AbsoluteMaxClippedPoints);					destFeatPnts->SetLength(AbsoluteMaxClippedPoints);					VA_Use(srcFeatPnts, featPnt, Point3DLong);					VA_Use(destFeatPnts, destPnt, Point3DLong);					featPnt = (Point3DLong *)VA_Abuse(srcFeatPnts);					featPntIndex = &(featPnt[j]);					destPnt = (Point3DLong *)VA_Abuse(destFeatPnts);					#if DEBUG					if(ProbableMaxClippedPoints == AbsoluteMaxClippedPoints) DEBUGGER();					#endif					ProbableMaxClippedPoints = AbsoluteMaxClippedPoints;					AbsoluteMaxClippedPoints <<= 1;				}				destPnt[destPntCntr] = clipPt;				destPntCntr++;			}			/* only old point is clipped away -- cross from clipped to unclipped */			else if (lastDist < 0)			{				clipPt = CalcClip(thisPt, lastPt, thisDist, lastDist);				clipPt.pad = (lastPt.pad & thisPt.pad & 0x00FF) | planeMask;//				VA_Append(destFeatPnts, clipPt, Point3DLong);				//if we are about to add a point and we already have the number				//of surface feature points plus four, we need to allocate more room.				//this should basically never happen except in bizare concave				//polygon situations.  This code should be tested in DEBUG=1				//mode due to the -4 on ProbableMaxClippedPoint earlier in the				//routine in debug mode				if(destPntCntr >= ProbableMaxClippedPoints)				{					srcFeatPnts->Unuse();					destFeatPnts->Unuse();					srcFeatPnts->SetLength(AbsoluteMaxClippedPoints);					destFeatPnts->SetLength(AbsoluteMaxClippedPoints);					VA_Use(srcFeatPnts, featPnt, Point3DLong);					VA_Use(destFeatPnts, destPnt, Point3DLong);					featPnt = (Point3DLong *)VA_Abuse(srcFeatPnts);					featPntIndex = &(featPnt[j]);					destPnt = (Point3DLong *)VA_Abuse(destFeatPnts);					#if DEBUG					if(ProbableMaxClippedPoints == AbsoluteMaxClippedPoints) DEBUGGER();					#endif					ProbableMaxClippedPoints = AbsoluteMaxClippedPoints;					AbsoluteMaxClippedPoints <<= 1;				}				destPnt[destPntCntr] = clipPt;				destPntCntr++;				if (has_texture)				{					/*					PointFFixed pt1, pt2, ptC;									txtPnt1->Get(j-1, &pt1);					if (j < nFeatPoints)						txtPnt1->Get(j, &pt2);					else						txtPnt1->Get(0, &pt2);									ptC = CalcClip2D(pt2, pt1, thisDist, lastDist);					txtPnt2->Append(&ptC);					*/										if(j < nFeatPoints)						*Txt2++ = CalcClip2D(Txt1[j],Txt1[j-1],thisDist,lastDist);					else						*Txt2++ = CalcClip2D(Txt1[0],Txt1[j-1],thisDist,lastDist);				}				if (j < nFeatPoints)				{//					VA_Append(destFeatPnts, thisPt, Point3DLong);					//if we are about to add a point and we already have the number					//of surface feature points plus four, we need to allocate more room.					//this should basically never happen except in bizare concave					//polygon situations.  This code should be tested in DEBUG=1					//mode due to the -4 on ProbableMaxClippedPoint earlier in the					//routine in debug mode					if(destPntCntr >= ProbableMaxClippedPoints)					{						srcFeatPnts->Unuse();						destFeatPnts->Unuse();						srcFeatPnts->SetLength(AbsoluteMaxClippedPoints);						destFeatPnts->SetLength(AbsoluteMaxClippedPoints);						VA_Use(srcFeatPnts, featPnt, Point3DLong);						VA_Use(destFeatPnts, destPnt, Point3DLong);						featPnt = (Point3DLong *)VA_Abuse(srcFeatPnts);						featPntIndex = &(featPnt[j]);						destPnt = (Point3DLong *)VA_Abuse(destFeatPnts);						#if DEBUG						if(ProbableMaxClippedPoints == AbsoluteMaxClippedPoints) DEBUGGER();						#endif						ProbableMaxClippedPoints = AbsoluteMaxClippedPoints;						AbsoluteMaxClippedPoints <<= 1;					}					destPnt[destPntCntr] = thisPt;					destPntCntr++;					if (has_texture)					{						//PointFFixed pt;						*Txt2++ = Txt1[j];						//txtPnt1->Get(j, &pt);						//txtPnt2->Append(&pt);					}				}				visible = TRUE;			}					lastPt = thisPt;			lastDist = thisDist;		}//		VA_Unuse(srcFeatPnts);		nFeatPoints = destPntCntr;#if DEBUG	if(nFeatPoints > ProbableMaxClippedPoints) DEBUGGER();#endif		tmpArray = destFeatPnts;		destFeatPnts = srcFeatPnts;		srcFeatPnts = tmpArray;		if (has_texture)		{			V_Array *tempptr;							tempptr = inTxtPnt1;			inTxtPnt1 = inTxtPnt2;			inTxtPnt2 = tempptr;				//			txtPnt2->CopyArray(txtPnt1);//			txtPnt2->SetLength(0);		}	}		VA_Unuse(srcFeatPnts);	VA_Unuse(destFeatPnts);	feat->rendPoints->SetLength(nFeatPoints);	 	if (visible && oddBits[clipPlanes])	{		tempFeatPoints->SetLength(nFeatPoints);	//MERGE-PRO-JAM-3 fix some spiders--this copy made rendpoints the max size		tempFeatPoints->CopyArray(feat->rendPoints);	}	if (has_texture)	{			PointFFixed *tempptr1 = (PointFFixed *)VA_Abuse(inTxtPnt1);			PointFFixed *tempptr2;			struct V_Array *rendpts;						rendpts = feat->GetRendTexturePoints();			rendpts->SetLength(nFeatPoints);			tempptr2 = (PointFFixed *)rendpts->Use();						for(j=0;j<nFeatPoints;j++)			{				*tempptr2++ = *tempptr1++;			}			rendpts->Unuse();	}	return(visible);}#else //else FASTERSPACIALCLIP is 0intView::ClipFeat(SurfFeature *feat, int clipPlanes)		// ABD TEXTURE{	register int nFeatPoints, j;	int xA, xB, zA, zB;	register int clipP;	int plane, planeMask;	V_Array *srcFeatPnts, *tmpArray;	register V_Array *destFeatPnts;	register Point3DLong *featPnt, *featPntIndex;	Point3DLong thisPt, lastPt, clipPt, *thisPtr; // DAS-HIRES	register long thisDist, lastDist;	int visible;	int has_texture = FALSE;	V_Array *txtPnt1, *txtPnt2;	V_Offscreen *tx;	/* feature is textured if feature texture field is not NULL */	has_texture = (feat->GetTexture() != NULL);	if (has_texture)	{		tx = feat->GetTexture()->GetPicture(0);//		if (tx == NULL) 					// can't get the picture, so try using thumbnail//			tx = feat->GetTexture()->GetThumbnail();		if (tx == NULL) 					// can't even get the thumbnail, so give up!			has_texture = FALSE;	}	// create some arrays to store the clipped texture points in	if (!clipPlanes)	{		// if no clip planes then the rend points are the same as the raw points		if (has_texture)		{			feat->GetRawTexturePoints()->CopyArray(feat->GetRendTexturePoints());		}		return(TRUE);	}	else if (has_texture)	{		// otherwise create our arrays to store the clipped texture points in, and		// copy the raw texture points into one of them		txtPnt1 = new(V_Array);		txtPnt1->cArray(0, sizeof(PointFFixed), 4);		txtPnt2 = new(V_Array);		txtPnt2->cArray(0, sizeof(PointFFixed), 4);		feat->GetRawTexturePoints()->CopyArray(txtPnt1);	}	xA = xClipA; xB = xClipB;	zA = zClipA; zB = zClipB;	visible = TRUE;	clipP = clipPlanes;	planeMask = 1;	srcFeatPnts = feat->rendPoints;	destFeatPnts = tempFeatPoints;		for (plane = 0; visible && clipP; clipP >>= 1, planeMask <<= 1, plane++)	{		while (!(clipP & 1))			{ clipP >>= 1; planeMask <<= 1, plane++; }		visible = FALSE;		nFeatPoints = VA_Length(srcFeatPnts);		VA_Use(srcFeatPnts, featPnt, Point3DLong); featPntIndex = featPnt;		VA_Truncate(destFeatPnts);		lastDist = 0;        lastPt.x = lastPt.y = lastPt.z = 0;		for (j = 0; j < nFeatPoints+1; j++, featPntIndex++)		{			if (j < nFeatPoints)				thisPtr = featPntIndex;			else				thisPtr = featPnt;			thisPt = *thisPtr;			if (plane == 0)				thisDist = DIST(thisPt.y, -thisPt.x, xA, xB);			else if (plane == 1)				thisDist = DIST(thisPt.y, -thisPt.z, zA, zB);			else if (plane == 2)				thisDist = DIST(thisPt.y, thisPt.x, xA, xB);			else if (plane == 3)				thisDist = DIST(thisPt.y, thisPt.z, zA, zB);						if (thisDist < 0) thisPtr->pad |= ~0x00FF;			/* neither old or new points are clipped away */			if (thisDist >= 0 && (j == 0 || lastDist >= 0))			{				if (j < nFeatPoints)				{					VA_Append(destFeatPnts, thisPt, Point3DLong);					if (has_texture)					{						PointFFixed pt;											txtPnt1->Get(j, &pt);						txtPnt2->Append(&pt);					}				}				visible = TRUE;			}			/* both old and new points are clipped away */			else if (thisDist < 0 && (j == 0 || lastDist < 0))				/* do nothing */ ;			/* only new point is clipped away -- cross from unclipped to clipped */			else if (thisDist < 0)			{				clipPt = CalcClip(lastPt, thisPt, lastDist, thisDist);				clipPt.pad = (lastPt.pad & thisPt.pad & 0x00FF) | planeMask;				if (has_texture)				{					PointFFixed pt1, pt2, ptC;										txtPnt1->Get(j-1, &pt1);					if (j < nFeatPoints)						txtPnt1->Get(j, &pt2);					else						txtPnt1->Get(0, &pt2);										ptC = CalcClip2D(pt1, pt2, lastDist, thisDist);					txtPnt2->Append(&ptC);				}				VA_Append(destFeatPnts, clipPt, Point3DLong);			}			/* only old point is clipped away -- cross from clipped to unclipped */			else if (lastDist < 0)			{				clipPt = CalcClip(thisPt, lastPt, thisDist, lastDist);				clipPt.pad = (lastPt.pad & thisPt.pad & 0x00FF) | planeMask;				VA_Append(destFeatPnts, clipPt, Point3DLong);				if (has_texture)				{					PointFFixed pt1, pt2, ptC;									txtPnt1->Get(j-1, &pt1);					if (j < nFeatPoints)						txtPnt1->Get(j, &pt2);					else						txtPnt1->Get(0, &pt2);									ptC = CalcClip2D(pt2, pt1, thisDist, lastDist);					txtPnt2->Append(&ptC);				}				if (j < nFeatPoints)				{					VA_Append(destFeatPnts, thisPt, Point3DLong);					if (has_texture)					{						PointFFixed pt;											txtPnt1->Get(j, &pt);						txtPnt2->Append(&pt);					}				}				visible = TRUE;			}					lastPt = thisPt;			lastDist = thisDist;		}		VA_Unuse(srcFeatPnts);		tmpArray = destFeatPnts;		destFeatPnts = srcFeatPnts;		srcFeatPnts = tmpArray;		if (has_texture)		{			txtPnt2->CopyArray(txtPnt1);			txtPnt2->SetLength(0);		}	} 	if (visible && oddBits[clipPlanes])		tempFeatPoints->CopyArray(feat->rendPoints); 	if (has_texture)	{		txtPnt1->CopyArray(feat->GetRendTexturePoints());		txtPnt1->dArray();		txtPnt2->dArray();	}	return(visible);}#endif //FASTERSPACIALCLIP//JAM FASTERSPACIALCLIP ]]]	/* ABD TEXTURE */PointFFixedView::CalcClip2D(PointFFixed pt1, PointFFixed pt2, register long dist1, register long dist2)	{	long	distTot;	int		shiftNum;	int		shiftAvail;	FFixed	num;	FFixed	den;	FFixed	scale;	FFixed	diff;	PointFFixed clipPt; // DAS-HIRES//----------------------------------------------------------------------------// Calc Scale												GJR090793// dist1/total distance. Always a fraction < 1. // Avoiding floats, do it to 14 bit precision. // PreShift numerator to get dist1/distTot << 14 to force 14 significant digits.//		Note: we would do upshift by 16, but scale ratio could be 1.0 which would//				overflow if shifted up by 16.//			  Well, we could try shifting by 15, but 1.0 << 15 would hit the sign bit.//			  Conclusion: we can only shift 1.0 up by 14 max.// Why do we want scale shifted? For two reasons. One is that the divide to//	make scale is guaranteed to be a fraction <= 1. So the max shift is obvious.//	Also, we want to keep as much precision as possible when doing the dist/tot scale calc.//	Secondly, we have no idea how large the pt.{x,y,z} diffs will be. We preshift the//	scale so that even small diffs will get scaled up into the intg part of the FFixed.// Since divide could be a "1", and there is a sign bit to avoid, can only shift 14 max.// Later, we will use this in S16.16 (FFixed) which implicitly reduces by >>16.// The preshift <<14 followed by implicit (FFixed) >>16 leaves us >>2.// We will correct that by preshifting the diff's by <<2 (its ok - they were a max of 22 bits)// Then we mult scale(<<14>>16) * diff(<<2), and add the result to base pt.// Note that we add (long)FFOver to get the top S32.0 integer portion of the FFixed mult.//----------------------------------------------------------------------------	distTot = dist1 - dist2;		num.l = dist1;	den.l = distTot;	scale = FFDiv(num, den);		// implicit <<16 due to decimal point in middle.			diff.l = pt2.h.l - pt1.h.l;	clipPt.h.l = FFMult(diff, scale).l + pt1.h.l;	diff.l = pt2.v.l - pt1.v.l;	clipPt.v.l = FFMult(diff, scale).l + pt1.v.l;	return(clipPt);	}		/* ABD TEXTURE */voidMakeTextureArray(V_Array *in, V_Array **out,Rect *r,Rect *real_rect,	// ABD MERGE-MEM	int use_real_world_size_h,	int use_real_world_size_v,	int hUnit,	int vUnit,	FFixed hPixels_per_unit,	FFixed vPixels_per_unit,	FFixed hTiles,	FFixed vTiles,	double meters_per_unit)	{	int j, n = in->ALength();	PointFFixed *i;	PointFFixed *o;//	Point mn, mx;	PointFFixed mn, mx;//	short dh, dv;	FFixed dh, dv;	long dx, dy;	V_Array *outp;		// ABD MERGE-MEM	// ABD MERGE-MEM [[[	// create the out array if it doesn't already exist, and save a local ptr to it	if (!out) DEBUGGER();			// big trouble here		if ((*out) == NULL)	{		*out = new(V_Array);							(*out)->cArray(0, sizeof(PointFFixed), 4);	}	outp = (*out); //jam 11-29-93 moved this line outside above brackets	// ABD MERGE-MEM ]]]	// see how wide the rect is in pixels (use the internal padded rect, not the "real" rect, which	// is used to compute real world sizes)	dx=(r->right-r->left)-1;	dy=(r->bottom-r->top)-1;		// make the texture points array the same length as the vertex points array	outp->SetLength(n);		// ABD MERGE-MEM	// and abuse them both	i = (PointFFixed *)in->Abuse();	o = (PointFFixed *)outp->Abuse();		// ABD MERGE-MEM	// copy the rounded vertex points into the texture points	for (j = 0; j < n; j++, i++, o++)		{		/*		o->h = FFRound(i->h);		o->v = FFRound(i->v);		*/		*o = *i;		}	// now compute the bounding box of the out (actually the rounded in) points so we can scale them//	mn.h = 32767; mx.h = -32738;//	mn.v = 32767; mx.v = -32768;	mn.h.l = 0x7FFFFFFF; mx.h.l = 0x80000000;	mn.v.l = 0x7FFFFFFF; mx.v.l = 0x80000000;	o = (PointFFixed *)outp->Abuse();		// ABD MERGE-MEM	for (j = 0; j < n; j++, o++)		{		if (o->h.l < mn.h.l) mn.h.l = o->h.l;		if (o->v.l < mn.v.l) mn.v.l = o->v.l;		if (o->h.l > mx.h.l) mx.h.l = o->h.l;		if (o->v.l > mx.v.l) mx.v.l = o->v.l;		}	// compute the height and width of the bounding box	dh.l = mx.h.l - mn.h.l;	dv.l = mx.v.l - mn.v.l;	// BUG FOUND BY DAS AND GJR 8/8/93 	if(dh.l<=0)dh.l=1;	if(dv.l<=0)dv.l=1;	// now scale all the texture points so that the texture rect is the same as the	// bounding box of the rounded in points (which are in the outp array)		// ABD MERGE-MEM	o = (PointFFixed *)outp->Abuse();		// ABD MERGE-MEM	for (j = 0; j < n; j++, o++)		{		o->h.l = o->h.l - mn.h.l;		o->h = FFDiv(o->h, dh);		o->h.l *= dx;		o->h.intg += r->left;		o->v.l = o->v.l - mn.v.l;		o->v = FFDiv(o->v, dv);				o->v.l *= dy;		/*		o->h = r->left+((o->h - mn.h) * dx / dh);		o->v = (o->v - mn.v) * dy / dv;		*/		}			//------------ calc the tiling values	{	PointFFixed *raw;	int i;		raw = (PointFFixed *)outp->Use();		// ABD MERGE-MEM		for ( i = 0 ; i < outp->ALength() ; i++ )		// ABD MERGE-MEM		{		FFixed f, f0, f1;					//------------------------------------------			// HORIZTONAL			if (use_real_world_size_h)			{			double surface_meters, texture_meters;			double size;			double texture_units;							// need to compute how many tiles based on the unit specified and the 				// real size of this surface				// compute how many meters is the surface feature//				surface_meters = (double)((double)dh) * meters_per_unit;				surface_meters = (double)(FixedToDbl(dh)) * meters_per_unit;								// compute how many units there are in this texture vertically				// e.g. texture is 200 pixels and 100 pixels per unit == 2 units				texture_units = ((double)(real_rect->right - real_rect->left)) / FixedToDbl(hPixels_per_unit);								size = GetSIUnit(hUnit);								texture_meters = texture_units * size;								// now we know the size of the texture in meters				// and the size of the surf in meters,				// so we can compute how many tiles by dividing				// (e.g. surface is 10 meters, texture is 1 meter, so need 10 tiles				if (texture_meters != 0.0) f1 = DblToFixed(surface_meters / texture_meters);				else f1 = DblToFixed(surface_meters);			}			else			{				f1 = hTiles;			}			raw[i].h = FFMult(raw[i].h,f1);			/*			f.intg = raw[i].h;			f.frac = 0;			f0 = FFMult(f, f1);			raw[i].h = FFRound(f0);			*/						//------------------------------------------			// VERTICAL			if (use_real_world_size_v)			{			double surface_meters, texture_meters;			double size;			double texture_units;							// need to compute how many tiles based on the unit specified and the 				// real size of this surface				// compute how many meters is the surface feature//				surface_meters = (double)((double)dv) * meters_per_unit;				surface_meters = (double)(FixedToDbl(dv)) * meters_per_unit;								// compute how many units there are in this texture vertically				// e.g. texture is 200 pixels and 100 pixels per unit == 2 units				texture_units = ((double)(real_rect->bottom - real_rect->top)) / FixedToDbl(vPixels_per_unit);								size = GetSIUnit(vUnit);								texture_meters = texture_units * size;								// now we know the size of the texture in meters				// and the size of the surf in meters,				// so we can compute how many tiles by dividing				// (e.g. surface is 10 meters, texture is 1 meter, so need 10 tiles				if (texture_meters)	f1 = DblToFixed(surface_meters / texture_meters);				else f1 = DblToFixed(surface_meters);			}			else			{				f1 = vTiles;	// just use the tiles specified			}			raw[i].v = FFMult(raw[i].v,f1);			/*			f.intg = raw[i].v;			f.frac = 0;			f0 = FFMult(f, f1);			raw[i].v = FFRound(f0);			*/		}		outp->Unuse();		// ABD MERGE-MEM	}		}//============================================================================// CalcClip////	Clip x,y,z according to dist1/(dist1-dist2)//	Assumes dist1,dist2 are < 30 bits, and pt1 is <30 bits//	Others claim pt1 and pt2 values are 22 bit values (22 + 10 = 32)//	Also assumed is that the dist1 and distTot is always positive.// GJR090393	rewrite to increase precision (was 9 bits or less, now is 14 bits exact)// DAS-HIRES 8/8/93 this code is completely Point3DLong based now.//----------------------------------------------------------------------------Point3DLongView::CalcClip(Point3DLong pt1, Point3DLong pt2, register long dist1, register long dist2)	{	long	distTot;	int		shiftNum;	int		shiftAvail;	FFixed	num;	FFixed	den;	FFixed	scale;	FFixed	diff;	Point3DLong clipPt; // DAS-HIRES//----------------------------------------------------------------------------// Calc Scale												GJR090793// dist1/total distance. Always a fraction < 1. // Avoiding floats, do it to 14 bit precision. // PreShift numerator to get dist1/distTot << 14 to force 14 significant digits.//		Note: we would do upshift by 16, but scale ratio could be 1.0 which would//				overflow if shifted up by 16.//			  Well, we could try shifting by 15, but 1.0 << 15 would hit the sign bit.//			  Conclusion: we can only shift 1.0 up by 14 max.// Why do we want scale shifted? For two reasons. One is that the divide to//	make scale is guaranteed to be a fraction <= 1. So the max shift is obvious.//	Also, we want to keep as much precision as possible when doing the dist/tot scale calc.//	Secondly, we have no idea how large the pt.{x,y,z} diffs will be. We preshift the//	scale so that even small diffs will get scaled up into the intg part of the FFixed.// Since divide could be a "1", and there is a sign bit to avoid, can only shift 14 max.// Later, we will use this in S16.16 (FFixed) which implicitly reduces by >>16.// The preshift <<14 followed by implicit (FFixed) >>16 leaves us >>2.// We will correct that by preshifting the diff's by <<2 (its ok - they were a max of 22 bits)// Then we mult scale(<<14>>16) * diff(<<2), and add the result to base pt.// Note that we add (long)FFOver to get the top S32.0 integer portion of the FFixed mult.//----------------------------------------------------------------------------	distTot = dist1 - dist2;	BIT_WIDTH(dist1, shiftNum);		// dist1 is the numerator, shiftNum:= (1..32)		shiftAvail = 31 - shiftNum;		// Amount we can shift Num up without hitting sign bit	if (shiftAvail >= 14)		{  // Then we have room to shift Numerator up by <<14		dist1 <<= 14;		}	else		{  // Else not enough room. Shift up Num as much as possible		   // and shift Den down the rest.		dist1   <<= shiftAvail;		distTot >>= 14 - shiftAvail;		// Hope we minimized the lost precision here		}		num.l = dist1;	den.l = distTot;	scale = FFDiv(num, den);		// implicit <<16 due to decimal point in middle.				diff.l = pt2.x - pt1.x;	diff.l <<= 2;					// Final correction: <<14,>>16,<<2	FFMult(diff, scale);	clipPt.x = FFOver + pt1.x;	diff.l = pt2.y - pt1.y;	diff.l <<= 2;					// Final correction: <<14,>>16,<<2	FFMult(diff, scale);	clipPt.y = FFOver + pt1.y;	diff.l = pt2.z - pt1.z;	diff.l <<= 2;					// Final correction: <<14,>>16,<<2	FFMult(diff, scale);	clipPt.z = FFOver + pt1.z;	#if 0	// old code	long distTot = dist1 - dist2;	int shift;	short scale;	long tmpL, diff; // DAS-HIRES	Point3DLong clipPt; // DAS-HIRES		if (dist1 >= 32*1024L)		{		BIT_WIDTH(dist1, shift);		shift -= 15;		dist1 >>= shift;		distTot >>= shift;		}	scale = (dist1 << 9) / distTot;		diff = pt2.x - pt1.x;	tmpL = (long)diff * scale;	clipPt.x = (tmpL >> 9) + pt1.x;	diff = pt2.y - pt1.y;	tmpL = (long)diff * scale;	clipPt.y = (tmpL >> 9) + pt1.y;	diff = pt2.z - pt1.z;	tmpL = (long)diff * scale;	clipPt.z = (tmpL >> 9) + pt1.z;#endif	return(clipPt);	}// ABD MERGE-TEXTURE 9/13/93 ]]]// MERGE-GOURAUD [[[FFixedView::CalcClip2DGouraud(FFixed sh1, FFixed sh2, register long dist1, register long dist2)	{	long	distTot;	int		shiftNum;	int		shiftAvail;	FFixed	num;	FFixed	den;	FFixed	scale;	FFixed	diff;	FFixed clipSh;	distTot = dist1 - dist2;		num.l = dist1;	den.l = distTot;	scale = FFDiv(num, den);		// implicit <<16 due to decimal point in middle.			diff.l = sh2.l - sh1.l;	clipSh.l = FFMult(diff, scale).l + sh1.l;	return(clipSh);	}// MERGE-GOURAUD ]]]