/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes: To Clean up containment.		General:		1) Find who contains me.		a) See if I am still in the same old one. (if not continue)		b) Keep going up containers till I find one I'm in.(eventuallu top poly)		c) Look in all the rooms contained in this container. (my new peers)		d) Look down these peers till I no longer am contained inside one.	2) Find who I contain.		a) Looking at only my new peers, look to see if anyone is inside of me.	 	Special Cases: (Groups)	 	1) Find who contains me.	 	a) See if everyone in the group is no longer in the old one.(if not continue)		b) Keep going up containers till I find group components are totally contained in one.		c) Look in all the rooms contained in this container. (my new peers)		d) Look down these peers till group components are no longer totally contained inside one.	2) Find who I contain.		a) Looking at only my new peers, look to see if anyone is totally inside a group member.	 	Special Cases: (Initial installment)	 	1) Find who contains me.	 	a) Find who a vector intersects (the mouse down point).		b) Check depth containment.	2) Find who I contain.		a) Looking at only my new peers, look to see if anyone is inside of me.	 General Note :: 		There might be some sort of volumetric test to determine who is 	'mostly' contained by another for groups.  I'm not sure of the 	validity of this.  We really have two types of groups.  Group 	constructs (like Furniture) and grouped ideas. (series of Rooms, 	Room layouts, things that aren't really 'nailed together') *------------------------------------------------------------------------------ * History:  * Platform: 	MACINTOSH 	X *				WINDOWS		 *------------------------------------------------------------------------------ */#include "VTypes.h"#include "CVPolyh.h"#include "CVConect.h"#include "CVObj.h"#include "CVDraw.h"#include "Geometry.h"#include "Misc.h"#include "CVLItem.h"#include "PolyDefs.h"#include "CVSrfDef.h"#include "CVSrfFet.h"#include "CVEnvirn.h"#include "Position.h"#include "CVWCntrl.h"#include "WalkDefs.h"#include "UndoBuf.h"#include "Surface.h"#include "PolyConv.h"#include "CVSlice.h"#include "Light.h" /* DWE */#include "VMDL.h" /* DWE */#include "Export.h" /* DWE */#include "ExpArray.h"#include "Clip.h"#include "VMath.h"#include "VGraphic.h"#include "VGUtil.h"#include <stdlib.h>#include <string.h>#include <math.h>void CAVPolyhedron::cPolyhedron(WalkDrawing *dwg) 	{				Polyhedron::cPolyhedron(dwg);	CAVlist = new(V_Array);	CAVlist->cArray(0, sizeof(CAVObject *), 4);		layer = NULL;		mode = OUT_POLY;	mark = NO_MARK;	cavsurf = NO_MARK;		editType = EDIT_POLYGON;		editState = 0;	}	voidCAVPolyhedron::dPolyhedron()	{	CAVObject 	**co;			int	length,i;				if(length = CAVlist->ALength())		{		co = (CAVObject**)CAVlist->Use();		for(i = 0; i < length; i++,co++)			{			if(NULL != (*co))				(*co)->dCAVObject();			}		CAVlist->Unuse();		}	CAVlist->dArray();				Polyhedron::dPolyhedron();	}	void CAVPolyhedron::Update() 	{	Polyhedron::Update();	CAVUpdate(TRUE);	}void CAVPolyhedron::UpdateMove() 	{	Polyhedron::UpdateMove();	CAVUpdate(OutOfDefinition());	}void CAVPolyhedron::CAVUpdate(int doOutline) 	{	CAVObject 	**co;	int			length,i;			if(length = CAVlist->ALength())		{		co = (CAVObject**)CAVlist->Use();		for(i = 0; i < length; i++,co++) 			{			if(NULL != (*co))				{				if(doOutline || ROTATE_OUT_VIEW == (*co)->editMode) /* dude */					(*co)->MakeOutl(posnPoints,OutOfDefinition(),defAxis,outline->ALength(),inflate,levels,point,base);				(*co)->Update(posnBoundMin,posnBoundMax);				(*co)->SetDirty(POLY_MUSSED);				}			}					CAVlist->Unuse();		}		}		/*=========================================================================*	void CAVPolyhedron::Display( CAVEnvironment *environment )*-------------------------------------------------------------------------*/void CAVPolyhedron::Display(CAVEnvironment *environment) 	{	DisplayInfo		displayInfo;	CAVPolyhedron	**ppoly;	CAVObject		*co;		int				layerFlag;		if((type & POLY_CLASS) != P_INTERNAL)		{		VPenMode(vPatCopy);				displayInfo.posnPoints = posnPoints;		displayInfo.layer = layer;		displayInfo.pieces = pieces;		displayInfo.piece = piece;		displayInfo.origin = posn->origin;		displayInfo.orientation = posn->orientation;		displayInfo.posnBoundMin = posnBoundMin;		displayInfo.posnBoundMax = posnBoundMax;		displayInfo.editType = editType;		displayInfo.environment = environment;#if (!VPLAYER)		layerFlag = layer->GetFlag();		displayInfo.state = (EDIT_LOCKED&GetEditState() ? FALSE : TRUE);		if(layerFlag&COLOR_LAYER)displayInfo.color = layer->color; 		else displayInfo.color = outsideColor;#endif //!VPLAYER		CAVlist->Get(environment->GetID(),&co);				if(EDIT_HIDDEN & GetEditState())			{			if(environment->RectInWorld(&(co->bounds)))				{ if(co->dirty)co->Scale(&displayInfo); }			}		else			{			if(POLY_GROUP != type)				co->Display(&displayInfo);				}		}				if(contents)		{		int	i,length;				length = contents->ALength();		ppoly = (CAVPolyhedron**)contents->Use();		for(i = 0; i < length; i++,ppoly++)			(*ppoly)->Display(environment);		contents->Unuse();		}			VSetPattern(vPatBlack);	}void CAVPolyhedron::Select(CAVEnvironment *environment) 	{	DisplayInfo	displayInfo;		CAVObject	*co;		int			layerFlag;		if( EDIT_NOTALLOWED&GetEditState()) return;			displayInfo.posnPoints = posnPoints;	displayInfo.origin = posn->origin;	displayInfo.orientation = posn->orientation;	displayInfo.posnBoundMin = posnBoundMin;	displayInfo.posnBoundMax = posnBoundMax;	displayInfo.editType = editType;	if(COLOR_LAYER&layer->flagState)displayInfo.color = layer->color; 	else displayInfo.color = outsideColor;		CAVlist->Get(environment->GetID(),&co);	co->Select(&displayInfo,mark);	}/*=========================================================================*	void CAVPolyhedron::Hilite(CAVEnvironment *environment,int state)*-------------------------------------------------------------------------*/void CAVPolyhedron::Hilite(CAVEnvironment *environment,int state) 	{	CAVObject	*co;			if((type & POLY_CLASS) == P_INTERNAL) return;	CAVlist->Get(environment->GetID(),&co);	co->Hilite(state);	}int CAVPolyhedron::GetEditMode(CAVEnvironment *environment)	{	CAVObject	*co;		CAVlist->Get(environment->GetID(),&co);			return(co->editMode);	}			CAVPolyhedron	* CAVPolyhedron::PointContained(CAVPolyhedron	*poly,CAVEnvironment *environment,PointLong cursor,V_Array	*notOnThisList) 	{	CAVPolyhedron	**ppoly,*couldBePoly,*foundPoly,*me;	CAVObject 		*co;	int				length,i;		if( poly == this ) return(NULL);	me = this;	if( 0 < notOnThisList->Find(&me))		return(NULL);		couldBePoly = foundPoly = NULL;				switch(type)		{		case POLY_ROOT: couldBePoly = this; break;		case POLY_GROUP:  break;		case POLY_MESH:		case POLY_INFLATE:			if(POLY_OUTSIDE == DepthContained(poly,environment->GetAxis())) 				return(NULL);							CAVlist->Get(environment->GetID(),&co);/* kill dude */						if(NO_MARK == co->Find(pieces,piece,&cursor,PARALLEL|ASKEW,6)) 				return(NULL);							if(POLY_GROUP == container->type && poly == container) 				return(NULL);						couldBePoly = this;			break;		}	if(contents)		{		if(length = contents->ALength())			{			ppoly = (CAVPolyhedron**)contents->Use();			for(i = 0; i < length; i++,ppoly++)				if(foundPoly = (*ppoly)->PointContained(poly,environment,cursor,notOnThisList)) break;			contents->Unuse();						if(foundPoly) 				couldBePoly = foundPoly;			}		}			return(couldBePoly);	}	intCAVPolyhedron::FindSurfaceNum(PointLong *p,CAVEnvironment *environment) 	{	CAVObject 	*co;	int 		whichSurf;		CAVlist->Get(environment->GetID(),&co);	if(POLY_GROUP == type || (EDIT_HIDDEN & GetEditState())) return(NO_MARK);	if(NO_MARK == (whichSurf = co->Find(pieces,piece,p,PERPINDICULAR,0)))		whichSurf = co->Find(pieces,piece,p,PARALLEL|ASKEW,0);	return(whichSurf);	}intCAVPolyhedron::FindEdge(PointLong *p,CAVEnvironment *environment) 	{	CAVObject 	*co;	int 		whichSurf;		CAVlist->Get(environment->GetID(),&co);	if(POLY_GROUP == type || (EDIT_HIDDEN & GetEditState())) 		return(NO_MARK);	whichSurf = co->Find(pieces,piece,p,PERPINDICULAR,0); 			return(whichSurf);	}	CAVPolyhedron * CAVPolyhedron::Find(PointLong *p,CAVEnvironment *environment,CAVPolyhedron *startPoly,int findMode) 	{	CAVObject 		*co;	CAVPolyhedron 	**ppoly,*fpoly,*lpoly;	int				i,length,rejectFlag;		fpoly = lpoly = NULL;		switch(type)		{		case POLY_ROOT:			fpoly = this;			mode = IN_POLY;			break;				case POLY_GROUP:			mode = IN_POLY; 			break;		case POLY_MESH:		case POLY_INFLATE:			CAVlist->Get(environment->GetID(),&co);					if(NO_MARK == co->Find(pieces,piece,p,PARALLEL|ASKEW,0))				mode = OUT_POLY; 			else				{ 				mark = environment->NormalizeView(defAxis);/* this is a hack */				fpoly = this; 				mode = IN_POLY; 				}			break;		default:			break;		}					if(contents && OUT_POLY != mode)		{		length = contents->ALength();		ppoly = (CAVPolyhedron**)contents->Use();		for(i = length - 1; i >= 0; i--)			if(lpoly = ppoly[i]->Find(p,environment,startPoly,findMode)) 				{ 				mode = OUT_POLY;				fpoly = lpoly; 				break; 				}		contents->Unuse();		}		switch(type)		{		case POLY_ROOT: 			mode = OUT_POLY; 			break;					case POLY_GROUP:			if(!fpoly)				mode = OUT_POLY;			else				{				if(this == fpoly->container)					{					fpoly->mode = OUT_POLY;					mode = IN_POLY;					fpoly = this;					}				} 			break;					case POLY_MESH:		case POLY_INFLATE:			if(IN_POLY == mode)				{				if((HIDE_LAYER|LOCK_LAYER)&layer->flagState)					rejectFlag = TRUE;				else					{					switch(findMode)						{						case FIND_HIDDEN: rejectFlag = (EDIT_HIDDEN&editState) ? FALSE : TRUE;break;						case FIND_LOCKED: rejectFlag = (EDIT_LOCKED&editState) ? FALSE : TRUE; break;						case FIND_NORMAL: rejectFlag = (EDIT_NOTALLOWED&editState) ? TRUE : FALSE; break;						case FIND_ALL: rejectFlag = FALSE; break;						}					}				if(rejectFlag)					{					mode = OUT_POLY;					fpoly = NULL;											}				}				break;		}						return(fpoly);	}int CAVPolyhedron::FindDetail(PointLong *p,PointFFixed *wPt,CAVEnvironment *environment) 	{	CAVPolyhedron 	**ppoly;	CAVObject 		*co;	Point3DFFixed	pt3D;	PointFFixed		pt1,pt2;	int				i,length;	short			tempMode,tempSurf,index;		tempMode = OUT_POLY;		switch(type)		{		case POLY_ROOT:			mark = cavsurf = NO_MARK;			break;				case POLY_GROUP:			mark = cavsurf = NO_MARK;			length = contents->ALength();			ppoly = (CAVPolyhedron**)contents->Use();			for(i = 0; i < length; i++,ppoly++)				if((*ppoly)->Find(p,environment,this,FIND_NORMAL))					{ tempMode = IN_POLY; break; }			contents->Unuse();			break;				case POLY_MESH:		case POLY_INFLATE:			if(EDIT_NOTALLOWED&GetEditState()) break;			CAVlist->Get(environment->GetID(),&co);						switch(tempMode = co->FindDetail(p,&mark,&tempSurf,inflate))				{				case OUT_POLY:				case IN_POLY:					mode = IN_POLY;					if(NO_MARK != (cavsurf = FindEdge(p,environment))) 						{						switch(co->editMode)							{							case IN_DEF_VIEW: SetMode(ON_POLY_SIDLINE);break;							case OUT_DEF_VIEW:							case ROTATE_OUT_VIEW:SetMode(ON_POLY_SIDLINE); break;														}						}					else						cavsurf = co->Find(pieces,piece,p,PARALLEL|ASKEW,0);										if(NO_MARK == cavsurf) tempMode = OUT_POLY;					else tempMode = mode;					break;									case ON_POLY_SIDLINE:				case ON_POLY_DEFLINE:									cavsurf = FindEdge(p,environment);										co->outline->Get(mark,&index);					posnPoints->Get(index,&pt3D);					pt1 = environment->MakeOutline(TO_CAD,pt3D);					length = co->outline->ALength();					co->outline->Get(nextIndex(mark,1,length),&index);					posnPoints->Get(index,&pt3D);					pt2 = environment->MakeOutline(TO_CAD,pt3D);					pt1 = FFPtToLine(*wPt,pt1,pt2);					wPt->h = FFAdd(pt1.h,wPt->h);					wPt->v = FFAdd(pt1.v,wPt->v);										mode = tempMode; 					break;										case ON_POLY_POINT: 					cavsurf = FindEdge(p,environment);					mode = tempMode; 					co->outline->Get(mark,&index);					posnPoints->Get(index,&pt3D);					*wPt = environment->MakeOutline(TO_CAD,pt3D);					break;					}						if(POLY_GROUP == container->type) 				mode = OUT_POLY;						break;		}								return(tempMode);	}	#if VRML_ANCHOR		// ABD PRO25 AUG95CAVPolyhedron * CAVPolyhedron::FindWithNoSideEffects(PointLong *p,CAVEnvironment *environment,CAVPolyhedron *startPoly,int findMode) {CAVObject 		*co;CAVPolyhedron 	**ppoly,*fpoly,*lpoly;int				i,length,rejectFlag;short mode, mark;		fpoly = lpoly = NULL;		switch(type)	{		case POLY_ROOT:			fpoly = this;			mode = IN_POLY;			break;				case POLY_GROUP:			mode = IN_POLY; 			break;		case POLY_MESH:		case POLY_INFLATE:			CAVlist->Get(environment->GetID(),&co);					if(NO_MARK == co->Find(pieces,piece,p,PARALLEL|ASKEW,0))				mode = OUT_POLY; 			else			{ 				fpoly = this; 				mode = IN_POLY; 			}			break;		default:			break;	}					if(contents && OUT_POLY != mode)	{		length = contents->ALength();		ppoly = (CAVPolyhedron**)contents->Use();		for(i = length - 1; i >= 0; i--)		{			if(lpoly = ppoly[i]->FindWithNoSideEffects(p,environment,startPoly,findMode)) 			{ 				mode = OUT_POLY;				fpoly = lpoly; 				break; 			}		}		contents->Unuse();	}		switch(type)	{		case POLY_ROOT: 			mode = OUT_POLY; 			break;					case POLY_GROUP:			if(!fpoly)				mode = OUT_POLY;			else			{				if(this == fpoly->container)				{					fpoly->mode = OUT_POLY;					mode = IN_POLY;					fpoly = this;				}			} 			break;					case POLY_MESH:		case POLY_INFLATE:			if(IN_POLY == mode)			{				if((HIDE_LAYER|LOCK_LAYER)&layer->flagState)					rejectFlag = TRUE;				else				{					switch(findMode)					{						case FIND_HIDDEN: rejectFlag = (EDIT_HIDDEN&editState) ? FALSE : TRUE;break;						case FIND_LOCKED: rejectFlag = (EDIT_LOCKED&editState) ? FALSE : TRUE; break;						case FIND_NORMAL: rejectFlag = (EDIT_NOTALLOWED&editState) ? TRUE : FALSE; break;						case FIND_ALL: rejectFlag = FALSE; break;					}				}				if(rejectFlag)				{					mode = OUT_POLY;					fpoly = NULL;										}			}				break;	}						return(fpoly);}#endif // VRML_ANCHORvoid CAVPolyhedron::RotatePolyhedron(Point anchor,FFixed angle,CAVEnvironment *environment) 	{	CAVObject *co;		CAVlist->Get(environment->GetID(),&co);	co->RotatePolyhedron(anchor,angle);	}	int CAVPolyhedron::BreakLine(Point p,FFixed angle,long modifiers,CAVEnvironment *environment) 	{	CAVObject *co;			CAVlist->Get(environment->GetID(),&co);			return co->BreakLine(p,mark,(ON_POLY_DEFLINE == mode) ? TRUE :FALSE);	}int CAVPolyhedron::ScalePoly(Point refPt,PointFFixed mult,long modifiers,CAVEnvironment *environment) 	{	CAVObject *co;		CAVlist->Get(environment->GetID(),&co);		return(co->ScalePolyhedronPoint(refPt,mult,modifiers));	}int CAVPolyhedron::SkewPoly(Point anchor,Point last,FFixed angle,long modifiers,CAVEnvironment *environment) 	{	CAVPolyhedron	**ppoly;	CAVObject *co;	FFixed	tangle;		int		i,length;	int		tmp,okay = TRUE;	Point 	tp,p;		CAVlist->Get(environment->GetID(),&co);		p.h = anchor.h - last.h; 	p.v = anchor.v - last.v;		if(OUT_DEF_VIEW == co->editMode)		{		if(ON_POLY_DEFLINE == mode)			okay = co->MovePolyhedronLine(p,angle,mark,inflate,modifiers);		else			{			p = PtZero;			co->MoveOutline(p);			}		}	else		{		okay = TRUE;		co->MoveOutline(p);		if(!(OPT_EDIT_MODE&modifiers) && contents)			{			length = contents->ALength();			ppoly = (CAVPolyhedron**)contents->Use();			for(i = 0; i < length; i++,ppoly++)				{				if(POLY_GROUP != (*ppoly)->container->type)					(*ppoly)->MovePoly(anchor,last,angle,modifiers,environment);				}			contents->Unuse();			}		}			return okay;	}			int CAVPolyhedron::MovePoly(Point anchor,Point last,FFixed angle,long modifiers,CAVEnvironment *environment) 	{	CAVObject *co;	FFixed	tangle;		int		tmp,okay = TRUE;	Point 	tp,p;		CAVlist->Get(environment->GetID(),&co);		if(OPT_EDIT_MODE&modifiers || IN_DEF_VIEW != co->editMode) 		tmp = EDIT_POLYGON; else tmp = editType;		switch(mode)		{		case IN_POLY:		case ON_POLY_SIDLINE:			p.h = anchor.h - last.h;			p.v = anchor.v - last.v;				co->MoveOutline(p);			if(!(OPT_EDIT_MODE&modifiers) && contents)				{				CAVPolyhedron	**ppoly;				int				i,length;								length = contents->ALength();				ppoly = (CAVPolyhedron**)contents->Use();				for(i = 0; i < length; i++,ppoly++)					{					if(POLY_GROUP != (*ppoly)->container->type)						(*ppoly)->MovePoly(anchor,last,angle,modifiers,environment);					}				contents->Unuse();				}			break;				case ON_POLY_POINT:			switch(tmp)				{				case EDIT_POLYGON:					okay = co->MovePolyhedronPoint(last,modifiers,mark);					break;						case EDIT_RECTANGLE:						angle = co->environment->GetAngle(posn->orientation,TO_WORLD);					co->MoveRectanglePoint(last,angle,mark);					break;						case EDIT_REGPOLYGON:					co->MoveRegPoint(last,angle,outline->ALength(),mark);					break;				}			break;						case ON_POLY_DEFLINE:			switch(tmp)				{				case EDIT_POLYGON:					p.h = anchor.h - last.h; 					p.v = anchor.v - last.v;					if(OUT_DEF_VIEW == co->editMode)						{						switch(defAxis)							{							case INFL_X: p.v = 0; break;							case INFL_Y: 								if(INFL_Z == environment->GetAxis()) p.h = 0;								else p.v = 0;								break;							case INFL_Z: p.h = 0; break;											}						}					okay = co->MovePolyhedronLine(p,angle,mark,inflate,modifiers);					break;						case EDIT_RECTANGLE:					angle = environment->GetAngle(posn->orientation,TO_WORLD);					co->MoveRectangleLine(last,angle,mark);					break;						case EDIT_REGPOLYGON:					co->MoveRegLine(last,outline->ALength(),mark);					break;				}			break;		}	return(okay);	}	int CAVPolyhedron::GetSide(CAVEnvironment *environment) 	{	int		upRight,side,editMode;		if(defAxis != environment->GetAxis()) editMode = OUT_DEF_VIEW;	else editMode = IN_DEF_VIEW;	if(GRTR == FFLogic(point,base)) upRight = TRUE; else upRight = FALSE;		switch(environment->NormalizeView(defAxis))		{		case topView:			if(upRight) side = TOP_SIDE; else side = BOTTOM_SIDE;			break;			 		case bottomView: 			if(upRight) side = BOTTOM_SIDE; else side = TOP_SIDE;			break;					default:			switch(inflate)				{				case INFL_ELLIPSE:				case INFL_CONVERGE:					switch(mark)						{						case 2:	side = TOP_SIDE; break;						default:side = BOTTOM_SIDE; break;						}					break;						default:					switch(mark)						{						case 0:	if(upRight) side = TOP_SIDE; else side = BOTTOM_SIDE; break;						case 2:	if(!upRight) side = TOP_SIDE; else side = BOTTOM_SIDE; break;						default: side = UNKNOWN_SIDE; break;						}					break;				}				break;		}	return(side);	}	int CAVPolyhedron::ModelSize(Point3DFFixed *modelMin,Point3DFFixed *modelMax) 	{		if(POLY_ROOT == type && contents)		{		CAVPolyhedron	**ppoly;		Point3D			tMin,tMax,mMin,mMax;		int				length,i;				if(!contents) return(FALSE);		if(!(length = contents->ALength())) return(FALSE);				mMin.x = FFRound(modelMin->x);		mMin.y = FFRound(modelMin->y);		mMin.z = FFRound(modelMin->z);		mMax.x = FFRound(modelMax->x);		mMax.y = FFRound(modelMax->y);		mMax.z = FFRound(modelMax->z);		ppoly = (CAVPolyhedron**)contents->Use();		tMin = (*ppoly)->posnBoundMin;		tMax = (*ppoly)->posnBoundMax;		ppoly++;		for(i = 1; i < length; i++,ppoly++)			{			tMin.x = min(tMin.x,(*ppoly)->posnBoundMin.x);			tMin.y = min(tMin.y,(*ppoly)->posnBoundMin.y);			tMin.z = min(tMin.z,(*ppoly)->posnBoundMin.z);			tMax.x = max(tMax.x,(*ppoly)->posnBoundMax.x);			tMax.y = max(tMax.y,(*ppoly)->posnBoundMax.y);			tMax.z = max(tMax.z,(*ppoly)->posnBoundMax.z);			}		contents->Unuse();				if( tMin.x < mMin.x || tMin.y < mMin.y || tMin.z < mMin.z 			|| tMax.x > mMax.x || tMax.y > mMax.y || tMax.z > mMax.z )			{			mMin.x = min(tMin.x,mMin.x);			mMin.y = min(tMin.y,mMin.y);			mMin.z = min(tMin.z,mMin.z);			mMax.x = max(tMax.x,mMax.x);			mMax.y = max(tMax.y,mMax.y);			mMax.z = max(tMax.z,mMax.z);						modelMin->x.intg = mMin.x;			modelMin->y.intg = mMin.y;			modelMin->z.intg = mMin.z;			modelMax->x.intg = mMax.x;			modelMax->y.intg = mMax.y;			modelMax->z.intg = mMax.z;			return(TRUE);			}		}	return(FALSE);	}		/*=========================================================================*	Point CAVPolyhedron::GetAnchor( CAVEnvironment *environment ,int theScaleAnchor)*-------------------------------------------------------------------------*/Point CAVPolyhedron::GetAnchor(CAVEnvironment *environment,int theScaleAnchor) 	{	CAVObject	*co;	CAVlist->Get(environment->GetID(),&co);	if(theScaleAnchor)editType=EDIT_POLYGON;	return(co->GetAnchor(editType,mark));	}	void CAVPolyhedron::SetMode(int newMode) 	{	 		mode = newMode;	}intCAVPolyhedron::GetMode() 	{ 	return(mode); 	}	void CAVPolyhedron::SetLayer(LayerItem *newLayer,int recursively) 	{ 	CAVPolyhedron	**ppoly;	int		i,length;		layer = newLayer; 		if((TRUE == recursively) || (type == POLY_GROUP))		{		if(contents)			{			length = contents->ALength();			ppoly = (CAVPolyhedron**)contents->Use();			for( i = 0; i < length; i++,ppoly++)				(*ppoly)->SetLayer(layer,recursively);			contents->Unuse();			}		}	}LayerItem * CAVPolyhedron::GetLayer()  	{ 	return(layer); 	}voidCAVPolyhedron::SetDirty(int state)  	{ 	CAVPolyhedron **ppoly;	CAVObject	*co;		SurfDef	**surfdefs;	CAVSurfFeature **pfeature;	int	l,llength,i,length;		if(POLY_ROOT != type)		CAVUpdate(POLY_DIRTY == state);			if(surfDef)		{		length = surfDef->ALength();		surfdefs = (SurfDef	**)surfDef->Use();		for(i = 0; i < length; i++,surfdefs++) 			{ 			if((*surfdefs) && (SDEF_FEATURE & (*surfdefs)->flags))				{				int k;				for(k =0; k < 3; k++)					{					if((*surfdefs)->features[k])						{												llength = (*surfdefs)->features[k]->ALength();						pfeature = (CAVSurfFeature **)(*surfdefs)->features[k]->Use();						for(l = 0; l < llength; l++,pfeature++)							(*pfeature)->SetDirty(state);						(*surfdefs)->features[k]->Unuse();						}					}				}			}		surfDef->Unuse();		}				if(contents)		{		length = contents->ALength();		ppoly = (CAVPolyhedron**)contents->Use();		for(i = 0; i < length; i++,ppoly++)			(*ppoly)->SetDirty(state);		contents->Unuse();		}	}void  CAVPolyhedron::Cut()	{	if(container)		container->Remove(this);	ShutDown();	dPolyhedron();	}void  CAVPolyhedron::DeleteLayer(LayerItem *delLayer)	{		CAVPolyhedron **ppoly;	int	i,length;		/* this is wrong */	/* first promote contained objects to the next higher level */	/* then kill this one */		if(contents)		{		V_Array		*tmpArray;		tmpArray = new(V_Array);		tmpArray->cArray(0,sizeof(CAVPolyhedron *),8);		contents->CopyArray(tmpArray);		length = tmpArray->ALength();		ppoly = (CAVPolyhedron **)tmpArray->Use();		for(i = 0; i < length; i++,ppoly++)			(*ppoly)->DeleteLayer(delLayer);		tmpArray->Unuse();		tmpArray->dArray();		}			if(delLayer == layer)  				{		PromoteContents();		Cut();			}	}void  CAVPolyhedron::HideLayer(LayerItem *hideLayer)	{		CAVPolyhedron **ppoly;	int	i,length,editFlag;#if (!VPLAYER)	if(layer == hideLayer)  				{		editFlag = hideLayer->GetFlag();		SetHidden(!(RENDER_LAYER&editFlag));		}#endif //!VPLAYER	if(contents)		{		length = contents->ALength();		ppoly = (CAVPolyhedron**)contents->Use();		for(i = 0; i < length; i++,ppoly++)			(*ppoly)->HideLayer(hideLayer);		contents->Unuse();		}	}		void CAVPolyhedron::AddCAVCtrl(CAVEnvironment *environment)	{	CAVPolyhedron 	**ppoly;	CAVSurfFeature **pfeature;	SurfDef			**surfdefs;	CAVObject		*newco;	int		i,length,id,l,llength;		newco = NULL;		if(contents)		{		length = contents->ALength();		ppoly = (CAVPolyhedron**)contents->Use();		for(i = 0; i < length; i++,ppoly++)			(*ppoly)->AddCAVCtrl(environment);		contents->Unuse();		}		if(POLY_ROOT != type)		{		id = environment->GetID();		while(id >= CAVlist->ALength()) 			CAVlist->Append(&newco);			CAVlist->Get(id,&newco);				if(newco)return;		newco = new(CAVObject);		newco->cCAVObject();		newco->SetEnvironment(environment);		CAVlist->Put(id,&newco);		newco->MakeOutl(posnPoints,OutOfDefinition(),defAxis,outline->ALength(),inflate,levels,point,base);		newco->Update(posnBoundMin,posnBoundMax);		if(surfDef)			{			length = surfDef->ALength();			surfdefs = (SurfDef	**)surfDef->Use();			for(i = 0; i < length; i++,surfdefs++) 				{ 				if((*surfdefs) && (SDEF_FEATURE & (*surfdefs)->flags))					{					int		k;					for(k = 0; k < 3; k++)						{						if((*surfdefs)->features[k])							{														llength = (*surfdefs)->features[k]->ALength();							pfeature = (CAVSurfFeature **)(*surfdefs)->features[k]->Use();							for(l = 0;l < llength; l++,pfeature++)								(*pfeature)->AddCAVCtrl(environment);							(*surfdefs)->features[k]->Unuse();							}						}					}				}			surfDef->Unuse();			}		}	}void CAVPolyhedron::RemoveCAVCtrl(CAVEnvironment *environment)	{	CAVPolyhedron 	**ppoly;	CAVSurfFeature **pfeature;	SurfDef			**surfdefs;	CAVObject		*co;	int				i,length,id,l,llength;									if(contents)		{		length = contents->ALength();		ppoly = (CAVPolyhedron**)contents->Use();		for(i = 0; i < length; i++,ppoly++)			(*ppoly)->RemoveCAVCtrl(environment);		contents->Unuse();		}		if(POLY_ROOT != type)		{		id = environment->GetID();		CAVlist->Get(id,&co);		co->dCAVObject();		co = NULL;		CAVlist->Put(id,&co);				if(surfDef)			{						length = surfDef->ALength();			surfdefs = (SurfDef	**)surfDef->Use();			for(i = 0; i < length; i++,surfdefs++) 				{ 				if((*surfdefs) && (SDEF_FEATURE & (*surfdefs)->flags))					{					int	k;					for( k = 0; k  < 3; k++)						{						if((*surfdefs)->features[k])							{							llength = (*surfdefs)->features[k]->ALength();							pfeature = (CAVSurfFeature **)(*surfdefs)->features[k]->Use();							for(l = 0; l < llength; l++,pfeature++)								(*pfeature)->RemoveCAVCtrl(environment);							(*surfdefs)->features[k]->Unuse();							}						}					}				}			surfDef->Unuse();			}					}	}/*=========================================================================*	void CAVPolyhedron::Promote(Polyhedron *newContainer)*-------------------------------------------------------------------------*/void CAVPolyhedron::Promote(Polyhedron *newContainer) 	{	container->Remove(this);	newContainer->Install(this);	}/*=========================================================================*	V_Array *CAVPolyhedron::GetPeers()*-------------------------------------------------------------------------*/V_Array *CAVPolyhedron::GetPeers() 	{		if(!container)return(NULL);	if(POLY_GROUP == container->type)		return(pcp(container)->GetPeers());	else		return(container->contents);	}/*=========================================================================*	int CAVPolyhedron::DepthContained( CAVPolyhedron *vol, int axis )*-------------------------------------------------------------------------*/intCAVPolyhedron::DepthContained(CAVPolyhedron *vol,int axis)	{		if(vol == this) return(POLY_OUTSIDE);		switch(axis)		{		case INFL_Z:			if(posnBoundMin.z <= vol->posnBoundMin.z && posnBoundMax.z >= vol->posnBoundMax.z)				return(POLY_INSIDE);				if(posnBoundMax.z <= vol->posnBoundMin.z || posnBoundMin.z >= vol->posnBoundMax.z)				return(POLY_OUTSIDE);			break;				case INFL_Y:			if(posnBoundMin.y <= vol->posnBoundMin.y && posnBoundMax.y >= vol->posnBoundMax.y)				return(POLY_INSIDE);				if(posnBoundMax.y <= vol->posnBoundMin.y || posnBoundMin.y >= vol->posnBoundMax.y)				return(POLY_OUTSIDE);			break;				case INFL_X:			if(posnBoundMin.x <= vol->posnBoundMin.x && posnBoundMax.x >= vol->posnBoundMax.x)				return(POLY_INSIDE);				if(posnBoundMax.x <= vol->posnBoundMin.x || posnBoundMin.x >= vol->posnBoundMax.x)				return(POLY_OUTSIDE);			break;		}	return(POLY_SHARED);	}/*=========================================================================*	int CAVPolyhedron::InSphere( Polyhedron *toPoly )*-------------------------------------------------------------------------*/intCAVPolyhedron::InSphere(Polyhedron *toPoly)	{		long distSquare, limitSquare, tmp;	short dx, dy, dz;	short limit;	short inSphere = FALSE;		if (toPoly->posnBoundMax.x > posnBoundMin.x && toPoly->posnBoundMin.x < posnBoundMax.x ||		toPoly->posnBoundMax.y > posnBoundMin.y && toPoly->posnBoundMin.y < posnBoundMax.y ||		toPoly->posnBoundMax.z > posnBoundMin.z && toPoly->posnBoundMin.z < posnBoundMax.z)		{		dx = toPoly->piece->posnBoundCenter.x - piece->posnBoundCenter.x;		dy = toPoly->piece->posnBoundCenter.y - piece->posnBoundCenter.y;		dz = toPoly->piece->posnBoundCenter.z - piece->posnBoundCenter.z;			distSquare =  (long)dx * dx;		tmp = (long)dy * dy;		distSquare += tmp;		tmp =  (long)dz * dz;		distSquare += tmp;				limit = toPoly->piece->posnBoundR + piece->posnBoundR;		limitSquare =  (long)limit * limit;		if (distSquare < limitSquare)			inSphere = TRUE;		}			return(inSphere);	}/*=========================================================================*	int CAVPolyhedron::PolyContained( CAVPolyhedron *poly )*	This tests to see if the volume passed in is IN,OUT,or SHARED by this polyhedron*-------------------------------------------------------------------------*/intCAVPolyhedron::PolyContained(CAVPolyhedron *poly)	{		CAVPolyhedron	**ppoly;	Point3DFFixed	*wp;	short			*pnt;	Surface			**surf;	Point3D			tmpPoint;	int				in,out,length,surfLength,pntLength,i,j;		if(poly == this) return(POLY_OUTSIDE);					out = FALSE;	in = FALSE;		switch(type)		{		case POLY_ROOT:		 	in = TRUE; 		 	break;				case POLY_GROUP: 			if(this == poly->container) return(POLY_OUTSIDE);			length = contents->ALength();			ppoly = (CAVPolyhedron**)contents->Use();			for(i = 0; i < length; i++,ppoly++)				{				switch((*ppoly)->PolyContained(poly))					{					case POLY_INSIDE:	in = TRUE;  out = FALSE; break;					case POLY_OUTSIDE:	in = FALSE; out = TRUE;  break;					case POLY_SHARED:	in = TRUE; out = TRUE;  break;/* the real question is who am i shared between */					}				if(in)break;							}			contents->Unuse();			break;					case POLY_INFLATE:			if(EQUL == FFLogic(point,base)) return(POLY_OUTSIDE);		case POLY_MESH:			switch(poly->type)				{				case POLY_ROOT: return(POLY_OUTSIDE); break;								case POLY_GROUP: 					length = poly->contents->ALength();					ppoly = (CAVPolyhedron**)poly->contents->Use();					for(i = 0; i < length; i++,ppoly++)						{						switch(PolyContained(*ppoly))							{							case POLY_INSIDE:	in = TRUE;  out = FALSE; break;							case POLY_OUTSIDE:	in = FALSE; out = TRUE;  break;							case POLY_SHARED:	in = TRUE; out = TRUE;  break;/* the real question is who am i shared between */							}						if(in)break;									}					poly->contents->Unuse();					break;									case POLY_MESH:								case POLY_INFLATE:					if(posnBoundMax.x < poly->posnBoundMin.x || posnBoundMin.x > poly->posnBoundMax.x ||						posnBoundMax.y < poly->posnBoundMin.y || posnBoundMin.y > poly->posnBoundMax.y ||						posnBoundMax.z < poly->posnBoundMin.z || posnBoundMin.z > poly->posnBoundMax.z)						{						out = TRUE;						}					else						{						wp = (Point3DFFixed	*)poly->posnPoints->Use();						surfLength = poly->piece->surfaces->ALength();						surf = (Surface**)poly->piece->surfaces->Use();						for(i = 0; i < surfLength; i++,surf++)							{							pntLength = (*surf)->points->ALength();							pnt = (short*)(*surf)->points->Use();														for(j = 0; j < pntLength; j++,pnt++)								{								tmpPoint.x = FFRound(wp[*pnt].x);								tmpPoint.y = FFRound(wp[*pnt].y);								tmpPoint.z = FFRound(wp[*pnt].z);								switch(Inside(tmpPoint))									{									case PNT_INSIDE: in = TRUE; break;									case PNT_OUTSIDE: out = TRUE; break;									default: break;									}								if(in&&out)break;								}							(*surf)->points->Unuse();							if (j != pntLength)break;							}						poly->posnPoints->Unuse();						poly->piece->surfaces->Unuse();						}					break;				}			break;		}			if(in&&out)return(POLY_SHARED);	if(!in&&out)return(POLY_OUTSIDE);	return(POLY_INSIDE);	}	/*=========================================================================*	CAVPolyhedron *CAVPolyhedron::FindNewContainer()*-------------------------------------------------------------------------*/CAVPolyhedron *CAVPolyhedron::FindNewContainer()  	{		CAVPolyhedron 	*newContainer,**pPoly;	V_Array			*peers;	int				i,length,found;		newContainer = NULL;		switch(type)		{		case POLY_ROOT:			return(this);			break;				case POLY_GROUP:			/* dude - not really a good idea */			length = contents->ALength();			pPoly = (CAVPolyhedron**)contents->Use();			for(i = 0;i < length; i++,pPoly++)				if(newContainer = (*pPoly)->FindNewContainer()) break;			contents->Unuse();			break;					case POLY_MESH:		case POLY_INFLATE:			newContainer = pcp(FindContainer());			if(!newContainer || newContainer == this) return(NULL);			if(POLY_ROOT != newContainer->type && POLY_OUTSIDE == newContainer->PolyContained(this))				{				newContainer = pcp(newContainer->FindContainer());				while(newContainer && POLY_ROOT != newContainer->type && POLY_INSIDE != newContainer->PolyContained(this))					newContainer = pcp(newContainer->FindContainer());				}						while(newContainer->contents)				{				peers = newContainer->contents;				length = peers->ALength();				pPoly = (CAVPolyhedron**)peers->Use();				for(i = 0;i < length; i++,pPoly++)					if(POLY_INSIDE == (*pPoly)->PolyContained(this))						{ newContainer = *pPoly; break; }				peers->Unuse();				if(i == length) break;				}			break;		}		return(newContainer);	}voidCAVPolyhedron::FindNewContents()  	{		Polyhedron		*gPoly;	CAVPolyhedron 	*iPoly,*newContainer,**pPoly;	V_Array			*peers;	int				i,length;		switch(type)		{		case POLY_ROOT:			return;			break;				case POLY_GROUP:			length = contents->ALength();			pPoly = (CAVPolyhedron**)contents->Use();			for(i = 0;i < length; i++,pPoly++)				(*pPoly)->FindNewContents();			contents->Unuse();			break;					case POLY_MESH:		case POLY_INFLATE:			if(contents)				{ 				length = contents->ALength();							for(i = length-1; i >= 0; i--)					{					contents->Get(i,&iPoly);					if(POLY_OUTSIDE == PolyContained(iPoly))						iPoly->Promote(container);					}								}			/* whose new inside of me ? */			if(peers = GetPeers())				{ 				length = peers->ALength();				//JAM 08FEB95 [[[				//this code checks each peer of THIS to determine if				//that peer should be contained by THIS.				//of course, it should not check if THIS is				//contained by the peer containing THIS, and in the old code,				//it was in the case where THIS was in a group that				//was in another group (so the peer containing THIS was				//two levels up).				//now the code finds the container of THIS that				//is at the level of the peers (i.e. goes up				//to the first thing below a non-group container)				//and uses that to see if the currently checked				//peer is a container of THIS				gPoly = this;				while((gPoly->container) && (POLY_GROUP == gPoly->container->type))					{                       gPoly = gPoly->container;                    }				for(i = length-1; i >= 0; i--)					{					peers->Get(i,&iPoly);					if(gPoly != iPoly)						{						if(iPoly && POLY_INSIDE == PolyContained(iPoly))							{                            iPoly->Promote(this);                            }                        }					#if 0 //old incorrect code					gPoly = iPoly;					while(gPoly && POLY_GROUP == gPoly->type)						{						if(gPoly == container)							gPoly = NULL;						else							gPoly = gPoly->container;						}					if(gPoly && POLY_INSIDE == PolyContained(iPoly))						iPoly->Promote(this);					#endif					}				//JAM 08FEB95 ]]]				}			break;		}	}	/*=========================================================================*	void CAVPolyhedron::ContainCleanUp()*-------------------------------------------------------------------------*/voidCAVPolyhedron::ContainCleanUp()  	{		V_Array			*holdArray;	CAVPolyhedron 	*newContainer,**pPoly,*iPoly;	int				sameContainer,i,length;	switch(type)		{		case POLY_ROOT: break;				case POLY_GROUP:			length = contents->ALength();			sameContainer = FALSE;			pPoly = (CAVPolyhedron**)contents->Use();			for(i = 0;i < length; i++,pPoly++)				{				if(container == (newContainer = (*pPoly)->FindNewContainer()))					break;				}			contents->Unuse();			/* dude - this is not exactly good */			if(container != newContainer && newContainer) 				Promote(newContainer);			pPoly = (CAVPolyhedron**)contents->Use();			for(i = 0;i < length; i++,pPoly++)				(*pPoly)->FindNewContents();			contents->Unuse();			break;					case POLY_INFLATE:		case POLY_MESH:						if(container) 				{				newContainer = FindNewContainer();				if(container != newContainer) Promote(newContainer);				FindNewContents();					}			break;		}					}/*=========================================================================*	void CAVPolyhedron::AutoConnect()*-------------------------------------------------------------------------*/voidCAVPolyhedron::AutoConnect()  	{#if VR	ClosePolys *cp;	Polyhedron *closePoly, **pPoly;	int mySurfCount, testSurfCount, polyLength;	int i, j, k;		if ((mySurfCount = SurfCount()) > 0)		{		//		//	Check For New Connection With Container.		//		if (container && (testSurfCount = container->SurfCount()) > 0)			{			for (i = 0; i < mySurfCount; i++)				{				for (j = 0; j < testSurfCount; j++)					{					if (ValidConnection(container, j, i))						Connect(i, container, j);					}				}			}		//		//	Check For New Connection With Peers.		//		if (piece->closePolys)			{			polyLength = piece->closePolys->ALength();			cp = (ClosePolys *)piece->closePolys->Use();			for (k = 0; k < polyLength; k++, cp++)				{				closePoly = (*cp).poly->polyhedron;				if ((testSurfCount = closePoly->SurfCount()) > 0)					{					for (i = 0; i < mySurfCount; i++)						{						for (j = 0; j < testSurfCount; j++)							{							if (ValidConnection(closePoly, j, i))								Connect(i, closePoly, j);							}						}					}				}			piece->closePolys->Unuse();			}		//		//	Check For New Connection With Contents.		//		if (contents)			{			polyLength = contents->ALength();			pPoly = (Polyhedron **)contents->Use();			for (k = 0; k < polyLength; k++, pPoly++)				{				if ((testSurfCount = (*pPoly)->SurfCount()) > 0)					{					for (i = 0; i < mySurfCount; i++)						{						for (j = 0; j < testSurfCount; j++)							{							if (ValidConnection((*pPoly), j, i))								Connect(i, (*pPoly), j);							}						}					}				}			contents->Unuse();			}		}#endif //VR	}	voidCAVPolyhedron::ConnectionCleanUp()  	{	V_Array			*connList[3];	CAVConnection	**conn;	int				i,j,length;		connList[0] = new(V_Array);	connList[0]->cArray(0,sizeof(CAVConnection	*),4);	connList[1] = new(V_Array);	connList[1]->cArray(0,sizeof(CAVConnection	*),4);	connList[2] = new(V_Array);	connList[2]->cArray(0,sizeof(CAVConnection	*),4);	GetConnectionList(connList);		for(j = 0; j < 3; j++)		{		length = connList[j]->ALength();		conn = (CAVConnection	**)connList[j]->Use();				for(i = 0; i < length; i++,conn++)			{			if(!(ValidConnection((*conn)->toPoly,(*conn)->toWall,(*conn)->fromWall)))				Disconnect((*conn)->fromWall,(*conn)->toPoly,(*conn)->toWall,-1);			else				{				Disconnect((*conn)->fromWall,(*conn)->toPoly,(*conn)->toWall,-1);				Connect((*conn)->fromWall,(*conn)->toPoly,(*conn)->toWall);				}			(*conn)->dCAVConnection();				}					connList[j]->Unuse();		connList[j]->dArray();		}	}#define NORMAL_SLOP		3FFixed DISTANCE_SLOP =  INITFIXXED(2,0);/*=========================================================================*	int CAVPolyhedron::ValidConnection(Polyhedron *toPoly,int toWall,int fromWall)*-------------------------------------------------------------------------*/intCAVPolyhedron::ValidConnection(Polyhedron *toPoly,int toWall,int fromWall)  	{		Polyhedron 		*aPoly,*bPoly;	Surface			*bSurface,*aSurface;	V_Array			*aList,*bList,*cList;	Point3DFFixed	surfNorm,comparePt,*bSurfPt,*aSurfPt;	PointFFixed		pt;	Clip			*tClip,*intClip,*resClip;	Point3D			aNorm,bNorm,rNorm;	FFixed			aA,aB,aC,aD,distance;	Point			p;	int				aWall,bWall,valid,aLength,bLength,i,j;	short			compareIndex,*aIndex,*bIndex,plane,cw,p0,p1,p2;			V_Array *testArray;			valid = FALSE;		/* first check if surface normals point at each other */	aPoly = this;	bPoly = toPoly;	aSurface = aPoly->FindSurface(fromWall);	bSurface = bPoly->FindSurface(toWall);		if (!aSurface || !bSurface)		return(FALSE);		aNorm = aSurface->posnNormal;	bNorm = bSurface->posnNormal;if (aPoly->container == bPoly->container){	rNorm.x = aNorm.x + bNorm.x;	rNorm.y = aNorm.y + bNorm.y;	rNorm.z = aNorm.z + bNorm.z;}else{	rNorm.x = aNorm.x - bNorm.x;	rNorm.y = aNorm.y - bNorm.y;	rNorm.z = aNorm.z - bNorm.z;}		if( NORMAL_SLOP < abs(rNorm.x) ||  NORMAL_SLOP < abs(rNorm.y) ||  NORMAL_SLOP < abs(rNorm.z) )		return(FALSE);			/* second check if there in each others bounding sphere */	if(!InSphere(toPoly)) 		return(FALSE);			/* third check distance between planes */	aLength = aSurface->points->ALength();	aIndex =(short*)aSurface->points->Use();	aSurfPt = (Point3DFFixed*)aPoly->posnPoints->Use();	/* get three distinct points */	p0 = 0;	p1 = aLength+2 >> 2;	p2 = aLength+1 >> 1;	PlaneEquation(aSurfPt[aIndex[p0]],aSurfPt[aIndex[p1]],aSurfPt[aIndex[p2]],&aA,&aB,&aC,&aD);	aPoly->posnPoints->Unuse();	aSurface->points->Unuse();	 	bSurface->points->Get(0,&compareIndex);	bPoly->posnPoints->Get(compareIndex,&comparePt);		distance = DistanceToPlane(comparePt,aA,aB,aC,aD);	if( LESS == FFLogic(distance,FFZero)) distance = FFSub(FFZero,distance);	if( LESS == FFLogic(DISTANCE_SLOP,distance))		return(FALSE);		rNorm.x = abs(aNorm.x);	rNorm.y = abs(aNorm.y);	rNorm.z = abs(aNorm.z);		if( rNorm.x >= rNorm.y && rNorm.x >= rNorm.z )		{ plane = INFL_X; }	else if( rNorm.y >= rNorm.x && rNorm.y >= rNorm.z )		{ plane = INFL_Y; }	else 		{ plane = INFL_Z; } 		/* Clipping A to B */	 	tClip = new(Clip);	tClip->cClip();	for( j =0; j < 2; j++)		{		if( 0 == j)			{			aLength = aSurface->points->ALength();			aIndex = (short*)aSurface->points->Use();			aSurfPt = (Point3DFFixed*)aPoly->posnPoints->Use();			aList = new(V_Array);			aList->cArray(0,sizeof(Point),4);			rNorm = aNorm;			cList = aList;			}		else			{			aLength = bSurface->points->ALength();			aIndex = (short*)bSurface->points->Use();			aSurfPt = (Point3DFFixed*)bPoly->posnPoints->Use();			bList = new(V_Array);			bList->cArray(0,sizeof(Point),4);			rNorm = bNorm;			cList = bList;			}								for( i = 0; i < aLength; i++,aIndex++)			{			switch(plane)				{				case INFL_X:					p.h = FFRound(aSurfPt[*aIndex].y);					p.v = FFRound(aSurfPt[*aIndex].z);						break;								case INFL_Y:					p.h = FFRound(aSurfPt[*aIndex].z);					p.v = FFRound(aSurfPt[*aIndex].x);						break;								case INFL_Z:					p.h = FFRound(aSurfPt[*aIndex].x);					p.v = FFRound(aSurfPt[*aIndex].y);						break;				}						cList->Append(&p);			}				cw = FALSE;		switch(plane)			{			case INFL_X: if(0 < rNorm.x) cw = TRUE; break;			case INFL_Y: if(0 < rNorm.y) cw = TRUE; break;			case INFL_Z: if(0 < rNorm.z) cw = TRUE; break;			}				if( 0 == j)			{			aSurface->points->Unuse();			aPoly->posnPoints->Unuse();	/*		intClip = tClip->ClipPoly(aList,cw);*/			testArray = Ident(aList,cw);			intClip = tClip->ClipClip(testArray);			}		else			{			bSurface->points->Unuse();			bPoly->posnPoints->Unuse();			/* resClip = intClip->ClipPoly(bList,cw);*/			testArray = Ident(bList,cw);			if (intClip) 	// BILBIL - stops some crashes - 2/07/94				resClip = intClip->ClipClip(testArray);			else            	resClip = NULL;			}		}		if(resClip) valid = TRUE;	else valid = FALSE;		tClip->dClip();	if(intClip) intClip->dClip();	if(resClip) resClip->dClip();	aList->dArray();	bList->dArray();	return(valid);	}voidCAVPolyhedron::SelectRect(V_Array **selectedList,Rect *r,Polyhedron **level,CAVEnvironment *environment,int findMode)  	{		CAVPolyhedron **ppoly,*me;	CAVObject	*co;	Rect		bounds,tr,pr;	int			found;		me = this;	found = FALSE;	tr = *r;		if(POLY_ROOT != type)		{			CAVlist->Get(environment->GetID(),&co);		bounds = co->bounds;		if(!((HIDE_LAYER|LOCK_LAYER)&layer->flagState) && POLY_GROUP != container->type 			&& RectInRect(bounds,tr)) 			{			switch(findMode)				{				case FIND_HIDDEN: found = EDIT_HIDDEN&editState ? TRUE : FALSE;break;				case FIND_LOCKED: found = EDIT_LOCKED&editState ? TRUE : FALSE;break;				default: found =  EDIT_NOTALLOWED&editState ? FALSE : TRUE; break;				}			if(found)				{				if(NULL == *level)*level = container;				if(*level == container)(*selectedList)->Append(&me);					return;				}			}		if(tr.left > bounds.right || tr.right < bounds.left 			|| tr.top < bounds.bottom || tr.bottom > bounds.top) 			return;			}			/* if this guy is not in the selection rect and doesnt contain it, bail out */	if(contents && NULL == *level)		{		int			i,length;		length = contents->ALength();		ppoly = (CAVPolyhedron**)contents->Use();		for(i = 0; i < length; i++,ppoly++)			(*ppoly)->SelectRect(selectedList,r,level,environment,findMode);		contents->Unuse();		}	}intCAVPolyhedron::OutlineMark(CAVEnvironment *environment)  	{		int			worldMark;			switch(environment->GetView())		{		case frontView:				case bottomView:		case leftView:			if(ON_POLY_POINT == mode)				worldMark = outline->ALength() - 1 - mark;			else				if(0 > (worldMark = outline->ALength() - mark - 2))					worldMark = outline->ALength() - 1;			break;					default:			worldMark = mark;		}		return(worldMark);	}intCAVPolyhedron::SurfMark(CAVEnvironment *environment)  	{		return(cavsurf);	}	intCAVPolyhedron::GetEditState()  	{	int result;		result = 0;	if(POLY_ROOT == type) result = EDIT_NOTALLOWED;	if (layer != NULL)    	{		if(HIDE_LAYER&layer->flagState) result |= EDIT_HIDDEN;		if(LOCK_LAYER&layer->flagState) result |= EDIT_LOCKED;    	}	result |= editState;	return(result);	}	voidCAVPolyhedron::SetEditState(int state)  	{		CAVPolyhedron	**pPoly;	int				i,length;	switch(type)		{		case POLY_ROOT:			break;		case POLY_GROUP:			if(contents)				{				length = contents->ALength();				pPoly = (CAVPolyhedron**)contents->Use();				for(i = 0; i < length; i++,pPoly++)					(*pPoly)->SetEditState(state);				contents->Unuse();				}		case POLY_INFLATE:		case POLY_MESH:			editState = state;			break;		}	}	voidCAVPolyhedron::ResetEditState(int state,int walkState)  	{		CAVPolyhedron	**ppoly;	int				i,length,layerFlag;			if(POLY_ROOT != type)		{#if (!VPLAYER)		layerFlag = layer->GetFlag();		if(walkState)/* WALK HIDDEN */			{ 			if(RENDER_LAYER&layerFlag)				SetHidden(FALSE);			} 		else			{			editState &= ~state;			/* This is only if you want to keep previously hidden objects hidden */			/* if(HIDE_LAYER&layerFlag)editState|=EDIT_HIDDEN; */			}#endif //!VPLAYER		}			if(contents)		{		length = contents->ALength();		ppoly = (CAVPolyhedron**)contents->Use();		for(i = 0; i < length; i++,ppoly++)			(*ppoly)->ResetEditState(state,walkState);		contents->Unuse();		}		}intCAVPolyhedron::IO_ReadExtra(V_Buffer *buf, long chunkID)	{	int layerState;	short l;	short  bit;	int found;	int err = 0;		switch (chunkID)		{		case IFF_LOCK:			err = buf->IOType(&bit, IO_SHORT);#if VWT// DAS-VR 9/6/93			if (!err && 0x01&bit)  editState|=EDIT_LOCKED;#endif			break;		case IFF_LNUM:			err = buf->IOType(&l, IO_SHORT);#if (!VPLAYER)			// jca 13MAY94 added in a check-- the var 'found' -- for			// whether we successfully found the layer.  Sometimes            // we don't find it...			if (!err)				found = pwc(drawing->control)->layerlist->Get(l, &layer);			if (found == VARY_SUCCESS)				{				layerState = layer->GetFlag();				if(!(layerState&RENDER_LAYER))					SetHidden(TRUE);				}			else				layer = NULL;  // jca 13MAY94 if we couldn't find the layer, make sure it isn't bogus.			// else, the layer we were looking for is not defined.  Oops.#endif //!VPLAYER			break;		case IFF_ELGT:			err = lights->IO_ELGT(buf);			break;		case IFF_ESLC:#if (!VPLAYER)			err = IO_ESLC(buf);#endif //!VPLAYER			break;		default:			err = Polyhedron::IO_ReadExtra(buf,chunkID);			break;		}	return(err);	}intCAVPolyhedron::IO_WriteFirst(V_Buffer *buf)	{	short l;	short bit;	int err = 0;	if (type != POLY_ROOT) 		{		bit = (editState&EDIT_LOCKED) ? 0x01 : 0x00;		buf->OpenChunkW(IFF_LOCK);		err = buf->IOType(&bit, IO_SHORT);		buf->CloseChunk();		}	if (type != POLY_ROOT) 		{		l = layer->layerID;		buf->OpenChunkW(IFF_LNUM);		err = buf->IOType(&l, IO_SHORT);		buf->CloseChunk();		}	if (!err) Polyhedron::IO_WriteFirst(buf);	return(err);	}	intCAVPolyhedron::IO_WriteLast(V_Buffer *buf)	{	int err = 0;	err = Polyhedron::IO_WriteLast(buf);	if (type != POLY_GROUP && lights != NULL && !err)		{		buf->OpenChunkW(IFF_ELGT);		err = lights->IO_ELGT(buf);		buf->CloseChunk();		}	if (type != POLY_ROOT && type != POLY_GROUP && slices != NULL && !err)		{		buf->OpenChunkW(IFF_ESLC);		err = IO_ESLC(buf);		buf->CloseChunk();		}	return(err);	}intCAVPolyhedron::IO_ESLC(V_Buffer *buf)	{	short nSlices, i;	Slice **slice, *slic;	int err = 0;	if (buf->IODirection() == DATA_IN)		{		err = buf->IOType(&nSlices, IO_SHORT);				for (i = 0; i < nSlices && !err; i++)			{			if (i < slices->ALength())				{				slices->Get(i, &slic);				err = pcs(slic)->IO_ESLC(buf);				}			}		}	else		{		nSlices = slices->ALength();		err = buf->IOType(&nSlices, IO_SHORT);		slice = (Slice **)slices->Use();		for (i = 0; i < nSlices && !err; i++)			err = pcs(*slice++)->IO_ESLC(buf);		slices->Unuse();		}	return(err);	}Slice *CAVPolyhedron::NewSlice() { return(new(CAVSlice)); }SurfDef *CAVPolyhedron::NewSurfDef() { return(new(CAVSurfDef)); }Polyhedron *CAVPolyhedron::NewPolyhedron() { return(new(CAVPolyhedron)); }	intCAVPolyhedron::OutOfDefinition()	{	int	outOfView = FALSE;		if(POLY_GROUP == type) return(TRUE);	if(POLY_MESH == type) return(TRUE);		switch(defAxis)		{		case INFL_X:			if(!FFZero(posn->orientation.roll) || !FFZero(posn->orientation.yaw))				outOfView = TRUE;			break;				case INFL_Y:			if(!FFZero(posn->orientation.pitch) || !FFZero(posn->orientation.yaw))				outOfView = TRUE;			break;				case INFL_Z:			if(!FFZero(posn->orientation.roll) || !FFZero(posn->orientation.pitch))				outOfView = TRUE;			break;		}	return(outOfView);	}intCAVPolyhedron::ShutDown()	{	CAVPolyhedron	**pPoly;	int	i,length;		if(contents)		{		length = contents->ALength();		pPoly = (CAVPolyhedron**)contents->Use();		for(i = 0; i < length; i++,pPoly++)			(*pPoly)->ShutDown();		contents->Unuse();		}			drawing->control->EditPolyhedron(this,msgDestroy);		return(TRUE);	}int CAVPolyhedron::NewMoveEnds(Point3DFFixed topSkew,Point3DFFixed bottomSkew) 	{	Point3DFFixed	origin;	PointFFixed		skewTop,skewBottom;	FFixed			topHeight,bottomHeight;		origin = Pt3DFFZero;	topSkew = posn->UnTransform3D(topSkew);	bottomSkew = posn->UnTransform3D(bottomSkew);	origin = posn->UnTransform3D(origin);	topSkew = FF3DSub(topSkew,origin);	bottomSkew = FF3DSub(bottomSkew,origin);	skewTop = OutlinePoint(topSkew,&topHeight);	skewBottom = OutlinePoint(bottomSkew,&bottomHeight);	SkewEnds(skewTop,skewBottom);	MoveEnds(topHeight,bottomHeight);		return(0);	}int CAVPolyhedron::NewMoveEndsAbs(Point3DFFixed *topSkew,Point3DFFixed *bottomSkew) 	{	PointFFixed		skewPointOffset,skewBaseOffset;	Point3DFFixed	origin,newPtSkew,newBaseSkew;	FFixed			pointOffset,baseOffset;	int	flag = FALSE;		newPtSkew = *topSkew;	newBaseSkew = *bottomSkew;	*topSkew = OutlToWorld(pointSkew,point);	*bottomSkew = OutlToWorld(baseSkew,base);	*topSkew = posn->Transform3D(*topSkew);	*bottomSkew = posn->Transform3D(*bottomSkew);	newPtSkew = posn->UnTransform3D(newPtSkew);	newBaseSkew = posn->UnTransform3D(newBaseSkew);	skewPointOffset = OutlinePoint(newPtSkew,&pointOffset);	skewBaseOffset = OutlinePoint(newBaseSkew,&baseOffset);		pointOffset = FFSub(pointOffset, point);	baseOffset = FFSub(baseOffset, base);	MoveEnds(pointOffset,baseOffset);		return(0);	}/*=========================================================================*	int CAVPolyhedron::NewMoveWall( Point3DFFixed offset,int whichWall)*-------------------------------------------------------------------------*/int CAVPolyhedron::NewMoveWall(Point3DFFixed offset,int whichWall) 	{	PointFFixed		outlinePt,coord1,coord2;	Point3DFFixed	origin;	FFixed	height,swap;	double	x,y,radius,angl;	int 	newWall,next,length;			offset = posn->UnTransform3D(offset);	origin = posn->UnTransform3D(Pt3DFFZero);	offset = FF3DSub(offset,origin);	outlinePt = OutlinePoint(offset,&height);	switch(editType)		{		case EDIT_POLYGON:			MoveLine(whichWall,outlinePt);			break;					case EDIT_REGPOLYGON:	length = outline->ALength();	next = nextIndex(whichWall,1,length);	outline->Get(whichWall,&coord1);	outline->Get(next,&coord2);	coord2.h = FFAdd(FFShift(FFSub(coord1.h,coord2.h),-1),coord2.h);	coord2.v = FFAdd(FFShift(FFSub(coord1.v,coord2.v),-1),coord2.v);	coord2.h = FFAdd(outlinePt.h,coord2.h);	coord2.v = FFAdd(outlinePt.v,coord2.v);	x = FixedToDbl(coord2.h);	y = FixedToDbl(coord2.v);	radius = sqrt(x*x+y*y);		x = FixedToDbl(coord1.h);	y = FixedToDbl(coord1.v);    if(x==0 && y==0)angl=0;	else	angl = atan2(y,x);	coord1.h=DblToFixed(radius*cos(angl));	coord1.v=DblToFixed(radius*sin(angl));	outline->Put(whichWall,&coord1);	outlinePt = PtFFZero;				newWall = NewOutline(outlinePt,whichWall);	whichWall = 0;			Update();			break;					case EDIT_RECTANGLE:			if(INFL_Y != defAxis)				{ if(0 == whichWall || 2 == whichWall) outlinePt.v = FFZero; else outlinePt.h = FFZero; }			else				{ if(0 == whichWall || 2 == whichWall) outlinePt.h = FFZero; else outlinePt.v = FFZero; }			newWall = NewOutline(outlinePt,whichWall);			if(newWall!=whichWall)whichWall = prevIndex(newWall,1,outline->ALength());			Update();			break;		}			return(whichWall);	}/*=========================================================================*	int CAVPolyhedron::NewAddPoint(Point3DFFixed offset,int whichCorner)*-------------------------------------------------------------------------*/int CAVPolyhedron::NewAddPoint(Point3DFFixed offset,int whichCorner) 	{	PointFFixed		outlinePt;	FFixed			height;		offset = posn->UnTransform3D(offset);	outlinePt = OutlinePoint(offset,&height);	switch(editType)		{		case EDIT_RECTANGLE:			SetEditType(EDIT_POLYGON);					case EDIT_POLYGON:			AddPoint(whichCorner + 1,outlinePt);			break;								case EDIT_REGPOLYGON:			/* outline->Insert(whichCorner,&outlinePt);*/			AddPoint(whichCorner + 1,outlinePt);			whichCorner = NewOutline(PtFFZero,whichCorner);			Update();			break;		}			return(whichCorner);	}/*=========================================================================*	int CAVPolyhedron::NewRemovePoint(Point3DFFixed *oldPoint,int whichCorner)*-------------------------------------------------------------------------*/int CAVPolyhedron::NewRemovePoint(Point3DFFixed *oldPoint,int whichCorner) 	{	PointFFixed		oldOutlinePt;			if(3 > (outline->ALength()-1)) return(-1);		switch(editType)		{		case EDIT_RECTANGLE:			SetEditType(EDIT_POLYGON);		case EDIT_POLYGON:			*oldPoint = Pt3DFFZero;			outline->Get(whichCorner,&oldOutlinePt);			switch(defAxis)				{				case INFL_X: 					oldPoint->y = oldOutlinePt.h;					oldPoint->z = oldOutlinePt.v; 					oldPoint->x = FFZero; 					break;				case INFL_Y: 					oldPoint->z = oldOutlinePt.h;					oldPoint->x = oldOutlinePt.v; 					oldPoint->y = FFZero; 					break;				case INFL_Z: 					oldPoint->x = oldOutlinePt.h;					oldPoint->y = oldOutlinePt.v; 					oldPoint->z = FFZero; 					break;				}			*oldPoint = posn->Transform3D(*oldPoint);			RemovePoint(whichCorner);			break;					case EDIT_REGPOLYGON:			RemovePoint(whichCorner);			whichCorner = NewOutline(PtFFZero,0);			Update();			break;		}			return(whichCorner);	}void CAVPolyhedron::OriginMove(Point3DFFixed offset) 	{	Point3DFFixed	origin = Pt3DFFZero;	PointFFixed		*outl,outlinePt;	FFixed			height;	int				i,length;		Move(offset);	offset = posn->UnTransform3D(offset);	origin = posn->UnTransform3D(origin);	offset = FF3DSub(offset,origin);	outlinePt = OutlinePoint(offset,&height);		length = outline->ALength();	outl = (PointFFixed*)outline->Use();	for(i = 0; i < length; i++,outl++)		*outl = FF2DSub(*outl,outlinePt);		outline->Unuse();		height = FFNeg(height);	MoveEnds(height,height);		Update();	}int CAVPolyhedron::NewMoveCorner(Point3DFFixed offset,int whichCorner) 	{	PointFFixed		outlinePt,prevPt,nextPt,actualPt;	Point3DFFixed	origin = Pt3DFFZero;	Angle3DFFixed	rotateAngle = Ang3DFFZero;	FFixed			height,swap,angle;	int				next,prev,swapLoc;	double			ang1,ang2,test;		offset = posn->UnTransform3D(offset);	origin = posn->UnTransform3D(origin);	offset = FF3DSub(offset,origin);	outlinePt = OutlinePoint(offset,&height);	if(!FFZero(height))		{		height = FFNeg(height);		MoveEnds(height,height);		}			switch(editType)		{		case EDIT_POLYGON:			MovePoint(whichCorner,outlinePt);			break;					case EDIT_REGPOLYGON:								whichCorner = NewOutline(outlinePt,whichCorner);			Update();			break;					case EDIT_RECTANGLE:			whichCorner = NewOutline(outlinePt,whichCorner);			Update();			break;		}			return(whichCorner);	}/*=========================================================================*	int CAVPolyhedron::NewMove(Point3DFFixed	offset)*-------------------------------------------------------------------------*/int CAVPolyhedron::NewMove(Point3DFFixed	offset) 	{	Point3DFFixed	origin = Pt3DFFZero;		if(container)		{		offset = container->posn->UnTransform3D(offset);		origin = container->posn->UnTransform3D(origin);		offset = FF3DSub(offset,origin);		}			Move(offset);		return(0);	}/*=========================================================================*	int CAVPolyhedron::GetConnectionList(V_Array *list[3])*-------------------------------------------------------------------------*/int CAVPolyhedron::GetConnectionList(V_Array *list[3]) 	{	Polyhedron		*toPoly;	CAVConnection	*conn;	Connection		connection;	SurfDef			**sDefs;	int				i,length,c,clength,toSurf,j;		if(!surfDef) return(-1);		length = surfDef->ALength();	sDefs = (SurfDef**)surfDef->Use();	for(i = 0; i < length; i++,sDefs++)		{		for(j = 0; j < 3; j++)			{			if((*sDefs)&&(*sDefs)->connections[j] && (clength = (*sDefs)->connections[j]->ALength()))				{				for(c = 0; c < clength; c++)					{					(*sDefs)->connections[j]->Get(c,&connection);					toSurf = connection.poly->surfDef->Find(&connection.surf);					conn = new(CAVConnection);					conn->cCAVConnection(connection.poly,toSurf,i);					list[j]->Append(&conn);					}				}			}		}			surfDef->Unuse();		return(0);	}/*=========================================================================*	int CAVPolyhedron::SetConnectionList(V_Array *list[3])*-------------------------------------------------------------------------*/int CAVPolyhedron::SetConnectionList(V_Array *list[3]) 	{	CAVConnection	**conn;	int	i,length,j;		for(j = 0; j < 3; j++)		{		length = list[j]->ALength();		conn = (CAVConnection**)list[j]->Use();		for(i = 0; i < length; i++,conn++)			Connect((*conn)->fromWall,(*conn)->toPoly,(*conn)->toWall);		list[j]->Unuse();		}			return(0);	}	int CAVPolyhedron::NewCreate() 	{	SetDirty(POLY_MUSSED);		return(0);	}int CAVPolyhedron::NewDestroy() 	{	container->Remove(this);	ShutDown();	SetMode(OUT_POLY);	return(0);	}int CAVPolyhedron::NewOutline(PointFFixed outlinePt,int whichCorner) 	{	PointFFixed		prevPt,nextPt,coord;	int		next,prev,swapLoc,length;		switch(editType)		{		case EDIT_POLYGON: break;					case EDIT_REGPOLYGON:			outline->Get(whichCorner, &coord);			outlinePt = FF2DAdd(coord,outlinePt);			BuildRegular(&outline,PtFFZero,outlinePt,outline->ALength());			whichCorner = 0;			break;					case EDIT_RECTANGLE:			length = outline->ALength();			next = nextIndex(whichCorner,1,length);			prev = prevIndex(whichCorner,1,length);			prevPt = nextPt = outlinePt;			nextPt.h = prevPt.v = FFZero;			if(INFL_Y != defAxis)				{				if(0 == whichCorner || 2 == whichCorner) 					{ swapLoc = prev; prev = next; next = swapLoc; }				}			else				{				if(1 == whichCorner || 3 == whichCorner) 					{ swapLoc = prev; prev = next; next = swapLoc; }				}						outline->Get(whichCorner, &coord);			coord.h = FFAdd(coord.h, outlinePt.h);			coord.v = FFAdd(coord.v, outlinePt.v);			outline->Put(whichCorner, &coord);			outline->Get(next, &coord);			coord.h = FFAdd(coord.h, nextPt.h);			coord.v = FFAdd(coord.v, nextPt.v);			outline->Put(next, &coord);			outline->Get(prev, &coord);			coord.h = FFAdd(coord.h, prevPt.h);			coord.v = FFAdd(coord.v, prevPt.v);			outline->Put(prev, &coord);			break;		}	if (!PolyClockwise(outline))		{		whichCorner = outline->ALength() - whichCorner - 1;		outline->Reverse();		}			return(whichCorner);	}PointFFixed CAVPolyhedron::OutlinePoint(Point3DFFixed	worldPt,FFixed *depth) 	{	PointFFixed	outlinePt;	outlinePt = WorldToOutl(worldPt);	switch(defAxis)		{		case INFL_X: *depth = worldPt.x; break;		case INFL_Y: *depth = worldPt.y; break;		case INFL_Z: *depth = worldPt.z; break;		}	return(outlinePt);	}Point3DFFixedVectorToPlane(Point3DFFixed wp,FFixed FFA,FFixed FFB,FFixed FFC,FFixed FFD);Point3DFFixedVectorToPlane(Point3DFFixed wp,FFixed FFA,FFixed FFB,FFixed FFC,FFixed FFD)	{	Point3DFFixed	distance;	double	x,y,z,A,B,C,D,p,a,b,c,normalize,jx,jy,jz;		x = FixedToDbl(wp.x);	y = FixedToDbl(wp.y);	z = FixedToDbl(wp.z);	A = FixedToDbl(FFA);	B = FixedToDbl(FFB);	C = FixedToDbl(FFC);	D = FixedToDbl(FFD);		normalize = A*A + B*B + C*C;		p = -(A*x + B*y + C*z + D) / normalize;		jx = A * p;	jy = B * p;	jz = C * p;			distance.x = DblToFixed(jx);	distance.y = DblToFixed(jy);	distance.z = DblToFixed(jz);	return(distance);	}Point3DFFixed CAVPolyhedron::PointOnSurface(Point3DFFixed	worldPt,int whichWall) 	{	Surface			*surface;	Point3DFFixed	*surfPt,offsetVector;	FFixed			A,B,C,D,offset,normalize;	short			*index,length,p0,p1,p2,count;		if(surface = FindSurface(whichWall))		{			length = surface->points->ALength();		count = 0;		p0 = count;		p1 = length+2 >> 2;		p2 = length+1 >> 1;				index = (short*)surface->points->Use();		surfPt = (Point3DFFixed	*)posnPoints->Use();				while((count < length) && FFEqual(surfPt[index[p0]].x,surfPt[index[p1]].x)			&& FFEqual(surfPt[index[p0]].y,surfPt[index[p1]].y)			&& FFEqual(surfPt[index[p0]].z,surfPt[index[p1]].z))			{ count++; p1 = count; };		while((count < length) && FFEqual(surfPt[index[p0]].x,surfPt[index[p2]].x)			&& FFEqual(surfPt[index[p0]].y,surfPt[index[p2]].y)			&& FFEqual(surfPt[index[p0]].z,surfPt[index[p2]].z))			{ count++; p2 = count; };		while((count < length) && FFEqual(surfPt[index[p1]].x,surfPt[index[p2]].x)			&& FFEqual(surfPt[index[p1]].y,surfPt[index[p2]].y)			&& FFEqual(surfPt[index[p1]].z,surfPt[index[p2]].z))			{ count++; p2 = count; };					PlaneEquation(surfPt[index[p0]],surfPt[index[p1]],surfPt[index[p2]],&A,&B,&C,&D);		surface->points->Unuse();		posnPoints->Unuse();				offsetVector = VectorToPlane(worldPt,A,B,C,D);				worldPt = FF3DAdd(worldPt,offsetVector);		}			return(worldPt);	}	/*=========================================================================*	Point3DFFixed CAVPolyhedron::GetSurfNormal(int whichWall) *-------------------------------------------------------------------------*/Point3DFFixed CAVPolyhedron::GetSurfNormal(int whichWall) 	{	Surface			*surface;	Point3DFFixed	normal = Pt3DFFZero;	if(surface = FindSurface(whichWall))		{		normal.x.intg = surface->posnNormal.x;		normal.y.intg = surface->posnNormal.y;		normal.z.intg = surface->posnNormal.z;		}	return(normal);	}intCAVPolyhedron::ForceFlip(int direction)  	{	int change;		change = TRUE;		switch(direction)		{		case INFL_UP:if(GRTR == FFLogic(point,base)) change = FALSE; break;			case INFL_DOWN:if(GRTR == FFLogic(base,point)) change = FALSE; break;			case INFL_BOTH:if((INFL_CONVERGE == inflate) && (INFL_ELLIPSE == inflate)) change = FALSE; break;		case INFL_SINGLE:if((INFL_DUALCONVERGE == inflate) && (INFL_DUALELLIPSE == inflate)) change = FALSE; break;		}		return(change);	}/*=========================================================================*	void CAVPolyhedron::MakeInflate( int newInflate , int newLevels)*-------------------------------------------------------------------------*/void CAVPolyhedron::MakeInflate( int newInflate , int newLevels)	{	switch(newInflate)		{		case INFL_EXTRUDE: break;		case INFL_CONVERGE:  break;		case INFL_DUALCONVERGE:		case INFL_ELLIPSE:		case INFL_DUALELLIPSE: 		default:			return;			break;		}	}int CAVPolyhedron::GroupMembers( V_Array *newMembers )	{	Point3DFFixed	orgn;	Point3D			bMin,bMax;	Polyhedron		*pContainer,**pPoly;	int				i,length;		length = newMembers->ALength();	pPoly = (Polyhedron**)newMembers->Use();	pContainer = (*pPoly)->container;		bMin = Pt3DMax;	bMax = Pt3DMin;	for(i = 0; i < length; i++,pPoly++)		{		bMin.x = min((*pPoly)->posnBoundMin.x,bMin.x);		bMin.y = min((*pPoly)->posnBoundMin.y,bMin.y);		bMin.z = min((*pPoly)->posnBoundMin.z,bMin.z);		bMax.x = max((*pPoly)->posnBoundMax.x,bMax.x);		bMax.y = max((*pPoly)->posnBoundMax.y,bMax.y);		bMax.z = max((*pPoly)->posnBoundMax.z,bMax.z);		}		orgn = Pt3DFFZero;	orgn.x.intg = (bMin.x>>1) + (bMax.x>>1);	orgn.y.intg = (bMin.y>>1) + (bMax.y>>1);	orgn.z.intg = (bMin.z>>1) + (bMax.z>>1);	MoveTo(orgn);		newMembers->Unuse();		if(pContainer)		pContainer->RemoveMulti(newMembers);	InstallMulti(newMembers);	if(pContainer)		pContainer->Install(this);				return(TRUE);	}voidCAVPolyhedron::Extrema( Point3DFFixed *extMin,Point3DFFixed *extMax )	{	CAVPolyhedron	**ppoly;	Point3DFFixed	*pt,pMin,pMax;	Surface			**surf;	short			*surfPnt;	int	i,j,length,surfLength,surfPntLength;		*extMin  = Pt3DFFMax;	*extMax = Pt3DFFMin;		switch(type)		{		case POLY_ROOT:			break;				case POLY_GROUP:			if(contents && (length = contents->ALength()))				{				ppoly = (CAVPolyhedron **)contents->Use();				for(i = 0; i < length; i++,ppoly++)					{					(*ppoly)->Extrema(&pMin,&pMax);					FFMin(extMin->x,extMin->x,pMin.x);					FFMin(extMin->y,extMin->y,pMin.y);					FFMin(extMin->z,extMin->z,pMin.z);					FFMax(extMax->x,extMax->x,pMax.x);					FFMax(extMax->y,extMax->y,pMax.y);					FFMax(extMax->z,extMax->z,pMax.z);					}				contents->Unuse();				}			break;				case POLY_INFLATE:		case POLY_MESH:			pt = (Point3DFFixed *)posnPoints->Use();			surfLength = piece->surfaces->ALength();			surf = (Surface **)piece->surfaces->Use();						for(i = 0; i < surfLength; i++,surf++)				{				surfPntLength = (*surf)->points->ALength();				surfPnt = (short *)(*surf)->points->Use();								for(j = 0; j < surfPntLength; j++,surfPnt++)					{					FFMin(extMin->x,extMin->x,pt[*surfPnt].x);					FFMin(extMin->y,extMin->y,pt[*surfPnt].y);					FFMin(extMin->z,extMin->z,pt[*surfPnt].z);					FFMax(extMax->x,extMax->x,pt[*surfPnt].x);					FFMax(extMax->y,extMax->y,pt[*surfPnt].y);					FFMax(extMax->z,extMax->z,pt[*surfPnt].z);					}				(*surf)->points->Unuse();				}			piece->surfaces->Unuse();			posnPoints->Unuse();				break;		}	}void CAVPolyhedron::PromoteContents( )	{	CAVPolyhedron	*newContainer,**pPoly;	int		i,length;		switch(type)		{		case POLY_ROOT:			break;				case POLY_GROUP:			if(contents)				{				length = contents->ALength();				pPoly = (CAVPolyhedron**)contents->Use();				for(i = 0; i < length; i++,pPoly++)					(*pPoly)->PromoteContents();				contents->Unuse();				}			break;				case POLY_INFLATE:		case POLY_MESH:			if(contents && (newContainer = pcp(FindContainer())))				{					length = contents->ALength();				pPoly = (CAVPolyhedron**)contents->Use();				for(i = length-1; i >= 0; i--)					pPoly[i]->Promote(newContainer);				contents->Unuse();				}					break;		}	}void CAVPolyhedron::CalcTraceOutline()	{	CAVPolyhedron	**pPoly;	SurfDef	**sDefs;	CAVSurfFeature **pFeat;	Point3DFFixed	pt3D,pt3DMax,pt3DMin;	PointFFixed featMin,featMax,ptMin,ptMax,pt;	int	i,length,j,fLength;		switch(type)		{		case POLY_GROUP:			if(contents)				{				length = contents->ALength();				pPoly = (CAVPolyhedron**)contents->Use();				for(i = 0; i < length; i++,pPoly++)					(*pPoly)->CalcTraceOutline();				contents->Unuse();				}			break;					case POLY_MESH:		case POLY_INFLATE:			if(surfDef)				{				featMin = PtFFMax;				featMax = PtFFMin;							length = surfDef->ALength();				sDefs = (SurfDef**)surfDef->Use();				for(i = 0; i < length; i++,sDefs++) 					{ 					if((*sDefs) && (SDEF_FEATURE & (*sDefs)->flags))						{						int k;						for(k =0; k < 3; k++)							{							if((*sDefs)->features[k])								{								fLength = (*sDefs)->features[k]->ALength();								pFeat = (CAVSurfFeature**)(*sDefs)->features[k]->Use();								for(j = 0; j < fLength; j++,pFeat++)									{									(*pFeat)->CalcOutline(&ptMin,&ptMax);									FFMin(featMin.h,featMin.h,ptMin.h);									FFMin(featMin.v,featMin.v,ptMin.v);									FFMax(featMax.h,featMax.h,ptMax.h);									FFMax(featMax.v,featMax.v,ptMax.v);									}								(*sDefs)->features[k]->Unuse();								}							}pt.h = FFNeg(featMin.h);pt.v = FFNeg(featMin.v);						for(k =0; k < 3; k++)							{							if((*sDefs)->features[k])								{								fLength = (*sDefs)->features[k]->ALength();								pFeat = (CAVSurfFeature**)(*sDefs)->features[k]->Use();								for(j = 0; j < fLength; j++,pFeat++)									(*pFeat)->Move(pt);								(*sDefs)->features[k]->Unuse();								}							}						pt3DMin = Pt3DFFZero;						pt3DMax = Pt3DFFZero;						pt3DMin.x = featMin.h; pt3DMin.y = featMin.v;						pt3DMin = (*sDefs)->position->Transform3D(pt3DMin);						pt3DMax.x = featMax.h; pt3DMax.y = featMax.v;						pt3DMax = (*sDefs)->position->Transform3D(pt3DMax);																		}					}				surfDef->Unuse();featMin = WorldToOutl(pt3DMin);featMax = WorldToOutl(pt3DMax);featMax.h = FFSub(featMax.h,featMin.h);featMax.v = FFSub(featMax.v,featMin.v);outline->SetLength(4);outline->Put(0, &PtZero);pt.h = FFZero;pt.v = featMax.v; outline->Put(1, &pt);outline->Put(2, &featMax);pt.h = featMax.h;pt.v = FFZero; outline->Put(3, &pt);Move(pt3DMin);				}				break;				}							Update();	}			void CAVPolyhedron::AddTraceElement(V_Array *outl,Point3DFFixed vector,RGBColor col,int traceType)	{	SurfDef	*surfDef;	SurfFeature	*surfFeature;	PointFFixed	pt,*pts;	FFixed	dir;	int	frontSide;		pt = OutlinePoint(vector,&dir);	if(GRTR == FFLogic(dir,FFZero)) frontSide = TRUE; else frontSide = FALSE;	if(frontSide) surfDef = GetSurfDef(0); else surfDef = GetSurfDef(5);	surfDef->SetColor(vWhite,OPAQUE_NOM,SURF_SHARED);	surfFeature = surfDef->NewSurfFeature();	surfFeature->cSurfFeature();	surfFeature->Create(outl,PtFFZero);	surfFeature->SetColor(col,OPAQUE_NOM);	surfFeature->SetEditType(traceType);	surfDef->InstallFeature(surfFeature,SURF_SHARED);	}void#if MACINTOSHCAVPolyhedron::AddPictElement(V_Picture *fromPict,Point3DFFixed vector,int traceType)#elif WINDOWSCAVPolyhedron::AddPictElement(V_Offscreen *fromPict,Point3DFFixed vector,int traceType)#endif	{	SurfDef	*surfDef;	SurfFeature	*surfFeature;#if MACINTOSH	V_Picture *toPict;#elif WINDOWS	V_Offscreen *toPict;#endif	FFixed	dir;	Rect	r,tr,dr;	V_Array			*pts;	PointFFixed		p;	int	frontSide;			toPict = fromPict;		toPict->GetRect(&r);	p = OutlinePoint(vector,&dir);	if(GRTR == FFLogic(dir,FFZero)) frontSide = TRUE; else frontSide = FALSE;	if(frontSide) surfDef = GetSurfDef(0); else surfDef = GetSurfDef(5);		dr = r;	if(!frontSide)		{		dr.left = -r.right;		dr.right = -r.left;		}	if(INFL_Y != defAxis)		tr = dr;	else		{		tr.left = dr.top; 		tr.right = dr.bottom;		tr.top = -dr.left;		tr.bottom = -dr.right;		}			pts = new(V_Array);	pts->cArray(0,sizeof(PointFFixed),4);	p.h.intg = r.left;p.v.intg = r.top; pts->Append(&p);	p.h.intg = r.right;p.v.intg = r.top; pts->Append(&p);	p.h.intg = r.right;p.v.intg = r.bottom; pts->Append(&p);	p.h.intg = r.left;p.v.intg = r.bottom; pts->Append(&p);			surfDef->SetColor(vWhite,OPAQUE_NOM,SURF_SHARED);	surfFeature = surfDef->NewSurfFeature();	surfFeature->cSurfFeature();	surfFeature->Create(pts,PtFFZero);	surfFeature->SetEditType(traceType);	((CAVSurfFeature*)surfFeature)->SetPicture(toPict);	surfDef->InstallFeature(surfFeature,SURF_SHARED);	pts->SetLength(0);	p.h.intg = tr.left;p.v.intg = tr.top; pts->Append(&p);	p.h.intg = tr.right;p.v.intg = tr.top; pts->Append(&p);	p.h.intg = tr.right;p.v.intg = tr.bottom; pts->Append(&p);	p.h.intg = tr.left;p.v.intg = tr.bottom; pts->Append(&p);	pts->CopyArray(outline);	if (!PolyClockwise(outline))		outline->Reverse();	Update();	pts->dArray();	}intCAVPolyhedron::FlipOutline(V_Array *outl)	{}		/* ... DWE */	#if (!VPLAYER)intCAVPolyhedron::Export(ModelExport *export)	{	if (type != POLY_ROOT && type != POLY_GROUP)		{		RGBAColor clr;		int nSurfaces, i;		Surface **surf;		V_Array *loop = piece->surfaces;		ExportArray *sort = NULL;				export->SetPolyhedron(this); 		clr.red = outsideColor.red;		clr.green = outsideColor.green;		clr.blue = outsideColor.blue;		clr.alpha = opacity;		export->OpenPolyhedron(posnPoints, clr, layer->layerID);		if (export->SortSurfaces())			{			sort = new(ExportArray);			sort->cArray(0, sizeof(Surface *), 4);			sort->SetExport(export);			sort->SetObject(expSurface);			loop->CopyArray(sort);			sort->QuickSort();			loop = sort;			}		nSurfaces = loop->ALength();		surf = (Surface **)loop->Use();		for (i = 0; i < nSurfaces; i++)			ExportSurface(export, *surf++);		loop->Unuse();		if (sort != NULL) sort->dArray();		export->ClosePolyhedron();		}	if (contents != NULL)		{		int nPolys, i;		CAVPolyhedron **poly;		V_Array *loop = contents;		ExportArray *sort = NULL;		if (export->SortPolyhedra())			{			sort = new(ExportArray);			sort->cArray(0, sizeof(Polyhedron *), 4);			sort->SetExport(export);			sort->SetObject(expPolyhedron);			loop->CopyArray(sort);			sort->QuickSort();			loop = sort;			}		nPolys = loop->ALength();		poly = (CAVPolyhedron **)loop->Use();		for (i = 0; i < nPolys; i++)			(*poly++)->Export(export);		loop->Unuse();		if (sort != NULL) sort->dArray();		}	return (0);		// ?always return ok for status?  // VRML // GJR 07/12/95	}intCAVPolyhedron::ExportSurface(ModelExport *export, Surface *surf)	{	CAVSurfDef *sDef = (CAVSurfDef *)(surf->surfDef);	Point3DFFixed norm = Pt3DFFZero;	RGBAColor clr;	RGBColor c;	unsigned short o;	export->SetSurface(surf);	if (sDef != NULL)		{		c = sDef->GetColor(SURF_OUTSIDE);		o = sDef->GetOpacity();		}	else		{		c = GetColor(SURF_OUTSIDE);		o = GetOpacity();		}	clr.red = c.red;	clr.green = c.green;	clr.blue = c.blue;	clr.alpha = o;	norm.x.intg = surf->posnNormal.x;	norm.y.intg = surf->posnNormal.y;	norm.z.intg = surf->posnNormal.z;	export->OpenSurface(surf->points, clr, norm);	if (sDef != NULL)		sDef->Export(export);	export->CloseSurface();	}#endif //!VPLAYER