/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	 *				David W. Easter *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VDisplay.h"#include "Polyhdrn.h"#include "Drawing.h"#include "PolyConv.h"#include "SurfDef.h"#include "Surface.h"#include "Slice.h"#include "Position.h"#include "Light.h"#include "Geometry.h"#include "WTypes.h"#include "VMDL.h"#include "WalkBuff.h"#include "Unit.h"#include "TextItem.h"		// ABD MERGE-TEXTURE 9/13/93#include "TextSrvr.h"		// ABD MERGE-TEXTURE 9/13/93#include "View.h"				// ABD MERGE-TEXTURE 9/13/93#include "AppDeflt.h"		// ABD MERGE-TEXTURE 9/13/93extern TextureServer *gTextureServer;		// ABD MERGE-TEXTURE 9/13/93#include <stddef.h>#include <math.h>#include <string.h>#include "VGraphic.h"#include "VGUtil.h"#include "VDialog.h"#include "VMemUtil.h"#include "VMath.h"/* *	Constructor/destructor methods. */voidPolyhedron::cPolyhedron(WalkDrawing *dwg)	{	type = POLY_INVALID;	/*	 *	Initialize references to neighbors.	 */	drawing = dwg;	container = NULL;	contents = NULL;	lights = NULL;	unit = NULL;	name = NULL;	data = NULL;	hidden = FALSE;	/*	 *	Initialize definition data.	 */	editType = 0;	defAxis = 0;	inflate = 0;	levels = 0;	point = FFZero;	base = FFZero;	pointSkew.h = FFZero; pointSkew.v = FFZero;	baseSkew.h = FFZero; baseSkew.v = FFZero;	outline = new(V_Array);	outline->cArray(0, sizeof(PointFFixed), 4);	meshPoints = NULL;	meshSurfs = NULL;	slices = NULL;	insideColor = vBlack;	outsideColor = vBlack;	opacity = 0;	surfDef = NULL;	insideTexture = NULL;		// ABD MERGE-TEXTURE 9/13/93	outsideTexture = NULL;		// ABD MERGE-TEXTURE 9/13/93// ABD MERGE-GOURAUD [[[	insideShadeType = SHADE_FLAT;	outsideShadeType = SHADE_FLAT;// ABD MERGE-GOURAUD ]]]		#if VRML_ANCHOR			// VRML-ABD 23JUN95	vrml_anchor = NULL;	#endif // VRML_ANCHOR	rPosn = new(Position);	rPosn->cPosition();		posn = new(Position);	posn->cPosition();	/*	 *	Allocate space for 3D derived data.	 */	boundMin.x = 0; boundMin.y = 0; boundMin.z = 0;	boundMax.x = 0; boundMax.y = 0; boundMax.z = 0;	posnBoundMin.x = 0; posnBoundMin.y = 0; posnBoundMin.z = 0;	posnBoundMax.x = 0; posnBoundMax.y = 0; posnBoundMax.z = 0;	points = new(V_Array);	points->cArray(0, sizeof(Point3DFFixed), 8);	posnPoints = new(V_Array);	posnPoints->cArray(0, sizeof(Point3DFFixed), 8);	pieces = NULL;	piece = NULL;	/*	 *	Allocate space for data for 3D rendering.	 */	 	rendPoints = new(V_Array);	rendPoints->cArray(0, sizeof(Point3DLong), 8); // DAS - HIRES// ABD MERGE-TEXTURE 9/13/93 [[[	/*extra data for perfect texturing (includes perspective multiply value)*/	/*added by JAM*/	NoPerspPoints = new(V_Array);	// JAM TEXTURE	NoPerspPoints->cArray(0, sizeof(struct Point3DNoPersp), 8);	// JAM TEXTURE// ABD MERGE-TEXTURE 9/13/93 ]]]	}voidPolyhedron::dPolyhedron()	{	int nSlices, nSurfDefs, i;	Slice **slice;	SurfDef **sDef;	KillContents();	if (lights != NULL)		lights->dLightModel();	if (unit != NULL)		unit->dUnit();	if (name != NULL)		name->dArray();	if (data != NULL)		data->dArray();			#if VRML_ANCHOR				// VRML-ABD 23JUN95	if (vrml_anchor != NULL)		vrml_anchor->dArray();	#endif // VRML_ANCHOR// MERGE21 [[[	if (insideTexture != NULL) 		insideTexture->DocUnusePoly(this);	// stop using the texture item	if (outsideTexture != NULL) 		outsideTexture->DocUnusePoly(this);	// stop using the texture item// MERGE21 ]]]	outline->dArray();	if (meshPoints != NULL)		meshPoints->dArray();	if (meshSurfs != NULL)		{		int nSurfaces;		V_Array **surf;		nSurfaces = meshSurfs->ALength();		surf = (V_Array **)meshSurfs->Use();		for (i = 0; i < nSurfaces; i++)			(*surf++)->dArray();		meshSurfs->Unuse();		meshSurfs->dArray();		}	if (slices != NULL)		{		nSlices = slices->ALength();		slice = (Slice **)slices->Use();		for (i = 0; i < nSlices; i++)			(*slice++)->dSlice();		slices->Unuse();		slices->dArray();		}	if (surfDef != NULL)		{		nSurfDefs = surfDef->ALength();		sDef = (SurfDef **)surfDef->Use();		for (i = 0; i < nSurfDefs; i++, sDef++)			{			if (*sDef != NULL)				{				(*sDef)->Disconnect(NULL, NULL, -1);				(*sDef)->dSurfDef();				}			}		surfDef->Unuse();		surfDef->dArray();		}	rPosn->dPosition();	posn->dPosition();	points->dArray();	posnPoints->dArray();	KillPieces();			rendPoints->dArray();	NoPerspPoints->dArray();	// JAM ABD MERGE-TEXTURE 9/13/93		delete(this);	}voidPolyhedron::KillContents()	{	int nPolys, i;	Polyhedron **poly;	if (contents != NULL)		{		nPolys = contents->ALength();		poly = (Polyhedron **)contents->Use();		for (i = 0; i < nPolys; i++)			(*poly++)->dPolyhedron();		contents->Unuse();		contents->SetLength(0);				contents->dArray();		contents = NULL;		}	}voidPolyhedron::AddPiece(PolyConvex *piec)	{	PolyConvex *p;	if (piece != NULL)		{		pieces = new(V_Array);		pieces->cArray(0, sizeof(PolyConvex *), 4);				p = piece;		pieces->Append(&p);		piece = NULL;		}	if (pieces != NULL)		pieces->Append(&piec);	else		piece = piec;	}voidPolyhedron::KillPieces()	{	if (pieces != NULL)		{		int nPieces, i;		PolyConvex **piec;			nPieces = pieces->ALength();		piec = (PolyConvex **)pieces->Use();		for (i = 0; i < nPieces; i++)			(*piec++)->dPolyConvex();		pieces->Unuse();		pieces->SetLength(0);				pieces->dArray();		pieces = NULL;		}	else if (piece != NULL)		{		piece->dPolyConvex();		piece = NULL;		}	}voidPolyhedron::KillSurfPieces()	{	if (surfDef != NULL)		{		int nSurfDefs, i;		SurfDef **sDef;		nSurfDefs = surfDef->ALength();		sDef = (SurfDef **)surfDef->Use();		for (i = 0; i < nSurfDefs; i++, sDef++)			if (*sDef != NULL)				(*sDef)->KillSurfaces();		surfDef->Unuse();		}	}voidPolyhedron::Install(Polyhedron *poly)	{	Unit *un;	Polyhedron *head;	if (type == POLY_INVALID || poly->type == POLY_INVALID)		return;	if ((un = GetUnit()) != NULL)		poly->SetUnit(un);	poly->RemoveUnit();	poly->container = this;	poly->rPosn->UnPosition(posn);	if (contents == NULL)		{		contents = new(V_Array);		contents->cArray(0, sizeof(Polyhedron *), 4);		}	contents->Append(&poly);	poly->FixConnections();	if ((head = poly->FindContainer()) != NULL)		{		head->InstallConvex(poly);		head->CompareClose(poly);		}/* Update( install/remove ) *//* UpdateMove(); */poly->CalcShade();if (type == POLY_GROUP) CalcGroupBound();	}voidPolyhedron::Remove(Polyhedron *poly)	{	Polyhedron *head;	Unit *un;	int i;	if (type == POLY_INVALID)		return;	if ((head = poly->FindContainer()) != NULL)		{		head->RemoveClose(poly);		head->RemoveConvex(poly);		}	poly->Disconnect(-1, NULL, -1, SDEF_PEER);	poly->Disconnect(-1, NULL, -1, SDEF_CONTAINER);	if ((i = contents->Find(&poly)) >= 0)		contents->Remove(i);	poly->rPosn->PositionX(posn);	poly->container = NULL;	if ((un = GetUnit()) != NULL)		poly->SetUnit(un);/* Update( install/remove ) *//* UpdateMove(); */poly->CalcShade();if (type == POLY_GROUP) CalcGroupBound();	}voidPolyhedron::InstallMulti(V_Array *polys)	{	int nPolys, i;	Polyhedron **polyIndex, *poly, *head;	Unit *un;	if (type == POLY_INVALID)		return;	un = GetUnit();	nPolys = polys->ALength();	polyIndex = (Polyhedron **)polys->Use();	for (i = 0; i < nPolys; i++)		{		poly = *polyIndex++;		if (un != NULL) poly->SetUnit(un);		poly->RemoveUnit();		poly->container = this;		poly->rPosn->UnPosition(posn);			if (contents == NULL)			{			contents = new(V_Array);			contents->cArray(0, sizeof(Polyhedron *), 4);			}		contents->Append(&poly);		poly->FixConnections();		if ((head = poly->FindContainer()) != NULL)			{			head->InstallConvex(poly);			head->CompareClose(poly);			}poly->CalcShade();		}	polys->Unuse();if (type == POLY_GROUP) CalcGroupBound();	}voidPolyhedron::RemoveMulti(V_Array *polys)	{	int nPolys, i, j;	Polyhedron **polyIndex, *poly, *head;	Unit *un;	if (type == POLY_INVALID)		return;	un = GetUnit();	nPolys = polys->ALength();	polyIndex = (Polyhedron **)polys->Use();	for (i = 0; i < nPolys; i++)		{		poly = *polyIndex++;		if ((head = poly->FindContainer()) != NULL)			{			head->RemoveClose(poly);			head->RemoveConvex(poly);			}				poly->DisconnectNot(-1, polys, SDEF_PEER);		poly->Disconnect(-1, NULL, -1, SDEF_CONTAINER);			if ((j = contents->Find(&poly)) >= 0)			contents->Remove(j);			poly->rPosn->PositionX(posn);		poly->container = NULL;		if (un != NULL) poly->SetUnit(un);poly->CalcShade();		}	polys->Unuse();if (type == POLY_GROUP) CalcGroupBound();	}voidPolyhedron::TreeInfo(ModelInfo *info)	{	NodeInfo(info, TRUE, TRUE);	}voidPolyhedron::NodeInfo(ModelInfo *info, int init, int total)	{	int nPolys, i;	Polyhedron **poly;	int root, group, infl, mesh;	if (init)		memset(info, 0, sizeof(ModelInfo));	if (total && contents != NULL)		{		nPolys = contents->ALength();		poly = (Polyhedron **)contents->Use();		for (i = 0; i < nPolys; i++)			(*poly++)->NodeInfo(info, FALSE, TRUE);		contents->Unuse();		}	root = (type == POLY_ROOT ? 1 : 0);	group = (type == POLY_GROUP ? 1 : 0);	infl = (type == POLY_INFLATE ? 1 : 0);	mesh = (type == POLY_MESH ? 1 : 0);	info->nPolyhedra++;	info->nPolyRoot += root;	info->nPolyGroup += group;	info->nPolyInflate += infl;	info->nPolyMesh += mesh;	info->nSurfaces += SurfCount();	info->nSurfCreate += SurfCreateCount();	info->nSurfSlice += SurfSliceCount();	if (surfDef != NULL)		{		int nSurfDefs, i;		SurfDef **sDef;		nSurfDefs = surfDef->ALength();		sDef = (SurfDef **)surfDef->Use();		for (i = 0; i < nSurfDefs; i++, sDef++)			if (*sDef != NULL) info->nFeatures += (*sDef)->FeatCount();		surfDef->Unuse();		}	}longPolyhedron::TreeSize(int all)	{	int nPolys, i;	Polyhedron **poly;	long size = 0;	if (contents != NULL)		{		nPolys = contents->ALength();		poly = (Polyhedron **)contents->Use();		for (i = 0; i < nPolys; i++)			size += (*poly++)->TreeSize(all);		contents->Unuse();		}	if (all || (type != POLY_ROOT && type != POLY_GROUP))		size++;	return(size);	}voidPolyhedron::SetName(char *nm, int len)	{	char *vnm;	if (name == NULL)		{		name = new(V_Array);		name->cArray(0, 1, 16);		}	name->SetLength(len);	vnm = (char *)name->Use();	memmove(vnm, nm, len);	name->Unuse();	}intPolyhedron::GetName(char *nm, int len)	{	int vlen;	char *vnm;	if (name == NULL || (vlen = name->ALength()) > len)		return(-1);	vnm = (char *)name->Use();	memmove(nm, vnm, vlen);	name->Unuse();		return(vlen);	}V_Array *Polyhedron::GetNameArray()	{	return(name);	}voidPolyhedron::SetData(char *dat, int len)	{	char *vdat;	if (data == NULL)		{		data = new(V_Array);		data->cArray(0, 1, 16);		}	data->SetLength(len);	vdat = (char *)data->Use();	memmove(vdat, dat, len);	data->Unuse();	}intPolyhedron::GetData(char *dat, int len)	{	int vlen;	char *vdat;	if (data == NULL || (vlen = data->ALength()) > len)		return(-1);	vdat = (char *)data->Use();	memmove(dat, vdat, vlen);	data->Unuse();		return(vlen);	}V_Array *Polyhedron::GetDataArray()	{	return(data);	}voidPolyhedron::SetHidden(int h)	{	int nPolys, i;	Polyhedron **poly;	hidden = h;	if (type == POLY_GROUP)		{		if (contents != NULL)			{			nPolys = contents->ALength();			poly = (Polyhedron **)contents->Use();				for (i = 0; i < nPolys; i++, poly++)				(*poly)->SetHidden(h);			contents->Unuse();			}		}	}intPolyhedron::GetHidden()	{	return(hidden);	}voidPolyhedron::CreateRoot()	{	type = POLY_ROOT;		Update();	}voidPolyhedron::CreateGroup()	{	type = POLY_GROUP;		Update();	}voidPolyhedron::CreateMesh(V_Array *pnts, V_Array *surfs)	{	type = POLY_MESH;		insideColor = vBlack;	outsideColor = vBlack;	opacity = 0xffff;		meshPoints = pnts;	meshSurfs = surfs;		Update();	}voidPolyhedron::CreateInflate(int axis, int infl, V_Array *outl, FFixed pnt, FFixed bas)	{	type = POLY_INFLATE;	editType = EDIT_POLYGON;	defAxis = axis;	inflate = infl;	levels = 1;	point = pnt;	base = bas;	insideColor = vBlack;	outsideColor = vBlack;	opacity = 0xffff;	pointSkew.h = FFZero;	pointSkew.v = FFZero;	baseSkew.h = FFZero;	baseSkew.v = FFZero;	outl->CopyArray(outline);	Update();	}voidPolyhedron::ChangeInflate(int infl, int lvls)	{	int oldExtr, oldDual, oldLevels;	int newExtr, newDual, newLevels;	if (infl == INFL_EXTRUDE || infl == INFL_CONVERGE || infl == INFL_DUALCONVERGE)		lvls = 1;	newExtr = (infl == INFL_EXTRUDE);	newDual = (infl == INFL_DUALCONVERGE || infl == INFL_DUALELLIPSE);	newLevels = lvls;	while (TRUE)		{		oldExtr = (inflate == INFL_EXTRUDE);		oldDual = (inflate == INFL_DUALCONVERGE || inflate == INFL_DUALELLIPSE);		oldLevels = levels;		if (oldExtr == newExtr && oldDual == newDual && oldLevels == newLevels)			break;		if (oldExtr && !newExtr)			InflExtrude(FALSE);		else if (!oldDual && newDual)			InflDual(TRUE);		else if (oldLevels != newLevels)			InflLevels(newLevels);		else if (oldDual && !newDual)			InflDual(FALSE);		else if (!oldExtr && newExtr)			InflExtrude(TRUE);		}	Update();	}/* *	Convert an inflation between extrusion and convergence, updating SurfDefs *	as necessary. */voidPolyhedron::InflExtrude(int extr)	{	SurfDef *sDef, *null = NULL;	int up, num;	up = (FFLogic(point, base) > 0);	if (extr)		{		num = (up ? 0 : SurfCreateCount());		if (surfDef != NULL)			surfDef->Insert(num, &null);		inflate = INFL_EXTRUDE;		}	else		{		num = (up ? 0 : SurfCreateCount()-1);		if (surfDef != NULL)			{			surfDef->Get(num, &sDef);			surfDef->Remove(num);				if (sDef != NULL)				sDef->dSurfDef();			}		inflate = INFL_CONVERGE;		}	}/* *	Convert an inflation between single and dual convergences or ellipsoids, *	updating SurfDefs as necessary. */voidPolyhedron::InflDual(int dual)	{	SurfDef *sDef, *null = NULL;	int up, num, delta, i;	up = (FFLogic(point, base) > 0);	if (dual)		{		num = (up ? SurfCreateCount()-1 : 0);		delta = SurfCreateCount()-1;		if (surfDef != NULL)			{			surfDef->Get(num, &sDef);			surfDef->Remove(num);				if (sDef != NULL)				sDef->dSurfDef();			for (i = 0; i < delta; i++)				surfDef->Insert(num, &null);			}		if (inflate == INFL_CONVERGE)			inflate = INFL_DUALCONVERGE;		else			inflate = INFL_DUALELLIPSE;		}	else		{		num = (up ? SurfCreateCount() >> 1 : 0);		delta = SurfCreateCount() >> 1;		if (surfDef != NULL)			{			for (i = 0; i < delta; i++)				{				surfDef->Get(num, &sDef);				surfDef->Remove(num);						if (sDef != NULL)					sDef->dSurfDef();				}			surfDef->Insert(num, &null);			}		if (inflate == INFL_DUALCONVERGE)			inflate = INFL_CONVERGE;		else			inflate = INFL_ELLIPSE;		}	}/* *	Change the number of levels in a single or dual convergence or ellipsiod, *	updating SurfDefs as necessary. */voidPolyhedron::InflLevels(int lvls)	{	SurfDef *sDef, *null = NULL;	int up, dual, num, delta, i;	up = (FFLogic(point, base) > 0);	dual = (inflate == INFL_DUALCONVERGE || inflate == INFL_DUALELLIPSE);	num = ((up || dual) ? levels * outline->ALength() : 1);	delta = (lvls - levels) * outline->ALength();	if (delta < 0)		{		delta = -delta;		if (up || dual)			num -= delta;		}	if (dual) delta <<=1;	if (lvls > levels)		{		if (surfDef != NULL)			{			for (i = 0; i < delta; i++)				surfDef->Insert(num, &null);			}		}	else		{		if (surfDef != NULL)			{			for (i = 0; i < delta; i++)				{				surfDef->Get(num, &sDef);				surfDef->Remove(num);						if (sDef != NULL)					sDef->dSurfDef();				}			}		}	levels = lvls;	if (levels == 1)		{		if (inflate == INFL_ELLIPSE) inflate = INFL_CONVERGE;		else if (inflate == INFL_DUALELLIPSE) inflate = INFL_DUALCONVERGE;		}	else		{		if (inflate == INFL_CONVERGE) inflate = INFL_ELLIPSE;		else if (inflate == INFL_DUALCONVERGE) inflate = INFL_DUALELLIPSE;		}	}voidPolyhedron::Connect(int fromSurf, Polyhedron *toPoly, int toSurf)	{	SurfDef *fromSurfDef, *toSurfDef;	if ((type & POLY_CLASS) == P_INTERNAL || (toPoly->type & POLY_CLASS) == P_INTERNAL)		return;	fromSurfDef = GetSurfDef(fromSurf);	toSurfDef = toPoly->GetSurfDef(toSurf);	if (fromSurfDef != NULL && toSurfDef != NULL && !fromSurfDef->Connected(toPoly, toSurfDef, -1))		fromSurfDef->Connect(toPoly, toSurfDef);	}voidPolyhedron::Disconnect(int fromSurf, Polyhedron *toPoly, int toSurf, int connType)	{	SurfDef *fromSurfDef, *toSurfDef = NULL, **sDef;	int nSurfDefs, i;		if ((type & POLY_CLASS) == P_INTERNAL)		return;	if (toPoly != NULL && toSurf >= 0)		toSurfDef = toPoly->FindSurfDef(toSurf);	if (fromSurf >= 0)		{		fromSurfDef = FindSurfDef(fromSurf);		if (fromSurfDef != NULL)			fromSurfDef->Disconnect(toPoly, toSurfDef, connType);		}	else if (surfDef != NULL)		{		nSurfDefs = surfDef->ALength();		sDef = (SurfDef **)surfDef->Use();		for (i = 0; i < nSurfDefs; i++, sDef++)			{			if (*sDef != NULL)				(*sDef)->Disconnect(toPoly, toSurfDef, connType);			}		surfDef->Unuse();		}	}voidPolyhedron::DisconnectNot(int fromSurf, V_Array *toPolys, int connType)	{	SurfDef *fromSurfDef, **sDef;	int nSurfDefs, i;		if ((type & POLY_CLASS) == P_INTERNAL)		return;	if (fromSurf >= 0)		{		fromSurfDef = FindSurfDef(fromSurf);		if (fromSurfDef != NULL)			fromSurfDef->DisconnectNot(toPolys, connType);		}	else if (surfDef != NULL)		{		nSurfDefs = surfDef->ALength();		sDef = (SurfDef **)surfDef->Use();		for (i = 0; i < nSurfDefs; i++, sDef++)			{			if (*sDef != NULL)				(*sDef)->DisconnectNot(toPolys, connType);			}		surfDef->Unuse();		}	}intPolyhedron::Connected(Polyhedron *poly, int connType)	{	SurfDef **sDef;	int nSurfDefs, i;	if ((type & POLY_CLASS) == P_INTERNAL)		return(FALSE);	if (surfDef == NULL)		return(FALSE);	nSurfDefs = surfDef->ALength();	sDef = (SurfDef **)surfDef->Use();	for (i = 0; i < nSurfDefs; i++, sDef++)		if (*sDef != NULL && (*sDef)->Connected(poly, NULL, connType))			break;	surfDef->Unuse();		return (i != nSurfDefs);	}voidPolyhedron::FixConnections()	{	if (type == POLY_GROUP)		{		int nPolys, i;		Polyhedron **poly;		if (contents != NULL)			{			nPolys = contents->ALength();			poly = (Polyhedron **)contents->Use();				for (i = 0; i < nPolys; i++, poly++)				(*poly)->FixConnections();			contents->Unuse();			}		}	else if (surfDef != NULL)		{		int nSurfDefs, i;		SurfDef **sDef;		nSurfDefs = surfDef->ALength();		sDef = (SurfDef **)surfDef->Use();		for (i = 0; i < nSurfDefs; i++, sDef++)			{			if (*sDef != NULL)				{				(*sDef)->FindOutsidePoly();				(*sDef)->FixConnections();				}			}		surfDef->Unuse();		}	}void Polyhedron::SetLightModel(LightModel *nlights)	{	if (lights != NULL)		lights->dLightModel();	/* should copy */	lights = nlights;	}LightModel *Polyhedron::GetLightModel()	{	LightModel *lm;	if ((lm = FindLightModel()) != NULL)		return(lm);	else		{		lights = new(LightModel);		lights->cLightModel();		return(lights);		}	}LightModel *Polyhedron::FindLightModel()	{	if (lights != NULL || container == NULL)		return(lights);	else		return(container->FindLightModel());	}voidPolyhedron::SetUnit(Unit *un)	{	Unit *oldUnit;	double factor;	if ((oldUnit = GetUnit()) != NULL)		{		factor = un->ConvertFrom(oldUnit);		if (factor < .9999 || factor > 1.0001)			{			FFixed f = DblToFixed(factor);			ChangeUnit(f);			}		}	if (unit == NULL)		{		unit = new(Unit);		unit->cUnit();		}	un->Copy(unit);	}Unit *Polyhedron::GetUnit()	{	if (unit != NULL || container == NULL)		return(unit);	else		return(container->GetUnit());	}voidPolyhedron::RemoveUnit()	{	if (unit != NULL)		{		unit->dUnit();		unit = NULL;		}	}voidPolyhedron::ChangeUnit(FFixed factor)	{	if (type == POLY_INFLATE || type == POLY_MESH)		{		int nSlices, nSurfDefs, i;		Slice **slice;		SurfDef **sDef;		if (type == POLY_INFLATE)			{			int nOutlPoints;			PointFFixed *outl;			/* Scale inflation values */					point = FFMult(point, factor);			base = FFMult(base, factor);					pointSkew.h = FFMult(pointSkew.h, factor);			pointSkew.v = FFMult(pointSkew.v, factor);			baseSkew.h = FFMult(baseSkew.h, factor);			baseSkew.v = FFMult(baseSkew.v, factor);					/* Scale outline */					nOutlPoints = outline->ALength();			outl = (PointFFixed *)outline->Use();					for (i = 0; i < nOutlPoints; i++, outl++)				{				outl->h = FFMult(outl->h, factor);				outl->v = FFMult(outl->v, factor);				}					outline->Unuse();			}		else if (type == POLY_MESH)			{			int nPoints;			Point3DFFixed *pnt;			/* Scale mesh points */			nPoints = meshPoints->ALength();			pnt = (Point3DFFixed *)meshPoints->Use();			for (i = 0; i < nPoints; i++, pnt++)				{				pnt->x = FFMult(pnt->x, factor);				pnt->y = FFMult(pnt->y, factor);				pnt->z = FFMult(pnt->z, factor);				}			meshPoints->Unuse();			}		/* Scale slices */			if (slices != NULL)			{			nSlices = slices->ALength();			slice = (Slice **)slices->Use();			for (i = 0; i < nSlices; i++)				(*slice++)->ChangeUnit(factor);			slices->Unuse();			}			/* Scale surfaces */			if (surfDef != NULL)			{			nSurfDefs = surfDef->ALength();			sDef = (SurfDef **)surfDef->Use();			for (i = 0; i < nSurfDefs; i++, sDef++)				if (*sDef != NULL)					(*sDef)->ChangeUnit(factor);			surfDef->Unuse();			}		}	if (type == POLY_INFLATE || type == POLY_MESH || type == POLY_GROUP)		{		/* Scale position */	/* Kind of a hack for 1.04; 1.1 can use Position's Scale method */		rPosn->origin.x = FFMult(rPosn->origin.x, factor);		rPosn->origin.y = FFMult(rPosn->origin.y, factor);		rPosn->origin.z = FFMult(rPosn->origin.z, factor);		}	Update();	if (contents != NULL)		{		int nPolys, i;		Polyhedron **poly;		nPolys = contents->ALength();		poly = (Polyhedron **)contents->Use();		for (i = 0; i < nPolys; i++)			(*poly++)->ChangeUnit(factor);		contents->Unuse();		}	}voidPolyhedron::SetColor(RGBColor clr, unsigned short opc, int where)	{	int nSurfDefs, nPieces, i;	SurfDef **sDef;	PolyConvex **piec;	if (type == POLY_INVALID)		return;	if (where == SURF_SHARED || !IS_OPAQUE(opc))		{ insideColor = clr; outsideColor = clr; }	else if (where == SURF_INSIDE)		insideColor = clr;	else if (where == SURF_OUTSIDE)		outsideColor = clr;	opacity = opc;	CalcShade(); /* should be Update( local color change ) */	}RGBColorPolyhedron::GetColor(int where)	{	if ((type & POLY_CLASS) == P_INTERNAL)		return(vBlack);	if (where == SURF_INSIDE)		return (insideColor);	else		return (outsideColor);	}unsigned shortPolyhedron::GetOpacity()	{	if ((type & POLY_CLASS) == P_INTERNAL)		return(0);	return(opacity);	}voidPolyhedron::Move(Point3DFFixed offset)	{	if ((type & POLY_CLASS) == P_INTERNAL)		return;	rPosn->Move3D(offset);	UpdateMove();	}voidPolyhedron::MoveTo(Point3DFFixed orgn)	{	if ((type & POLY_CLASS) == P_INTERNAL)		return;	rPosn->SetOrigin3D(orgn);	UpdateMove();	}voidPolyhedron::Rotate(Angle3DFFixed rotate, Point3DFFixed pnt)	{	if ((type & POLY_CLASS) == P_INTERNAL)		return;	if (container != NULL)		pnt = container->posn->UnTransform3D(pnt);	rPosn->Rotate3D(rotate, pnt);	UpdateMove();	}voidPolyhedron::RotateTo(Angle3DFFixed orient)	{	if ((type & POLY_CLASS) == P_INTERNAL)		return;	rPosn->SetOrientation3D(orient);	UpdateMove();	}voidPolyhedron::Scale(Point3DFFixed mult, Point3DFFixed pnt)	{	if ((type & POLY_CLASS) == P_INTERNAL)		return;	if (container != NULL)		pnt = container->posn->UnTransform3D(pnt);	rPosn->Scale3D(mult, pnt);	UpdateMove();	}voidPolyhedron::ScaleTo(Point3DFFixed scal)	{	if ((type & POLY_CLASS) == P_INTERNAL)		return;	rPosn->SetScale3D(scal);	UpdateMove();	}voidPolyhedron::AddSlice(Slice *slic)	{	SurfDef *null = NULL;	if ((type & POLY_CLASS) == P_INTERNAL)		return;	SliceArray();	if (surfDef != NULL)		surfDef->Insert(SliceToSurf(slices->ALength()), &null);		slices->Append(&slic);	Update();	}voidPolyhedron::RemoveSlice(Slice *slic)	{	int sliceNum, surfNum;	SurfDef *sDef;	if ((type & POLY_CLASS) == P_INTERNAL)		return;	if (slices == NULL || (sliceNum = slices->Find(&slic)) < 0)		return;	surfNum = SliceToSurf(sliceNum);	Disconnect(surfNum, NULL, -1, -1);	if (surfDef != NULL)		{		surfDef->Get(surfNum, &sDef);		surfDef->Remove(surfNum);		if (sDef != NULL)			sDef->dSurfDef();		}	slices->Remove(sliceNum);	Update();	}voidPolyhedron::MoveEnds(FFixed pointOffset, FFixed baseOffset)	{	if (type != POLY_INFLATE)		return;	point = FFAdd(point, pointOffset);	base = FFAdd(base, baseOffset);	Update();	}voidPolyhedron::SkewEnds(PointFFixed pointOffset, PointFFixed baseOffset)	{	if (type != POLY_INFLATE)		return;	pointSkew.h = FFAdd(pointSkew.h, pointOffset.h);	pointSkew.v = FFAdd(pointSkew.v, pointOffset.v);	baseSkew.h = FFAdd(baseSkew.h, baseOffset.h);	baseSkew.v = FFAdd(baseSkew.v, baseOffset.v);	Update();	}voidPolyhedron::Invert()	{	FFixed tmp;	PointFFixed tmpPnt;	if (type != POLY_INFLATE)		return;	if (surfDef != NULL && (inflate == INFL_CONVERGE || inflate == INFL_ELLIPSE))		{		int up, num, num2;		SurfDef *sDef;		up = (FFLogic(point, base) > 0);		num = (up ? SurfCreateCount()-1 : 0);		num2 = SurfCreateCount()-1 - num;		surfDef->Get(num, &sDef);		surfDef->Remove(num);		surfDef->Insert(num2, &sDef);		}	tmp = point;	point = base;	base = tmp;		tmpPnt = pointSkew;	pointSkew = baseSkew;	baseSkew = tmpPnt;	Update();	}voidPolyhedron::SetEditType(int t)	{	editType = t;	}intPolyhedron::GetEditType()	{	return(editType);	}voidPolyhedron::SetLevels(int lvl)	{	if (type != POLY_INFLATE)		return;	if (inflate != INFL_ELLIPSE && inflate != INFL_DUALELLIPSE)		return;	ChangeInflate(inflate, lvl);	}voidPolyhedron::SetAxis(int axis)	{	defAxis = axis;	Update();	}intPolyhedron::GetAxis()	{	return(defAxis);	}voidPolyhedron::AddPoint(int num, PointFFixed coord)	{	int num2, l;	SurfDef *null = NULL;		if (type != POLY_INFLATE)		return;	if (num < 0 || num > outline->ALength())		return;	num2 = num;	if (num2 == outline->ALength()) num2 = 0;	for (l = LevelCount()-1; l >= 0; l--)		{		Disconnect(LineToSurf(num2, l), NULL, -1, -1);				if (surfDef != NULL)			surfDef->Insert(LineToSurf(num, l), &null);		}	outline->Insert(num, &coord);	Update();	}voidPolyhedron::RemovePoint(int num)	{	int num2, sNum, l;	SurfDef *sDef;	if (type != POLY_INFLATE)		return;	if (num < 0 || num >= outline->ALength() || outline->ALength() <= 3)		return;	num2 = num + 1;	if (num2 == outline->ALength()) num2 = 0;	for (l = LevelCount()-1; l >= 0; l--)		{		sNum = LineToSurf(num, l);		Disconnect(sNum, NULL, -1, -1);		Disconnect(LineToSurf(num2, l), NULL, -1, -1);			if (surfDef != NULL)			{			surfDef->Get(sNum, &sDef);			surfDef->Remove(sNum);				if (sDef != NULL)				sDef->dSurfDef();			}		}		outline->Remove(num);	Update();	}/* *	Modify number of points in outline. Assumes outline will be immediately stomped *	on with real new distinct points, followed by an Update(). */voidPolyhedron::AddPoints(int num)	{	int l, index;	PointFFixed coord;	SurfDef *null = NULL;	if (type != POLY_INFLATE)		return;	if (num < 0)		return;	index = outline->ALength();	outline->Get(index-1, &coord);	while (num-- > 0)		{		for (l = LevelCount()-1; l >= 0; l--)			{					if (surfDef != NULL)				surfDef->Insert(LineToSurf(index, l), &null);			}		outline->Insert(index, &coord);		}	/* Update(); */	}/* *	Modify number of points in outline. Assumes outline will be immediately stomped *	on with real new distinct points, followed by an Update(). */voidPolyhedron::RemovePoints(int num)	{	int index;	int sNum, l;	SurfDef *sDef;	if (type != POLY_INFLATE)		return;	if (num < 0 || num > outline->ALength() - 3)		return;	index = outline->ALength() - num;	while (num-- > 0)		{		for (l = LevelCount()-1; l >= 0; l--)			{			sNum = LineToSurf(index, l);					if (surfDef != NULL)				{				surfDef->Get(sNum, &sDef);				surfDef->Remove(sNum);						if (sDef != NULL)					sDef->dSurfDef();				}			}				outline->Remove(index);		}	/* Update(); */	}voidPolyhedron::MovePoint(int num, PointFFixed offset)	{	PointFFixed coord;	if (type != POLY_INFLATE)		return;	if (num < 0 || num >= outline->ALength())		return;	outline->Get(num, &coord);	coord.h = FFAdd(coord.h, offset.h);	coord.v = FFAdd(coord.v, offset.v);	outline->Put(num, &coord);	Update();	}voidPolyhedron::MoveLine(int num, PointFFixed offset)	{	int num2;	PointFFixed coord;	if (type != POLY_INFLATE)		return;	if (num < 0 || num >= outline->ALength())		return;	num2 = num + 1;	if (num2 == outline->ALength()) num2 = 0;	outline->Get(num, &coord);	coord.h = FFAdd(coord.h, offset.h);	coord.v = FFAdd(coord.v, offset.v);	outline->Put(num, &coord);	outline->Get(num2, &coord);	coord.h = FFAdd(coord.h, offset.h);	coord.v = FFAdd(coord.v, offset.v);	outline->Put(num2, &coord);	Update();	}SurfDef *Polyhedron::FindSurfDef(int surfNum)	{	SurfDef *sDef;	if ((type & POLY_CLASS) == P_INTERNAL)		return(NULL);	if (surfNum < 0 || surfNum >= SurfCount())		return(NULL);	if (surfDef != NULL)		surfDef->Get(surfNum, &sDef);	else		sDef = NULL;		return(sDef);	}SurfDef *Polyhedron::GetSurfDef(int surfNum)	{	SurfDef *sDef;	Surface *surf;	if ((type & POLY_CLASS) == P_INTERNAL)		return(NULL);	if (surfNum < 0 || surfNum >= SurfCount())		return(NULL);	SurfDefArray(SurfCount());	surfDef->Get(surfNum, &sDef);		if (sDef == NULL)		{		sDef = NewSurfDef();		sDef->cSurfDef(this);		/* recomputing surface rotation & outline every time is inefficient */		surf = FindSurface(surfNum);/* how to update surfaces with new surfDef? */if (surf != NULL) surf->surfDef = sDef;sDef->surface = surf;		if (surf != NULL) sDef->Update(surf->normal, surf->points, points);  // BILBIL moved line down		surfDef->Put(surfNum, &sDef);		}		return(sDef);	}intPolyhedron::Inside(Point3D pnt)	{	int nPolyCs, i, ret;	PolyConvex **polyC;	if (type == POLY_INVALID)		return(PNT_OUTSIDE);	if (type == POLY_ROOT)		return(PNT_INSIDE);	if (pieces != NULL)		{		nPolyCs = pieces->ALength();		polyC = (PolyConvex **)pieces->Use();/* needs to test "on surface" condition better */		for (i = 0; i < nPolyCs; i++, polyC++)			if ((ret = (*polyC)->Inside(pnt)) == PNT_INSIDE)				break;		pieces->Unuse();		}	else ret = piece->Inside(pnt);		return(ret);	}PolyConvex *Polyhedron::InsideContents(Point3D pnt, V_Array *viewPolys)	{	Polyhedron **poly;	PolyConvex *pce, *ret;	int nPolys, i, side;	if (contents == NULL)		return(NULL);	nPolys = contents->ALength();	poly = (Polyhedron **)contents->Use();	for (i = 0, ret = NULL; i < nPolys && ret == NULL; i++, poly++)		{		if ((*poly)->type == POLY_GROUP)			ret = (*poly)->InsideContents(pnt, viewPolys);		else			{			pce = (*poly)->piece;			if ((side = pce->Inside(pnt)) == PNT_SURFACE)				viewPolys->Append(&pce);			else if (side == PNT_INSIDE)				ret = pce;			}		}	contents->Unuse();	return(ret);	}voidPolyhedron::Update()	{	int nPolys, i;	Polyhedron *head, **poly;	head = FindContainer();	if (head != NULL)		{		head->RemoveClose(this);		head->RemoveConvex(this);		}	Build();	SliceX();	KillNullSurfs();	PositionX();	UpdateSurf();	if (head != NULL)		{		head->InstallConvex(this);		head->CompareClose(this);		}		if (contents != NULL)		{		nPolys = contents->ALength();		poly = (Polyhedron **)contents->Use();				for (i = 0; i < nPolys; i++)			InstallConvex(*poly++);			contents->Unuse();		}if (type == POLY_GROUP)CalcGroupBound();if (container != NULL && container->type == POLY_GROUP)container->CalcGroupBound();	}/* This method is a special case hack to avoid work during a simple move.  Two thingsneed to happen to make this go away:  objects must be created relative to theircontainers, and Update() must be smart enough to avoid work on its own based onhow it's updating. */voidPolyhedron::UpdateMove()	{	int nPolys, i;	Polyhedron *head, **poly;	head = FindContainer();	if (head != NULL)		head->RemoveClose(this);	PositionX();	UpdateSurf();	if (head != NULL)		head->CompareClose(this);	if (contents != NULL)		{		nPolys = contents->ALength();		poly = (Polyhedron **)contents->Use();		for (i = 0; i < nPolys; i++)			(*poly++)->UpdateMove();		contents->Unuse();		}if (type == POLY_GROUP)CalcGroupBound();if (container != NULL && container->type == POLY_GROUP)container->CalcGroupBound();	}/* this is really an update */voidPolyhedron::CalcShade()	{	int nSurfDefs, nPieces, nPolys, i;	SurfDef **sDef;	PolyConvex **piec;	Polyhedron **poly;	if (type == POLY_INVALID)		return;	if (surfDef != NULL)		{		nSurfDefs = surfDef->ALength();		sDef = (SurfDef **)surfDef->Use();		for (i = 0; i < nSurfDefs; i++, sDef++)			if (*sDef != NULL)				(*sDef)->ResolveOpacity();		surfDef->Unuse();		}	if (pieces != NULL)		{		nPieces = pieces->ALength();		piec = (PolyConvex **)pieces->Use();		for (i = 0; i < nPieces; i++)			(*piec++)->CalcShade();		pieces->Unuse();		}	else if (piece != NULL)		piece->CalcShade();	if (contents != NULL)		{		nPolys = contents->ALength();		poly = (Polyhedron **)contents->Use();		for (i = 0; i < nPolys; i++, poly++)			(*poly)->CalcShade();		contents->Unuse();		}	}typedef struct BuildInfo	{	int nSides;	int nLayers;	char topFlat, bottomFlat;	} BuildInfo;voidPolyhedron::Build()	{	KillPieces();	KillSurfPieces();		if (type == POLY_ROOT)		{		PolyConvex *newPiece;		newPiece = new(PolyConvex);		newPiece->cPolyConvex(this);		AddPiece(newPiece);		}	else if (type == POLY_GROUP)		/* nothing */ ;	else if (type == POLY_INFLATE)		{		BuildInfo info;		if (!PolyClockwise(outline))			outline->Reverse();			if (inflate == INFL_EXTRUDE)			BuildEPoints(&info);		else			BuildCPoints(&info);		BuildPieces(&info);		}	else if (type == POLY_MESH)		{		PolyConvex *newPiece;		int nSurfaces, i;		Point3D bMin, bMax;				meshPoints->CopyArray(points);				newPiece = new(PolyConvex);		newPiece->cPolyConvex(this);		AddPiece(newPiece);				nSurfaces = meshSurfs->ALength();				for (i = 0; i < nSurfaces; i++)			{			V_Array *surfPnts;						meshSurfs->Get(i, &surfPnts);			newPiece->AddSurface(surfPnts, i, FindSurfDef(i));			}				newPiece->CalcBound(BOUND_DEF);		newPiece->ExpandBound(&bMin, &bMax, BOUND_DEF);				boundMin = bMin;		boundMax = bMax;		}	}voidPolyhedron::BuildEPoints(BuildInfo *info)	{	int nOutlPoints, i, pointIndex, baseIndex;	PointFFixed *outl, pointPnt, basePnt;	Point3DFFixed *pnt;	nOutlPoints = outline->ALength();	points->SetLength(nOutlPoints + nOutlPoints);	info->nSides = nOutlPoints;	info->nLayers = 1;	info->topFlat = TRUE;	info->bottomFlat = TRUE;	if (FFLogic(point, base) > 0)		{ pointIndex = 0; baseIndex = nOutlPoints; }	else		{ pointIndex = nOutlPoints; baseIndex = 0; }	pnt = (Point3DFFixed *)points->Use();	outl = (PointFFixed *)outline->Use();	for (i = 0; i < nOutlPoints; i++, outl++)		{		pointPnt.h = FFAdd(outl->h, pointSkew.h);		pointPnt.v = FFAdd(outl->v, pointSkew.v);		basePnt.h = FFAdd(outl->h, baseSkew.h);		basePnt.v = FFAdd(outl->v, baseSkew.v);		pnt[pointIndex] = OutlToWorld(pointPnt, point);		pnt[baseIndex] = OutlToWorld(basePnt, base);		pnt++;		}	points->Unuse();	outline->Unuse();	}extern double Vsqrt(double);voidPolyhedron::BuildCPoints(BuildInfo *info)	{	FFixed upEnd, downEnd;	PointFFixed upSkew, downSkew, centerSkew, layerSkew, deltaSkew;	FFixed centerHeight, layerHeight, deltaHeight, height, nLevelsFF;	Point3DFFixed *pntCenter, *pnt;	int nPoints, nHalf, i;	double hRatio;	FFixed ellipseConst;	int up = FALSE, down = FALSE;	static FFixed one = INITFIXXED(1, 0x0000), two = INITFIXXED(2, 0x0000);	nLevelsFF.intg = levels;	nLevelsFF.frac = 0;	if (FFLogic(point, base) > 0)		{		up = TRUE;		upEnd = point; upSkew = pointSkew;		downEnd = base; downSkew = baseSkew;		}	else		{		down = TRUE;		upEnd = base; upSkew = baseSkew;		downEnd = point; downSkew = pointSkew;		}	if (inflate == INFL_DUALCONVERGE || inflate == INFL_DUALELLIPSE)		{ up = TRUE; down = TRUE; }	info->nSides = outline->ALength();	info->nLayers = (up && down ? levels+levels-2 : levels-1);	info->topFlat = (!up ? TRUE : FALSE);	info->bottomFlat = (!down ? TRUE : FALSE);	nHalf = (levels-1) * info->nSides + 1;	nPoints = nHalf + info->nSides;	if (up && down) nPoints += nHalf;	points->SetLength(nPoints);	pntCenter = (Point3DFFixed *)points->Use();	if (up) pntCenter += nHalf;	if (up && down)		{		centerHeight = FFDiv(FFAdd(base, point), two);		centerSkew.h = FFDiv(FFAdd(downSkew.h, upSkew.h), two);		centerSkew.v = FFDiv(FFAdd(downSkew.v, upSkew.v), two);		height = FFSub(upEnd, centerHeight);		deltaHeight = FFDiv(height, nLevelsFF);		deltaSkew.h = FFDiv(FFSub(upSkew.h, centerSkew.h), nLevelsFF);		deltaSkew.v = FFDiv(FFSub(upSkew.v, centerSkew.v), nLevelsFF);		}	else		{		centerHeight = base;		centerSkew = baseSkew;		height = FFSub(upEnd, downEnd);		deltaHeight = FFDiv(height, nLevelsFF);		deltaSkew.h = FFDiv(FFSub(upSkew.h, downSkew.h), nLevelsFF);		deltaSkew.v = FFDiv(FFSub(upSkew.v, downSkew.v), nLevelsFF);		}	BuildLayer(pntCenter, centerSkew, centerHeight, one);	if (up)		{		pnt = pntCenter - info->nSides;		layerHeight = FFAdd(centerHeight, deltaHeight);		layerSkew.h = FFAdd(centerSkew.h, deltaSkew.h);		layerSkew.v = FFAdd(centerSkew.v, deltaSkew.v);		for (i = 1; i < levels; i++)			{			hRatio = FixedToDbl(FFDiv(FFSub(layerHeight, centerHeight), height));	 		ellipseConst = DblToFixed(Vsqrt(1.0 - hRatio*hRatio));	 					BuildLayer(pnt, layerSkew, layerHeight, ellipseConst);			pnt -= info->nSides;			layerHeight = FFAdd(layerHeight, deltaHeight);			layerSkew.h = FFAdd(layerSkew.h, deltaSkew.h);			layerSkew.v = FFAdd(layerSkew.v, deltaSkew.v);			}		pnt += info->nSides;		*--pnt = OutlToWorld(upSkew, upEnd);		}	if (down)		{		pnt = pntCenter + info->nSides;		layerHeight = FFSub(centerHeight, deltaHeight);		layerSkew.h = FFSub(centerSkew.h, deltaSkew.h);		layerSkew.v = FFSub(centerSkew.v, deltaSkew.v);		for (i = 1; i < levels; i++)			{			hRatio = FixedToDbl(FFDiv(FFSub(layerHeight, centerHeight), height));	 		ellipseConst = DblToFixed(Vsqrt(1.0 - hRatio*hRatio));			BuildLayer(pnt, layerSkew, layerHeight, ellipseConst);						pnt += info->nSides;			layerHeight = FFSub(layerHeight, deltaHeight);			layerSkew.h = FFSub(layerSkew.h, deltaSkew.h);			layerSkew.v = FFSub(layerSkew.v, deltaSkew.v);			}		*pnt = OutlToWorld(downSkew, downEnd);		}	points->Unuse();	}voidPolyhedron::BuildLayer(Point3DFFixed *pnt, PointFFixed skew, FFixed height, FFixed scale)	{	int i, nOutlPoints;	PointFFixed *outl, layerPnt;	nOutlPoints = outline->ALength();	outl = (PointFFixed *)outline->Use();	for (i = 0; i < nOutlPoints; i++, outl++)		{		layerPnt.h = FFAdd(FFMult(outl->h, scale), skew.h);		layerPnt.v = FFAdd(FFMult(outl->v, scale), skew.v);		*pnt++ = OutlToWorld(layerPnt, height);		}	outline->Unuse();	}voidPolyhedron::BuildPieces(BuildInfo *info)	{	int nPieces;	Point3D bMin, bMax;	V_Array *surfPnts;	nPieces = 1;	bMin.x = 32767; bMin.y = 32767; bMin.z = 32767;	bMax.x = -32768; bMax.y = -32768; bMax.z = -32768;	surfPnts = new(V_Array);	surfPnts->cArray(0, sizeof(short), 4);	while (nPieces--)		{		PolyConvex *newPiece;		short pBase, p0, p1, p2;		short layerNum, pointNum, surfNum, *surfP;		newPiece = new(PolyConvex);		newPiece->cPolyConvex(this);		AddPiece(newPiece);		pBase = 0;		surfNum = 0;		if (info->topFlat)			{			p1 = pBase;			p2 = pBase + info->nSides;			surfPnts->SetLength(p2-p1);			surfP = (short *)VA_Abuse(surfPnts); // DAS-LIZARD KING 10/2/93						for (pointNum = p1; pointNum < p2; pointNum++)				*surfP++ = pointNum;			newPiece->AddSurface(surfPnts, surfNum, FindSurfDef(surfNum));			surfNum++;			}		else			{			p0 = pBase++;						for (pointNum = 0; pointNum < info->nSides; pointNum++)				{				p1 = pBase + pointNum;				p2 = p1-1;				if (pointNum == 0)					p2 += info->nSides;				surfPnts->SetLength(3);				surfP = (short *)VA_Abuse(surfPnts);// DAS-LIZARD KING 10/2/93							*surfP++ = p0;				*surfP++ = p2;				*surfP++ = p1;								newPiece->AddSurface(surfPnts, surfNum, FindSurfDef(surfNum));				surfNum++;				}			}					for (layerNum = 0; layerNum < info->nLayers; layerNum++)			{			for (pointNum = 0; pointNum < info->nSides; pointNum++)				{				p1 = pBase + pointNum;				p2 = p1-1;				if (pointNum == 0)					p2 += info->nSides;								surfPnts->SetLength(4);				surfP = (short *)VA_Abuse(surfPnts);// DAS-LIZARD KING 10/2/93								*surfP++ = p1;				*surfP++ = p2;				p1 += info->nSides;				p2 += info->nSides;								*surfP++ = p2;				*surfP++ = p1;								newPiece->AddSurface(surfPnts, surfNum, FindSurfDef(surfNum));				surfNum++;				}			pBase += info->nSides;			}		if (info->bottomFlat)			{			p1 = pBase;			p2 = pBase + info->nSides;			surfPnts->SetLength(p2-p1);			surfP = (short *)VA_Abuse(surfPnts);// DAS-LIZARD KING 10/2/93			for (pointNum = p2-1; pointNum >= p1; pointNum--)				*surfP++ = pointNum;						newPiece->AddSurface(surfPnts, surfNum, FindSurfDef(surfNum));			surfNum++;			}		else			{			p0 = pBase + info->nSides;						for (pointNum = 0; pointNum < info->nSides; pointNum++)				{				p1 = pBase + pointNum;				p2 = p1-1;				if (pointNum == 0)					p2 += info->nSides;				surfPnts->SetLength(3);				surfP = (short *)VA_Abuse(surfPnts);// DAS-LIZARD KING 10/2/93								*surfP++ = p1;				*surfP++ = p2;				*surfP++ = p0;				newPiece->AddSurface(surfPnts, surfNum, FindSurfDef(surfNum));				surfNum++;				}			}		newPiece->CalcBound(BOUND_DEF);		newPiece->ExpandBound(&bMin, &bMax, BOUND_DEF);		}	surfPnts->dArray();	boundMin = bMin;	boundMax = bMax;	}voidPolyhedron::SliceX()	{	int nPieces, i;	PolyConvex **piec;	if (pieces != NULL)		{		nPieces = pieces->ALength();		piec = (PolyConvex **)pieces->Use();		for (i = 0; i < nPieces; i++)			(*piec++)->SliceX();		pieces->Unuse();		}	else if (piece != NULL)		piece->SliceX();	}voidPolyhedron::KillNullSurfs()	{	int nPieces, i;	PolyConvex **piec;	if (pieces != NULL)		{		nPieces = pieces->ALength();		piec = (PolyConvex **)pieces->Use();		for (i = 0; i < nPieces; i++)			(*piec++)->KillNullSurfs();		pieces->Unuse();		}	else if (piece != NULL)		piece->KillNullSurfs();	}voidPolyhedron::PositionX()	{	int nPoints, nPieces, i;	Point3DFFixed *pnt, *posnPnt;	PolyConvex **piec;	Point3D bMin, bMax;	VSetCursor(vCursorEarth);	rPosn->Copy(posn);	if (container != NULL)		posn->PositionX(container->posn);	nPoints = points->ALength();	posnPoints->SetLength(nPoints);		pnt = (Point3DFFixed *)points->Use();	posnPnt = (Point3DFFixed *)posnPoints->Use();	for (i = 0; i < nPoints; i++)		*posnPnt++ = posn->Transform3D(*pnt++);	points->Unuse();	posnPoints->Unuse();	bMin.x = 32767; bMin.y = 32767; bMin.z = 32767;	bMax.x = -32768; bMax.y = -32768; bMax.z = -32768;	if (pieces != NULL)		{		nPieces = pieces->ALength();		piec = (PolyConvex **)pieces->Use();		for (i = 0; i < nPieces; i++, piec++)			{			(*piec)->PositionX();			(*piec)->CalcBound(BOUND_POSN);			(*piec)->ExpandBound(&bMin, &bMax, BOUND_POSN);			}		pieces->Unuse();		}	else if (piece != NULL)		{		piece->PositionX();		piece->CalcBound(BOUND_POSN);		piece->ExpandBound(&bMin, &bMax, BOUND_POSN);		}	posnBoundMin = bMin;	posnBoundMax = bMax;	}voidPolyhedron::UpdateSurf()	{	int nPieces; 			// ABD MERGE-TEXTURE 9/13/93	PolyConvex **piec; 		// ABD MERGE-TEXTURE 9/13/93	int nSurfDefs, i;	SurfDef **sDef;	Surface *surf;	if (surfDef != NULL)		{		nSurfDefs = surfDef->ALength();		sDef = (SurfDef **)surfDef->Use();		for (i = 0; i < nSurfDefs; i++, sDef++)			{			if (*sDef != NULL && (surf = FindSurface(i)) != NULL)				(*sDef)->Update(surf->normal, surf->points, points);			}		surfDef->Unuse();		}// ABD MERGE-TEXTURE 9/13/93 [[[	// ABD TEXTURE -- need to update outline for each surface 	if (pieces != NULL)		{		nPieces = pieces->ALength();		piec = (PolyConvex **)pieces->Use();		for (i = 0; i < nPieces; i++)			(*piec++)->UpdateSurfs();		pieces->Unuse();		}	else if (piece != NULL)		piece->UpdateSurfs();			// ABD TEXTURE -- now we need to recalc the texture mappings	CalcTextureMapping();// ABD MERGE-TEXTURE 9/13/93 ]]]	}voidPolyhedron::CalcGroupBound()	{	int nPolys, i;	Polyhedron **polyIndex, *poly;	Point3D bMin, bMax;	bMin.x = 32767; bMin.y = 32767; bMin.z = 32767;	bMax.x = -32768; bMax.y = -32768; bMax.z = -32768;	if (contents != NULL)		{		nPolys = contents->ALength();		polyIndex = (Polyhedron **)contents->Use();		for (i = 0; i < nPolys; i++)			{			poly = *polyIndex++;			if (poly->posnBoundMin.x < bMin.x) bMin.x = poly->posnBoundMin.x;			if (poly->posnBoundMin.y < bMin.y) bMin.y = poly->posnBoundMin.y;			if (poly->posnBoundMin.z < bMin.z) bMin.z = poly->posnBoundMin.z;			if (poly->posnBoundMax.x > bMax.x) bMax.x = poly->posnBoundMax.x;			if (poly->posnBoundMax.y > bMax.y) bMax.y = poly->posnBoundMax.y;			if (poly->posnBoundMax.z > bMax.z) bMax.z = poly->posnBoundMax.z;			}		contents->Unuse();		}	posnBoundMin = bMin;	posnBoundMax = bMax;	}intPolyhedron::SurfCount()	{	if ((type & POLY_CLASS) == P_INTERNAL && type != POLY_ROOT)		return(-1);	return(SurfCreateCount() + SurfSliceCount());	}intPolyhedron::SurfCreateCount()	{	if (type == POLY_ROOT || type == POLY_GROUP)		return(0);	else if (type == POLY_INFLATE)		return(SurfEndCount() + SurfSideCount());	else if (type == POLY_MESH)		return(meshSurfs->ALength());	else		return(-1);	}intPolyhedron::SurfSliceCount()	{	if ((type & POLY_CLASS) == P_INTERNAL && type != POLY_ROOT)		return(-1);	if (slices != NULL)		return(slices->ALength());	else		return(0);	}intPolyhedron::SurfEndCount()	{	if (type != POLY_INFLATE)		return(-1);	if (inflate == INFL_EXTRUDE)		return(2);	else if (inflate == INFL_CONVERGE || inflate == INFL_ELLIPSE)		return(1);	else if (inflate == INFL_DUALCONVERGE || inflate == INFL_DUALELLIPSE)		return(0);	else		return(-1);	}intPolyhedron::SurfSideCount()	{	if (type != POLY_INFLATE)		return(-1);	return (outline->ALength() * LevelCount());	}intPolyhedron::LevelCount()	{	if (type != POLY_INFLATE)		return(-1);	if (inflate == INFL_EXTRUDE || inflate == INFL_CONVERGE)		return(1);	else if (inflate == INFL_DUALCONVERGE)		return(2);	else if (inflate == INFL_ELLIPSE)		return(levels);	else if (inflate == INFL_DUALELLIPSE)		return (levels << 1);	else		return(-1);	}intPolyhedron::EndSurf(int end)	{	int endCnt = SurfEndCount();	if (type != POLY_INFLATE)		return(-1);		if (end > 0)		{		if (endCnt == 2 || endCnt == 1 && FFLogic(point, base) <= 0)			return(0);		else			return(-1);		}	else		{		if (endCnt == 2 || endCnt == 1 && FFLogic(point, base) > 0)			return(SurfCreateCount()-1);		else			return(-1);		}	}intPolyhedron::LineToSurf(int lineNum, int layerNum)	{	int sNum;	if (type != POLY_INFLATE)		return(-1);	sNum = outline->ALength() * layerNum + lineNum;	if (EndSurf(1) >= 0)		return(sNum + 1);	else		return(sNum);	}intPolyhedron::SliceToSurf(int sliceNum)	{	if ((type & POLY_CLASS) == P_INTERNAL)		return(-1);	return(SurfCreateCount() + sliceNum);	}Point3DFFixedPolyhedron::SurfNormal(int surfNum)	{	Point3DFFixed normal;	PointFFixed pnt, pnt1, pnt2, *outl;	FFixed depth;	int createCnt, sliceCnt;	int p1, p2;	Slice **slice;	normal.x = FFZero;	normal.y = FFZero;	normal.z = FFZero;	if ((type & POLY_CLASS) == P_INTERNAL)		return(normal);	createCnt = SurfCreateCount();	sliceCnt = SurfSliceCount();	if (surfNum < createCnt)		{		if (type == POLY_INFLATE)			{			int topSurf, bottomSurf;			if (surfNum == (topSurf = EndSurf(1)))				{				depth.intg = 1; depth.frac = 0;				pnt.h = FFZero; pnt.v = FFZero;				normal = OutlToWorld(pnt, depth);				}			else if (surfNum == (bottomSurf = EndSurf(-1)))				{				depth.intg = -1; depth.frac = 0;				pnt.h = FFZero; pnt.v = FFZero;				normal = OutlToWorld(pnt, depth);				}			else				{				if (inflate == INFL_EXTRUDE &&/* hack to not recognize point or linear "surfaces"; not a complete solution */FFRound(base) != FFRound(point) &&					FFZero(baseSkew.h) && FFZero(baseSkew.v) &&					FFZero(pointSkew.h) && FFZero(pointSkew.v))					{					p1 = surfNum;					if (topSurf >= 0) p1--;					if (p1 == 0) p2 = outline->ALength() - 1;					else p2 = p1 - 1;										outl = (PointFFixed*)VA_Abuse(outline);// DAS-LIZARD KING 10/2/93					pnt1 = outl[p1];					pnt2 = outl[p2];										pnt.h = FFSub(pnt2.v, pnt1.v);					pnt.v = FFSub(pnt1.h, pnt2.h);					depth = FFZero;										normal = OutlToWorld(pnt, depth);					}				}			}		}	else if (surfNum < createCnt+sliceCnt)		{		slice = (Slice **)VA_Abuse(slices);// DAS-LIZARD KING 10/2/93		slice += surfNum-createCnt;		normal = (*slice)->Normal();		}	return(normal);	}intPolyhedron::PolyValid()	{	if (type == POLY_ROOT || type == POLY_GROUP)		return(TRUE);	else if (type == POLY_INFLATE)		{		if (defAxis != INFL_X && defAxis != INFL_Y && defAxis != INFL_Z)			return(FALSE);			if (inflate != INFL_EXTRUDE &&			inflate != INFL_CONVERGE && inflate != INFL_DUALCONVERGE &&			inflate != INFL_ELLIPSE && inflate != INFL_DUALELLIPSE)			return(FALSE);			if (outline->ALength() < 3)			return(FALSE);				return(TRUE);		}	else if (type == POLY_MESH)		{		if (meshPoints == NULL || meshSurfs == NULL)			return(FALSE);		return(TRUE);		}	return(FALSE);	}voidPolyhedron::SliceArray()	{	if (slices == NULL)		{		slices = new(V_Array);		slices->cArray(0, sizeof(Slice *), 4);		}	}voidPolyhedron::SurfDefArray(int n)	{	int i, length;	SurfDef *null = NULL;	if (surfDef == NULL)		{		surfDef = new(V_Array);		surfDef->cArray(n, sizeof(SurfDef *), 4);		length = 0;		}	else		{		length = surfDef->ALength();		surfDef->SetLength(n);		}			for (i = length; i < n; i++)		surfDef->Put(i, &null);	}voidPolyhedron::InstallConvex(Polyhedron *poly)	{/* need to somehow recompute convex contents all the way down */	int ncPolys, nPieces, i;	Polyhedron **cPoly;	PolyConvex **piec;	if (poly->type == POLY_GROUP)		{		if (poly->contents != NULL)			{			ncPolys = poly->contents->ALength();			cPoly = (Polyhedron **)poly->contents->Use();						for (i = 0; i < ncPolys; i++)				InstallConvex(*cPoly++);				poly->contents->Unuse();			}		}	else		{		if (pieces != NULL)			{			nPieces = pieces->ALength();			piec = (PolyConvex **)pieces->Use();			for (i = 0; i < nPieces; i++, piec++)				(*piec)->Install(poly);			pieces->Unuse();			}		else if (piece != NULL)			piece->Install(poly);		}	}voidPolyhedron::RemoveConvex(Polyhedron *poly)	{	int ncPolys, nPieces, i;	Polyhedron **cPoly;	PolyConvex **piec;	if (poly->type == POLY_GROUP)		{		if (poly->contents != NULL)			{			ncPolys = poly->contents->ALength();			cPoly = (Polyhedron **)poly->contents->Use();						for (i = 0; i < ncPolys; i++)				RemoveConvex(*cPoly++);				poly->contents->Unuse();			}		}	else		{		if (pieces != NULL)			{			nPieces = pieces->ALength();			piec = (PolyConvex **)pieces->Use();			for (i = 0; i < nPieces; i++, piec++)				(*piec)->Remove(poly);			pieces->Unuse();			}		else if (piece != NULL)			piece->Remove(poly);		}	}voidPolyhedron::CompareClose(Polyhedron *poly)	{	int ncPolys, nPolys, i;	Polyhedron **cPoly, **testPoly;	if (poly->type == POLY_GROUP)		{		if (poly->contents != NULL)			{			ncPolys = poly->contents->ALength();			cPoly = (Polyhedron **)poly->contents->Use();						for (i = 0; i < ncPolys; i++)				CompareClose(*cPoly++);				poly->contents->Unuse();			}		}	else		{		if (contents != NULL)			{			nPolys = contents->ALength();			testPoly = (Polyhedron **)contents->Use();						for (i = 0; i < nPolys; i++, testPoly++)				{				if ((*testPoly)->type == POLY_GROUP)					(*testPoly)->CompareClose(poly);				else if (*testPoly != poly)					poly->TestClose(*testPoly);				}					contents->Unuse();			}		}	}voidPolyhedron::RemoveClose(Polyhedron *poly)	{	int ncPolys, i;	Polyhedron **cPoly;	if (poly->type == POLY_GROUP)		{		if (poly->contents != NULL)			{			ncPolys = poly->contents->ALength();			cPoly = (Polyhedron **)poly->contents->Use();						for (i = 0; i < ncPolys; i++)				RemoveClose(*cPoly++);				poly->contents->Unuse();			}		}	else		poly->KillClose();	}voidPolyhedron::TestClose(Polyhedron *testPoly)	{	int nPieces, nTestPieces, i, j;	PolyConvex **piec, **testPiec;	if (pieces != NULL)		{		nPieces = pieces->ALength();		piec = (PolyConvex **)pieces->Use();				for (i = 0; i < nPieces; i++, piec++)			{			if (testPoly->pieces != NULL)				{				nTestPieces = testPoly->pieces->ALength();				testPiec = (PolyConvex **)testPoly->pieces->Use();								for (j = 0; j < nTestPieces; j++, testPiec++)					(*piec)->TestClose(*testPiec);						testPoly->pieces->Unuse();				}			else (*piec)->TestClose(testPoly->piece);			}			pieces->Unuse();		}	else		{		if (testPoly->pieces != NULL)			{			nTestPieces = testPoly->pieces->ALength();			testPiec = (PolyConvex **)testPoly->pieces->Use();						for (j = 0; j < nTestPieces; j++, testPiec++)				piece->TestClose(*testPiec);				testPoly->pieces->Unuse();			}		else piece->TestClose(testPoly->piece);		}	}voidPolyhedron::KillClose()	{	int nPieces, i;	PolyConvex **piec;		if (pieces != NULL)		{		nPieces = pieces->ALength();		piec = (PolyConvex **)pieces->Use();				for (i = 0; i < nPieces; i++, piec++)			(*piec)->KillClose();		pieces->Unuse();		}	else if (piece != NULL)		piece->KillClose();	}// jca 24MAR94 routines to indicate the state of this polyhedronintPolyhedron::IsPolySkewed(void)	{	if ((!(PtFFZero(baseSkew))) || (!(PtFFZero(pointSkew))))		return(TRUE);	else    	return(FALSE);	}intPolyhedron::IsPolyScaled(void)	{	if (!(Pt3DFFOne(rPosn->GetScale())))		return(TRUE);	else    	return(FALSE);	}intPolyhedron::IsPolyRotated(void)	{	if (!(Ang3DFFZero(rPosn->GetOrientation())))		return(TRUE);	else    	return(FALSE);	}intPolyhedron::IsPolyPointed(void)	{	if ((type == POLY_INFLATE) &&		((inflate == INFL_CONVERGE) || (inflate == INFL_DUALCONVERGE)))		return(TRUE);	else		return(FALSE);	}intPolyhedron::IsPolyRounded(void)	{	if ((type == POLY_INFLATE) &&		((inflate == INFL_ELLIPSE) || (inflate == INFL_DUALELLIPSE)))		return(TRUE);	else		return(FALSE);	}intPolyhedron::IsPolyStraight(void)	{	if ((type == POLY_INFLATE) && (inflate == INFL_EXTRUDE))		return(TRUE);	else		return(FALSE);	}intPolyhedron::GetExtrusionType(void)	{	if (type == POLY_INFLATE)		{        if ((inflate == INFL_DUALCONVERGE) || (inflate == INFL_DUALELLIPSE))			return(2);	// double extrusion		else			return(1);	// single extrusion		}    else return(0);    }intPolyhedron::CanLevelsBeChanged(void)	{	return(IsPolyRounded());	// only rounded polys have levels	}intPolyhedron::CanSidesBeChanged(void)	{	if ((type == POLY_INFLATE) && (editType == EDIT_REGPOLYGON))		return(TRUE);	else    	return(FALSE);	}intPolyhedron::IsPolyGrouped(void)	{	if (type == POLY_GROUP)		return(TRUE);	else		return(FALSE);	}Polyhedron *Polyhedron::FindContainer()	{	Polyhedron *c = container;	while (c != NULL && c->type == POLY_GROUP)		c = c->container;	return(c);	}// { DAS-VR 9/22/93 find the containing group of this object.	Polyhedron *Polyhedron::FindGroup()	{	Polyhedron *c = container;	Polyhedron *g = this;	while (c != NULL && c->type == POLY_GROUP)		{		g = c;		c = c->container;		}	return(g);	}// } DAS-VR 9/22/93 find the containing group of this object.	/* this probably goes away because more than one real surface can result from *//* a defined surface (because of convex splits) */Surface *Polyhedron::FindSurface(int surfNum)	{	int nPieces, i;	PolyConvex **piec;	Surface *surf = NULL;	if (surfNum < 0 || surfNum >= SurfCount())		return(NULL);	if (pieces != NULL)		{		nPieces = pieces->ALength();		piec = (PolyConvex **)pieces->Use();		for (i = 0; i < nPieces; i++)			{			surf = (*piec++)->FindSurface(surfNum);			if (surf != NULL) break;			}		pieces->Unuse();		}	else if (piece != NULL)		surf = piece->FindSurface(surfNum);		return(surf);	}Point3DFFixedPolyhedron::OutlToWorld(PointFFixed outlPoint, FFixed outlDepth)	{	Point3DFFixed worldPoint;	switch (defAxis)		{		case INFL_X:			worldPoint.x = outlDepth;			worldPoint.y = outlPoint.h;			worldPoint.z = outlPoint.v;			break;				case INFL_Y:			worldPoint.x = outlPoint.v;			worldPoint.y = outlDepth;			worldPoint.z = outlPoint.h;			break;				case INFL_Z:			worldPoint.x = outlPoint.h;			worldPoint.y = outlPoint.v;			worldPoint.z = outlDepth;			break;		}	return(worldPoint);	}PointFFixedPolyhedron::WorldToOutl(Point3DFFixed worldPoint)	{	PointFFixed outlPoint;	switch (defAxis)		{		case INFL_X:			outlPoint.h = worldPoint.y;			outlPoint.v = worldPoint.z;			break;				case INFL_Y:			outlPoint.h = worldPoint.z;			outlPoint.v = worldPoint.x;			break;				case INFL_Z:			outlPoint.h = worldPoint.x;			outlPoint.v = worldPoint.y;			break;		}		return(outlPoint);	}Slice *Polyhedron::NewSlice()	{	return(new(Slice));	}SurfDef *Polyhedron::NewSurfDef()	{	return(new(SurfDef));	}intPolyhedron::IORoot(V_Buffer *buf)	{	short stateFlags;	long id;	V_Array *invalid = NULL;	int err = 0;	extern int gHigherPriorityMeterInUse;		// jca 3MAR94	ObjLock((ObjectHandle)this);	if (buf->IODirection() == DATA_IN)		{// MERGE22 [[[		if (!gHigherPriorityMeterInUse)		{		MeterSetCount(buf->IOGetPosition());		if (MeterUpdate(0)) err = -2;		}// MERGE22 ]]]		if (!gHigherPriorityMeterInUse)		if (lowMemory) err = -3;		ReadState(0, &stateFlags, buf);		while (!err)			{			id = buf->OpenChunkR();			if (id == 0) break;			if (ReadState(id, &stateFlags, buf))				{				switch (id)					{					case IFF_NAME: err = IO_NAME(buf); break;					case IFF_DATA: err = IO_DATA(buf); break;					case IFF_UNIT: err = IO_UNIT(buf); break;					case IFF_LGHT: err = IO_LGHT(buf); break;					case IFF_COLR: err = IO_COLR(buf); break;					case IFF_PLGR: err = IO_PLGR(buf); break;	// MERGE-GOURAUD					case IFF_PLTX: err = IO_PLTX(buf); break;	// ABD MERGE-TEXTURE 9/13/93					case IFF_PGRP: err = IO_PRSM(buf, &invalid, TRUE); break;					case IFF_PRSM: err = IO_PRSM(buf, &invalid, FALSE); break;					case IFF_CONN: err = IO_CONN(buf, invalid); break;					}				}			else err = IO_ReadExtra(buf, id);			buf->CloseChunk();			}				ReadState(1, &stateFlags, buf);		if (invalid != NULL) invalid->dArray();// MERGE22 [[[		if (!gHigherPriorityMeterInUse)		{		MeterSetCount(buf->IOGetPosition());		if (MeterUpdate(0)) err = -2;		}// MERGE22 ]]]		if (lowMemory) err = -3;		}	else		{		IO_WriteFirst(buf);		if (name != NULL)			{			buf->OpenChunkW(IFF_NAME);			name->IO(buf);			buf->CloseChunk();			}		if (data != NULL)			{			buf->OpenChunkW(IFF_DATA);			data->IO(buf);			buf->CloseChunk();			}		if (unit != NULL)			{			buf->OpenChunkW(IFF_UNIT);			unit->IO(buf);			buf->CloseChunk();			}		if (lights != NULL)			{			buf->OpenChunkW(IFF_LGHT);			lights->IO(buf);			buf->CloseChunk();			}		buf->OpenChunkW(IFF_COLR);		IO_COLR(buf);		buf->CloseChunk();		IO_WriteLast(buf);		MeterSetCount(MeterGetCount() + 1);		if (MeterUpdate(0)) err = -2;		if (!err && contents != NULL)			err = IO_Contents(buf);		}		ObjUnlock((ObjectHandle)this);	return(err);	}intPolyhedron::IOGroup(V_Buffer *buf)	{	short stateFlags;	long id;	V_Array *invalid = NULL;	int err = 0;	extern int gHigherPriorityMeterInUse;	// jca 3MAR94 now in txtrsrvr	ObjLock((ObjectHandle)this);	if (buf->IODirection() == DATA_IN)		{// MERGE 22 [[[		if (!gHigherPriorityMeterInUse)		{			MeterSetCount(buf->IOGetPosition());			if (MeterUpdate(0)) err = -2;		}// MERGE 22 ]]]		if (lowMemory) err = -3;		ReadState(0, &stateFlags, buf);		type = POLY_GROUP;		while (!err)			{			id = buf->OpenChunkR();			if (id == 0) break;			if (ReadState(id, &stateFlags, buf))				{				switch (id)					{					case IFF_NAME: err = IO_NAME(buf); break;					case IFF_DATA: err = IO_DATA(buf); break;					case IFF_UNIT: err = IO_UNIT(buf); break;					case IFF_POSN: err = IO_POSN(buf); break;					case IFF_PGRP: err = IO_PRSM(buf, &invalid, TRUE); break;					case IFF_PRSM: err = IO_PRSM(buf, &invalid, FALSE); break;					case IFF_CONN: err = IO_CONN(buf, invalid); break;					}				}			else err = IO_ReadExtra(buf, id);			buf->CloseChunk();			}				ReadState(1, &stateFlags, buf);		if (invalid != NULL) invalid->dArray();// MERGE22 [[[		if (!gHigherPriorityMeterInUse)		{			MeterSetCount(buf->IOGetPosition());			if (MeterUpdate(0)) err = -2;		}// MERGE22 ]]]		if (lowMemory) err = -3;		}	else		{		IO_WriteFirst(buf);		if (name != NULL)			{			buf->OpenChunkW(IFF_NAME);			name->IO(buf);			buf->CloseChunk();			}		if (data != NULL)			{			buf->OpenChunkW(IFF_DATA);			data->IO(buf);			buf->CloseChunk();			}		if (unit != NULL)			{			buf->OpenChunkW(IFF_UNIT);			unit->IO(buf);			buf->CloseChunk();			}		buf->OpenChunkW(IFF_POSN);		IO_POSN(buf);		buf->CloseChunk();		IO_WriteLast(buf);		MeterSetCount(MeterGetCount() + 1);		if (MeterUpdate(0)) err = -2;		if (!err && contents != NULL)			err = IO_Contents(buf);		}		ObjUnlock((ObjectHandle)this);	return(err);	}intPolyhedron::IO(V_Buffer *buf)	{	short stateFlags;	long id;	V_Array *invalid = NULL;	int err = 0;	extern int gHigherPriorityMeterInUse;	// MERGE22	ObjLock((ObjectHandle)this);	if (buf->IODirection() == DATA_IN)		{// MERGE22 [[[		if (!gHigherPriorityMeterInUse)		{			MeterSetCount(buf->IOGetPosition());			if (MeterUpdate(0)) err = -2;		}// MERGE22 ]]]		if (lowMemory) err = -3;		ReadState(0, &stateFlags, buf);		while (!err)			{			id = buf->OpenChunkR();			if (id == 0) break;			if (ReadState(id, &stateFlags, buf))				{				switch (id)					{					case IFF_NAME: err = IO_NAME(buf); break;					case IFF_DATA: err = IO_DATA(buf); break;					case IFF_UNIT: err = IO_UNIT(buf); break;					case IFF_LGHT: err = IO_LGHT(buf); break;					case IFF_COLR: err = IO_COLR(buf); break;					case IFF_PLGR: err = IO_PLGR(buf); break;	// MERGE-GOURAUD					case IFF_PLTX: err = IO_PLTX(buf); break;	// ABD MERGE-TEXTURE 9/14/93					case IFF_POLY: err = IO_POLY(buf); break;					case IFF_MESH: err = IO_MESH(buf); break;											#if VRML_ANCHOR				// VRML-ABD 23JUN95					case IFF_VRAN: err = IO_VRAN(buf); break;					#endif // VRML_ANCHOR					case IFF_SLIC: err = IO_SLIC(buf); break;					case IFF_SURF: err = IO_SURF(buf); break;					case IFF_POSN: err = IO_POSN(buf); break;					case IFF_PGRP: err = IO_PRSM(buf, &invalid, TRUE); break;					case IFF_PRSM: err = IO_PRSM(buf, &invalid, FALSE); break;					case IFF_CONN: err = IO_CONN(buf, invalid); break;					}				}			else err = IO_ReadExtra(buf, id);			buf->CloseChunk();			}				ReadState(1, &stateFlags, buf);		if (invalid != NULL) invalid->dArray();// MERGE22 [[[		if (!gHigherPriorityMeterInUse)		{		MeterSetCount(buf->IOGetPosition());		if (MeterUpdate(0)) err = -2;		}// MERGE22 ]]]		if (lowMemory) err = -3;		}	else		{		IO_WriteFirst(buf);			if (name != NULL)			{			buf->OpenChunkW(IFF_NAME);			name->IO(buf);			buf->CloseChunk();			}		if (data != NULL)			{			buf->OpenChunkW(IFF_DATA);			data->IO(buf);			buf->CloseChunk();			}		if (unit != NULL)			{			buf->OpenChunkW(IFF_UNIT);			unit->IO(buf);			buf->CloseChunk();			}		if (lights != NULL)			{			buf->OpenChunkW(IFF_LGHT);			lights->IO(buf);			buf->CloseChunk();			}		buf->OpenChunkW(IFF_COLR);		IO_COLR(buf);		buf->CloseChunk();		// MERGE-GOURAUD [[[		buf->OpenChunkW(IFF_PLGR);		IO_PLGR(buf);		buf->CloseChunk();		// MERGE-GOURAUD ]]]		if (type == POLY_INFLATE)			{			buf->OpenChunkW(IFF_POLY);			IO_POLY(buf);			buf->CloseChunk();			}		else if (type == POLY_MESH)			{			buf->OpenChunkW(IFF_MESH);			IO_MESH(buf);			buf->CloseChunk();			}		if (slices != NULL)			{			buf->OpenChunkW(IFF_SLIC);			IO_SLIC(buf);			buf->CloseChunk();			}// ABD MERGE-TEXTURE 9/13/93 [[[		if ((insideTexture != NULL) || (outsideTexture != NULL))	// ABD TEXTURE			{			buf->OpenChunkW(IFF_PLTX);			IO_PLTX(buf);			buf->CloseChunk();			}// ABD MERGE-TEXTURE 9/13/93 ]]]		if (surfDef != NULL)			IO_SurfDefs(buf);		buf->OpenChunkW(IFF_POSN);		IO_POSN(buf);		buf->CloseChunk();		#if VRML_ANCHOR			// VRML-ABD 23JUN95		if (HasVRMLAnchor())		{			buf->OpenChunkW(IFF_VRAN);			IO_VRAN(buf);			buf->CloseChunk();		}		#endif // VRML_ANCHOR		IO_WriteLast(buf);		MeterSetCount(MeterGetCount() + 1);		if (MeterUpdate(0)) err = -2;		if (!err && contents != NULL)			err = IO_Contents(buf);		}		ObjUnlock((ObjectHandle)this);	return(err);	}#define FLAG_Create		0x0001#define FLAG_LGHT		0x0002#define FLAG_COLR		0x0004#define FLAG_SLIC		0x0008#define FLAG_POSN		0x0010#define FLAG_Contents	0x0020#define FLAG_NAME		0x0040#define FLAG_DATA		0x0080#define FLAG_UNIT		0x0100#define FLAG_PLTX		0x0200		// ABD MERGE-TEXTURE 9/13/93#define FLAG_PLGR		0x0400		// ABD MERGE-GOURAUD#define FLAG_VRAN		0x0800		// VRML-ABD 23JUN95intPolyhedron::ReadState(long id, short *flags, V_Buffer *buf)	{	int ret = TRUE;	switch (id)		{		case 0:			*flags = 0;			break;		case IFF_NAME:			if (*flags & (FLAG_NAME|FLAG_Contents))				ret = FALSE;			*flags |= FLAG_NAME;			break;		case IFF_DATA:			if (*flags & (FLAG_DATA|FLAG_Contents))				ret = FALSE;			*flags |= FLAG_DATA;			break;		case IFF_UNIT:			if (*flags & (FLAG_UNIT|FLAG_Contents))				ret = FALSE;						*flags |= FLAG_UNIT;			break;		case IFF_LGHT:			if (*flags & (FLAG_LGHT|FLAG_Contents))				ret = FALSE;			*flags |= FLAG_LGHT;			break;		case IFF_COLR:			if (*flags & (FLAG_COLR|FLAG_Contents))				ret = FALSE;			*flags |= FLAG_COLR;			break;// ABD MERGE-TEXTURE 9/13/93 [[[		case IFF_PLTX:									// ABD TEXTURE			if (*flags & (FLAG_PLTX|FLAG_Contents))				ret = FALSE;			*flags |= FLAG_PLTX;			break;// ABD MERGE-TEXTURE 9/13/93 ]]]// ABD MERGE-GOURAUD [[[		case IFF_PLGR:			if (*flags & (FLAG_PLGR|FLAG_Contents))				ret = FALSE;			*flags |= FLAG_PLGR;			break;// ABD MERGE-GOURAUD ]]]		case IFF_POLY:		case IFF_MESH:			if (*flags & (FLAG_Create|FLAG_Contents))				ret = FALSE;			*flags |= FLAG_Create;			break;		case IFF_SLIC:			if (*flags & (FLAG_SLIC|FLAG_Contents))				ret = FALSE;			*flags |= FLAG_SLIC;			break;		case IFF_SURF:			if (*flags & FLAG_Contents)				ret = FALSE;			break;		case IFF_POSN:			if (*flags & (FLAG_POSN|FLAG_Contents))				ret = FALSE;			*flags |= FLAG_POSN;			break;		case IFF_PGRP:		case IFF_PRSM:		case IFF_CONN:			if (!(*flags & FLAG_Create) && type != POLY_ROOT && type != POLY_GROUP)				ret = FALSE;			else if (!(*flags & FLAG_Contents))				{				Update();				*flags |= FLAG_Contents;				}			break;					#if VRML_ANCHOR				// VRML-ABD 23JUN95		case IFF_VRAN:			if (*flags & (FLAG_VRAN|FLAG_Contents))				ret = FALSE;			*flags |= FLAG_VRAN;			break;		#endif // VRML_ANCHOR				case 1:			if (!(*flags & FLAG_Contents))				Update();			break;				default:			ret = FALSE;			break;		}		return (ret);	}intPolyhedron::IO_Contents(V_Buffer *buf)	{	int conn = FALSE;	int nPolys, i;	Polyhedron **poly;	int err = 0;	nPolys = contents->ALength();	poly = (Polyhedron **)contents->Use();	for (i = 0; !err && i < nPolys; i++, poly++)		{		if ((*poly)->type == POLY_GROUP)			{			err = buf->OpenChunkW(IFF_PGRP);			if (!err) err = (*poly)->IOGroup(buf);			if (!err) buf->CloseChunk();			}		else			{			err = buf->OpenChunkW(IFF_PRSM);			if (!err) err = (*poly)->IO(buf);			if (!err) buf->CloseChunk();			if ((*poly)->Connected(NULL, SDEF_PEER) ||				(*poly)->Connected(NULL, SDEF_CONTAINER))				conn = TRUE;			}		}	contents->Unuse();		if (!err && conn)		{		err = buf->OpenChunkW(IFF_CONN);		if (!err) err = IO_CONN(buf, NULL);		if (!err) buf->CloseChunk();		}	return(err);	}intPolyhedron::IO_PRSM(V_Buffer *buf, V_Array **invalid, int group)	{	Polyhedron *poly;	int err = 0;	if (buf->IODirection() == DATA_IN)		{		if (group)			{			poly = drawing->NewPolyhedron();			poly->cPolyhedron(drawing);		    err = poly->IOGroup(buf);			}		else			{			poly = drawing->NewPolyhedron();			poly->cPolyhedron(drawing);			err = poly->IO(buf);			}		if (!err && poly->PolyValid())			Install(poly);		else			{			short polyNum;						if (*invalid == NULL)				{				*invalid = new(V_Array);				(*invalid)->cArray(0, sizeof(short), 4);				}				polyNum = (*invalid)->ALength();			if (contents != NULL) polyNum += contents->ALength();			(*invalid)->Append(&polyNum);			poly->dPolyhedron();			}		}	return(err);	}intPolyhedron::IO_CONN(V_Buffer *buf, V_Array *invalid)	{	short nConnections;	short nConn;	short nPolys, nSurfDefs;	short fromPolyNum, fromSurfNum, toPolyNum, toSurfNum;	Polyhedron **polyIndex, *fromPoly, *toPoly;	SurfDef **surfIndex;	V_Array *surfArray;	long nPosition, endPosition;	int err = 0;		if (buf->IODirection() == DATA_IN)		{		err = buf->IOType(&nConnections, IO_SHORT);		nPolys = contents->ALength();				while (nConnections--)			{			buf->IOType(&fromPolyNum, IO_SHORT);			buf->IOType(&fromSurfNum, IO_SHORT);			buf->IOType(&toPolyNum, IO_SHORT);			buf->IOType(&toSurfNum, IO_SHORT);			if (invalid != NULL)				{				int nInvalid, i;				short *inv;				int fromDiff = 0, toDiff = 0;				nInvalid = invalid->ALength();				inv = (short *)invalid->Use();								for (i = 0; i < nInvalid; i++, inv++)					{					if (fromPolyNum == *inv || toPolyNum == *inv)						break;										if (fromPolyNum > *inv) fromDiff++;					if (toPolyNum > *inv) toDiff++;					}					invalid->Unuse();								fromPolyNum -= fromDiff;				toPolyNum -= toDiff;					if (i != nInvalid)					continue;				}			if (toPolyNum >= 0 && toPolyNum < nPolys)				{				if (fromPolyNum >= 0 && fromPolyNum < nPolys)					{					contents->Get(fromPolyNum, &fromPoly);					contents->Get(toPolyNum, &toPoly);						fromPoly->Connect(fromSurfNum, toPoly, toSurfNum);					}				else if (fromPolyNum == -1)					{					contents->Get(toPolyNum, &toPoly);					Connect(fromSurfNum, toPoly, toSurfNum);					}				}			}		}	else		{/* need to get poly & surf numbers more efficiently than V_Array Find() */		nPosition = buf->IOGetPosition();		nConnections = 0;		buf->IOType(&nConnections, IO_SHORT);		nPolys = contents->ALength();		polyIndex = (Polyhedron **)contents->Use();		for (fromPolyNum = 0; fromPolyNum < nPolys; fromPolyNum++, polyIndex++)			{			surfArray = (*polyIndex)->surfDef;			if (surfArray != NULL)				{				nSurfDefs = surfArray->ALength();				surfIndex = (SurfDef **)surfArray->Use();				/* ask surfDef for connection info */				for (fromSurfNum = 0; fromSurfNum < nSurfDefs; fromSurfNum++, surfIndex++)					{					if (*surfIndex != NULL)						{						(*surfIndex)->IO_CONN(buf, fromPolyNum, fromSurfNum,							contents, &nConn);						nConnections += nConn;						}					}				surfArray->Unuse();				}			}		contents->Unuse();		endPosition = buf->IOGetPosition();		buf->IOTypePosition(&nConnections, IO_SHORT, nPosition);		buf->IOSetPosition(endPosition);		}	return(err);	}intPolyhedron::IO_NAME(V_Buffer *buf)	{	int err = 0;	name = new(V_Array);	name->cArray(buf->ChunkSize(), 1, 16);	name->IO(buf);	return(err);	}intPolyhedron::IO_DATA(V_Buffer *buf)	{	int err = 0;	data = new(V_Array);	data->cArray(buf->ChunkSize(), 1, 16);	data->IO(buf);	return(err);	}intPolyhedron::IO_UNIT(V_Buffer *buf)	{	int err = 0;	unit = new(Unit);	unit->cUnit();	unit->IO(buf);	return(err);	}intPolyhedron::IO_LGHT(V_Buffer *buf)	{	int err = 0;	lights = new(LightModel);	lights->cLightModel();	lights->IO(buf);CalcShade();	return(err);	}intPolyhedron::IO_COLR(V_Buffer *buf)	{	RGBAColor clr1, clr2;	int err = 0;	if (buf->IODirection() == DATA_IN)		{		IOType(buf, &clr1, IO_RGBA_COLOR);		IOType(buf, &clr2, IO_RGBA_COLOR);				insideColor.red = clr1.red;		insideColor.green = clr1.green;		insideColor.blue = clr1.blue;		outsideColor.red = clr2.red;		outsideColor.green = clr2.green;		outsideColor.blue = clr2.blue;				opacity = clr2.alpha;		}	else		{		clr1.red = insideColor.red;		clr1.green = insideColor.green;		clr1.blue = insideColor.blue;		clr1.alpha = 0;		clr2.red = outsideColor.red;		clr2.green = outsideColor.green;		clr2.blue = outsideColor.blue;		clr2.alpha = opacity;		IOType(buf, &clr1, IO_RGBA_COLOR);		IOType(buf, &clr2, IO_RGBA_COLOR);		}	return(err);	}intPolyhedron::IO_POLY(V_Buffer *buf)	{	short nPoints, i;	PointFFixed *outlPnt;	int err = 0;	if (buf->IODirection() == DATA_IN)		{		type = POLY_INFLATE;		buf->IOType(&editType, IO_SHORT);		buf->IOType(&defAxis, IO_CHAR);		buf->IOType(&inflate, IO_CHAR);		buf->IOType(&levels, IO_SHORT);		IOType(buf, &point, IO_FFIXED);		IOType(buf, &base, IO_FFIXED);			IOType(buf, &pointSkew, IO_POINT_FFIXED);		IOType(buf, &baseSkew, IO_POINT_FFIXED);		buf->IOType(&nPoints, IO_SHORT);		outline->SetLength(nPoints);		outlPnt = (PointFFixed *)outline->Use();		for (i = 0; i < nPoints; i++)			IOType(buf, outlPnt++, IO_POINT_FFIXED);		outline->Unuse();		}	else		{		buf->IOType(&editType, IO_SHORT);		buf->IOType(&defAxis, IO_CHAR);		buf->IOType(&inflate, IO_CHAR);		buf->IOType(&levels, IO_SHORT);			IOType(buf, &point, IO_FFIXED);		IOType(buf, &base, IO_FFIXED);			IOType(buf, &pointSkew, IO_POINT_FFIXED);		IOType(buf, &baseSkew, IO_POINT_FFIXED);		nPoints = outline->ALength();		buf->IOType(&nPoints, IO_SHORT);		outlPnt = (PointFFixed *)outline->Use();		for (i = 0; i < nPoints; i++)			err= IOType(buf, outlPnt++, IO_POINT_FFIXED);		outline->Unuse();		}	return(err);	}intPolyhedron::IO_MESH(V_Buffer *buf)	{	short nPoints, nSurfaces, nSurfPoints, i, j;	Point3DFFixed *pnt;	V_Array **surf;	short *pntRef;	int err = 0;	if (buf->IODirection() == DATA_IN)		{		type = POLY_MESH;		buf->IOType(&nPoints, IO_SHORT);		meshPoints = new(V_Array);		meshPoints->cArray(nPoints, sizeof(Point3DFFixed), 4);		pnt = (Point3DFFixed *)meshPoints->Use();		for (i = 0; i < nPoints; i++)			IOType(buf, pnt++, IO_POINT3D_FFIXED);		meshPoints->Unuse();		buf->IOType(&nSurfaces, IO_SHORT);		meshSurfs = new(V_Array);		meshSurfs->cArray(nSurfaces, sizeof(V_Array *), 4);		surf = (V_Array **)meshSurfs->Use();		for (i = 0; i < nSurfaces; i++, surf++)			{			buf->IOType(&nSurfPoints, IO_SHORT);			*surf = new(V_Array);			(*surf)->cArray(nSurfPoints, sizeof(short), 4);			pntRef = (short *)(*surf)->Use();			for (j = 0; j < nSurfPoints; j++)				buf->IOType(pntRef++, IO_SHORT);			(*surf)->Unuse();			}		meshSurfs->Unuse();		}	else		{		nPoints = meshPoints->ALength();		buf->IOType(&nPoints, IO_SHORT);		pnt = (Point3DFFixed *)meshPoints->Use();		for (i = 0; i < nPoints; i++)			IOType(buf, pnt++, IO_POINT3D_FFIXED);		meshPoints->Unuse();		nSurfaces = meshSurfs->ALength();		buf->IOType(&nSurfaces, IO_SHORT);		surf = (V_Array **)meshSurfs->Use();		for (i = 0; i < nSurfaces; i++, surf++)			{			nSurfPoints = (*surf)->ALength();			buf->IOType(&nSurfPoints, IO_SHORT);			pntRef = (short *)(*surf)->Use();			for (j = 0; j < nSurfPoints; j++)				buf->IOType(pntRef++, IO_SHORT);			(*surf)->Unuse();			}		meshSurfs->Unuse();		}	return(err);	}intPolyhedron::IO_SLIC(V_Buffer *buf)	{	short nSlices, i;	Slice **slice, *slic;	int err = 0;	if (buf->IODirection() == DATA_IN)		{		SliceArray();		buf->IOType(&nSlices, IO_SHORT);				for (i = 0; i < nSlices; i++)			{			slic = NewSlice();			err = slic->IO(buf);			if(!err) slices->Append(&slic);            if(err) break;			}		if (surfDef != NULL)			SurfDefArray(SurfCount());		}	else		{		nSlices = slices->ALength();		buf->IOType(&nSlices, IO_SHORT);		slice = (Slice **)slices->Use();		for (i = 0; i < nSlices; i++)			(*slice++)->IO(buf);		slices->Unuse();		}	return(err);	}intPolyhedron::IO_SurfDefs(V_Buffer *buf)	{	short nSurfDefs, sNum;	SurfDef **sDefIndex;	int err = 0;	nSurfDefs = surfDef->ALength();	sDefIndex = (SurfDef **)surfDef->Use();	for (sNum = 0; sNum < nSurfDefs; sNum++, sDefIndex++)		{		// VRML-ABD 23JUN95		// ABD NOTE: This was changed from (*sDefIndex)->flags & SDEF_IO because there		// may be times when we want to write out the SurfDef, but the flags don't 		// indicate that.  So there is a new routine, ShouldWriteSurfDef() that 		// returns TRUE if we should write out the SurfDef.		if (*sDefIndex != NULL && ((*sDefIndex)->ShouldWriteSurfDef()))			{			buf->OpenChunkW(IFF_SURF);			buf->IOType(&sNum, IO_SHORT);			(*sDefIndex)->IO(buf);			buf->CloseChunk();			}		}	surfDef->Unuse();	return(err);	}intPolyhedron::IO_SURF(V_Buffer *buf)	{	SurfDef *sDef;	short sNum;	int err = 0;	err = buf->IOType(&sNum, IO_SHORT);	if (!err && sNum >= 0 && sNum < SurfCount())		{		SurfDefArray(SurfCount());		surfDef->Get(sNum, &sDef);				if (sDef == NULL)			{			sDef = NewSurfDef();			sDef->cSurfDef(this);			err = sDef->IO(buf);			if (!err) surfDef->Put(sNum, &sDef);			else sDef->dSurfDef();			}		}	return(err);	}intPolyhedron::IO_POSN(V_Buffer *buf)	{	int err = 0;	posn->IO_3D(buf);		if (buf->IODirection() == DATA_IN)		posn->Copy(rPosn);	return(err);	}intPolyhedron::IO_ReadExtra(V_Buffer *buf, long id)	{	return(0);	}intPolyhedron::IO_WriteFirst(V_Buffer *buf)	{	return(0);	}intPolyhedron::IO_WriteLast(V_Buffer *buf)	{	return(0);	}// MERGE-GOURAUD [[[voidPolyhedron::SetShadeType(unsigned char sh, short where){	if (where == SURF_SHARED)	{		insideShadeType = sh;		outsideShadeType = sh;	}	else if (where == SURF_INSIDE)		insideShadeType = sh;	else 		outsideShadeType = sh;}unsigned charPolyhedron::GetShadeType(short where){	if (where == SURF_INSIDE)		return insideShadeType;	else 		return outsideShadeType;}intPolyhedron::IO_PLGR(V_Buffer *buf)	{	unsigned char sh1, sh2;	int err = 0;	if (buf->IODirection() == DATA_IN)		{		buf->IOType(&sh1, IO_CHAR);		buf->IOType(&sh2, IO_CHAR);				insideShadeType = sh1;		outsideShadeType = sh2;		}	else		{		sh1 = insideShadeType;		sh2 = outsideShadeType;		buf->IOType(&sh1, IO_CHAR);		buf->IOType(&sh2, IO_CHAR);		}	return(err);	}// MERGE-GOURAUD ]]]#if VRML_ANCHOR				// VRML-ABD 23JUN95voidPolyhedron::SetVRMLAnchor(char *new_anchor){char *str;int i;	#if DEBUG	if (new_anchor == NULL)		DEBUGGER();	#endif // DEBUG		if (vrml_anchor != NULL)		vrml_anchor->dArray();		vrml_anchor = new(V_Array);	vrml_anchor->cArray(0, sizeof(char), 4);	vrml_anchor->SetLength(strlen(new_anchor));	str = (char *)vrml_anchor->Use();	for ( i = 0 ; i < strlen(new_anchor) ; i++ )		str[i] = new_anchor[i];	vrml_anchor->Unuse();}V_Array *Polyhedron::GetVRMLAnchor(){	return vrml_anchor;}intPolyhedron::HasVRMLAnchor(){	return (vrml_anchor != NULL);}intPolyhedron::IO_VRAN(V_Buffer *buf){int err = 0;		if (buf->IODirection() == DATA_IN)	{		vrml_anchor = new(V_Array);		vrml_anchor->cArray(buf->ChunkSize(), sizeof(char), 4);	}			err = vrml_anchor->IO(buf);	return(err);}#endif // VRML_ANCHOR