/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	 *				David W. Easter *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "DispArry.h"#include "View.h"#include "PolyConv.h"#include "Surface.h"#include <stddef.h>/* *	Return a value less than, equal to, or greater than 0 corresponding to *	'a' less than, equivalent to, or greater than 'b' in sort order.  Elements *	nearer the viewpoint are considered greater. */#define pcA		(*(PolyConvex **)a)#define pcB		(*(PolyConvex **)b)#define Overlap(poly1,poly2) (!(poly1->rendBoundMax.x < poly2->rendBoundMin.x ||	\								poly1->rendBoundMin.x > poly2->rendBoundMax.x ||	\								poly1->rendBoundMax.z < poly2->rendBoundMin.z ||	\								poly1->rendBoundMin.z > poly2->rendBoundMax.z))intDispArray::Compare(void *a, void *b)	{	return(pcB->rendBoundMin.y - pcA->rendBoundMin.y>>6);//DAS - HIRES	}/* void DispArray::CleanUp(View *view)  * This method assumes that the polyhedra in a somewhat useful order based upon the * results of the QuickSort algorithm.  We use the close polyhedra list to determine  * who goes in front of who. * Modified 12/13/90 by DAS to implement new sorting method */voidDispArray::CleanUp(View *view)/*DAS 12/13/90*/	{/* test bounding box in compare */	int nClose, i, j, k, l,switchNum;	PolyConvex **polyIndex,**polyIndex2, *poly;	ClosePolys *close;/*---specify the current order of the objects, so I can find out where the other is.*/	polyIndex = (PolyConvex **)Use();    polyIndex2 = polyIndex;	for (i = 0; i < length; i++, polyIndex++)		{		(*polyIndex)->index = i;		(*polyIndex)->lastIndex = -1;		(*polyIndex)->lastCount = 0;		}/*---go through all of the polyhedra and determine their relative order*/	polyIndex = polyIndex2;	for (i = 0; i < length; i++, polyIndex++)		{		poly = *polyIndex;		if (poly->closePolys == NULL)			continue;/*---this test keeps us from falling into an infinite loop*/		if (poly->lastIndex == i /*&& ++poly->lastCount >= length-i */)			continue;				nClose = VA_Length(poly->closePolys);		close = (ClosePolys *)VA_Abuse(poly->closePolys);		switchNum=-1;/*---test each of the near by polyhedra to see if they are misordered*/		for (j = 0; j < nClose; j++, close++)			if (close->poly->visible && 	/*is the other one even visible?*/				i < close->poly->index &&	/*is his index greater then mine?*/				(switchNum==-1||switchNum>close->poly->index) &&/*we wish to switch as close to this one as possible*/				Overlap(poly,close->poly) &&	/*do the projections of the polyhedra overlap?*/				CleanCompare(close,view))	/*what is their true order? (based upon visible surfaces)*/					switchNum=close->poly->index;		if(switchNum>=0)			{			if (poly->lastIndex != i)				{				poly->lastIndex = i;				poly->lastCount = 0;				}			k = switchNum - i;			poly=polyIndex[k];			for (l = k-1; l >=0; l--)				{				polyIndex[l+1] = polyIndex[l];				polyIndex[l+1]->index++;				}							polyIndex[0] = poly;			polyIndex[0]->index -= k;							i--;			polyIndex--;			}		}	Unuse();	}/*DAS 12/13/90 completely reworked to support new sorting method*/intDispArray::CleanCompare(ClosePolys *close,View *view)	{	Point3D viewPoint,vector,norm;	long dotProd,tmpL;		viewPoint = view->point;	vector.x = close->center.x - viewPoint.x;	vector.y = close->center.y - viewPoint.y;	vector.z = close->center.z - viewPoint.z;			norm = close->normal;			dotProd = (long)vector.x * norm.x;	tmpL =  (long)vector.y * norm.y;	dotProd += tmpL;	tmpL = (long)vector.z * norm.z;	dotProd += tmpL;			if (dotProd < 0)return FALSE;	else return TRUE;	}