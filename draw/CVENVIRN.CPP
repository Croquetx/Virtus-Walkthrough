/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  * Platform: 	MACINTOSH 	X *				WINDOWS		 *------------------------------------------------------------------------------ */ #include "VTypes.h"#include "CVEnvirn.h"#include "Polyhdrn.h"#include "WalkDefs.h"#include "VMath.h"#include "Geometry.h"#include "VArray.h"#include "VGraphic.h"#include "VDisplay.h"#include "VGUtil.h"#include <stdlib.h>#include <math.h>void CAVEnvironment::cCAVEnvironment() 	{	primPenSize = 1;	secPenSize = 1;	}	void CAVEnvironment::dCAVEnvironment()  { delete(this); }int CAVEnvironment::GetCAVDepth()  { return(depth); }int  CAVEnvironment::GetView() { return(view); }int  CAVEnvironment::GetSide() 	{	int side;	switch(view)		{		case insideView: side = SURF_INSIDE; break;		case outsideView:side = SURF_OUTSIDE; break;		}	return(side); 	}void  CAVEnvironment::SetSide(int side) 	{	switch(side)		{		case SURF_INSIDE: view = insideView; break;		case SURF_OUTSIDE:view = outsideView; break;		} 	}		int CAVEnvironment::GetAxis() 	{	switch(view)		{		case topView: case bottomView: case insideView: case outsideView: return(INFL_Z); break;		case rightView: case leftView: return(INFL_X); break;		case frontView: case backView: return(INFL_Y); break;		}	}	void CAVEnvironment::SetPenSizes(int prm,int sec) 	{	primPenSize = prm;	secPenSize = sec;	}void CAVEnvironment::SetView(int newView) 	{ if(view != newView) view = newView; }void CAVEnvironment::SetID(int newID) 	{ uniqueID = newID; }int CAVEnvironment::GetID() 	{ return(uniqueID); }	FFixed CAVEnvironment::GetScale() 	{ return(scale); }PointLong CAVEnvironment::GetOrigin() 	{ return(origin); }PointLong CAVEnvironment::GetDrawOrigin() 	{ return(drawOrigin); }void CAVEnvironment::SetEnvironment(Rect	*dr,Rect *wr,PointLong org,FFixed sc,int dpt) 	{	Point	pt;	FFixed	tmp;		tmp = FFZero;		dataRect = *dr;	dataRect.left-=5;dataRect.right+=5;dataRect.top-=5;dataRect.bottom+=5;	worldRect = *wr;	origin = org;	scale = sc;	depth = dpt;	drawOrigin.h = origin.h;	drawOrigin.v = origin.v;		tmp.intg = worldRect.left; 		wmin.h =  FFLongMult(tmp,scale); 	tmp.intg = -worldRect.bottom; 	wmax.v =  FFLongMult(tmp,scale); 	tmp.intg = worldRect.right; 	wmax.h =  FFLongMult(tmp,scale); 	tmp.intg = -worldRect.top; 		wmin.v =  FFLongMult(tmp,scale); 		pt.h = drawOrigin.h;	pt.v = drawOrigin.v;		VSelectPatternOrigin(pt);	}voidCAVEnvironment::SetPatternOrigin(){Point	pt;	pt.h = drawOrigin.h;	pt.v = drawOrigin.v;		VSelectPatternOrigin(pt);}int CAVEnvironment::PointInWorld(PointLong pl) 	{		if(PtInBounds(pl,wmin,wmax))		return(TRUE);	return(FALSE);	}int CAVEnvironment::RectInWorld(Rect *r) 	{		if(r->top < worldRect.bottom || r->bottom > worldRect.top		|| r->left > worldRect.right || r->right < worldRect.left)		return(FALSE);			return(TRUE);	}			Angle3DFFixedCAVEnvironment::Translate3DFFAngle(int direction,Angle3DFFixed tangle) 	{	Angle3DFFixed angle = Ang3DFFZero;		switch(direction)		{		case TO_CAD:			switch(view)				{				case topView: 							angle = tangle; 					break;									case bottomView: 						angle = tangle; 					angle.yaw = FFNeg(tangle.yaw);					break;									case frontView: 						angle.roll = tangle.yaw; 					angle.pitch = tangle.pitch; 					angle.yaw = FFNeg(tangle.roll); 					break;									case backView: 						angle.roll = tangle.yaw; 					angle.pitch = tangle.pitch; 					angle.yaw = tangle.roll; 					break;				case rightView: 						angle.roll = tangle.yaw; 					angle.pitch = tangle.roll; 					angle.yaw = tangle.pitch; 					break;				case leftView: 						angle.roll = tangle.yaw; 					angle.pitch = tangle.roll; 					angle.yaw = FFNeg(tangle.pitch); 					break;				}			break;				case TO_WORLD:			switch(view)				{				case topView: 							angle = tangle; 					break;									case bottomView: 						angle = tangle; 					angle.yaw = FFNeg(tangle.yaw);					break;									case frontView: 						angle.roll = FFNeg(tangle.yaw); 					angle.pitch = tangle.pitch; 					angle.yaw = tangle.roll; 					break;									case backView: 						angle.roll = tangle.yaw; 					angle.pitch = tangle.pitch; 					angle.yaw = tangle.roll; 					break;				case rightView: 						angle.roll = tangle.pitch; 					angle.pitch = tangle.yaw; 					angle.yaw = tangle.roll; 					break;				case leftView: 						angle.roll = tangle.pitch; 					angle.pitch = FFNeg(tangle.yaw); 					angle.yaw = tangle.roll; 					break;				}			break;		}			return(angle);	}Angle3DFFixedCAVEnvironment::TranslateFFAngle(FFixed tangle) 	{	Angle3DFFixed angle = Ang3DFFZero;		switch(view)		{		case topView: 		angle.yaw = tangle; 		break;		case bottomView: 	angle.yaw = FFNeg(tangle); 	break;		case frontView: 	angle.roll = FFNeg(tangle); break;		case backView: 	angle.roll = tangle; 		break;		case rightView: 	angle.pitch = tangle; 		break;		case leftView: 	angle.pitch = FFNeg(tangle);break;		case outsideView: 	angle.yaw = tangle; 		break;		case insideView: 	angle.yaw = FFNeg(tangle); 	break;		}	return(angle);	}	Point3DCAVEnvironment::Translate3D(int	transway,Point3D tp) 	{	Point3D wp;			switch(transway)		{		case TO_CAD:			switch(view)				{				case topView: wp = tp; break;				case bottomView: wp.x = -tp.x; wp.y = tp.y; wp.z = -tp.z; break;				case frontView: wp.x = tp.x; wp.y = tp.z; wp.z = -tp.y;  break;				case backView: wp.x = -tp.x; wp.y = tp.z; wp.z = -tp.y; break;				case rightView: wp.x = tp.y; wp.y = tp.z; wp.z = tp.x; break;				case leftView: wp.x = -tp.y; wp.y = tp.z; wp.z = -tp.x; break;				}			break;				case TO_WORLD:			switch(view)				{				case topView: wp = tp; break;				case bottomView: wp.x = -tp.x; wp.y = tp.y; wp.z = -tp.z; break;				case frontView: wp.x = tp.x; wp.y = -tp.z; wp.z = tp.y; break;				case backView: wp.x = -tp.x; wp.y = tp.z; wp.z = tp.y; break;				case rightView: wp.x = tp.z; wp.y = tp.x; wp.z = tp.y; break;				case leftView: wp.x = -tp.z; wp.y = -tp.x; wp.z = tp.y; break;				}			break;					}	return(wp);	}Point3DFFixed CAVEnvironment::Translate3DFFixed(int transway,Point3DFFixed tp) 	{	Point3DFFixed wp;			switch(transway)		{		case TO_CAD:			switch(view)				{				case topView: wp = tp; break;				case bottomView: wp.x = FFNeg(tp.x); wp.y = tp.y; wp.z = FFNeg(tp.z); break;				case frontView: wp.x = tp.x; wp.y = tp.z; wp.z = FFNeg(tp.y); break;				case backView: wp.x = FFNeg(tp.x); wp.y = tp.z; wp.z = tp.y; break;				case rightView: wp.x = tp.y; wp.y = tp.z; wp.z = tp.x; break;				case leftView: wp.x = FFNeg(tp.y); wp.y = tp.z; wp.z = FFNeg(tp.x); break;				case outsideView: wp = tp; break;				case insideView: wp.x = FFNeg(tp.x); wp.y = tp.y; wp.z = FFZero; break;				default: wp = tp; break;				}			break;		case TO_WORLD:			switch(view)				{				case topView: wp = tp; break;				case bottomView: wp.x = FFNeg(tp.x); wp.y = tp.y; wp.z = FFNeg(tp.z); break;				case frontView: wp.x = tp.x; wp.y = FFNeg(tp.z); wp.z = tp.y; break;				case backView: wp.x = FFNeg(tp.x); wp.y = tp.z; wp.z = tp.y; break;				case rightView: wp.x = tp.z; wp.y = tp.x; wp.z = tp.y; break;				case leftView: wp.x = FFNeg(tp.z); wp.y = FFNeg(tp.x); wp.z = tp.y; break;				case outsideView: wp = tp; break;				case insideView: wp.x = FFNeg(tp.x); wp.y = tp.y; wp.z = FFZero; break;				default: wp = tp; break;				}			break;		}	return(wp);	}Point3DFFixed CAVEnvironment::MakeVector(int direction,PointFFixed tp) 	{	Point3DFFixed	vector;		vector.x = tp.h;	vector.y = tp.v;	vector.z = FFZero;	vector = Translate3DFFixed(direction,vector);	return(vector);	}	PointFFixed CAVEnvironment::MakeOutline(int direction,Point3DFFixed vector) 	{	PointFFixed	pt;		vector = Translate3DFFixed(direction,vector);	pt.h = vector.x;	pt.v = vector.y;	return pt;	}FFixed CAVEnvironment::Translate2DAngle(int transway,FFixed lAngle) 	{	FFixed 	wAngle;		switch(view)		{		case outsideView: wAngle = lAngle; break;				case insideView:  wAngle = FFNeg(lAngle);break;		}			return(wAngle);	}PointFFixed CAVEnvironment::Translate2DFFixed(int transway,PointFFixed tp) 	{	PointFFixed 	wp;		switch(view)		{		case outsideView: wp = tp; break;				case insideView:  wp.h = FFNeg(tp.h); wp.v = tp.v; break;		}			return(wp);	}FFixedCAVEnvironment::GetAngle(Angle3DFFixed angle,int transway) 	{	FFixed	tmp;		switch(transway)		{		case TO_WORLD:			switch(view)				{				case topView: 		tmp = angle.yaw; 		break;				case bottomView: 	tmp = FFNeg(angle.yaw); break;				case frontView: 	tmp = FFNeg(angle.roll); break;				case backView: 	tmp = angle.roll; 		break;				case rightView: 	tmp = angle.pitch; 		break;				case leftView: 	tmp = FFNeg(angle.pitch); break;				case outsideView: 	tmp = angle.yaw; 		 break;				case insideView: 	tmp = FFNeg(angle.yaw);  break;				}			break;				case TO_CAD:			switch(view)				{				case topView: 		tmp = angle.yaw; 		break;				case bottomView: 	tmp = angle.yaw; break;				case frontView: 	tmp = angle.roll; break;				case backView: 	tmp = angle.roll; 		break;				case rightView: 	tmp = angle.pitch; 		break;				case leftView: 	tmp = angle.pitch; break;				case outsideView: 	tmp = angle.yaw; 		 break;				case insideView: 	tmp = FFNeg(angle.yaw);  break;				}			break;		}			return(tmp);	}Point3DLongCAVEnvironment::WorldToScale(Point3DFFixed wp)	{	Point3DLong	outPt;		wp.x = FFMult(wp.x,scale); 	wp.y = FFMult(wp.y,scale); 	wp.z = FFMult(wp.z,scale);	outPt.x = FFRound(wp.x); 	outPt.y = FFRound(wp.y); 	outPt.z = FFRound(wp.z);		return(outPt);	}	Point3DLong  CAVEnvironment::WorldToView(Point3DFFixed wp)	{	Point3DLong outPt;		wp = Translate3DFFixed(TO_CAD,wp);	outPt.x = FFLongMult(wp.x,scale); 	outPt.y = -FFLongMult(wp.y,scale); 	outPt.z = -FFLongMult(wp.z,scale);	return(outPt);	}int  CAVEnvironment::AngleToView(Angle3DFFixed orientation)	{	FFixed angle;	angle = GetAngle(orientation,TO_WORLD);	angle = FFMult(angle,radian2Degree);	if(angle.frac>0x8000)angle.intg++;	while(angle.intg >= 360) angle.intg -= 360;	while(angle.intg < 0) angle.intg += 360;	return(angle.intg);	}	PointLong  CAVEnvironment::WorldToView2D(Point3DFFixed wp)	{	PointLong outPt;		wp = Translate3DFFixed(TO_CAD,wp);	outPt.h = FFLongMult(wp.x,scale); 	outPt.v = -FFLongMult(wp.y,scale); 	return(outPt);	}PointLong  CAVEnvironment::ScalePoint(PointFFixed wp)	{	PointLong outPt;		outPt.h = FFLongMult(wp.h,scale); 	outPt.v = -FFLongMult(wp.v,scale); 		return(outPt);	}	int CAVEnvironment::NormalizeView(int axis) 	{	int objView;		switch(axis)		{		case INFL_Z:			objView = view;			break;		case INFL_Y:			switch(view)				{				case topView: objView = backView; break;				case bottomView: objView = frontView; break;				case frontView: objView = bottomView; break;				case backView: objView = topView; break;				case rightView: objView = leftView; break;				case leftView: objView = rightView; break;				}			break;		case INFL_X:			switch(view)				{				case topView: objView = backView; break;				case bottomView: objView = frontView; break;				case frontView: objView = leftView; break;				case backView: objView = rightView; break;				case rightView: objView = topView; break;				case leftView: objView = bottomView; break;				}			break;		}			return(objView);	}Point3D CAVEnvironment::TransFix(int transway,Point p1,Point3D wp) 	{	wp = Translate3D(!transway,wp);	wp.x = p1.h;	wp.y = p1.v;	wp = Translate3D(transway,wp);	return(wp);	}	int CAVEnvironment::SurfaceVisible(Point3D normal) 	{		int val;				switch(view)		{		case topView:			if(5 < abs(normal.z))				{				if(normal.z > 0) val = FACE_UP; else val = FACE_DOWN;				if(normal.x||normal.y) val |= ASKEW; else val |= PARALLEL;				return(val);				}			else				return(FACE_DOWN|PERPINDICULAR);			break;				case bottomView:			if(5 < abs(normal.z))				{				if(normal.z < 0) val = FACE_UP; else val = FACE_DOWN;				if(normal.x||normal.y) val |= ASKEW; else val |= PARALLEL;				return(val);				}			else				return(FACE_DOWN|PERPINDICULAR);			break;				case leftView:			if(5 < abs(normal.x))				{				if(normal.x < 0) val = FACE_UP; else val = FACE_DOWN;				if(normal.z||normal.y) val |= ASKEW; else val |= PARALLEL;				return(val);				}			else				return(FACE_DOWN|PERPINDICULAR);			break;				case rightView:			if(5 < abs(normal.x))				{				if(normal.x > 0) val = FACE_UP; else val = FACE_DOWN;				if(normal.z||normal.y) val |= ASKEW; else val |= PARALLEL;				return(val);				}			else				return(FACE_DOWN|PERPINDICULAR);			break;				case frontView:			if(5 < abs(normal.y))				{				if(normal.y < 0) val = FACE_UP; else val = FACE_DOWN;				if(normal.x||normal.z) val |= ASKEW; else val |= PARALLEL;				return(val);				}			else				return(FACE_DOWN|PERPINDICULAR);			break;				case backView:			if(5 < abs(normal.y))				{				if(normal.y > 0) val = FACE_UP; else val = FACE_DOWN;				if(normal.x||normal.z) val |= ASKEW; else val |= PARALLEL;				return(val);				}			else				return(FACE_DOWN|PERPINDICULAR);			break;		}	return(FALSE);	}Point3DFFixedCAVEnvironment::OrientPolyhedron(V_Array *points,Point3DFFixed center,int flag) 	{		Point3DFFixed 	tmpVertex;	FFixed			ffLength = INITFIXXED(2,0x0000);	PointFFixed 	*pt,*pt2,*pt3,ffmin,ffmax;	int 			i,length;	FFixed			tmp;		length = points->ALength();	pt = (PointFFixed*)points->Use();	pt3 = pt2 = pt;		if(flag)		{		for(i = 0; i < length; i++,pt++)			{			pt->h = FFSub(pt->h,center.x);			pt->v = FFSub(pt->v,center.y);			}		}	else		{		ffmin = PtFFMax;		ffmax = PtFFMin;		for(i = 0; i < length; i++,pt++) 			{ 			FFMin(ffmin.h,ffmin.h,pt->h);			FFMin(ffmin.v,ffmin.v,pt->v);			FFMax(ffmax.h,ffmax.h,pt->h);			FFMax(ffmax.v,ffmax.v,pt->v);			}					ffmin.h = FFDiv(ffmin.h,ffLength);		ffmax.h = FFDiv(ffmax.h,ffLength);		ffmin.v = FFDiv(ffmin.v,ffLength);		ffmax.v = FFDiv(ffmax.v,ffLength);				center.x = FFAdd(ffmin.h,ffmax.h);		center.y = FFAdd(ffmin.v,ffmax.v);		center.z = FFZero;					for(i = 0; i < length; i++,pt2++)			{			pt2->h = FFSub(pt2->h,center.x);			pt2->v = FFSub(pt2->v,center.y);			}		}			switch(view)		{			case backView:			for (i = 0; i < length; i++,pt3++)				{				tmp = pt3->h;				pt3->h = pt3->v;				pt3->v = FFNeg(tmp);					}			break;				case bottomView:		case leftView:			for (i = 0; i < length; i++,pt3++)				pt3->h = FFNeg(pt3->h);							break;				case frontView:			for (i = 0; i < length; i++,pt3++)				{				tmp = pt3->h;				pt3->h = pt3->v;				pt3->v = tmp;					}						break;				case insideView:			for (i = 0; i < length; i++,pt3++)				pt3->h = FFNeg(pt3->h);			break;				case outsideView:			break;		}									points->Unuse();		if( view != insideView && view != outsideView)		{		if(!PolyClockwise(points))			points->Reverse();		}	center = Translate3DFFixed(TO_WORLD,center);	return(center);	}Point3DFFixedCAVEnvironment::FFBounds(Point3DFFixed p1,Point3DFFixed p2,int type) 	{	Point3DFFixed	result;		p1 = Translate3DFFixed(TO_CAD,p1);	p2 = Translate3DFFixed(TO_CAD,p2);	if(0 == type)		{		FFMin(result.x,p1.x,p2.x);			FFMin(result.y,p1.y,p2.y);			FFMin(result.z,p1.z,p2.z);			}	else		{		FFMax(result.x,p1.x,p2.x);			FFMax(result.y,p1.y,p2.y);			FFMax(result.z,p1.z,p2.z);			}			return(result);	}Point3DCAVEnvironment::Bounds(Point3D p1,Point3D p2,int type) 	{	Point3D	result;		p1 = Translate3D(TO_CAD,p1);	p2 = Translate3D(TO_CAD,p2);	if(0 == type)		{		result.x = min(p1.x,p2.x);			result.y = min(p1.y,p2.y);			result.z = min(p1.z,p2.z);			}	else		{		result.x = max(p1.x,p2.x);			result.y = max(p1.y,p2.y);			result.z = max(p1.z,p2.z);					}			return(result);	}FFixedCAVEnvironment::FFExtreme(Point3DFFixed p1,Point3DFFixed p2,int type) 	{	FFixed	result;	switch(view)		{		case topView:if(!type){ FFMin(result,p1.z,p2.z); } else { FFMax(result,p1.z,p2.z); } break;		case backView:if(!type){ FFMin(result,p1.y,p2.y); } else { FFMax(result,p1.y,p2.y); }break;		case rightView:if(!type){ FFMin(result,p1.x,p2.x); } else { FFMax(result,p1.x,p2.x); }break;		case bottomView:if(type){ FFMin(result,p1.z,p2.z); } else { FFMax(result,p1.z,p2.z); result = FFNeg(result); }break;		case frontView:if(type){ FFMin(result,p1.y,p2.y); } else { FFMax(result,p1.y,p2.y); }break; 		case leftView:if(type){ FFMin(result,p1.x,p2.x); } else { FFMax(result,p1.x,p2.x); }break;		}	return(result);	}intCAVEnvironment::Extreme(Point3D p1,Point3D p2,int type) 	{	int	result;	switch(view)		{		case topView:if(!type)result = min(p1.z,p2.z); else result = max(p1.z,p2.z); break;		case backView:if(!type)result = min(p1.y,p2.y); else result = max(p1.y,p2.y); break;		case rightView:if(!type)result = min(p1.x,p2.x); else result = max(p1.x,p2.x); break;		case bottomView:if(type)result = min(p1.z,p2.z); else result = -max(p1.z,p2.z); break;		case frontView:if(type)result = min(p1.y,p2.y); else result = max(p1.y,p2.y);break; 		case leftView:if(type)result = min(p1.x,p2.x); else result = max(p1.x,p2.x); break;		}	return(result);	}Point3DFFixedPoint3D2FFixed(Point3D pt) 	{	Point3DFFixed	toPt;		toPt.x.frac = 0;	toPt.y.frac = 0;	toPt.z.frac = 0;	toPt.x.intg = pt.x;	toPt.y.intg = pt.y;	toPt.z.intg = pt.z;		return(toPt);	}Point3DFFixed2Point3D(Point3DFFixed pt) 	{	Point3D	toPt;		toPt.x = FFRound(pt.x);	toPt.y = FFRound(pt.y);	toPt.z = FFRound(pt.z);		return(toPt);	}PointFFixedPoint2FFixed(Point pt) 	{	PointFFixed	toPt;		toPt.h.frac = 0;	toPt.v.frac = 0;	toPt.h.intg = pt.h;	toPt.v.intg = pt.v;		return(toPt);	}PointFFixed2Point(PointFFixed pt) 	{	Point	toPt;		toPt.h = FFRound(pt.h);	toPt.v = FFRound(pt.v);	return(toPt);	}