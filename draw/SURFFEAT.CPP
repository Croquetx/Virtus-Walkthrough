/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	 *				David W. Easter *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VDisplay.h"#include "SurfFeat.h"#include "Drawing.h"#include "Polyhdrn.h"#include "PolyConv.h"#include "SurfDef.h"#include "Surface.h"#include "Position.h"#include "Light.h"#include "View.h"#include "Clip.h"#include "Geometry.h"#include "VMDL.h"#include "WalkBuff.h"#include "VMath.h"#include "VGraphic.h"#include "VGUtil.h"#include "VArray.h"#include "VDialog.h"#include "VMemUtil.h"#include "InTransp.h"#include "Flash.h"				// ABD MERGE-TEXTURE 9/13/93#include "TextItem.h"			// ABD MERGE-TEXTURE 9/13/93#include "Unit.h"				// ABD MERGE-TEXTURE 9/13/93#include "TextSrvr.h"			// ABD MERGE-TEXTURE 9/13/93#include "AppDeflt.h"			// ABD MERGE-TEXTURE 9/13/93#include "Region.h"#include <stdlib.h>#include <stddef.h>#include <math.h>#include <string.h>extern struct TextureServer *gTextureServer;	// ABD MERGE-TEXTURE 9/13/93extern TextureShader gTextureShader;			// ABD MERGE-TEXTURE 9/13/93voidSurfFeature::cSurfFeature()	{	surfDef = NULL;	name = NULL;	data = NULL;	hidden = 0;	type = FEAT_INVALID;	editType = 0;	color = vBlack;	opacity = 0;	insideShade = vBlack;	outsideShade = vBlack;// ABD MERGE-TEXTURE 9/13/93 [[[	rawTexturePoints = new(V_Array);	// ABD TEXTURE	rawTexturePoints->cArray(0, sizeof(PointFFixed), 8);	// ABD TEXTURE	rendTexturePoints = new(V_Array);	// ABD TEXTURE	rendTexturePoints->cArray(0, sizeof(PointFFixed), 8);	// ABD TEXTURE	texture = NULL;	// ABD TEXTURE	insideTextureShade = NULL;	// ABD TEXTURE 	outsideTextureShade = NULL;	// ABD TEXTURE 	NoPerspPoints = new(V_Array);		// JAM TEXTURE	NoPerspPoints->cArray(0, sizeof(Point3DNoPersp), 8);		// JAM TEXTURE// ABD MERGE-TEXTURE 9/13/93 ]]]	outline = new(V_Array);	outline->cArray(0, sizeof(PointFFixed), 4);		posn = new(Position);	posn->cPosition();	points = new(V_Array);	points->cArray(0, sizeof(Point3DFFixed), 8);	posnPoints = new(V_Array);	posnPoints->cArray(0, sizeof(Point3DFFixed), 8);	calculated = 0;	visible = 0;	rendPoints = new(V_Array);	rendPoints->cArray(0, sizeof(Point3DLong), 8); // DAS-HIRES		#if VRML_ANCHOR			// VRML-ABD 23JUN95	vrml_anchor = NULL;	#endif // VRML_ANCHOR	}voidSurfFeature::dSurfFeature()	{	if (name != NULL)		name->dArray();	if (data != NULL)		data->dArray();			#if VRML_ANCHOR				// VRML-ABD 23JUN95	if (vrml_anchor != NULL)		vrml_anchor->dArray();	#endif // VRML_ANCHOR	outline->dArray();	points->dArray();	posnPoints->dArray();	rendPoints->dArray();		posn->dPosition();	// ABD MERGE-TEXTURE 9/13/93 [[[	NoPerspPoints->dArray();		// JAM TEXTURE	if (rawTexturePoints) rawTexturePoints->dArray();		/* ABD TEXTURE */	if (rendTexturePoints) rendTexturePoints->dArray();		/* ABD TEXTURE */	if (texture != NULL) 		texture->DocUnuseFeat(this);	// stop using the texture item// ABD MERGE-TEXTURE 9/13/93 ]]]	if (featConnections[0]) featConnections[0]->dArray();	// BILBIL - multiple surface connections	if (featConnections[1]) featConnections[1]->dArray();	// BILBIL - multiple surface connections//	if (featureRgn[0]) featureRgn[0]->dRegion();			// BILBIL - multiple surface connections//	if (featureRgn[1]) featureRgn[1]->dRegion();			// BILBIL - multiple surface connections	delete(this);	}voidSurfFeature::SetName(char *nm, int len)	{	char *vnm;	if (name == NULL)		{		name = new(V_Array);		name->cArray(0, 1, 16);		}	name->SetLength(len);	vnm = (char *)name->Use();	memmove(vnm, nm, len);	name->Unuse();	}intSurfFeature::GetName(char *nm, int len)	{	int vlen;	char *vnm;	if (name == NULL || (vlen = name->ALength()) > len)		return(-1);	vnm = (char *)name->Use();	memmove(nm, vnm, vlen);	name->Unuse();		return(vlen);	}V_Array *SurfFeature::GetNameArray()	{	return(name);	}voidSurfFeature::SetData(char *dat, int len)	{	char *vdat;	if (data == NULL)		{		data = new(V_Array);		data->cArray(0, 1, 16);		}	data->SetLength(len);	vdat = (char *)data->Use();	memmove(vdat, dat, len);	data->Unuse();	}intSurfFeature::GetData(char *dat, int len)	{	int vlen;	char *vdat;	if (data == NULL || (vlen = data->ALength()) > len)		return(-1);	vdat = (char *)data->Use();	memmove(dat, vdat, vlen);	data->Unuse();		return(vlen);	}V_Array *SurfFeature::GetDataArray()	{	return(data);	}voidSurfFeature::SetHidden(int h)	{	hidden = h;	}intSurfFeature::GetHidden()	{	return(hidden);	}voidSurfFeature::Create(V_Array *outl, PointFFixed orgn)	{	type = FEAT_POLY;		editType = EDIT_POLYGON;	outl->CopyArray(outline);	posn->SetOrigin2D(orgn);		color = vBlack;	opacity = 0xffff;	Update();	}voidSurfFeature::AddPoint(int num, PointFFixed coord)	{	if (num < 0 || num > outline->ALength()) return;	outline->Insert(num, &coord);	Update();	}voidSurfFeature::RemovePoint(int num)	{	if (num < 0 || num >= outline->ALength() || outline->ALength() <= 3) return;	outline->Remove(num);	Update();	}/* *	Modify number of points in outline. Assumes outline will be immediately stomped *	on with real new distinct points, followed by an Update(). */voidSurfFeature::AddPoints(int num)	{	int index;	PointFFixed coord;	if (num < 0) return;	index = outline->ALength();	outline->Get(index-1, &coord);	while (num-- > 0) outline->Insert(index, &coord);	/* Update(); */	}/* *	Modify number of points in outline. Assumes outline will be immediately stomped *	on with real new distinct points, followed by an Update(). */voidSurfFeature::RemovePoints(int num)	{	int index;	if (num < 0 || num > outline->ALength() - 3) return;	index = outline->ALength() - num;	while (num-- > 0) outline->Remove(index);	/* Update(); */	}voidSurfFeature::Move(PointFFixed offset)	{	posn->Move2D(offset);	Update();	}voidSurfFeature::MoveTo(PointFFixed orgn)	{	posn->SetOrigin2D(orgn);	Update();	}voidSurfFeature::Rotate(FFixed rotate, PointFFixed pnt)	{	posn->Rotate2D(rotate, pnt);	Update();	}voidSurfFeature::RotateTo(FFixed orient)	{	posn->SetOrientation2D(orient);	Update();	}voidSurfFeature::Scale(PointFFixed mult, PointFFixed pnt)	{	posn->Scale2D(mult, pnt);	Update();	}voidSurfFeature::ScaleTo(PointFFixed scal)	{	posn->SetScale2D(scal);	Update();	}voidSurfFeature::MovePoint(int num, PointFFixed offset)	{	PointFFixed coord;		if (num < 0 || num >= outline->ALength()) return;	outline->Get(num, &coord);	coord.h = FFAdd(coord.h, offset.h);	coord.v = FFAdd(coord.v, offset.v);	outline->Put(num, &coord);		Update();	}voidSurfFeature::MoveLine(int num, PointFFixed offset)	{	int num2;	PointFFixed coord;	if (num < 0 || num >= outline->ALength()) return;	num2 = num + 1;	if (num2 == outline->ALength()) num2 = 0;	outline->Get(num, &coord);	coord.h = FFAdd(coord.h, offset.h);	coord.v = FFAdd(coord.v, offset.v);	outline->Put(num, &coord);	outline->Get(num2, &coord);	coord.h = FFAdd(coord.h, offset.h);	coord.v = FFAdd(coord.v, offset.v);	outline->Put(num2, &coord);	Update();	}voidSurfFeature::ChangeUnit(FFixed factor)	{	int i, nPoints;	PointFFixed *outl;	/* Scale outline */		nPoints = outline->ALength();	outl = (PointFFixed *)outline->Use();	for (i = 0; i < nPoints; i++, outl++)		{		outl->h = FFMult(outl->h, factor);		outl->v = FFMult(outl->v, factor);		}			outline->Unuse();	/* Scale position *//* Kind of a hack for 1.04; 1.1 can use Position's Scale method */	posn->origin.x = FFMult(posn->origin.x, factor);	posn->origin.y = FFMult(posn->origin.y, factor);	}voidSurfFeature::SetColor(RGBColor clr, unsigned short opc)	{	color = clr;	opacity = opc;	// BILBIL - multiple surface connections [[[if (!IS_OPAQUE(opc))	UpdateConnections();// BILBIL - multiple surface connections ]]]	CalcShade();	}RGBColorSurfFeature::GetColor()	{	return(color);	}unsigned shortSurfFeature::GetOpacity()	{	return(opacity);	}voidSurfFeature::SetEditType(int t)	{	editType = t;	}intSurfFeature::GetEditType()	{	return(editType);	}voidSurfFeature::Update()	{	if (!PolyClockwise(outline))		outline->Reverse();	CalcTextureMapping();		// ABD MERGE-TEXTURE 9/13/93		PositionX();	PositionPoly();// ABD MERGE-TEXTURE 9/13/93 [[[	/*JAM 27Aug93	  when we alter a surface feature, we must recalculate the bounds of the polyhedron*/	if(surfDef != NULL)		if(surfDef->polyhedron != NULL)			surfDef->polyhedron->UpdateBound();// ABD MERGE-TEXTURE 9/13/93 ]]]	UpdateConnections();	// BILBIL - multiple surface connections	}voidSurfFeature::CalcShade()	{	Polyhedron *poly;	SurfDef *sd = surfDef;	int surfNum;	Surface *surf;	Point3D normal, n;	LightModel *iLight, *oLight;	VSetCursor(vCursorEarth);	if (surfDef == NULL || (poly = surfDef->polyhedron) == NULL) return;	surfNum = surfDef->polyhedron->surfDef->Find(&sd);	surf = surfDef->polyhedron->FindSurface(surfNum);	if (surf == NULL) return;	normal = surf->posnNormal;	n.x = -normal.x;	n.y = -normal.y;	n.z = -normal.z;	iLight = poly->FindLightModel();	if (poly->container != NULL)		oLight = poly->container->FindLightModel();	else		oLight = iLight;	if (iLight != NULL)		insideShade = iLight->CalcShade(color, n);	else		insideShade = vBlack;	if (oLight != NULL)		outsideShade = oLight->CalcShade(color, normal);	else		outsideShade = vBlack;	// ABD MERGE-TEXTURE 9/13/93	if (iLight != NULL)	{	FFixed shade_level = iLight->CalcShadeLevel(NUM_TEXTURE_SHADING_LEVELS, n);		// MERGE-GOURAUD					insideTextureShade = &(gTextureShader[shade_level.intg]);	// MERGE-GOURAUD // ABD TEXTURE 	}	else		insideTextureShade = &(gTextureShader[NUM_TEXTURE_SHADING_LEVELS-1]);	// black			if (oLight != NULL)	{	FFixed shade_level = oLight->CalcShadeLevel(NUM_TEXTURE_SHADING_LEVELS, normal);	// MERGE-GOURAUD			outsideTextureShade = &(gTextureShader[shade_level.intg]);	// MERGE-GOURAUD // ABD TEXTURE 	}	else		outsideTextureShade = &(gTextureShader[NUM_TEXTURE_SHADING_LEVELS-1]);	// black}// JAM bounding sphere for surf features fix 9/24/93 [[[/*JAM added for expanding bounding sphere based on surface features*/voidSurfFeature::ExpandBound(Point3D *min, Point3D *max, int which)	{	V_Array *polyPnts;	Point3DFFixed *pnt, pt;	short *surfPnt;	int nPoints, i, nFeatures;	SurfFeature **feat;		if (which == BOUND_DEF)		polyPnts = points;	else		polyPnts = posnPoints;	pnt = (Point3DFFixed *)polyPnts->Use();     // jca 27 Sept 93	nPoints = polyPnts->ALength();//	surfPnt = points->Use();		for (i = 0; i < nPoints; i++)		{		int maxX, maxY, maxZ;		//pt = pnt[*surfPnt++];		pt = pnt[i];		if (pt.x.intg < min->x) min->x = pt.x.intg;		if (pt.y.intg < min->y) min->y = pt.y.intg;		if (pt.z.intg < min->z) min->z = pt.z.intg;		maxX = pt.x.intg; if (pt.x.frac != 0) maxX++;		maxY = pt.y.intg; if (pt.y.frac != 0) maxY++;		maxZ = pt.z.intg; if (pt.z.frac != 0) maxZ++;		if (maxX > max->x) max->x = maxX;		if (maxY > max->y) max->y = maxY;		if (maxZ > max->z) max->z = maxZ;		}	polyPnts->Unuse();//	points->Unuse();		}//JAM bounding sphere fix 24Sept93 ]]]// ABD MERGE-TEXTURE 9/13/93 [[[/*	// ABD TEXTURE */intSurfFeature::IO_SFTX(V_Buffer *buf){int err = 0;long id;long txID;struct TextureItem *t;			if (buf->IODirection() == DATA_IN)	{		while (!err)		{			id = buf->OpenChunkR();			if (id == 0) break;						switch (id)			{				case IFF_TXID:	/* texture ID */				{					// DATA IN					// We read in the id number and ask the texture server for a					// texture item with that id number.  If there is already a texture					// item with that id number, then we get a pointer to it.  Otherwise					// the texture server creates a new texture item with that id number.					// in any case we will receive a ptr to a texture item, and we should					// set our texture to that texture item.  Note that we MUST call					// SetTexture() instead of setting the texture directly, because					// we have to add ourselves to the list of objects using this texture.					buf->IOType(&txID, IO_LONG);	// Write out the id.					t = gTextureServer->IDtoTexture(txID);										// use SetTextureIO which defers recalcing the texture coords					SetTextureIO(t);										// later, when the texture server reads in the id table, it will set					// the name and file ref of each of these new, blank texture items					// that it created.  If the name, when set, conflicts with a name					// that already exists in the file, then the user will be prompted					// to either rename the texture or go ahead and replace the texture					// that was there already with the new texture name/file ref.										break;				}				case IFF_TATR:	/* texture attributes */				{					break;				}			}						buf->CloseChunk();		}	}	else // DATA OUT	{				buf->OpenChunkW(IFF_TXID);	/* texture index */			// ABD 22 Mar 93 		// DATA OUT		// ask the texture server for a new local id based on this texture		// if this texture has already been written out during this file i/o, then we		// will be given the id this texture was assigned before.  Otherwise we will		// be assigned a new id.  In any case we will be given an id.			txID = gTextureServer->TexturetoID(texture);		buf->IOType(&txID, IO_LONG);	// Write out the id.		buf->CloseChunk();		buf->OpenChunkW(IFF_TATR);	/* texture attributes */		buf->CloseChunk();	}	return(err);}// ABD MERGE-TEXTURE 9/13/93 ]]]voidSurfFeature::PositionX()	{	PointFFixed *outl, pt2D, scal;	Point3DFFixed *pnt, pt3D;	int i, nPoints, inv;	if (surfDef == NULL) return;	nPoints = outline->ALength();	points->SetLength(nPoints);	outl = (PointFFixed *)outline->Use();	pnt = (Point3DFFixed *)points->Use();	pt3D.z = FFZero;	for (i = 0; i < nPoints; i++)		{		pt2D = posn->Transform2D(*outl++);		pt3D.x = pt2D.h; pt3D.y = pt2D.v;		*pnt++ = surfDef->position->Transform3D(pt3D);		}			outline->Unuse();	points->Unuse();	scal = posn->GetScale2D();	inv = FALSE;	if (FFNegative(scal.h)) inv = !inv;	if (FFNegative(scal.v)) inv = !inv;	if (inv) points->Reverse();	}voidSurfFeature::PositionPoly()	{	Polyhedron *poly;	Point3DFFixed *pnt, *posnPnt;	int i, nPoints;	if (surfDef == NULL || (poly = surfDef->polyhedron) == NULL || poly->piece == NULL)		return;	nPoints = outline->ALength();	posnPoints->SetLength(nPoints);	pnt = (Point3DFFixed *)points->Use();	posnPnt = (Point3DFFixed *)posnPoints->Use();	for (i = 0; i < nPoints; i++)		*posnPnt++ = poly->posn->Transform3D(*pnt++);			points->Unuse();	posnPoints->Unuse();	if (surfDef->polyhedron->piece->inverted)		posnPoints->Reverse();	}intSurfFeature::FeatValid()	{	if (type == FEAT_POLY)		{		if (outline->ALength() < 3)			return(FALSE);		return(TRUE);		}	else return(FALSE);	}// jca 25MAR94 info funcs [[intSurfFeature::IsFeatScaled(void){	if (!(Pt3DFFOne(posn->GetScale())))		return(TRUE);	else    	return(FALSE);}intSurfFeature::IsFeatRotated(void){	if (!(Ang3DFFZero(posn->GetOrientation())))		return(TRUE);	else    	return(FALSE);}intSurfFeature::CanSidesBeChanged(void){	if ((type == FEAT_POLY) && (editType == EDIT_REGPOLYGON))		return(TRUE);	else		return(FALSE);} // jca 25MAR94 ]]voidSurfFeature::AddConnection(int start, int end, int side)	{	long	loop;	short	plane;	Point3D	norm;	long	i;	V_Region	*sRgn;	long	sLength;	V_Array	*sList;	PointFFixed		p;	Point3DFFixed	*sSurfPt;	Connection	*connections;	long		*index;	if (surfDef == NULL) return;	if (!IS_OPAQUE(opacity) && (surfDef->flatConnections[side]))		{		// find normal so we know where to project onto		norm.x = abs(surfDef->surface->posnNormal.x);		norm.y = abs(surfDef->surface->posnNormal.y);		norm.z = abs(surfDef->surface->posnNormal.z);				if( norm.x >= norm.y && norm.x >= norm.z )			{ plane = INFL_X; }		else if( norm.y >= norm.x && norm.y >= norm.z )			{ plane = INFL_Y; }		else 			{ plane = INFL_Z; } 				if (featConnections[side] == NULL)			{			featConnections[side] = new(V_Array);			featConnections[side]->cArray(0, sizeof(Long), 4);			}		sLength = posnPoints->ALength();		sSurfPt = (Point3DFFixed*)posnPoints->Use();		sList = new(V_Array);		sList->cArray(0, sizeof(PointFFixed), 4);		for (i=0; i < sLength; i++)			{			switch (plane)				{				case INFL_X:					p.h.l = sSurfPt[i].y.l;					p.v.l = sSurfPt[i].z.l;						break;								case INFL_Y:					p.h.l = sSurfPt[i].z.l;					p.v.l = sSurfPt[i].x.l;						break;								case INFL_Z:					p.h.l = sSurfPt[i].x.l;					p.v.l = sSurfPt[i].y.l;						break;				}			sList->Append(&p);			}				posnPoints->Unuse();		sRgn = new(V_Region);		sRgn->cRegion(sList);		sList->dArray();		connections = (Connection*)surfDef->flatConnections[side]->Use();				for (loop = 0; loop < start; loop++)			{			V_Array		*bList;						if (featConnections[side]->Find(&loop)>= 0)				{				bList = new(V_Array);				bList->cArray(0, sizeof(PointFFixed), 4);				Fast2DFromConnection(&(connections[loop]), bList, &plane);				sRgn->AddCompliment(bList);				bList->dArray();				}			} 				// reset indicies that have been moved (indicies after end of insertion)		index = (long *)featConnections[side]->Use();		for (loop = end +1; loop < surfDef->flatConnections[side]->ALength(); loop++)			{			long	aIndex, realIndex = loop - (end - start +1);						if ((aIndex = featConnections[side]->Find(&realIndex))>= 0)				index[aIndex] += (end - start +1);			}		featConnections[side]->Unuse();		for (loop = start; loop <= end; loop ++)			{			V_Array		*bList;						bList = new(V_Array);			bList->cArray(0, sizeof(PointFFixed), 4);			Fast2DFromConnection(&(connections[loop]), bList, &plane);			if ((side == SIDE_OUTSIDE)||(loop < surfDef->firstContainer))  // BilBil 27MAR94				if (sRgn->AddCompliment(bList))					featConnections[side]->Append(&loop);			bList->dArray();			} 		for (loop = end +1; loop < surfDef->flatConnections[side]->ALength(); loop++)			{			V_Array		*bList;			long		aIndex;						if ((aIndex = featConnections[side]->Find(&loop))>= 0)				{				bList = new(V_Array);				bList->cArray(0, sizeof(PointFFixed), 4);				Fast2DFromConnection(&(connections[loop]), bList, &plane);				if (!sRgn->AddCompliment(bList))					featConnections[side]->Remove(aIndex);				bList->dArray();				}			} 		surfDef->flatConnections[side]->Unuse();				featConnections[side]->QuickSort();		if (sRgn->Compliment())			renderPoly[side] = TRUE;		else			renderPoly[side] = FALSE;		sRgn->dRegion();		}	else		renderPoly[side] = TRUE;	}	voidSurfFeature::RemoveConnection(int start, int end, int side)	{	long	loop, index, firstFound, lastFound = -1;	Long	*array;	Connection *conn;		if ((featConnections[side] == NULL)||(surfDef == NULL)||			(surfDef->flatConnections[side] == NULL)) return;	conn = (Connection*)surfDef->flatConnections[side]->Use();		firstFound = -1;	for (loop = end; loop >= start; loop --)		if ((index = featConnections[side]->Find(&loop)) >= 0)			{			firstFound = loop;			break;			}	while(firstFound != -1)		{		int		found = FALSE;				for(loop = firstFound +1; loop < surfDef->flatConnections[side]->ALength(); loop ++)			if (conn[loop].poly == conn[firstFound].poly->container)				{				found = TRUE;				if (featConnections[side]->Find(&loop) < 0)					featConnections[side]->Append(&loop);				break;				}		if (found == FALSE) renderPoly[side] = TRUE;		featConnections[side]->Remove(index);					firstFound = -1;		for (loop = end; loop >= start; loop --)			if ((index = featConnections[side]->Find(&loop)) >= 0)				{				firstFound = loop;				break;				}		}		for (loop = end; loop >= start; loop --)		{		if ((index = featConnections[side]->Find(&loop)) >= 0)			featConnections[side]->Remove(index);		}	array = (Long*)featConnections[side]->Use();	for (loop = end +1; loop < surfDef->flatConnections[side]->ALength(); loop ++)		{		if ((index = featConnections[side]->Find(&loop)) >= 0)			array[index] -= (end - start + 1);		}		if (featConnections[side]->ALength() == 0)		{		featConnections[side]->dArray();		featConnections[side] = NULL;		}	if (featConnections[side] == NULL)		renderPoly[side] = TRUE;	}	voidSurfFeature::UpdateConnections()	{	int	lengthOut, lengthIn;		if (surfDef == NULL) return;	if (!IS_OPAQUE(opacity) && ((surfDef->flatConnections[0])||(surfDef->flatConnections[1])))		{		if (surfDef->flatConnections[SIDE_OUTSIDE])			lengthOut = surfDef->flatConnections[SIDE_OUTSIDE]->ALength() - 1;		else lengthOut = -1;		if (surfDef->flatConnections[SIDE_INSIDE])			lengthIn = surfDef->flatConnections[SIDE_INSIDE]->ALength() - 1;		else lengthIn = -1;		if (featConnections[SIDE_INSIDE]) featConnections[SIDE_INSIDE]->SetLength(0);		if (featConnections[SIDE_OUTSIDE]) featConnections[SIDE_OUTSIDE]->SetLength(0);		AddConnection(0, lengthIn, SIDE_INSIDE);		AddConnection(0, lengthOut, SIDE_OUTSIDE);		}	else		{		renderPoly[SIDE_INSIDE] = TRUE;		renderPoly[SIDE_OUTSIDE] = TRUE;		//JAM 13JAN94 arrays need to be nulled out or undoing a		//surface feature on a connected surface will cause a crash		//bug found by jeff, fixed by greg and jeff		if (featConnections[SIDE_INSIDE])			{			featConnections[SIDE_INSIDE]->dArray();			featConnections[SIDE_INSIDE] = NULL;			}		if (featConnections[SIDE_OUTSIDE])			{            //JAM 13JAN94 these used to be SIDE_INSIDE			featConnections[SIDE_OUTSIDE]->dArray();			featConnections[SIDE_OUTSIDE] = NULL;			}		}	}//JAM 17FEB95 low memory walk rendering [[[//global and stuff for checking to see if we need to save memory on//surface features#define SURFFEATMEMCHECKINTERVAL 50int gSurfFeatMemCheckCounter = 0;//JAM 17FEB95 low memory walk rendering ]]]intSurfFeature::Calc3D(register View *view, int clipPlanes)	{	register short seq = surfDef->polyhedron->drawing->sequence;//JAM 17FEB95 low memory walk rendering [[[//global and stuff for checking to see if we need to save memory on//surface features	if ((calculated == seq) && (!gmemoryLowForSurfaceFeatures)) return(visible);//JAM 17FEB95 low memory walk rendering ]]]	calculated = seq;	visible = TRUE;	if (hidden)		{ visible = FALSE; return(FALSE); }	view->TransRot(posnPoints, rendPoints);	if (!view->ClipFeat(this, clipPlanes))		{			visible = FALSE;						//JAM 17FEB95 low memory walk rendering [[[			//if memory is running somewhat low, make surface features			//not take up more memory--deallocate room for rendpoints.			//extra stuff is so we don't have to do a freemem EVERY time			#if MACINTOSH			gSurfFeatMemCheckCounter++;			if(gSurfFeatMemCheckCounter == SURFFEATMEMCHECKINTERVAL)			{				gSurfFeatMemCheckCounter = 0;//				if(FreeMem() < SURFFEAT_RENDER_MEM_THRESHOLD)				if (!MemThreshholdTest(SURFFEAT_RENDER_MEM_THRESHOLD))				{					gmemoryLowForSurfaceFeatures = 1;				}			}			if(lowMemory || gmemoryLowForSurfaceFeatures)			{				if(rendPoints->lockCount == 0) 				{					rendPoints->dArray();					rendPoints = new(V_Array);					rendPoints->cArray(0, sizeof(Point3DLong), 8);				}			}			#endif			//JAM 17FEB95 low memory walk rendering ]]]			return(FALSE);		}	view->Project(rendPoints, NoPerspPoints, NULL, NULL);	// ABD MERGE-TEXTURE 9/13/93	return(TRUE);	}voidSurfFeature::Draw3D(View *view, Clip *clip, int inside, int where, PolyConvex *poly,	int renderPoly, V_Array *connections, V_Array *surfConnections, PolyConvex *stop,	int n, Surface *fromSurf, int fromInside, RGBAColor inheritedColor)	{	RGBColor clr, lclr;	unsigned short opc;	RGBAColor newBase;    RGBColor newColor;    V_Offscreen *texture_offscreen;		// ABD MERGE-TEXTURE 9/14/93	int has_texture = FALSE;			// ABD MERGE-TEXTURE 9/14/93	int texture_decal = FALSE;			// ABD MERGE-TEXTURE 9/14/93	TRANSPARENCY_INTERP_INIT;	struct ObjSpec obj;					// ABD 3D PICK 8/13/93	struct ObjSpec *obj_ptr = NULL;		// ABD 3D PICK 8/13/93 	// JCA PRO081893	{			// ABD MERGE-TEXTURE 9/14/93 [[[	if ((view->textures) && (texture != NULL) && ((!polyCheckMode)))	// ABD polyCheckMode needs real polys		has_texture = TRUE;		// JCA PRO081893	}			// ABD MERGE-TEXTURE 9/14/93 ]]]/*11-29-93 JAM [[[ patch to cause textures to	  not be used when doing GDI stuff*/	if(clip != NULL)    {		if (clip->method == QD_METHOD)		{    		has_texture = FALSE;		}	}/*11-29-93 JAM ]]] patch to cause textures to      not be used when doing GDI stuff*///GJR 09/24/93 [[[ check now if texture is viable	if (has_texture)		{		if (NULL == texture->GetPicture(0))			{			has_texture = FALSE;	// oops, no real texture to use. Pretend its gone.			}		}//GJR 09/24/93 ]]] check now if texture is viable	opc = opacity;	if (view->whiteShade)		{		clr = vWhite;		lclr = vBlack;		}	else		{		if (view->shade)			{			if (inside) clr = insideShade;			else clr = outsideShade;			}		else clr = color;		if (view->interpTransp)			{			if (IS_TRANSPARENT(inheritedColor.alpha))				{				newBase.alpha = opc;				InterpolateColorFirstTime(color.red, opc, newBase.red);				InterpolateColorFirstTime(color.green, opc, newBase.green);				InterpolateColorFirstTime(color.blue, opc, newBase.blue);        		}			else if (IS_TRANSLUCENT(inheritedColor.alpha))				{				InterpolateAlphaFrontToBack(opc, inheritedColor.alpha, newBase.alpha);				InterpolateColorFrontToBack(color.red, inheritedColor.red, newBase.red);				InterpolateColorFrontToBack(color.green, inheritedColor.green, newBase.green);				InterpolateColorFrontToBack(color.blue, inheritedColor.blue, newBase.blue);				InterpolateColorFrontToBack(clr.red, inheritedColor.red, newColor.red);				InterpolateColorFrontToBack(clr.green, inheritedColor.green, newColor.green);				InterpolateColorFrontToBack(clr.blue, inheritedColor.blue, newColor.blue);                clr = newColor;				}			else				{				opc = OPAQUE_NOM;	/* truncate the transparency recursion */				clr.red = inheritedColor.red;				clr.green = inheritedColor.green;				clr.blue = inheritedColor.blue;				}			}		if (!view->blackFrame)			{			lclr.red = clr.red >> 1; lclr.red += lclr.red >> 1;			lclr.green = clr.green >> 1; lclr.green += lclr.green >> 1;			lclr.blue = clr.blue >> 1; lclr.blue += lclr.blue >> 1;			}		else lclr = vBlack;		}// ABD MERGE-TEXTURE [[[	if (has_texture)		texture_decal = texture->settings.decal;	else		texture_decal = FALSE;	if ((!IS_OPAQUE(opc)) && (!((has_texture) && (!texture_decal))))// ABD MERGE-TEXTURE ]]]		{		if ((poly != NULL || connections != NULL))			{			Clip *newClip;			int nConn, i;			Connection *conn;			SurfDef *sDef;						newClip = clip->ClipPoly(rendPoints, !inside);			if (newClip != NULL)				{				if ((poly != NULL)&&(renderPoly))					poly->DrawWalk(view, newClip, stop, NULL, newBase);									if (connections != NULL && n > 0)					{					long	*index;					// BILBIL - feature connections [[[					if (surfConnections)						{						nConn = surfConnections->ALength();						conn = (Connection*)connections->Use();						index = (Long*)surfConnections->Use();						for (i = 0; i < nConn; i++, index++)							conn[*index].poly->piece->DrawWalk(view, newClip, stop, conn[*index].surf->surface, newBase);						surfConnections->Unuse();						connections->Unuse();						}// BILBIL - feature connections ]]]					}								if ((sDef = fromSurf->surfDef) != NULL)					{					int farSide = (fromInside ? SURF_OUTSIDE : SURF_INSIDE);					int s = (fromInside ? SURF_INSIDE : SURF_OUTSIDE);						if (sDef->features[farSide] != NULL || sDef->interesting[farSide][s])						fromSurf->DrawSurface(view, newClip, fromInside, SURF_FARSIDE, newBase);					}				newClip->dClip();				}			}		else			{			if (where == SURF_SHARED)				opc = OPAQUE_NOM;			}		}	// draw the surface feature polygon	// if this surface feature is visible then draw the surface feature	// and we make sure that either the surface feature has no texture to draw or the texture is	// decalled.  (if the texture is not decalled then no surface feature will show through, and so	// we will not see the surface feature). 	// also, if the surface feature is transparent and textured, then don't draw it at all	// (not even the frames)	if (((!has_texture) || (has_texture && texture_decal)) &&		(!(has_texture && IS_TRANSPARENT(opc))))		{		short v = view->drawMode;		// ABD TEXTURE		// if we are drawing a texture later, then dont frame the surface		if ((has_texture) && ((view->drawMode & CLIP_FRAME) == CLIP_FRAME))			v &= ~CLIP_FRAME;				// ABD 3D PICK 8/13/93 v			// fill in the obj spec for 3d pick			if (polyCheckMode)				{				obj.poly = surfDef->surface->polyConvex->polyhedron;		// ABD 3D PICK 8/13/93				obj.polyc = surfDef->surface->polyConvex;					// ABD 3D PICK 8/13/93				obj.surfNum = surfDef->surface->surfNum;					// ABD 3D PICK 8/13/93				obj.surfSide = (inside ? SURF_INSIDE : SURF_OUTSIDE);		// ABD 3D PICK 8/13/93				obj.surffeat = this;										// ABD 3D PICK 8/13/93				obj_ptr = &obj;				} 			// ABD 3D PICK 8/13/93 ^				if (!IS_TRANSPARENT(opc))			{			if (!IS_OPAQUE(opc) && view->fill)				{				if (!view->interpTransp)					{					if (!view->whiteShade)						clip->DrawPoly(rendPoints, view->drawMode, NULL, TRUE, vPatBlack, &clr, &lclr, !inside, obj_ptr);		// MERGE-GOURAUD		// ABD 3D PICK 8/13/93					else if (view->frame)						clip->DrawPoly(rendPoints, CLIP_FRAME, NULL, FALSE, vPatBlack, &clr, &lclr, !inside, obj_ptr);		// MERGE-GOURAUD		// ABD 3D PICK 8/13/93					}	            else if (view->frame)					clip->DrawPoly(rendPoints, CLIP_FRAME, NULL, FALSE, vPatBlack, &clr, &lclr, !inside, obj_ptr);		// MERGE-GOURAUD		// ABD 3D PICK 8/13/93				}			else clip->DrawPoly(rendPoints, view->drawMode, NULL, FALSE, vPatBlack, &clr, &lclr, !inside, obj_ptr);		// MERGE-GOURAUD		// ABD 3D PICK 8/13/93			}		else if (view->frame)			clip->DrawPoly(rendPoints, CLIP_FRAME, NULL, FALSE, vPatBlack, &clr, &lclr, !inside, obj_ptr);		// MERGE-GOURAUD		// ABD 3D PICK 8/13/93		}	// ABD MERGE-TEXTURE 9/14/93 [[[	if (view->fill && has_texture && offscreen)		{		Point *pf;	    Point *pt,c;	    Rect flip;	    long l,l2,i;	    struct TextureRendSettings rset;	    V_Array *it;	    V_Array *ai;	    V_Array *ainp;		FFixed ff_flip, ff_temp;		int flip_height; 		    rendTexturePoints->Use();	   	rendPoints->Use();	   	NoPerspPoints->Use();	   	 	texture->GetPaddedRect(&flip, 0);					ff_flip.intg = flip.bottom-flip.top;		ff_flip.frac = 0;		ff_temp = FFMult(ff_flip, texture->settings.vTiles);		flip_height = FFRound(ff_temp);    // jca 22 Sept 93  Borland can't handle combining these two lines	    		rset.decal = texture->settings.decal;		rset.colorize = texture->settings.colorize;		rset.hMirror = texture->settings.hMirror;		rset.vMirror = texture->settings.vMirror;		rset.hFlip = texture->settings.hFlip;		rset.vFlip = texture->settings.vFlip;		rset.filtered_color = texture->GetFilteredRGB();		if (texture->settings.shade)			{		    if (inside)				rset.textureShade = insideTextureShade;			else				rset.textureShade = outsideTextureShade;			}		else			rset.textureShade = &(gTextureShader[0]);					for (i = 0 ; i < MAX_NUM_MIPS ; i++ )			{			rset.mip[i] = texture->GetPicture(i);			texture->GetPaddedRect(&rset.mip_rect[i], i);			}	    	    NewIdent(rendPoints, NoPerspPoints, rendTexturePoints, flip_height, !inside,	    		 &ai, &ainp, &it);	    texture->SetupFrame();	 	Texture8(offscreen, it, ai, ainp, clip, &rset);	    rendTexturePoints->Unuse();	   	rendPoints->Unuse();	   	NoPerspPoints->Unuse();		}// ABD MERGE-TEXTURE 9/14/93 ]]]		//JAM 17FEB95 low memory walk rendering [[[		//if memory is running somewhat low, make surface features		//not take up more memory--deallocate room for rendpoints.		//extra stuff is so we don't have to do a freemem EVERY time		#if MACINTOSH		gSurfFeatMemCheckCounter++;		if(gSurfFeatMemCheckCounter == SURFFEATMEMCHECKINTERVAL)		{			gSurfFeatMemCheckCounter = 0;//			if(FreeMem() < SURFFEAT_RENDER_MEM_THRESHOLD)			if (!MemThreshholdTest(SURFFEAT_RENDER_MEM_THRESHOLD))			{				gmemoryLowForSurfaceFeatures = 1;			}		}		if(lowMemory || gmemoryLowForSurfaceFeatures)		{			if(rendPoints->lockCount == 0) 			{				rendPoints->dArray();				rendPoints = new(V_Array);				rendPoints->cArray(0, sizeof(Point3DLong), 8);			}		}		#endif		//JAM 17FEB95 low memory walk rendering ]]]	}intSurfFeature::IO(V_Buffer *buf)	{	long id;	int err = 0;	extern int gHigherPriorityMeterInUse;	ObjLock((ObjectHandle)this);	if (buf->IODirection() == DATA_IN)		{		while (!err)			{			id = buf->OpenChunkR();			if (id == 0) break;						switch (id)				{				case IFF_NAME: err = IO_NAME(buf); break;				case IFF_DATA: err = IO_DATA(buf); break;				case IFF_COLR: err = IO_COLR(buf); break;				case IFF_SFTX: err = IO_SFTX(buf); break;	// MERGE27				case IFF_POLY: err = IO_POLY(buf); break;				case IFF_POSN: err = posn->IO_2D(buf); break;				#if VRML_ANCHOR			// VRML-ABD 23JUN95				case IFF_VRAN:					err = IO_VRAN(buf);					break;				#endif // VRML_ANCHOR				}						buf->CloseChunk();			}		// MERGE22 [[[		if (!gHigherPriorityMeterInUse)			{			MeterSetCount(buf->IOGetPosition());			if (MeterUpdate(0)) err = -2;			}// MERGE22 ]]]		if (lowMemory) err = -3;		}	else		{				if (name != NULL)			{			buf->OpenChunkW(IFF_NAME);			name->IO(buf);			buf->CloseChunk();			}		if (data != NULL)			{			buf->OpenChunkW(IFF_DATA);			data->IO(buf);			buf->CloseChunk();			}		buf->OpenChunkW(IFF_COLR);		IO_COLR(buf);		buf->CloseChunk();		// ABD MERGE27 [[[		if (texture != NULL)			{			buf->OpenChunkW(IFF_SFTX);			IO_SFTX(buf);			buf->CloseChunk();			}		// ABD MERGE27 ]]]		#if VRML_ANCHOR			// VRML-ABD 23JUN95		if (HasVRMLAnchor())		{			buf->OpenChunkW(IFF_VRAN);			IO_VRAN(buf);			buf->CloseChunk();		}		#endif // VRML_ANCHOR		buf->OpenChunkW(IFF_POLY);		IO_POLY(buf);		buf->CloseChunk();				buf->OpenChunkW(IFF_POSN);		posn->IO_2D(buf);		buf->CloseChunk();		}	ObjUnlock((ObjectHandle)this);	return(err);	}intSurfFeature::IO_NAME(V_Buffer *buf)	{	int err = 0;	name = new(V_Array);	name->cArray(buf->ChunkSize(), 1, 16);	name->IO(buf);	return(err);	}intSurfFeature::IO_DATA(V_Buffer *buf)	{	int err = 0;	data = new(V_Array);	data->cArray(buf->ChunkSize(), 1, 16);	data->IO(buf);	return(err);	}intSurfFeature::IO_COLR(V_Buffer *buf)	{	RGBAColor clr;	int err = 0;	if (buf->IODirection() == DATA_IN)		{		IOType(buf, &clr, IO_RGBA_COLOR);		color.red = clr.red;		color.green = clr.green;		color.blue = clr.blue;		opacity = clr.alpha;		}	else		{		clr.red = color.red;		clr.green = color.green;		clr.blue = color.blue;		clr.alpha = opacity;		IOType(buf, &clr, IO_RGBA_COLOR);		}// BILBIL - multiple surface connections [[[if (!IS_OPAQUE(opacity))	UpdateConnections();// BILBIL - multiple surface connections ]]]	return(err);	}intSurfFeature::IO_POLY(V_Buffer *buf)	{	short nPoints, i;	PointFFixed *outlPnt;	int err = 0;	if (buf->IODirection() == DATA_IN)		{		type = FEAT_POLY;		buf->IOType(&editType, IO_SHORT);		buf->IOType(&nPoints, IO_SHORT);		outline->SetLength(nPoints);		outlPnt = (PointFFixed *)outline->Use();		for (i = 0; i < nPoints; i++)			IOType(buf, outlPnt++, IO_POINT_FFIXED);		outline->Unuse();		}	else		{		buf->IOType(&editType, IO_SHORT);		nPoints = outline->ALength();		buf->IOType(&nPoints, IO_SHORT);		outlPnt = (PointFFixed *)outline->Use();		for (i = 0; i < nPoints; i++)			IOType(buf, outlPnt++, IO_POINT_FFIXED);		outline->Unuse();		}	return(err);	}// ABD MERGE-TEXTURE 9/13/93 [[[/* ----- TEXTURE STUFF ----- */voidSurfFeature::CalcTextureMapping(){TextureItem *t;Rect r,r2;	// if this texture is a real texture (not NULL) then create our raw texture point	// list if it doesn't already exist	t = GetTexture();	if (t != NULL)	{	Point *raw;	int i;	double meters_per_unit;	        //JAM altered this stuff to use default unit if there is no unit//		if (!surfDef) return;//		if (!surfDef->polyhedron) return;//		if (!surfDef->polyhedron->GetUnit()) return;		if (!outline) return;		if (!surfDef) return;		if (!surfDef->polyhedron) return;		if (!surfDef->polyhedron->GetUnit())		{        	meters_per_unit = 0.0254;	//use inches as default		}		else		{			meters_per_unit = surfDef->polyhedron->GetUnit()->GetSize();        }		t->GetPaddedRect(&r,0);		t->GetUnpaddedRect(&r2,0);		ObjLock(this);			// ABD MERGE-MEM		MakeTextureArray(outline, &rawTexturePoints, &r, &r2,	// ABD MERGE-MEM			t->settings.use_real_world_size_h,			t->settings.use_real_world_size_v,			t->settings.hUnit,			t->settings.vUnit,			t->settings.hPixels_per_unit,			t->settings.vPixels_per_unit,			t->settings.hTiles,			t->settings.vTiles,			meters_per_unit			);		ObjUnlock(this);			// ABD MERGE-MEM	}}voidSurfFeature::SetTexture(struct TextureItem *t){ 	/* don't do anything if the textures are the same already */	if (t != texture) 	{ 		SetTextureIO(t);	 		 // calc the texture mapping		 CalcTextureMapping();	 }}voidSurfFeature::SetTextureIO(struct TextureItem *t){int err = 0;SurfFeature *local_sf = this; 	/* don't do anything if the textures are the same already */	if (t != texture) 	{ 		/*  			we don't DocUnuse a texture if it is no texture (NULL).  we need to DocUnuse() 			it if it is not NULL so that the picture can be unloaded if no one else 			is using the picture.  		*/		if (texture != NULL) 			texture->DocUnuseFeat(local_sf);				/*				we need to DocUse() this texture so that the picture can be loaded.			note that t might be NULL (no texture) so we have to check it first 		*/		if (t != NULL) 		{			err = t->DocUseFeat(local_sf);						if (err)			{				/*					some kind of error, probably not enough memory to load picture					note that Draw3D automagically uses the thumbnail pict if it 					can't find the picture, so we don't really need to do anything					here 				*/			}		}		/* set the texture to the new texture */		texture = t;#if 0// we might want to ask the user if he wants to use the thumbnail or revert back// to old texture		/* set the texture to the new texture if there was no error */		if (!err) 			texture = t;		else		{			/* 				there was an error, so set texture to old texture.  Another 				possibility is to set the texture to no texture (NULL) if 				this causes thrashing. 			*/			if (texture != NULL) texture->DocUseFeat(local_sf);		}#endif	 	 // calc the texture mapping	 CalcTextureMapping();	 }}voidSurfFeature::GetTextureInfo(V_Offscreen **off, Rect *r)	{	}struct V_Array *SurfFeature::GetRawTexturePoints()			// ABD TEXTURE{	return rawTexturePoints;}struct V_Array *SurfFeature::GetRendTexturePoints()			// ABD TEXTURE{	return rendTexturePoints;}struct TextureItem *SurfFeature::GetTexture()	{	return(texture);	}// ABD MERGE-TEXTURE 9/13/93 ]]]// PRO25 [[[voidSurfFeature::GetTextureName(char *name)	{	if (texture != NULL)		strcpy(name, texture->settings.name); 	else		strcpy(name, "");	}// PRO25 ]]]#if VRML_ANCHOR				// VRML-ABD 23JUN95voidSurfFeature::SetVRMLAnchor(char *new_anchor){char *str;int i;	#if DEBUG	if (new_anchor == NULL)		DEBUGGER();	#endif // DEBUG		if (vrml_anchor != NULL)		vrml_anchor->dArray();	vrml_anchor = new(V_Array);	vrml_anchor->cArray(0, sizeof(char), 4);	vrml_anchor->SetLength(strlen(new_anchor));	str = (char *)vrml_anchor->Use();	for ( i = 0 ; i < strlen(new_anchor) ; i++ )		str[i] = new_anchor[i];	vrml_anchor->Unuse();}V_Array *SurfFeature::GetVRMLAnchor(){	return vrml_anchor;}intSurfFeature::HasVRMLAnchor(){	return (vrml_anchor != NULL);}intSurfFeature::IO_VRAN(V_Buffer *buf){int err = 0;	if (buf->IODirection() == DATA_IN)	{		vrml_anchor = new(V_Array);		vrml_anchor->cArray(buf->ChunkSize(), sizeof(char), 4);	}			err = vrml_anchor->IO(buf);	return(err);}#endif // VRML_ANCHOR