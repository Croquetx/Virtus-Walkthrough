#include "VTypes.h"#if USE_HMD			// ABD HMD MAR95#include "HMD.h"#include "View.h"#include "Drawing.h"#include "VPane.h"#include "VGraphic.h"#include "VGUtil.h"#include "VMath.h"#include "vdebug.h"#include "Observer.h"#include "Position.h"#include "Flash.h"#include <math.h>#include <stddef.h>#include <stdio.h>#include "VDialog.h"#include "VItem.h"#include "AppDeflt.h"#include "Vwcntrl.h"#include "VWI.h"#include "VWCntrl.h"#include "ToolDef.h"#include "Wlkcntrl.h"#include "VWindow.h"#include "WalkPane.h"// ABD HMD MAR95 changed globals herestruct HMD *gHMD;		// ABD HMD MAR95int gUseHMDs = FALSE;	// ABD HMD MAR95int gSavedOldFilmWidth = FALSE;short gOldFilmWidth = 36;short gOldFocalLength = 35;/*=============================================================================================*//* OBSERVER ROUTINES *//*=============================================================================================*/#if 0		// ABD HMD JUL95// ABD HMD MAR95/*-----------------------------------------------------------------------------*//*	The Observer routine that tells us if we are to render stereo or not	(TRUE is stereo).  Use this routine, not GetHMD(), because GetHMD() will	always return TRUE even if stereo drawing is not on.*/intObserver::UseHMDs(){	return use_hmds;		// ABD HMD MAR95 don't use global}// ABD HMD MAR95#endif// HMD MAR95 removed DefaultHMD()/*-----------------------------------------------------------------------------*//*	The Observer routine for drawing a stereo frame.  If we have an hmd, then call that	routine to draw a frame, otherwise just call the default Observer->Draw routine to	draw a mono frame.*/voidObserver::DrawHMD(int cancelable, int clipToScreen){AppPreference *appPref = controller->GetPreference();HMDPreference *hmdPref = (HMDPreference*)appPref->GetPreference(preferHMD);	// if we have an hmd, then draw with that	if ((use_hmds) && (hmd))	// ABD HMD MAR95	{		if (hmdPref->hmd_type != hmd->hmd_type)		{			CreateHMD(hmdPref->hmd_type);		}		gHMD = hmd;			// ABD HMD MAR95		gUseHMDs = TRUE;	// ABD HMD MAR95		hmd->Draw(cancelable, clipToScreen);		gUseHMDs = FALSE;	// ABD HMD MAR95		//gHMD = NULL;		// ABD HMD MAR95	}	else		Draw(cancelable, clipToScreen);		// otherwise just do default Observer::Draw()}/*-----------------------------------------------------------------------------*//*	This routine creates an HMD of the appropriate type for the observer.	observer->hmd must be NULL or a valid hmd before calling CreateHMD, because	CreateHMD destroys the existing hmd.  We don't want it to try to destroy 	random memory, so NULL out hmd in a newly created observer before calling CreateHMD.*/intObserver::CreateHMD(int hmd_type_code){int err = HMD_NO_ERR;	// first, dispose of the current hmd -- we can only have one active at a time.	if (hmd != NULL)		DestroyHMD();	switch (hmd_type_code)	{		case HMD_STEREO_PAIR:			hmd = new(HMDStereoPair);			hmd->cHMD(hmd_type_code, this);			break;		case HMD_CYBERSCOPE:			hmd = new(HMDCyberScope);			hmd->cHMD(hmd_type_code, this);			break;		case HMD_VREX:			hmd = new(HMDVRex);			hmd->cHMD(hmd_type_code, this);			break;		case HMD_CRYSTALEYES:			hmd = new(HMDCrystalEyes);			hmd->cHMD(hmd_type_code, this);			break;		default:								// unimplemented HMD type			hmd = new(HMDStereoPair);			// default back to stereo pair			hmd->cHMD(hmd_type_code, this);		// (must always have *some* HMD)			err = HMD_ERROR;					// return an error			DEBUGGER();			break;	}		// save it in our global	gHMD = hmd;		return err;}/*-----------------------------------------------------------------------------*//*	This routine destroys an HMD, if there is one.*/voidObserver::DestroyHMD(){	// make sure we have an HMD before we try to destroy it	if (hmd != NULL)	{ 		hmd->dHMD();		hmd = NULL;			// set our instance variable to NULL		gHMD = NULL;		// set our global to NULL	}}#if 0		// ABD HMD JUL95/*-----------------------------------------------------------------------------*//*	This routine returns an HMD, if there is one, which there never is for a 	View object, so it just return NULL.  This is so we can call GetHMD from	within a view object and not have to know if we are an Observer or just	a View object*/struct HMD *View::GetHMD() { return NULL; }#endif#if 0		// ABD HMD JUL95/*-----------------------------------------------------------------------------*//*	See Observer::UseHMDs()*/int View::UseHMDs() { return gUseHMDs; }#endif#if 0		// ABD HMD JUL95/*-----------------------------------------------------------------------------*//*	This routine returns an HMD, if there is one.*/struct HMD *Observer::GetHMD() { return hmd; }#endif /*-----------------------------------------------------------------------------*//**/voidObserver::SetFFPointTemp(Point3DFFixed pnt){Point3D	tmpPt;			tmpPt.x = FFRound(pnt.x);	tmpPt.y = FFRound(pnt.y);	tmpPt.z = FFRound(pnt.z);		SetPointTemp(tmpPt);}	/*-----------------------------------------------------------------------------*//**/voidObserver::SetFFAngleTemp(Angle3DFFixed angl){Angle3D	tmpAngle;			tmpAngle.roll = FFRound(angl.roll);	tmpAngle.pitch = FFRound(angl.pitch);	tmpAngle.yaw = FFRound(angl.yaw);	SetAngleTemp(tmpAngle);}/*-----------------------------------------------------------------------------*//**/voidObserver::SetPointTemp(Point3D pnt){	// NOTE that we don't change lastPoint	FFpoint.x.frac = FFpoint.y.frac = FFpoint.z.frac = 0;	FFpoint.x.intg = pnt.x;	FFpoint.y.intg = pnt.y;	FFpoint.z.intg = pnt.z;	View::SetPoint(pnt);}	/*-----------------------------------------------------------------------------*//**/voidObserver::SetAngleTemp(Angle3D angl){	// NOTE that we don't change lastAngle	FFangle.roll.frac = FFangle.pitch.frac = FFangle.yaw.frac = 0;	FFangle.roll.intg = angl.roll;	FFangle.pitch.intg = angl.pitch;	FFangle.yaw.intg = angl.yaw;	View::SetAngle(angl);}/*=============================================================================================*//* HMD SETTINGS DIALOG ROUTINES *//*=============================================================================================*/int  HMDDialog::cHMDDialog(FFixed *ff_ipd, FFixed *ff_wp, FFixed *ff_dp, FFixed *ff_dv, short *yblank){V_Text *title;V_CtrlButton_Die *button;V_Array	*buttonGroup;V_EditText *ipd, *wp, *dp, *dv, *yb;V_Text *statText;Rect r;int	success;short new_yblank;char str[256];double d;	VSetRect(&r, 0, 0, 382, 194);	CenterDialog(&r,r.right-r.left,r.bottom-r.top,0);	cDialog(&r);	frame = 3;    SetTitle("HMD Settings");		title = new(V_Text);	title->cItem();	VSetRect(&r, 8, 8, 370, 24);	title->SetRect(&r);	title->SetText("HMD Settings (all values in inches except YBLANK)");	AddItem(title);	ipd = new(V_EditText);	ipd->cItem();	VSetRect(&r, 240, 32, 369, 48);	ipd->SetRect(&r);	d = FixedToDbl(*ff_ipd);	sprintf(str, "%.2f", d);	ipd->SetText(str);	AddItem(ipd);	wp = new(V_EditText);	wp->cItem();	VSetRect(&r, 240, 56, 369, 72);	wp->SetRect(&r);	d = FixedToDbl(*ff_wp);	sprintf(str, "%.2f", d);	wp->SetText(str);	AddItem(wp);	dp = new(V_EditText);	dp->cItem();	VSetRect(&r, 240, 80, 369, 96);	dp->SetRect(&r);	d = FixedToDbl(*ff_dp);	sprintf(str, "%.2f", d);	dp->SetText(str);	AddItem(dp);	dv = new(V_EditText);	dv->cItem();	VSetRect(&r, 240, 104, 369, 120);	dv->SetRect(&r);	d = FixedToDbl(*ff_dv);	sprintf(str, "%.2f", d);	dv->SetText(str);	AddItem(dv);	yb = new(V_EditText);	yb->cItem();	VSetRect(&r, 240, 128, 369, 144);	yb->SetRect(&r);	sprintf(str, "%d", *yblank);	yb->SetText(str);	AddItem(yb);	statText = new(V_Text);	statText->cItem();	VSetRect(&r, 8, 32, 233, 48);	statText->SetRect(&r);	statText->SetText("Inter-Pupilary Distance (IPD)");	AddItem(statText);	statText = new(V_Text);	statText->cItem();	VSetRect(&r, 8, 56, 233, 72);	statText->SetRect(&r);	statText->SetText("Width of Physical Image (Wp)");	AddItem(statText);	statText = new(V_Text);	statText->cItem();	VSetRect(&r, 8, 80, 233, 96);	statText->SetRect(&r);	statText->SetText("Dist from Viewer to Screen (Dp)");	AddItem(statText);	statText = new(V_Text);	statText->cItem();	VSetRect(&r, 8, 104, 233, 120);	statText->SetRect(&r);	statText->SetText("Dist to Virtual Screen (Dv)");	AddItem(statText);	statText = new(V_Text);	statText->cItem();	VSetRect(&r, 8, 128, 233, 144);	statText->SetRect(&r);	statText->SetText("CrystalEyes YBLANK (in pixels)");	AddItem(statText);	buttonGroup = new(V_Array);	buttonGroup->cArray(0,sizeof(V_CtrlButton_Die*),4);	button = new(V_CtrlButton_Die);	button->cItem();	VSetRect(&r, 280, 160, 359, 180);	button->SetRect(&r);	button->SetText(systemLayoutSpec[inputOK].title);	button->SetFlag(TRUE);	button->SetGroup(buttonGroup);	SetDefBtn(button);#if WINDOWS    button->SetCtrlNumber(IDOK);#endif	AddItem(button);	button = new(V_CtrlButton_Die);	button->cItem();	VSetRect(&r, 16, 160, 95, 180);	button->SetRect(&r);	button->SetText(systemLayoutSpec[inputCancel].title);	button->SetFlag(FALSE);	button->SetGroup(buttonGroup);#if WINDOWS    button->SetCtrlNumber(IDCANCEL);#endif	AddItem(button);	useOffscreen = TRUE;	Show();		//SetText("name");	if(Modal())	{	int val;			ipd->GetText(str);		val = sscanf(str, "%lf", &d);		if (val != 0)			*ff_ipd = DblToFixed(d);					wp->GetText(str);		val = sscanf(str, "%lf", &d);		if (val != 0)			*ff_wp = DblToFixed(d);					dp->GetText(str);		val = sscanf(str, "%lf", &d);		if (val != 0)			*ff_dp = DblToFixed(d);					dv->GetText(str);		val = sscanf(str, "%lf", &d);		if (val != 0)			*ff_dv = DblToFixed(d);					yb->GetText(str);		val = sscanf(str, "%d", &new_yblank);		if (val != 0)			*yblank = new_yblank;				success = TRUE;	}	else		success = FALSE;			Delete();		return(success);}/*=============================================================================================*//* HMD ROUTINES *//*=============================================================================================*//*-----------------------------------------------------------------------------*//*	This is the constructor routine for the HMD; initialize variables.  	Return a non-zero value to signal an error of some kind.  */intHMD::cHMD(int hmd_type_code, struct Observer *observer_ptr){FFixed temp;// ABD HMD MAR95 removed gCrossEyed	hmd_type = hmd_type_code;	observer = observer_ptr;		eye = EYE_NONE;	pos = new(Position);	pos->cPosition();		ComputeIODandFOV();		return HMD_NO_ERR;}/*-----------------------------------------------------------------------------*//*	This is the destructor routine for the HMD.*/voidHMD::dHMD(){	if (pos) pos->dPosition();	delete this;}/*-----------------------------------------------------------------------------*//*	This routine gets the full (not half) inter-observer distance.  Note that this may be 	different than the inter-pupilary distance based on the dp, wp, and dv.*/voidHMD::SetIOD(FFixed new_iod){	half_iod.l = new_iod.l >> 1;}/*-----------------------------------------------------------------------------*//* . */int HMD::GetType() { return hmd_type; }/*-----------------------------------------------------------------------------*//* . */void HMD::RestoreOldFilmWidth(){	return;	if (gSavedOldFilmWidth)	{	ViewController *viewC = (ViewController *)observer->controller;	AppPreference *appPref = observer->controller->GetPreference();	NavigatePreference	*navPref = (NavigatePreference*)appPref->GetPreference(preferNavigate);;		gSavedOldFilmWidth = FALSE;		navPref->focalLength = gOldFocalLength;		navPref->filmWidth = gOldFilmWidth;		navPref->SetChange(TRUE);		// HMD MAR95	}}/*-----------------------------------------------------------------------------*//*	This routine recomputes the current half_iod based on dp, dv, and wp, and 	resets the observer FOV based on dp, dv, and wp.*/voidHMD::ComputeIODandFOV(){double d_iod, d_ipd, d_wp, d_dv, d_dp, d_theta_p, d_theta_v, d_wv;double d_film_width;double d_new_focal_length;short new_focal_length, new_film_width;short old_focal_length, old_film_width;ViewController *viewC;AppPreference *appPref;NavigatePreference	*navPref;HMDPreference *hmdPref;	viewC = (ViewController *)observer->controller;	appPref = observer->controller->GetPreference();	navPref = (NavigatePreference*)appPref->GetPreference(preferNavigate);	hmdPref = (HMDPreference*)appPref->GetPreference(preferHMD);	// get double versions of everything	d_wp = FixedToDbl(hmdPref->wp);//	d_dv = FixedToDbl(hmdPref->dv);//	d_dp = FixedToDbl(hmdPref->dp);	d_ipd = FixedToDbl(hmdPref->ipd);	d_iod = FixedToDbl(hmdPref->iod);    #if 0	// calculate theta_p (physical field of view) based on wp and dp	if (d_dp < 0.01) d_dp = 0.01;	d_theta_p = 2.0 * atan(d_wp / (2.0 * d_dp));		// set theta_v (virtual field of view) to the same thing as physical field of view	d_theta_v = d_theta_p;		// We want to change the field of view for the observer, but we can't do that 	// directly, we have to change the observer->filmWidth and observer->focalLength.	// We are given dv, which is the distance to the virtual screen the user wants.  	// This corresponds to observer->focalLength.  	// But what about filmWidth?  We want the filmWidth set so that the combination	// of filmWidth and focalLength makes the field of view d_theta_v.  So we compute	// the new filmWidth, which is wv -- width of the virtual screen.  	// compute wv (width of the virtual screen) so we can set filmWidth to it	d_wv = 2.0 * d_dv * tan(d_theta_v / 2.0);	new_film_width = (short)d_wv;	new_focal_length = (short)d_dv;	#endif    #if 0// gregr debug// don't do film recalc - we already have a control for it.	viewC = (ViewController *)observer->controller;	appPref = observer->controller->GetPreference();	navPref = (NavigatePreference*)appPref->GetPreference(preferNavigate);	new_film_width = navPref->filmWidth;	new_focal_length = navPref->focalLength;	// fix up the film width value -- this is needed because some HMDs have narrower	// screens (e.g. stereo pair is half as wide)	new_film_width = FixUpFilmWidth(new_film_width);		// HMD MAR95 moved this line up		// reset the film width and focal length through the preferences mechanism.  For	// some idiotic reason, chaning the filmWidth/focalLength through the SetFocalValue	// observer routine screws up the clip planes somehow.  So we do it the canonical way.	viewC = (ViewController *)observer->controller;	appPref = observer->controller->GetPreference();	navPref = (NavigatePreference*)appPref->GetPreference(preferNavigate);	if (!gSavedOldFilmWidth)    {		gOldFocalLength = navPref->focalLength;		gOldFilmWidth = navPref->filmWidth;		gSavedOldFilmWidth = TRUE;    }   		navPref->focalLength = new_focal_length;		navPref->filmWidth = new_film_width;	navPref->SetChange(TRUE);		// HMD MAR95	viewC->SetPreference(appPref, FALSE);	#endif    #if 0	// compute a new iod (inter-observer distance)	if (d_wp < 0.01) d_wp = 0.01;	d_iod = (d_ipd / d_wp) * d_wv;// gregr debug// let user specify distance between cameras	d_iod = d_ipd;	#endif			// save the new iod (actuall half-iod)	half_iod.l = DblToFixed(d_iod).l >> 1;		// note that the pixel shift is computed during a Draw, because we need to know the	// width of the final rendered image in pixels}/*-----------------------------------------------------------------------------*//*	The default routine for fixing up the value of film_width -- by default do not	change it.  */shortHMD::FixUpFilmWidth(short film_width){	return film_width;}/*-----------------------------------------------------------------------------*//*	The default routine for drawing a stereo frame.  Most of the time this will not	have to be overridden by subclasses.  It merely calls the left, then right routines	and the resets the eye variable.	Returns a non-zero value to signal an error of some kind.  */intHMD::Draw(int cancelable, int clipToScreen){Point3DFFixed FF_point;Angle3DFFixed FF_angle;Point3DFFixed old_FF_point;Angle3DFFixed old_FF_angle;int err = 0;extern long gQTCurrentFrame;		// MERGE-HMD	// make sure we have the necessary pieces	if (observer == NULL)		return HMD_ERROR;	if (observer->drawing == NULL)		return HMD_ERROR;	// read in at most one QT movie frame per rendered frame	gQTCurrentFrame++;	// MERGE-MAY94		// MERGE-HMD	oldFilmWidth = observer->filmWidth;	observer->filmWidth = FixUpFilmWidth(observer->filmWidth);    observer->SetFocalValue(observer->focalLength, observer->filmWidth);	// draw the left eye	err = DrawLeft(cancelable, clipToScreen);	if (err != HMD_NO_ERR) goto reset;	// note we don't update gQTCurrentFrame here so that the same QT frame is used for	// each eye	// draw the right eye	err = DrawRight(cancelable, clipToScreen);	if (err != HMD_NO_ERR) goto reset;	reset:	// reset the observer position and angle to the old position and angle	observer->filmWidth = oldFilmWidth;    observer->SetFocalValue(observer->focalLength, observer->filmWidth);	// reset the observer position and angle to the old position and angle	eye = EYE_NONE;	return err;}/*-----------------------------------------------------------------------------*//*	The default routine for drawing the left eye.  Most of the time this will not	have to be overridden by subclasses.  It merely saves the observer position/orientation	and calls the appropriate HMD routines to calculate the new observer position and 	draw the frame.	Returns a non-zero value to signal an error of some kind.  */intHMD::DrawLeft(int cancelable, int clipToScreen){Point3DFFixed old_FF_point;Angle3DFFixed old_FF_angle256;Point3D old_point;Angle3D old_angle;Point3DFFixed FF_point;Angle3DFFixed FF_angleRad, FF_angle256;Point3D	tmpPt;Angle3D tmpAng;int err = 0;	// make sure we have the necessary pieces	if (observer == NULL)		return HMD_ERROR;	if (observer->drawing == NULL)		return HMD_ERROR;		// ================	// ***** INIT *****	// ================	// remember the old point and angle so we can reset it later	old_FF_point = observer->FFpoint;	FF_angle256 = old_FF_angle256 = observer->FFangle;	old_point = observer->point;	old_angle = observer->angle;	// ====================	// ***** LEFT EYE *****	// ====================		// compute the position and angle of the left eye -- start with the current position	observer->GetPosition(&FF_point, &FF_angleRad);	ComputeLeftEye(&FF_point, &FF_angleRad, &FF_angle256);	// set the observer (and view) position and angle to the left eye	observer->SetFFPointTemp(FF_point);	observer->SetFFAngleTemp(FF_angle256);		// the the current eye to left eye	eye = EYE_LEFT;		// resequence the view so we get new clipping info	observer->drawing->Sequence();	// call the begin routine -- do hmd-specific setup	err = BeginDrawLeftEye();	if (err != HMD_NO_ERR) goto reset;		// draw the view	observer->Draw(cancelable, TRUE);		// always clip to screen	// call the end routine -- do hmd-specific setup	err = EndDrawLeftEye();	if (err != HMD_NO_ERR) goto reset;		// =================	// ***** RESET *****	// =================reset:	eye = EYE_NONE;	observer->SetFFPointTemp(old_FF_point);	observer->SetFFAngleTemp(old_FF_angle256);	return err;}/*-----------------------------------------------------------------------------*//*	The default routine for drawing the right eye.  Most of the time this will not	have to be overridden by subclasses.  It merely saves the observer position/orientation	and calls the appropriate HMD routines to calculate the new observer position and 	draw the frame.	Returns a non-zero value to signal an error of some kind.  */intHMD::DrawRight(int cancelable, int clipToScreen){Point3DFFixed old_FF_point;Angle3DFFixed old_FF_angle256;Point3D old_point;Angle3D old_angle;Point3DFFixed FF_point;Angle3DFFixed FF_angleRad, FF_angle256;Point3D	tmpPt;Angle3D tmpAng;int err = 0;	// make sure we have the necessary pieces	if (observer == NULL)		return HMD_ERROR;	if (observer->drawing == NULL)		return HMD_ERROR;		// ================	// ***** INIT *****	// ================	// remember the old point and angle so we can reset it later	old_FF_point = observer->FFpoint;	FF_angle256 = old_FF_angle256 = observer->FFangle;	old_point = observer->point;	old_angle = observer->angle;		// =====================	// ***** RIGHT EYE *****	// =====================	// compute the position and angle of the right eye -- start with the current position	observer->GetPosition(&FF_point, &FF_angleRad);	ComputeRightEye(&FF_point, &FF_angleRad, &FF_angle256);		// set the observer (and view) position and angle to the right eye position and angle	observer->SetFFPointTemp(FF_point);	observer->SetFFAngleTemp(FF_angle256);		// the the current eye to right eye	eye = EYE_RIGHT;		// resequence the view so we get new clipping info	observer->drawing->Sequence();		// call the begin routine -- do hmd-specific setup	err = BeginDrawRightEye();	if (err != HMD_NO_ERR) goto reset;		// draw the view	observer->Draw(cancelable, TRUE);		// always clip to screen	// call the end routine -- do hmd-specific setup 	err = EndDrawRightEye();	if (err != HMD_NO_ERR) goto reset;		// =================	// ***** RESET *****	// =================reset:	// reset the observer position and angle to the old position and angle	eye = EYE_NONE;	observer->SetFFPointTemp(old_FF_point);	observer->SetFFAngleTemp(old_FF_angle256);	return err;}/*-----------------------------------------------------------------------------*//*	Default routine for beginning to draw the left eye: do nothing.	Return a non-zero value to signal an error of some kind.  */int HMD::BeginDrawLeftEye() { return HMD_NO_ERR; }/*-----------------------------------------------------------------------------*//*	Default routine for ending drawing the left eye: do nothing.	Return a non-zero value to signal an error of some kind.  */int HMD::EndDrawLeftEye() { return HMD_NO_ERR; }/*-----------------------------------------------------------------------------*//*	Default routine for beginning to draw the right eye: do nothing.	Return a non-zero value to signal an error of some kind.  */int HMD::BeginDrawRightEye() { return HMD_NO_ERR; }/*-----------------------------------------------------------------------------*//*	Default routine for ending drawing the right eye: do nothing.	Return a non-zero value to signal an error of some kind.  */int HMD::EndDrawRightEye() { return HMD_NO_ERR; }/*-----------------------------------------------------------------------------*//*	Default routine for computing the right eye position/orientation in world space.	If we wanted to change the observer's orientation, we must change new_angle256, which	will be stored back to the observer.  new_angle_rad is merely provided for convenience,	so that we can use the angle with Position objects easily.*/voidHMD::ComputeLeftEye(struct Point3DFFixed *new_point, struct Angle3DFFixed *new_angle_rad,	struct Angle3DFFixed *new_angle256){Point3DFFixed offset = FFPoint3DZero;Point3DFFixed new_offset;	if ((!new_point) || (!new_angle_rad) || (!new_angle256)) DEBUGGER();	pos->Reset();	pos->SetOrientation3D(*new_angle_rad);	// ###Êmay have to do some sort of coordinate conversion here???	offset.x.intg = -half_iod.intg;	offset.x.frac = half_iod.frac;	new_offset = pos->Transform3D(offset);	new_point->x.l += new_offset.x.l;	new_point->y.l += new_offset.y.l;	new_point->z.l += new_offset.z.l;}/*-----------------------------------------------------------------------------*//*	Default routine for computing the right eye position/orientation in world space.	If we wanted to change the observer's orientation, we must change new_angle256, which	will be stored back to the observer.  new_angle_rad is merely provided for convenience,	so that we can use the angle with Position objects easily.*/voidHMD::ComputeRightEye(struct Point3DFFixed *new_point, struct Angle3DFFixed *new_angle_rad,	struct Angle3DFFixed *new_angle256){Point3DFFixed offset = FFPoint3DZero;Point3DFFixed new_offset;		if ((!new_point) || (!new_angle_rad) || (!new_angle256)) DEBUGGER();	pos->Reset();	pos->SetOrientation(*new_angle_rad);	// ###Êmay have to do some sort of coordinate conversion here???	offset.x.intg = half_iod.intg;	offset.x.frac = half_iod.frac;	new_offset = pos->Transform3D(offset);	new_point->x.l += new_offset.x.l;	new_point->y.l += new_offset.y.l;	new_point->z.l += new_offset.z.l;}/*-----------------------------------------------------------------------------*//*	Default routine setting any alternate flash routines.  This is required because	it is called after texturing.  Default routine does nothing.  */void HMD::ResetFlashRoutines(struct V_Offscreen *to) {  }/*-----------------------------------------------------------------------------*//*	The default routine for reporting whether or not this HMD is stretched vertically	by the hardware device.*/int HMD::IsStretchedVertically() { return FALSE; }/*=============================================================================================*//* HMD STEREO PAIR *//*=============================================================================================*//*-----------------------------------------------------------------------------*//*	This is the constructor routine for the HMDStereoPair; initialize cross_eye	and call default routine.*/intHMDStereoPair::cHMD(int hmd_type_code, struct Observer *observer_ptr){int return_val;	return_val = HMD::cHMD(hmd_type_code, observer_ptr);		ComputeIODandFOV();		return return_val;}/*-----------------------------------------------------------------------------*//*	HMD Stereo Pair routine for starting to draw the left eye: set up to draw in the	left half of the offscreen for wall-eyed, the right half for cross eyed stereo.*/intHMDStereoPair::BeginDrawLeftEye(){Rect r;int half_width, half_height;FFixed pixel_shift, wi;AppPreference *appPref = observer->controller->GetPreference();HMDPreference *hmdPref = (HMDPreference*)appPref->GetPreference(preferHMD);	HMD::BeginDrawLeftEye();	if (currentPane == NULL) return HMD_ERROR;		// save center X and center Y	oldCenterX = currentPane->centerX;	oldCenterY = currentPane->centerY;	oldDataRect = currentPane->dataRect;	r = currentPane->dataRect;	half_width = (r.right - r.left) >> 1;	half_height = (r.bottom - r.top) >> 1;	if (hmdPref->cross_eyed)	{		// by default, we draw in the left side of the window, so we need to muck about with		// the offscreen and the current panes centerX/centerY so the clipping works right.			// set up a fake centerX and centerY		currentPane->centerX = half_width + (half_width >> 1);		currentPane->centerY = half_height;		currentPane->dataRect.left = oldDataRect.left + ((oldDataRect.right - oldDataRect.left) >> 1);		currentPane->dataRect.top = oldDataRect.top;		currentPane->dataRect.right = oldDataRect.right;		currentPane->dataRect.bottom = oldDataRect.bottom;	}	else	{		// by default, we draw in the left side of the window, so we need to muck about with		// the offscreen and the current panes centerX/centerY so the clipping works right.			// set up a fake centerX and centerY		currentPane->centerX = half_width >> 1;		currentPane->centerY = half_height;				currentPane->dataRect.left = oldDataRect.left;		currentPane->dataRect.top = oldDataRect.top;		currentPane->dataRect.right = oldDataRect.left + ((oldDataRect.right - oldDataRect.left) >> 1);		currentPane->dataRect.bottom = oldDataRect.bottom;	}	//#########	{	Rect monitorRect;	FFixed monitorWidth, ppi;	GetScreen(&monitorRect);	monitorWidth.intg = monitorRect.right - monitorRect.left;	monitorWidth.frac = 0;	ppi = FFDiv(monitorWidth , hmdPref->wp);	pixel_shift = FFMult(ppi, hmdPref->ipd);	pixel_shift.l >>= 1;	if (!hmdPref->cross_eyed)		currentPane->centerX -= pixel_shift.intg;	else		currentPane->centerX += pixel_shift.intg;	}	//#########		// let the view know the new pane infoobserver->UpdatePane((half_width >> 1)+pixel_shift.intg, half_height);// 7/31	observer->UpdateScreenPoly(half_width >> 1, half_height);	return HMD_NO_ERR;}/*-----------------------------------------------------------------------------*//*	HMD Stereo Pair routine for ending drawing: restore global variables.*/intHMDStereoPair::EndDrawLeftEye(){	HMD::EndDrawLeftEye();	if (currentPane == NULL) return HMD_ERROR;	// restore center X and center Y	currentPane->centerX = oldCenterX;	currentPane->centerY = oldCenterY;	currentPane->dataRect = oldDataRect;	return HMD_NO_ERR;}/*-----------------------------------------------------------------------------*//*	HMD Stereo Pair routine for starting to draw the right eye: set up to draw in the	right half of the offscreen for wall-eyed, the left half for cross eyed stereo.*/intHMDStereoPair::BeginDrawRightEye(){Rect r;int half_width, half_height;FFixed pixel_shift, wi;AppPreference *appPref = observer->controller->GetPreference();HMDPreference *hmdPref = (HMDPreference*)appPref->GetPreference(preferHMD);	HMD::BeginDrawRightEye();	if (currentPane == NULL) return HMD_ERROR;		// save center X and center Y	oldCenterX = currentPane->centerX;	oldCenterY = currentPane->centerY;	oldDataRect = currentPane->dataRect;	r = currentPane->dataRect;	half_width = (r.right - r.left) >> 1;	half_height = (r.bottom - r.top) >> 1;	if (hmdPref->cross_eyed)	{		// by default, we draw in the left side of the window, so we need to muck about with		// the offscreen and the current panes centerX/centerY so the clipping works right.			// set up a fake centerX and centerY		currentPane->centerX = half_width >> 1;		currentPane->centerY = half_height;				currentPane->dataRect.left = oldDataRect.left;		currentPane->dataRect.top = oldDataRect.top;		currentPane->dataRect.right = oldDataRect.left + ((oldDataRect.right - oldDataRect.left) >> 1);		currentPane->dataRect.bottom = oldDataRect.bottom;	}	else	{		// by default, we draw in the left side of the window, so we need to muck about with		// the offscreen and the current panes centerX/centerY so the clipping works right.			// set up a fake centerX and centerY		currentPane->centerX = half_width + (half_width >> 1);		currentPane->centerY = half_height;		currentPane->dataRect.left = oldDataRect.left + ((oldDataRect.right - oldDataRect.left) >> 1);		currentPane->dataRect.top = oldDataRect.top;		currentPane->dataRect.right = oldDataRect.right;		currentPane->dataRect.bottom = oldDataRect.bottom;	}	//#########	{	Rect monitorRect;	FFixed monitorWidth, ppi;	GetScreen(&monitorRect);	monitorWidth.intg = monitorRect.right - monitorRect.left;	monitorWidth.frac = 0;	ppi = FFDiv(monitorWidth , hmdPref->wp);	pixel_shift = FFMult(ppi, hmdPref->ipd);	pixel_shift.l >>= 1;	if (hmdPref->cross_eyed)		currentPane->centerX -= pixel_shift.intg;	else		currentPane->centerX += pixel_shift.intg;	}	//#########		// let the view know the new pane info	observer->UpdatePane((half_width >> 1)+pixel_shift.intg, half_height);// 7/31	observer->UpdateScreenPoly(half_width >> 1, half_height);	return HMD_NO_ERR;}/*-----------------------------------------------------------------------------*//*	HMD Stereo Pair routine for ending drawing: restore global variables.*/intHMDStereoPair::EndDrawRightEye(){	HMD::EndDrawRightEye();	if (currentPane == NULL) return HMD_ERROR;	// restore center X and center Y	currentPane->centerX = oldCenterX;	currentPane->centerY = oldCenterY;	currentPane->dataRect = oldDataRect;	return HMD_NO_ERR;}/*-----------------------------------------------------------------------------*//*	HMD Stereo Pair routine for computing the left eye.*/voidHMDStereoPair::ComputeLeftEye(struct Point3DFFixed *new_point, struct Angle3DFFixed *new_angle_rad,	struct Angle3DFFixed *new_angle256){	HMD::ComputeLeftEye(new_point, new_angle_rad, new_angle256);	}/*-----------------------------------------------------------------------------*//*	HMD Stereo Pair routine for computing the left eye.*/voidHMDStereoPair::ComputeRightEye(struct Point3DFFixed *new_point, struct Angle3DFFixed *new_angle_rad,	struct Angle3DFFixed *new_angle256){	HMD::ComputeRightEye(new_point, new_angle_rad, new_angle256);	}/*-----------------------------------------------------------------------------*//*	The stereo pair routine for fixing up the value of film_width -- return half of it.*/shortHMDStereoPair::FixUpFilmWidth(short film_width){//	return (film_width >> 1);	return (film_width );}/*=============================================================================================*//* HMD CYBERSCOPE *//*=============================================================================================*//*-----------------------------------------------------------------------------*//*	This is the constructor routine for the HMDCyberScope; initialize cross_eye	and call default HMD routine -- note not the HMDStereoPair*/intHMDCyberScope::cHMD(int hmd_type_code, struct Observer *observer_ptr){int val;// ABD HMD MAR95 removed gCrossEyedViewController *viewC = NULL;#if VRV_Window *libWindow = ActiveDocument()->GetVRLib();#endif	val = HMDStereoPair::cHMD(hmd_type_code, observer_ptr);		ComputeIODandFOV();	// go into full screen mode#if VR	VWIHide();			if (libWindow)	{		ActiveDocument()->MoveVRLib(TRUE);	#if MACINTOSH		oldLibWindowVisible = libWindow->Visible();		if(libWindow->Visible())			libWindow->Hide();	#endif //MACINTOSH - BUGBUG - do we need to do this for windows(tm) too?		}#endif // VR	if (observer->controller != NULL)		viewC = ((ViewController*)(((WalkController*)(observer->controller))			->FindController(toolCRTLView)));				#if 0	if (viewC != NULL)	{		if (!(viewC->walkPane->walkMenu->GetState(menuFullScreen)))		{			viewC->walkPane->walkMenu->Select(menuFullScreen, TRUE);			viewC->FullScreen(TRUE);		}	}	#endif	return val;}/*-----------------------------------------------------------------------------*//*	This is the destructor routine for the HMDCyberScope.*/voidHMDCyberScope::dHMD(){ViewController *viewC = NULL;#if VRV_Window *libWindow = ActiveDocument()->GetVRLib();#endif	// get out of full screen mode#if VR	VWIShow();		if ((libWindow) && (oldLibWindowVisible))	{		ActiveDocument()->MoveVRLib(TRUE);	#if MACINTOSH		libWindow->Show();	#endif //MACINTOSH - BUGBUG - do we need to do this for windows(tm) too?		}	if (observer->controller != NULL)		viewC = ((ViewController*)(((WalkController*)(observer->controller))			->FindController(toolCRTLView)));				#if 0	if (viewC != NULL)	{		if ((viewC->walkPane->walkMenu->GetState(menuFullScreen)))		{			viewC->walkPane->walkMenu->Select(menuFullScreen, FALSE);			viewC->FullScreen(FALSE);		}	}		#endif	#endif // VR	HMD::dHMD();	// for god's sake don't do anything after the HMD::dHMD()!!! It destroys 'this'!!!}/*-----------------------------------------------------------------------------*//*	HMD Cyberscope left eye routine.*/intHMDCyberScope::BeginDrawLeftEye(){	// draw just like stereo pair, but make sure that we don't draw cross eyed	// (for cyberscope, cross_eyed is always FALSE)	return HMDStereoPair::BeginDrawLeftEye();}/*-----------------------------------------------------------------------------*//*	HMD Cyberscope right eye routine.*/intHMDCyberScope::BeginDrawRightEye(){	// draw just like stereo pair, but make sure that we don't draw cross eyed	// (for cyberscope, cross_eyed is always FALSE)	return HMDStereoPair::BeginDrawRightEye();}/*-----------------------------------------------------------------------------*//*	HMD Cyberscope routine for computing the left eye.	Note that because we change the observer's orientation, we must change new_angle256, which	will be stored back to the observer.  new_angle_rad is merely provided for convenience,	so that we can use the angle with Position objects easily.*/voidHMDCyberScope::ComputeLeftEye(struct Point3DFFixed *new_point, struct Angle3DFFixed *new_angle_rad,	struct Angle3DFFixed *new_angle256){	HMDStereoPair::ComputeLeftEye(new_point, new_angle_rad, new_angle256);		// for cyberscope, add 64 (i.e. ninety degree rotation)	new_angle256->roll.intg += 64;	new_angle256->roll.intg &= 0xFF;		// bring back to 256-based angle}/*-----------------------------------------------------------------------------*//*	HMD Cyberscope routine for computing the left eye.	Note that because we change the observer's orientation, we must change new_angle256, which	will be stored back to the observer.  new_angle_rad is merely provided for convenience,	so that we can use the angle with Position objects easily.*/voidHMDCyberScope::ComputeRightEye(struct Point3DFFixed *new_point, struct Angle3DFFixed *new_angle_rad,	struct Angle3DFFixed *new_angle256){	HMDStereoPair::ComputeRightEye(new_point, new_angle_rad, new_angle256);			// for cyberscope, subtract 64 (i.e. ninety degree rotation)	new_angle256->roll.intg -= 64;	new_angle256->roll.intg &= 0xFF;		// bring back to 256-based angle}/*=============================================================================================*//* HMD VREX *//*=============================================================================================*/long gHMDOffsetRight;long gHMDOffsetLeft;/*-----------------------------------------------------------------------------*//**/intHMDVRex::Draw(int cancelable, int clipToScreen){	// make sure we have the necessary pieces	if (observer == NULL)		return HMD_ERROR;	if (observer->drawing == NULL)		return HMD_ERROR;			return HMD::Draw(cancelable, clipToScreen);}/*-----------------------------------------------------------------------------*//*	This is the constructor routine for the HMD VRex.*/intHMDVRex::cHMD(int hmd_type_code, struct Observer *observer_ptr){int val;	val = HMD::cHMD(hmd_type_code, observer_ptr);		// initial reasonable values for these	#if 0  // where to fix these values?	ipd = DblToFixed(2.5);	wp = DblToFixed(50.0);	dp = DblToFixed(50.0);	dv = DblToFixed(12.0);	#endif		ComputeIODandFOV();	return val;}/*-----------------------------------------------------------------------------*//*	HMD VRex left eye routine.*/intHMDVRex::BeginDrawLeftEye(){OSErr err = 0;int half_width, half_height;Rect r;FFixed pixel_shift, wi;AppPreference *appPref = observer->controller->GetPreference();HMDPreference *hmdPref = (HMDPreference*)appPref->GetPreference(preferHMD);FFixed eyedist;	err = HMD::BeginDrawLeftEye();	if (err)		return err;	// save center X and center Y	oldCenterX = currentPane->centerX;	oldCenterY = currentPane->centerY;	oldDataRect = currentPane->dataRect;	r = currentPane->dataRect;	half_width = (r.right - r.left) >> 1;	half_height = (r.bottom - r.top) >> 1;	// set up a fake centerX and centerY	currentPane->centerX = half_width;	currentPane->centerY = half_height >> 1;	// compute the width of the image in pixels	wi.intg = r.right - r.left;	wi.frac = 0;		//#########	{	Rect monitorRect;	FFixed monitorWidth, ppi;	GetScreen(&monitorRect);	monitorWidth.intg = monitorRect.right - monitorRect.left;	monitorWidth.frac = 0;	ppi = FFDiv(monitorWidth , hmdPref->wp);	pixel_shift = FFMult(ppi, hmdPref->ipd);	pixel_shift.l >>= 1;	if (!hmdPref->cross_eyed)		currentPane->centerX -= pixel_shift.intg;	else		currentPane->centerX += pixel_shift.intg;	}	//#########		// compute the required pixel shift//#	pixel_shift = FFMult(FFDiv(hmdPref->ipd, hmdPref->wp), wi);//#	pixel_shift.l >>= 1;//#	currentPane->centerX -= pixel_shift.intg;	currentPane->dataRect.left = r.left;	currentPane->dataRect.top = r.top;	currentPane->dataRect.right = r.right;	currentPane->dataRect.bottom = half_height;		// ABD HMD MAR95 -- for some bizarre reason, the following comment is no longer valid.	// Now we do an UpdatePane() and everything works right it seems.	// note that we don't update the pane (i.e. no observer->UpdatePane) because that	// will screw up the clipPlanes stuff, and so when we are close to the objects (or	// inside them, we will see them as half-size.  But we have to update the screen	// poly so pixel shift will work right (if the screen poly doesn't fill the whole	// screen, then the edges of the screen won't get cleared from frame to frame)	// observer->UpdateScreenPoly(half_width + pixel_shift.intg, half_height);	observer->UpdatePane(half_width + pixel_shift.intg, half_height);			// save the current flash routines so we can restore them later	// ABD HMD JUL95 oldFlashFill = FlashFill;	// ABD HMD JUL95 oldFlashClip = FlashClip;		// set the flash routines to our special VRex routines	ResetFlashRoutines(offscreen);	return HMD_NO_ERR;}/*-----------------------------------------------------------------------------*//*	HMD VRex right eye routine.*/intHMDVRex::BeginDrawRightEye(){OSErr err = 0;int half_width, half_height;Rect r;FFixed pixel_shift, wi;AppPreference *appPref = observer->controller->GetPreference();HMDPreference *hmdPref = (HMDPreference*)appPref->GetPreference(preferHMD);FFixed eyedist;	err = HMD::BeginDrawRightEye();	if (err)		return err;	// save center X and center Y	oldCenterX = currentPane->centerX;	oldCenterY = currentPane->centerY;	oldDataRect = currentPane->dataRect;	r = currentPane->dataRect;	half_width = (r.right - r.left) >> 1;	half_height = (r.bottom - r.top) >> 1;	// set up a fake centerX and centerY	currentPane->centerX = half_width;	currentPane->centerY = half_height >> 1;		// compute the width of the image in pixels	wi.intg = r.right - r.left;	wi.frac = 0;	//#########	{	Rect monitorRect;	FFixed monitorWidth, ppi;	GetScreen(&monitorRect);	monitorWidth.intg = monitorRect.right - monitorRect.left;	monitorWidth.frac = 0;	ppi = FFDiv(monitorWidth , hmdPref->wp);	pixel_shift = FFMult(ppi, hmdPref->ipd);	pixel_shift.l >>= 1;	if (hmdPref->cross_eyed)		currentPane->centerX -= pixel_shift.intg;	else		currentPane->centerX += pixel_shift.intg;	}	//#########		// compute the required pixel shift//#	pixel_shift = FFMult(FFDiv(hmdPref->ipd, hmdPref->wp), wi);//#	pixel_shift.l >>= 1;//#	currentPane->centerX += pixel_shift.intg;		currentPane->dataRect.left = r.left;	currentPane->dataRect.top = r.top;	currentPane->dataRect.right = r.right;	currentPane->dataRect.bottom = half_height;		// note that we don't update the pane (i.e. no observer->UpdatePane) because that	// will screw up the clipPlanes stuff, and so when we are close to the objects (or	// inside them, we will see them as half-size.  But we have to update the screen	// poly so pixel shift will work right (if the screen poly doesn't fill the whole	// screen, then the edges of the screen won't get cleared from frame to frame)	// observer->UpdateScreenPoly(half_width + pixel_shift.intg, half_height);	observer->UpdatePane(half_width + pixel_shift.intg, half_height);	// save the current flash routines so we can restore them later	// ABD HMD JUL95 oldFlashFill = FlashFill;	// ABD HMD JUL95 oldFlashClip = FlashClip;		// set the flash routines to our special VRex routines	ResetFlashRoutines(offscreen);	return HMD_NO_ERR;}/*-----------------------------------------------------------------------------*//*	HMD VRex routine for ending drawing: restore global variables.*/intHMDVRex::EndDrawLeftEye(){OSErr err = 0;	err = HMD::EndDrawLeftEye();	if (err)		return err;	// restore center X and center Y	currentPane->centerX = oldCenterX;	currentPane->centerY = oldCenterY;	currentPane->dataRect = oldDataRect;	// ABD HMD JUL95 FlashFill = oldFlashFill;	// ABD HMD JUL95 FlashClip = oldFlashClip;	return HMD_NO_ERR;}/*-----------------------------------------------------------------------------*//*	HMD VRex routine for ending drawing: restore global variables.*/intHMDVRex::EndDrawRightEye(){OSErr err = 0;	err = HMD::EndDrawRightEye();	if (err)		return err;	// restore center X and center Y	currentPane->centerX = oldCenterX;	currentPane->centerY = oldCenterY;	currentPane->dataRect = oldDataRect;	// ABD HMD JUL95 FlashFill = oldFlashFill;	// ABD HMD JUL95 FlashClip = oldFlashClip;	return HMD_NO_ERR;}/*-----------------------------------------------------------------------------*//*	HMD VRex routine for computing the left eye.*/voidHMDVRex::ComputeLeftEye(struct Point3DFFixed *new_point, struct Angle3DFFixed *new_angle_rad,	struct Angle3DFFixed *new_angle256){	HMD::ComputeLeftEye(new_point, new_angle_rad, new_angle256);	}/*-----------------------------------------------------------------------------*//*	HMD VRex routine for computing the left eye.*/voidHMDVRex::ComputeRightEye(struct Point3DFFixed *new_point, struct Angle3DFFixed *new_angle_rad,	struct Angle3DFFixed *new_angle256){	HMD::ComputeRightEye(new_point, new_angle_rad, new_angle256);	}/*-----------------------------------------------------------------------------*//*	VRex routine setting our alternate flash routines.  This is required because	SetCurrent is called after texturing to reset the flash routines.  Then we	call this routine to reset them again to whatever special HMD flash routines	we have.  This routine is also called by BeginDrawLeftEye/BeginDrawRightEye.*/void HMDVRex::ResetFlashRoutines(V_Offscreen *to) {  AppPreference *appPref = observer->controller->GetPreference();HMDPreference *hmdPref = (HMDPreference*)appPref->GetPreference(preferHMD);	if (hmdPref->cross_eyed)	{		gHMDOffsetRight = (long)0;		gHMDOffsetLeft = (long)1;	}	else	{		gHMDOffsetRight = (long)1;		gHMDOffsetLeft = (long)0;	}			#if 0	switch (eye)	{		case EYE_LEFT:			switch(to->GetDepth())			{				case 8:					FlashFill = FlashFill8HMDL;					FlashClip = FlashClip8HMDL;					break;				default:					Debugger();		// don't support other bit depths yet!!!!					break;			}			break;		case EYE_RIGHT:			switch(to->GetDepth())			{				case 8:					FlashFill = FlashFill8HMDR;					FlashClip = FlashClip8HMDR;					break;				default:					Debugger();		// don't support other bit depths yet!!!!					break;			}			break;					default:			break;	}	#endif}/*-----------------------------------------------------------------------------*//*	The VREx routine for reporting that this HMD is stretched vertically by the 	hardware device.*/int HMDVRex::IsStretchedVertically() { return TRUE; }/*=============================================================================================*//* HMD CRYSTALEYES *//*=============================================================================================*//*-----------------------------------------------------------------------------*//*	This is the constructor routine for the HMDStereoPair; initialize cross_eye	and call default routine.*/intHMDCrystalEyes::cHMD(int hmd_type_code, struct Observer *observer_ptr){int return_val;ViewController *viewC = NULL;#if VRV_Window *libWindow = ActiveDocument()->GetVRLib();#endif// ABD HMD MAR95 removed gCrossEyed	return_val = HMD::cHMD(hmd_type_code, observer_ptr);			ComputeIODandFOV();		// go into full screen mode#if VR	VWIHide();			if (libWindow)	{		ActiveDocument()->MoveVRLib(TRUE);	#if MACINTOSH		oldLibWindowVisible = libWindow->Visible();		if(libWindow->Visible())			libWindow->Hide();	#endif //MACINTOSH - BUGBUG - do we need to do this for windows(tm) too?		}#endif // VR	if (observer->controller != NULL)		viewC = ((ViewController*)(((WalkController*)(observer->controller))			->FindController(toolCRTLView)));	#if 0	if (viewC != NULL)	{		if (!(viewC->walkPane->walkMenu->GetState(menuFullScreen)))		{			viewC->walkPane->walkMenu->Select(menuFullScreen, TRUE);			viewC->FullScreen(TRUE);		}	}	#endif		return return_val;}/*-----------------------------------------------------------------------------*//*	This is the destructor routine for the HMDCrystalEyes.*/voidHMDCrystalEyes::dHMD(){ViewController *viewC = NULL;#if VRV_Window *libWindow = ActiveDocument()->GetVRLib();#endif	// get out of full screen mode#if VR	VWIShow();		if ((libWindow) && (oldLibWindowVisible))	{		ActiveDocument()->MoveVRLib(TRUE);	#if MACINTOSH		libWindow->Show();	#endif //MACINTOSH - BUGBUG - do we need to do this for windows(tm) too?		}	if (observer->controller != NULL)		viewC = ((ViewController*)(((WalkController*)(observer->controller))			->FindController(toolCRTLView)));	#if 0	if (viewC != NULL)	{		if ((viewC->walkPane->walkMenu->GetState(menuFullScreen)))		{			viewC->walkPane->walkMenu->Select(menuFullScreen, FALSE);			viewC->FullScreen(FALSE);		}	}		#endif#endif // VR	HMD::dHMD();	// for god's sake don't do anything after the HMD::dHMD()!!! It destroys 'this'!!!}/*-----------------------------------------------------------------------------*//*	The HMDCrystalEyes routine for drawing a stereo frame.  Make sure the entire Walk	Pane rect is erased (with black) so there won't be garbage in the YBLANK area.  */intHMDCrystalEyes::Draw(int cancelable, int clipToScreen){Rect r;int return_val;int half;AppPreference *appPref = observer->controller->GetPreference();HMDPreference *hmdPref = (HMDPreference*)appPref->GetPreference(preferHMD);	if (currentPane == NULL)		return HMD_ERROR;	return_val = HMD::Draw(cancelable, clipToScreen);		VForeColor(&vBlack);	r = currentPane->dataRect;	half = (r.bottom + r.top) >> 1;	r.bottom = half + (hmdPref->yblank >> 1);	r.top = half - (hmdPref->yblank >> 1);	r.top--;	r.bottom++;	VPaintRect(&r);	return return_val;}/*-----------------------------------------------------------------------------*//*	HMD Stereo Pair routine for starting to draw the left eye: set up to draw in the	left half of the offscreen for wall-eyed, the right half for cross eyed stereo.*/intHMDCrystalEyes::BeginDrawLeftEye(){Rect r;int half_width, half_height;FFixed pixel_shift, wi;AppPreference *appPref = observer->controller->GetPreference();HMDPreference *hmdPref = (HMDPreference*)appPref->GetPreference(preferHMD);	HMD::BeginDrawLeftEye();	if (currentPane == NULL) return HMD_ERROR;		// save center X and center Y	oldCenterX = currentPane->centerX;	oldCenterY = currentPane->centerY;	oldDataRect = currentPane->dataRect;	r = currentPane->dataRect;	half_width = (r.right - r.left) >> 1;	half_height = ((r.bottom - r.top) - hmdPref->yblank) >> 1;	if (!hmdPref->cross_eyed)	{		// draw on top		// set up a fake centerX and centerY		currentPane->centerX = half_width;		currentPane->centerY = half_height >> 1;				currentPane->dataRect.left = oldDataRect.left;		currentPane->dataRect.top = oldDataRect.top;		currentPane->dataRect.right = oldDataRect.right;		currentPane->dataRect.bottom = oldDataRect.top + half_height;	}	else	{		// draw on bottom		// set up a fake centerX and centerY		currentPane->centerX = half_width;		currentPane->centerY = (r.bottom + (r.bottom - half_height)) >> 1;			currentPane->dataRect.left = oldDataRect.left;		currentPane->dataRect.top = oldDataRect.bottom - half_height;		currentPane->dataRect.right = oldDataRect.right;		currentPane->dataRect.bottom = oldDataRect.bottom;	}		//#########	{	Rect monitorRect;	FFixed monitorWidth, ppi;	GetScreen(&monitorRect);	monitorWidth.intg = monitorRect.right - monitorRect.left;	monitorWidth.frac = 0;	ppi = FFDiv(monitorWidth , hmdPref->wp);	pixel_shift = FFMult(ppi, hmdPref->ipd);	pixel_shift.l >>= 1;	if (!hmdPref->cross_eyed)		currentPane->centerX -= pixel_shift.intg;	else		currentPane->centerX += pixel_shift.intg;	}	//#########		// let the view know the new pane info	observer->UpdateScreenPoly(half_width+pixel_shift.intg, half_height >> 1);  //	observer->UpdatePane(half_width+pixel_shift.intg, half_height >> 1);	return HMD_NO_ERR;}/*-----------------------------------------------------------------------------*//*	HMD Stereo Pair routine for ending drawing: restore global variables.*/intHMDCrystalEyes::EndDrawLeftEye(){	HMD::EndDrawLeftEye();	if (currentPane == NULL) return HMD_ERROR;	// restore center X and center Y	currentPane->centerX = oldCenterX;	currentPane->centerY = oldCenterY;	currentPane->dataRect = oldDataRect;	return HMD_NO_ERR;}/*-----------------------------------------------------------------------------*//*	HMD Stereo Pair routine for starting to draw the right eye: set up to draw in the	right half of the offscreen for wall-eyed, the left half for cross eyed stereo.*/intHMDCrystalEyes::BeginDrawRightEye(){Rect r;int half_width, half_height;FFixed pixel_shift, wi;AppPreference *appPref = observer->controller->GetPreference();HMDPreference *hmdPref = (HMDPreference*)appPref->GetPreference(preferHMD);	HMD::BeginDrawRightEye();	if (currentPane == NULL) return HMD_ERROR;		// save center X and center Y	oldCenterX = currentPane->centerX;	oldCenterY = currentPane->centerY;	oldDataRect = currentPane->dataRect;	r = currentPane->dataRect;	half_width = (r.right - r.left) >> 1;	half_height = ((r.bottom - r.top) - hmdPref->yblank) >> 1;	if (!hmdPref->cross_eyed)	{		// draw on bottom		// set up a fake centerX and centerY		currentPane->centerX = half_width;		currentPane->centerY = (r.bottom + (r.bottom - half_height)) >> 1;			currentPane->dataRect.left = oldDataRect.left;		currentPane->dataRect.top = oldDataRect.bottom - half_height;		currentPane->dataRect.right = oldDataRect.right;		currentPane->dataRect.bottom = oldDataRect.bottom;	}	else	{		// draw on top		// set up a fake centerX and centerY		currentPane->centerX = half_width;		currentPane->centerY = half_height >> 1;				currentPane->dataRect.left = oldDataRect.left;		currentPane->dataRect.top = oldDataRect.top;		currentPane->dataRect.right = oldDataRect.right;		currentPane->dataRect.bottom = oldDataRect.top + half_height;	}	//#########	{	Rect monitorRect;	FFixed monitorWidth, ppi;	GetScreen(&monitorRect);	monitorWidth.intg = monitorRect.right - monitorRect.left;	monitorWidth.frac = 0;	ppi = FFDiv(monitorWidth , hmdPref->wp);	pixel_shift = FFMult(ppi, hmdPref->ipd);	pixel_shift.l >>= 1;	if (hmdPref->cross_eyed)		currentPane->centerX -= pixel_shift.intg;	else		currentPane->centerX += pixel_shift.intg;	}	//#########		// let the view know the new pane info   	observer->UpdateScreenPoly(half_width+pixel_shift.intg, half_height >> 1);   //	observer->UpdatePane(half_width+pixel_shift.intg, half_height >> 1);	return HMD_NO_ERR;}/*-----------------------------------------------------------------------------*//*	HMD Stereo Pair routine for ending drawing: restore global variables.*/intHMDCrystalEyes::EndDrawRightEye(){	HMD::EndDrawRightEye();	if (currentPane == NULL) return HMD_ERROR;	// restore center X and center Y	currentPane->centerX = oldCenterX;	currentPane->centerY = oldCenterY;	currentPane->dataRect = oldDataRect;	return HMD_NO_ERR;}/*-----------------------------------------------------------------------------*//*	The CrystalEyes routine for reporting that this HMD is stretched vertically by the 	hardware device.*/int HMDCrystalEyes::IsStretchedVertically() { return TRUE; }#endif // USE_HMD ABD HMD MAR95