/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  * Platform: 	MACINTOSH 	X *				WINDOWS		 *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VArray.h"#include "CVObj.h"#include "CVPolyh.h"#include "CVSrfDef.h"#include "CVSrfFet.h"#include "PolyConv.h"#include "Surface.h"#include "PolyDefs.h"#include "CVEnvirn.h"#include "Clip.h"#include "SinTable.h"#include "CVLItem.h"#include "WalkDefs.h"#include "Misc.h"#include "AppText.h"#include "Geometry.h"#include "VGraphic.h"#include "VGUtil.h"#include "VButton.h"#include "VMath.h"#include <math.h>//DUDE#include "Clip.h"extern Clip marksStockClip;char cornerSymbol =  0x89;void CAVObject::cCAVObject() 	{		outline = new(V_Array);	outline->cArray(0,sizeof(short),4);		points = new(V_Array);	points->cArray(0,sizeof(PointLong),4);		dirty =  POLY_MUSSED;				editMode = IN_DEF_VIEW;		}	voidCAVObject::dCAVObject()	{	outline->dArray();	points->dArray();		delete(this);	}void CAVObject::SetEnvironment(CAVEnvironment  *newEnv) {environment = newEnv;}void CAVObject::SetDirty(int	cleanState) {dirty = cleanState;}Point CAVObject::GetAnchor(int editType,int mark) 	{	PointLong	*lp,drawOrigin;	Point anchor;	int		length,opp;	short   *index;		drawOrigin = environment->GetDrawOrigin();		switch(editType)		{		case EDIT_POLYGON:		case EDIT_REGPOLYGON:				anchor.h = origin.h - drawOrigin.h;			anchor.v = origin.v - drawOrigin.v;			break;				case EDIT_RECTANGLE:			length = points->ALength();			lp = (PointLong*)points->Use();			index = (short*)outline->Use();			length = outline->ALength();			opp = nextIndex(mark,2,length);			anchor.h = lp[index[opp]].h - drawOrigin.h;			anchor.v = lp[index[opp]].v - drawOrigin.v;			points->Unuse();			outline->Unuse();			break;		}			return(anchor);	}void CAVObject::Update(Point3D posnBoundMin,Point3D posnBoundMax) 	{	Point3D			tmpmin,tmpmax;	tmpmin = environment->Translate3D(TO_CAD,posnBoundMin);	tmpmax = environment->Translate3D(TO_CAD,posnBoundMax);			bounds.left = min(tmpmin.x,tmpmax.x);	bounds.right = max(tmpmin.x,tmpmax.x);	bounds.top = max(tmpmin.y,tmpmax.y);	bounds.bottom = min(tmpmin.y,tmpmax.y);		bounds.left--;bounds.top--;	bounds.right++;bounds.bottom++;	}	voidCAVObject::Scale(DisplayInfo	*info)	{		Point3DFFixed 	*wp;	PointLong		*lp;	int				i = 0,length;							VSetCursor(vCursorEarth);	length = info->posnPoints->ALength();	if(ROTATE_OUT_VIEW == editMode)points->SetLength(length+4);	else points->SetLength(length);		lp = (PointLong*)points->Use();		if(length)		{		wp = (Point3DFFixed *)info->posnPoints->Use();				lp[0] = environment->WorldToView2D(*wp);					cmin.h = cmax.h = lp[0].h;		cmin.v = cmax.v = lp[0].v;				wp++;lp++;		for(i = 1;i < length; i++,wp++,lp++)			{			*lp = environment->WorldToView2D(*wp);						cmin.h = min(cmin.h,lp->h);			cmax.h = max(cmax.h,lp->h);			cmin.v = min(cmin.v,lp->v);			cmax.v = max(cmax.v,lp->v);				}			info->posnPoints->Unuse();		}		if(ROTATE_OUT_VIEW == editMode)		{		Point3DFFixed	tmpWrld;		PointLong		tmpBox1,tmpBox2;				tmpWrld.x = tmpWrld.y = tmpWrld.z = FFZero;				tmpWrld.x.intg = info->posnBoundMin.x;		tmpWrld.y.intg = info->posnBoundMin.y;		tmpWrld.z.intg = info->posnBoundMin.z;		tmpBox1 = environment->WorldToView2D(tmpWrld);				if(length)			{			cmin.h = min(cmin.h,tmpBox1.h);			cmax.h = max(cmax.h,tmpBox1.h);			cmin.v = min(cmin.v,tmpBox1.v);			cmax.v = max(cmax.v,tmpBox1.v);				}		else			{			cmin = cmax = tmpBox1;			}					tmpWrld.x.intg = info->posnBoundMax.x;		tmpWrld.y.intg = info->posnBoundMax.y;		tmpWrld.z.intg = info->posnBoundMax.z;		tmpBox2 = environment->WorldToView2D(tmpWrld);				cmin.h = min(cmin.h,tmpBox2.h);		cmax.h = max(cmax.h,tmpBox2.h);		cmin.v = min(cmin.v,tmpBox2.v);		cmax.v = max(cmax.v,tmpBox2.v);					lp->h = tmpBox1.h;lp->v = tmpBox1.v;lp++;		lp->h = tmpBox1.h;lp->v = tmpBox2.v;lp++;		lp->h = tmpBox2.h;lp->v = tmpBox2.v;lp++;		lp->h = tmpBox2.h;lp->v = tmpBox1.v;		}			points->Unuse();		/*	origin = environment->WorldToView2D(info->origin);*/		origin.h = cmin.h + ((cmax.h - cmin.h)>>1);	origin.v = cmin.v + ((cmax.v - cmin.v)>>1);	angle = environment->AngleToView(info->orientation);			cmin.h -= 4;	cmin.v -= 4;	cmax.h += 4;	cmax.v += 4;				dirty = POLY_CLEAN;	}	voidCAVObject::Display(DisplayInfo *info)	{		PolyConvex		**convexs;	PointLong		*lp;	PointLong		drawOrigin;	int				length,i,depth;	if(!environment->RectInWorld(&bounds)) return;	if(dirty)Scale(info);	if((HIDE_LAYER&info->layer->flagState)) return;						drawOrigin = environment->GetDrawOrigin();			VPenMode(vPatCopy);				DisplaySurface(info->piece,lp,drawOrigin,info);	}	voidCAVObject::DisplaySurface(PolyConvex *pc,PointLong *lp,PointLong drawOrigin,DisplayInfo *info)	{		Surface		**surface,**surfaceAll;	V_Array	*tmpArray,*clipPts;	Rect	r;	CAVSurfFeature **pfeature;	int	 k,i,j,length,pointLength,orientation,depth,l,llength;	short  *index,direction;	PointLong cp,lastcp;	long h,v,lh,lv;	int		patType,drawAllFlag;		drawAllFlag = TRUE;		if(2 >= (depth = environment->GetCAVDepth())) depth = FALSE;	surface = (Surface**)pc->surfaces->Use();	surfaceAll = surface;	length = pc->surfaces->ALength();	r = environment->dataRect;	for(i = 0; i < length; i++,surface++)		{		/* check here if the normal is good for this view */		orientation = environment->SurfaceVisible((*surface)->posnNormal);		if(FACE_UP & orientation)			{			drawAllFlag = FALSE;//if(depth) VForeColor(&(info->color));//if(info->state) VSetPattern(vPatBlack); else VSetPattern(vPatGray);			patType = (info->state) ? FALSE : vPatGray;			clipPts = IndexLongClipPoly(points,(*surface)->points,&r,drawOrigin);virtusClipper->NewDrawPoly(clipPts,CLIP_FRAME,NULL,FALSE,patType,vPatBlack,&vWhite,&info->color,TRUE,NULL);		// MERGE-GOURAUD//virtusClipper->NewDrawPoly(clipPts,CLIP_FRAME,FALSE,patType,patType,&vWhite,&info->color,TRUE,NULL);			}				if((FEATURE_LAYER&info->layer->flagState) && (0x0003 & orientation) && (*surface)->surfDef 				&& (SDEF_FEATURE & (*surface)->surfDef->flags))			{						info->direction = PERPINDICULAR & orientation;						for(k = 0; k < 3; k++)				{				if(tmpArray = (*surface)->surfDef->features[k])					{					llength = tmpArray->ALength();					pfeature = (CAVSurfFeature**)tmpArray->Use();					for(l = 0; l < llength; l++,pfeature++)						(*pfeature)->DisplayFeature(info);					tmpArray->Unuse();					}				}				}					}	if(drawAllFlag)		{		patType = (info->state) ? FALSE : vPatGray;		for(i = 0; i < length; i++,surfaceAll++)			{//if(depth) VForeColor(&(info->color));			clipPts = IndexLongClipPoly(points,(*surfaceAll)->points,&r,drawOrigin);			virtusClipper->NewDrawPoly(clipPts,CLIP_FRAME,NULL,FALSE,patType,vPatBlack,&vWhite,&info->color,TRUE,NULL);		// MERGE-GOURAUD//			virtusClipper->NewDrawPoly(clipPts,CLIP_FRAME,FALSE,patType,patType,&vWhite,&info->color,TRUE,NULL);			}		}			pc->surfaces->Unuse();	}		voidCAVObject::Select(DisplayInfo *info,int mark)	{		Rect			handles,r;	PointLong		*lp,adjPt,inPt;	PointLong		drawOrigin;	int				length,i,depth,start;	short			*index;	V_Array			*clPts;	RGBColor		lineColor;	int				flags;	if(dirty)Scale(info);	if(2 < (depth = environment->GetCAVDepth())) VForeColor(&info->color);		drawOrigin = environment->GetDrawOrigin();	r = environment->dataRect;		clPts = IndexLongClipPoly(points,outline,&r,drawOrigin);	if(editMode==ROTATE_OUT_VIEW)VSetPattern(vPatGray);	else VSetPattern(vPatBlack);	VPenMode(vPatXor);	VForeColor(&vBlack);	VBackColor(&vWhite);	length = outline->ALength();	lp = (PointLong*)points->Use();	index = (short*)outline->Use();	/* why do we do this? It's not like we use the inPt value; it's   an automatic variable and it's never referenced.  mark can be   > length, which will cause crashes under Windows.  I've commented   it out.  jca 16FEB94	if((-1 != mark) && (mark < length))		inPt = lp[index[mark]];*/	for(i = 0; i < length; i++,index++)		{		adjPt.h = lp[*index].h - drawOrigin.h;		adjPt.v = lp[*index].v - drawOrigin.v;		if(adjPt.v<=r.bottom&&adjPt.v>=r.top&&adjPt.h<=r.right&&adjPt.h>=r.left)			{			handles.left = adjPt.h - 2;			handles.right = adjPt.h + 3;			handles.top = adjPt.v - 2;			handles.bottom = adjPt.v + 3;			switch(editMode)				{				case IN_DEF_VIEW: VPaintRect(&handles); break;				case OUT_DEF_VIEW: VFrameRect(&handles); break;				case ROTATE_OUT_VIEW: VPaintRect(&handles); break;				}			}		}	VSetPattern(vPatSelect);	lineColor = info->color;	// DAS-FIX 1-bit fill 9/13/93	flags=CLIP_FILL;//	if(editMode==ROTATE_OUT_VIEW)flags|=CLIP_FRAME; // DAS-VR-FIX 10/1/93	virtusClipper->NewDrawPoly(clPts,flags,NULL,FALSE,FALSE,vPatBlack,NULL,NULL,TRUE,NULL);		// MERGE-GOURAUD//	virtusClipper->NewDrawPoly(clPts,flags,FALSE,FALSE,vPatBlack,NULL,NULL,TRUE,NULL);    	outline->Unuse();	points->Unuse();	   		VSetPattern(vPatBlack);	VPenMode(vPatCopy);	}voidCAVObject::Hilite(int newState)	{		Rect			r,bR;	PointLong		*lp,adjPt;	PointLong		drawOrigin;	int				length,i,h,v;	short			*index;				drawOrigin = environment->GetDrawOrigin();	r = environment->dataRect;		VPenMode(vPatXor);	VSetPattern(vPatBlack);	length = outline->ALength();	lp = (PointLong*)points->Use();	index = (short*)outline->Use();	//	VTextMode(vSrcXor);	// 	TextSetUp(vButtonFont,vButtonFontSize,vNormal);		for(i = 0; i < length; i++,index++)		{		adjPt.h = lp[*index].h - drawOrigin.h - 2;		adjPt.v = lp[*index].v - drawOrigin.v;		if(adjPt.v<=r.bottom&&adjPt.v>=r.top&&adjPt.h<=r.right&&adjPt.h>=r.left)			{			bR.left = adjPt.h;			bR.bottom = adjPt.v+3;			bR.top = bR.bottom-5;			bR.right=bR.left+5;			VFrameRect(&bR);//			VDrawChar(cornerSymbol,&bR);			}		}//	TextSetUp(vSystemFont,vSystemFontSize,vNormal);//	VTextMode(vSrcOr);	outline->Unuse();	points->Unuse();			VSetPattern(vPatBlack);	VPenMode(vPatCopy);	}	intCAVObject::Find(V_Array *pieces,PolyConvex *convex,PointLong *p,int method,int slop)	{		PolyConvex	**convexs;	PointLong *lp,sp;	int	surfNum,inside,i,length;		sp = *p;	surfNum = NO_MARK;		if(slop)		{		PointLong tmin,tmax;				tmin.h = cmin.h + slop;		tmin.v = cmin.v + slop;		tmax.h = cmax.h - slop;		tmax.v = cmax.v - slop;				inside = PtInBounds(sp,tmin,tmax);		}	else			inside = PtInBounds(sp,cmin,cmax);			if(inside)		{		lp = (PointLong*)points->Use();		surfNum = FindConvexSurface(convex,lp,p,method);			points->Unuse();		}		*p = sp;		return(surfNum);	}intCAVObject::FindDetail(PointLong *p,short *mark, short *surf, int inflate)	{	PointLong	*lp;	PointLong	sp,tl,br;	Point 		tp;	int			length,i;	short		*inIndex,*index,mode,spot;				sp = *p;	mode = OUT_POLY;	spot = NO_MARK;	tp.h = p->h;	tp.v = p->v;						if(!PtInBounds(sp,cmin,cmax)) 		{ 		*mark = spot;		*surf = spot; 		return(mode); 		}	/* mode = IN_POLY; */	if(ROTATE_OUT_VIEW == editMode) 		{ 		*mark = spot;		*surf = spot; 		return(IN_POLY); 		}		mode = OUT_POLY;		length = outline->ALength();	inIndex = (short*)outline->Use();	index = inIndex;	lp = (PointLong*)points->Use();	/* search for end points */			for(i = 0; i < length; i++,inIndex++)		{		tl.h = lp[*inIndex].h - 3;		tl.v = lp[*inIndex].v - 3;		br.h = lp[*inIndex].h + 4;		br.v = lp[*inIndex].v + 4;		if(PtInBounds(sp,tl,br))			{ 			if(IN_DEF_VIEW == editMode)				mode = ON_POLY_POINT; 			else 				{				switch(inflate)					{					case INFL_EXTRUDE:						if(1 == i)i = 0; else if(3 == i) i = 2;						mode = ON_POLY_DEFLINE; 						break;										case INFL_CONVERGE:					case INFL_ELLIPSE:						mode = ON_POLY_DEFLINE; 						break;										case INFL_DUALCONVERGE:					case INFL_DUALELLIPSE:						if(0 == i || 2 == i)mode = ON_POLY_DEFLINE; 						else mode = ON_POLY_SIDLINE; 						break;					}				}							spot = i; 			p->h = lp[*inIndex].h; 			p->v = lp[*inIndex].v;  			break; 			}		}	/* end of searching for points */				/* search for edges */							if(NO_MARK == spot)		{			Point	a,b,tp;			for(i = 0; i < length; i++)			{			/* axoffset - these all have to be longs */			a.h = lp[index[i]].h; a.v = lp[index[i]].v;			b.h = lp[index[nextIndex(i,1,length)]].h;			b.v = lp[index[nextIndex(i,1,length)]].v;			tp.h = sp.h; tp.v = sp.v;							if(PtOnLine(tp,a,b)) 				{ /*				tp = ExactPtOnLine(tp,a,b);*/				p->h = tp.h;				p->v = tp.v;				if(IN_DEF_VIEW == editMode || (OUT_DEF_VIEW == editMode && (0 == i || 2 == i)))					mode = ON_POLY_DEFLINE;				else					mode = ON_POLY_SIDLINE;				spot = i; 				break; 				}				} 		}	/* end of searching for lines */						outline->Unuse();	points->Unuse();						*mark = spot;	*surf = spot;	return(mode);	}	intCAVObject::FindConvexSurface(PolyConvex *pc,PointLong *lp,PointLong *p,int	method)	{	Surface	**surface;	int	i,j,found,pointLength,surfaceLength,surfNum = NO_MARK;	Point	a,b,tp; 	short	*index;		tp.h  = p->h;	tp.v  = p->v;		surfaceLength = pc->surfaces->ALength();	surface = (Surface	**)pc->surfaces->Use();		if(PERPINDICULAR & method)		{			for(i = 0; i < surfaceLength; i++,surface++)			{			/* check here if the normal is good for this view */			if((method & environment->SurfaceVisible((*surface)->posnNormal)))				{				pointLength = (*surface)->points->ALength();				index = (short*)(*surface)->points->Use();					for(j = 0; j < pointLength; j++)					{					a.h = lp[index[j]].h;					a.v = lp[index[j]].v;					b.h = lp[index[nextNum(j,pointLength)]].h;					b.v = lp[index[nextNum(j,pointLength)]].v;					if(found = PtOnLine(tp,a,b))						{						tp = ExactPtOnLine(tp,a,b);						p->h = tp.h;						p->v = tp.v;						break;						}					}					(*surface)->points->Unuse();									if(TRUE == found) 					{ surfNum = (*surface)->surfNum; break; }					}					}		}	else		{		for(i = 0; i < surfaceLength; i++,surface++)			{			/* check here if the normal is good for this view */			if((FACE_UP & environment->SurfaceVisible((*surface)->posnNormal)))				{				pointLength = (*surface)->points->ALength();				index = (short*)(*surface)->points->Use();					for(j = 0; j < pointLength; j++)					{					a.h = lp[index[j]].h;					a.v = lp[index[j]].v;					b.h = lp[index[nextNum(j,pointLength)]].h;					b.v = lp[index[nextNum(j,pointLength)]].v;					if(CLOCKWISE == (found = Clockwise(tp,a,b))) break;					}					(*surface)->points->Unuse();									if(CLOCKWISE != found && UNKNOWN != found) 					{ surfNum = (*surface)->surfNum; break; }					}					}		}			pc->surfaces->Unuse();					return(surfNum);	}/*=========================================================================*	void CAVObject::RotatePolyhedron(Point anchor,FFixed angle) *-------------------------------------------------------------------------*/void CAVObject::RotatePolyhedron(Point anchor,FFixed angle) 	{	PointLong	*lp;	PointLong	drawOrigin;	Point	np,tp,p;	int		i,length,ccos,ssin;	short *index;		drawOrigin = environment->GetDrawOrigin();	SetAngle(360 - angle.intg,&ssin,&ccos);	drawOrigin.h += anchor.h; drawOrigin.v += anchor.v;		length = outline->ALength();	index = (short*)outline->Use();	lp = (PointLong*)points->Use();			p.h = lp[index[length-1]].h - drawOrigin.h;	p.v = lp[index[length-1]].v - drawOrigin.v;	np.h = (((long)p.h * ccos - (long)p.v * ssin +64) >> 7) + anchor.h;	np.v = (((long)p.h * ssin + (long)p.v * ccos +64) >> 7) + anchor.v;	VMoveTo(np.h,np.v);		for(i = 0; i < length; i++,index++)		{		p.h = lp[*index].h - drawOrigin.h;		p.v = lp[*index].v - drawOrigin.v;		np.h = (((long)p.h * ccos - (long)p.v * ssin +64) >> 7) + anchor.h;		np.v = (((long)p.h * ssin + (long)p.v * ccos +64) >> 7) + anchor.v;		VLineTo(np.h,np.v);		}		points->Unuse();	outline->Unuse();	}	int CAVObject::BreakLine(Point p,int mark,int addFlag) 	{	PointLong	*lp;	PointLong 	drawOrigin;	Point		l1,l2,r1,r2;	int			i,length,result;	short		*index,next,next1,prev1;		drawOrigin = environment->GetDrawOrigin();		length = outline->ALength();	index = (short*)outline->Use();	lp = (PointLong*)points->Use();		next = nextIndex(mark,1,length);	l2.h = lp[index[mark]].h - drawOrigin.h;l2.v = lp[index[mark]].v - drawOrigin.v;	r2.h = lp[index[next]].h - drawOrigin.h;r2.v = lp[index[next]].v - drawOrigin.v;	prev1 = prevIndex(mark,1,length);		l1.h = lp[index[prev1]].h - drawOrigin.h;l1.v = lp[index[prev1]].v - drawOrigin.v;		if(addFlag)		{		next1 = nextIndex(mark,2,length);		r1.h = lp[index[next1]].h - drawOrigin.h;r1.v = lp[index[next1]].v - drawOrigin.v;		if(!PointConvex(l1,l2,r1,r2,p))			{			VMoveTo(l2.h,l2.v);			VLineTo(r2.h,r2.v);				result = FALSE;			}		else			{			VMoveTo(l2.h,l2.v);			VLineTo(p.h,p.v);			VLineTo(r2.h,r2.v);			result = TRUE;			}		}	else		{		VMoveTo(l1.h,l1.v);		VLineTo(l2.h,l2.v);		VLineTo(r2.h,r2.v);		result = TRUE;		}	points->Unuse();	outline->Unuse();		return(result);	}int CAVObject::MovePolyhedronPoint(Point p,long modifiers,int mark) 	{	PointLong	*lp;	PointLong 	drawOrigin;	Point 		l1,l2,r1,r2;	int			length,next,prev,next1,prev1,okay;	short	*index;		okay = TRUE;	drawOrigin = environment->GetDrawOrigin();				length = outline->ALength();	index = (short*)outline->Use();	lp = (PointLong*)points->Use();		prev = prevIndex(mark,1,length);	next = nextIndex(mark,1,length);		l2.h = lp[index[prev]].h - drawOrigin.h;l2.v = lp[index[prev]].v - drawOrigin.v;	r2.h = lp[index[next]].h - drawOrigin.h;r2.v = lp[index[next]].v - drawOrigin.v;		if(length>3)			{		prev1 = prevIndex(mark,2,length);		next1 = nextIndex(mark,2,length);				l1.h = lp[index[prev1]].h - drawOrigin.h;l1.v = lp[index[prev1]].v - drawOrigin.v;		r1.h = lp[index[next1]].h - drawOrigin.h;r1.v = lp[index[next1]].v - drawOrigin.v;#if MACINTOSH  // jca 4FEB94 this lets you make non-convex objects. 	   	if(!(V_CONTROL&modifiers) && !PointConvex(l1,l2,r1,r2,p))#elif WINDOWS  // V_CONTROL on Windows does what the OPTION key does on Mac.  Danger, Will Robinson. 		if(!PointConvex(l1,l2,r1,r2,p))#endif // MACINTOSH			okay = FALSE;		}		if(okay)		{		VMoveTo(l2.h,l2.v);		VLineTo(p.h,p.v);		VLineTo(r2.h,r2.v);		}	else		{		VMoveTo(l2.h,l2.v);		VLineTo(r2.h,r2.v);			}			points->Unuse();	outline->Unuse();	return(okay);	}/*=========================================================================*	void CAVObject::MoveRectanglePoint(Point lastPt,FFixed tangle,int mark) *-------------------------------------------------------------------------*/void CAVObject::MoveRectanglePoint(Point lastPt,FFixed tangle,int mark) 	{	Point	pointArray[4];	PointLong	*lp;	PointLong 	drawOrigin;	Point 		p0,p2,pt;	int			length,next;		short 	*index;		drawOrigin = environment->GetDrawOrigin();		length = outline->ALength();	index = (short*)outline->Use();	lp = (PointLong*)points->Use();		next = nextIndex(mark,2,length);			p0.h = lp[index[mark]].h - drawOrigin.h;	p0.v = lp[index[mark]].v - drawOrigin.v;	p2.h = lp[index[next]].h - drawOrigin.h;	p2.v = lp[index[next]].v - drawOrigin.v;	pt.h = lastPt.h - p0.h;	pt.v = lastPt.v - p0.v;		RotateRect(pointArray,p0,p2,pt,tangle,LIM_NONE,TRUE);			points->Unuse();	outline->Unuse();	}				/*=========================================================================*	void CAVObject::MoveRegPoint(Point p,FFixed angle,int nSides,int mark) *-------------------------------------------------------------------------*/void CAVObject::MoveRegPoint(Point p,FFixed newAngle,int nSides,int mark) 	{	V_Array 	*pp;	PointLong 	drawOrigin;	Point		pt,*rp;	long		xx,yy;	int			rad,i,length;		drawOrigin = environment->GetDrawOrigin();					pt.h = origin.h - drawOrigin.h;	pt.v = origin.v - drawOrigin.v;	p.h -= pt.h;p.v -= pt.v;	xx = (long)p.h * p.h;	yy = (long)p.v * p.v;	rad = LSqrt(xx + yy);		pp = RegularPoly(outline->ALength(),pt,rad,FindAngle(p.h,p.v));	length = pp->ALength();	rp = (Point*)pp->Use();	VMoveTo(rp[length-1].h,rp[length-1].v);	for(i = 0; i < length; i++,rp++)		VLineTo(rp->h,rp->v);	pp->Unuse();	pp->dArray();	}	int CAVObject::MovePolyhedronLine(Point p,FFixed angle,int mark,int inflate,long modifiers) 	{	PointLong	*lp;	PointLong 	drawOrigin;	Point 		tl,br,r1,r2,r3,r4,l1,l2,p1,p2,ofst;	int			i,length,next,next1,next2,prev,prev1,okay;	short	*index;		okay = TRUE;					drawOrigin = environment->GetDrawOrigin();				length = outline->ALength();	index = (short*)outline->Use();	lp = (PointLong*)points->Use();		switch(inflate)		{		case INFL_DUALCONVERGE:		case INFL_DUALELLIPSE:			if(OUT_DEF_VIEW == editMode)				{				prev = previousNum(mark,length);				next = nextIndex(mark,1,length);				next1 =  nextIndex(mark,2,length);				ofst.h = p.h >> 1;ofst.v = p.v >> 1;				r1.h = lp[index[prev]].h - drawOrigin.h - ofst.h;r1.v = lp[index[prev]].v - drawOrigin.v - ofst.v;				r2.h = lp[index[mark]].h - drawOrigin.h - p.h;r2.v = lp[index[mark]].v - drawOrigin.v - p.v;				r3.h = lp[index[next]].h - drawOrigin.h - ofst.h;r3.v = lp[index[next]].v - drawOrigin.v - ofst.v;				r4.h = lp[index[next1]].h - drawOrigin.h;r4.v = lp[index[next1]].v - drawOrigin.v;				VMoveTo(r4.h,r4.v);				VLineTo(r1.h,r1.v);				VLineTo(r2.h,r2.v);				VLineTo(r3.h,r3.v);				VLineTo(r4.h,r4.v);				break;				}						case INFL_CONVERGE:		case INFL_ELLIPSE:			if(OUT_DEF_VIEW == editMode)				{				if(2 == mark)					{					VMoveTo(lp[index[1]].h - drawOrigin.h,lp[index[1]].v - drawOrigin.v);					VLineTo(lp[index[2]].h - drawOrigin.h - p.h,lp[index[2]].v - drawOrigin.v - p.v);					VLineTo(lp[index[0]].h - drawOrigin.h,lp[index[0]].v - drawOrigin.v);					break;					}				else 					mark = 0;				}						case INFL_EXTRUDE:			prev1 = prevIndex(mark,2,length);			prev = prevIndex(mark,1,length);			next = nextIndex(mark,1,length);			next1 = nextIndex(mark,2,length);			next2 = nextIndex(mark,3,length);			r1.h = lp[index[prev1]].h - drawOrigin.h;r1.v = lp[index[prev1]].v - drawOrigin.v;			r2.h = lp[index[prev]].h - drawOrigin.h;r2.v = lp[index[prev]].v - drawOrigin.v;			p1.h = lp[index[mark]].h - drawOrigin.h - p.h;p1.v = lp[index[mark]].v - drawOrigin.v - p.v;			p2.h = lp[index[next]].h - drawOrigin.h - p.h;p2.v = lp[index[next]].v - drawOrigin.v - p.v;			l2.h = lp[index[next1]].h - drawOrigin.h;l2.v = lp[index[next1]].v - drawOrigin.v;			l1.h = lp[index[next2]].h - drawOrigin.h;l1.v = lp[index[next2]].v - drawOrigin.v;#if MACINTOSH // for debugging and testing.  V_CONTROL maps to the control key			if((4 < length) && !(V_CONTROL&modifiers)				&& !LineConvex(l1,l2,r1,r2,p1,p2))#elif WINDOWS  // V_CONTROL still maps to the control key, but we use that key for other things under Windows.			if((4 < length) && !LineConvex(l1,l2,r1,r2,p1,p2))#endif // MACINTOSH				okay = FALSE;							if(okay)				{				VMoveTo(r2.h,r2.v);				VLineTo(p1.h,p1.v);				VLineTo(p2.h,p2.v);				VLineTo(l2.h,l2.v);				}			else				{				VMoveTo(l2.h,l2.v);				VLineTo(r2.h,r2.v);				}				break;		}				points->Unuse();	outline->Unuse();		return(okay);	}	/*=========================================================================*	void CAVObject::MoveRectangleLine(Point lastPt,FFixed tangle,int mark) *-------------------------------------------------------------------------*/void CAVObject::MoveRectangleLine(Point lastPt,FFixed tangle,int mark) 	{	Point		pointArray[4];	PointLong	*lp;	PointLong 	drawOrigin;	Point 		p0,p2,pt;	int			length,restrict,next;		short 		*index;	drawOrigin = environment->GetDrawOrigin();				length = outline->ALength();	index = (short*)outline->Use();	lp = (PointLong*)points->Use();		next = nextIndex(mark,2,length);	p0.h = lp[index[mark]].h - drawOrigin.h;	p0.v = lp[index[mark]].v - drawOrigin.v;	p2.h = lp[index[next]].h - drawOrigin.h;	p2.v = lp[index[next]].v - drawOrigin.v;	pt.h = lastPt.h - p0.h;	pt.v = lastPt.v - p0.v;		if(0 == mark || 2 == mark) restrict = LIM_VERT; else restrict = LIM_HORZ;	RotateRect(pointArray,p0,p2,pt,tangle,restrict,TRUE);	points->Unuse();	outline->Unuse();	}		void CAVObject::MoveRegLine(Point p,int nSides,int mark) 	{	V_Array 	*pp;	PointLong 	drawOrigin,lp;	Point		pt,*rp;	long		xx,yy;	int			rad,i,length,angl;		drawOrigin = environment->GetDrawOrigin();					pt.h = origin.h - drawOrigin.h;	pt.v = origin.v - drawOrigin.v;	p.h -= pt.h;p.v -= pt.v;	xx = (long)p.h*p.h;	yy = (long)p.v*p.v;	points->Get(0,&lp);	lp.h -= origin.h;	lp.v -= origin.v;	angl = FindAngle(lp.h,lp.v);		rad = LSqrt(xx + yy);	/* radius is wrong here */		pp = RegularPoly(outline->ALength(),pt,rad,angl);	length = pp->ALength();	rp = (Point*)pp->Use();	VMoveTo(rp[length-1].h,rp[length-1].v);	for(i = 0; i < length; i++,rp++)		VLineTo(rp->h,rp->v);	pp->Unuse();	pp->dArray();	}	/*=========================================================================*	void CAVObject::MoveOutline( Point p	 )*-------------------------------------------------------------------------*/void CAVObject::MoveOutline(Point p) 	{	PointLong	*lp;	PointLong 	drawOrigin;	int			i,length;	short 	*index;		drawOrigin = environment->GetDrawOrigin();				length = outline->ALength();	index = (short*)outline->Use();	lp = (PointLong*)points->Use();		drawOrigin.h += p.h;	drawOrigin.v += p.v;	VMoveTo(lp[index[length-1]].h - drawOrigin.h,lp[index[length-1]].v - drawOrigin.v);	for(i = 0; i < length; i++,index++)		VLineTo(lp[*index].h - drawOrigin.h,lp[*index].v - drawOrigin.v);			points->Unuse();	outline->Unuse();	}	/*=========================================================================*	int CAVObject::ScalePolyhedronPoint(Point anchor,Point last,long modifiers,int mark) *  	*	Notes: *	¥ If the cursor hasn't moved, then the scale is 1.0.*	¥ When I'm scaling, I am scaling relative to some reference point.*		¥ The distance between the original point and  reference point give me *			the scaling increments.*		¥ The reference point won't change position after the scaling.*	¥ *-------------------------------------------------------------------------*/int CAVObject::ScalePolyhedronPoint(Point refPt,PointFFixed mult,long modifiers) 	{	PointLong 	drawOrigin,refOrigin,*lp,tp;	PointFFixed myMult,tmpFFPt;	int			i,length;	short 		*index;	Point		result;		if(!FFZero(mult.h))myMult.h = mult.h; else myMult.h = FFOne;	if(!FFZero(mult.v))myMult.v = mult.v; else myMult.v = FFOne;		drawOrigin = environment->GetDrawOrigin();	refOrigin.h = refPt.h + drawOrigin.h;			refOrigin.v = refPt.v + drawOrigin.v;						length = outline->ALength();	index = (short*)outline->Use();	lp = (PointLong*)points->Use();		tmpFFPt.h = FFMultIntShift(myMult.h,(lp[index[length-1]].h - refOrigin.h),0);	tmpFFPt.v = FFMultIntShift(myMult.v,(lp[index[length-1]].v - refOrigin.v),0);	tp.h = FFRound(tmpFFPt.h);	tp.v = FFRound(tmpFFPt.v);		result.h = tp.h + refOrigin.h - drawOrigin.h;	result.v = tp.v + refOrigin.v - drawOrigin.v;	VMoveTo(result.h,result.v);	for(i = 0; i < length; i++,index++)		{		tmpFFPt.h = FFMultIntShift(myMult.h,(lp[*index].h - refOrigin.h),0);		tmpFFPt.v = FFMultIntShift(myMult.v,(lp[*index].v - refOrigin.v),0);		tp.h = FFRound(tmpFFPt.h);		tp.v = FFRound(tmpFFPt.v);		result.h = tp.h + refOrigin.h - drawOrigin.h;		result.v = tp.v + refOrigin.v - drawOrigin.v;		VLineTo(result.h,result.v);		}	points->Unuse();	outline->Unuse();			return(TRUE);	}/*int CAVObject::ScalePolyhedronPoint(Point anchor,Point last,long modifiers,int mark) 	{	PointLong	*lp;	PointLong 	drawOrigin;	int			i,length;	short	*index;	PointFFixed	mult;	Point		result;		drawOrigin = environment->GetDrawOrigin();				last.h = last.h - (origin.h - drawOrigin.h);	last.v = last.v - (origin.v - drawOrigin.v);	anchor.h = anchor.h - (origin.h - drawOrigin.h);	anchor.v = anchor.v - (origin.v - drawOrigin.v);	drawOrigin.h -= origin.h;	drawOrigin.v -= origin.v;			if(last.h == anchor.h || 0 == anchor.h) mult.h = FFOne; 	else mult.h = DblToFixed((double)last.h/(double)anchor.h);		if(last.v == anchor.v || 0 == anchor.v) mult.v = FFOne; 	else mult.v = DblToFixed((double)last.v/(double)anchor.v);	length = outline->ALength();	index = (short*)outline->Use();	lp = (PointLong*)points->Use();		result.h = FFRound(FFMultIntShift(mult.h,(lp[index[length-1]].h - origin.h),0)) - drawOrigin.h;	result.v = FFRound(FFMultIntShift(mult.v,(lp[index[length-1]].v - origin.v),0)) - drawOrigin.v;	VMoveTo(result.h,result.v);	for(i = 0; i < length; i++,index++)		{		result.h = FFRound(FFMultIntShift(mult.h,(lp[*index].h - origin.h),0)) - drawOrigin.h;		result.v = FFRound(FFMultIntShift(mult.v,(lp[*index].v - origin.v),0)) - drawOrigin.v;		VLineTo(result.h,result.v);		}	points->Unuse();	outline->Unuse();		return(TRUE);	}*/	voidCAVObject::MakeOutl(V_Array *posnPoints,int outOfPlane,int defAxis,int nOutlPoints,int inflate,int nLevels,FFixed tp,FFixed bt)	{	int objView,i;	short *outl;	Point3DFFixed outl3DPnt,*wp,tmpPt;	PointFFixed *outlPnt;	FFixed tmin, tmax, comp;	int minNum, maxNum,length;	short	*index,started,theDirection,up,nHalf,view;		if(LESS == FFLogic(bt,tp)) up = TRUE; else up = FALSE;			if(outOfPlane)		{		outline->SetLength(4);		outl = (short*)outline->Use();		editMode = ROTATE_OUT_VIEW;		length = posnPoints->ALength();		for(i=length;i<length+4;i++) *outl++ = i;		outline->Unuse();		return;		}			switch(objView = environment->NormalizeView(defAxis))		{		case topView:		case bottomView:			outline->SetLength(nOutlPoints);			editMode = IN_DEF_VIEW;						outl = (short*)outline->Use();						switch(inflate)				{				case INFL_DUALCONVERGE:					nHalf = (nLevels-1) * nOutlPoints + 1;					if (topView == objView) for (i = nHalf; i < nOutlPoints+nHalf; i++) *outl++ = i;					else for (i = nOutlPoints; i >= 1; i--) *outl++ = i;					break;									case INFL_DUALELLIPSE:					nHalf = (nLevels-1) * nOutlPoints + 1;					if (topView == objView) for (i = nHalf; i < nOutlPoints+nHalf; i++) *outl++ = i;					else for (i = nHalf+nOutlPoints-1; i >= nHalf; i--) *outl++ = i;					break;									case INFL_ELLIPSE:				case INFL_CONVERGE:					if(up) nHalf = (nLevels-1) * nOutlPoints + 1; else nHalf = 0;					if (topView == objView) for (i = nHalf; i < nOutlPoints+nHalf; i++) *outl++ = i;					else for (i = nHalf+nOutlPoints-1; i >= nHalf; i--) *outl++ = i;					break;				case INFL_EXTRUDE:				default:					if (topView == objView) for (i = 0; i < nOutlPoints; i++) *outl++ = i;					else for (i = nOutlPoints+nOutlPoints-1; i >= nOutlPoints; i--) *outl++ = i;					break;								}							outline->Unuse();			break;				case frontView:		case backView:		case rightView:		case leftView:					editMode = OUT_DEF_VIEW;								switch(inflate)				{				case INFL_DUALCONVERGE:				case INFL_DUALELLIPSE:					nHalf = (nLevels-1) * nOutlPoints + 1;					outline->SetLength(4);					break;									case INFL_ELLIPSE:				case INFL_CONVERGE:					outline->SetLength(3);					if(up) nHalf = (nLevels-1) * nOutlPoints + 1; else nHalf = 0;					break;				case INFL_EXTRUDE:				default:					outline->SetLength(4);					nHalf = 0;					break;				}							wp = (Point3DFFixed*)posnPoints->Use();			view = environment->GetView();			comp = Translate2Outline(wp[nHalf],defAxis,view);			tmin = comp;tmax = comp; 			minNum = nHalf; maxNum = nHalf; 			for (i = nHalf; i < nOutlPoints+nHalf; i++)				{				comp = Translate2Outline(wp[i],defAxis,view);				if(LESS == FFLogic(comp,tmin)){ tmin = comp; minNum = i; }				if(GRTR == FFLogic(comp,tmax)){ tmax = comp; maxNum = i; }				}			posnPoints->Unuse();							outl = (short*)outline->Use();			/* Create the side outlines such that line zero corresponds to */			/* the "near" end and line two corresponds to the "far" end. */						if (objView != backView || objView != rightView)				{				int swap;				swap = minNum; minNum = maxNum; maxNum = swap;				}							switch(inflate)				{				case INFL_DUALCONVERGE:				case INFL_DUALELLIPSE:					outl[0] = 0;					outl[1] = maxNum;					outl[2] = posnPoints->ALength()-1;					outl[3] = minNum;					break;									case INFL_ELLIPSE:					outl[0] = minNum;					outl[1] = maxNum;					if(up) outl[2] = 0; else outl[2] = posnPoints->ALength()-1;					break;									case INFL_CONVERGE:					outl[0] = minNum;					outl[1] = maxNum;					if(up) outl[2] = 0; else outl[2] = nOutlPoints;					break;				case INFL_EXTRUDE:				default:					outl[0] = minNum;					outl[1] = maxNum;					outl[2] = maxNum + nOutlPoints;					outl[3] = minNum + nOutlPoints;					break;				}													outline->Unuse();			break;		}	}	/*=========================================================================*	Point3DFFixed CAVObject::Translate2Outline()*-------------------------------------------------------------------------*/FFixed CAVObject::Translate2Outline(Point3DFFixed tp,int defAxis,int view) 	{	FFixed	val;	tp = environment->Translate3DFFixed(TO_CAD,tp);		switch(defAxis)		{		case INFL_Z: val = tp.x; break;		case INFL_Y:			if(topView == view || bottomView == view)val = tp.x; else val = tp.y;			break;		case INFL_X: val = tp.y; break; break;		}	return(val);	}