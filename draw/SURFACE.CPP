/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	 *				David W. Easter *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VDisplay.h"#include "Surface.h"#include "Drawing.h"#include "Polyhdrn.h"#include "PolyConv.h"#include "SurfDef.h"#include "SurfFeat.h"#include "Position.h"#include "Slice.h"#include "Light.h"#include "View.h"#include "Clip.h"#include "Flash.h"			// ABD MERGE-TEXTURE 9/13/93 #include "TextItem.h"		// ABD MERGE-TEXTURE 9/13/93#include "TextSrvr.h"		// ABD MERGE-TEXTURE 9/13/93#include "VGraphic.h"#include "VGUtil.h"#include "VArray.h"#include "VMath.h"#include "InTransp.h"#include "Geometry.h"#include "Region.h"#include <stddef.h>#include <math.h>#include "Matrix.h"			// ABD MERGE-GOURAUD DEBUG ??? еее#include "Gouraud.h"		// MERGE-GOURAUD#include "VMemUtil.h"		// MERGE-GOURAUD#include "VTimer.h"	// DEBUG еееееееextern TextureShader gTextureShader;	// ABD MERGE-TEXTURE 9/13/93intSurface::cSurface(PolyConvex *poly, SurfDef *sDef, int sNum, V_Array *pnts)	{	int anError = 0;	// jca 20 Nov 93  erros can happen	VSetCursor(vCursorEarth);	/*	 *	Set up references to our neighbors.	 */	polyConvex = poly;	surfDef = sDef;	surfNum = sNum;	/*	 *	Set up surface points and compute derived data.	 */	points = new(V_Array);	points->cArray(0, sizeof(short), 4);	pnts->CopyArray(points);	if (CalcNorm())		anError = -1;     // jca 20 Nov 93// ABD MERGE-TEXTURE 9/13/93 [[[	outline = NULL;							// ABD MERGE-MEM	rawInsideTexturePoints = NULL;			// ABD MERGE-MEM	rawOutsideTexturePoints = NULL;			// ABD MERGE-MEM	rendInsideTexturePoints = NULL;			// ABD MERGE-MEM	rendOutsideTexturePoints = NULL;		// ABD MERGE-MEM	insideTextureShade = NULL;	// ABD TEXTURE 	outsideTextureShade = NULL;	// ABD TEXTURE 	NoPerspPointArray = new(V_Array);		// JAM TEXTURE	NoPerspPointArray->cArray(0, sizeof(short), 4);		// JAM TEXTURE	NoPerspPoints = NoPerspPointArray;		// JAM TEXTURE// ABD MERGE-TEXTURE 9/13/93 ]]]// ABD MERGE-GOURAUD [[[	rawInsideIntensities = NULL;	rawOutsideIntensities = NULL;	rendInsideIntensities = NULL;	rendOutsideIntensities = NULL;// ABD MERGE-GOURAUD ]]]	/*	 *	Set up data for 3D rendering.	 */	rendPointArray = new(V_Array);	rendPointArray->cArray(0, sizeof(short), 4);	rendPoints = rendPointArray;	visible = 0;	clipped = 0;    return(anError);		// jca 20 Nov 93	}voidSurface::dSurface()	{	points->dArray();	rendPointArray->dArray();// ABD MERGE-TEXTURE 9/13/93 [[[	if (outline) outline->dArray();			// ABD TEXTURE	if (rawInsideTexturePoints) rawInsideTexturePoints->dArray();			// ABD TEXTURE	if (rawOutsideTexturePoints) rawOutsideTexturePoints->dArray();			// ABD TEXTURE	if (rendInsideTexturePoints) rendInsideTexturePoints->dArray();			// ABD TEXTURE	if (rendOutsideTexturePoints) rendOutsideTexturePoints->dArray();		// ABD TEXTURE	NoPerspPointArray->dArray();		// JAM TEXTURE// ABD MERGE-TEXTURE 9/13/93 ]]]// ABD MERGE-GOURAUD [[[	if (rawInsideIntensities) rawInsideIntensities->dArray();	if (rawOutsideIntensities) rawOutsideIntensities->dArray();	if (rendInsideIntensities) rendInsideIntensities->dArray();	if (rendOutsideIntensities) rendOutsideIntensities->dArray();// ABD MERGE-GOURAUD ]]]//	if (surfRgn[0]) surfRgn[0]->dRegion();			// BILBIL - multiple surface connections//	if (surfRgn[1]) surfRgn[1]->dRegion();			// BILBIL - multiple surface connections	delete(this);	}/* optimizations:		cache distance values--calc here when first needed for poly & save in list		don't convert a, b, c, d to double for every surface--pass in		don't convert points to double until needed for clip calculation*/intSurface::SliceX(Slice *slice, V_Array *dist, V_Array *lines)	{	double a, b, c, d;	V_Array *polyPoints, *pointsOut;	double *distVal;	int nSurfPoints, i;	short *surfPnt, *surfPntIndex, pntNum, linePnt1, linePnt2;	long line;	Point3DFFixed *pnt, pt, clipPt;	Point3Ddouble thisPt, lastPt;	double thisDist, lastDist;    int returnCode;  // jca 8 Dec 93	VSetCursor(vCursorEarth);	a = FixedToDbl(slice->a);	b = FixedToDbl(slice->b);	c = FixedToDbl(slice->c);	d = FixedToDbl(slice->d);	polyPoints = polyConvex->polyhedron->points;	distVal = (double *)dist->Use();	pointsOut = new(V_Array);	pointsOut->cArray(0, sizeof(short), 4);		linePnt1 = -1;	linePnt2 = -1;	nSurfPoints = points->ALength();	surfPnt = surfPntIndex = (short *)points->Use();		for (i = 0; i < nSurfPoints+1; i++, surfPntIndex++)		{		if (i < nSurfPoints)			pntNum = *surfPntIndex;		else			pntNum = *surfPnt;// XYZZY 6.18.92 //		//		pnt = (Point3DFFixed *)polyPoints->Use();//		pt = pnt[pntNum];		polyPoints->Get(pntNum,&pt);		thisPt.x = FixedToDbl(pt.x);		thisPt.y = FixedToDbl(pt.y);		thisPt.z = FixedToDbl(pt.z);		thisDist = distVal[pntNum];//		polyPoints->Unuse();		/* neither old or new points are clipped away */		if (thisDist >= 0 && (i == 0 || lastDist >= 0))			{			if (i < nSurfPoints)				pointsOut->Append(surfPntIndex);			}		/* both old and new points are clipped away */		else if (thisDist < 0 && (i == 0 || lastDist < 0))			/* do nothing */ ;		/* only new point is clipped away -- cross from unclipped to clipped */		else if (thisDist < 0)			{			CalcClip(&lastPt, &thisPt, lastDist, thisDist, &clipPt);						linePnt1 = FindPoint(&clipPt);			pointsOut->Append(&linePnt1);			if (linePnt2 >= 0 && linePnt1 != linePnt2)				{				line = (long)linePnt1 << 16 | linePnt2;				lines->Append(&line);				}			}		/* only old point is clipped away -- cross from clipped to unclipped */		else if (lastDist < 0)			{			CalcClip(&thisPt, &lastPt, thisDist, lastDist, &clipPt);			linePnt2 = FindPoint(&clipPt);			pointsOut->Append(&linePnt2);			if (i < nSurfPoints)				pointsOut->Append(surfPntIndex);						if (linePnt1 >= 0 && linePnt1 != linePnt2)				{				line = (long)linePnt1 << 16 | linePnt2;				lines->Append(&line);				}			}			lastPt = thisPt;		lastDist = thisDist;		}	points->Unuse();	dist->Unuse();	pointsOut->CopyArray(points);	pointsOut->dArray();#if WINDOWS    // this only seems to be a problem under windows.  Thank you, SANE	if (points->ALength() >= 3)    // jca 8 Dec 93 {		{  // we *must* have 3 distinct points.  Or else.		short v1, v2, which, *pts;		pts = (short *)points->Abuse();		for (i = 0, which = 0; i < points->ALength(); i++)			{			if (which == 0)            	{				v1 = pts[i];                which++;                }			else if (which == 1)				{				if (v1 != pts[i])					{					which++;					v2 = pts[i];                     }				}			else if (which == 2)				{				if ((pts[i] != v1) && (pts[i] != v2))					{					which++;                    break;                    }				}            else	break;            			}		if (which > 2)			returnCode = 1;		else        	returnCode = 0;		}	else    	returnCode = 0;	return(returnCode);         // jca 8 Dec 93 }#elif MACINTOSH	return(points->ALength() != 0);#endif	}voidSurface::PositionX(Position *scalePosn, Position *shearPosn, Position *rotatePosn, int invert)	{	long	i;		PosnNorm(scalePosn, shearPosn, rotatePosn);	CalcShade();	if (invert) points->Reverse();	/*	for (i=0; i<= 1; i++)		if (!IS_OPAQUE(opacity) && (surfDef != NULL) && (surfDef->flatConnections[i]))			{			Connection	conn;			V_Array		*tempArray;			long		length, loop;			V_Region	*sRgn;						tempArray = new(V_Array);			tempArray->cArray(0,sizeof(PointFFixed),4);			conn.poly = surfDef->polyhedron;			conn.surf = surfDef;			Fast2DFromConnection(&conn, tempArray);			sRgn = new(V_Region);			sRgn->cRegion(tempArray);						length = surfDef->flatConnections[i]->ALength() -1;			for (loop = length; loop >= 0; loop --)				{				surfDef->flatConnections[i]->Get(loop, &conn);				tempArray->SetLength(0);				Fast2DFromConnection(&conn, tempArray);				sRgn->AddCompliment(tempArray);				}			if (sRgn->Compliment())				renderPoly[i] = TRUE;			else				renderPoly[i] = FALSE;				sRgn->dRegion();			tempArray->dArray();			}		else renderPoly[i] = TRUE;*/	}// MERGE-GOURAUD [[[// ABD this is a special version of PositionX that does not call CalcShade().  We cannot call// CalcShade() until all surfaces have been positioned, so if any surface is gouraud shaded// in the poly, when and Update() is done, we do this routine for each surface, and then // after all normals have been fixed up we do a CalcShade() for each surface.voidSurface::PositionXG(Position *scalePosn, Position *shearPosn, Position *rotatePosn, int invert)	{	PosnNorm(scalePosn, shearPosn, rotatePosn);	// note no call to CalcShade here	if (invert) points->Reverse();	}// MERGE-GOURAUD ]]]intSurface::CalcNorm()	{	Point3DFFixed norm, *pnt, pt0, pt1, pt2;	short *pntIndex;	int nPoints, i, p0, p1, p2;	long xx, yy, zz;		double dxx,dyy,dzz,mag;	norm = polyConvex->polyhedron->SurfNormal(surfNum);// DAS-HIRES 8/8/93 this needs to be doubles for really small surfaces	if (FFZero(norm.x) && FFZero(norm.y) && FFZero(norm.z))		{		nPoints = points->ALength();		pntIndex = (short *)points->Abuse();		pnt = (Point3DFFixed*)polyConvex->polyhedron->points->Abuse();				p0 = 0;		p1 = nPoints+2 >> 2;		p2 = nPoints+1 >> 1;			pt0 = pnt[pntIndex[p0]];		pt1 = pnt[pntIndex[p1]];		pt2 = pnt[pntIndex[p2]];		dxx = (double)(pt0.y.l - pt1.y.l) * (double)(pt2.z.l - pt1.z.l) -			(double)(pt2.y.l - pt1.y.l) * (double)(pt0.z.l - pt1.z.l);		dyy = (double)(pt2.x.l - pt1.x.l) * (double)(pt0.z.l - pt1.z.l) -			(double)(pt0.x.l - pt1.x.l) * (double)(pt2.z.l - pt1.z.l);		dzz = (double)(pt0.x.l - pt1.x.l) * (double)(pt2.y.l - pt1.y.l) -			(double)(pt2.x.l - pt1.x.l) * (double)(pt0.y.l - pt1.y.l);				mag=sqrt(dxx*dxx+dyy*dyy+dzz*dzz);		if (mag)	// jca 20 Nov 93  mag _can_ be zero  {        	{			xx=32767*dxx/mag;			yy=32767*dyy/mag;			zz=32767*dzz/mag;			}		else        	return(-1);    // jca 20 Nov 93 }		}	else		{		xx = norm.x.l;		yy = norm.y.l;		zz = norm.z.l;		}	normal = Normalize(xx, yy, zz);    return(0);	}voidSurface::PosnNorm(Position *scalePosn, Position *shearPosn, Position *rotatePosn)	{	Point3DFFixed pnt;		pnt.x.intg = normal.x; pnt.x.frac = 0;	pnt.y.intg = normal.y; pnt.y.frac = 0;	pnt.z.intg = normal.z; pnt.z.frac = 0;	if (scalePosn != NULL)		pnt = scalePosn->Transform3D(pnt);	/* Ick; Position can't represent normal transformation for shear, */	/* so we have to do it manually */	if (shearPosn != NULL)		{		Shear3DFFixed shr = shearPosn->GetShear3D();		FFixed xTerm, yTerm;		yTerm = FFMult(pnt.y, shr.yz);		xTerm = FFMult(pnt.x, FFSub(shr.xz, FFMult(shr.xy, shr.yz)));		pnt.z = FFSub(pnt.z, FFAdd(yTerm, xTerm));		pnt.y = FFSub(pnt.y, FFMult(pnt.x, shr.xy));		/* pnt.x = pnt.x; */		}	if (rotatePosn != NULL)		pnt = rotatePosn->Transform3D(pnt);	posnNormal = Normalize(pnt.x.l, pnt.y.l, pnt.z.l);	}// MERGE-GOURAUD [[[// this routine returns an accurate dot product between the two given vectors -- which need not// be normalized double VectDotDouble(Point3D v1, Point3D v2);doubleVectDotDouble(Point3D v1, Point3D v2){Point3Ddouble v1d, v2d;double len;	v1d.x = (double)v1.x;	v1d.y = (double)v1.y;	v1d.z = (double)v1.z;	v2d.x = (double)v2.x;	v2d.y = (double)v2.y;	v2d.z = (double)v2.z;		len = VectLengthPointDouble(&v1d);	if(len != 0.0)    {		v1d.x /= len;		v1d.y /= len;		v1d.z /= len;    }	len = VectLengthPointDouble(&v2d);	if(len != 0.0)    {		v2d.x /= len;		v2d.y /= len;		v2d.z /= len;	}	return (((double)(v1d.x) * (double)(v2d.x)) + 			((double)(v1d.y) * (double)(v2d.y)) + 			((double)(v1d.z) * (double)(v2d.z)));}// returns TRUE if s1 has shares vertex vert int SurfaceHasVertex(Surface *s1, short vert);int SurfaceHasVertex(Surface *s1, short vert){short *s1_indx = (short*)s1->points->Use();int i;int return_val = FALSE;	for ( i = 0 ; i < s1->points->ALength() ; i++ )	{		if (s1_indx[i] == vert)		{			return_val = TRUE;			break;		}	}	s1->points->Unuse();	return return_val;}// MERGE-GOURAUD ]]] voidSurface::CalcShade()	{	LightModel *iLight, *oLight;	Point3D n;	Polyhedron *poly = polyConvex->polyhedron;	VSetCursor(vCursorEarth);	if (surfDef != NULL)		{		insideColor = surfDef->GetColor(SURF_INSIDE);		outsideColor = surfDef->GetColor(SURF_OUTSIDE);		opacity = surfDef->GetOpacity();		}	else		{		insideColor = polyConvex->polyhedron->GetColor(SURF_INSIDE);		outsideColor = polyConvex->polyhedron->GetColor(SURF_OUTSIDE);		opacity = polyConvex->polyhedron->GetOpacity();		}	n.x = -posnNormal.x;	n.y = -posnNormal.y;	n.z = -posnNormal.z;	iLight = poly->FindLightModel();	if (poly->container != NULL)		oLight = poly->container->FindLightModel();	else		oLight = iLight;	if (iLight != NULL)		insideShade = iLight->CalcShade(insideColor, n);	else		insideShade = vBlack;	if (oLight != NULL)		outsideShade = oLight->CalcShade(outsideColor, posnNormal);	else		outsideShade = vBlack;	if (surfDef != NULL)		surfDef->CalcShade();// ABD MERGE-TEXTURE 9/13/93 [[[	// ABD TEXTURE	// calc texture shading	if (iLight != NULL)	{	FFixed shade_level = iLight->CalcShadeLevel(NUM_TEXTURE_SHADING_LEVELS, n);		// MERGE-GOURAUD					insideTextureShade = &(gTextureShader[shade_level.intg]);		// MERGE-GOURAUD ABD TEXTURE 	}	else		insideTextureShade = &(gTextureShader[NUM_TEXTURE_SHADING_LEVELS-1]);	// black			if (oLight != NULL)	{	FFixed shade_level = oLight->CalcShadeLevel(NUM_TEXTURE_SHADING_LEVELS, posnNormal);		// MERGE-GOURAUD			outsideTextureShade = &(gTextureShader[shade_level.intg]);		// MERGE-GOURAUD ABD TEXTURE 	}	else		outsideTextureShade = &(gTextureShader[NUM_TEXTURE_SHADING_LEVELS-1]);	// black// ABD MERGE-TEXTURE 9/13/93 ]]]// ABD MERGE-GOURAUD [[[if ((iLight != NULL) && (oLight != NULL)){short *indx;Surface **srf;int i, j, k;Point3D inside_normal;Point3D outside_normal;Point3DFFixed pnt;FFixed shade_level;V_Array *shi, *sho;FFixed *sh_in, *sh_out;double val;int in = FALSE;int out = FALSE;	ObjLock((ObjectHandle)this);	insideColorIndex = gOff8->ColorTo256(&insideColor);	outsideColorIndex = gOff8->ColorTo256(&outsideColor);	ObjUnlock((ObjectHandle)this);	// gouraud shading scheme:  We loop through each vertex in this surface, and determine	// which other surfaces in this poly share this vertex.  Once we have a list of common	// surfaces, we compute the average surface normal for these surfaces -- we average 	// only those surfaces that are almost parallel -- i.e. the angle between the surfaces	// is below some threshold.  We then use the average normal to compute a shading value	// for this vertex.  After we compute all of the shading values for the vertices, we	// loop through them and make sure that they are all different -- if they are all the	// same we reset the shading to SHADE_FLAT to save rendering time.  		// еее╩note: right now this takes into account only those surfaces in the same polyconvex;	// we should probably take into account surfaces in the polyhedron, or in the same group	// or something	indx = (short*)points->Use();	srf = (Surface**)polyConvex->surfaces->Use();		// is either side gouraud shaded???	if (GetShadeType(SURF_INSIDE) == SHADE_GOURAUD)		in = TRUE;	if (GetShadeType(SURF_OUTSIDE) == SHADE_GOURAUD)		out = TRUE;			// if neither side is gouraud shaded, just leave 	if ((!in) && (!out)) 		goto endit;		if (in) 	{		shi = GetRawIntensities(SURF_INSIDE);		shi->SetLength(points->ALength());		sh_in = (FFixed*)shi->Use();	}	if (out)	{		sho = GetRawIntensities(SURF_OUTSIDE);		sho->SetLength(points->ALength());		sh_out = (FFixed*)sho->Use();	}		// loop through all the points in this surface	for ( i = 0 ; i < points->ALength() ; i++ )	{	Point3Ddouble inside_normal_sum;	// reset normal stuff for this vertex	Point3Ddouble outside_normal_sum;	short num_inside_normals = 1;	short num_outside_normals = 1;			inside_normal_sum.x = (double)-posnNormal.x;		inside_normal_sum.y = (double)-posnNormal.y;		inside_normal_sum.z = (double)-posnNormal.z;			outside_normal_sum.x = (double)posnNormal.x;		outside_normal_sum.y = (double)posnNormal.y;		outside_normal_sum.z = (double)posnNormal.z;			// loop through all the surfaces in this polyconvex		for ( j = 0 ; j < polyConvex->surfaces->ALength() ; j++ )		{			// do not do anything if this surface is the same as the surface we are looking at --			// don't average in our own normals			if (this == srf[j])				continue;						// if the surface we are looking at has vertex indx[i], then average the normals 			if ( SurfaceHasVertex(srf[j], indx[i]) )			{			Point3D n0;			double dot;							// this surface shares a vertex -- do something with it								// first we compare the inside normals (n is inside normal for this surface)				// make the inside normal of srf[j]->posnNormal				n0.x = -srf[j]->posnNormal.x;				n0.y = -srf[j]->posnNormal.y;				n0.z = -srf[j]->posnNormal.z;								// compare n and n0				dot = VectDotDouble(n, n0);								// if they are close enough, then add in the srf[j] normal to the sum				if (dot > 0.0)				{					inside_normal_sum.x += (double)(n0.x);					inside_normal_sum.y += (double)(n0.y);					inside_normal_sum.z += (double)(n0.z);					num_inside_normals++;				}								// second, we compare the outside normals								// compare posnNormal and srf[j]->posnNormal				dot = VectDotDouble(posnNormal, srf[j]->posnNormal);								// if they are close enough, then add in the srf[j] normal to the sum 				if (dot > 0.0)				{					outside_normal_sum.x += (double)(srf[j]->posnNormal.x);					outside_normal_sum.y += (double)(srf[j]->posnNormal.y);					outside_normal_sum.z += (double)(srf[j]->posnNormal.z);					num_outside_normals++;				}			}		}				// compute the average inside and outside normal 		if (in)		{			inside_normal.x = (short)(inside_normal_sum.x / (double)num_inside_normals);			inside_normal.y = (short)(inside_normal_sum.y / (double)num_inside_normals);			inside_normal.z = (short)(inside_normal_sum.z / (double)num_inside_normals);			val = VectLengthPoint(&inside_normal);			inside_normal.x = (short)((double)inside_normal.x / (double)val * (double)256.0);			inside_normal.y = (short)((double)inside_normal.y / (double)val * (double)256.0);			inside_normal.z = (short)((double)inside_normal.z / (double)val * (double)256.0);		}				if (out)		{			outside_normal.x = (short)(outside_normal_sum.x / (double)num_outside_normals);			outside_normal.y = (short)(outside_normal_sum.y / (double)num_outside_normals);			outside_normal.z = (short)(outside_normal_sum.z / (double)num_outside_normals);			val = VectLengthPoint(&outside_normal);			outside_normal.x = (short)((double)outside_normal.x / (double)val * (double)256.0);			outside_normal.y = (short)((double)outside_normal.y / (double)val * (double)256.0);			outside_normal.z = (short)((double)outside_normal.z / (double)val * (double)256.0);		}				// now, fill in the intensities for this point		if (in)		{			shade_level = iLight->CalcShadeLevel(NUM_TEXTURE_SHADING_LEVELS, inside_normal);			ASSERT(shade_level.intg >= 0);			ASSERT(shade_level.intg < 32);			sh_in[i] = shade_level;		}				if (out)		{			shade_level = oLight->CalcShadeLevel(NUM_TEXTURE_SHADING_LEVELS, outside_normal);			ASSERT(shade_level.intg >= 0);			ASSERT(shade_level.intg < 32);			sh_out[i] = shade_level;		}	}	#if 0	// as a final check, loop through all the points in this surface and make sure the 	// the intensities are different -- and set SHADE_GOURAUD if any are different.  If they	// are all the same then we leave the shade type to be flat shaded.	SetShadeType(SHADE_FLAT, SURF_INSIDE);	for ( i = 1 ; i < points->ALength() ; i++ )	{		if (!FFEqual(sh_in[i], sh_in[0]))		{			SetShadeType(SHADE_GOURAUD, SURF_INSIDE);			break;		}	}		SetShadeType(SHADE_FLAT, SURF_OUTSIDE);	for ( i = 1 ; i < points->ALength() ; i++ )	{		if (!FFEqual(sh_out[i], sh_out[0]))		{			SetShadeType(SHADE_GOURAUD, SURF_OUTSIDE);			break;		}	}#endifendit:	if (in) shi->Unuse();	if (out) sho->Unuse();	points->Unuse();}// ABD MERGE-GOURAUD ]]]	}Point3DSurface::Normalize(long xx, long yy, long zz)	{	long tt, shift, mag;		int x, y, z;	Point3D norm;	tt = (xx < 0 ? -xx : xx); 	shift = 0;	while (tt > 0x3FFF)		{ tt >>= 1; shift++; }	if (shift)		{		xx >>= shift;		yy >>= shift;		zz >>= shift;		}	tt = (yy < 0 ? -yy : yy);	shift = 0;	while (tt > 0x3FFF)		{ tt >>= 1 ; shift++; }	if (shift)		{		xx >>= shift;		yy >>= shift;		zz >>= shift;		}	tt = (zz < 0 ? -zz : zz); 	shift = 0;	while (tt > 0x3FFF)		{ tt >>= 1; shift++; }	if (shift)		{		xx >>= shift;		yy >>= shift;		zz >>= shift;		}	x = xx; y = yy; z = zz;	xx = (long)x * x;	yy = (long)y * y;	zz = (long)z * z;		mag = LSqrt(xx + yy + zz);		if (mag != 0)		{		norm.x = ((long)x << 8) / mag;		norm.y = ((long)y << 8) / mag;		norm.z = ((long)z << 8) / mag;		}	else		{		norm.x = 0;		norm.y = 0;		norm.z = 0;		}	return(norm);	}voidSurface::ExpandBound(Point3D *min, Point3D *max, int which)	{	V_Array *polyPnts;	Point3DFFixed *pnt, pt;	short *surfPnt;	int nPoints, i;		if (which == BOUND_DEF)		polyPnts = polyConvex->polyhedron->points;	else		polyPnts = polyConvex->polyhedron->posnPoints;	pnt = (Point3DFFixed *)polyPnts->Use();	nPoints = points->ALength();	surfPnt = (short *)points->Use();		for (i = 0; i < nPoints; i++)		{		int maxX, maxY, maxZ;		pt = pnt[*surfPnt++];		if (pt.x.intg < min->x) min->x = pt.x.intg;		if (pt.y.intg < min->y) min->y = pt.y.intg;		if (pt.z.intg < min->z) min->z = pt.z.intg;		maxX = pt.x.intg; if (pt.x.frac != 0) maxX++;		maxY = pt.y.intg; if (pt.y.frac != 0) maxY++;		maxZ = pt.z.intg; if (pt.z.frac != 0) maxZ++;		if (maxX > max->x) max->x = maxX;		if (maxY > max->y) max->y = maxY;		if (maxZ > max->z) max->z = maxZ;		}	polyPnts->Unuse();	points->Unuse();// JAM bounding sphere for surf features fix 9/24/93 [[[	/*JAM--need bounding sphere to include surface features which may be larger than	  surfaces*/	if(surfDef != NULL)		{		int where, nFeatures;		SurfFeature **feat;				for(where = 0; where < 3; where++)			{			if(surfDef->features[where] != NULL)				{				nFeatures = surfDef->features[where]->ALength();				feat = (SurfFeature**)surfDef->features[where]->Use();   // jca 27 Sept 93				for(i = 0; i < nFeatures; i++)					{					(*feat++)->ExpandBound(min, max, which);					}				surfDef->features[where]->Unuse();									}			}		}// JAM bounding sphere for surf features fix 9/24/93 ]]]	}voidSurface::CalcClip(Point3Ddouble *pt1, Point3Ddouble *pt2, double dist1, double dist2,	Point3DFFixed *rslt)	{	double scale = dist1 / (dist1 - dist2);		rslt->x = DblToFixed((pt2->x - pt1->x) * scale + pt1->x);	rslt->y = DblToFixed((pt2->y - pt1->y) * scale + pt1->y);	rslt->z = DblToFixed((pt2->z - pt1->z) * scale + pt1->z);	}intSurface::FindPoint(Point3DFFixed *p)	{	V_Array *polyPoints = polyConvex->polyhedron->points;	FFixed x, y, z;	int nPoints, i;	Point3DFFixed *pnt;	x = p->x;	y = p->y;	z = p->z;	nPoints = polyPoints->ALength();	pnt = (Point3DFFixed *)polyPoints->Abuse();	for (i = 0; i < nPoints; i++, pnt++)		if (FFEqual(pnt->x, x) && FFEqual(pnt->y, y) && FFEqual(pnt->z, z))			break;	if (i == nPoints)		polyPoints->Append(p);	return (i);	}intSurface::DrawSurface(View *view, Clip *clip, int inside, int side, RGBAColor inheritedColor)	{	int where, surfVisible = TRUE;	short seq = polyConvex->polyhedron->drawing->sequence;	PolyConvex *poly = NULL, *stop = NULL;	V_Array *polys = NULL;	int n = 0, renderPoly;	RGBAColor newColor;	TRANSPARENCY_INTERP_INIT;	int has_texture;				// ABD MERGE-TEXTURE 9/13/93	FFixed ff_flip, ff_temp;		// ABD MERGE-TEXTURE 9/13/93	int flip_height;				// ABD MERGE-TEXTURE 9/13/93	short which_side;	/* need to make 'inside', 'side', 'where' more consistent and efficient */	/* maybe type side: { inside, outside, shared } */	/* inside -> side == inside */	int s = (inside ? SIDE_INSIDE : SIDE_OUTSIDE);	where = (inside ? side : SURF_OPPOSITE(side));	if (side == SURF_SHARESIDE)		{		if (inside)			{			which_side = SIDE_INSIDE;			if (surfDef != NULL && (polys = surfDef->flatConnections[SIDE_INSIDE]) != NULL)				{				n = surfDef->firstContainer;				poly = surfDef->outsidePoly->piece;				stop = surfDef->stopPoly->piece;				}			else				{				Polyhedron *p;				p = polyConvex->polyhedron->container;				while (p->type == POLY_GROUP) p = p->container;				poly = p->piece;				stop = polyConvex;				}			if (!view->seeThrough) { polys = NULL; n = 0; }			if (!view->seeOut) { poly = NULL; stop = NULL; }			if (!view->fill && poly != NULL && stop->entered == seq)				{ poly = NULL; stop = NULL; }			}		else			{// BILBIL - 2/3/95 - CONNECTION - Hey, why was this INSIDE?			which_side = SIDE_OUTSIDE;//			which_side = SIDE_INSIDE;			if (view->seeIn)				{				poly = polyConvex;				poly->entered = seq;					if (surfDef != NULL)					{					polys = surfDef->flatConnections[SIDE_OUTSIDE];					if (polys != NULL) n = VA_Length(polys);					}				}			}		if (surfDef) renderPoly = surfDef->renderPoly[which_side];		else renderPoly = TRUE;				surfVisible = Draw3D(view, clip, inside, poly, renderPoly, polys, stop, n, this, inside, inheritedColor);		}	else  // jca 27MAR94 somebody has to set which_side!		which_side = (inside ? SIDE_INSIDE : SIDE_OUTSIDE);	if (surfVisible && surfDef != NULL)		{		Clip *newClip = clip, *surfClip = NULL;		V_Array *connections;		V_Array *features;		if ((connections = surfDef->flatConnections[s]) != NULL &&			surfDef->interesting[where][s] &&			(!inside || (newClip = surfClip = clip->ClipPolyRef(polyConvex->polyhedron->rendPoints,			rendPoints, !inside)) != NULL))			{			int nConn, i;			Connection *conn;			nConn = VA_Length(connections);			VA_Use(connections, conn, Connection);			for (i = 0; i < nConn; i++, conn++)				{				int inxx = (s == SIDE_INSIDE && i >= surfDef->firstContainer);				int wherexx = (inxx ? side : SURF_OPPOSITE(side));				if (conn->poly->piece->Calc3D(view))					{					PolyConvex *connPoly = NULL, *connStop = NULL;					V_Array *connPolys = NULL;					int connN = 0;					short this_side;					if (side == SURF_SHARESIDE)						{						SurfDef *sDef = conn->surf;						Surface *surf = sDef->surface;						if (inxx)							{							this_side = SIDE_INSIDE;							if ((connPolys = sDef->flatConnections[SIDE_INSIDE]) != NULL)								{								connN = sDef->firstContainer;								connPoly = sDef->outsidePoly->piece;								connStop = sDef->stopPoly->piece;								}							else								{								Polyhedron *p;								p = sDef->polyhedron->container;								while (p->type == POLY_GROUP) p = p->container;								connPoly = p->piece;								connStop = surf->polyConvex;								}							if (!view->seeThrough) { connPolys = NULL; connN = 0; }							if (!view->seeOut) { connPoly = NULL; connStop = NULL; }							}						else							{							this_side = SIDE_OUTSIDE;							if (inside && view->seeThrough || !inside && view->seeIn)								{								connPoly = sDef->surface->polyConvex;								connPolys = sDef->flatConnections[SIDE_OUTSIDE];								if (connPolys != NULL) connN = VA_Length(connPolys);								}							}						if (!surf->clipped && !IS_OPAQUE(surf->opacity))							{							if (surf->surfDef)								renderPoly = surf->surfDef->renderPoly[this_side];							else								renderPoly = TRUE;							surf->Draw3D(view, newClip, inxx, connPoly, renderPoly,								connPolys, connStop, connN, this, inside, inheritedColor);							}						}					else    // must define this_side if this is not a shared surface						{						if (inxx)							this_side = SIDE_INSIDE;						else							this_side = SIDE_OUTSIDE;						}                    						if ((features = conn->surf->features[wherexx]) != NULL)						{						int nFeatures, j;						SurfFeature **featIndex;						int cp = conn->poly->piece->clipPlanes;							nFeatures = VA_Length(features);						VA_Use(features, featIndex, SurfFeature *);							if (side != SURF_FARSIDE)							{							for (j = 0; j < nFeatures; j++)								{								SurfFeature *feat = *featIndex++;										if (feat->Calc3D(view, cp))									{									if (feat->surfDef)										renderPoly = feat->surfDef->renderPoly[this_side];									else										renderPoly = TRUE;									feat->Draw3D(view, newClip, inxx, wherexx,										connPoly, renderPoly, connPolys,										feat->featConnections[this_side], connStop, connN, this,										inside, inheritedColor); // BILBIL - surface feature connection									}								}							}						else							{							featIndex += nFeatures;							for (j = nFeatures; j > 0; j--)								{								SurfFeature *feat = *--featIndex;										if (feat->Calc3D(view, cp))									feat->Draw3D(view, newClip, inxx, wherexx,										connPoly, feat->renderPoly[this_side], connPolys,										feat->featConnections[this_side], connStop, connN,										this, inside, inheritedColor); // BILBIL - surface feature connection								}							}						VA_Unuse(features);						}					}				}			VA_Unuse(connections);			if (surfClip != NULL)				surfClip->dClip();			}		if ((features = surfDef->features[where]) != NULL)			{			int nFeatures, j;			SurfFeature **featIndex;			int cp = polyConvex->clipPlanes;			nFeatures = VA_Length(features);			VA_Use(features, featIndex, SurfFeature *);			if (side != SURF_FARSIDE)				{				for (j = 0; j < nFeatures; j++)					{					SurfFeature *feat = *featIndex++;						if (feat->Calc3D(view, cp))						feat->Draw3D(view, clip, inside, where, poly,							feat->renderPoly[which_side], polys, feat->featConnections[which_side],							stop, n, this, inside, inheritedColor); // BILBIL - surface feature connection					}				}			else				{				featIndex += nFeatures;				for (j = nFeatures; j > 0; j--)					{					SurfFeature *feat = *--featIndex;						if (feat->Calc3D(view, cp))						feat->Draw3D(view, clip, inside, where, poly,							feat->renderPoly[which_side], polys, feat->featConnections[which_side],							stop, n, this, inside, inheritedColor); // BILBIL - surface feature connection					}				}			VA_Unuse(features);			}		}	return(surfVisible);	}intSurface::Draw3D(View *view, Clip *clip, int inside,	PolyConvex *poly, int renderPoly, V_Array *connections, PolyConvex *stop, int n,	Surface *fromSurf, int fromInside, RGBAColor inheritedColor)	{	int surfVisible = TRUE;	RGBColor clr, lclr;	unsigned short opc;	RGBAColor newBase;    RGBColor newColor;    TRANSPARENCY_INTERP_INIT;// ABD MERGE-TEXTURE 9/13/93 [[[	int texture_decal = FALSE;		// JCA PRO081893	int draw_texture = FALSE;		// JCA PRO081893	int has_texture_inside = FALSE;		// ABD TEXTURE	int has_texture_outside = FALSE;	// ABD TEXTURE    V_Offscreen *tx_off_in,*tx_off_out;		// ABD TEXTURE	FFixed ff_flip, ff_temp;		// ABD TEXTURE	int flip_height;		// ABD TEXTURE	int nearSide = (inside ? SURF_INSIDE : SURF_OUTSIDE);	// MERGE-GOURAUD	struct GouraudRendSettings grs;	// MERGE-GOURAUD	// JCA PRO081893    {	has_texture_inside = ((view->textures) && (!view->whiteShade) && (!polyCheckMode)) && (GetTexture(SURF_INSIDE) != NULL);	//PRO-14	// ABD TEXTURE	has_texture_outside = ((view->textures) && (!view->whiteShade) && (!polyCheckMode)) && (GetTexture(SURF_OUTSIDE) != NULL);	//PRO-14	// ABD TEXTURE// JCA PRO081893    }/*11-29-93 JAM [[[ patch to cause textures to	  not be used when doing GDI stuff*/	if (clip->method == QD_METHOD)	{		has_texture_inside = has_texture_outside = FALSE;    }/*11-29-93 JAM ]]] patch to cause textures to      not be used when doing GDI stuff*/// ABD MERGE-TEXTURE 9/13/93 ]]]	opc = opacity;	if (view->whiteShade)		{		clr = vWhite;		lclr = vBlack;		}	else		{		if (view->shade)			{			if (inside) clr = insideShade;			else clr = outsideShade;			}		else			{			if (inside) clr = insideColor;			else clr = outsideColor;			}		if (view->interpTransp)			{			RGBColor hclr;			if (inside) hclr = insideColor;            else hclr = outsideColor;			if (IS_TRANSPARENT(inheritedColor.alpha))				{				newBase.alpha = opc;				InterpolateColorFirstTime(hclr.red, opc, newBase.red);				InterpolateColorFirstTime(hclr.green, opc, newBase.green);				InterpolateColorFirstTime(hclr.blue, opc, newBase.blue);        		}			else if (IS_TRANSLUCENT(inheritedColor.alpha))				{				InterpolateAlphaFrontToBack(opc, inheritedColor.alpha, newBase.alpha);				InterpolateColorFrontToBack(hclr.red, inheritedColor.red, newBase.red);				InterpolateColorFrontToBack(hclr.green, inheritedColor.green, newBase.green);				InterpolateColorFrontToBack(hclr.blue, inheritedColor.blue, newBase.blue);				InterpolateColorFrontToBack(clr.red, inheritedColor.red, newColor.red);				InterpolateColorFrontToBack(clr.green, inheritedColor.green, newColor.green);				InterpolateColorFrontToBack(clr.blue, inheritedColor.blue, newColor.blue);                clr = newColor;				}			else				{				opc = OPAQUE_NOM;	/* truncate the transparency recursion */				clr.red = inheritedColor.red;				clr.green = inheritedColor.green;				clr.blue = inheritedColor.blue;				}			}		if (!view->blackFrame)			{			lclr.red = clr.red >> 1; lclr.red += lclr.red >> 1;			lclr.green = clr.green >> 1; lclr.green += lclr.green >> 1;			lclr.blue = clr.blue >> 1; lclr.blue += lclr.blue >> 1;			}		else lclr = vBlack;		}// ABD MERGE-TEXTURE 9/14/93 [[[			// if we have drawn a texture, then we have to draw the surface if the texture is a decal.	// Note that if the surface is transparent then 	// we draw the surface if we didn't draw a texture and the surface is visible,	// or if we drew a texture and the texture is a decal	if (has_texture_inside)	{	    tx_off_in = GetTexture(SURF_INSIDE)->GetPicture(0);//	    if (tx_off_in == NULL)  	// can't get the picture, so try using thumbnail//	    	tx_off_in = GetTexture(SURF_INSIDE)->GetThumbnail();		if (tx_off_in == NULL) 	// can't even get the thumbnail, so give up!			has_texture_inside = FALSE;	}	if (has_texture_outside)	{	    tx_off_out = GetTexture(SURF_OUTSIDE)->GetPicture(0);//	    if (tx_off_out == NULL)  	// can't get the picture, so try using thumbnail//	    	tx_off_out = GetTexture(SURF_OUTSIDE)->GetThumbnail();		if (tx_off_out == NULL) 	// can't even get the thumbnail, so give up!			has_texture_outside = FALSE;	}		if (has_texture_inside)		texture_decal = GetTexture(SURF_INSIDE)->settings.decal;	else if (has_texture_outside)		texture_decal = GetTexture(SURF_OUTSIDE)->settings.decal;				draw_texture = ((fromInside && has_texture_inside) || (!fromInside && has_texture_outside));	// if this surface is not opaque, then draw through it.	// however, if the surface is textured and the texture is not decalled, then there is no	// point so dont do it.	if ((!IS_OPAQUE(opc)) && (!((draw_texture) && (!texture_decal))))		{		if (poly != NULL || connections != NULL)			{			Clip *newClip;			int nConn, i;			Connection *conn;			SurfDef *sDef;				newClip = clip->ClipPolyRef(polyConvex->polyhedron->rendPoints,				rendPoints, !inside);				if (newClip != NULL)				{				if ((poly != NULL) && renderPoly)					poly->DrawWalk(view, newClip, stop, NULL, newBase);				if (connections != NULL && n > 0)					{					nConn = VA_Length(connections);					VA_Use(connections, conn, Connection);						conn += n-1;					for (i = n-1; i >= 0; i--, conn--)						conn->poly->piece->DrawWalk(view, newClip, stop, conn->surf->surface, newBase);						VA_Unuse(connections);					}					if ((sDef = fromSurf->surfDef) != NULL)					{					int farSide = (fromInside ? SURF_OUTSIDE : SURF_INSIDE);					int s = (fromInside ? SURF_INSIDE : SURF_OUTSIDE);						if (sDef->features[farSide] != NULL || sDef->interesting[farSide][s])						fromSurf->DrawSurface(view, newClip, fromInside, SURF_FARSIDE, newBase);					}					newClip->dClip();				}			else surfVisible = FALSE;			}		else opc = OPAQUE_NOM;		}	// ABD MERGE-TEXTURE 9/13/93 [[[	// if this surface is visible then draw the surface	// and we make sure that either the surface has no texture to draw or the texture is	// decalled.  (if the texture is not decalled then no surface will show through, and so	// we will not see the surface). 	// also, if the surface is transparent and textured, then don't draw it at all	// (not even the frames)	if ((surfVisible) && 		((!draw_texture) || (draw_texture && texture_decal)) &&		(!(draw_texture && IS_TRANSPARENT(opc))))		{		short v = view->drawMode;		// ABD TEXTURE		struct ObjSpec obj;				// ABD 3D PICK 8/13/93		struct ObjSpec *obj_ptr = NULL;	// ABD 3D PICK 8/13/93		// if we are drawing a texture later, then dont frame the surface		if ((draw_texture) && ((view->drawMode & CLIP_FRAME) == CLIP_FRAME))			v &= ~CLIP_FRAME;// ABD MERGE-TEXTURE 9/13/93 ]]]		// ABD 3D PICK 8/13/93		// fill in the obj spec for 3d pick		if (polyCheckMode)		{			obj.poly = polyConvex->polyhedron;						// ABD 3D PICK 8/13/93			obj.polyc = polyConvex;									// ABD 3D PICK 8/13/93			obj.surfNum = surfNum;									// ABD 3D PICK 8/13/93			obj.surfSide = (inside ? SURF_INSIDE : SURF_OUTSIDE);	// ABD 3D PICK 8/13/93			obj.surffeat = NULL;									// ABD 3D PICK 8/13/93			obj_ptr = &obj;		}		if (view->gouraud)	// MERGE-GOURAUD-PRO-7		{	// PRO-14			if (view->whiteShade)	// PRO-14				grs.intensities = NULL;		// PRO-14			else	// PRO-14				grs.intensities = GetRendIntensities(nearSide);					// MERGE-GOURAUD		}	// PRO-14		else	// MERGE-GOURAUD-PRO-7			grs.intensities = NULL;	// MERGE-GOURAUD-PRO-7		grs.unshaded_color = (inside ? insideColorIndex : outsideColorIndex);		// MERGE-GOURAUD						if (!IS_TRANSPARENT(opc))			{			if (!IS_OPAQUE(opc) && view->fill)				{				if (!view->interpTransp)                	{					if (!view->whiteShade)						surfVisible = clip->DrawPolyRef(polyConvex->polyhedron->rendPoints,							rendPoints, view->drawMode, &grs, TRUE, vPatBlack, &clr, &lclr, !inside, obj_ptr);	// MERGE-GOURAUD	// ABD 3D PICK 8/13/93					else if (view->frame)						surfVisible = clip->DrawPolyRef(polyConvex->polyhedron->rendPoints,							rendPoints, CLIP_FRAME, &grs, FALSE, vPatBlack, &clr, &lclr, !inside, obj_ptr);	// MERGE-GOURAUD	// ABD 3D PICK 8/13/93					}				else if (view->frame)					surfVisible = clip->DrawPolyRef(polyConvex->polyhedron->rendPoints,						rendPoints, CLIP_FRAME, &grs, FALSE, vPatBlack, &clr, &lclr, !inside, obj_ptr);	// MERGE-GOURAUD	// ABD 3D PICK 8/13/93				}			else surfVisible = clip->DrawPolyRef(polyConvex->polyhedron->rendPoints,				rendPoints, view->drawMode, &grs, FALSE, vPatBlack, &clr, &lclr, !inside, obj_ptr);	// MERGE-GOURAUD	// ABD 3D PICK 8/13/93			}		else if (view->frame)			surfVisible = clip->DrawPolyRef(polyConvex->polyhedron->rendPoints,				rendPoints, CLIP_FRAME, &grs, FALSE, vPatBlack, &clr, &lclr, !inside, obj_ptr);	// MERGE-GOURAUD	// ABD 3D PICK 8/13/93		}// ABD MERGE-TEXTURE 9/14/93 [[[	if (surfVisible && view->fill && fromInside && has_texture_inside && offscreen)	{    Point *pf;    Point *pt,c;    Rect flip;    long l,l2,i;    V_Array *inPts = GetRendTexturePoints(SURF_INSIDE);    V_Array *it;    V_Array *aii;    V_Array *aiinp;    struct TextureRendSettings rset;					if (has_texture_inside)		{				inPts->Use();			polyConvex->polyhedron->rendPoints->Use();			polyConvex->polyhedron->NoPerspPoints->Use();		   		    GetTexture(SURF_INSIDE)->GetPaddedRect(&flip, 0);							ff_flip.intg = flip.bottom-flip.top;			ff_flip.frac = 0;   			ff_flip = FFMult(ff_flip, GetTexture(SURF_INSIDE)->settings.vTiles);			flip_height = FFRound(ff_flip);        // jca 22 Sept 93.  borland can't handle the combination of these two things			rset.decal = GetTexture(SURF_INSIDE)->settings.decal;			rset.colorize = GetTexture(SURF_INSIDE)->settings.colorize;			rset.hMirror = GetTexture(SURF_INSIDE)->settings.hMirror;			rset.vMirror = GetTexture(SURF_INSIDE)->settings.vMirror;			rset.hFlip = GetTexture(SURF_INSIDE)->settings.hFlip;			rset.vFlip = GetTexture(SURF_INSIDE)->settings.vFlip;			if (GetTexture(SURF_INSIDE)->settings.shade)				rset.textureShade = insideTextureShade;			else				rset.textureShade = &(gTextureShader[0]);			rset.filtered_color = GetTexture(SURF_INSIDE)->GetFilteredRGB();			    			for (i = 0 ; i < MAX_NUM_MIPS ; i++ )			{				rset.mip[i] = GetTexture(SURF_INSIDE)->GetPicture(i);				GetTexture(SURF_INSIDE)->GetPaddedRect(&rset.mip_rect[i], i);			}//			if(rset.mip[0] == NULL) {//				rset.mip[0] = GetTexture(SURF_INSIDE)->GetThumbnail();//				rset.mip[0]->GetRect(&rset.mip_rect[0]);//				//texture->GetPaddedRect(&rset.mip_rect[0], 0); ????//			}		    //it = IdentTexture(inPts,flip_height,!inside);		    //aii = IndexIdent(polyConvex->polyhedron->rendPoints,rendPoints,!inside);		    //aiinp = IndexIdentNoPersp(polyConvex->polyhedron->NoPerspPoints,rendPoints,!inside);			NewIndexIdent(polyConvex->polyhedron->rendPoints, 						  polyConvex->polyhedron->NoPerspPoints,						  inPts, rendPoints, flip_height, !inside,						  &aii, &aiinp, &it);		    GetTexture(SURF_INSIDE)->SetupFrame();		 	Texture8(offscreen, it, aii, aiinp, clip, &rset);		//ееее		    		    //offscreen->UnsetMetaPort();	ееее 		   	//offscreen->SetMetaPort();		ееее 					inPts->Unuse();			polyConvex->polyhedron->rendPoints->Unuse();			polyConvex->polyhedron->NoPerspPoints->Unuse();		}	}	else if (surfVisible && view->fill && (!fromInside) && has_texture_outside && offscreen)	{    Point *pf;    Point *pt,c;    Rect flip;    long l,l2,i;    V_Array *outPts = GetRendTexturePoints(SURF_OUTSIDE);    V_Array *it;    V_Array *aii;    V_Array *aiinp;    struct TextureRendSettings rset;			if (has_texture_outside)		{			outPts->Use();			polyConvex->polyhedron->rendPoints->Use();			polyConvex->polyhedron->NoPerspPoints->Use();		   		    GetTexture(SURF_OUTSIDE)->GetPaddedRect(&flip, 0);							ff_flip.intg = flip.bottom-flip.top;			ff_flip.frac = 0;			ff_temp = FFMult(ff_flip, GetTexture(SURF_OUTSIDE)->settings.vTiles);			flip_height = FFRound(ff_temp);        // jca 22 Sept 93.  borland can't handle the combination of these two things			rset.decal = GetTexture(SURF_OUTSIDE)->settings.decal;			rset.colorize = GetTexture(SURF_OUTSIDE)->settings.colorize;			rset.hMirror = GetTexture(SURF_OUTSIDE)->settings.hMirror;			rset.vMirror = GetTexture(SURF_OUTSIDE)->settings.vMirror;			rset.hFlip = GetTexture(SURF_OUTSIDE)->settings.hFlip;			rset.vFlip = GetTexture(SURF_OUTSIDE)->settings.vFlip;			if (GetTexture(SURF_OUTSIDE)->settings.shade)				rset.textureShade = outsideTextureShade;			else				rset.textureShade = &(gTextureShader[0]);			rset.filtered_color = GetTexture(SURF_OUTSIDE)->GetFilteredRGB();			for (i = 0 ; i < MAX_NUM_MIPS ; i++ )			{				rset.mip[i] = GetTexture(SURF_OUTSIDE)->GetPicture(i);				GetTexture(SURF_OUTSIDE)->GetPaddedRect(&rset.mip_rect[i], i);			}//			if(rset.mip[0] == NULL) {//				rset.mip[0] = GetTexture(SURF_OUTSIDE)->GetThumbnail();//				rset.mip[0]->GetRect(&rset.mip_rect[0]);//				//texture->GetPaddedRect(&rset.mip_rect[0], 0); ????//			}		    //it = IdentTexture(outPts,flip_height,!inside);		    //aii = IndexIdent(polyConvex->polyhedron->rendPoints,rendPoints,!inside);		    //aiinp = IndexIdentNoPersp(polyConvex->polyhedron->NoPerspPoints,rendPoints,!inside);		    			NewIndexIdent(polyConvex->polyhedron->rendPoints, 						  polyConvex->polyhedron->NoPerspPoints,						  outPts, rendPoints, flip_height, !inside,						  &aii, &aiinp, &it);		    GetTexture(SURF_OUTSIDE)->SetupFrame();		 	Texture8(offscreen, it, aii, aiinp, clip, &rset);		//ееее		    		   // offscreen->UnsetMetaPort();	ееее 		   // offscreen->SetMetaPort();	ееее 					outPts->Unuse();			polyConvex->polyhedron->rendPoints->Unuse();			polyConvex->polyhedron->NoPerspPoints->Unuse();		}	}// ABD MERGE-TEXTURE 9/14/93 ]]]	return (surfVisible);	}// ABD MERGE-TEXTURE 9/13/93 [[[/* ---- TEXTURE STUFF ---- */struct V_Array *Surface::GetRawTexturePoints(int where)			// ABD TEXTURE{	if (where == SURF_INSIDE)	{			if ((surfDef) && (surfDef->flags & SDEF_TEXT(SURF_INSIDE)))		{			// ABD MERGE-MEM [[[			if (surfDef->rawInsideTexturePoints == NULL)			{				surfDef->rawInsideTexturePoints = new(V_Array);					// ABD TEXTURE				surfDef->rawInsideTexturePoints->cArray(0, sizeof(PointFFixed), 4);			// ABD TEXTURE			}			// ABD MERGE-MEM ]]]			return surfDef->rawInsideTexturePoints;		}		else		{			// ABD MERGE-MEM [[[			if (rawInsideTexturePoints == NULL)			{				rawInsideTexturePoints = new(V_Array);					// ABD TEXTURE				rawInsideTexturePoints->cArray(0, sizeof(PointFFixed), 4);			// ABD TEXTURE			}			// ABD MERGE-MEM ]]]						return rawInsideTexturePoints;		}	}	else if (where == SURF_OUTSIDE)	{		if ((surfDef) && (surfDef->flags & SDEF_TEXT(SURF_OUTSIDE)))		{			// ABD MERGE-MEM [[[			if (surfDef->rawOutsideTexturePoints == NULL)			{				surfDef->rawOutsideTexturePoints = new(V_Array);					// ABD TEXTURE				surfDef->rawOutsideTexturePoints->cArray(0, sizeof(PointFFixed), 4);			// ABD TEXTURE			}			// ABD MERGE-MEM ]]]			return surfDef->rawOutsideTexturePoints;		}		else		{			// ABD MERGE-MEM [[[			if (rawOutsideTexturePoints == NULL)			{				rawOutsideTexturePoints = new(V_Array);					// ABD TEXTURE				rawOutsideTexturePoints->cArray(0, sizeof(PointFFixed), 4);			// ABD TEXTURE			}			// ABD MERGE-MEM ]]]			return rawOutsideTexturePoints;		}	}}struct V_Array *Surface::GetRendTexturePoints(int where)			// ABD TEXTURE{	if (where == SURF_INSIDE)	{		if ((surfDef) && (surfDef->flags & SDEF_TEXT(SURF_INSIDE)))		{			// ABD MERGE-MEM [[[			if (surfDef->rendInsideTexturePoints == NULL)			{				surfDef->rendInsideTexturePoints = new(V_Array);					// ABD TEXTURE				surfDef->rendInsideTexturePoints->cArray(0, sizeof(PointFFixed), 4);			// ABD TEXTURE			}			// ABD MERGE-MEM ]]]			return surfDef->rendInsideTexturePoints;		}		else		{			// ABD MERGE-MEM [[[			if (rendInsideTexturePoints == NULL)			{				rendInsideTexturePoints = new(V_Array);					// ABD TEXTURE				rendInsideTexturePoints->cArray(0, sizeof(PointFFixed), 4);			// ABD TEXTURE			}			// ABD MERGE-MEM ]]]						return rendInsideTexturePoints;		}	}	else if (where == SURF_OUTSIDE)	{		if ((surfDef) && (surfDef->flags & SDEF_TEXT(SURF_OUTSIDE)))		{			// ABD MERGE-MEM [[[			if (surfDef->rendOutsideTexturePoints == NULL)			{				surfDef->rendOutsideTexturePoints = new(V_Array);					// ABD TEXTURE				surfDef->rendOutsideTexturePoints->cArray(0, sizeof(PointFFixed), 4);			// ABD TEXTURE			}			// ABD MERGE-MEM ]]]			return surfDef->rendOutsideTexturePoints;		}		else		{			// ABD MERGE-MEM [[[			if (rendOutsideTexturePoints == NULL)			{				rendOutsideTexturePoints = new(V_Array);					// ABD TEXTURE				rendOutsideTexturePoints->cArray(0, sizeof(PointFFixed), 4);			// ABD TEXTURE			}			// ABD MERGE-MEM ]]]			return rendOutsideTexturePoints;		}	}}struct TextureItem *Surface::GetTexture(int where)			// ABD TEXTURE{	if (where == SURF_INSIDE)	{		if ((surfDef) && (surfDef->flags & SDEF_TEXT(SURF_INSIDE)))			return surfDef->insideTexture;		else			return polyConvex->polyhedron->insideTexture;	}	else if (where == SURF_OUTSIDE)	{		if ((surfDef) && (surfDef->flags & SDEF_TEXT(SURF_OUTSIDE)))			return surfDef->outsideTexture;		else			return polyConvex->polyhedron->outsideTexture;	}}struct V_Array *Surface::GetOutline()			// ABD TEXTURE{	if (!outline)			// ABD MERGE-MEM		CalcOutline();		// ABD MERGE-MEM	if ((surfDef) && (surfDef->flags & SDEF_TEXTURE))		return surfDef->outline;	else		return outline;}// this routine calc the outline for this surface -- we need this for texturing if there is// no surface definition for this texture but the poly this surface is part of is textured.voidSurface::CalcOutline()			// ABD TEXTURE{	// ABD MERGE-MEM [[[	if (!outline)	{		outline = new(V_Array);					// ABD TEXTURE		outline->cArray(0, sizeof(PointFFixed), 4);			// ABD TEXTURE	}	// ABD MERGE-MEM ]]]	if (surfDef)		// if surfDef exists then outline exists		surfDef->outline->CopyArray(outline);	else	{	SurfDef *sd;			sd = polyConvex->polyhedron->GetSurfDef(surfNum);		sd->outline->CopyArray(outline);		sd->dSurfDef();		sd = NULL;		surfDef = NULL;		polyConvex->polyhedron->surfDef->Put(surfNum, &sd);	}}// ABD MERGE-TEXTURE 9/13/93 ]]]// ABD MERGE-GOURAUD [[[/* ---- GOURAUD STUFF ---- */// this surface is gouraud shaded if the surface definition is gouraud shaded, or else the// polyhedron is gouraud shadedunsigned charSurface::GetShadeType(short where){	if (where == SURF_INSIDE)	{		if ((surfDef) && (surfDef->flags & SDEF_GOUR(SURF_INSIDE)))			return surfDef->insideShadeType;		else			return polyConvex->polyhedron->insideShadeType;	}	else if (where == SURF_OUTSIDE)	{		if ((surfDef) && (surfDef->flags & SDEF_GOUR(SURF_OUTSIDE)))			return surfDef->outsideShadeType;		else			return polyConvex->polyhedron->outsideShadeType;	}}// this surface is gouraud shaded if the surface definition is gouraud shaded, or else the// polyhedron is gouraud shadedvoidSurface::SetShadeType(unsigned char sh, short where){	if ((surfDef) && (surfDef->flags & SDEF_GOUR(where)))		surfDef->SetShadeType(sh, where);	else		polyConvex->polyhedron->SetShadeType(sh, where);}struct V_Array *Surface::GetRawIntensities(short where){	if (GetShadeType(where) == SHADE_FLAT)		return NULL;	if (where == SURF_INSIDE)	{		if (rawInsideIntensities == NULL)		{			rawInsideIntensities = new(V_Array);			rawInsideIntensities->cArray(0, sizeof(FFixed), 4);		}				return rawInsideIntensities;	}	else if (where == SURF_OUTSIDE)	{		if (rawOutsideIntensities == NULL)		{			rawOutsideIntensities = new(V_Array);			rawOutsideIntensities->cArray(0, sizeof(FFixed), 4);		}		return rawOutsideIntensities;	}}struct V_Array *Surface::GetRendIntensities(short where){	if (GetShadeType(where) == SHADE_FLAT)		return NULL;	if (where == SURF_INSIDE)	{		if (rendInsideIntensities == NULL)		{			rendInsideIntensities = new(V_Array);			rendInsideIntensities->cArray(0, sizeof(FFixed), 4);		}				return rendInsideIntensities;	}	else if (where == SURF_OUTSIDE)	{		if (rendOutsideIntensities == NULL)		{			rendOutsideIntensities = new(V_Array);			rendOutsideIntensities->cArray(0, sizeof(FFixed), 4);		}		return rendOutsideIntensities;	}}// MERGE-GOURAUD ]]]