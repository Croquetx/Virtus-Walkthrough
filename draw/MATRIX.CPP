/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	 *				David W. Easter *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "Matrix.h"#include "VMath.h"#include "VMemUtil.h"#include <math.h>voidMatrix::cMatrix()	{	SetIdentity();	scale = Pt3DFFOne;	shear = Shr3DFFZero;	angle = Ang3DFFZero;	calcScale = FALSE;	calcRotate = FALSE;	}voidMatrix::dMatrix()	{	delete(this);	}voidMatrix::Scale(Point3DFFixed scal)	{	Matrix *mScale;	if (FFOne(scal.x) && FFOne(scal.y) && FFOne(scal.z)) return;	mScale = new(Matrix);	mScale->cMatrix();	mScale->matrix[0][0] = scal.x;	mScale->matrix[1][1] = scal.y;	mScale->matrix[2][2] = scal.z;	Multiply(mScale);	mScale->dMatrix();	calcScale = TRUE;	calcRotate = TRUE;	}voidMatrix::Shear(Shear3DFFixed shr)	{	Matrix *mShear;	if (FFZero(shr.xy) && FFZero(shr.xz) && FFZero(shr.yz)) return;	mShear = new(Matrix);	mShear->cMatrix();	mShear->matrix[1][0] = shr.xy;	mShear->matrix[2][0] = shr.xz;	mShear->matrix[2][1] = shr.yz;	Multiply(mShear);	mShear->dMatrix();	calcScale = TRUE;	calcRotate = TRUE;	}voidMatrix::Rotate(FFixed angle, matrixAxis axis)	{	FFixed sinAngle, cosAngle;	if (FFZero(angle)) return;	sinAngle = DblToFixed(sin(FixedToDbl(angle)));	cosAngle = DblToFixed(cos(FixedToDbl(angle)));	RotateSC(sinAngle, cosAngle, axis);	}voidMatrix::RotateSC(FFixed sinAngle, FFixed cosAngle, matrixAxis axis)	{	Matrix *mRotate;	int a, b;	int axisType;		if (FFZero(sinAngle) && FFOne(cosAngle)) return;		axisType = axis - matrixX;	a = axisType + 1; if (a >= 3) a -= 3;	b = axisType + 2; if (b >= 3) b -= 3;	mRotate = new(Matrix);	mRotate->cMatrix();	mRotate->matrix[a][a] = cosAngle;	mRotate->matrix[a][b] = sinAngle;	mRotate->matrix[b][a] = FFNeg(sinAngle);	mRotate->matrix[b][b] = cosAngle;	Multiply(mRotate);	mRotate->dMatrix();	calcRotate = TRUE;	}Point3DFFixed Matrix::GetScale() { return(scale); }Shear3DFFixed Matrix::GetShear() { return(shear); }Angle3DFFixed Matrix::GetAngle() { return(angle); }voidMatrix::SetIdentity()	{	int r, c;	for (r = 0; r < 3; r++)		{		for (c = 0; c < 3; c++)			{			if (r == c) matrix[r][c] = FFOne;			else matrix[r][c] = FFZero;			}		}	}voidMatrix::SetMatrix(Matrix *m)	{	int r, c;	for (r = 0; r < 3; r++)		for (c = 0; c < 3; c++)			matrix[r][c] = m->matrix[r][c];	}voidMatrix::Multiply(Matrix *m)	{	Matrix *product;	int r, c;	product = new(Matrix);	product->cMatrix();	for (r = 0; r < 3; r++)		{		for (c = 0; c < 3; c++)			{			FFixed tmp0, tmp1, tmp2, sum;			tmp0 = FFMult(matrix[r][0], m->matrix[0][c]);			tmp1 = FFMult(matrix[r][1], m->matrix[1][c]);			tmp2 = FFMult(matrix[r][2], m->matrix[2][c]);			sum = FFAdd(tmp0, FFAdd(tmp1, tmp2));			if (sum.l == 0xFFFF0001 || sum.l == 0xFFFEFFFF) sum.l = 0xFFFF0000;			if (sum.l == 0x00000001 || sum.l == 0xFFFFFFFF) sum.l = 0x00000000;			if (sum.l == 0x00010001 || sum.l == 0x0000FFFF) sum.l = 0x00010000;			product->matrix[r][c] = sum;			}		}	SetMatrix(product);	product->dMatrix();	}/* From Graphics Gems II, p. 320-3 */voidMatrix::CalcComponents()	{	FFixed determ;		ObjLock((ObjectHandle)this);	if (calcScale)		{		scale.x = VectLength(matrix[0]);		VectDivide(matrix[0], scale.x);		shear.xy = VectDot(matrix[0], matrix[1]);		VectAdd(matrix[1], matrix[0], FFNeg(shear.xy));		scale.y = VectLength(matrix[1]);		VectDivide(matrix[1], scale.y);		shear.xy = FFDiv(shear.xy, scale.y);		shear.xz = VectDot(matrix[0], matrix[2]);		VectAdd(matrix[2], matrix[0], FFNeg(shear.xz));		shear.yz = VectDot(matrix[1], matrix[2]);		VectAdd(matrix[2], matrix[1], FFNeg(shear.yz));		scale.z = VectLength(matrix[2]);		VectDivide(matrix[2], scale.z);		shear.xz = FFDiv(shear.xz, scale.z);		shear.yz = FFDiv(shear.yz, scale.z);				determ = Determinant();/*MJU*/		if (FFNegative(determ))			{			int r, c;			for (r = 0; r < 3; r++)				for (c = 0; c < 3; c++)					matrix[r][c] = FFNeg(matrix[r][c]);			scale.x = FFNeg(scale.x);			scale.y = FFNeg(scale.y);			scale.z = FFNeg(scale.z);			}		}	if (calcRotate)		{		double asinRange, roll, pitch, yaw;		const double limit = PI/2 - .01;		asinRange = FixedToDbl(FFNeg(matrix[2][1]));		if (asinRange < -1.0)		asinRange = -1.0;  // jca 18APR94 clamp to the asin range.		else if (asinRange > 1.0)	asinRange = 1.0;   // jca 18APR94 clamp to the asin range.		pitch = asin(asinRange);		if (pitch > -limit && pitch < limit)			{			yaw = atan2(FixedToDbl(matrix[0][1]), FixedToDbl(matrix[1][1]));			roll = atan2(FixedToDbl(matrix[2][0]), FixedToDbl(matrix[2][2]));			}		else			{			if (pitch > 0) yaw = atan2(FixedToDbl(matrix[0][2]), FixedToDbl(matrix[0][0]));			else yaw = atan2(FixedToDbl(FFNeg(matrix[0][2])), FixedToDbl(matrix[0][0]));			roll = 0;			}		angle.yaw = DblToFixed(yaw);		angle.pitch = DblToFixed(pitch);		angle.roll = DblToFixed(roll);		}	ObjUnlock((ObjectHandle)this);	}FFixedMatrix::Determinant()	{	FFixed tmp0, tmp1, tmp2;	FFixed tmp0a, tmp0b, tmp1a, tmp1b, tmp2a, tmp2b;	tmp0a = FFMult(matrix[1][1], matrix[2][2]);	tmp0b = FFMult(matrix[2][1], matrix[1][2]);	tmp0 = FFMult(matrix[0][0], FFSub(tmp0a, tmp0b));	tmp1a = FFMult(matrix[1][0], matrix[2][2]);	tmp1b = FFMult(matrix[2][0], matrix[1][2]);	tmp1 = FFMult(matrix[0][1], FFSub(tmp1a, tmp1b));	tmp2a = FFMult(matrix[1][0], matrix[2][1]);	tmp2b = FFMult(matrix[2][0], matrix[1][1]);	tmp2 = FFMult(matrix[0][2], FFSub(tmp2a, tmp2b));	return(FFAdd(FFSub(tmp0, tmp1), tmp2));	}// ABD MERGE2 8/16/93 vextern double Vsqrt(double);FFixedVectLength(FFixed v[3])	{	FFixed tmp0, tmp1, tmp2, sum;	tmp0 = FFMult(v[0], v[0]);	tmp1 = FFMult(v[1], v[1]);	tmp2 = FFMult(v[2], v[2]);	sum = FFAdd(tmp0, FFAdd(tmp1, tmp2));	return(DblToFixed(Vsqrt(FixedToDbl(sum))));	}FFixedVectLengthPointFF(Point3DFFixed *v)	{	FFixed tmp0, tmp1, tmp2, sum;	tmp0 = FFMult(v->x, v->x);	tmp1 = FFMult(v->y, v->y);	tmp2 = FFMult(v->z, v->z);	sum = FFAdd(tmp0, FFAdd(tmp1, tmp2));	return(DblToFixed(sqrt(FixedToDbl(sum))));	}doubleVectLengthPoint(Point3D *v)	{	return sqrt((double)((long)v->x * (long)v->x + (((long)v->y * (long)v->y) + ((long)v->z * (long)v->z))));	// MERGE-GOURAUD	}doubleVectLengthPointDouble(Point3Ddouble *v)	{	return sqrt((v->x * v->x + ((v->y * v->y) + (v->z * v->z))));	}voidVectDivide(FFixed v[3], FFixed f)	{	v[0] = FFDiv(v[0], f);	v[1] = FFDiv(v[1], f);	v[2] = FFDiv(v[2], f);	}FFixedVectDot(FFixed v1[3], FFixed v2[3])	{	FFixed tmp0, tmp1, tmp2;	tmp0 = FFMult(v1[0], v2[0]);	tmp1 = FFMult(v1[1], v2[1]);	tmp2 = FFMult(v1[2], v2[2]);	return(FFAdd(tmp0, FFAdd(tmp1, tmp2)));	}voidVectAdd(FFixed v1[3], FFixed v2[3], FFixed mult)	{	v1[0] = FFAdd(v1[0], FFMult(v2[0], mult));	v1[1] = FFAdd(v1[1], FFMult(v2[1], mult));	v1[2] = FFAdd(v1[2], FFMult(v2[2], mult));	}// ABD MERGE2 8/16/93 ^