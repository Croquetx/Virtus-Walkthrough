/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by  	 *				David W. Easter *				 * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */#include "VTypes.h"#include "VDisplay.h"#include "SurfDef.h"#include "Polyhdrn.h"#include "SurfFeat.h"#include "Surface.h"#include "View.h"#include "Clip.h"#include "VMDL.h"#include "WalkBuff.h"#include "VMath.h"#include "Position.h"#include "VGraphic.h"#include "VGUtil.h"#include "VArray.h"#include "VMemUtil.h"#include "TextItem.h"		// ABD MERGE-TEXTURE 9/13/93#include "TextSrvr.h"		// ABD MERGE-TEXTURE 9/13/93#include "AppDefLT.h"		// ABD MERGE-TEXTURE 9/13/93#include "Unit.h"				// ABD MERGE-TEXTURE 9/13/93#include "VError.h"			// jca 22 Sept 93#include "Region.h"#include "Geometry.h"#include <stddef.h>#include <math.h>extern TextureServer *gTextureServer;	// ABD MERGE-TEXTURE 9/13/93voidSurfDef::cSurfDef(Polyhedron *poly)	{	polyhedron = poly;	connections[0] = NULL;	connections[1] = NULL;	connections[2] = NULL;	position = new(Position);	position->cPosition();	flags = 0;	insideColor = vBlack;	outsideColor = vBlack;	opacity = 0;	// ABD MERGE-TEXTURE 9/13/93 [[[	insideTexture = NULL;			// ABD TEXTURE	outsideTexture = NULL;			// ABD TEXTURE	rawInsideTexturePoints = NULL;			// ABD MERGE-MEM	rawOutsideTexturePoints = NULL;			// ABD MERGE-MEM	rendInsideTexturePoints = NULL;			// ABD MERGE-MEM	rendOutsideTexturePoints = NULL;		// ABD MERGE-MEM// ABD MERGE-TEXTURE 9/13/93 ]]]	outline = NULL;	features[0] = NULL;	features[1] = NULL;	features[2] = NULL;		surfaces = NULL;	surface = NULL;// ABD MERGE-GOURAUD [[[	insideShadeType = SHADE_FLAT;	outsideShadeType = SHADE_FLAT;// ABD MERGE-GOURAUD ]]]		flatConnections[0] = NULL;	flatConnections[1] = NULL;	renderPoly[0] = TRUE;	renderPoly[1] = TRUE;	firstContainer = 0;	outsidePoly = NULL;	interesting[0][0] = 0; interesting[0][1] = 0;	interesting[1][0] = 0; interesting[1][1] = 0;	interesting[2][0] = 0; interesting[2][1] = 0;		#if VRML_ANCHOR			// VRML-ABD 23JUN95	vrml_anchor = NULL;	#endif // VRML_ANCHOR		ResolveOpacity();	}voidSurfDef::dSurfDef()	{	int nFeatures, i, where;	SurfFeature **feat;	for (i = 0; i < 3; i++)		if (connections[i] != NULL)			connections[i]->dArray();	position->dPosition();	if (outline != NULL)		outline->dArray();			#if VRML_ANCHOR				// VRML-ABD 23JUN95	if (vrml_anchor != NULL)		vrml_anchor->dArray();	#endif // VRML_ANCHOR// ABD MERGE-TEXTURE 9/13/93 [[[	if (rawInsideTexturePoints) rawInsideTexturePoints->dArray();		/* delete texture mapping data */	if (rawOutsideTexturePoints) rawOutsideTexturePoints->dArray();		/* delete texture mapping data */	if (rendInsideTexturePoints) rendInsideTexturePoints->dArray();		/* delete texture mapping data */	if (rendOutsideTexturePoints) rendOutsideTexturePoints->dArray();		/* delete texture mapping data */	if (insideTexture != NULL) 		insideTexture->DocUnuseSurf(this);	// stop using the texture 	if (outsideTexture != NULL) 		outsideTexture->DocUnuseSurf(this);	// stop using the texture // ABD MERGE-TEXTURE 9/13/93 ]]]	for (where = 0; where < 3; where++)		{		if (features[where] != NULL)			{			nFeatures = features[where]->ALength();			feat = (SurfFeature **)features[where]->Use();			for (i = 0; i < nFeatures; i++)				(*feat++)->dSurfFeature();			features[where]->Unuse();			features[where]->dArray();			}		}	KillSurfaces();	for (i = 0; i < 2; i++)		if (flatConnections[i] != NULL)			flatConnections[i]->dArray();	delete(this);	}voidSurfDef::AddSurface(Surface *surf)	{	Surface *s;	if (surface != NULL)		{		surfaces = new(V_Array);		surfaces->cArray(0, sizeof(Surface *), 4);				s = surface;		surfaces->Append(&s);		surface = NULL;		}	if (surfaces != NULL)		surfaces->Append(&surf);	else		surface = surf;	}voidSurfDef::KillSurfaces()	{	if (surfaces != NULL)		{		surfaces->dArray();		surfaces = NULL;		}	else surface = NULL;	}voidSurfDef::Connect(Polyhedron *poly, SurfDef *surf)	{	int type, i;	Connection thisConn, conn;	if ((type = ConnectionType(poly)) < 0)		return;	thisConn.poly = polyhedron;	thisConn.surf = this;	conn.poly = poly;	conn.surf = surf;		ConnectionArray(type);	connections[type]->Append(&conn);	if (type == SDEF_PEER)		InsertFlatConnection(SIDE_INSIDE, &thisConn, &conn, SIDE_OUTSIDE);	else if (type == SDEF_CONTAINER)		InsertFlatConnection(SIDE_INSIDE, &thisConn, &conn, SIDE_INSIDE);	else if (type == SDEF_CONTENT)		InsertFlatConnection(SIDE_OUTSIDE, &thisConn, &conn, SIDE_OUTSIDE);	if (!surf->Connected(polyhedron, this, -1))		surf->Connect(polyhedron, this);	}voidSurfDef::Disconnect(Polyhedron *poly, SurfDef *surf, int type)	{	int connType, nConn, i;	Connection conn, *c;	if (poly == NULL && surf != NULL)		poly = surf->polyhedron;	for (connType = 0; connType < 3; connType++)		{		if (type >= 0 && type != connType || connections[connType] == NULL)			continue;		nConn = connections[connType]->ALength();		for (i = 0; i < nConn; i++)			{			c = (Connection *)connections[connType]->Abuse();			conn = c[i];			if ((poly == NULL || conn.poly == poly) && (surf == NULL || conn.surf == surf))				{				connections[connType]->Remove(i);				if (connType == SDEF_PEER)					RemoveFlatConnection(SIDE_INSIDE, &conn, SIDE_OUTSIDE);				else if (connType == SDEF_CONTAINER)					RemoveFlatConnection(SIDE_INSIDE, &conn, SIDE_INSIDE);				else if (connType == SDEF_CONTENT)					RemoveFlatConnection(SIDE_OUTSIDE, &conn, SIDE_OUTSIDE);				if (conn.surf->Connected(polyhedron, this, -1))					conn.surf->Disconnect(polyhedron, this, -1);				i--;				nConn--;				}			}		ConnectionArrayX(connType);		}	}voidSurfDef::DisconnectNot(V_Array *polys, int type)	{	int connType, nConn, nPolys, i, j;	Connection conn, *c;	Polyhedron **poly;	for (connType = 0; connType < 3; connType++)		{		if (type >= 0 && type != connType || connections[connType] == NULL)			continue;		nConn = connections[connType]->ALength();		for (i = 0; i < nConn; i++)			{			c = (Connection*)connections[connType]->Abuse();			conn = c[i];			nPolys = polys->ALength();			poly = (Polyhedron **)polys->Use();			for (j = 0; j < nPolys; j++, poly++)				if (conn.poly == *poly) break;			polys->Unuse();			if (j == nPolys)				{				SurfDef *surf = conn.surf;				connections[connType]->Remove(i);					if (connType == SDEF_PEER)					RemoveFlatConnection(SIDE_INSIDE, &conn, SIDE_OUTSIDE);				else if (connType == SDEF_CONTAINER)					RemoveFlatConnection(SIDE_INSIDE, &conn, SIDE_INSIDE);				else if (connType == SDEF_CONTENT)					RemoveFlatConnection(SIDE_OUTSIDE, &conn, SIDE_OUTSIDE);				if (conn.surf->Connected(polyhedron, this, -1))					conn.surf->Disconnect(polyhedron, this, -1);					i--;				nConn--;				}			}		ConnectionArrayX(connType);		}	}intSurfDef::Connected(Polyhedron *poly, SurfDef *surf, int type)	{	int connType, nConn, i;	Connection *conn;	if (poly == NULL && surf != NULL)		poly = surf->polyhedron;	if (poly == NULL)		{		if (type < 0)			{			return(connections[SDEF_PEER] != NULL || connections[SDEF_CONTAINER] != NULL ||				connections[SDEF_CONTENT] != NULL);			}		else return(connections[type] != NULL);		}	else		{		if ((connType = ConnectionType(poly)) < 0 || connections[connType] == NULL)			return(FALSE);			if (type >= 0 && type != connType)			return(FALSE);		nConn = connections[connType]->ALength();		conn = (Connection *)connections[connType]->Abuse();			for (i = 0; i < nConn; i++, conn++)			if (conn->poly == poly && (surf == NULL || conn->surf == surf))				break;		return (i != nConn);		}	}intSurfDef::ConnectionType(Polyhedron *poly)	{	if (polyhedron->container == poly->container)		return(SDEF_PEER);	else if (polyhedron->container == poly)		return(SDEF_CONTAINER);	else if (poly->container == polyhedron)		return(SDEF_CONTENT);	else return(-1);	}voidSurfDef::ConnectionArray(int type)	{	if (connections[type] == NULL)		{		connections[type] = new(V_Array);		connections[type]->cArray(0, sizeof(Connection), 4);		}	}voidSurfDef::ConnectionArrayX(int type)	{	if (connections[type] != NULL && connections[type]->ALength() == 0)		{		connections[type]->dArray();		connections[type] = NULL;		}	}voidSurfDef::InsertFlatConnection(int side, Connection *mark, Connection *conn, int connSide)	{	int i, j, loop;	int where, connWhere;	SurfFeature **featureList;	FlatConnectionArray(side);	if ((i = flatConnections[side]->Find(mark)) < 0)		i = flatConnections[side]->ALength();	j = i;	flatConnections[side]->Insert(i, conn);	if (conn->surf->flatConnections[connSide] != NULL)		{		flatConnections[side]->InsertArray(conn->surf->flatConnections[connSide], i);		j += conn->surf->flatConnections[connSide]->ALength();		}	if (side == SIDE_INSIDE)		{		if (connSide == SIDE_INSIDE)			firstContainer = i + conn->surf->firstContainer;		else			{			firstContainer += 1;			if (conn->surf->flatConnections[connSide] != NULL)				firstContainer += conn->surf->flatConnections[connSide]->ALength();			}		FindOutsidePoly();		}	where = (side == SIDE_INSIDE ? SURF_INSIDE : SURF_OUTSIDE);	connWhere = (connSide == SIDE_INSIDE ? SURF_INSIDE : SURF_OUTSIDE);	interesting[where][side] += conn->surf->Interesting(connSide, connWhere);	interesting[SURF_SHARED][side] += conn->surf->Interesting(connSide, SURF_SHARED);	interesting[SURF_OPPOSITE(where)][side] += conn->surf->Interesting(connSide, SURF_OPPOSITE(connWhere));	if (connections[SDEF_CONTAINER] != NULL && side == SIDE_OUTSIDE)		{		int nConn, i;		Connection *c;		nConn = connections[SDEF_CONTAINER]->ALength();		c = (Connection *)connections[SDEF_CONTAINER]->Use();		for (i = 0; i < nConn; i++, c++)			c->surf->InsertFlatConnection(SIDE_OUTSIDE, mark, conn, connSide);		connections[SDEF_CONTAINER]->Unuse();		}	else if (connections[SDEF_PEER] != NULL && side == SIDE_OUTSIDE)		{		int nConn, i;		Connection *c;		nConn = connections[SDEF_PEER]->ALength();		c = (Connection *)connections[SDEF_PEER]->Use();		for (i = 0; i < nConn; i++, c++)			c->surf->InsertFlatConnection(SIDE_INSIDE, mark, conn, connSide);		connections[SDEF_PEER]->Unuse();		}	else if (connections[SDEF_CONTENT] != NULL && side == SIDE_INSIDE)		{		int nConn, i;		Connection *c;		nConn = connections[SDEF_CONTENT]->ALength();		c = (Connection *)connections[SDEF_CONTENT]->Use();		for (i = 0; i < nConn; i++, c++)			c->surf->InsertFlatConnection(SIDE_INSIDE, mark, conn, connSide);		connections[SDEF_CONTENT]->Unuse();		}	if (features[SURF_SHARED])		{		long len = features[SURF_SHARED]->ALength();		featureList = (SurfFeature**)features[SURF_SHARED]->Use();		for (loop=0; loop< len; featureList++,loop++)			(*featureList)->AddConnection(i, j, side);		features[SURF_SHARED]->Unuse();		}	if (!IS_OPAQUE(opacity) && (flatConnections[side]))		{		Connection	conn;		V_Array		*tempArray;		long		length, loop;		V_Region	*sRgn;		short		plane = 0;				tempArray = new(V_Array);		tempArray->cArray(0,sizeof(PointFFixed),4);		conn.poly = polyhedron;		conn.surf = this;		Fast2DFromConnection(&conn, tempArray, &plane);		sRgn = new(V_Region);		sRgn->cRegion(tempArray);				length = flatConnections[side]->ALength() -1;		for (loop = length; loop >= 0; loop --)			{			if ((side == SIDE_OUTSIDE)||(loop < firstContainer))				{				flatConnections[side]->Get(loop, &conn);				tempArray->SetLength(0);				Fast2DFromConnection(&conn, tempArray, &plane);				sRgn->AddCompliment(tempArray);				}			}		if (sRgn->Compliment())			renderPoly[side] = TRUE;		else			renderPoly[side] = FALSE;		sRgn->dRegion();		tempArray->dArray();		}	else		renderPoly[side] = TRUE;	}voidSurfDef::RemoveFlatConnection(int side, Connection *conn, int connSide)	{	int i, j, loop;	int where, connWhere;SurfFeature **featureList;	if ((j = flatConnections[side]->Find(conn)) < 0)		j = flatConnections[side]->ALength() - 1;	i = j;	if (conn->surf->flatConnections[connSide] != NULL)		i -= conn->surf->flatConnections[connSide]->ALength();if (features[SURF_SHARED]){long len = features[SURF_SHARED]->ALength();featureList = (SurfFeature**)features[SURF_SHARED]->Use();for (loop=0; loop< len; featureList++,loop++)	(*featureList)->RemoveConnection(i, j, side);features[SURF_SHARED]->Unuse();}	flatConnections[side]->RemoveRange(i, j);	FlatConnectionArrayX(side);	if (side == SIDE_INSIDE)		{		if (connSide == SIDE_INSIDE)			firstContainer = i;		else			{			firstContainer -= 1;			if (conn->surf->flatConnections[connSide] != NULL)				firstContainer -= conn->surf->flatConnections[connSide]->ALength();			}		FindOutsidePoly();		}	where = (side == SIDE_INSIDE ? SURF_INSIDE : SURF_OUTSIDE);	connWhere = (connSide == SIDE_INSIDE ? SURF_INSIDE : SURF_OUTSIDE);	interesting[where][side] -= conn->surf->Interesting(connSide, connWhere);	interesting[SURF_SHARED][side] -= conn->surf->Interesting(connSide, SURF_SHARED);	interesting[SURF_OPPOSITE(where)][side] -= conn->surf->Interesting(connSide, SURF_OPPOSITE(connWhere));	if (connections[SDEF_CONTAINER] != NULL && side == SIDE_OUTSIDE)		{		int nConn, i;		Connection *c;		nConn = connections[SDEF_CONTAINER]->ALength();		c = (Connection *)connections[SDEF_CONTAINER]->Use();		for (i = 0; i < nConn; i++, c++)			c->surf->RemoveFlatConnection(SIDE_OUTSIDE, conn, connSide);		connections[SDEF_CONTAINER]->Unuse();		}	else if (connections[SDEF_PEER] != NULL && side == SIDE_OUTSIDE)		{		int nConn, i;		Connection *c;		nConn = connections[SDEF_PEER]->ALength();		c = (Connection *)connections[SDEF_PEER]->Use();		for (i = 0; i < nConn; i++, c++)			c->surf->RemoveFlatConnection(SIDE_INSIDE, conn, connSide);		connections[SDEF_PEER]->Unuse();		}	else if (connections[SDEF_CONTENT] != NULL && side == SIDE_INSIDE)		{		int nConn, i;		Connection *c;		nConn = connections[SDEF_CONTENT]->ALength();		c = (Connection *)connections[SDEF_CONTENT]->Use();		for (i = 0; i < nConn; i++, c++)			c->surf->RemoveFlatConnection(SIDE_INSIDE, conn, connSide);		connections[SDEF_CONTENT]->Unuse();		}	if (!IS_OPAQUE(opacity) && (flatConnections[side]))		{		Connection	conn;		V_Array		*tempArray;		long		length, loop;		V_Region	*sRgn;		short		plane = 0;				tempArray = new(V_Array);		tempArray->cArray(0,sizeof(PointFFixed),4);		conn.poly = polyhedron;		conn.surf = this;		Fast2DFromConnection(&conn, tempArray, &plane);		sRgn = new(V_Region);		sRgn->cRegion(tempArray);				length = flatConnections[side]->ALength() -1;		for (loop = length; loop >= 0; loop --)			{			if ((side == SIDE_OUTSIDE)||(loop < firstContainer))				{				flatConnections[side]->Get(loop, &conn);				tempArray->SetLength(0);				Fast2DFromConnection(&conn, tempArray, &plane);				sRgn->AddCompliment(tempArray);				}			}		if (sRgn->Compliment())			renderPoly[side] = TRUE;		else			renderPoly[side] = FALSE;		sRgn->dRegion();		tempArray->dArray();		}	else		renderPoly[side] = TRUE;	}voidSurfDef::FindOutsidePoly()	{	Connection conn;	if (flatConnections[SIDE_INSIDE] != NULL &&		firstContainer < flatConnections[SIDE_INSIDE]->ALength())		{		flatConnections[SIDE_INSIDE]->Get(firstContainer, &conn);		stopPoly = conn.poly;		}	else stopPoly = polyhedron;	outsidePoly = stopPoly->container;	while (outsidePoly != NULL && outsidePoly->type == POLY_GROUP)		outsidePoly = outsidePoly->container;	}voidSurfDef::FixConnections()	{	int nConn, i;	Connection *conn;	if (connections[SDEF_CONTENT] != NULL)		{		nConn = connections[SDEF_CONTENT]->ALength();		conn = (Connection *)connections[SDEF_CONTENT]->Use();			for (i = 0; i < nConn; i++, conn++)			{			conn->surf->FindOutsidePoly();			conn->poly->FixConnections();			}			connections[SDEF_CONTENT]->Unuse();		}	}voidSurfDef::FlatConnectionArray(int side)	{	if (flatConnections[side] == NULL)		{		flatConnections[side] = new(V_Array);		flatConnections[side]->cArray(0, sizeof(Connection), 4);		}	}voidSurfDef::FlatConnectionArrayX(int side)	{	if (flatConnections[side] != NULL && flatConnections[side]->ALength() == 0)		{		flatConnections[side]->dArray();		flatConnections[side] = NULL;		}	}voidSurfDef::InstallFeature(SurfFeature *feat, int where)	{	if (feat->type == FEAT_INVALID)		return;	if (features[where] == NULL)		{		if (!LocalInterest(where))			PropagateInterest(where, 1);		features[where] = new(V_Array);		features[where]->cArray(0, sizeof(SurfFeature *), 4);		flags |= SDEF_FEAT(where);		}	features[where]->Append(&feat);	feat->surfDef = this;	feat->Update();	feat->CalcShade();	}voidSurfDef::RemoveFeature(SurfFeature *feat, int where)	{	int i;	if ((i = features[where]->Find(&feat)) < 0)		return;	features[where]->Remove(i);	feat->surfDef = NULL;	if (features[where]->ALength() == 0)		{		features[where]->dArray();		features[where] = NULL;				flags &= ~SDEF_FEAT(where);		if (!LocalInterest(where))			PropagateInterest(where, -1);		}	}voidSurfDef::MoveFeature(SurfFeature *feat, int offset, int where)	{	int num, to;	if ((num = features[where]->Find(&feat)) < 0)		return;	to = num + offset;	if (to >= features[where]->ALength())		to = features[where]->ALength()-1;	else if (to < 0)		to = 0;	features[where]->Get(num, &feat);	features[where]->Remove(num);	features[where]->Insert(to, &feat);	}voidSurfDef::ChangeUnit(FFixed factor)	{	int nFeatures, i, where;	SurfFeature **feat;	for (where = 0; where < 3; where++)		{		if (features[where] != NULL)			{			nFeatures = features[where]->ALength();			feat = (SurfFeature **)features[where]->Use();			for (i = 0; i < nFeatures; i++)				(*feat++)->ChangeUnit(factor);			features[where]->Unuse();			}		}	}voidSurfDef::SetColor(RGBColor clr, unsigned short opc, int where)	{	SurfDef *me = this;	int surfNum;	Surface *surf;int moreInterest, lessInterest;moreInterest = IS_OPAQUE(GetOpacity()) && !IS_OPAQUE(opc);lessInterest = !IS_OPAQUE(GetOpacity()) && IS_OPAQUE(opc);if (moreInterest && !LocalInterest(SURF_SHARED))	PropagateInterest(SURF_SHARED, 1);	if (where == SURF_SHARED || !IS_OPAQUE(opc))		{		insideColor = clr;		outsideColor = clr;		flags |= SDEF_COLR(SURF_INSIDE) | SDEF_COLR(SURF_OUTSIDE);		}	else if (where == SURF_INSIDE)		{		insideColor = clr;		flags |= SDEF_COLR(SURF_INSIDE);		}	else if (where == SURF_OUTSIDE)		{		outsideColor = clr;		flags |= SDEF_COLR(SURF_OUTSIDE);		}	opacity = opc;	ResolveOpacity();if (lessInterest && !LocalInterest(SURF_SHARED))	PropagateInterest(SURF_SHARED, -1);	surfNum = polyhedron->surfDef->Find(&me);	surf = polyhedron->FindSurface(surfNum);	if (surf != NULL) surf->CalcShade();	}RGBColorSurfDef::GetColor(int where)	{	if (where == SURF_SHARED)		where = SURF_OUTSIDE;	if (flags & SDEF_COLR(where))		{		if (where == SURF_INSIDE)			return (insideColor);		else			return (outsideColor);		}	else return (polyhedron->GetColor(where));	}unsigned shortSurfDef::GetOpacity()	{	if (flags & SDEF_COLOR)		return(opacity);	else		return(polyhedron->GetOpacity());	}voidSurfDef::RemoveColor(int where)	{	if (where == SURF_SHARED || !IS_OPAQUE(opacity))		{		insideColor = vBlack;		outsideColor = vBlack;		flags &= ~(SDEF_COLR(SURF_INSIDE) | SDEF_COLR(SURF_OUTSIDE));		}	else if (where == SURF_INSIDE)		{		insideColor = vBlack;		flags &= ~SDEF_COLR(SURF_INSIDE);		}	else if (where == SURF_OUTSIDE)		{		outsideColor = vBlack;		flags &= ~SDEF_COLR(SURF_OUTSIDE);		}	if (!(flags & SDEF_COLOR))		opacity = 0;	ResolveOpacity();	}voidSurfDef::ResolveOpacity()	{	int i, o;	i = flags & SDEF_COLR(SURF_INSIDE);	o = flags & SDEF_COLR(SURF_OUTSIDE);	if (!IS_OPAQUE(polyhedron->GetOpacity()) && (i && !o || o && !i))		{		if (i)			{			outsideColor = insideColor;			flags |= SDEF_COLR(SURF_OUTSIDE);			}		else			{			insideColor = outsideColor;			flags |= SDEF_COLR(SURF_INSIDE);			}		}	}intSurfDef::Interesting(int side, int where)	{	return(LocalInterest(where) + interesting[where][side]);	}intSurfDef::LocalInterest(int where)	{	if (features[where] != NULL)		return(1);	// BILBIL - DWE - 14APR94 - don't do a texture case here, is	// VERY different from the case w/ colors, opacity and color	// are closely tied.	if (where == SURF_SHARED &&		(flags & SDEF_COLOR) && !IS_OPAQUE(opacity) ||		!(flags & SDEF_COLOR) && !IS_OPAQUE(polyhedron->opacity))		return(1);	return(0);	}voidSurfDef::PropagateInterest(int where, int delta)	{	int side;	V_Array *conn;	for (side = 0; side < 2; side++)		{		if ((conn = flatConnections[side]) != NULL)			{			int nConn, i;			Connection *c;			int connSide, connWhere;			nConn = conn->ALength();			c = (Connection *)conn->Use();				for (i = 0; i < nConn; i++, c++)				{				connSide = (side == SIDE_OUTSIDE || i < firstContainer) ?					SIDE_INSIDE : SIDE_OUTSIDE;				connWhere = (connSide != side ? where : SURF_OPPOSITE(where));				c->surf->interesting[connWhere][connSide] += delta;				}				conn->Unuse();			}		}	}extern double Vsqrt(double);voidSurfDef::CalcTransform(Point3DFFixed point, Point3D normal)	{	Angle3DFFixed ang;	position->Reset();	if (normal.x != 0 || normal.y != 0)		{		long hypXYSquare;		double hypXY;		double yaw, pitch;		hypXYSquare = (long)normal.x*normal.x + (long)normal.y*normal.y;		hypXY = Vsqrt(hypXYSquare);		pitch = atan2(hypXY, normal.z);		yaw = atan2(normal.x, -normal.y);		ang = Ang3DFFZero; ang.pitch = DblToFixed(pitch);		position->Rotate3D(ang, Pt3DFFZero);		ang = Ang3DFFZero; ang.yaw = DblToFixed(yaw);		position->Rotate3D(ang, Pt3DFFZero);		}	else if (normal.z < 0)		{		ang = Ang3DFFZero; ang.roll = FFPi;		position->Rotate3D(ang, Pt3DFFZero);		}	position->Move3D(point);	}voidSurfDef::CalcOutline(V_Array *refs, V_Array *points)	{	int nPoints, i;	short *ref;	Point3DFFixed *pnt, outlPoint3D, temp3D;	PointFFixed outlPoint, min, *oPnt;	Position *posn;	if (outline == NULL)		{		outline = new(V_Array);		outline->cArray(0, sizeof(PointFFixed), 4);		}	else outline->SetLength(0);	nPoints = refs->ALength();	ref = (short *)refs->Use();	pnt = (Point3DFFixed *)points->Use();	for (i = 0; i < nPoints; i++)		{		temp3D = pnt[*ref++];		// BILBIL - PPC fix for next function call - 12/06/93		outlPoint3D = position->UnTransform3D(temp3D);		outlPoint.h = outlPoint3D.x; outlPoint.v = outlPoint3D.y;		outline->Append(&outlPoint);		if (i == 0 || FFLogic(outlPoint.h, min.h) < 0) min.h = outlPoint.h;		if (i == 0 || FFLogic(outlPoint.v, min.v) < 0) min.v = outlPoint.v;		}	refs->Unuse();	points->Unuse();	nPoints = outline->ALength();	oPnt = (PointFFixed*)outline->Use();	for (i = 0; i < nPoints; i++, oPnt++)		{		oPnt->h = FFSub(oPnt->h, min.h);		oPnt->v = FFSub(oPnt->v, min.v);		}	outline->Unuse();	posn = new(Position);	posn->cPosition();	posn->Move2D(min);	posn->PositionX(position);	posn->Copy(position);	posn->dPosition();	}voidSurfDef::Update(Point3D normal, V_Array *refs, V_Array *points)	{	short pointNum;	Point3DFFixed point;	int nFeatures, i, where;	SurfFeature **feat;	refs->Get(0, &pointNum);	points->Get(pointNum, &point);	CalcTransform(point, normal);	CalcOutline(refs, points);	for (where = 0; where < 3; where++)		{		if (features[where] != NULL)			{			nFeatures = features[where]->ALength();			feat = (SurfFeature **)features[where]->Use();			for (i = 0; i < nFeatures; i++)				(*feat++)->Update();			features[where]->Unuse();			}		}	CalcTextureMapping();	// JAM - scale textures on surface features	}voidSurfDef::CalcShade()	{	int nFeatures, i, where;	SurfFeature **feat;	for (where = 0; where < 3; where++)		{		if (features[where] != NULL)			{			nFeatures = features[where]->ALength();			feat = (SurfFeature **)features[where]->Use();			for (i = 0; i < nFeatures; i++)				(*feat++)->CalcShade();			features[where]->Unuse();			}		}	}intSurfDef::FeatCount()	{	int where, count = 0;	for (where = 0; where < 3; where++)		if (features[where] != NULL) count += features[where]->ALength();    return(count);	}SurfFeature *SurfDef::NewSurfFeature()	{	return (new(SurfFeature));	}intSurfDef::IO(V_Buffer *buf)	{	long id;	int nFeatures, i;	short where;	SurfFeature *feat, **featIndex;	int err = 0;	ObjLock((ObjectHandle)this);	if (buf->IODirection() == DATA_IN)		{		while (!err)			{			id = buf->OpenChunkR();			if (id == 0) break;			switch (id)				{				case IFF_COLR:					err = IO_COLR(buf);					break;// ABD MERGE-TEXTURE 9/13/93 [[[				case IFF_SUTX:			// ABD TEXTURE					err = IO_SUTX(buf);					break;// ABD MERGE-TEXTURE 9/13/93 ]]]// ABD MERGE-GOURAUD [[[				case IFF_SUGR:					err = IO_SUGR(buf);					break;// ABD MERGE-GOURAUD ]]]				#if VRML_ANCHOR			// VRML-ABD 23JUN95				case IFF_VRAN:					err = IO_VRAN(buf);					break;				#endif // VRML_ANCHOR				case IFF_FEAT:					err = buf->IOType(&where, IO_SHORT);					if (!err)						{						feat = NewSurfFeature();						feat->cSurfFeature();						err = feat->IO(buf);						if (!err && feat->FeatValid())							InstallFeature(feat, where);						else							feat->dSurfFeature();						}					break;				}			buf->CloseChunk();			}		}	else		{		if (flags & SDEF_COLOR)			{			buf->OpenChunkW(IFF_COLR);			err = IO_COLR(buf);			buf->CloseChunk();			}// ABD MERGE-TEXTURE 9/13/93 [[[		// we need to check the flags instead of insideTexture/outsideTexture directly, because		// they could be NULL but we would still need to save the textured info.  See comments		// in the IO_SUTX/SetTexture routines.		if (flags & SDEF_TEXTURE)		// ABD TEXTURE			{			buf->OpenChunkW(IFF_SUTX);			err = IO_SUTX(buf);			buf->CloseChunk();			}// ABD MERGE-TEXTURE 9/13/93 ]]]		// MERGE-GOURAUD [[[		if (flags & SDEF_GOURAUD)		{			buf->OpenChunkW(IFF_SUGR);			IO_SUGR(buf);			buf->CloseChunk();		}		// MERGE-GOURAUD ]]]		#if VRML_ANCHOR			// VRML-ABD 23JUN95		if (HasVRMLAnchor())		{			buf->OpenChunkW(IFF_VRAN);			IO_VRAN(buf);			buf->CloseChunk();		}		#endif // VRML_ANCHOR		for (where = 0; where < 3 && !err; where++)			{			if (features[where] == NULL)				continue;			nFeatures = features[where]->ALength();			featIndex = (SurfFeature **)features[where]->Use();			for (i = 0; i < nFeatures && !err; i++)				{				buf->OpenChunkW(IFF_FEAT);				err = buf->IOType(&where, IO_SHORT);				if (!err) (*featIndex++)->IO(buf);				buf->CloseChunk();				}			features[where]->Unuse();			}		}	ObjUnlock((ObjectHandle)this);	return(err);	}intSurfDef::IO_COLR(V_Buffer *buf)	{	short where;	RGBAColor clr1, clr2;	int err = 0;	if (buf->IODirection() == DATA_IN)		{		buf->IOType(&where, IO_SHORT);		where--;		if (where == SURF_SHARED)			{			IOType(buf, &clr1, IO_RGBA_COLOR);			IOType(buf, &clr2, IO_RGBA_COLOR);						insideColor.red = clr1.red;			insideColor.green = clr1.green;			insideColor.blue = clr1.blue;			outsideColor.red = clr2.red;			outsideColor.green = clr2.green;			outsideColor.blue = clr2.blue;						opacity = clr2.alpha;						flags |= SDEF_COLR(SURF_INSIDE) | SDEF_COLR(SURF_OUTSIDE);			}		else if (where == SURF_INSIDE)			{			IOType(buf, &clr1, IO_RGBA_COLOR);						insideColor.red = clr1.red;			insideColor.green = clr1.green;			insideColor.blue = clr1.blue;						opacity = clr1.alpha;						flags |= SDEF_COLR(SURF_INSIDE);			}		else if (where == SURF_OUTSIDE)			{			IOType(buf, &clr1, IO_RGBA_COLOR);						outsideColor.red = clr1.red;			outsideColor.green = clr1.green;			outsideColor.blue = clr1.blue;						opacity = clr1.alpha;						flags |= SDEF_COLR(SURF_OUTSIDE);			}		}	else		{		if ((flags & SDEF_COLR(SURF_INSIDE)) && (flags & SDEF_COLR(SURF_OUTSIDE)))			{			where = SURF_SHARED+1;			buf->IOType(&where, IO_SHORT);						clr1.red = insideColor.red;			clr1.green = insideColor.green;			clr1.blue = insideColor.blue;			clr1.alpha = 0;			clr2.red = outsideColor.red;			clr2.green = outsideColor.green;			clr2.blue = outsideColor.blue;			clr2.alpha = opacity;			IOType(buf, &clr1, IO_RGBA_COLOR);			IOType(buf, &clr2, IO_RGBA_COLOR);			}		else if (flags & SDEF_COLR(SURF_INSIDE))			{			where = SURF_INSIDE+1;			buf->IOType(&where, IO_SHORT);						clr1.red = insideColor.red;			clr1.green = insideColor.green;			clr1.blue = insideColor.blue;			clr1.alpha = opacity;			IOType(buf, &clr1, IO_RGBA_COLOR);			}		else if (flags & SDEF_COLR(SURF_OUTSIDE))			{			where = SURF_OUTSIDE+1;			buf->IOType(&where, IO_SHORT);			clr1.red = outsideColor.red;			clr1.green = outsideColor.green;			clr1.blue = outsideColor.blue;			clr1.alpha = opacity;			IOType(buf, &clr1, IO_RGBA_COLOR);			}		}	return(err);	}/* don't much like the way this worked out either */intSurfDef::IO_CONN(V_Buffer *buf, short fromPolyNum, short fromSurfNum,	V_Array *contents, short *n)	{	int nConn, i;	Connection *conn;	short toPolyNum, toSurfNum;	int err = 0;	*n = 0;	if (connections[SDEF_CONTAINER] != NULL)		{		nConn = connections[SDEF_CONTAINER]->ALength();		conn = (Connection *)connections[SDEF_CONTAINER]->Use();			for (i = 0; i < nConn; i++, conn++)			{			toPolyNum = -1;			toSurfNum = conn->poly->surfDef->Find(&conn->surf);			buf->IOType(&toPolyNum, IO_SHORT);			buf->IOType(&toSurfNum, IO_SHORT);			buf->IOType(&fromPolyNum, IO_SHORT);			buf->IOType(&fromSurfNum, IO_SHORT);			(*n)++;			}			connections[SDEF_CONTAINER]->Unuse();		}	if (connections[SDEF_PEER] != NULL)		{		nConn = connections[SDEF_PEER]->ALength();		conn = (Connection *)connections[SDEF_PEER]->Use();			for (i = 0; i < nConn; i++, conn++)			{			toPolyNum = contents->Find(&conn->poly);				if (toPolyNum > fromPolyNum)				{				toSurfNum = conn->poly->surfDef->Find(&conn->surf);					buf->IOType(&fromPolyNum, IO_SHORT);				buf->IOType(&fromSurfNum, IO_SHORT);				buf->IOType(&toPolyNum, IO_SHORT);				buf->IOType(&toSurfNum, IO_SHORT);					(*n)++;				}			}			connections[SDEF_PEER]->Unuse();		}	return(err);	}// ABD MERGE-TEXTURE 9/13/93 [[[/*----- ABD TEXTURE STUFF -----*//* ABD TEXTURE */voidSurfDef::SetTexture(struct TextureItem *t, int where){	// don't do anything if textures are the same	if ((where == SURF_SHARED) && (t == insideTexture) && (t == outsideTexture) 		&& (t == polyhedron->GetTexture(SURF_INSIDE)) && (t == polyhedron->GetTexture(SURF_OUTSIDE)))		return;	else if ((where == SURF_INSIDE) && (t == insideTexture) && (t == polyhedron->GetTexture(SURF_INSIDE)))		return;	else if ((where == SURF_OUTSIDE) && (t == outsideTexture) && (t == polyhedron->GetTexture(SURF_OUTSIDE)))		return;	SetTextureIO(t, where);		// recalc the texture mapping	CalcTextureMapping();			// calc the texture shading here !!!}/* ABD TEXTURE -- set texture routine that deferres recalc of texture mapping */voidSurfDef::SetTextureIO(struct TextureItem *t, int where){struct SurfDef *local_surf = this;int err = noErr;	if (where == SURF_SHARED)	{		if (t != insideTexture)	 	{	 		// if the texture we are using is not NULL, then stop using it			if (insideTexture != NULL) 				insideTexture->DocUnuseSurf(local_surf);							// if t is not NULL, then start using it			if (t != NULL) 				err = t->DocUseSurf(local_surf);							// set the texture			insideTexture = t;		}		if (t != outsideTexture)	 	{			if (outsideTexture != NULL) 				outsideTexture->DocUnuseSurf(local_surf);			if (t != NULL) 				err = t->DocUseSurf(local_surf);			outsideTexture = t;		}				// update flags to be the current textured state		// note that this surf def could have a texture of NULL, but if the polyhedron is		// textured, we still need to remember this		if (t == NULL)		{			// if the polyhedron this surface is attached to is NULL, and this new texture t			// is NULL, then we are no longer textured.  However, if the polygon is textured			// and the new texture t is NULL, we need to "pretend" to be textured so that			// this information (the fact that we are NOT textured even though the polyhedron			// is) should be saved in the model.  So only clear the texture flag if we are NULL			// and the polyhedron is NULL.  We set the texture flag if t is not NULL or if t			// is NULL but the poly texture is not NULL.						if (polyhedron->GetTexture(SURF_SHARED) == NULL)				flags &= ~(SDEF_TEXT(SURF_INSIDE) | SDEF_TEXT(SURF_OUTSIDE));			else				flags |= SDEF_TEXT(SURF_INSIDE) | SDEF_TEXT(SURF_OUTSIDE);		}		else	// the new texture is not NULL, so set flags to textured		{			flags |= SDEF_TEXT(SURF_INSIDE) | SDEF_TEXT(SURF_OUTSIDE);		}	}	else if (where == SURF_INSIDE)	{		if (t != insideTexture)	 	{			if (insideTexture != NULL) 				insideTexture->DocUnuseSurf(local_surf);			if (t != NULL) 				err = t->DocUseSurf(local_surf);			insideTexture = t;		}				if (t == NULL)		{			// [see above comment]			if (polyhedron->GetTexture(SURF_INSIDE) == NULL)				flags &= ~(SDEF_TEXT(SURF_INSIDE));			else				flags |= SDEF_TEXT(SURF_INSIDE);		}		else	// the new texture is not NULL, so set flags to textured		{			flags |= SDEF_TEXT(SURF_INSIDE);		}	}	else if (where == SURF_OUTSIDE)	{		if (t != outsideTexture)	 	{			if (outsideTexture != NULL) 				outsideTexture->DocUnuseSurf(local_surf);			if (t != NULL) 				err = t->DocUseSurf(local_surf);			outsideTexture = t;		}		if (t == NULL)		{			// [see above comment]			if (polyhedron->GetTexture(SURF_OUTSIDE) == NULL)				flags &= ~(SDEF_TEXT(SURF_OUTSIDE));			else				flags |= SDEF_TEXT(SURF_OUTSIDE);		}		else	// the new texture is not NULL, so set flags to textured		{			flags |= SDEF_TEXT(SURF_OUTSIDE);		}	}	}/* ABD TEXTURE */struct TextureItem *SurfDef::GetTexture(int where)	{	if (where == SURF_SHARED)		where = SURF_OUTSIDE;			// note that we check the flags to determine whether or not to use insideTexture an	// outsideTexture or to use the polyhedron's texture.  This is because the flags reflect	// the true state of affairs wrt textures.  If the flags are set so that we are textured,	// then we should return this surfDef's texture pointers -- which might be NULL even though	// the polyhedron's texture is not NULL.  This is to allow overriding an objects texture	// with no texture.  The flags are set so that we can remember to save this info in the 	// model.	if (flags & SDEF_TEXT(where))		{		if (where == SURF_INSIDE)			return (insideTexture);		else			return (outsideTexture);		}	else 		return (polyhedron->GetTexture(where));	}// PRO25 [[[voidSurfDef::GetTextureName(int where, char *name)	{	struct TextureItem *ti = NULL;	 	if (where == SURF_SHARED)		where = SURF_OUTSIDE;	if (flags & SDEF_TEXT(where))		{		if (where == SURF_INSIDE)			ti = insideTexture;		else			ti = outsideTexture;		}	else 		ti = polyhedron->GetTexture(where);			if (ti != NULL)		strcpy(name, ti->settings.name); 	else		strcpy(name, "");	}// PRO25 ]]]/* ABD TEXTURE */voidSurfDef::RemoveTexture(int where)	{	if (where == SURF_SHARED)		{		insideTexture = NULL;		outsideTexture = NULL;		flags &= ~(SDEF_TEXT(SURF_INSIDE) | SDEF_TEXT(SURF_OUTSIDE));		}	else if (where == SURF_INSIDE)		{		insideTexture = NULL;		flags &= ~SDEF_TEXT(SURF_INSIDE);		}	else if (where == SURF_OUTSIDE)		{		outsideTexture = NULL;		flags &= ~SDEF_TEXT(SURF_OUTSIDE);		}	}intSurfDef::IO_SUTX(V_Buffer *buf)	// ABD TEXTURE{int err = 0;long id;long txID;struct TextureItem *t;			if (buf->IODirection() == DATA_IN)	{		while (!err)		{			id = buf->OpenChunkR();			if (id == 0) break;						switch (id)			{				case IFF_TXID:	/* inside texture ID */				{					// DATA IN					// We read in the id number and ask the texture server for a					// texture item with that id number.  If there is already a texture					// item with that id number, then we get a pointer to it.  Otherwise					// the texture server creates a new texture item with that id number.					// in any case we will receive a ptr to a texture item, and we should					// set our texture to that texture item.  Note that we MUST call					// SetTexture() instead of setting the texture directly, because					// we have to add ourselves to the list of objects using this texture.					buf->IOType(&txID, IO_LONG);	// Write out the id.					t = gTextureServer->IDtoTexture(txID);					// call SetTextureIO instead of SetTexture because we don't want to recalc					// the texture mapping yet					SetTextureIO(t, SURF_INSIDE);										// later, when the texture server reads in the id table, it will set					// the name and file ref of each of these new, blank texture items					// that it created.  If the name, when set, conflicts with a name					// that already exists in the file, then the user will be prompted					// to either rename the texture or go ahead and replace the texture					// that was there already with the new texture name/file ref.										break;				}				case IFF_TXOD:	/* outside texture ID */				{					buf->IOType(&txID, IO_LONG);	// Write out the id.					t = gTextureServer->IDtoTexture(txID);										// call SetTextureIO instead of SetTexture because we don't want to recalc					// the texture mapping yet					SetTextureIO(t, SURF_OUTSIDE);					break;				}				case IFF_TATR:	/* texture attributes */				{					break;				}			}						buf->CloseChunk();		}	}	else // DATA OUT	{				// ABD 22 Mar 93 		// DATA OUT		// ask the texture server for a new local id based on this texture		// if this texture has already been written out during this file i/o, then we		// will be given the id this texture was assigned before.  Otherwise we will		// be assigned a new id.  In any case we will be given an id.			// we need to check the flags instead of insideTexture/outsideTexture directly, because		// they could be NULL but we would still need to save the textured info.  See comments		// in the IO_SUTX/SetTexture routines.  Note that we always write out the inside and 		// outside textures.				// if inside/outsideTexture is NULL, TexturetoID will return a special value that 		// IDtoTexture undertstands.  IDToTexture will return NULL when it sees this value		// instead of searching the table for a texture that matches that ID (which of course		// is not there).		if (flags & SDEF_TEXTURE)		// ABD TEXTURE		{			buf->OpenChunkW(IFF_TXID);	/* inside texture index */			txID = gTextureServer->TexturetoID(insideTexture);			buf->IOType(&txID, IO_LONG);	// Write out the id.			buf->CloseChunk();			buf->OpenChunkW(IFF_TXOD);	/* outside texture index */			txID = gTextureServer->TexturetoID(outsideTexture);			buf->IOType(&txID, IO_LONG);	// Write out the id.			buf->CloseChunk();		}		buf->OpenChunkW(IFF_TATR);	/* texture attributes */		buf->CloseChunk();	}	return(err);}voidSurfDef::CalcTextureMapping(){TextureItem *t;Rect r,r2;double meters_per_unit;	// MERGE-VPRO-2	// if this texture is a real texture (not NULL) then create our raw texture point	// list if it doesn't already exist	t = GetTexture(SURF_INSIDE);	if (t != NULL)	{	Point *raw;	int i;		t->GetPaddedRect(&r,0);		t->GetUnpaddedRect(&r2,0);				if (!surface) return;		if (!surface->GetOutline()) return;		if (!polyhedron) return;		// MERGE-VPRO-2 [[[		if (!polyhedron->GetUnit())		{			meters_per_unit = 0.0254;	// use inches as a default		}		else 			meters_per_unit = polyhedron->GetUnit()->GetSize();		// MERGE-VPRO-2 ]]]		ObjLock(this);		// ABD MERGE-MEM		MakeTextureArray(surface->GetOutline(), &rawInsideTexturePoints, &r,&r2,		/* ABD MERGE-MEM */			t->settings.use_real_world_size_h,			t->settings.use_real_world_size_v,			t->settings.hUnit,			t->settings.vUnit,			t->settings.hPixels_per_unit,			t->settings.vPixels_per_unit,			t->settings.hTiles,			t->settings.vTiles,			meters_per_unit);	// MERGE-VPRO-2		ObjUnlock(this);	// ABD MERGE-MEM	}	t = GetTexture(SURF_OUTSIDE);	if (t != NULL)	{		t->GetPaddedRect(&r,0);		t->GetUnpaddedRect(&r2,0);				if (!surface) return;		if (!surface->GetOutline()) return;		if (!polyhedron) return;		// MERGE-VPRO-2 [[[		if (!polyhedron->GetUnit())		{			meters_per_unit = 0.0254;	// use inches as a default		}		else 			meters_per_unit = polyhedron->GetUnit()->GetSize();		// MERGE-VPRO-2 ]]]		ObjLock(this);		// ABD MERGE-MEM		MakeTextureArray(surface->GetOutline(), &rawOutsideTexturePoints, &r,&r2,		/* ABD MERGE-MEM */			t->settings.use_real_world_size_h,			t->settings.use_real_world_size_v,			t->settings.hUnit,			t->settings.vUnit,			t->settings.hPixels_per_unit,			t->settings.vPixels_per_unit,			t->settings.hTiles,			t->settings.vTiles,			meters_per_unit);	// MERGE-VPRO-2		ObjUnlock(this);	// ABD MERGE-MEM	}}// ABD MERGE-TEXTURE 9/13/93 ]]]// ABD MERGE-GOURAUD [[[voidSurfDef::SetShadeType(unsigned char sh, short where){	if (where == SURF_SHARED)	{		if (sh != insideShadeType)	 	{			insideShadeType = sh;		}		if (sh != outsideShadeType)	 	{			outsideShadeType = sh;		}				// update flags to be the current shaded state		// note that this surf def could be flat shaded, but if the polyhedron is		// gouraud shaded, we still need to remember this		if (sh == SHADE_FLAT)		{			// if the polyhedron this surface is attached to is flat shaded, and the new shade type			// is flat, then we are now flat shaded.  However, if the polyhedron is gouraud			// and the new texture t is flat, we need to "pretend" to be gouraud shaded so that			// this information (the fact that we are flat shaded even though the polyhedron			// is gouraud) should be saved in the model.  So only clear the gouraud flag if we are 			// flat and the polyhedron is flat.  We set the gouraud flag if sh is not flat or if sh			// is flat but the poly shade type is not flat.			if (polyhedron->GetShadeType(SURF_SHARED) == SHADE_FLAT)				flags &= ~(SDEF_GOUR(SURF_INSIDE) | SDEF_GOUR(SURF_OUTSIDE));			else				flags |= SDEF_GOUR(SURF_INSIDE) | SDEF_GOUR(SURF_OUTSIDE);		}		else		{			flags |= SDEF_GOUR(SURF_INSIDE) | SDEF_GOUR(SURF_OUTSIDE);		}	}	else if (where == SURF_INSIDE)	{		if (sh != insideShadeType)	 	{			insideShadeType = sh;		}				if (sh == SHADE_FLAT)		{			// [see above comment]			if (polyhedron->GetShadeType(SURF_INSIDE) == SHADE_FLAT)				flags &= ~(SDEF_GOUR(SURF_INSIDE));			else				flags |= SDEF_GOUR(SURF_INSIDE);		}		else		{			flags |= SDEF_GOUR(SURF_INSIDE);		}	}	else if (where == SURF_OUTSIDE)	{		if (sh != outsideShadeType)	 	{			outsideShadeType = sh;		}		if (sh == SHADE_FLAT)		{			// [see above comment]			if (polyhedron->GetShadeType(SURF_OUTSIDE) == SHADE_FLAT)				flags &= ~(SDEF_GOUR(SURF_OUTSIDE));			else				flags |= SDEF_GOUR(SURF_OUTSIDE);		}		else		{			flags |= SDEF_GOUR(SURF_OUTSIDE);		}	}	}unsigned charSurfDef::GetShadeType(short where){	if (where == SURF_INSIDE)		return insideShadeType;	else 		return outsideShadeType;}intSurfDef::IO_SUGR(V_Buffer *buf)	{	short where;	unsigned char sh1, sh2;	int err = 0;	if (buf->IODirection() == DATA_IN)		{		buf->IOType(&where, IO_SHORT);		where--;		if (where == SURF_SHARED)			{			buf->IOType(&sh1, IO_CHAR);			buf->IOType(&sh2, IO_CHAR);						insideShadeType = sh1;			outsideShadeType = sh2;						flags |= SDEF_GOUR(SURF_INSIDE) | SDEF_GOUR(SURF_OUTSIDE);			}		else if (where == SURF_INSIDE)			{			buf->IOType(&sh1, IO_CHAR);						insideShadeType = sh1;						flags |= SDEF_GOUR(SURF_INSIDE);			}		else if (where == SURF_OUTSIDE)			{			buf->IOType(&sh1, IO_CHAR);						outsideShadeType = sh1;						flags |= SDEF_GOUR(SURF_OUTSIDE);			}		}	else		{		if ((flags & SDEF_GOUR(SURF_INSIDE)) && (flags & SDEF_GOUR(SURF_OUTSIDE)))			{			where = SURF_SHARED+1;			buf->IOType(&where, IO_SHORT);						sh1 = insideShadeType;			sh2 = outsideShadeType;			buf->IOType(&sh1, IO_CHAR);			buf->IOType(&sh2, IO_CHAR);			}		else if (flags & SDEF_GOUR(SURF_INSIDE))			{			where = SURF_INSIDE+1;			buf->IOType(&where, IO_SHORT);						sh1 = insideShadeType;			buf->IOType(&sh1, IO_CHAR);			}		else if (flags & SDEF_GOUR(SURF_OUTSIDE))			{			where = SURF_OUTSIDE+1;			buf->IOType(&where, IO_SHORT);			sh1 = outsideShadeType;			buf->IOType(&sh1, IO_CHAR);			}		}	return(err);	}// MERGE-GOURAUD ]]]#if VRML_ANCHOR				// VRML-ABD 23JUN95voidSurfDef::SetVRMLAnchor(char *new_anchor){char *str;int i;	#if DEBUG	if (new_anchor == NULL)		DEBUGGER();	#endif // DEBUG		if (vrml_anchor != NULL)		vrml_anchor->dArray();	vrml_anchor = new(V_Array);	vrml_anchor->cArray(0, sizeof(char), 4);	vrml_anchor->SetLength(strlen(new_anchor));	str = (char *)vrml_anchor->Use();	for ( i = 0 ; i < strlen(new_anchor) ; i++ )		str[i] = new_anchor[i];	vrml_anchor->Unuse();}V_Array *SurfDef::GetVRMLAnchor(){	return vrml_anchor;}intSurfDef::HasVRMLAnchor(){	return (vrml_anchor != NULL);}intSurfDef::IO_VRAN(V_Buffer *buf){int err = 0;	if (buf->IODirection() == DATA_IN)	{		vrml_anchor = new(V_Array);		vrml_anchor->cArray(buf->ChunkSize(), sizeof(char), 4);	}			err = vrml_anchor->IO(buf);	return(err);}#endif // VRML_ANCHOR// VRML-ABD 23JUN95// ABD NOTE: This was added because there// may be times when we want to write out the SurfDef, but the flags don't // indicate that.  So there is a new routine, ShouldWriteSurfDef() that // returns TRUE if we should write out the SurfDef.  It just checks the// flags against SDEF_IO, and then if we are doing VRML stuff, it or's// that with HasVRMLAnchor().intSurfDef::ShouldWriteSurfDef(){int ret = flags & SDEF_IO;	#if VRML_ANCHOR	ret = ret || HasVRMLAnchor();	#endif // VRML_ANCHOR		return ret;}