/*------------------------------------------------------------------------------ * Virtus WalkThrough_ * Version 1.1.1 * * Copyright _ 1990-1992 by Virtus Corporation * All Rights Reserved * Written by   *				 *				Mark J. Uland * Virtus Corporation * Suite 204 * 117 Edinburgh South * Cary, North Carolina    27511 * (919) 467-9700 *------------------------------------------------------------------------------ * Source File:  * Notes:  * History:  *------------------------------------------------------------------------------ */ #include "VTypes.h"#include "CVSrfDef.h"#include "CVSrfFet.h"#include "CVPolyh.h"#include "CVEnvirn.h"#include "SrfObj.h"#include "PolyDefs.h"#include "Export.h"#include "Surface.h"#include "ExpArray.h"#include "Position.h"#include "VMath.h"voidCAVSurfDef::InstallFeature(SurfFeature *feature,int where)	{	CAVSurfFeature *pFeat;	pFeat = (CAVSurfFeature *)feature;	SurfDef::InstallFeature(feature,where);	if(surfDefObject)		{		pFeat->cSurfObject(surfDefObject->environment);		pFeat->SetSide(where);		}	}SurfFeature *CAVSurfDef::NewSurfFeature()	{	return(new(CAVSurfFeature));	}voidCAVSurfDef::cSurfObject(CAVEnvironment *env)	{	CAVSurfFeature	**pFeat;	int		i,k,length;			surfDefObject = new(SurfObject);	surfDefObject->cSurfObject();	surfDefObject->SetSurfDef(this);	surfDefObject->SetEnvironment(env);	localOutline = new(V_Array);	localOutline->cArray(0,sizeof(PointFFixed),4);	for(k = 0; k < 3; k++)		{		if(NULL != features[k])			{			pFeat = (CAVSurfFeature	**)features[k]->Use();			length = features[k]->ALength();			for(i = 0; i < length; i++,pFeat++)				(*pFeat)->cSurfObject(env);			features[k]->Unuse();			}		}	}voidCAVSurfDef::dSurfObject()	{	CAVSurfFeature	**pFeat;	Point3DFFixed	pt3D;	PointFFixed		*wPt,*lPt;	int		i,k,length;			surfDefObject->dSurfObject();	surfDefObject = NULL;	localOutline->dArray();	localOutline = NULL;	for(k = 0; k < 3; k++)		{		if(features[k])			{			pFeat = (CAVSurfFeature	**)features[k]->Use();			length = features[k]->ALength();			for(i = 0; i < length; i++,pFeat++)				(*pFeat)->dSurfObject();			features[k]->Unuse();			}		}	}void CAVSurfDef::Select()  { surfDefObject->Select(); }void CAVSurfDef::SetDirty(int state)   	{  	CAVSurfFeature	**pFeat;	Position	*polyPosn,*sdPosn;	Point3DFFixed	pt3D;	PointFFixed		*wPt,*lPt;	int		i,k,length;		if(surfDefObject)		{polyPosn = new(Position);polyPosn->cPosition();polyPosn->SetScale(polyhedron->posn->GetScale());polyPosn->SetShear(polyhedron->posn->GetShear());sdPosn = new(Position); /* DWE */sdPosn->cPosition();position->Copy(sdPosn);sdPosn->SetOrigin(Pt3DFFZero);				length = outline->ALength();		localOutline->SetLength(length);		wPt = (PointFFixed*)outline->Use();		lPt = (PointFFixed*)localOutline->Use();		for(i = 0; i < length; i++,wPt++,lPt++)			{			pt3D.x = wPt->h;			pt3D.y = wPt->v;			pt3D.z = FFZero;			pt3D = sdPosn->Transform3D(pt3D); /* DWE */			pt3D = polyPosn->Transform3D(pt3D);			pt3D = sdPosn->UnTransform3D(pt3D); /* DWE */			lPt->h = pt3D.x;			lPt->v = pt3D.y;			}		localOutline->Unuse();		outline->Unuse();		polyPosn->dPosition();sdPosn->dPosition();		surfDefObject->SetDirty(state); 		}			for(k = 0; k < 3; k++)		{		if(features[k])			{			pFeat = (CAVSurfFeature	**)features[k]->Use();			length = features[k]->ALength();			for(i = 0; i < length; i++,pFeat++)				(*pFeat)->SetDirty(state);			features[k]->Unuse();			}		}	}void CAVSurfDef::Display()  	{ 	CAVSurfFeature	**pFeat;	int		i,k,length;	surfDefObject->Display(FALSE);	for(k = 0; k < 3; k++)		{		if(features[k])			{			length = features[k]->ALength();			pFeat = (CAVSurfFeature	**)features[k]->Use();			for(i = 0; i < length; i++,pFeat++)				(*pFeat)->Display();			features[k]->Unuse();			}		} 	}	void CAVSurfDef::ResetEditState(int state, int walkState)  	{ 	CAVSurfFeature	**pFeat;	int		i,k,length,current;		for(k = 0; k < 3; k++)		{		if(features[k])			{			length = features[k]->ALength();			pFeat = (CAVSurfFeature	**)features[k]->Use();			for(i = 0; i < length; i++,pFeat++)				{				if(walkState)/* WALK HIDDEN */					(*pFeat)->SetHidden(FALSE);				else					{					current = (*pFeat)->GetEditState();					current &= ~state;					(*pFeat)->SetEditState(current);					}				}			features[k]->Unuse();			}		}	}int CAVSurfDef::GetSide(SurfFeature *pFeat)  	{ 	int		k;			for(k = 0; k < 3; k++)		{		if(features[k])			if(0 <= features[k]->Find(&pFeat)) 				break;			}	if(k>2)k = -1;	return(k);	}void CAVSurfDef::SetSide(SurfFeature *pFeat,int newSide)  	{ 	RemoveFeature(pFeat,GetSide(pFeat));	InstallFeature(pFeat,newSide);	}int CAVSurfDef::GetOrder(SurfFeature *pFeat)  	{ return(features[GetSide(pFeat)]->Find(&pFeat)); }void CAVSurfDef::SetOrder(SurfFeature *pFeat,int offset)  	{ MoveFeature(pFeat,offset,GetSide(pFeat)); }CAVSurfDef *CAVSurfDef::Find(Point *p,long modifiers,int detailed,int findMode) 	{	if(OUT_POLY != surfDefObject->Find(p,modifiers,detailed))		return(this);	else		return(NULL);	}CAVSurfFeature *CAVSurfDef::FindFeature(Point *p,PointFFixed *wPt,long modifiers,int detailed,int findMode) 	{	CAVSurfFeature	*result,**pFeat;	int		i,length,side;		result = NULL;	side = surfDefObject->environment->GetSide();		if(features[side])		{		length = features[side]->ALength();		pFeat = (CAVSurfFeature	**)features[side]->Use();		for(i = length-1; i>=0; i--)			{			if(OUT_POLY != pFeat[i]->Find(p,wPt,modifiers,detailed,findMode))				{				result = pFeat[i];				break;				}			}		features[side]->Unuse();		}		if(!result && features[SURF_SHARED])		{		length = features[SURF_SHARED]->ALength();		pFeat = (CAVSurfFeature	**)features[SURF_SHARED]->Use();		for(i = length-1; i>=0; i--)			{			if(OUT_POLY != pFeat[i]->Find(p,wPt,modifiers,detailed,findMode))				{				result = pFeat[i];				break;				}			}		features[SURF_SHARED]->Unuse();		}	return(result);	}#if VRML_ANCHOR	// ABD PRO25 AUG95CAVSurfFeature *CAVSurfDef::FindFeatureNoSideEffects(Point *p,PointFFixed *wPt,long modifiers,int detailed,int findMode) 	{	CAVSurfFeature	*result,**pFeat;	int		i,length,side;		result = NULL;	side = surfDefObject->environment->GetSide();		if(features[side])		{		length = features[side]->ALength();		pFeat = (CAVSurfFeature	**)features[side]->Use();		for(i = length-1; i>=0; i--)			{			if(OUT_POLY != pFeat[i]->FindNoSideEffects(p,wPt,modifiers,detailed,findMode))				{				result = pFeat[i];				break;				}			}		features[side]->Unuse();		}		if(!result && features[SURF_SHARED])		{		length = features[SURF_SHARED]->ALength();		pFeat = (CAVSurfFeature	**)features[SURF_SHARED]->Use();		for(i = length-1; i>=0; i--)			{			if(OUT_POLY != pFeat[i]->FindNoSideEffects(p,wPt,modifiers,detailed,findMode))				{				result = pFeat[i];				break;				}			}		features[SURF_SHARED]->Unuse();		}	return(result);	}#endif // VRML_ANCHORvoid CAVSurfDef::Extrema(PointFFixed *ptMin,PointFFixed *ptMax) 	{	Position	*tPosn;	PointFFixed	*wp,pt;	int			i,length;	tPosn = new(Position);	tPosn->cPosition();	tPosn->SetScale2D(polyhedron->posn->GetScale2D());	tPosn->SetShear2D(polyhedron->posn->GetShear2D());	*ptMin = PtFFMax;	*ptMax = PtFFMin;		length = outline->ALength();	wp = (PointFFixed*)outline->Use();	for(i = 0; i < length; i++,wp++)		{		pt = tPosn->Transform2D(*wp);		FFMin(ptMin->h,ptMin->h,pt.h);		FFMin(ptMin->v,ptMin->v,pt.v);		FFMax(ptMax->h,ptMax->h,pt.h);		FFMax(ptMax->v,ptMax->v,pt.v);		}	outline->Unuse();	tPosn->dPosition();	}	void CAVSurfDef::ModelSize(Rect *r) 	{	CAVSurfFeature	**pFeat;	PointFFixed	*wp,tMin,tMax,eMin,eMax;	int			i,k,length;	V_Array		*fList;		Extrema(&tMin,&tMax);		for(k = 0; k < 3; k++)		{		if(features[k])			{			length = features[k]->ALength();			pFeat = (CAVSurfFeature	**)features[k]->Use();			for(i = 0; i < length; i++,pFeat++)				{				(*pFeat)->Extrema(&eMin,&eMax);				FFMin(tMin.h,tMin.h,eMin.h);				FFMax(tMax.h,tMax.h,eMax.h);				FFMin(tMin.v,tMin.v,eMin.v);				FFMax(tMax.v,tMax.v,eMax.v);				}			features[k]->Unuse();			}		}						r->top = tMax.v.intg;	r->left = tMin.h.intg;	r->bottom = tMin.v.intg;	r->right = tMax.h.intg;/*	if(VIEW_INSIDE == direction)		{		tmp = r->left;		r->left  = -r->right;		r->right = tmp;		}*/	}void CAVSurfDef::SelectAll(V_Array **selectList)  	{ 	CAVSurfFeature	**pFeat;	int		i,k,length,selSide;	selSide = surfDefObject->environment->GetSide();	if(features[SURF_SHARED] && (length = features[SURF_SHARED]->ALength()))		{		pFeat = (CAVSurfFeature	**)features[SURF_SHARED]->Use();		for(i = 0; i < length; i++,pFeat++) 			{			if(!(*pFeat)->GetEditState())				{				(*pFeat)->SetMode(IN_POLY);				(*selectList)->Append(&(*pFeat));				}			}		features[SURF_SHARED]->Unuse();			}	if(features[selSide] && (length = features[selSide]->ALength()))		{		pFeat = (CAVSurfFeature	**)features[selSide]->Use();		for(i = 0; i < length; i++,pFeat++) 			{			if(!(*pFeat)->GetEditState())				{				(*pFeat)->SetMode(IN_POLY);				(*selectList)->Append(&(*pFeat));				}			}		features[selSide]->Unuse();			}	}int CAVSurfDef::SelectRect(V_Array **selectList,Rect *r,int findMode)  	{ 	CAVSurfFeature	**pFeat;	Point	featureMin,featureMax;	int		i,k,length,selSide,inRect,editState,rejectFlag;	selSide = surfDefObject->environment->GetSide();		inRect = surfDefObject->SelectRect(r);		if(features[SURF_SHARED] && (length = features[SURF_SHARED]->ALength()))		{		pFeat = (CAVSurfFeature	**)features[SURF_SHARED]->Use();		for(i = 0; i < length; i++,pFeat++) 			if((*pFeat)->SelectRect(r,findMode))				{				(*pFeat)->SetMode(IN_POLY);				(*selectList)->Append(&(*pFeat));				}		features[SURF_SHARED]->Unuse();			}	if(features[selSide] && (length = features[selSide]->ALength()))		{		pFeat = (CAVSurfFeature	**)features[selSide]->Use();		for(i = 0; i < length; i++,pFeat++) 			if((*pFeat)->SelectRect(r,findMode))				{				(*pFeat)->SetMode(IN_POLY);				(*selectList)->Append(&(*pFeat));				}		features[selSide]->Unuse();			}		return(inRect);	}intCAVSurfDef::Export(ModelExport *export)	{	Point3DFFixed norm = Pt3DFFZero;	int nConn, nFeatures, i, side, cn, where;	Connection *conn;	CAVSurfFeature **feat;	norm.x.intg = surface->posnNormal.x;	norm.y.intg = surface->posnNormal.y;	norm.z.intg = surface->posnNormal.z;// DAS VRML 95.06.01 BEGIN add transparent/translucent connected surfaces to surface feature list	#if VRML_ANCHOR	for (side = 0; side < 2; side++)		{		V_Array *connArray;		if ((connArray = flatConnections[side]) != NULL)			{			RGBAColor clr;			RGBColor c;			unsigned short o;						nConn = connArray->ALength();			conn = (Connection *)connArray->Use();				for (cn = 0; cn < nConn; cn++, conn++)				{				if (conn->surf != NULL)					{					c = conn->surf->GetColor(SURF_OUTSIDE);					o = conn->surf->GetOpacity();					}				else					{					c = conn->surf->polyhedron->GetColor(SURF_OUTSIDE);					o = conn->surf->polyhedron->GetOpacity();					}				if(o<=OPAQUE_THRESH)					{					V_Array *surfPoints;					clr.red = c.red;					clr.green = c.green;					clr.blue = c.blue;					clr.alpha = o;										surfPoints = new(V_Array);					surfPoints->cArray(0, sizeof(Point3DFFixed), 4);					export->DerefPoints(conn->surf->polyhedron->posnPoints, 							conn->surf->surface->points, surfPoints);					export->OpenFeature(surfPoints, clr, SURF_SHARED, side+1); // DAS VRML 95.06.03 added side+1					surfPoints->dArray();					}				}				connArray->Unuse();			}		}    #endif // VRML_ANCHOR// DAS VRML 95.06.01 END add transparent/translucent connected surfaces to surface feature list	for (where = 0; where < 3; where++)		{		V_Array *featArray;		if ((featArray = features[where]) != NULL)			{			V_Array *loop = featArray;			ExportArray *sort = NULL;			if (export->SortFeatures())				{				sort = new(ExportArray);				sort->cArray(0, sizeof(SurfFeature *), 4);				sort->SetExport(export);				sort->SetObject(expFeature);				loop->CopyArray(sort);					sort->QuickSort();				loop = sort;				}			nFeatures = loop->ALength();			feat = (CAVSurfFeature	**)loop->Use();            #if !VRML_ANCHOR			for (i = 0; i < nFeatures; i++)				(*feat++)->Export(export, where, FALSE);            #else			for (i = 0; i < nFeatures; i++)				(*feat++)->Export(export, where, side+1); // DAS VRML 95.06.03 added side+1			#endif // VRML_ANCHOR			loop->Unuse();			if (sort != NULL) sort->dArray();			}		}	for (side = 0; side < 2; side++)		{		V_Array *connArray;		if ((connArray = flatConnections[side]) != NULL)			{			nConn = connArray->ALength();			conn = (Connection *)connArray->Use();				for (cn = 0; cn < nConn; cn++, conn++)				{				for (where = 0; where < 3; where++)					{					V_Array *featArray;					if ((featArray = conn->surf->features[where]) != NULL)						{						V_Array *loop = featArray;						ExportArray *sort = NULL;									if (export->SortFeatures())							{							sort = new(ExportArray);							sort->cArray(0, sizeof(SurfFeature *), 4);							sort->SetExport(export);							sort->SetObject(expFeature);							loop->CopyArray(sort);											sort->QuickSort();							loop = sort;							}						nFeatures = featArray->ALength();						feat = (CAVSurfFeature **)featArray->Use();									for (i = 0; i < nFeatures; i++)							(*feat++)->Export(export, where, TRUE);						featArray->Unuse();						if (sort != NULL) sort->dArray();						}					}				}				connArray->Unuse();			}		}	}